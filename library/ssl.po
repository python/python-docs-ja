# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-09-24 09:17+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: tomoğŸ§, 2017\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/ssl.rst:2
msgid ":mod:`ssl` --- TLS/SSL wrapper for socket objects"
msgstr ":mod:`ssl` --- ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹ TLS/SSL ãƒ©ãƒƒãƒ‘ãƒ¼"

#: ../../library/ssl.rst:10
msgid "**Source code:** :source:`Lib/ssl.py`"
msgstr "**Source code:** :source:`Lib/ssl.py`"

#: ../../library/ssl.rst:18
msgid ""
"This module provides access to Transport Layer Security (often known as "
"\"Secure Sockets Layer\") encryption and peer authentication facilities for "
"network sockets, both client-side and server-side.  This module uses the "
"OpenSSL library. It is available on all modern Unix systems, Windows, Mac OS"
" X, and probably additional platforms, as long as OpenSSL is installed on "
"that platform."
msgstr ""
"ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ Transport Layer Security ( \"Secure Sockets Layer\" "
"ã¨ã„ã†åå‰ã§ã‚ˆãçŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™) "
"æš—å·åŒ–ã¨ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã€ã‚µãƒ¼ãƒã‚µã‚¤ãƒ‰ä¸¡æ–¹ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚½ã‚±ãƒƒãƒˆã®ãŸã‚ã®ãƒ”ã‚¢èªè¨¼ã®ä»•çµ„ã¿ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ OpenSSL "
"ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’åˆ©ç”¨ã—ã¦ã„ã¾ã™ã€‚ OpenSSL ã¯ã€ã™ã¹ã¦ã®ãƒ¢ãƒ€ãƒ³ãª Unix ã‚·ã‚¹ãƒ†ãƒ ã€ Windows ã€ Mac OS X ã€ãã®ä»–å¹¾ã¤ã‹ã® "
"OpenSSL ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§åˆ©ç”¨ã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:26
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs.  The installed version of OpenSSL may also "
"cause variations in behavior. For example, TLSv1.1 and TLSv1.2 come with "
"openssl version 1.0.1."
msgstr ""
"OSã®ã‚½ã‚±ãƒƒãƒˆAPIã«å¯¾ã—ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€å¹¾ã¤ã‹ã®æŒ™å‹•ã¯ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ä¾å­˜ã«ãªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹OpenSSLã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®é•ã„ã‚‚æŒ™å‹•ã®é•ã„ã®åŸå› ã«ãªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€TLSv1.1,"
" TLSv1.2 ã¯ openssl version 1.0.1 ä»¥é™ã§ã®ã¿åˆ©ç”¨ã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:32
msgid ""
"Don't use this module without reading the :ref:`ssl-security`.  Doing so may"
" lead to a false sense of security, as the default settings of the ssl "
"module are not necessarily appropriate for your application."
msgstr ""
":ref:`ssl-security` ã‚’èª­ã¾ãšã«ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã—ãªã„ã§ãã ã•ã„ã€‚SSL "
"ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã¯ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ååˆ†ã§ã¯ãªã„ã®ã§ã€èª­ã¾ãªã„å ´åˆã¯ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã«èª¤ã£ãŸæ„è­˜ã‚’æŒã£ã¦ã—ã¾ã†ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:37
msgid ""
"This section documents the objects and functions in the ``ssl`` module; for "
"more general information about TLS, SSL, and certificates, the reader is "
"referred to the documents in the \"See Also\" section at the bottom."
msgstr ""
"ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€ ``ssl`` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨é–¢æ•°ã‚’è§£èª¬ã—ã¾ã™ã€‚ TLS, SSL, è¨¼æ˜æ›¸ã«é–¢ã™ã‚‹ã‚ˆã‚Šä¸€èˆ¬çš„ãªæƒ…å ±ã¯ã€æœ«å°¾ã«ã‚ã‚‹ "
"\"See Also\" ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:41
msgid ""
"This module provides a class, :class:`ssl.SSLSocket`, which is derived from "
"the :class:`socket.socket` type, and provides a socket-like wrapper that "
"also encrypts and decrypts the data going over the socket with SSL.  It "
"supports additional methods such as :meth:`getpeercert`, which retrieves the"
" certificate of the other side of the connection, and :meth:`cipher`,which "
"retrieves the cipher being used for the secure connection."
msgstr ""
"ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ :class:`ssl.SSLSocket` ã‚¯ãƒ©ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚ã“ã®ã‚¯ãƒ©ã‚¹ã¯ :class:`socket.socket` "
"ã‚¯ãƒ©ã‚¹ã‚’ç¶™æ‰¿ã—ã¦ã„ã¦ã€ã‚½ã‚±ãƒƒãƒˆã§é€šä¿¡ã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’SSLã§æš—å·åŒ–ãƒ»å¾©å·ã™ã‚‹ã‚½ã‚±ãƒƒãƒˆã«ä¼¼ãŸãƒ©ãƒƒãƒ‘ãƒ¼ã«ãªã‚Šã¾ã™ã€‚ã¾ãŸã€ã“ã®ã‚¯ãƒ©ã‚¹ã¯ã€æ¥ç¶šã®ç›¸æ‰‹å´ã‹ã‚‰ã®è¨¼æ˜æ›¸ã‚’å–å¾—ã™ã‚‹"
" :meth:`getpeercert` ãƒ¡ã‚½ãƒƒãƒ‰ã‚„ã€ã‚»ã‚­ãƒ¥ã‚¢æ¥ç¶šã§ä½¿ã†ãŸã‚ã®æš—å·æ–¹å¼ã‚’å–å¾—ã™ã‚‹ :meth:`cipher` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚ˆã†ãªè¿½åŠ ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/ssl.rst:48
msgid ""
"For more sophisticated applications, the :class:`ssl.SSLContext` class helps"
" manage settings and certificates, which can then be inherited by SSL "
"sockets created through the :meth:`SSLContext.wrap_socket` method."
msgstr ""
"ã‚ˆã‚Šæ´—ç·´ã•ã‚ŒãŸã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãŸã‚ã«ã€ :class:`ssl.SSLContext` ã‚¯ãƒ©ã‚¹ãŒè¨­å®šã¨è¨¼æ˜æ›¸ã®ç®¡ç†ã®åŠ©ã‘ã¨ãªã‚‹ã§ã—ã‚‡ã†ã€‚ãã‚Œã¯ "
":meth:`SSLContext.wrap_socket` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’é€šã—ã¦ SSL ã‚½ã‚±ãƒƒãƒˆã‚’ä½œæˆã™ã‚‹ã“ã¨ã§å¼•ãç¶™ãŒã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:52
msgid "Updated to support linking with OpenSSL 1.1.0"
msgstr ""

#: ../../library/ssl.rst:57
msgid ""
"OpenSSL 0.9.8, 1.0.0 and 1.0.1 are deprecated and no longer supported. In "
"the future the ssl module will require at least OpenSSL 1.0.2 or 1.1.0."
msgstr ""
"OpenSSL 0.9.8, 1.0.0, 1.0.1 ã¯å»ƒæ­¢ã•ã‚Œã¦ãŠã‚Šã€ã‚‚ã¯ã‚„ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ssl ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€å°†æ¥çš„ã« OpenSSL "
"1.0.2 ã¾ãŸã¯ 1.1.0 ã‚’å¿…è¦ã¨ã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/ssl.rst:63
msgid "Functions, Constants, and Exceptions"
msgstr "é–¢æ•°ã€å®šæ•°ã€ä¾‹å¤–"

#: ../../library/ssl.rst:67
msgid "Socket creation"
msgstr "ã‚½ã‚±ãƒƒãƒˆã®ä½œæˆ"

#: ../../library/ssl.rst:69
msgid ""
"Since Python 3.2 and 2.7.9, it is recommended to use the "
":meth:`SSLContext.wrap_socket` of an :class:`SSLContext` instance to wrap "
"sockets as :class:`SSLSocket` objects. The helper functions "
":func:`create_default_context` returns a new context with secure default "
"settings. The old :func:`wrap_socket` function is deprecated since it is "
"both inefficient and has no support for server name indication (SNI) and "
"hostname matching."
msgstr ""

#: ../../library/ssl.rst:77
msgid "Client socket example with default context and IPv4/IPv6 dual stack::"
msgstr ""

#: ../../library/ssl.rst:90
msgid "Client socket example with custom context and IPv4::"
msgstr ""

#: ../../library/ssl.rst:102
msgid "Server socket example listening on localhost IPv4::"
msgstr ""

#: ../../library/ssl.rst:116
msgid "Context creation"
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ä½œæˆ"

#: ../../library/ssl.rst:118
msgid ""
"A convenience function helps create :class:`SSLContext` objects for common "
"purposes."
msgstr "ã‚³ãƒ³ãƒ“ãƒ‹ã‚¨ãƒ³ã‚¹é–¢æ•°ãŒã€å…±é€šã®ç›®çš„ã§ä½¿ç”¨ã•ã‚Œã‚‹ :class:`SSLContext` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ã®ã«å½¹ç«‹ã¡ã¾ã™ã€‚"

#: ../../library/ssl.rst:123
msgid ""
"Return a new :class:`SSLContext` object with default settings for the given "
"*purpose*.  The settings are chosen by the :mod:`ssl` module, and usually "
"represent a higher security level than when calling the :class:`SSLContext` "
"constructor directly."
msgstr ""
"æ–°è¦ã® :class:`SSLContext` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã€ä¸ãˆã‚‰ã‚ŒãŸ *purpose* ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã§è¿”ã—ã¾ã™ã€‚è¨­å®šã¯ :mod:`ssl`"
" ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§é¸æŠã•ã‚Œã€é€šå¸¸ã¯ :class:`SSLContext` ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ç›´æ¥å‘¼ã³å‡ºã™ã‚ˆã‚Šã‚‚é«˜ã„ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒ™ãƒ«ã‚’è¡¨ç¾ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:128
msgid ""
"*cafile*, *capath*, *cadata* represent optional CA certificates to trust for"
" certificate verification, as in :meth:`SSLContext.load_verify_locations`.  "
"If all three are :const:`None`, this function can choose to trust the "
"system's default CA certificates instead."
msgstr ""
"*cafile*, *capath*, *cadata* ã¯è¨¼æ˜æ›¸ã®æ¤œè¨¼ã§ä¿¡ç”¨ã™ã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® CA è¨¼æ˜æ›¸ã§ã€ "
":meth:`SSLContext.load_verify_locations` ã®ã‚‚ã®ã¨åŒã˜ã§ã™ã€‚ã“ã‚Œã‚‰ 3 ã¤ã™ã¹ã¦ãŒ :const:`None` "
"ã§ã‚ã‚Œã°ã€ã“ã®é–¢æ•°ã¯ä»£ã‚ã‚Šã«ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® CA è¨¼æ˜æ›¸ã‚’ä¿¡ç”¨ã—ã¦é¸æŠã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:134
msgid ""
"The settings are: :data:`PROTOCOL_TLS`, :data:`OP_NO_SSLv2`, and "
":data:`OP_NO_SSLv3` with high encryption cipher suites without RC4 and "
"without unauthenticated cipher suites. Passing :data:`~Purpose.SERVER_AUTH` "
"as *purpose* sets :data:`~SSLContext.verify_mode` to :data:`CERT_REQUIRED` "
"and either loads CA certificates (when at least one of *cafile*, *capath* or"
" *cadata* is given) or uses :meth:`SSLContext.load_default_certs` to load "
"default CA certificates."
msgstr ""
"è¨­å®šã¯ã€ :data:`PROTOCOL_TLS`, :data:`OP_NO_SSLv2`, RC4 "
"ã¨éèªè¨¼æš—å·åŒ–ã‚¹ã‚¤ãƒ¼ãƒˆä»¥å¤–ã®ã€é«˜åº¦æš—å·åŒ–ã‚¹ã‚¤ãƒ¼ãƒˆã‚’åˆ©ç”¨ã—ãŸ :data:`OP_NO_SSLv3` "
"ã§ã™ã€‚:data:`~Purpose.SERVER_AUTH` ã‚’ *purpose* "
"ã¨ã—ã¦æ¸¡ã™ã¨ã€:data:`~SSLContext.verify_mode` ã‚’ :data:`CERT_REQUIRED` ã«è¨­å®šã—ã€ CA "
"è¨¼æ˜æ›¸ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ (*cafile*, *capath*, *cadata* ã®å°‘ãªãã¨ã‚‚1ã¤ãŒä¸ãˆã‚‰ã‚Œã¦ã„ã‚‹å ´åˆ) "
"ã‹ã€:meth:`SSLContext.load_default_certs` ã‚’ä½¿ç”¨ã—ã¦ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® CA è¨¼æ˜æ›¸ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:143
msgid ""
"The protocol, options, cipher and other settings may change to more "
"restrictive values anytime without prior deprecation.  The values represent "
"a fair balance between compatibility and security."
msgstr ""
"ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã€æš—å·æ–¹å¼ãã®ä»–ã®è¨­å®šã¯ã€äº‹å‰ã«éæ¨å¥¨ã®çŠ¶æ…‹ã«ã™ã‚‹ã“ã¨ãªãã€ã‚‚ã£ã¨åˆ¶é™ã®å¼·ã„å€¤ã«å¤‰æ›´ã•ã‚Œã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã®å€¤ã¯ã€äº’æ›æ€§ã¨å®‰å…¨æ€§ã¨ã®å¦¥å½“ãªãƒãƒ©ãƒ³ã‚¹ã‚’ã¨ã£ã¦æ±ºã‚ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:147
msgid ""
"If your application needs specific settings, you should create a "
":class:`SSLContext` and apply the settings yourself."
msgstr ""
"ã‚‚ã—ã‚‚ã‚ãªãŸã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒç‰¹å®šã®è¨­å®šã‚’å¿…è¦ã¨ã™ã‚‹å ´åˆã€ :class:`SSLContext` ã‚’ä½œã£ã¦è‡ªåˆ†è‡ªèº«ã§è¨­å®šã‚’é©ç”¨ã™ã¹ãã§ã™ã€‚"

#: ../../library/ssl.rst:151
msgid ""
"If you find that when certain older clients or servers attempt to connect "
"with a :class:`SSLContext` created by this function that they get an error "
"stating \"Protocol or cipher suite mismatch\", it may be that they only "
"support SSL3.0 which this function excludes using the :data:`OP_NO_SSLv3`. "
"SSL3.0 is widely considered to be `completely broken "
"<https://en.wikipedia.org/wiki/POODLE>`_. If you still wish to continue to "
"use this function but still allow SSL 3.0 connections you can re-enable them"
" using::"
msgstr ""
"ã‚ã‚‹ç¨®ã®å¤ã„ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚„ã‚µãƒ¼ãƒãŒæ¥ç¶šã—ã‚ˆã†ã¨è©¦ã¿ã¦ããŸå ´åˆã«ã€ã“ã®é–¢æ•°ã§ä½œã‚‰ã‚ŒãŸ :class:`SSLContext` ãŒ \"Protocol "
"or cipher suite mismatch\" ã§å§‹ã¾ã‚‹ã‚¨ãƒ©ãƒ¼ã‚’èµ·ã“ã™ã®ã‚’ç›®æ’ƒã—ãŸã‚‰ãã‚Œã¯ã€ã“ã®é–¢æ•°ãŒ :data:`OP_NO_SSLv3` "
"ã‚’ä½¿ã£ã¦é™¤å¤–ã—ã¦ã„ã‚‹ SSL 3.0 ã—ã‹ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„ã®ã§ã—ã‚‡ã†ã€‚SSL 3.0 ã¯ `å®Œç’§ã«ã¶ã£å£Šã‚Œã¦ã„ã‚‹ "
"<https://en.wikipedia.org/wiki/POODLE>`_ ã“ã¨ãŒåºƒãçŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚ãã‚Œã§ã‚‚ã¾ã ã“ã®é–¢æ•°ã‚’ä½¿ã£ã¦ã€ãŸã ã— SSL"
" 3.0 æ¥ç¶šã‚’è¨±å¯ã—ãŸã„ã¨æœ›ã‚€ãªã‚‰ã°ã€ã“ã‚Œã‚’ã“ã®ã‚ˆã†ã«å†æœ‰åŠ¹åŒ–ã§ãã¾ã™::"

#: ../../library/ssl.rst:167
msgid "RC4 was dropped from the default cipher string."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æš—å·è¨­å®šã‹ã‚‰ RC4 ãŒé™¤ã‹ã‚Œã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:171
msgid "ChaCha20/Poly1305 was added to the default cipher string."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æš—å·åŒ–æ–‡å­—åˆ—ã« ChaCha20/Poly1305 ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:173
msgid "3DES was dropped from the default cipher string."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æš—å·åŒ–æ–‡å­—åˆ—ã‹ã‚‰ 3DES ãŒé™¤ã‹ã‚Œã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:177
msgid "Exceptions"
msgstr "ä¾‹å¤–"

#: ../../library/ssl.rst:181
msgid ""
"Raised to signal an error from the underlying SSL implementation (currently "
"provided by the OpenSSL library).  This signifies some problem in the "
"higher-level encryption and authentication layer that's superimposed on the "
"underlying network connection.  This error is a subtype of :exc:`OSError`.  "
"The error code and message of :exc:`SSLError` instances are provided by the "
"OpenSSL library."
msgstr ""
"(ç¾åœ¨ã®ã¨ã“ã‚ OpenSSL ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã‚ˆã£ã¦æä¾›ã•ã‚Œã¦ã„ã‚‹)ä¸‹å±¤ã® SSL "
"å®Ÿè£…ã‹ã‚‰ã®ã‚¨ãƒ©ãƒ¼ã‚’ä¼ãˆã‚‹ãŸã‚ã®ä¾‹å¤–ã§ã™ã€‚ã“ã®ã‚¨ãƒ©ãƒ¼ã¯ã€ä½ãƒ¬ãƒ™ãƒ«ãªãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®ä¸Šã«è¼‰ã£ã¦ã„ã‚‹ã€é«˜ãƒ¬ãƒ™ãƒ«ãªæš—å·åŒ–ã¨èªè¨¼ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§ã®å•é¡Œã‚’é€šçŸ¥ã—ã¾ã™ã€‚ã“ã®ã‚¨ãƒ©ãƒ¼ã¯"
" :exc:`OSError` ã®ã‚µãƒ–ã‚¿ã‚¤ãƒ—ã§ã™ã€‚ :exc:`SSLError` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ OpenSSL "
"ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã‚ˆã‚‹ã‚‚ã®ã§ã™ã€‚"

#: ../../library/ssl.rst:188
msgid ":exc:`SSLError` used to be a subtype of :exc:`socket.error`."
msgstr ":exc:`SSLError` ã¯ä»¥å‰ã¯ :exc:`socket.error` ã®ã‚µãƒ–ã‚¿ã‚¤ãƒ—ã§ã—ãŸã€‚"

#: ../../library/ssl.rst:193
msgid ""
"A string mnemonic designating the OpenSSL submodule in which the error "
"occurred, such as ``SSL``, ``PEM`` or ``X509``.  The range of possible "
"values depends on the OpenSSL version."
msgstr ""
"ã‚¨ãƒ©ãƒ¼ãŒèµ·ã“ã£ãŸ OpenSSL ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç¤ºã™ãƒ‹ãƒ¼ãƒ¢ãƒ‹ãƒƒã‚¯æ–‡å­—åˆ—ã§ã€ ``SSL``, ``PEM``, ``X509`` "
"ãªã©ã§ã™ã€‚å–ã‚Šå¾—ã‚‹å€¤ã¯ OpenSSL ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ä¾å­˜ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:201
msgid ""
"A string mnemonic designating the reason this error occurred, for example "
"``CERTIFICATE_VERIFY_FAILED``.  The range of possible values depends on the "
"OpenSSL version."
msgstr ""
"ã‚¨ãƒ©ãƒ¼ãŒèµ·ã“ã£ãŸåŸå› ã‚’ç¤ºã™ãƒ‹ãƒ¼ãƒ¢ãƒ‹ãƒƒã‚¯æ–‡å­—åˆ—ã§ã€ ``CERTIFICATE_VERIFY_FAILED`` ãªã©ã§ã™ã€‚å–ã‚Šå¾—ã‚‹å€¤ã¯ OpenSSL "
"ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ä¾å­˜ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:209
msgid ""
"A subclass of :exc:`SSLError` raised when trying to read or write and the "
"SSL connection has been closed cleanly.  Note that this doesn't mean that "
"the underlying transport (read TCP) has been closed."
msgstr ""
"èª­ã¿å‡ºã—ã‚ã‚‹ã„ã¯æ›¸ãè¾¼ã¿ã‚’è©¦ã¿ã‚ˆã†ã¨ã—ãŸéš›ã« SSL ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãŒè¡Œå„€ã‚ˆãé–‰ã˜ã‚‰ã‚Œã¦ã—ã¾ã£ãŸå ´åˆã«é€å‡ºã•ã‚Œã‚‹ :exc:`SSLError` "
"ã‚µãƒ–ã‚¯ãƒ©ã‚¹ä¾‹å¤–ã§ã™ã€‚ã“ã‚Œã¯ä¸‹å±¤ã®è»¢é€(read TCP)ãŒé–‰ã˜ãŸã“ã¨ã¯æ„å‘³ã—ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:217
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket "
"<ssl-nonblocking>` when trying to read or write data, but more data needs to"
" be received on the underlying TCP transport before the request can be "
"fulfilled."
msgstr ""
"èª­ã¿å‡ºã—ã‚ã‚‹ã„ã¯æ›¸ãè¾¼ã¿ã‚’è©¦ã¿ã‚ˆã†ã¨ã—ãŸéš›ã«ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒé‚è¡Œã•ã‚Œã‚‹å‰ã«ä¸‹å±¤ã® TCP è»¢é€ã§å—ã‘å–ã‚‹å¿…è¦ãŒã‚ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ãŸå ´åˆã« :ref"
":`non-blocking SSL socket <ssl-nonblocking>` ã«ã‚ˆã£ã¦é€å‡ºã•ã‚Œã‚‹ :exc:`SSLError` "
"ã‚µãƒ–ã‚¯ãƒ©ã‚¹ä¾‹å¤–ã§ã™ã€‚"

#: ../../library/ssl.rst:226
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket "
"<ssl-nonblocking>` when trying to read or write data, but more data needs to"
" be sent on the underlying TCP transport before the request can be "
"fulfilled."
msgstr ""
"èª­ã¿å‡ºã—ã‚ã‚‹ã„ã¯æ›¸ãè¾¼ã¿ã‚’è©¦ã¿ã‚ˆã†ã¨ã—ãŸéš›ã«ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒé‚è¡Œã•ã‚Œã‚‹å‰ã«ä¸‹å±¤ã® TCP è»¢é€ãŒé€ä¿¡ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ãŸå ´åˆã« :ref"
":`non-blocking SSL socket <ssl-nonblocking>` ã«ã‚ˆã£ã¦é€å‡ºã•ã‚Œã‚‹ :exc:`SSLError` "
"ã‚µãƒ–ã‚¯ãƒ©ã‚¹ä¾‹å¤–ã§ã™ã€‚"

#: ../../library/ssl.rst:235
msgid ""
"A subclass of :exc:`SSLError` raised when a system error was encountered "
"while trying to fulfill an operation on a SSL socket.  Unfortunately, there "
"is no easy way to inspect the original errno number."
msgstr ""
"SSL ã‚½ã‚±ãƒƒãƒˆä¸Šã§æ“ä½œã‚’é‚è¡Œã—ã‚ˆã†ã¨ã—ã¦ã„ã¦ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼ãŒèµ·ã“ã£ãŸå ´åˆã«é€å‡ºã•ã‚Œã‚‹ :exc:`SSLError` "
"ã‚µãƒ–ã‚¯ãƒ©ã‚¹ä¾‹å¤–ã§ã™ã€‚æ®‹å¿µãªãŒã‚‰å…ƒã¨ãªã£ãŸ errno ç•ªå·ã‚’èª¿ã¹ã‚‹ç°¡å˜ãªæ–¹æ³•ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:243
msgid ""
"A subclass of :exc:`SSLError` raised when the SSL connection has been "
"terminated abruptly.  Generally, you shouldn't try to reuse the underlying "
"transport when this error is encountered."
msgstr ""
"SSL ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãŒå”çªã«æ‰“ã¡åˆ‡ã‚‰ã‚ŒãŸéš›ã«é€å‡ºã•ã‚Œã‚‹ :exc:`SSLError` "
"ã‚µãƒ–ã‚¯ãƒ©ã‚¹ä¾‹å¤–ã§ã™ã€‚ä¸€èˆ¬çš„ã«ã€ã“ã®ã‚¨ãƒ©ãƒ¼ãŒèµ·ã“ã£ãŸã‚‰ä¸‹å±¤ã®è»¢é€ã‚’å†åˆ©ç”¨ã—ã‚ˆã†ã¨è©¦ã¿ã‚‹ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:251
msgid ""
"A subclass of :exc:`SSLError` raised when certificate validation has failed."
msgstr ""

#: ../../library/ssl.rst:258
msgid "A numeric error number that denotes the verification error."
msgstr ""

#: ../../library/ssl.rst:262
msgid "A human readable string of the verification error."
msgstr ""

#: ../../library/ssl.rst:266
msgid "An alias for :exc:`SSLCertVerificationError`."
msgstr ""

#: ../../library/ssl.rst:268
msgid "The exception is now an alias for :exc:`SSLCertVerificationError`."
msgstr ""

#: ../../library/ssl.rst:273
msgid "Random generation"
msgstr "ä¹±æ•°ç”Ÿæˆ"

#: ../../library/ssl.rst:277
msgid ""
"Return *num* cryptographically strong pseudo-random bytes. Raises an "
":class:`SSLError` if the PRNG has not been seeded with enough data or if the"
" operation is not supported by the current RAND method. :func:`RAND_status` "
"can be used to check the status of the PRNG and :func:`RAND_add` can be used"
" to seed the PRNG."
msgstr ""
"æš—å·å­¦çš„ã«å¼·å›ºãªæ“¬ä¼¼ä¹±æ•°ã® *num* ãƒã‚¤ãƒˆã‚’è¿”ã—ã¾ã™ã€‚æ“¬ä¼¼ä¹±æ•°ç”Ÿæˆå™¨ã«ååˆ†ãªãƒ‡ãƒ¼ã‚¿ã§ã‚·ãƒ¼ãƒ‰ãŒä¸ãˆã‚‰ã‚Œã¦ã„ãªã„å ´åˆã‚„ã€ç¾åœ¨ã® RANDOM ãƒ¡ã‚½ãƒƒãƒ‰ã«æ“ä½œãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„å ´åˆã¯ :class:`SSLError` ã‚’é€å‡ºã—ã¾ã™ã€‚ :func:`RAND_status` ã‚’ä½¿ã£ã¦æ“¬ä¼¼ä¹±æ•°ç”Ÿæˆå™¨ã®çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯ã§ãã¾ã™ã€‚\n"
":func:`RAND_add` ã‚’ä½¿ã£ã¦æ“¬ä¼¼ä¹±æ•°ç”Ÿæˆå™¨ã«ã‚·ãƒ¼ãƒ‰ã‚’ä¸ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:283 ../../library/ssl.rst:304
msgid "For almost all applications :func:`os.urandom` is preferable."
msgstr "ã»ã¨ã‚“ã©ã™ã¹ã¦ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ :func:`os.urandom` ãŒæœ›ã¾ã—ã„ã§ã™ã€‚"

#: ../../library/ssl.rst:285
msgid ""
"Read the Wikipedia article, `Cryptographically secure pseudorandom number "
"generator (CSPRNG) "
"<https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator>`_,"
" to get the requirements of a cryptographically generator."
msgstr ""
"æš—å·è«–çš„æ“¬ä¼¼ä¹±æ•°ç”Ÿæˆå™¨ã«è¦æ±‚ã•ã‚Œã‚‹ã“ã¨ã«ã¤ã„ã¦ã¯ Wikipedia ã®è¨˜äº‹ `Cryptographically secure "
"pseudorandom number generator (CSPRNG) "
"<https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator>`_"
" (æ—¥æœ¬èªç‰ˆ: `æš—å·è«–çš„æ“¬ä¼¼ä¹±æ•°ç”Ÿæˆå™¨ "
"<http://ja.wikipedia.org/wiki/%E6%9A%97%E5%8F%B7%E8%AB%96%E7%9A%84%E6%93%AC%E4%BC%BC%E4%B9%B1%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8>`_)"
" ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:294
msgid ""
"Return (bytes, is_cryptographic): bytes are *num* pseudo-random bytes, "
"is_cryptographic is ``True`` if the bytes generated are cryptographically "
"strong. Raises an :class:`SSLError` if the operation is not supported by the"
" current RAND method."
msgstr ""
"(bytes, is_cryptographic) ã‚¿ãƒ—ãƒ«ã‚’è¿”å´: bytes ã¯é•·ã• *num* ã®æ“¬ä¼¼ä¹±æ•°ãƒã‚¤ãƒˆåˆ—ã€ "
"is_cryptographic ã¯ã€ç”Ÿæˆã•ã‚ŒãŸãƒã‚¤ãƒˆåˆ—ãŒæš—å·ã¨ã—ã¦å¼·ã‘ã‚Œã° ``True`` ã€‚ æ“ä½œãŒç¾åœ¨ä½¿ã‚ã‚Œã¦ã„ã‚‹ RAND "
"ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã€  :class:`SSLError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:299
msgid ""
"Generated pseudo-random byte sequences will be unique if they are of "
"sufficient length, but are not necessarily unpredictable. They can be used "
"for non-cryptographic purposes and for certain purposes in cryptographic "
"protocols, but usually not for key generation etc."
msgstr ""
"ç”Ÿæˆã•ã‚Œã‚‹æ“¬ä¼¼ä¹±æ•°ãƒã‚¤ãƒˆã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ååˆ†ãªé•·ã•ã§ã‚ã‚Œã°ä¸€æ„ã«ã¯ãªã‚‹ã§ã—ã‚‡ã†ãŒã€å¿…ãšã—ã‚‚äºˆæ¸¬ä¸å¯èƒ½ã¨ã¯è¨€ãˆã¾ã›ã‚“ã€‚ã“ã‚Œã¯éæš—å·ç›®çš„ã€ã‚ã‚‹ã„ã¯æš—å·åŒ–ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã®è‹¥å¹²ã®ç”¨é€”ã«ä½¿ã‚ã‚Œã¾ã™ãŒã€æ™®é€šã¯éµç”Ÿæˆãªã©ã«ã¯ä½¿ã„ã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:310
msgid ""
"OpenSSL has deprecated :func:`ssl.RAND_pseudo_bytes`, use "
":func:`ssl.RAND_bytes` instead."
msgstr ""
"OpenSSL ã¯ :func:`ssl.RAND_pseudo_bytes` ã‚’å»ƒæ­¢ã—ã¾ã—ãŸã€‚ä»£ã‚ã‚Šã« :func:`ssl.RAND_bytes` "
"ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:315
msgid ""
"Return ``True`` if the SSL pseudo-random number generator has been seeded "
"with 'enough' randomness, and ``False`` otherwise.  You can use "
":func:`ssl.RAND_egd` and :func:`ssl.RAND_add` to increase the randomness of "
"the pseudo-random number generator."
msgstr ""
"SSL æ“¬ä¼¼ä¹±æ•°ç”Ÿæˆå™¨ãŒååˆ†ãªãƒ©ãƒ³ãƒ€ãƒ æ€§(randomness)ã‚’å—ã‘å–ã£ã¦ã„ã‚‹æ™‚ã« ``True`` ã‚’ã€ãã‚Œä»¥å¤–ã®å ´åˆã¯ `False` "
"ã‚’è¿”ã—ã¾ã™ã€‚ :func:`ssl.RAND_egd` ã¨ :func:`ssl.RAND_add` "
"ã‚’ä½¿ã£ã¦æ“¬ä¼¼ä¹±æ•°ç”Ÿæˆæ©Ÿã«ãƒ©ãƒ³ãƒ€ãƒ æ€§ã‚’åŠ ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:322
msgid ""
"If you are running an entropy-gathering daemon (EGD) somewhere, and *path* "
"is the pathname of a socket connection open to it, this will read 256 bytes "
"of randomness from the socket, and add it to the SSL pseudo-random number "
"generator to increase the security of generated secret keys.  This is "
"typically only necessary on systems without better sources of randomness."
msgstr ""
"ã‚‚ã—ã‚¨ãƒ³ãƒˆãƒ­ãƒ”ãƒ¼åé›†ãƒ‡ãƒ¼ãƒ¢ãƒ³(EGD=entropy-gathering daemon)ãŒå‹•ã„ã¦ã„ã¦ã€ *path* "
"ãŒEGDã¸ã®ã‚½ã‚±ãƒƒãƒˆã®ãƒ‘ã‚¹ã ã£ãŸå ´åˆã€ã“ã®é–¢æ•°ã¯ãã®ã‚½ã‚±ãƒƒãƒˆã‹ã‚‰ "
"256ãƒã‚¤ãƒˆã®ãƒ©ãƒ³ãƒ€ãƒ æ€§ã‚’èª­ã¿è¾¼ã¿ã€SSLæ“¬ä¼¼ä¹±æ•°ç”Ÿæˆå™¨ã«ãã‚Œã‚’æ¸¡ã™ã“ã¨ã§ã€ç”Ÿæˆã•ã‚Œã‚‹æš—å·éµã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’å‘ä¸Šã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã¯ã€ã‚ˆã‚Šè‰¯ã„ãƒ©ãƒ³ãƒ€ãƒ æ€§ã®ã‚½ãƒ¼ã‚¹ãŒç„¡ã„ã‚·ã‚¹ãƒ†ãƒ ã§ã®ã¿å¿…è¦ã§ã™ã€‚"

#: ../../library/ssl.rst:328
msgid ""
"See http://egd.sourceforge.net/ or http://prngd.sourceforge.net/ for sources"
" of entropy-gathering daemons."
msgstr ""
"ã‚¨ãƒ³ãƒˆãƒ­ãƒ”ãƒ¼åé›†ãƒ‡ãƒ¼ãƒ¢ãƒ³ã«ã¤ã„ã¦ã¯ã€ http://egd.sourceforge.net/ ã‚„ "
"http://prngd.sourceforge.net/ ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:331
msgid "Availability: not available with LibreSSL and OpenSSL > 1.1.0"
msgstr "åˆ©ç”¨å‡ºæ¥ã‚‹ç’°å¢ƒ: LibreSSL ãŠã‚ˆã³ 1.1.0 ã‚’è¶…ãˆã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® OpenSSL ã§ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:335
msgid ""
"Mix the given *bytes* into the SSL pseudo-random number generator.  The "
"parameter *entropy* (a float) is a lower bound on the entropy contained in "
"string (so you can always use :const:`0.0`).  See :rfc:`1750` for more "
"information on sources of entropy."
msgstr ""
"ä¸ãˆã‚‰ã‚ŒãŸ *bytes* ã‚’SSLæ“¬ä¼¼ä¹±æ•°ç”Ÿæˆå™¨ã«æ··ãœã¾ã™ã€‚ *entropy* "
"å¼•æ•°(floatå€¤)ã¯ã€ãã®æ–‡å­—åˆ—ã«å«ã¾ã‚Œã‚‹ã‚¨ãƒ³ãƒˆãƒ­ãƒ”ãƒ¼ã®ä¸‹é™(lower bound)ã§ã™ã€‚ (ãªã®ã§ã€ã„ã¤ã§ã‚‚ :const:`0.0` "
"ã‚’ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚) ã‚¨ãƒ³ãƒˆãƒ­ãƒ”ãƒ¼ã®ã‚½ãƒ¼ã‚¹ã«ã¤ã„ã¦ã®ã‚ˆã‚Šè©³ã—ã„æƒ…å ±ã¯ã€ :rfc:`1750` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:340
msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "æ›¸ãè¾¼ã¿å¯èƒ½ãª :term:`bytes-like object` ã‚’ä½¿ç”¨ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:344
msgid "Certificate handling"
msgstr "è¨¼æ˜æ›¸ã®å–ã‚Šæ‰±ã„"

#: ../../library/ssl.rst:352
msgid ""
"Verify that *cert* (in decoded format as returned by "
":meth:`SSLSocket.getpeercert`) matches the given *hostname*.  The rules "
"applied are those for checking the identity of HTTPS servers as outlined in "
":rfc:`2818`, :rfc:`5280` and :rfc:`6125`.  In addition to HTTPS, this "
"function should be suitable for checking the identity of servers in various "
"SSL-based protocols such as FTPS, IMAPS, POPS and others."
msgstr ""

#: ../../library/ssl.rst:359
msgid ""
":exc:`CertificateError` is raised on failure. On success, the function "
"returns nothing::"
msgstr "å¤±æ•—ã™ã‚Œã° :exc:`CertificateError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚æˆåŠŸã™ã‚Œã°ã€ã“ã®é–¢æ•°ã¯ä½•ã‚‚è¿”ã—ã¾ã›ã‚“::"

#: ../../library/ssl.rst:372
msgid ""
"The function now follows :rfc:`6125`, section 6.4.3 and does neither match "
"multiple wildcards (e.g. ``*.*.com`` or ``*a*.example.org``) nor a wildcard "
"inside an internationalized domain names (IDN) fragment. IDN A-labels such "
"as ``www*.xn--pthon-kva.org`` are still supported, but ``x*.python.org`` no "
"longer matches ``xn--tda.python.org``."
msgstr ""
"ã“ã®é–¢æ•°ã¯ :rfc:`6125` ã® section 6.4.3 ã«å¾“ã†ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã®ã§ã€ãƒãƒ«ãƒãƒ—ãƒ«ãƒ¯ã‚¤ãƒ«ãƒ‰ã‚«ãƒ¼ãƒ‰(ä¾‹. ``*.*.com`` "
"ã‚„ ``*a*.example.org``) ã«ã‚‚å›½éš›åŒ–ãƒ‰ãƒ¡ã‚¤ãƒ³å (IDN=internationalized domain "
"name)ãƒ•ãƒ©ã‚°ãƒ¡ãƒ³ãƒˆå†…éƒ¨ã«å«ã¾ã‚Œã‚‹ãƒ¯ã‚¤ãƒ«ãƒ‰ã‚«ãƒ¼ãƒ‰ã®ã©ã¡ã‚‰ã«ã‚‚åˆè‡´ã—ã¾ã›ã‚“ã€‚ ``www*.xn--pthon-kva.org`` ã®ã‚ˆã†ãª IDN "
"A-labels ã¯ã¾ã ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ãŒã€ ``x*.python.org`` ã¯ã‚‚ã¯ã‚„ ``xn--tda.python.org`` "
"ã«ã¯åˆè‡´ã—ã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:379
msgid ""
"Matching of IP addresses, when present in the subjectAltName field of the "
"certificate, is now supported."
msgstr "èªå®šæ›¸ã® subjectAltName ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§æç¤ºã•ã‚Œã¦ã„ã‚‹å ´åˆã€IP ã‚¢ãƒ‰ãƒ¬ã‚¹ã®ä¸€è‡´ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:383
msgid ""
"The function is no longer used to TLS connections. Hostname matching is now "
"performed by OpenSSL."
msgstr ""

#: ../../library/ssl.rst:387
msgid ""
"Allow wildcard when it is the leftmost and the only character in that "
"segment. Partial wildcards like ``www*.example.com`` are no longer "
"supported."
msgstr ""

#: ../../library/ssl.rst:395
msgid ""
"Return the time in seconds since the Epoch, given the ``cert_time`` string "
"representing the \"notBefore\" or \"notAfter\" date from a certificate in "
"``\"%b %d %H:%M:%S %Y %Z\"`` strptime format (C locale)."
msgstr ""
"``cert_time`` ã¨ã—ã¦è¨¼æ˜æ›¸å†…ã® \"notBefore\" ã‚„ \"notAfter\" ã® ``\"%b %d %H:%M:%S %Y "
"%Z\"`` strptime ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ (C locale) æ—¥ä»˜ã‚’æ¸¡ã™ã¨ã€ã‚¨ãƒãƒƒã‚¯ã‹ã‚‰ã®ç©ç®—ç§’ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:400
msgid "Here's an example:"
msgstr "ä¾‹ã§ã™ã€‚ :"

#: ../../library/ssl.rst:412
msgid "\"notBefore\" or \"notAfter\" dates must use GMT (:rfc:`5280`)."
msgstr "\"notBefore\" ã‚„ \"notAfter\" ã®æ—¥ä»˜ã«ã¯ GMT ã‚’ä½¿ã‚ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“(:rfc:`5280`)ã€‚"

#: ../../library/ssl.rst:414
msgid ""
"Interpret the input time as a time in UTC as specified by 'GMT' timezone in "
"the input string. Local timezone was used previously. Return an integer (no "
"fractions of a second in the input format)"
msgstr ""
"å…¥åŠ›æ–‡å­—åˆ—ã«æŒ‡å®šã•ã‚ŒãŸ 'GMT' ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã‚’ UTC "
"ã¨ã—ã¦è§£é‡ˆã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ä»¥å‰ã¯ãƒ­ãƒ¼ã‚«ãƒ«ã‚¿ã‚¤ãƒ ã§è§£é‡ˆã—ã¦ã„ã¾ã—ãŸã€‚ã¾ãŸã€æ•´æ•°ã‚’è¿”ã™ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸ(å…¥åŠ›ã«å«ã¾ã‚Œã‚‹ç§’ã®ç«¯æ•°ã‚’å«ã¾ãªã„)ã€‚"

#: ../../library/ssl.rst:422
msgid ""
"Given the address ``addr`` of an SSL-protected server, as a (*hostname*, "
"*port-number*) pair, fetches the server's certificate, and returns it as a "
"PEM-encoded string.  If ``ssl_version`` is specified, uses that version of "
"the SSL protocol to attempt to connect to the server.  If ``ca_certs`` is "
"specified, it should be a file containing a list of root certificates, the "
"same format as used for the same parameter in "
":meth:`SSLContext.wrap_socket`.  The call will attempt to validate the "
"server certificate against that set of root certificates, and will fail if "
"the validation attempt fails."
msgstr ""

#: ../../library/ssl.rst:432
msgid "This function is now IPv6-compatible."
msgstr "ã“ã®é–¢æ•°ã¯IPv6äº’æ›ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:435
msgid ""
"The default *ssl_version* is changed from :data:`PROTOCOL_SSLv3` to "
":data:`PROTOCOL_TLS` for maximum compatibility with modern servers."
msgstr ""
"*ssl_version* ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãŒã€æœ€è¿‘ã®ã‚µãƒ¼ãƒã¸ã®æœ€å¤§é™ã®äº’æ›æ€§ã®ãŸã‚ã« :data:`PROTOCOL_SSLv3` ã‹ã‚‰ "
":data:`PROTOCOL_TLS` ã«å¤‰æ›´ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:441
msgid ""
"Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded "
"string version of the same certificate."
msgstr "DERã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒã‚¤ãƒˆåˆ—ã¨ã—ã¦ä¸ãˆã‚‰ã‚ŒãŸè¨¼æ˜æ›¸ã‹ã‚‰ã€ PEMã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®åŒã˜è¨¼æ˜æ›¸ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:446
msgid ""
"Given a certificate as an ASCII PEM string, returns a DER-encoded sequence "
"of bytes for that same certificate."
msgstr "PEM å½¢å¼ã®ASCIIæ–‡å­—åˆ—ã¨ã—ã¦ä¸ãˆã‚‰ã‚ŒãŸè¨¼æ˜æ›¸ã‹ã‚‰ã€åŒã˜è¨¼æ˜æ›¸ã‚’DERã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ãŸãƒã‚¤ãƒˆåˆ—ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:451
msgid ""
"Returns a named tuple with paths to OpenSSL's default cafile and capath. The"
" paths are the same as used by :meth:`SSLContext.set_default_verify_paths`. "
"The return value is a :term:`named tuple` ``DefaultVerifyPaths``:"
msgstr ""
"OpenSSL ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® cafile, capath ã‚’æŒ‡ã™ãƒ‘ã‚¹ã‚’åå‰ä»˜ãã‚¿ãƒ—ãƒ«ã§è¿”ã—ã¾ã™ã€‚ãƒ‘ã‚¹ã¯ "
":meth:`SSLContext.set_default_verify_paths` ã§ä½¿ã‚ã‚Œã‚‹ã‚‚ã®ã¨åŒã˜ã§ã™ã€‚æˆ»ã‚Šå€¤ã¯ :term:`named "
"tuple` ``DefaultVerifyPaths`` ã§ã™:"

#: ../../library/ssl.rst:456
msgid ""
":attr:`cafile` - resolved path to cafile or ``None`` if the file doesn't "
"exist,"
msgstr ":attr:`cafile` - cafile ã®è§£æ±ºæ¸ˆã¿ãƒ‘ã‚¹ã€ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ ``None``"

#: ../../library/ssl.rst:457
msgid ""
":attr:`capath` - resolved path to capath or ``None`` if the directory "
"doesn't exist,"
msgstr ":attr:`capath` - capath ã®è§£æ±ºæ¸ˆã¿ãƒ‘ã‚¹ã€ã¾ãŸã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ ``None``"

#: ../../library/ssl.rst:458
msgid ""
":attr:`openssl_cafile_env` - OpenSSL's environment key that points to a "
"cafile,"
msgstr ":attr:`openssl_cafile_env` - cafile ã‚’æŒ‡ã™ OpenSSL ã®ç’°å¢ƒå¤‰æ•°"

#: ../../library/ssl.rst:459
msgid ":attr:`openssl_cafile` - hard coded path to a cafile,"
msgstr ":attr:`openssl_cafile` - OpenSSL ã«ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸ cafile ã®ãƒ‘ã‚¹"

#: ../../library/ssl.rst:460
msgid ""
":attr:`openssl_capath_env` - OpenSSL's environment key that points to a "
"capath,"
msgstr ":attr:`openssl_capath_env` - capath ã‚’æŒ‡ã™ OpenSSL ã®ç’°å¢ƒå¤‰æ•°"

#: ../../library/ssl.rst:461
msgid ":attr:`openssl_capath` - hard coded path to a capath directory"
msgstr ":attr:`openssl_capath` - OpenSSL ã«ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸ capath ã®ãƒ‘ã‚¹"

#: ../../library/ssl.rst:463
msgid ""
"Availability: LibreSSL ignores the environment vars "
":attr:`openssl_cafile_env` and :attr:`openssl_capath_env`"
msgstr ""
"åˆ©ç”¨å‡ºæ¥ã‚‹ç’°å¢ƒ: LibreSSL ã§ã¯ç’°å¢ƒå¤‰æ•° :attr:`openssl_cafile_env` ã¨ "
":attr:`openssl_capath_env` ãŒç„¡è¦–ã•ã‚Œã¾ã™"

#: ../../library/ssl.rst:470
msgid ""
"Retrieve certificates from Windows' system cert store. *store_name* may be "
"one of ``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert "
"stores, too."
msgstr ""
"Windows ã®ã‚·ã‚¹ãƒ†ãƒ è¨¼æ˜æ›¸ã‚¹ãƒˆã‚¢ã‚ˆã‚Šè¨¼æ˜æ›¸ã‚’æŠ½å‡ºã—ã¾ã™ã€‚ *store_name* ã¯ ``CA``, ``ROOT``, ``MY`` "
"ã®ã†ã¡ã©ã‚Œã‹ä¸€ã¤ã§ã—ã‚‡ã†ã€‚Windows ã¯è¿½åŠ ã®è¨¼æ˜æ›¸ã‚¹ãƒˆã‚¢ã‚’æä¾›ã—ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:474
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either "
":const:`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 "
"ASN.1 data. Trust specifies the purpose of the certificate as a set of OIDS "
"or exactly ``True`` if the certificate is trustworthy for all purposes."
msgstr ""
"ã“ã®é–¢æ•°ã¯ã‚¿ãƒ—ãƒ« (cert_bytes, encoding_type, trust) ã®ãƒªã‚¹ãƒˆã§è¿”ã—ã¾ã™ã€‚encoding_type ã¯ "
"cert_bytes ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¡¨ã—ã¾ã™ã€‚X.509 ASN.1 ã«å¯¾ã™ã‚‹ :const:`x509_asn` ã‹ PKCS#7 ASN.1 "
"ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã™ã‚‹ :const:`pkcs_7_asn` ã®ã„ãšã‚Œã‹ã§ã™ã€‚trust ã¯ã€è¨¼æ˜æ›¸ã®ç›®çš„ã‚’ã€OIDS ã‚’å†…å®¹ã«æŒã¤ set "
"ã¨ã—ã¦è¡¨ã™ã‹ã€ã¾ãŸã¯è¨¼æ˜æ›¸ãŒã™ã¹ã¦ã®ç›®çš„ã§ä¿¡é ¼ã§ãã‚‹ãªã‚‰ã° ``True`` ã§ã™ã€‚"

#: ../../library/ssl.rst:481 ../../library/ssl.rst:1565
#: ../../library/ssl.rst:1878
msgid "Example::"
msgstr "ä»¥ä¸‹ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ä¾‹ã§ã™::"

#: ../../library/ssl.rst:487 ../../library/ssl.rst:502
msgid "Availability: Windows."
msgstr "åˆ©ç”¨ã§ãã‚‹ç’°å¢ƒ : Windows."

#: ../../library/ssl.rst:493
msgid ""
"Retrieve CRLs from Windows' system cert store. *store_name* may be one of "
"``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert stores, too."
msgstr ""
"Windows ã®ã‚·ã‚¹ãƒ†ãƒ è¨¼æ˜æ›¸ã‚¹ãƒˆã‚¢ã‚ˆã‚Š CRLs ã‚’æŠ½å‡ºã—ã¾ã™ã€‚ *store_name* ã¯ ``CA``, ``ROOT``, ``MY`` "
"ã®ã†ã¡ã©ã‚Œã‹ä¸€ã¤ã§ã—ã‚‡ã†ã€‚Windows ã¯è¿½åŠ ã®è¨¼æ˜æ›¸ã‚¹ãƒˆã‚¢ã‚’æä¾›ã—ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:497
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either "
":const:`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 "
"ASN.1 data."
msgstr ""
"ã“ã®é–¢æ•°ã¯ã‚¿ãƒ—ãƒ« (cert_bytes, encoding_type, trust) ã®ãƒªã‚¹ãƒˆã§è¿”ã—ã¾ã™ã€‚encoding_type ã¯ "
"cert_bytes ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¡¨ã—ã¾ã™ã€‚X.509 ASN.1 ã«å¯¾ã™ã‚‹ :const:`x509_asn` ã‹ PKCS#7 ASN.1 "
"ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã™ã‚‹ :const:`pkcs_7_asn` ã®ã„ãšã‚Œã‹ã§ã™ã€‚"

#: ../../library/ssl.rst:511
msgid ""
"Takes an instance ``sock`` of :class:`socket.socket`, and returns an "
"instance of :class:`ssl.SSLSocket`, a subtype of :class:`socket.socket`, "
"which wraps the underlying socket in an SSL context.  ``sock`` must be a "
":data:`~socket.SOCK_STREAM` socket; other socket types are unsupported."
msgstr ""
":class:`socket.socket` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ ``sock`` ã‚’å—ã‘å–ã‚Šã€ :class:`socket.socket` "
"ã®ã‚µãƒ–ã‚¿ã‚¤ãƒ—ã§ã‚ã‚‹ :class:`ssl.SSLSocket` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ :class:`ssl.SSLSocket` "
"ã¯ä½ãƒ¬ã‚¤ãƒ¤ã®ã‚½ã‚±ãƒƒãƒˆã‚’SSLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ãƒ©ãƒƒãƒ—ã—ã¾ã™ã€‚ ``sock`` ã¯ :data:`~socket.SOCK_STREAM` "
"ã‚½ã‚±ãƒƒãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“; ã»ã‹ã®ã‚¿ã‚¤ãƒ—ã®ã‚½ã‚±ãƒƒãƒˆã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:516
msgid ""
"Internally, function creates a :class:`SSLContext` with protocol "
"*ssl_version* and :attr:`SSLContext.options` set to *cert_reqs*. If "
"parameters *keyfile*, *certfile*, *ca_certs* or *ciphers* are set, then the "
"values are passed to :meth:`SSLContext.load_cert_chain`, "
":meth:`SSLContext.load_verify_locations`, and "
":meth:`SSLContext.set_ciphers`."
msgstr ""

#: ../../library/ssl.rst:523
msgid ""
"The arguments *server_side*, *do_handshake_on_connect*, and "
"*suppress_ragged_eofs* have the same meaning as "
":meth:`SSLContext.wrap_socket`."
msgstr ""

#: ../../library/ssl.rst:529
msgid ""
"Since Python 3.2 and 2.7.9, it is recommended to use the "
":meth:`SSLContext.wrap_socket` instead of :func:`wrap_socket`. The top-level"
" function is limited and creates an insecure client socket without server "
"name indication or hostname matching."
msgstr ""

#: ../../library/ssl.rst:535
msgid "Constants"
msgstr "å®šæ•°"

#: ../../library/ssl.rst:537
msgid ""
"All constants are now :class:`enum.IntEnum` or :class:`enum.IntFlag` "
"collections."
msgstr ""
"ã™ã¹ã¦ã®å®šæ•°ãŒ :class:`enum.IntEnum` ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã¾ãŸã¯ :class:`enum.IntFlag` ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:543
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  Except for :const:`PROTOCOL_TLS_CLIENT`, "
"it is the default mode.  With client-side sockets, just about any cert is "
"accepted.  Validation errors, such as untrusted or expired cert, are ignored"
" and do not abort the TLS/SSL handshake."
msgstr ""

#: ../../library/ssl.rst:549
msgid ""
"In server mode, no certificate is requested from the client, so the client "
"does not send any for client cert authentication."
msgstr ""

#: ../../library/ssl.rst:552 ../../library/ssl.rst:2268
msgid "See the discussion of :ref:`ssl-security` below."
msgstr "ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ä¸‹ã®æ–¹ã®ã€ :ref:`ssl-security` ã«é–¢ã™ã‚‹è­°è«–ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:556
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In client mode, :const:`CERT_OPTIONAL` "
"has the same meaning as :const:`CERT_REQUIRED`. It is recommended to use "
":const:`CERT_REQUIRED` for client-side sockets instead."
msgstr ""

#: ../../library/ssl.rst:561
msgid ""
"In server mode, a client certificate request is sent to the client.  The "
"client may either ignore the request or send a certificate in order perform "
"TLS client cert authentication.  If the client chooses to send a "
"certificate, it is verified.  Any verification error immediately aborts the "
"TLS handshake."
msgstr ""

#: ../../library/ssl.rst:567 ../../library/ssl.rst:587
msgid ""
"Use of this setting requires a valid set of CA certificates to be passed, "
"either to :meth:`SSLContext.load_verify_locations` or as a value of the "
"``ca_certs`` parameter to :func:`wrap_socket`."
msgstr ""
"ã“ã®è¨­å®šã§ã¯ã€æ­£å½“ãªCAè¨¼æ˜æ›¸ã®ã‚»ãƒƒãƒˆã‚’ :meth:`SSLContext.load_verify_locations` ã¾ãŸã¯ "
":func:`wrap_socket` ã® ``ca_certs`` ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ã©ã¡ã‚‰ã‹ã«æ¸¡ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/ssl.rst:573
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In this mode, certificates are required "
"from the other side of the socket connection; an :class:`SSLError` will be "
"raised if no certificate is provided, or if its validation fails. This mode "
"is **not** sufficient to verify a certificate in client mode as it does not "
"match hostnames.  :attr:`~SSLContext.check_hostname` must be enabled as well"
" to verify the authenticity of a cert. :const:`PROTOCOL_TLS_CLIENT` uses "
":const:`CERT_REQUIRED` and enables :attr:`~SSLContext.check_hostname` by "
"default."
msgstr ""

#: ../../library/ssl.rst:583
msgid ""
"With server socket, this mode provides mandatory TLS client cert "
"authentication.  A client certificate request is sent to the client and the "
"client must provide a valid and trusted certificate."
msgstr ""

#: ../../library/ssl.rst:593
msgid ":class:`enum.IntEnum` collection of CERT_* constants."
msgstr "CERT_* å®šæ•°ã® :class:`enum.IntEnum` ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã§ã™ã€‚"

#: ../../library/ssl.rst:599
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, "
"certificate revocation lists (CRLs) are not checked. By default OpenSSL does"
" neither require nor verify CRLs."
msgstr ""
":attr:`SSLContext.verify_flags` "
"ã«æ¸¡ã›ã‚‹å€¤ã§ã™ã€‚ã“ã®ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€è¨¼æ˜æ›¸å¤±åŠ¹ãƒªã‚¹ãƒˆ(CRLs)ã¯ãƒã‚§ãƒƒã‚¯ã•ã‚Œã¾ã›ã‚“ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ OpenSSL ã¯ CRLs "
"ã‚’å¿…è¦ã¨ã‚‚ã—ã¾ã›ã‚“ã—æ¤œè¨¼ã«ã‚‚ä½¿ã„ã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:607
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, only the "
"peer cert is check but non of the intermediate CA certificates. The mode "
"requires a valid CRL that is signed by the peer cert's issuer (its direct "
"ancestor CA). If no proper has been loaded "
":attr:`SSLContext.load_verify_locations`, validation will fail."
msgstr ""
":attr:`SSLContext.verify_flags` ã«æ¸¡ã›ã‚‹å€¤ã§ã™ã€‚ã“ã®ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€æ¥ç¶šå…ˆã®è¨¼æ˜æ›¸ã®ãƒã‚§ãƒƒã‚¯ã®ã¿ã§ä»²ä»‹ã® CA "
"è¨¼æ˜æ›¸ã¯ãƒã‚§ãƒƒã‚¯ã—ã¾ã›ã‚“ã€‚æ¥ç¶šå…ˆè¨¼æ˜æ›¸ã®ç™ºè¡Œè€…(ãã® CA ã®ç›´æ¥ã®ç¥–å…ˆ)ã«ã‚ˆã£ã¦ç½²åã•ã‚ŒãŸå¦¥å½“ãª CRL ãŒå¿…è¦ã§ã™ã€‚ "
":attr:`SSLContext.load_verify_locations` ãŒç›¸å¿œã—ã„ã‚‚ã®ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¦ã„ãªã‘ã‚Œã°ã€æ¤œè¨¼ã¯å¤±æ•—ã™ã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../library/ssl.rst:617
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, CRLs of "
"all certificates in the peer cert chain are checked."
msgstr ""
":attr:`SSLContext.verify_flags` ã«æ¸¡ã›ã‚‹å€¤ã§ã™ã€‚ã“ã®ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€æ¥ç¶šå…ˆã®è¨¼æ˜æ›¸ãƒã‚§ã‚¤ãƒ³å†…ã®ã™ã¹ã¦ã®è¨¼æ˜æ›¸ã«ã¤ã„ã¦ã® "
"CRLs ãŒãƒã‚§ãƒƒã‚¯ã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:624
msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to disable workarounds "
"for broken X.509 certificates."
msgstr ""
":attr:`SSLContext.verify_flags` ã«æ¸¡ã›ã‚‹å€¤ã§ã€å£Šã‚ŒãŸ X.509 è¨¼æ˜æ›¸ã«å¯¾ã™ã‚‹ãƒ¯ãƒ¼ã‚¯ã‚¢ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’ç„¡åŠ¹ã«ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:631
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL to "
"prefer trusted certificates when building the trust chain to validate a "
"certificate. This flag is enabled by default."
msgstr ""
":attr:`SSLContext.verify_flags` ã«æ¸¡ã›ã‚‹å€¤ã§ã™ã€‚OpenSSL "
"ã«å¯¾ã—ã€è¨¼æ˜æ›¸æ¤œè¨¼ã®ãŸã‚ã«ä¿¡é ¼ãƒã‚§ã‚¤ãƒ³ã‚’æ§‹ç¯‰ã™ã‚‹éš›ã€ä¿¡é ¼ã§ãã‚‹è¨¼æ˜æ›¸ã‚’é¸ã¶ã‚ˆã†ã«æŒ‡ç¤ºã—ã¾ã™ã€‚ã“ã‚Œã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§æœ‰åŠ¹ã«ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/ssl.rst:639
msgid ":class:`enum.IntFlag` collection of VERIFY_* constants."
msgstr "VERIFY_* å®šæ•°ã® :class:`enum.IntFlag` ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã§ã™ã€‚"

#: ../../library/ssl.rst:645
msgid ""
"Selects the highest protocol version that both the client and server "
"support. Despite the name, this option can select both \"SSL\" and \"TLS\" "
"protocols."
msgstr ""

#: ../../library/ssl.rst:652
msgid ""
"Auto-negotiate the highest protocol version like :data:`PROTOCOL_TLS`, but "
"only support client-side :class:`SSLSocket` connections. The protocol "
"enables :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` by "
"default."
msgstr ""

#: ../../library/ssl.rst:661
msgid ""
"Auto-negotiate the highest protocol version like :data:`PROTOCOL_TLS`, but "
"only support server-side :class:`SSLSocket` connections."
msgstr ""

#: ../../library/ssl.rst:668
msgid "Alias for data:`PROTOCOL_TLS`."
msgstr "data:`PROTOCOL_TLS` ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã§ã™ã€‚"

#: ../../library/ssl.rst:672
msgid "Use :data:`PROTOCOL_TLS` instead."
msgstr "ä»£ã‚ã‚Šã« :data:`PROTOCOL_TLS` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:676
msgid "Selects SSL version 2 as the channel encryption protocol."
msgstr "ãƒãƒ£ãƒ³ãƒãƒ«æš—å·åŒ–ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨ã—ã¦ SSL ãƒãƒ¼ã‚¸ãƒ§ãƒ³2ã‚’é¸æŠã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:678
msgid ""
"This protocol is not available if OpenSSL is compiled with the "
"``OPENSSL_NO_SSL2`` flag."
msgstr ""
"ã“ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯ã€ OpenSSL ãŒ ``OPENSSL_NO_SSL2`` ãƒ•ãƒ©ã‚°ãŒæœ‰åŠ¹ãªçŠ¶æ…‹ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:683
msgid "SSL version 2 is insecure.  Its use is highly discouraged."
msgstr "SSL version 2 ã¯éã‚»ã‚­ãƒ¥ã‚¢ã§ã™ã€‚ã“ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯å¼·ãéæ¨å¥¨ã§ã™ã€‚"

#: ../../library/ssl.rst:687
msgid "OpenSSL has removed support for SSLv2."
msgstr "OpenSSL ã¯ SSLv2 ã¸ã®ã‚µãƒãƒ¼ãƒˆã‚’æ‰“åˆ‡ã‚Šã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:691
msgid "Selects SSL version 3 as the channel encryption protocol."
msgstr "ãƒãƒ£ãƒ³ãƒãƒ«æš—å·åŒ–ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨ã—ã¦SSLãƒãƒ¼ã‚¸ãƒ§ãƒ³3ã‚’é¸æŠã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:693
msgid ""
"This protocol is not be available if OpenSSL is compiled with the "
"``OPENSSL_NO_SSLv3`` flag."
msgstr ""
"ã“ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯ã€ OpenSSL ãŒ ``OPENSSL_NO_SSLv3`` ãƒ•ãƒ©ã‚°ãŒæœ‰åŠ¹ãªçŠ¶æ…‹ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:698
msgid "SSL version 3 is insecure.  Its use is highly discouraged."
msgstr "SSL version 3 ã¯éã‚»ã‚­ãƒ¥ã‚¢ã§ã™ã€‚ã“ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯å¼·ãéæ¨å¥¨ã§ã™ã€‚"

#: ../../library/ssl.rst:702 ../../library/ssl.rst:711
#: ../../library/ssl.rst:723 ../../library/ssl.rst:736
msgid ""
"OpenSSL has deprecated all version specific protocols. Use the default "
"protocol :data:`PROTOCOL_TLS` with flags like :data:`OP_NO_SSLv3` instead."
msgstr ""
"OpenSSL ã¯å…¨ã¦ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³å›ºæœ‰ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’å»ƒæ­¢ã—ã¾ã—ãŸã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ—ãƒ­ãƒˆã‚³ãƒ«ã® :data:`PROTOCOL_TLS` ã« "
":data:`OP_NO_SSLv3` ãªã©ã®ãƒ•ãƒ©ã‚°ã‚’ã¤ã‘ã¦ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:707
msgid "Selects TLS version 1.0 as the channel encryption protocol."
msgstr "ãƒãƒ£ãƒ³ãƒãƒ«æš—å·åŒ–ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨ã—ã¦TLSãƒãƒ¼ã‚¸ãƒ§ãƒ³1.0ã‚’é¸æŠã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:716
msgid ""
"Selects TLS version 1.1 as the channel encryption protocol. Available only "
"with openssl version 1.0.1+."
msgstr "ãƒãƒ£ãƒ³ãƒãƒ«æš—å·åŒ–ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨ã—ã¦TLSãƒãƒ¼ã‚¸ãƒ§ãƒ³1.1ã‚’é¸æŠã—ã¾ã™ã€‚ openssl version 1.0.1+ ã®ã¿ã§åˆ©ç”¨å¯èƒ½ã§ã™ã€‚"

#: ../../library/ssl.rst:728
msgid ""
"Selects TLS version 1.2 as the channel encryption protocol. This is the most"
" modern version, and probably the best choice for maximum protection, if "
"both sides can speak it.  Available only with openssl version 1.0.1+."
msgstr ""
"ãƒãƒ£ãƒ³ãƒãƒ«æš—å·åŒ–ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨ã—ã¦TLSãƒãƒ¼ã‚¸ãƒ§ãƒ³1.2ã‚’é¸æŠã—ã¾ã™ã€‚ã“ã‚Œã¯æœ€ã‚‚ç¾ä»£çš„ã§ã€æ¥ç¶šã®ä¸¡ã‚µã‚¤ãƒ‰ãŒåˆ©ç”¨ã§ãã‚‹å ´åˆã¯ã€ãŸã¶ã‚“æœ€ã‚‚å®‰å…¨ãªé¸æŠè‚¢ã§ã™ã€‚ "
"openssl version 1.0.1+ ã®ã¿ã§åˆ©ç”¨å¯èƒ½ã§ã™ã€‚"

#: ../../library/ssl.rst:741
msgid ""
"Enables workarounds for various bugs present in other SSL implementations. "
"This option is set by default.  It does not necessarily set the same flags "
"as OpenSSL's ``SSL_OP_ALL`` constant."
msgstr ""
"ç›¸æ‰‹ã«ã™ã‚‹ SSL å®Ÿè£…ã®ã•ã¾ã–ã¾ãªãƒã‚°ã‚’å›é¿ã™ã‚‹ãŸã‚ã®ãƒ¯ãƒ¼ã‚¯ã‚¢ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’æœ‰åŠ¹ã«ã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§æœ‰åŠ¹ã§ã™ã€‚ã“ã‚Œã‚’æœ‰åŠ¹ã«ã™ã‚‹å ´åˆ "
"OpenSSL ç”¨ã®åŒã˜æ„å‘³ã®ãƒ•ãƒ©ã‚° ``SSL_OP_ALL`` ã‚’ã‚»ãƒƒãƒˆã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:749
msgid ""
"Prevents an SSLv2 connection.  This option is only applicable in conjunction"
" with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv2 as "
"the protocol version."
msgstr ""
"SSLv2 æ¥ç¶šãŒè¡Œã‚ã‚Œãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ :const:`PROTOCOL_TLS` "
"ã¨çµ„ã¿åˆã‚ã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã®ã¿é©ç”¨ã•ã‚Œã¾ã™ã€‚ãƒ”ã‚¢ãŒãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ã—ã¦ SSLv2 ã‚’é¸æŠã—ãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:757
msgid "SSLv2 is deprecated"
msgstr "SSLv2 ã¯éæ¨å¥¨ã§ã™"

#: ../../library/ssl.rst:762
msgid ""
"Prevents an SSLv3 connection.  This option is only applicable in conjunction"
" with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv3 as "
"the protocol version."
msgstr ""
"SSLv3 æ¥ç¶šãŒè¡Œã‚ã‚Œãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ :const:`PROTOCOL_TLS` "
"ã¨çµ„ã¿åˆã‚ã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã®ã¿é©ç”¨ã•ã‚Œã¾ã™ã€‚ãƒ”ã‚¢ãŒãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ã—ã¦ SSLv3 ã‚’é¸æŠã—ãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:770
msgid "SSLv3 is deprecated"
msgstr "SSLv3 ã¯éæ¨å¥¨ã§ã™"

#: ../../library/ssl.rst:774
msgid ""
"Prevents a TLSv1 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing TLSv1 as "
"the protocol version."
msgstr ""
"TLSv1 æ¥ç¶šãŒè¡Œã‚ã‚Œãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ :const:`PROTOCOL_TLS` "
"ã¨çµ„ã¿åˆã‚ã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã®ã¿é©ç”¨ã•ã‚Œã¾ã™ã€‚ãƒ”ã‚¢ãŒãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ã—ã¦ TLSv1 ã‚’é¸æŠã—ãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:780
msgid ""
"The option is deprecated since OpenSSL 1.1.0, use the new "
":attr:`SSLContext.minimum_version` and :attr:`SSLContext.maximum_version` "
"instead."
msgstr ""

#: ../../library/ssl.rst:787
msgid ""
"Prevents a TLSv1.1 connection. This option is only applicable in conjunction"
" with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.1 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"TLSv1.1 æ¥ç¶šãŒè¡Œã‚ã‚Œãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ :const:`PROTOCOL_TLS` "
"ã¨çµ„ã¿åˆã‚ã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã®ã¿é©ç”¨ã•ã‚Œã¾ã™ã€‚ãƒ”ã‚¢ãŒãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ã—ã¦ TLSv1.1 ã‚’é¸æŠã—ãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚openssl ãƒãƒ¼ã‚¸ãƒ§ãƒ³ "
"1.0.1 ä»¥é™ã§ã®ã¿åˆ©ç”¨ã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:793 ../../library/ssl.rst:804
msgid "The option is deprecated since OpenSSL 1.1.0."
msgstr ""

#: ../../library/ssl.rst:798
msgid ""
"Prevents a TLSv1.2 connection. This option is only applicable in conjunction"
" with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.2 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"TLSv1.2 æ¥ç¶šãŒè¡Œã‚ã‚Œãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ :const:`PROTOCOL_TLS` "
"ã¨çµ„ã¿åˆã‚ã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã®ã¿é©ç”¨ã•ã‚Œã¾ã™ã€‚ãƒ”ã‚¢ãŒãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ã—ã¦ TLSv1.2 ã‚’é¸æŠã—ãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚openssl ãƒãƒ¼ã‚¸ãƒ§ãƒ³ "
"1.0.1 ä»¥é™ã§ã®ã¿åˆ©ç”¨ã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:809
msgid ""
"Prevents a TLSv1.3 connection. This option is only applicable in conjunction"
" with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.3 as "
"the protocol version. TLS 1.3 is available with OpenSSL 1.1.1 or later. When"
" Python has been compiled against an older version of OpenSSL, the flag "
"defaults to *0*."
msgstr ""

#: ../../library/ssl.rst:817
msgid ""
"The option is deprecated since OpenSSL 1.1.0. It was added to 2.7.15, 3.6.3 "
"and 3.7.0 for backwards compatibility with OpenSSL 1.0.2."
msgstr ""

#: ../../library/ssl.rst:823
msgid ""
"Disable all renegotiation in TLSv1.2 and earlier. Do not send HelloRequest "
"messages, and ignore renegotiation requests via ClientHello."
msgstr ""

#: ../../library/ssl.rst:826
msgid "This option is only available with OpenSSL 1.1.0h and later."
msgstr ""

#: ../../library/ssl.rst:832
msgid ""
"Use the server's cipher ordering preference, rather than the client's. This "
"option has no effect on client sockets and SSLv2 server sockets."
msgstr ""
"æš—å·ã®å„ªå…ˆé †ä½ã¨ã—ã¦ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®ã‚‚ã®ã§ã¯ãªãã‚µãƒ¼ãƒã®ã‚‚ã®ã‚’ä½¿ã„ã¾ã™ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚½ã‚±ãƒƒãƒˆã¨ SSLv2 "
"ã®ã‚µãƒ¼ãƒã‚½ã‚±ãƒƒãƒˆã§ã¯åŠ¹æœã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:839
msgid ""
"Prevents re-use of the same DH key for distinct SSL sessions.  This improves"
" forward secrecy but requires more computational resources. This option only"
" applies to server sockets."
msgstr ""
"SSL ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’åŒºåˆ¥ã™ã‚‹ã®ã«åŒã˜ DH "
"éµã‚’å†åˆ©ç”¨ã—ãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã‚Œã¯ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’å‘ä¸Šã•ã›ã¾ã™ãŒã€ã‚ˆã‚Šå¤šãã®è¨ˆç®—æ©Ÿãƒªã‚½ãƒ¼ã‚¹ã‚’å¿…è¦ã¨ã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ã‚µãƒ¼ãƒã‚½ã‚±ãƒƒãƒˆã«é©ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:847
msgid ""
"Prevents re-use of the same ECDH key for distinct SSL sessions.  This "
"improves forward secrecy but requires more computational resources. This "
"option only applies to server sockets."
msgstr ""
"SSL ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’åŒºåˆ¥ã™ã‚‹ã®ã«åŒã˜ ECDH "
"éµã‚’å†åˆ©ç”¨ã—ãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã‚Œã¯ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’å‘ä¸Šã•ã›ã¾ã™ãŒã€ã‚ˆã‚Šå¤šãã®è¨ˆç®—æ©Ÿãƒªã‚½ãƒ¼ã‚¹ã‚’å¿…è¦ã¨ã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ã‚µãƒ¼ãƒã‚½ã‚±ãƒƒãƒˆã«é©ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:855
msgid ""
"Send dummy Change Cipher Spec (CCS) messages in TLS 1.3 handshake to make a "
"TLS 1.3 connection look more like a TLS 1.2 connection."
msgstr ""

#: ../../library/ssl.rst:858
msgid "This option is only available with OpenSSL 1.1.1 and later."
msgstr ""

#: ../../library/ssl.rst:864
msgid ""
"Disable compression on the SSL channel.  This is useful if the application "
"protocol supports its own compression scheme."
msgstr "SSL ãƒãƒ£ãƒãƒ«ã§ã®åœ§ç¸®ã‚’ç„¡åŠ¹ã«ã—ã¾ã™ã€‚ã“ã‚Œã¯ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãŒè‡ªèº«ã®åœ§ç¸®æ–¹æ³•ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å ´åˆã«æœ‰ç”¨ã§ã™ã€‚"

#: ../../library/ssl.rst:867
msgid "This option is only available with OpenSSL 1.0.0 and later."
msgstr "ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ OpenSSL 1.0.0ä»¥é™ã®ã¿ã§ä½¿ç”¨ã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:873
msgid ":class:`enum.IntFlag` collection of OP_* constants."
msgstr "OP_* å®šæ•°ã® :class:`enum.IntFlag` ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã§ã™ã€‚"

#: ../../library/ssl.rst:877
msgid "Prevent client side from requesting a session ticket."
msgstr "ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ãŒã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒã‚±ãƒƒãƒˆã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆã—ãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:883
msgid ""
"Whether the OpenSSL library has built-in support for the *Application-Layer "
"Protocol Negotiation* TLS extension as described in :rfc:`7301`."
msgstr ""
"OpenSSL ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã€çµ„ã¿è¾¼ã¿ã§ :rfc:`7301` ã§è¨˜è¿°ã•ã‚Œã¦ã„ã‚‹ *Application-Layer Protocol "
"Negotiation* TLS æ‹¡å¼µã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã€‚"

#: ../../library/ssl.rst:890
msgid ""
"Whether the OpenSSL library has built-in support not checking subject common"
" name and :attr:`SSLContext.hostname_checks_common_name` is writeable."
msgstr ""

#: ../../library/ssl.rst:898
msgid ""
"Whether the OpenSSL library has built-in support for the Elliptic Curve-"
"based Diffie-Hellman key exchange.  This should be true unless the feature "
"was explicitly disabled by the distributor."
msgstr ""

#: ../../library/ssl.rst:906
msgid ""
"Whether the OpenSSL library has built-in support for the *Server Name "
"Indication* extension (as defined in :rfc:`6066`)."
msgstr ""

#: ../../library/ssl.rst:913
msgid ""
"Whether the OpenSSL library has built-in support for the *Next Protocol "
"Negotiation* as described in the `Application Layer Protocol Negotiation "
"<https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_. "
"When true, you can use the :meth:`SSLContext.set_npn_protocols` method to "
"advertise which protocols you want to support."
msgstr ""

#: ../../library/ssl.rst:923
msgid ""
"Whether the OpenSSL library has built-in support for the SSL 2.0 protocol."
msgstr ""

#: ../../library/ssl.rst:929
msgid ""
"Whether the OpenSSL library has built-in support for the SSL 3.0 protocol."
msgstr ""

#: ../../library/ssl.rst:935
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.0 protocol."
msgstr ""

#: ../../library/ssl.rst:941
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.1 protocol."
msgstr ""

#: ../../library/ssl.rst:947
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.2 protocol."
msgstr ""

#: ../../library/ssl.rst:953
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.3 protocol."
msgstr ""

#: ../../library/ssl.rst:959
msgid ""
"List of supported TLS channel binding types.  Strings in this list can be "
"used as arguments to :meth:`SSLSocket.get_channel_binding`."
msgstr ""
"ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ TLS ã®ãƒãƒ£ãƒãƒ«ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã®ã‚¿ã‚¤ãƒ—ã®ãƒªã‚¹ãƒˆã€‚ãƒªã‚¹ãƒˆå†…ã®æ–‡å­—åˆ—ã¯ "
":meth:`SSLSocket.get_channel_binding` ã®å¼•æ•°ã«æ¸¡ã›ã¾ã™ã€‚"

#: ../../library/ssl.rst:966
msgid "The version string of the OpenSSL library loaded by the interpreter::"
msgstr "ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ã‚ˆã£ã¦ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸ OpenSSL ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³æ–‡å­—åˆ—::"

#: ../../library/ssl.rst:975
msgid ""
"A tuple of five integers representing version information about the OpenSSL "
"library::"
msgstr "OpenSSL ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ã‚’è¡¨ã™5ã¤ã®æ•´æ•°ã®ã‚¿ãƒ—ãƒ«::"

#: ../../library/ssl.rst:985
msgid "The raw version number of the OpenSSL library, as a single integer::"
msgstr "1ã¤ã®æ•´æ•°ã®å½¢å¼ã®ã€ OpenSSL ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ç”Ÿã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·::"

#: ../../library/ssl.rst:998
msgid ""
"Alert Descriptions from :rfc:`5246` and others. The `IANA TLS Alert Registry"
" <https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_ contains this list and references to the RFCs where their "
"meaning is defined."
msgstr ""
":rfc:`5246` ãã®ä»–ã‹ã‚‰ã®ã‚¢ãƒ©ãƒ¼ãƒˆã®ç¨®é¡ã§ã™ã€‚ `IANA TLS Alert Registry "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_ ã«ã¯ã“ã®ãƒªã‚¹ãƒˆã¨ãã®æ„å‘³ãŒå®šç¾©ã•ã‚ŒãŸ RFC ã¸ã®ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/ssl.rst:1002
msgid ""
"Used as the return value of the callback function in "
":meth:`SSLContext.set_servername_callback`."
msgstr ":meth:`SSLContext.set_servername_callback` ã§ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã®æˆ»ã‚Šå€¤ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:1009
msgid ":class:`enum.IntEnum` collection of ALERT_DESCRIPTION_* constants."
msgstr "ALERT_DESCRIPTION_* å®šæ•°ã® :class:`enum.IntEnum`Â ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã§ã™ã€‚"

#: ../../library/ssl.rst:1015
msgid ""
"Option for :func:`create_default_context` and "
":meth:`SSLContext.load_default_certs`.  This value indicates that the "
"context may be used to authenticate Web servers (therefore, it will be used "
"to create client-side sockets)."
msgstr ""
":func:`create_default_context` ã¨ :meth:`SSLContext.load_default_certs` "
"ã«æ¸¡ã™ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã™ã€‚ã“ã®å€¤ã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒ Web ã‚µãƒ¼ãƒã®èªè¨¼ã«ä½¿ã‚ã‚Œã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ "
"(ã§ã™ã®ã§ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã®ã‚½ã‚±ãƒƒãƒˆã‚’ä½œã‚‹ã®ã«ä½¿ã†ã“ã¨ã«ãªã‚‹ã§ã—ã‚‡ã†)ã€‚"

#: ../../library/ssl.rst:1024
msgid ""
"Option for :func:`create_default_context` and "
":meth:`SSLContext.load_default_certs`.  This value indicates that the "
"context may be used to authenticate Web clients (therefore, it will be used "
"to create server-side sockets)."
msgstr ""
":func:`create_default_context` ã¨ :meth:`SSLContext.load_default_certs` "
"ã«æ¸¡ã™ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã™ã€‚ã“ã®å€¤ã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒ Web ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®èªè¨¼ã«ä½¿ã‚ã‚Œã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ "
"(ã§ã™ã®ã§ã€ã‚µãƒ¼ãƒã‚µã‚¤ãƒ‰ã®ã‚½ã‚±ãƒƒãƒˆã‚’ä½œã‚‹ã®ã«ä½¿ã†ã“ã¨ã«ãªã‚‹ã§ã—ã‚‡ã†)ã€‚"

#: ../../library/ssl.rst:1033
msgid ":class:`enum.IntEnum` collection of SSL_ERROR_* constants."
msgstr "SSL_ERROR_* å®šæ•°ã® :class:`enum.IntEnum`Â ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã§ã™ã€‚"

#: ../../library/ssl.rst:1039
msgid ""
":class:`enum.IntEnum` collection of SSL and TLS versions for "
":attr:`SSLContext.maximum_version` and :attr:`SSLContext.minimum_version`."
msgstr ""

#: ../../library/ssl.rst:1047
msgid ""
"The minimum or maximum supported SSL or TLS version. These are magic "
"constants. Their values don't reflect the lowest and highest available "
"TLS/SSL versions."
msgstr ""

#: ../../library/ssl.rst:1057
msgid "SSL 3.0 to TLS 1.3."
msgstr ""

#: ../../library/ssl.rst:1060
msgid "SSL Sockets"
msgstr "SSL ã‚½ã‚±ãƒƒãƒˆ"

#: ../../library/ssl.rst:1064
msgid "SSL sockets provide the following methods of :ref:`socket-objects`:"
msgstr "SSL ã‚½ã‚±ãƒƒãƒˆã¯ :ref:`socket-objects` ã®ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã—ã¾ã™:"

#: ../../library/ssl.rst:1066
msgid ":meth:`~socket.socket.accept()`"
msgstr ":meth:`~socket.socket.accept()`"

#: ../../library/ssl.rst:1067
msgid ":meth:`~socket.socket.bind()`"
msgstr ":meth:`~socket.socket.bind()`"

#: ../../library/ssl.rst:1068
msgid ":meth:`~socket.socket.close()`"
msgstr ":meth:`~socket.socket.close()`"

#: ../../library/ssl.rst:1069
msgid ":meth:`~socket.socket.connect()`"
msgstr ":meth:`~socket.socket.connect()`"

#: ../../library/ssl.rst:1070
msgid ":meth:`~socket.socket.detach()`"
msgstr ":meth:`~socket.socket.detach()`"

#: ../../library/ssl.rst:1071
msgid ":meth:`~socket.socket.fileno()`"
msgstr ":meth:`~socket.socket.fileno()`"

#: ../../library/ssl.rst:1072
msgid ""
":meth:`~socket.socket.getpeername()`, :meth:`~socket.socket.getsockname()`"
msgstr ""
":meth:`~socket.socket.getpeername()`, :meth:`~socket.socket.getsockname()`"

#: ../../library/ssl.rst:1073
msgid ""
":meth:`~socket.socket.getsockopt()`, :meth:`~socket.socket.setsockopt()`"
msgstr ""
":meth:`~socket.socket.getsockopt()`, :meth:`~socket.socket.setsockopt()`"

#: ../../library/ssl.rst:1074
msgid ""
":meth:`~socket.socket.gettimeout()`, :meth:`~socket.socket.settimeout()`, "
":meth:`~socket.socket.setblocking()`"
msgstr ""
":meth:`~socket.socket.gettimeout()`, :meth:`~socket.socket.settimeout()`, "
":meth:`~socket.socket.setblocking()`"

#: ../../library/ssl.rst:1076
msgid ":meth:`~socket.socket.listen()`"
msgstr ":meth:`~socket.socket.listen()`"

#: ../../library/ssl.rst:1077
msgid ":meth:`~socket.socket.makefile()`"
msgstr ":meth:`~socket.socket.makefile()`"

#: ../../library/ssl.rst:1078
msgid ""
":meth:`~socket.socket.recv()`, :meth:`~socket.socket.recv_into()` (but "
"passing a non-zero ``flags`` argument is not allowed)"
msgstr ""
":meth:`~socket.socket.recv()`, :meth:`~socket.socket.recv_into()` (éã‚¼ãƒ­ã® "
"``flags`` ã¯æ¸¡ã›ã¾ã›ã‚“)"

#: ../../library/ssl.rst:1080
msgid ""
":meth:`~socket.socket.send()`, :meth:`~socket.socket.sendall()` (with the "
"same limitation)"
msgstr ""
":meth:`~socket.socket.send()`, :meth:`~socket.socket.sendall()` (éã‚¼ãƒ­ã® "
"``flags`` ã¯æ¸¡ã›ã¾ã›ã‚“)"

#: ../../library/ssl.rst:1082
msgid ""
":meth:`~socket.socket.sendfile()` (but :mod:`os.sendfile` will be used for "
"plain-text sockets only, else :meth:`~socket.socket.send()` will be used)"
msgstr ""
":meth:`~socket.socket.sendfile()` (ãŸã ã—ã€ :mod:`os.sendfile` "
"ã¯å¹³æ–‡ã‚½ã‚±ãƒƒãƒˆã«ã®ã¿ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯ã€ :meth:`~socket.socket.send()` ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚)"

#: ../../library/ssl.rst:1084
msgid ":meth:`~socket.socket.shutdown()`"
msgstr ":meth:`~socket.socket.shutdown()`"

#: ../../library/ssl.rst:1086
msgid ""
"However, since the SSL (and TLS) protocol has its own framing atop of TCP, "
"the SSL sockets abstraction can, in certain respects, diverge from the "
"specification of normal, OS-level sockets.  See especially the :ref:`notes "
"on non-blocking sockets <ssl-nonblocking>`."
msgstr ""
"SSL(ãŠã‚ˆã³TLS)ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯ TCP ã®ä¸Šã«ç‹¬è‡ªã®æ çµ„ã¿ã‚’æŒã£ã¦ã„ã‚‹ã®ã§ã€SSLã‚½ã‚±ãƒƒãƒˆã®æŠ½è±¡åŒ–ã¯ã€ã„ãã¤ã‹ã®ç‚¹ã§é€šå¸¸ã® "
"OSãƒ¬ãƒ™ãƒ«ã®ã‚½ã‚±ãƒƒãƒˆã®ä»•æ§˜ã‹ã‚‰é€¸è„±ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ç‰¹ã« :ref:`ãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã‚½ã‚±ãƒƒãƒˆã«ã¤ã„ã¦ã®æ³¨é‡ˆ <ssl-nonblocking>` "
"ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:1091
msgid ""
"Instances of :class:`SSLSocket` must be created using the "
":meth:`SSLContext.wrap_socket` method."
msgstr ""

#: ../../library/ssl.rst:1094
msgid "The :meth:`sendfile` method was added."
msgstr ":meth:`sendfile` ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:1097
msgid ""
"The :meth:`shutdown` does not reset the socket timeout each time bytes are "
"received or sent. The socket timeout is now to maximum total duration of the"
" shutdown."
msgstr ""
":meth:`shutdown` "
"ã¯ã€ãƒã‚¤ãƒˆãŒé€å—ä¿¡ã•ã‚Œã‚‹ãŸã³ã«ã‚½ã‚±ãƒƒãƒˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã›ã‚“ã€‚ã‚½ã‚±ãƒƒãƒˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¯ã€ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³ã®æœ€å¤§åˆè¨ˆæ™‚é–“ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:1102
msgid ""
"It is deprecated to create a :class:`SSLSocket` instance directly, use "
":meth:`SSLContext.wrap_socket` to wrap a socket."
msgstr ""
":class:`SSLSocket` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç›´æ¥ä½œæˆã™ã‚‹ã“ã¨ã¯éæ¨å¥¨ã§ã™ã€‚ã‚½ã‚±ãƒƒãƒˆã‚’ãƒ©ãƒƒãƒ—ã™ã‚‹ãŸã‚ã« "
":meth:`SSLContext.wrap_socket` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:1106
msgid ""
":class:`SSLSocket` instances must to created with "
":meth:`~SSLContext.wrap_socket`. In earlier versions, it was possible to "
"create instances directly. This was never documented or officially "
"supported."
msgstr ""

#: ../../library/ssl.rst:1112
msgid "SSL sockets also have the following additional methods and attributes:"
msgstr "SSL ã‚½ã‚±ãƒƒãƒˆã«ã¯ã€ä»¥ä¸‹ã«ç¤ºã™è¿½åŠ ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨å±æ€§ã‚‚ã‚ã‚Šã¾ã™:"

#: ../../library/ssl.rst:1116
msgid ""
"Read up to *len* bytes of data from the SSL socket and return the result as "
"a ``bytes`` instance. If *buffer* is specified, then read into the buffer "
"instead, and return the number of bytes read."
msgstr ""
"SSL ã‚½ã‚±ãƒƒãƒˆã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã® *len* ãƒã‚¤ãƒˆã¾ã§ã‚’èª­ã¿å‡ºã—ã€èª­ã¿å‡ºã—ãŸçµæœã‚’ ``bytes`` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§è¿”ã—ã¾ã™ã€‚ *buffer* "
"ã‚’æŒ‡å®šã™ã‚‹ã¨ã€çµæœã¯ä»£ã‚ã‚Šã« buffer ã«èª­ã¿è¾¼ã¾ã‚Œã€èª­ã¿è¾¼ã‚“ã ãƒã‚¤ãƒˆæ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1120
msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is "
":ref:`non-blocking <ssl-nonblocking>` and the read would block."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆãŒ :ref:`non-blocking <ssl-nonblocking>` ã§èª­ã¿å‡ºã—ãŒãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹ã¨ã€ "
":exc:`SSLWantReadError` ã‚‚ã—ãã¯ :exc:`SSLWantWriteError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:1123
msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`read` can also"
" cause write operations."
msgstr "å†ãƒã‚´ã‚·ã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ãŒã„ã¤ã§ã‚‚å¯èƒ½ãªã®ã§ã€ :meth:`read`  ã®å‘¼ã³å‡ºã—ã¯æ›¸ãè¾¼ã¿æ“ä½œã‚‚å¼•ãèµ·ã“ã—ãˆã¾ã™ã€‚"

#: ../../library/ssl.rst:1126
msgid ""
"The socket timeout is no more reset each time bytes are received or sent. "
"The socket timeout is now to maximum total duration to read up to *len* "
"bytes."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¯ã€ãƒã‚¤ãƒˆãŒé€å—ä¿¡ã•ã‚Œã‚‹ãŸã³ã«ãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã›ã‚“ã€‚ã‚½ã‚±ãƒƒãƒˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¯ã€æœ€å¤§ *len* "
"ãƒã‚¤ãƒˆã‚’èª­ã‚€ã®ã«ã‹ã‹ã‚‹æœ€å¤§åˆè¨ˆæ™‚é–“ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:1131
msgid "Use :meth:`~SSLSocket.recv` instead of :meth:`~SSLSocket.read`."
msgstr ":meth:`~SSLSocket.read` ã®ä»£ã‚ã‚Šã« :meth:`~SSLSocket.recv` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:1136
msgid ""
"Write *buf* to the SSL socket and return the number of bytes written. The "
"*buf* argument must be an object supporting the buffer interface."
msgstr ""
"*buf* ã‚’ SSL ã‚½ã‚±ãƒƒãƒˆã«æ›¸ãè¾¼ã¿ã€æ›¸ãè¾¼ã‚“ã ãƒã‚¤ãƒˆæ•°ã‚’è¿”ã—ã¾ã™ã€‚ *buf* "
"å¼•æ•°ã¯ãƒãƒƒãƒ•ã‚¡ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:1139
msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is "
":ref:`non-blocking <ssl-nonblocking>` and the write would block."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆãŒ :ref:`non-blocking <ssl-nonblocking>` ã§æ›¸ãè¾¼ã¿ãŒãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹ã¨ã€ "
":exc:`SSLWantReadError` ã‚‚ã—ãã¯ :exc:`SSLWantWriteError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:1142
msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`write` can "
"also cause read operations."
msgstr "å†ãƒã‚´ã‚·ã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ãŒã„ã¤ã§ã‚‚å¯èƒ½ãªã®ã§ã€ :meth:`write`  ã®å‘¼ã³å‡ºã—ã¯èª­ã¿å‡ºã—æ“ä½œã‚‚å¼•ãèµ·ã“ã—ãˆã¾ã™ã€‚"

#: ../../library/ssl.rst:1145
msgid ""
"The socket timeout is no more reset each time bytes are received or sent. "
"The socket timeout is now to maximum total duration to write *buf*."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¯ã€ãƒã‚¤ãƒˆãŒé€å—ä¿¡ã•ã‚Œã‚‹ãŸã³ã«ãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã›ã‚“ã€‚ã‚½ã‚±ãƒƒãƒˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¯ã€*buf* "
"ã‚’æ›¸ãè¾¼ã‚€ã®ã«ã‹ã‹ã‚‹æœ€å¤§åˆè¨ˆæ™‚é–“ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:1149
msgid "Use :meth:`~SSLSocket.send` instead of :meth:`~SSLSocket.write`."
msgstr ":meth:`~SSLSocket.write` ã®ä»£ã‚ã‚Šã« :meth:`~SSLSocket.send` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:1154
msgid ""
"The :meth:`~SSLSocket.read` and :meth:`~SSLSocket.write` methods are the "
"low-level methods that read and write unencrypted, application-level data "
"and decrypt/encrypt it to encrypted, wire-level data. These methods require "
"an active SSL connection, i.e. the handshake was completed and "
":meth:`SSLSocket.unwrap` was not called."
msgstr ""
":meth:`~SSLSocket.read`, :meth:`~SSLSocket.write` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã¯ä¸‹ä½ãƒ¬ãƒ™ãƒ«ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚ã‚Šã€æš—å·åŒ–ã•ã‚Œã¦ã„ãªã„ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¬ãƒ™ãƒ«ã®ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿æ›¸ãã—ã€ãã‚Œã‚’å¾©å·/æš—å·åŒ–ã—ã¦æš—å·åŒ–ã•ã‚ŒãŸæ›¸ãè¾¼ã¿ãƒ¬ãƒ™ãƒ«ã®ãƒ‡ãƒ¼ã‚¿ã«ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãª"
" SSL æ¥ç¶šã¤ã¾ã‚Šã€ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ãŒå®Œäº†ã—ã¦ã„ã¦ã€ :meth:`SSLSocket.unwrap` ãŒå‘¼ã°ã‚Œã¦ã„ãªã„ã“ã¨ã‚’å¿…è¦ã¨ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1160
msgid ""
"Normally you should use the socket API methods like "
":meth:`~socket.socket.recv` and :meth:`~socket.socket.send` instead of these"
" methods."
msgstr ""
"é€šå¸¸ã¯ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ä»£ã‚ã‚Šã« :meth:`~socket.socket.recv` ã‚„ :meth:`~socket.socket.send` "
"ã®ã‚ˆã†ãªã‚½ã‚±ãƒƒãƒˆ API ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã†ã¹ãã§ã™ã€‚"

#: ../../library/ssl.rst:1166
msgid "Perform the SSL setup handshake."
msgstr "SSL ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã®ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1168
msgid ""
"The handshake method also performs :func:`match_hostname` when the "
":attr:`~SSLContext.check_hostname` attribute of the socket's "
":attr:`~SSLSocket.context` is true."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã® :attr:`~SSLSocket.context` ã®å±æ€§ :attr:`~SSLContext.check_hostname` "
"ãŒçœŸã®å ´åˆã«ã€ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ãƒ¡ã‚½ãƒƒãƒ‰ãŒ :func:`match_hostname` ã‚’å®Ÿè¡Œã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:1173
msgid ""
"The socket timeout is no more reset each time bytes are received or sent. "
"The socket timeout is now to maximum total duration of the handshake."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¯ã€ãƒã‚¤ãƒˆãŒé€å—ä¿¡ã•ã‚Œã‚‹ãŸã³ã«ãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã›ã‚“ã€‚ã‚½ã‚±ãƒƒãƒˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¯ã€ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã«ã‹ã‹ã‚‹æœ€å¤§åˆè¨ˆæ™‚é–“ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:1177
msgid ""
"Hostname or IP address is matched by OpenSSL during handshake. The function "
":func:`match_hostname` is no longer used. In case OpenSSL refuses a hostname"
" or IP address, the handshake is aborted early and a TLS alert message is "
"send to the peer."
msgstr ""

#: ../../library/ssl.rst:1185
msgid ""
"If there is no certificate for the peer on the other end of the connection, "
"return ``None``.  If the SSL handshake hasn't been done yet, raise "
":exc:`ValueError`."
msgstr ""
"æ¥ç¶šå…ˆã«è¨¼æ˜æ›¸ãŒç„¡ã„å ´åˆã€ ``None`` ã‚’è¿”ã—ã¾ã™ã€‚SSL ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ãŒã¾ã è¡Œã‚ã‚Œã¦ã„ãªã„å ´åˆã¯ã€ :exc:`ValueError` "
"ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:1189
msgid ""
"If the ``binary_form`` parameter is :const:`False`, and a certificate was "
"received from the peer, this method returns a :class:`dict` instance.  If "
"the certificate was not validated, the dict is empty.  If the certificate "
"was validated, it returns a dict with several keys, amongst them ``subject``"
" (the principal for which the certificate was issued) and ``issuer`` (the "
"principal issuing the certificate).  If a certificate contains an instance "
"of the *Subject Alternative Name* extension (see :rfc:`3280`), there will "
"also be a ``subjectAltName`` key in the dictionary."
msgstr ""
"``binary_form`` ãŒ :const:`False` ã§æ¥ç¶šå…ˆã‹ã‚‰è¨¼æ˜æ›¸ã‚’å–å¾—ã—ãŸå ´åˆã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :class:`dict` "
"ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚è¨¼æ˜æ›¸ãŒèªè¨¼ã•ã‚Œã¦ã„ãªã„å ´åˆã€è¾æ›¸ã¯ç©ºã§ã™ã€‚è¨¼æ˜æ›¸ãŒèªè¨¼ã•ã‚Œã¦ã„ãŸå ´åˆã„ãã¤ã‹ã®ã‚­ãƒ¼ã‚’æŒã£ãŸè¾æ›¸ã‚’è¿”ã—ã€ "
"``subject`` (è¨¼æ˜æ›¸ãŒç™ºè¡Œã•ã‚ŒãŸ principal), ``issuer`` (è¨¼æ˜æ›¸ã‚’ç™ºè¡Œã—ãŸ principal) "
"ã‚’å«ã¿ã¾ã™ã€‚è¨¼æ˜æ›¸ãŒ *Subject Alternative Name* æ‹¡å¼µ(:rfc:`3280` ã‚’å‚ç…§)ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ ¼ç´ã—ã¦ã„ãŸå ´åˆã€ "
"``subjectAltName`` ã‚­ãƒ¼ã‚‚è¾æ›¸ã«å«ã¾ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:1198
msgid ""
"The ``subject`` and ``issuer`` fields are tuples containing the sequence of "
"relative distinguished names (RDNs) given in the certificate's data "
"structure for the respective fields, and each RDN is a sequence of name-"
"value pairs.  Here is a real-world example::"
msgstr ""
"``subject``, ``issuer`` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ã€è¨¼æ˜æ›¸ã®ãã‚Œãã‚Œã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã¤ã„ã¦ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ä¸ãˆã‚‰ã‚Œã‚‹ RDN (relative "
"distinguishued name) ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’æ ¼ç´ã—ãŸã‚¿ãƒ—ãƒ«ã§ã€å„ RDN ã¯ name-value "
"ãƒšã‚¢ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã™ã€‚ç¾å®Ÿä¸–ç•Œã§ã®ä¾‹ã‚’ãŠè¦‹ã›ã—ã¾ã™::"

#: ../../library/ssl.rst:1224
msgid ""
"To validate a certificate for a particular service, you can use the "
":func:`match_hostname` function."
msgstr "ç‰¹å®šã®ã‚µãƒ¼ãƒ“ã‚¹ã®ãŸã‚ã«è¨¼æ˜æ›¸ã®æ¤œè¨¼ãŒã—ãŸã‘ã‚Œã°ã€ :func:`match_hostname` é–¢æ•°ã‚’ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:1227
msgid ""
"If the ``binary_form`` parameter is :const:`True`, and a certificate was "
"provided, this method returns the DER-encoded form of the entire certificate"
" as a sequence of bytes, or :const:`None` if the peer did not provide a "
"certificate.  Whether the peer provides a certificate depends on the SSL "
"socket's role:"
msgstr ""
"``binary_form`` å¼•æ•°ãŒ :const:`True` "
"ã ã£ãŸå ´åˆã€è¨¼æ˜æ›¸ãŒæ¸¡ã•ã‚Œã¦ã„ã‚Œã°ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯DERã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸè¨¼æ˜æ›¸å…¨ä½“ã‚’ãƒã‚¤ãƒˆåˆ—ã¨ã—ã¦è¿”ã—ã€æ¥ç¶šå…ˆãŒè¨¼æ˜æ›¸ã‚’æç¤ºã—ãªã‹ã£ãŸå ´åˆã¯ "
":const:`None` ã‚’è¿”ã—ã¾ã™ã€‚æ¥ç¶šå…ˆãŒè¨¼æ˜æ›¸ã‚’æä¾›ã™ã‚‹ã‹ã©ã†ã‹ã¯ SSL ã‚½ã‚±ãƒƒãƒˆã®å½¹å‰²ã«ä¾å­˜ã—ã¾ã™:"

#: ../../library/ssl.rst:1233
msgid ""
"for a client SSL socket, the server will always provide a certificate, "
"regardless of whether validation was required;"
msgstr "ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ SSL ã‚½ã‚±ãƒƒãƒˆã§ã¯ã€èªè¨¼ãŒè¦æ±‚ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã«é–¢ã‚ã‚‰ãšã€ã‚µãƒ¼ãƒã¯å¸¸ã«è¨¼æ˜æ›¸ã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1236
msgid ""
"for a server SSL socket, the client will only provide a certificate when "
"requested by the server; therefore :meth:`getpeercert` will return "
":const:`None` if you used :const:`CERT_NONE` (rather than "
":const:`CERT_OPTIONAL` or :const:`CERT_REQUIRED`)."
msgstr ""
"ã‚µãƒ¼ãƒ SSL ã‚½ã‚±ãƒƒãƒˆã§ã¯ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ã‚µãƒ¼ãƒã«ã‚ˆã£ã¦èªè¨¼ãŒè¦æ±‚ã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã®ã¿è¨¼æ˜æ›¸ã‚’æä¾›ã—ã¾ã™ã€‚ã—ãŸãŒã£ã¦ã€ "
"(:const:`CERT_OPTIONAL` ã‚„ :const:`CERT_REQUIRED` ã§ã¯ãªã) :const:`CERT_NONE` "
"ã‚’ä½¿ç”¨ã—ãŸå ´åˆ :meth:`getpeercert` ã¯ :const:`None` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1241
msgid ""
"The returned dictionary includes additional items such as ``issuer`` and "
"``notBefore``."
msgstr "è¿”ã•ã‚Œã‚‹è¾æ›¸ã« ``issuer``, ``notBefore`` ã®ã‚ˆã†ãªè¿½åŠ ã‚¢ã‚¤ãƒ†ãƒ ã‚’å«ã‚€ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:1245
msgid ""
":exc:`ValueError` is raised when the handshake isn't done. The returned "
"dictionary includes additional X509v3 extension items   such as "
"``crlDistributionPoints``, ``caIssuers`` and ``OCSP`` URIs."
msgstr ""
"ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ãŒæ¸ˆã‚“ã§ã„ãªã‘ã‚Œã° :exc:`ValueError` ã‚’æŠ•ã’ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚è¿”ã•ã‚Œã‚‹è¾æ›¸ã« "
"``crlDistributionPoints``, ``caIssuers``, ``OCSP`` URI ã®ã‚ˆã†ãª X509v3 "
"æ‹¡å¼µã‚¢ã‚¤ãƒ†ãƒ ã‚’å«ã‚€ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:1252
msgid ""
"Returns a three-value tuple containing the name of the cipher being used, "
"the version of the SSL protocol that defines its use, and the number of "
"secret bits being used.  If no connection has been established, returns "
"``None``."
msgstr ""
"åˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹æš—å·ã®åå‰ã€ãã®æš—å·ã®åˆ©ç”¨ã‚’å®šç¾©ã—ã¦ã„ã‚‹SSLãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã€åˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹éµã®bité•·ã®3ã¤ã®å€¤ã‚’å«ã‚€ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚ã‚‚ã—æ¥ç¶šãŒç¢ºç«‹ã•ã‚Œã¦ã„ãªã„å ´åˆã€"
" ``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1258
msgid ""
"Return the list of ciphers shared by the client during the handshake.  Each "
"entry of the returned list is a three-value tuple containing the name of the"
" cipher, the version of the SSL protocol that defines its use, and the "
"number of secret bits the cipher uses.  :meth:`~SSLSocket.shared_ciphers` "
"returns ``None`` if no connection has been established or the socket is a "
"client socket."
msgstr ""
"ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ä¸­ã«ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ã‚ˆã‚Šå…±æœ‰ã•ã‚Œã‚‹æš—å·æ–¹å¼ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚è¿”ã•ã‚Œã‚‹ãƒªã‚¹ãƒˆã®å„è¦ç´ ã¯ "
"3ã¤ã®å€¤ã‚’å«ã‚€ã‚¿ãƒ—ãƒ«ã§ã€ãã®å€¤ã¯ãã‚Œãã‚Œã€æš—å·æ–¹å¼ã®åå‰ã€ãã®æš—å·ã®åˆ©ç”¨ã‚’å®šç¾©ã—ã¦ã„ã‚‹ SSL "
"ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã€æš—å·ã§ä½¿ç”¨ã•ã‚Œã‚‹ç§˜å¯†éµã®ãƒ“ãƒƒãƒˆé•·ã§ã™ã€‚æ¥ç¶šãŒç¢ºç«‹ã•ã‚Œã¦ã„ãªã„ã‹ã€ã‚½ã‚±ãƒƒãƒˆãŒã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚½ã‚±ãƒƒãƒˆã§ã‚ã‚‹å ´åˆã€meth:`~SSLSocket.shared_ciphers`"
" ã¯ ``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1269
msgid ""
"Return the compression algorithm being used as a string, or ``None`` if the "
"connection isn't compressed."
msgstr "ä½¿ã‚ã‚Œã¦ã„ã‚‹åœ§ç¸®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’æ–‡å­—åˆ—ã§è¿”ã—ã¾ã™ã€‚æ¥ç¶šãŒåœ§ç¸®ã•ã‚Œã¦ã„ãªã‘ã‚Œã° ``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1272
msgid ""
"If the higher-level protocol supports its own compression mechanism, you can"
" use :data:`OP_NO_COMPRESSION` to disable SSL-level compression."
msgstr ""
"ä¸Šä½ãƒ¬ãƒ™ãƒ«ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãŒè‡ªèº«ã§åœ§ç¸®ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å ´åˆã€SSL ãƒ¬ãƒ™ãƒ«ã§ã®åœ§ç¸®ã‚’ :data:`OP_NO_COMPRESSION` "
"ã‚’ä½¿ã£ã¦ç„¡åŠ¹ã«ã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:1279
msgid ""
"Get channel binding data for current connection, as a bytes object.  Returns"
" ``None`` if not connected or the handshake has not been completed."
msgstr ""
"ç¾åœ¨ã®æ¥ç¶šã«ãŠã‘ã‚‹ãƒãƒ£ãƒãƒ«ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¾ã™ã€‚æœªæ¥ç¶šã‚ã‚‹ã„ã¯ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ãŒå®Œäº†ã—ã¦ã„ãªã‘ã‚Œã° ``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1282
msgid ""
"The *cb_type* parameter allow selection of the desired channel binding type."
" Valid channel binding types are listed in the :data:`CHANNEL_BINDING_TYPES`"
" list.  Currently only the 'tls-unique' channel binding, defined by "
":rfc:`5929`, is supported.  :exc:`ValueError` will be raised if an "
"unsupported channel binding type is requested."
msgstr ""
"*cb_type* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«ã‚ˆã‚Šã€æœ›ã¿ã®ãƒãƒ£ãƒãƒ«ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã®ã‚¿ã‚¤ãƒ—ã‚’é¸æŠã§ãã¾ã™ã€‚ãƒãƒ£ãƒãƒ«ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã®ã‚¿ã‚¤ãƒ—ã®å¦¥å½“ãªã‚‚ã®ã¯ "
":data:`CHANNEL_BINDING_TYPES` ã§ãƒªã‚¹ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚ç¾åœ¨ã®ã¨ã“ã‚ã¯ :rfc:`5929` ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ 'tls-"
"unique' ã®ã¿ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚æœªã‚µãƒãƒ¼ãƒˆã®ãƒãƒ£ãƒãƒ«ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã®ã‚¿ã‚¤ãƒ—ãŒè¦æ±‚ã•ã‚ŒãŸå ´åˆã€ :exc:`ValueError` "
"ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1292
msgid ""
"Return the protocol that was selected during the TLS handshake.  If "
":meth:`SSLContext.set_alpn_protocols` was not called, if the other party "
"does not support ALPN, if this socket does not support any of the client's "
"proposed protocols, or if the handshake has not happened yet, ``None`` is "
"returned."
msgstr ""
"TLS ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã§é¸æŠã•ã‚ŒãŸãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚ :meth:`SSLContext.set_alpn_protocols` "
"ãŒå‘¼ã°ã‚Œã¦ã„ãªã„å ´åˆã€ç›¸æ‰‹å´ãŒ ALPN "
"ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„å ´åˆã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒææ¡ˆã—ãŸãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ã©ã‚Œã‚‚ã‚½ã‚±ãƒƒãƒˆãŒã‚µãƒãƒ¼ãƒˆã—ãªã„å ´åˆã€ã‚ã‚‹ã„ã¯ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ãŒã¾ã è¡Œã‚ã‚Œã¦ã„ãªã„å ´åˆã«ã¯ã€ "
"``None`` ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:1302
msgid ""
"Return the higher-level protocol that was selected during the TLS/SSL "
"handshake. If :meth:`SSLContext.set_npn_protocols` was not called, or if the"
" other party does not support NPN, or if the handshake has not yet happened,"
" this will return ``None``."
msgstr ""
"TLS/SSL ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã§é¸æŠã•ã‚ŒãŸä¸Šä½ãƒ¬ãƒ™ãƒ«ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚ :meth:`SSLContext.set_npn_protocols` "
"ãŒå‘¼ã°ã‚Œã¦ã„ãªã„å ´åˆã€ç›¸æ‰‹å´ãŒ NPN ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„å ´åˆã€ã‚ã‚‹ã„ã¯ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ãŒã¾ã è¡Œã‚ã‚Œã¦ã„ãªã„å ´åˆã«ã¯ã€ ``None`` ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:1311
msgid ""
"Performs the SSL shutdown handshake, which removes the TLS layer from the "
"underlying socket, and returns the underlying socket object.  This can be "
"used to go from encrypted operation over a connection to unencrypted.  The "
"returned socket should always be used for further communication with the "
"other side of the connection, rather than the original socket."
msgstr ""
"SSLã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚ã“ã‚Œã¯ä¸‹ä½ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚½ã‚±ãƒƒãƒˆã‹ã‚‰TLSãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å–ã‚Šé™¤ãã€ä¸‹ä½ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯æš—å·åŒ–ã•ã‚ŒãŸã‚ªãƒšãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‹ã‚‰æš—å·åŒ–ã•ã‚Œã¦ã„ãªã„æ¥ç¶šã«ç§»è¡Œã™ã‚‹ã¨ãã«åˆ©ç”¨ã•ã‚Œã¾ã™ã€‚ä»¥é™ã®é€šä¿¡ã«ã¯ã€ã‚ªãƒªã‚¸ãƒŠãƒ«ã®ã‚½ã‚±ãƒƒãƒˆã§ã¯ãªãã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¿”ã—ãŸã‚½ã‚±ãƒƒãƒˆã®ã¿ã‚’åˆ©ç”¨ã™ã‚‹ã¹ãã§ã™ã€‚"

#: ../../library/ssl.rst:1319
msgid ""
"Requests post-handshake authentication (PHA) from a TLS 1.3 client. PHA can "
"only be initiated for a TLS 1.3 connection from a server-side socket, after "
"the initial TLS handshake and with PHA enabled on both sides, see "
":attr:`SSLContext.post_handshake_auth`."
msgstr ""

#: ../../library/ssl.rst:1324
msgid ""
"The method does not perform a cert exchange immediately. The server-side "
"sends a CertificateRequest during the next write event and expects the "
"client to respond with a certificate on the next read event."
msgstr ""

#: ../../library/ssl.rst:1328
msgid ""
"If any precondition isn't met (e.g. not TLS 1.3, PHA not enabled), an "
":exc:`SSLError` is raised."
msgstr ""

#: ../../library/ssl.rst:1334
msgid ""
"Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3 "
"support, the method raises :exc:`NotImplementedError`."
msgstr ""

#: ../../library/ssl.rst:1339
msgid ""
"Return the actual SSL protocol version negotiated by the connection as a "
"string, or ``None`` is no secure connection is established. As of this "
"writing, possible return values include ``\"SSLv2\"``, ``\"SSLv3\"``, "
"``\"TLSv1\"``, ``\"TLSv1.1\"`` and ``\"TLSv1.2\"``. Recent OpenSSL versions "
"may define more return values."
msgstr ""
"ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã«ã‚ˆã£ã¦å®Ÿéš›ã«ãƒã‚´ã‚·ã‚¨ã‚¤ãƒˆã•ã‚ŒãŸ SSL ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’æ–‡å­—åˆ—ã§ã€ã¾ãŸã¯ã€ã‚»ã‚­ãƒ¥ã‚¢ãªã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãŒç¢ºç«‹ã—ã¦ã„ãªã‘ã‚Œã° "
"``None`` ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã‚’æ›¸ã„ã¦ã„ã‚‹æ™‚ç‚¹ã§ã¯ã€ ``\"SSLv2\"``, ``\"SSLv3\"``, ``\"TLSv1\"``, "
"``\"TLSv1.1\"``, ``\"TLSv1.2\"`` ãªã©ãŒè¿”ã‚Šã¾ã™ã€‚æœ€æ–°ã® OpenSSL ã¯ã‚‚ã£ã¨è‰²ã€…ãªå€¤ã‚’å®šç¾©ã—ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:1349
msgid ""
"Returns the number of already decrypted bytes available for read, pending on"
" the connection."
msgstr "æ¥ç¶šã«ãŠã„ã¦æ—¢ã«å¾©å·æ¸ˆã¿ã§èª­ã¿å‡ºã—å¯èƒ½ã§ä¿ç•™ã«ãªã£ã¦ã„ã‚‹ãƒã‚¤ãƒˆåˆ—ã®æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1354
msgid ""
"The :class:`SSLContext` object this SSL socket is tied to.  If the SSL "
"socket was created using the deprecated :func:`wrap_socket` function (rather"
" than :meth:`SSLContext.wrap_socket`), this is a custom context object "
"created for this SSL socket."
msgstr ""

#: ../../library/ssl.rst:1363
msgid ""
"A boolean which is ``True`` for server-side sockets and ``False`` for "
"client-side sockets."
msgstr "ã‚µãƒ¼ãƒã‚µã‚¤ãƒ‰ã®ã‚½ã‚±ãƒƒãƒˆã«å¯¾ã—ã¦ ``True`` ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã®ã‚½ã‚±ãƒƒãƒˆã«å¯¾ã—ã¦ ``False`` ã¨ãªã‚‹çœŸå½å€¤ã§ã™ã€‚"

#: ../../library/ssl.rst:1370
msgid ""
"Hostname of the server: :class:`str` type, or ``None`` for server-side "
"socket or if the hostname was not specified in the constructor."
msgstr ""
"ã‚µãƒ¼ãƒã®ãƒ›ã‚¹ãƒˆå: :class:`str` å‹ã€ã¾ãŸã¯ã‚µãƒ¼ãƒã‚µã‚¤ãƒ‰ã®ã‚½ã‚±ãƒƒãƒˆã®å ´åˆã¨ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ hostname ãŒæŒ‡å®šã•ã‚Œãªã‹ã£ãŸå ´åˆã¯ "
"``None``"

#: ../../library/ssl.rst:1375
msgid ""
"The attribute is now always ASCII text. When ``server_hostname`` is an "
"internationalized domain name (IDN), this attribute now stores the A-label "
"form (``\"xn--pythn-mua.org\"``), rather than the U-label form "
"(``\"pythÃ¶n.org\"``)."
msgstr ""

#: ../../library/ssl.rst:1383
msgid ""
"The :class:`SSLSession` for this SSL connection. The session is available "
"for client and server side sockets after the TLS handshake has been "
"performed. For client sockets the session can be set before "
":meth:`~SSLSocket.do_handshake` has been called to reuse a session."
msgstr ""
"ã“ã® SSL æ¥ç¶šã«å¯¾ã™ã‚‹ :class:`SSLSession` ã§ã™ã€‚ã“ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã¯ã€TLS "
"ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã®å®Ÿè¡Œå¾Œã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã¨ã‚µãƒ¼ãƒã‚µã‚¤ãƒ‰ã®ã‚½ã‚±ãƒƒãƒˆã§ä½¿ç”¨ã§ãã¾ã™ã€‚ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚½ã‚±ãƒƒãƒˆã§ã¯ã€ã“ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ "
":meth:`~SSLSocket.do_handshake` ãŒå‘¼ã°ã‚Œã‚‹å‰ã«è¨­å®šã—ã¦ã€ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’å†åˆ©ç”¨ã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:1396
msgid "SSL Contexts"
msgstr "SSL ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ"

#: ../../library/ssl.rst:1400
msgid ""
"An SSL context holds various data longer-lived than single SSL connections, "
"such as SSL configuration options, certificate(s) and private key(s). It "
"also manages a cache of SSL sessions for server-side sockets, in order to "
"speed up repeated connections from the same clients."
msgstr ""
"SSL ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¯ã€SSL æ§‹æˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ã€è¨¼æ˜æ›¸(ç¾¤)ã‚„ç§˜å¯†éµ(ç¾¤)ãªã©ã®ã‚ˆã†ãªã€ä¸€å›ã® SSL "
"æ¥ç¶šã‚ˆã‚Šã‚‚é•·ç”Ÿãã™ã‚‹ã•ã¾ã–ã¾ãªãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒã—ã¾ã™ã€‚ã“ã‚Œã¯ã‚µãƒ¼ãƒã‚µã‚¤ãƒ‰ã‚½ã‚±ãƒƒãƒˆã® SSL "
"ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚‚ç®¡ç†ã—ã€åŒã˜ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã®ç¹°ã‚Šè¿”ã—ã®æ¥ç¶šæ™‚ã®é€Ÿåº¦å‘ä¸Šã«ä¸€å½¹è²·ã„ã¾ã™ã€‚"

#: ../../library/ssl.rst:1407
msgid ""
"Create a new SSL context.  You may pass *protocol* which must be one of the "
"``PROTOCOL_*`` constants defined in this module.  The parameter specifies "
"which version of the SSL protocol to use.  Typically, the server chooses a "
"particular protocol version, and the client must adapt to the server's "
"choice.  Most of the versions are not interoperable with the other versions."
"  If not specified, the default is :data:`PROTOCOL_TLS`; it provides the "
"most compatibility with other versions."
msgstr ""

#: ../../library/ssl.rst:1416
msgid ""
"Here's a table showing which versions in a client (down the side) can "
"connect to which versions in a server (along the top):"
msgstr "æ¬¡ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ã€ã©ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒã©ã®ã‚µãƒ¼ãƒã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«æ¥ç¶šã§ãã‚‹ã‹ã‚’ç¤ºã—ã¦ã„ã¾ã™:"

#: ../../library/ssl.rst:1422
msgid "*client* / **server**"
msgstr "*client* / **server**"

#: ../../library/ssl.rst:1422
msgid "**SSLv2**"
msgstr "**SSLv2**"

#: ../../library/ssl.rst:1422
msgid "**SSLv3**"
msgstr "**SSLv3**"

#: ../../library/ssl.rst:1422
msgid "**TLS** [3]_"
msgstr ""

#: ../../library/ssl.rst:1422
msgid "**TLSv1**"
msgstr "**TLSv1**"

#: ../../library/ssl.rst:1422
msgid "**TLSv1.1**"
msgstr "**TLSv1.1**"

#: ../../library/ssl.rst:1422
msgid "**TLSv1.2**"
msgstr "**TLSv1.2**"

#: ../../library/ssl.rst:1424
msgid "*SSLv2*"
msgstr "*SSLv2*"

#: ../../library/ssl.rst:1424 ../../library/ssl.rst:1425
#: ../../library/ssl.rst:1426 ../../library/ssl.rst:1426
#: ../../library/ssl.rst:1426 ../../library/ssl.rst:1426
#: ../../library/ssl.rst:1427 ../../library/ssl.rst:1427
#: ../../library/ssl.rst:1428 ../../library/ssl.rst:1428
#: ../../library/ssl.rst:1429 ../../library/ssl.rst:1429
msgid "yes"
msgstr "yes"

#: ../../library/ssl.rst:1424 ../../library/ssl.rst:1424
#: ../../library/ssl.rst:1424 ../../library/ssl.rst:1424
#: ../../library/ssl.rst:1425 ../../library/ssl.rst:1425
#: ../../library/ssl.rst:1425 ../../library/ssl.rst:1425
#: ../../library/ssl.rst:1427 ../../library/ssl.rst:1427
#: ../../library/ssl.rst:1427 ../../library/ssl.rst:1427
#: ../../library/ssl.rst:1428 ../../library/ssl.rst:1428
#: ../../library/ssl.rst:1428 ../../library/ssl.rst:1428
#: ../../library/ssl.rst:1429 ../../library/ssl.rst:1429
#: ../../library/ssl.rst:1429 ../../library/ssl.rst:1429
msgid "no"
msgstr "no"

#: ../../library/ssl.rst:1424 ../../library/ssl.rst:1426
msgid "no [1]_"
msgstr "no [1]_"

#: ../../library/ssl.rst:1425
msgid "*SSLv3*"
msgstr "*SSLv3*"

#: ../../library/ssl.rst:1425 ../../library/ssl.rst:1426
msgid "no [2]_"
msgstr "no [2]_"

#: ../../library/ssl.rst:1426
msgid "*TLS* (*SSLv23*) [3]_"
msgstr ""

#: ../../library/ssl.rst:1427
msgid "*TLSv1*"
msgstr "*TLSv1*"

#: ../../library/ssl.rst:1428
msgid "*TLSv1.1*"
msgstr "*TLSv1.1*"

#: ../../library/ssl.rst:1429
msgid "*TLSv1.2*"
msgstr "*TLSv1.2*"

#: ../../library/ssl.rst:1432
msgid "Footnotes"
msgstr "è„šæ³¨"

#: ../../library/ssl.rst:1433
msgid ""
":class:`SSLContext` disables SSLv2 with :data:`OP_NO_SSLv2` by default."
msgstr ""
":class:`SSLContext` ã§ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ :data:`OP_NO_SSLv2` ã«ã‚ˆã‚ŠSSLv2 ãŒç„¡åŠ¹ã«ãªã£ã¦ã„ã¾ã™ã€‚"

#: ../../library/ssl.rst:1434
msgid ""
":class:`SSLContext` disables SSLv3 with :data:`OP_NO_SSLv3` by default."
msgstr ""
":class:`SSLContext` ã§ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ :data:`OP_NO_SSLv3` ã«ã‚ˆã‚Š SSLv3 ãŒç„¡åŠ¹ã«ãªã£ã¦ã„ã¾ã™ã€‚"

#: ../../library/ssl.rst:1435
msgid ""
"TLS 1.3 protocol will be available with :data:`PROTOCOL_TLS` in OpenSSL >= "
"1.1.1. There is no dedicated PROTOCOL constant for just TLS 1.3."
msgstr ""

#: ../../library/ssl.rst:1440
msgid ""
":func:`create_default_context` lets the :mod:`ssl` module choose security "
"settings for a given purpose."
msgstr ""
":func:`create_default_context` ã¯ :mod:`ssl` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã€ç›®çš„ã«åˆã£ãŸã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®šã‚’é¸ã°ã›ã¾ã™ã€‚"

#: ../../library/ssl.rst:1445
msgid ""
"The context is created with secure default values. The options "
":data:`OP_NO_COMPRESSION`, :data:`OP_CIPHER_SERVER_PREFERENCE`, "
":data:`OP_SINGLE_DH_USE`, :data:`OP_SINGLE_ECDH_USE`, :data:`OP_NO_SSLv2` "
"(except for :data:`PROTOCOL_SSLv2`), and :data:`OP_NO_SSLv3` (except for "
":data:`PROTOCOL_SSLv3`) are set by default. The initial cipher suite list "
"contains only ``HIGH`` ciphers, no ``NULL`` ciphers and no ``MD5`` ciphers "
"(except for :data:`PROTOCOL_SSLv2`)."
msgstr ""
"ã“ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¯ã€å®‰å…¨æ€§ã®é«˜ã„ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã§ä½œæˆã•ã‚Œã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã•ã‚Œã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ã€ :data:`OP_NO_COMPRESSION`, "
":data:`OP_CIPHER_SERVER_PREFERENCE`, :data:`OP_SINGLE_DH_USE`, "
":data:`OP_SINGLE_ECDH_USE`, :data:`OP_NO_SSLv2` (:data:`PROTOCOL_SSLv2` ä»¥å¤–),"
" :data:`OP_NO_SSLv3` (:data:`PROTOCOL_SSLv3` ä»¥å¤–) ã§ã™ã€‚åˆæœŸã®æš—å·æ–¹å¼ã‚¹ã‚¤ãƒ¼ãƒˆãƒªã‚¹ãƒˆã«ã¯ "
"``HIGH`` æš—å·ã®ã¿ãŒå«ã¾ã‚Œã¦ãŠã‚Šã€ ``NULL`` æš—å·ãŠã‚ˆã³ ``MD5`` æš—å·ã¯å«ã¾ã‚Œã¾ã›ã‚“ "
"(:data:`PROTOCOL_SSLv2` ä»¥å¤–)ã€‚"

#: ../../library/ssl.rst:1455
msgid ":class:`SSLContext` objects have the following methods and attributes:"
msgstr ":class:`SSLContext` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨å±æ€§ã‚’æŒã£ã¦ã„ã¾ã™:"

#: ../../library/ssl.rst:1459
msgid ""
"Get statistics about quantities of loaded X.509 certificates, count of X.509"
" certificates flagged as CA certificates and certificate revocation lists as"
" dictionary."
msgstr ""
"ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸ X.509 è¨¼æ˜æ›¸ã®æ•°ã€CA è¨¼æ˜æ›¸ã§æ´»æ€§ã® X.509 è¨¼æ˜æ›¸ã®æ•°ã€è¨¼æ˜æ›¸å¤±åŠ¹ãƒªã‚¹ãƒˆã®æ•°ã€ã«ã¤ã„ã¦ã®çµ±è¨ˆæƒ…å ±ã‚’è¾æ›¸ã¨ã—ã¦å–å¾—ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1463
msgid "Example for a context with one CA cert and one other cert::"
msgstr "ä¸€ã¤ã® CA ã¨ä»–ã®ä¸€ã¤ã®è¨¼æ˜æ›¸ã‚’æŒã£ãŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ã®ä¾‹ã§ã™::"

#: ../../library/ssl.rst:1473
msgid ""
"Load a private key and the corresponding certificate.  The *certfile* string"
" must be the path to a single file in PEM format containing the certificate "
"as well as any number of CA certificates needed to establish the "
"certificate's authenticity.  The *keyfile* string, if present, must point to"
" a file containing the private key in.  Otherwise the private key will be "
"taken from *certfile* as well.  See the discussion of :ref:`ssl-"
"certificates` for more information on how the certificate is stored in the "
"*certfile*."
msgstr ""
"ç§˜å¯†éµã¨å¯¾å¿œã™ã‚‹è¨¼æ˜æ›¸ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚ *certfile* ã¯ã€è¨¼æ˜æ›¸ã¨ã€è¨¼æ˜æ›¸èªè¨¼ã§å¿…è¦ã¨ã•ã‚Œã‚‹ä»»æ„ã®æ•°ã® CA è¨¼æ˜æ›¸ã‚’å«ã‚€ã€PEM "
"ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ *keyfile* "
"æ–‡å­—åˆ—ã‚’æŒ‡å®šã™ã‚‹å ´åˆã€ç§˜å¯†éµãŒå«ã¾ã‚Œã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ‡ã™ã‚‚ã®ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚æŒ‡å®šã—ãªã„å ´åˆã€ç§˜å¯†éµã‚‚ *certfile* ã‹ã‚‰å–å¾—ã•ã‚Œã¾ã™ã€‚ "
"*certfile* ã¸ã®è¨¼æ˜æ›¸ã®æ ¼ç´ã«ã¤ã„ã¦ã®è©³ç´°ã¯ã€ :ref:`ssl-certificates` ã®è­°è«–ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:1482
msgid ""
"The *password* argument may be a function to call to get the password for "
"decrypting the private key.  It will only be called if the private key is "
"encrypted and a password is necessary.  It will be called with no arguments,"
" and it should return a string, bytes, or bytearray.  If the return value is"
" a string it will be encoded as UTF-8 before using it to decrypt the key. "
"Alternatively a string, bytes, or bytearray value may be supplied directly "
"as the *password* argument.  It will be ignored if the private key is not "
"encrypted and no password is needed."
msgstr ""
"*password* "
"å¼•æ•°ã«ã€ç§˜å¯†éµã‚’å¾©å·ã™ã‚‹ãŸã‚ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’è¿”ã™é–¢æ•°ã‚’ä¸ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãã®é–¢æ•°ã¯ç§˜å¯†éµãŒæš—å·åŒ–ã•ã‚Œã¦ã„ã¦ã€ãªãŠã‹ã¤ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒå¿…è¦ãªå ´åˆã«ã®ã¿å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ãã®é–¢æ•°ã¯å¼•æ•°ãªã—ã§å‘¼ã³å‡ºã•ã‚Œã€string,"
" bytes, ã¾ãŸã¯ bytearray ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚æˆ»ã‚Šå€¤ãŒ string ã®å ´åˆã¯éµã‚’å¾©å·åŒ–ã™ã‚‹ã®ã«ä½¿ã†å‰ã« UTF-8 "
"ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚Œã¾ã™ã€‚string ã®ä»£ã‚ã‚Šã« bytes ã‚„ bytearray ã‚’è¿”ã—ãŸå ´åˆã¯ *password* "
"å¼•æ•°ã«ç›´æ¥ä¾›çµ¦ã•ã‚Œã¾ã™ã€‚ç§˜å¯†éµãŒæš—å·åŒ–ã•ã‚Œã¦ã„ãªã‹ã£ãŸã‚Šãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å¿…è¦ã¨ã—ãªã„å ´åˆã¯ã€æŒ‡å®šã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:1491
msgid ""
"If the *password* argument is not specified and a password is required, "
"OpenSSL's built-in password prompting mechanism will be used to "
"interactively prompt the user for a password."
msgstr ""
"*password* ãŒä¸ãˆã‚‰ã‚Œãšã€ãã—ã¦ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒå¿…è¦ãªå ´åˆã«ã¯ã€OpenSSL "
"çµ„ã¿è¾¼ã¿ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å•ã„åˆã‚ã›ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ãŒã€ãƒ¦ãƒ¼ã‚¶ã«å¯¾è©±çš„ã«ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å•ã„åˆã‚ã›ã¾ã™ã€‚"

#: ../../library/ssl.rst:1495
msgid ""
"An :class:`SSLError` is raised if the private key doesn't match with the "
"certificate."
msgstr "ç§˜å¯†éµãŒè¨¼æ˜æ›¸ã«åˆè‡´ã—ãªã‘ã‚Œã°ã€ :class:`SSLError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:1498
msgid "New optional argument *password*."
msgstr "æ–°ã—ã„ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *password*ã€‚"

#: ../../library/ssl.rst:1503
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from "
"default locations. On Windows it loads CA certs from the ``CA`` and ``ROOT``"
" system stores. On other systems it calls "
":meth:`SSLContext.set_default_verify_paths`. In the future the method may "
"load CA certificates from other locations, too."
msgstr ""
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å ´æ‰€ã‹ã‚‰ \"èªè¨¼å±€\" (CA=certification authority) è¨¼æ˜æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ä¸€å¼ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚Windows "
"ã§ã¯ã€CA è¨¼æ˜æ›¸ã¯ã‚·ã‚¹ãƒ†ãƒ è¨˜æ†¶åŸŸã® ``CA`` ã¨ ``ROOT`` ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚ãã‚Œä»¥å¤–ã®ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€ã“ã®é–¢æ•°ã¯ "
":meth:`SSLContext.set_default_verify_paths` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚å°†æ¥çš„ã«ã¯ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ä»–ã®å ´æ‰€ã‹ã‚‰ã‚‚ CA "
"è¨¼æ˜æ›¸ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:1509
msgid ""
"The *purpose* flag specifies what kind of CA certificates are loaded. The "
"default settings :data:`Purpose.SERVER_AUTH` loads certificates, that are "
"flagged and trusted for TLS web server authentication (client side sockets)."
" :data:`Purpose.CLIENT_AUTH` loads CA certificates for client certificate "
"verification on the server side."
msgstr ""
"*purpose* ãƒ•ãƒ©ã‚°ã§ã©ã®ç¨®é¡ã® CA è¨¼æ˜æ›¸ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã‹ã‚’æŒ‡å®šã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® :data:`Purpose.SERVER_AUTH` ã¯"
" TLS web ã‚µãƒ¼ãƒã®èªè¨¼ã®ãŸã‚ã«æ´»æ€§ã‹ã¤ä¿¡é ¼ã•ã‚ŒãŸè¨¼æ˜æ›¸ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™(ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã®ã‚½ã‚±ãƒƒãƒˆ)ã€‚ "
":data:`Purpose.CLIENT_AUTH` ã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆè¨¼æ˜æ›¸ã®æ­£å½“æ€§æ¤œè¨¼ã‚’ã‚µãƒ¼ãƒã‚µã‚¤ãƒ‰ã§è¡Œã†ãŸã‚ã® CA è¨¼æ˜æ›¸ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1519
msgid ""
"Load a set of \"certification authority\" (CA) certificates used to validate"
" other peers' certificates when :data:`verify_mode` is other than "
":data:`CERT_NONE`.  At least one of *cafile* or *capath* must be specified."
msgstr ""
":data:`verify_mode` ãŒ :data:`CERT_NONE` ã§ãªã„å ´åˆã«æ¥ç¶šå…ˆã®è¨¼æ˜æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ã®æ­£å½“æ€§æ¤œè¨¼ã«ä½¿ã‚ã‚Œã‚‹ \"èªè¨¼å±€\""
" (CA=certification authority) è¨¼æ˜æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ä¸€å¼ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚å°‘ãªãã¨ã‚‚ *cafile* ã‹ *capath* "
"ã®ã©ã¡ã‚‰ã‹ã¯æŒ‡å®šã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:1523
msgid ""
"This method can also load certification revocation lists (CRLs) in PEM or "
"DER format. In order to make use of CRLs, :attr:`SSLContext.verify_flags` "
"must be configured properly."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ PEM ã¾ãŸã¯ DER ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®è¨¼æ˜æ›¸å¤±åŠ¹ãƒªã‚¹ãƒˆ (CRLs=certification revocation "
"lists)ã‚‚ãƒ­ãƒ¼ãƒ‰ã§ãã¾ã™ã€‚CRLs ã®ãŸã‚ã«ä½¿ã†ã«ã¯ã€ :attr:`SSLContext.verify_flags` "
"ã‚’é©åˆ‡ã«è¨­å®šã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:1527
msgid ""
"The *cafile* string, if present, is the path to a file of concatenated CA "
"certificates in PEM format. See the discussion of :ref:`ssl-certificates` "
"for more information about how to arrange the certificates in this file."
msgstr ""
"*cafile* ã‚’æŒ‡å®šã™ã‚‹å ´åˆã¯ã€PEM ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§ CA "
"è¨¼æ˜æ›¸ãŒçµåˆã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«å†…ã§è¨¼æ˜æ›¸ã‚’ã©ã®ã‚ˆã†ã«ç·¨æˆã™ã‚Œã°è‰¯ã„ã®ã‹ã«ã¤ã„ã¦ã®è©³ã—ã„æƒ…å ±ã«ã¤ã„ã¦ã¯ã€ :ref"
":`ssl-certificates` ã®è­°è«–ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:1532
msgid ""
"The *capath* string, if present, is the path to a directory containing "
"several CA certificates in PEM format, following an `OpenSSL specific layout"
" "
"<https://www.openssl.org/docs/manmaster/man3/SSL_CTX_load_verify_locations.html>`_."
msgstr ""

#: ../../library/ssl.rst:1537
msgid ""
"The *cadata* object, if present, is either an ASCII string of one or more "
"PEM-encoded certificates or a :term:`bytes-like object` of DER-encoded "
"certificates. Like with *capath* extra lines around PEM-encoded certificates"
" are ignored but at least one certificate must be present."
msgstr ""
"*cadata* ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡å®šã™ã‚‹å ´åˆã¯ã€PEM ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã®è¨¼æ˜æ›¸ä¸€ã¤ä»¥ä¸Šã® ASCII æ–‡å­—åˆ—ã‹ã€DER ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã®è¨¼æ˜æ›¸ã® :term"
":`bytes-like object` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã©ã¡ã‚‰ã‹ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚PEM "
"ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã®è¨¼æ˜æ›¸ã®å‘¨å›²ã®ä½™åˆ†ãªè¡Œã¯ç„¡è¦–ã•ã‚Œã¾ã™ãŒã€å°‘ãªãã¨ã‚‚ä¸€ã¤ã®è¨¼æ˜æ›¸ãŒå«ã¾ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/ssl.rst:1542
msgid "New optional argument *cadata*"
msgstr "æ–°ã—ã„ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *cadata* ã€‚"

#: ../../library/ssl.rst:1547
msgid ""
"Get a list of loaded \"certification authority\" (CA) certificates. If the "
"``binary_form`` parameter is :const:`False` each list entry is a dict like "
"the output of :meth:`SSLSocket.getpeercert`. Otherwise the method returns a "
"list of DER-encoded certificates. The returned list does not contain "
"certificates from *capath* unless a certificate was requested and loaded by "
"a SSL connection."
msgstr ""
"ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸ \"èªè¨¼å±€\" (CA=certification authority) è¨¼æ˜æ›¸ã®ãƒªã‚¹ãƒˆã‚’å–å¾—ã—ã¾ã™ã€‚ ``binary_form`` "
"å¼•æ•°ãŒ :const:`False` ã§ã‚ã‚‹å ´åˆã€ãƒªã‚¹ãƒˆã®ãã‚Œãã‚Œã®ã‚¨ãƒ³ãƒˆãƒªã¯ :meth:`SSLSocket.getpeercert` "
"ãŒå‡ºåŠ›ã™ã‚‹ã‚ˆã†ãªè¾æ›¸ã«ãªã‚Šã¾ã™ã€‚True ã§ã‚ã‚‹å ´åˆã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€DER ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰å½¢å¼ã®è¨¼æ˜æ›¸ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚è¿”å´ã•ã‚Œã‚‹ãƒªã‚¹ãƒˆã«ã¯ã€ SSL "
"æ¥ç¶šã«ã‚ˆã£ã¦è¨¼æ˜æ›¸ãŒãƒªã‚¯ã‚¨ã‚¹ãƒˆãŠã‚ˆã³ãƒ­ãƒ¼ãƒ‰ã•ã‚Œãªã„é™ã‚Šã€ *capath* ã‹ã‚‰ã®è¨¼æ˜æ›¸ã¯å«ã¾ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:1555
msgid ""
"Certificates in a capath directory aren't loaded unless they have been used "
"at least once."
msgstr "capath ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã®è¨¼æ˜æ›¸ã¯ä¸€åº¦ã§ã‚‚ä½¿ã‚ã‚Œãªã„é™ã‚Šã¯ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:1562
msgid ""
"Get a list of enabled ciphers. The list is in order of cipher priority. See "
":meth:`SSLContext.set_ciphers`."
msgstr ""
"æœ‰åŠ¹ãªæš—å·åŒ–ã®ãƒªã‚¹ãƒˆã‚’å–å¾—ã—ã¾ã™ã€‚ãƒªã‚¹ãƒˆã¯æš—å·åŒ–å„ªå…ˆåº¦é †ã«ä¸¦ã³ã¾ã™ã€‚:meth:`SSLContext.set_ciphers` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:1585
msgid "On OpenSSL 1.1 and newer the cipher dict contains additional fields::"
msgstr "OpenSSL 1.1 ä»¥é™ã§ã¯ã€æš—å·åŒ–è¾æ›¸ã«ä»¥ä¸‹ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:1613
msgid "Availability: OpenSSL 1.0.2+"
msgstr "åˆ©ç”¨å¯èƒ½ãªç’°å¢ƒ: OpenSSL 1.0.2+"

#: ../../library/ssl.rst:1619
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from a "
"filesystem path defined when building the OpenSSL library.  Unfortunately, "
"there's no easy way to know whether this method succeeds: no error is "
"returned if no certificates are to be found.  When the OpenSSL library is "
"provided as part of the operating system, though, it is likely to be "
"configured properly."
msgstr ""
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® \"èªè¨¼å±€\" (CA=certification authority) è¨¼æ˜æ›¸ã‚’ã€OpenSSL "
"ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒãƒ“ãƒ«ãƒ‰ã•ã‚ŒãŸéš›ã«å®šç¾©ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ä¸Šã®ãƒ‘ã‚¹ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚æ®‹å¿µãªãŒã‚‰ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒæˆåŠŸã—ãŸã‹ã©ã†ã‹ã‚’çŸ¥ã‚‹ãŸã‚ã®ç°¡å˜ãªæ–¹æ³•ã¯ã‚ã‚Šã¾ã›ã‚“:"
" è¨¼æ˜æ›¸ãŒè¦‹ã¤ã‹ã‚‰ãªãã¦ã‚‚ã‚¨ãƒ©ãƒ¼ã¯è¿”ã‚Šã¾ã›ã‚“ã€‚OpenSSL "
"ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã®ä¸€éƒ¨ã¨ã—ã¦æä¾›ã•ã‚Œã¦ã„ã‚‹éš›ã«ã¯ã©ã†ã‚„ã‚‰é©åˆ‡ã«æ§‹æˆã§ãã‚‹ã‚ˆã†ã§ã™ãŒã€‚"

#: ../../library/ssl.rst:1628
msgid ""
"Set the available ciphers for sockets created with this context. It should "
"be a string in the `OpenSSL cipher list format "
"<https://www.openssl.org/docs/manmaster/man1/ciphers.html>`_. If no cipher "
"can be selected (because compile-time options or other configuration forbids"
" use of all the specified ciphers), an :class:`SSLError` will be raised."
msgstr ""

#: ../../library/ssl.rst:1636
msgid ""
"when connected, the :meth:`SSLSocket.cipher` method of SSL sockets will give"
" the currently selected cipher."
msgstr "æ¥ç¶šæ™‚ã« SSL ã‚½ã‚±ãƒƒãƒˆã® :meth:`SSLSocket.cipher` ãƒ¡ã‚½ãƒƒãƒ‰ãŒã€ç¾åœ¨é¸æŠã•ã‚Œã¦ã„ã‚‹ãã®æš—å·ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../library/ssl.rst:1639
msgid ""
"OpenSSL 1.1.1 has TLS 1.3 cipher suites enabled by default. The suites "
"cannot be disabled with :meth:`~SSLContext.set_ciphers`."
msgstr ""

#: ../../library/ssl.rst:1644
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of ASCII strings, like ``['http/1.1', "
"'spdy/2']``, ordered by preference. The selection of a protocol will happen "
"during the handshake, and will play out according to :rfc:`7301`. After a "
"successful handshake, the :meth:`SSLSocket.selected_alpn_protocol` method "
"will return the agreed-upon protocol."
msgstr ""
"SSL/TLS ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯æ™‚ã«ã‚½ã‚±ãƒƒãƒˆãŒæç¤ºã™ã¹ããƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’æŒ‡å®šã—ã¾ã™ã€‚ ``['http/1.1', 'spdy/2']`` "
"ã®ã‚ˆã†ãªæ¨å¥¨é †ã«ä¸¦ã¹ãŸ ASCII æ–‡å­—åˆ—ã®ãƒªã‚¹ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®é¸æŠã¯ :rfc:`7301` "
"ã«å¾“ã„ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ä¸­ã«è¡Œã‚ã‚Œã¾ã™ã€‚ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ãŒæ­£å¸¸ã«çµ‚äº†ã—ãŸå¾Œã€ :meth:`SSLSocket.selected_alpn_protocol`"
" ãƒ¡ã‚½ãƒƒãƒ‰ã¯åˆæ„ã•ã‚ŒãŸãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1651
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_ALPN` is "
"False."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :data:`HAS_ALPN` ãŒå½ã®å ´åˆ :exc:`NotImplementedError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1654
msgid ""
"OpenSSL 1.1.0 to 1.1.0e will abort the handshake and raise :exc:`SSLError` "
"when both sides support ALPN but cannot agree on a protocol. 1.1.0f+ behaves"
" like 1.0.2, :meth:`SSLSocket.selected_alpn_protocol` returns None."
msgstr ""

#: ../../library/ssl.rst:1662
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of strings, like ``['http/1.1', 'spdy/2']``, "
"ordered by preference. The selection of a protocol will happen during the "
"handshake, and will play out according to the `Application Layer Protocol "
"Negotiation <https://en.wikipedia.org/wiki/Application-"
"Layer_Protocol_Negotiation>`_. After a successful handshake, the "
":meth:`SSLSocket.selected_npn_protocol` method will return the agreed-upon "
"protocol."
msgstr ""

#: ../../library/ssl.rst:1670
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_NPN` is "
"False."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :data:`HAS_NPN` ãŒå½ã®å ´åˆ :exc:`NotImplementedError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1677
msgid ""
"Register a callback function that will be called after the TLS Client Hello "
"handshake message has been received by the SSL/TLS server when the TLS "
"client specifies a server name indication. The server name indication "
"mechanism is specified in :rfc:`6066` section 3 - Server Name Indication."
msgstr ""
"TLS ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒã‚µãƒ¼ãƒåè¡¨ç¤ºã‚’æŒ‡å®šã—ãŸéš›ã®ã€SSL/TLS ã‚µãƒ¼ãƒã«ã‚ˆã£ã¦ TLS Client Hello "
"ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒå—ã‘å–ã‚‰ã‚ŒãŸã‚ã¨ã§å‘¼ã³å‡ºã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’ç™»éŒ²ã—ã¾ã™ã€‚ã‚µãƒ¼ãƒåè¡¨ç¤ºãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã¯ :rfc:`6066` ã‚»ã‚¯ã‚·ãƒ§ãƒ³ 3 "
"- Server Name Indication ã§è¿°ã¹ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/ssl.rst:1682
msgid ""
"Only one callback can be set per ``SSLContext``.  If *sni_callback* is set "
"to ``None`` then the callback is disabled. Calling this function a "
"subsequent time will disable the previously registered callback."
msgstr ""

#: ../../library/ssl.rst:1686
msgid ""
"The callback function will be called with three arguments; the first being "
"the :class:`ssl.SSLSocket`, the second is a string that represents the "
"server name that the client is intending to communicate (or :const:`None` if"
" the TLS Client Hello does not contain a server name) and the third argument"
" is the original :class:`SSLContext`. The server name argument is text. For "
"internationalized domain name, the server name is an IDN A-label (``\"xn"
"--pythn-mua.org\"``)."
msgstr ""

#: ../../library/ssl.rst:1694
msgid ""
"A typical use of this callback is to change the :class:`ssl.SSLSocket`'s "
":attr:`SSLSocket.context` attribute to a new object of type "
":class:`SSLContext` representing a certificate chain that matches the server"
" name."
msgstr ""
"ã“ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®å…¸å‹çš„ãªåˆ©ç”¨æ–¹æ³•ã¯ã€ :class:`ssl.SSLSocket` ã® :attr:`SSLSocket.context` "
"å±æ€§ã‚’ã€ã‚µãƒ¼ãƒåã«åˆè‡´ã™ã‚‹è¨¼æ˜æ›¸ãƒã‚§ã‚¤ãƒ³ã‚’æŒã¤æ–°ã—ã„ :class:`SSLContext` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›´ã™ã‚‹ã“ã¨ã§ã™ã€‚"

#: ../../library/ssl.rst:1699
msgid ""
"Due to the early negotiation phase of the TLS connection, only limited "
"methods and attributes are usable like "
":meth:`SSLSocket.selected_alpn_protocol` and :attr:`SSLSocket.context`. "
":meth:`SSLSocket.getpeercert`, :meth:`SSLSocket.getpeercert`, "
":meth:`SSLSocket.cipher` and :meth:`SSLSocket.compress` methods require that"
" the TLS connection has progressed beyond the TLS Client Hello and therefore"
" will not contain return meaningful values nor can they be called safely."
msgstr ""
"TLS æ¥ç¶šã®åˆæœŸãƒã‚´ã‚·ã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ•ã‚§ãƒ¼ã‚ºãªã®ã§ã€ :meth:`SSLSocket.selected_alpn_protocol`, "
":attr:`SSLSocket.context` ã®ã‚ˆã†ãªé™ã‚‰ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã¨å±æ€§ã®ã¿ä½¿ãˆã¾ã™ã€‚ "
":meth:`SSLSocket.getpeercert`, :meth:`SSLSocket.getpeercert`, "
":meth:`SSLSocket.cipher`, :meth:`SSLSocket.compress` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ TLS æ¥ç¶šãŒ TLS "
"Client Hello ã‚ˆã‚Šã‚‚å…ˆã«é€²è¡Œã—ã¦ã„ã‚‹ã“ã¨ã‚’å¿…è¦ã¨ã—ã¾ã™ã‹ã‚‰ã€ã“ã‚Œã‚‰ã¯æ„å‘³ã®ã‚ã‚‹å€¤ã‚’è¿”ã—ã¾ã›ã‚“ã—ã€å®‰å…¨ã«å‘¼ã³å‡ºã™ã“ã¨ã‚‚ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:1707
msgid ""
"The *sni_callback* function must return ``None`` to allow the TLS "
"negotiation to continue.  If a TLS failure is required, a constant "
":const:`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>` can be "
"returned.  Other return values will result in a TLS fatal error with "
":const:`ALERT_DESCRIPTION_INTERNAL_ERROR`."
msgstr ""

#: ../../library/ssl.rst:1713
msgid ""
"If an exception is raised from the *sni_callback* function the TLS "
"connection will terminate with a fatal TLS alert message "
":const:`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`."
msgstr ""

#: ../../library/ssl.rst:1717
msgid ""
"This method will raise :exc:`NotImplementedError` if the OpenSSL library had"
" OPENSSL_NO_TLSEXT defined when it was built."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ OpenSSL ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒ OPENSSL_NO_TLSEXT ã‚’å®šç¾©ã—ã¦ãƒ“ãƒ«ãƒ‰ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ "
":exc:`NotImplementedError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1724
msgid ""
"This is a legacy API retained for backwards compatibility. When possible, "
"you should use :attr:`sni_callback` instead. The given "
"*server_name_callback* is similar to *sni_callback*, except that when the "
"server hostname is an IDN-encoded internationalized domain name, the "
"*server_name_callback* receives a decoded U-label (``\"pythÃ¶n.org\"``)."
msgstr ""

#: ../../library/ssl.rst:1730
msgid ""
"If there is an decoding error on the server name, the TLS connection will "
"terminate with an :const:`ALERT_DESCRIPTION_INTERNAL_ERROR` fatal TLS alert "
"message to the client."
msgstr ""

#: ../../library/ssl.rst:1738
msgid ""
"Load the key generation parameters for Diffie-Hellman (DH) key exchange. "
"Using DH key exchange improves forward secrecy at the expense of "
"computational resources (both on the server and on the client). The *dhfile*"
" parameter should be the path to a file containing DH parameters in PEM "
"format."
msgstr ""

#: ../../library/ssl.rst:1744
msgid ""
"This setting doesn't apply to client sockets.  You can also use the "
":data:`OP_SINGLE_DH_USE` option to further improve security."
msgstr ""
"ã“ã®è¨­å®šã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚½ã‚±ãƒƒãƒˆã«ã¯é©ç”¨ã•ã‚Œã¾ã›ã‚“ã€‚ã•ã‚‰ã«ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’æ”¹å–„ã™ã‚‹ã®ã« :data:`OP_SINGLE_DH_USE` "
"ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚‚åˆ©ç”¨ã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:1751
msgid ""
"Set the curve name for Elliptic Curve-based Diffie-Hellman (ECDH) key "
"exchange.  ECDH is significantly faster than regular DH while arguably as "
"secure.  The *curve_name* parameter should be a string describing a well-"
"known elliptic curve, for example ``prime256v1`` for a widely supported "
"curve."
msgstr ""
"æ¥•å††æ›²ç·šãƒ‡ã‚£ãƒ•ã‚£ãƒ¼ãƒ»ãƒ˜ãƒ«ãƒãƒ³(ECDH)éµäº¤æ›ã®æ›²ç·šåã‚’æŒ‡å®šã—ã¾ã™ã€‚ECDH ã¯ã‚‚ã¨ã® DH "
"ã«è¼ƒã¹ã¦ã€ã»ã¼é–“é•ã„ãªãåŒç¨‹åº¦ã«å®‰å…¨ã§ã‚ã‚‹ä¸€æ–¹ã§ã€é¡•è‘—ã«é«˜é€Ÿã§ã™ã€‚ *curve_name* "
"ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯æ—¢çŸ¥ã®æ¥•å††æ›²ç·šã‚’è¡¨ã™æ–‡å­—åˆ—ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ä¾‹ãˆã° ``prime256v1`` ãŒåºƒãã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹æ›²ç·šã§ã™ã€‚"

#: ../../library/ssl.rst:1757
msgid ""
"This setting doesn't apply to client sockets.  You can also use the "
":data:`OP_SINGLE_ECDH_USE` option to further improve security."
msgstr ""
"ã“ã®è¨­å®šã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚½ã‚±ãƒƒãƒˆã«ã¯é©ç”¨ã•ã‚Œã¾ã›ã‚“ã€‚ã•ã‚‰ã«ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’æ”¹å–„ã™ã‚‹ã®ã« :data:`OP_SINGLE_ECDH_USE` "
"ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚‚åˆ©ç”¨ã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:1760
msgid "This method is not available if :data:`HAS_ECDH` is ``False``."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :data:`HAS_ECDH` ãŒ ``False`` ã®å ´åˆã¯åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:1765
msgid ""
"`SSL/TLS & Perfect Forward Secrecy <https://vincent.bernat.im/en/blog/2011"
"-ssl-perfect-forward-secrecy>`_"
msgstr ""

#: ../../library/ssl.rst:1766
msgid "Vincent Bernat."
msgstr "Vincent Bernat."

#: ../../library/ssl.rst:1772
msgid ""
"Wrap an existing Python socket *sock* and return an instance of "
":attr:`SSLContext.sslsocket_class` (default :class:`SSLSocket`). The "
"returned SSL socket is tied to the context, its settings and certificates. "
"*sock* must be a :data:`~socket.SOCK_STREAM` socket; other socket types are "
"unsupported."
msgstr ""

#: ../../library/ssl.rst:1778
msgid ""
"The parameter ``server_side`` is a boolean which identifies whether server-"
"side or client-side behavior is desired from this socket."
msgstr "``server_side`` å¼•æ•°ã¯çœŸå½å€¤ã§ã€ã“ã®ã‚½ã‚±ãƒƒãƒˆãŒã‚µãƒ¼ãƒã‚µã‚¤ãƒ‰ã¨ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã®ã©ã¡ã‚‰ã®å‹•ä½œã‚’ã™ã‚‹ã®ã‹ã‚’æŒ‡å®šã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1781
msgid ""
"For client-side sockets, the context construction is lazy; if the underlying"
" socket isn't connected yet, the context construction will be performed "
"after :meth:`connect` is called on the socket.  For server-side sockets, if "
"the socket has no remote peer, it is assumed to be a listening socket, and "
"the server-side SSL wrapping is automatically performed on client "
"connections accepted via the :meth:`accept` method. The method may raise "
":exc:`SSLError`."
msgstr ""

#: ../../library/ssl.rst:1789
msgid ""
"On client connections, the optional parameter *server_hostname* specifies "
"the hostname of the service which we are connecting to.  This allows a "
"single server to host multiple SSL-based services with distinct "
"certificates, quite similarly to HTTP virtual hosts. Specifying "
"*server_hostname* will raise a :exc:`ValueError` if *server_side* is true."
msgstr ""
"ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã®æ¥ç¶šã§ã¯ã€ *server_hostname* ã§æ¥ç¶šå…ˆã‚µãƒ¼ãƒ“ã‚¹ã®ãƒ›ã‚¹ãƒˆåã‚’æŒ‡å®šã§ãã¾ã™ã€‚ã“ã‚Œã¯ HTTP "
"ãƒãƒ¼ãƒãƒ£ãƒ«ãƒ›ã‚¹ãƒˆã«ã‹ãªã‚Šä¼¼ã¦ã€ã‚·ãƒ³ã‚°ãƒ«ã‚µãƒ¼ãƒã§è¤‡æ•°ã® SSL ãƒ™ãƒ¼ã‚¹ã®ã‚µãƒ¼ãƒ“ã‚¹ã‚’åˆ¥ã€…ã®è¨¼æ˜æ›¸ã§ãƒ›ã‚¹ãƒˆã—ã¦ã„ã‚‹ã‚ˆã†ãªã‚µãƒ¼ãƒã«å¯¾ã—ã¦ä½¿ãˆã¾ã™ã€‚ "
"*server_side* ãŒ True ã®å ´åˆã« *server_hostname* ã‚’æŒ‡å®šã™ã‚‹ã¨ :exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1795
msgid ""
"The parameter ``do_handshake_on_connect`` specifies whether to do the SSL "
"handshake automatically after doing a :meth:`socket.connect`, or whether the"
" application program will call it explicitly, by invoking the "
":meth:`SSLSocket.do_handshake` method.  Calling "
":meth:`SSLSocket.do_handshake` explicitly gives the program control over the"
" blocking behavior of the socket I/O involved in the handshake."
msgstr ""
"``do_handshake_on_connect`` å¼•æ•°ã¯ã€ :meth:`socket.connect` ã®å¾Œã«è‡ªå‹•çš„ã« "
"SSLãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã‚’è¡Œã†ã‹ã€ãã‚Œã¨ã‚‚ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒæ˜ç¤ºçš„ã« :meth:`SSLSocket.do_handshake` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã‹ã‚’æŒ‡å®šã—ã¾ã™ã€‚ :meth:`SSLSocket.do_handshake` "
"ã‚’æ˜ç¤ºçš„ã«å‘¼ã³ã ã™ã“ã¨ã§ã€ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã«ã‚ˆã‚‹ã‚½ã‚±ãƒƒãƒˆI/Oã®ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°å‹•ä½œã‚’åˆ¶å¾¡ã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:1802
msgid ""
"The parameter ``suppress_ragged_eofs`` specifies how the "
":meth:`SSLSocket.recv` method should signal unexpected EOF from the other "
"end of the connection.  If specified as :const:`True` (the default), it "
"returns a normal EOF (an empty bytes object) in response to unexpected EOF "
"errors raised from the underlying socket; if :const:`False`, it will raise "
"the exceptions back to the caller."
msgstr ""
"``suppress_ragged_eofs`` å¼•æ•°ã¯ã€ :meth:`SSLSocket.recv` ãƒ¡ã‚½ãƒƒãƒ‰ãŒã€æ¥ç¶šå…ˆã‹ã‚‰äºˆæœŸã—ãªã„EOF "
"ã‚’å—ã‘å–ã£ãŸæ™‚ã«é€šçŸ¥ã™ã‚‹æ–¹æ³•ã‚’æŒ‡å®šã—ã¾ã™ã€‚ :const:`True` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) "
"ã®å ´åˆã€ä¸‹ä½ã®ã‚½ã‚±ãƒƒãƒˆãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰äºˆæœŸã›ã¬EOFã‚¨ãƒ©ãƒ¼ãŒæ¥ãŸå ´åˆã€é€šå¸¸ã®EOF (ç©ºã®ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ)ã‚’è¿”ã—ã¾ã™ã€‚ :const:`False` "
"ã®å ´åˆã€å‘¼ã³å‡ºã—å…ƒã«ä¾‹å¤–ã‚’æŠ•ã’ã¦é€šçŸ¥ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1809
msgid "*session*, see :attr:`~SSLSocket.session`."
msgstr "*session*, :attr:`~SSLSocket.session` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:1811
msgid ""
"Always allow a server_hostname to be passed, even if OpenSSL does not have "
"SNI."
msgstr "OpenSSL ãŒ SNI ã‚’ã‚µãƒãƒ¼ãƒˆã—ãªãã¦ã‚‚ server_hostname ã‚’è¨±å®¹ã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:1815 ../../library/ssl.rst:1841
msgid "*session* argument was added."
msgstr "*session* å¼•æ•°ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:1818
msgid ""
"The method returns on instance of :attr:`SSLContext.sslsocket_class` instead"
" of hard-coded :class:`SSLSocket`."
msgstr ""

#: ../../library/ssl.rst:1824
msgid ""
"The return type of :meth:`SSLContext.wrap_sockets`, defaults to "
":class:`SSLSocket`. The attribute can be overridden on instance of class in "
"order to return a custom subclass of :class:`SSLSocket`."
msgstr ""

#: ../../library/ssl.rst:1833
msgid ""
"Wrap the BIO objects *incoming* and *outgoing* and return an instance of "
"attr:`SSLContext.sslobject_class` (default :class:`SSLObject`). The SSL "
"routines will read input data from the incoming BIO and write data to the "
"outgoing BIO."
msgstr ""

#: ../../library/ssl.rst:1838
msgid ""
"The *server_side*, *server_hostname* and *session* parameters have the same "
"meaning as in :meth:`SSLContext.wrap_socket`."
msgstr ""
"*server_side*ã€ *server_hostname* ã€ *session* å¼•æ•°ã¯ã€ "
":meth:`SSLContext.wrap_socket` ã§ã®æ„å‘³ã¨åŒã˜æ„å‘³ã‚’æŒã¡ã¾ã™ã€‚"

#: ../../library/ssl.rst:1844
msgid ""
"The method returns on instance of :attr:`SSLContext.sslobject_class` instead"
" of hard-coded :class:`SSLObject`."
msgstr ""

#: ../../library/ssl.rst:1850
msgid ""
"The return type of :meth:`SSLContext.wrap_bio`, defaults to "
":class:`SSLObject`. The attribute can be overridden on instance of class in "
"order to return a custom subclass of :class:`SSLObject`."
msgstr ""

#: ../../library/ssl.rst:1858
msgid ""
"Get statistics about the SSL sessions created or managed by this context. A "
"dictionary is returned which maps the names of each `piece of information "
"<https://www.openssl.org/docs/man1.1.0/ssl/SSL_CTX_sess_number.html>`_ to "
"their numeric values.  For example, here is the total number of hits and "
"misses in the session cache since the context was created::"
msgstr ""

#: ../../library/ssl.rst:1869
msgid ""
"Whether to match the peer cert's hostname with :func:`match_hostname` in "
":meth:`SSLSocket.do_handshake`. The context's "
":attr:`~SSLContext.verify_mode` must be set to :data:`CERT_OPTIONAL` or "
":data:`CERT_REQUIRED`, and you must pass *server_hostname* to "
":meth:`~SSLContext.wrap_socket` in order to match the hostname.  Enabling "
"hostname checking automatically sets :attr:`~SSLContext.verify_mode` from "
":data:`CERT_NONE` to :data:`CERT_REQUIRED`.  It cannot be set back to "
":data:`CERT_NONE` as long as hostname checking is enabled."
msgstr ""

#: ../../library/ssl.rst:1895
msgid ""
":attr:`~SSLContext.verify_mode` is now automatically changed to "
":data:`CERT_REQUIRED`  when hostname checking is enabled and "
":attr:`~SSLContext.verify_mode` is :data:`CERT_NONE`. Previously the same "
"operation would have failed with a :exc:`ValueError`."
msgstr ""

#: ../../library/ssl.rst:1902
msgid "This features requires OpenSSL 0.9.8f or newer."
msgstr "ã“ã®æ©Ÿèƒ½ã«ã¯OpenSSL0.9.8fä»¥é™ãŒå¿…è¦ã§ã™ã€‚"

#: ../../library/ssl.rst:1906
msgid ""
"A :class:`TLSVersion` enum member representing the highest supported TLS "
"version. The value defaults to :attr:`TLSVersion.MAXIMUM_SUPPORTED`. The "
"attribute is read-only for protocols other than :attr:`PROTOCOL_TLS`, "
":attr:`PROTOCOL_TLS_CLIENT`, and :attr:`PROTOCOL_TLS_SERVER`."
msgstr ""

#: ../../library/ssl.rst:1911
msgid ""
"The attributes :attr:`~SSLContext.maximum_version`, "
":attr:`~SSLContext.minimum_version` and :attr:`SSLContext.options` all "
"affect the supported SSL and TLS versions of the context. The implementation"
" does not prevent invalid combination. For example a context with "
":attr:`OP_NO_TLSv1_2` in :attr:`~SSLContext.options` and "
":attr:`~SSLContext.maximum_version` set to :attr:`TLSVersion.TLSv1_2` will "
"not be able to establish a TLS 1.2 connection."
msgstr ""

#: ../../library/ssl.rst:1922 ../../library/ssl.rst:1932
msgid ""
"This attribute is not available unless the ssl module is compiled with "
"OpenSSL 1.1.0g or newer."
msgstr ""

#: ../../library/ssl.rst:1927
msgid ""
"Like :attr:`SSLContext.maximum_version` except it is the lowest supported "
"version or :attr:`TLSVersion.MINIMUM_SUPPORTED`."
msgstr ""

#: ../../library/ssl.rst:1937
msgid ""
"An integer representing the set of SSL options enabled on this context. The "
"default value is :data:`OP_ALL`, but you can specify other options such as "
":data:`OP_NO_SSLv2` by ORing them together."
msgstr ""
"ã“ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§æœ‰åŠ¹ã«ãªã£ã¦ã„ã‚‹ SSL ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¡¨ã™æ•´æ•°ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å€¤ã¯ :data:`OP_ALL` ã§ã™ãŒã€ "
":data:`OP_NO_SSLv2` ã®ã‚ˆã†ãªä»–ã®å€¤ã‚’ãƒ“ãƒƒãƒˆ OR æ¼”ç®—ã§æŒ‡å®šã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:1942
msgid ""
"With versions of OpenSSL older than 0.9.8m, it is only possible to set "
"options, not to clear them.  Attempting to clear an option (by resetting the"
" corresponding bits) will raise a ``ValueError``."
msgstr ""
"OpenSSL ã® 0.9.8m ã‚ˆã‚Šå¤ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ä½¿ã†å ´åˆã€å€¤ã¯ã‚»ãƒƒãƒˆã¯ã§ãã¾ã™ãŒã‚¯ãƒªã‚¢ãŒã§ãã¾ã›ã‚“ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’ "
"(å¯¾å¿œã™ã‚‹ãƒ“ãƒƒãƒˆã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹ã“ã¨ã§) ã‚¯ãƒªã‚¢ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ ``ValueError`` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:1946
msgid ":attr:`SSLContext.options` returns :class:`Options` flags:"
msgstr ":attr:`SSLContext.options` ã¯æ¬¡ã®ã‚ˆã†ã« :class:`Options` ã®ãƒ•ãƒ©ã‚°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1954
msgid ""
"Enable TLS 1.3 post-handshake client authentication. Post-handshake auth is "
"disabled by default and a server can only request a TLS client certificate "
"during the initial handshake. When enabled, a server may request a TLS "
"client certificate at any time after the handshake."
msgstr ""

#: ../../library/ssl.rst:1959
msgid ""
"When enabled on client-side sockets, the client signals the server that it "
"supports post-handshake authentication."
msgstr ""

#: ../../library/ssl.rst:1962
msgid ""
"When enabled on server-side sockets, :attr:`SSLContext.verify_mode` must be "
"set to :data:`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, too. The actual "
"client cert exchange is delayed until "
":meth:`SSLSocket.verify_client_post_handshake` is called and some I/O is "
"performed."
msgstr ""

#: ../../library/ssl.rst:1971
msgid ""
"Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3 "
"support, the property value is None and can't be modified"
msgstr ""

#: ../../library/ssl.rst:1976
msgid ""
"The protocol version chosen when constructing the context.  This attribute "
"is read-only."
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®æ§‹ç¯‰æ™‚ã«é¸æŠã•ã‚ŒãŸãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã€‚ã“ã®å±æ€§ã¯èª­ã¿å‡ºã—å°‚ç”¨ã§ã™ã€‚"

#: ../../library/ssl.rst:1981
msgid ""
"Whether :attr:`~SSLContext.check_hostname` falls back to verify the cert's "
"subject common name in the absence of a subject alternative name extension "
"(default: true)."
msgstr ""

#: ../../library/ssl.rst:1988
msgid "Only writeable with OpenSSL 1.1.0 or higher."
msgstr ""

#: ../../library/ssl.rst:1992
msgid ""
"The flags for certificate verification operations. You can set flags like "
":data:`VERIFY_CRL_CHECK_LEAF` by ORing them together. By default OpenSSL "
"does neither require nor verify certificate revocation lists (CRLs). "
"Available only with openssl version 0.9.8+."
msgstr ""
"è¨¼æ˜æ›¸ã®æ¤œè¨¼æ“ä½œã®ãŸã‚ã®ãƒ•ãƒ©ã‚°ã§ã™ã€‚ :data:`VERIFY_CRL_CHECK_LEAF` ãªã©ã®ãƒ•ãƒ©ã‚°ã‚’ãƒ“ãƒƒãƒˆ OR "
"æ¼”ç®—ã§ã‚»ãƒƒãƒˆã§ãã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ OpenSSL ã¯è¨¼æ˜æ›¸å¤±åŠ¹ãƒªã‚¹ãƒˆ (CRLs) ã‚’å¿…è¦ã¨ã—ã¾ã›ã‚“ã—æ¤œè¨¼ã«ã‚‚ä½¿ã„ã¾ã›ã‚“ã€‚openssl "
"version 0.9.8+ ã§ã®ã¿åˆ©ç”¨å¯èƒ½ã§ã™ã€‚"

#: ../../library/ssl.rst:1999
msgid ":attr:`SSLContext.verify_flags` returns :class:`VerifyFlags` flags:"
msgstr ""
":attr:`SSLContext.verify_flags` ã¯æ¬¡ã®ã‚ˆã†ã« :class:`VerifyFlags` ã®ãƒ•ãƒ©ã‚°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:2007
msgid ""
"Whether to try to verify other peers' certificates and how to behave if "
"verification fails.  This attribute must be one of :data:`CERT_NONE`, "
":data:`CERT_OPTIONAL` or :data:`CERT_REQUIRED`."
msgstr ""
"æ¥ç¶šå…ˆã®è¨¼æ˜æ›¸ã®æ¤œè¨¼ã‚’è©¦ã¿ã‚‹ã‹ã©ã†ã‹ã€ã¾ãŸã€æ¤œè¨¼ãŒå¤±æ•—ã—ãŸå ´åˆã«ã©ã®ã‚ˆã†ã«æŒ¯èˆã†ã¹ãã‹ã‚’åˆ¶å¾¡ã—ã¾ã™ã€‚ã“ã®å±æ€§ã¯ :data:`CERT_NONE`, "
":data:`CERT_OPTIONAL`, :data:`CERT_REQUIRED` ã®ã†ã¡ã©ã‚Œã‹ä¸€ã¤ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:2011
msgid ":attr:`SSLContext.verify_mode` returns :class:`VerifyMode` enum:"
msgstr ""
":attr:`SSLContext.verify_mode` ã¯æ¬¡ã®ã‚ˆã†ã« :class:`VerifyMode` enum (åˆ—æŒ™) ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:2024
msgid "Certificates"
msgstr "è¨¼æ˜æ›¸"

#: ../../library/ssl.rst:2026
msgid ""
"Certificates in general are part of a public-key / private-key system.  In "
"this system, each *principal*, (which may be a machine, or a person, or an "
"organization) is assigned a unique two-part encryption key.  One part of the"
" key is public, and is called the *public key*; the other part is kept "
"secret, and is called the *private key*.  The two parts are related, in that"
" if you encrypt a message with one of the parts, you can decrypt it with the"
" other part, and **only** with the other part."
msgstr ""
"è¨¼æ˜æ›¸ã‚’å¤§ã¾ã‹ã«èª¬æ˜ã™ã‚‹ã¨ã€å…¬é–‹éµ/ç§˜å¯†éµã‚·ã‚¹ãƒ†ãƒ ã®ä¸€ç¨®ã§ã™ã€‚ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€å„ *principal* (ã“ã‚Œã¯ãƒã‚·ãƒ³ã€äººã€çµ„ç¹”ãªã©ã§ã™) "
"ã¯ã€ãƒ¦ãƒ‹ãƒ¼ã‚¯ãª2ã¤ã®æš—å·éµã‚’å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¾ã™ã€‚1ã¤ã¯å…¬é–‹ã•ã‚Œã€ *å…¬é–‹éµ(public key)* ã¨å‘¼ã°ã‚Œã¾ã™ã€‚ã‚‚ã†ä¸€æ–¹ã¯ç§˜å¯†ã«ã•ã‚Œã€ "
"*ç§˜å¯†éµ(private key)* ã¨å‘¼ã°ã‚Œã¾ã™ã€‚ 2ã¤ã®éµã¯é–¢é€£ã—ã¦ãŠã‚Šã€ç‰‡æ–¹ã®éµã§æš—å·åŒ–ã—ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ã€ã‚‚ã†ç‰‡æ–¹ã®éµ **ã®ã¿** "
"ã§å¾©å·ã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:2034
msgid ""
"A certificate contains information about two principals.  It contains the "
"name of a *subject*, and the subject's public key.  It also contains a "
"statement by a second principal, the *issuer*, that the subject is who they "
"claim to be, and that this is indeed the subject's public key.  The issuer's"
" statement is signed with the issuer's private key, which only the issuer "
"knows.  However, anyone can verify the issuer's statement by finding the "
"issuer's public key, decrypting the statement with it, and comparing it to "
"the other information in the certificate. The certificate also contains "
"information about the time period over which it is valid.  This is expressed"
" as two fields, called \"notBefore\" and \"notAfter\"."
msgstr ""

#: ../../library/ssl.rst:2044
msgid ""
"In the Python use of certificates, a client or server can use a certificate "
"to prove who they are.  The other side of a network connection can also be "
"required to produce a certificate, and that certificate can be validated to "
"the satisfaction of the client or server that requires such validation.  The"
" connection attempt can be set to raise an exception if the validation "
"fails. Validation is done automatically, by the underlying OpenSSL "
"framework; the application need not concern itself with its mechanics.  But "
"the application does usually need to provide sets of certificates to allow "
"this process to take place."
msgstr ""
"Python "
"ã«ãŠã„ã¦è¨¼æ˜æ›¸ã‚’åˆ©ç”¨ã™ã‚‹å ´åˆã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚‚ã‚µãƒ¼ãƒãƒ¼ã‚‚è‡ªåˆ†ã‚’è¨¼æ˜ã™ã‚‹ãŸã‚ã«è¨¼æ˜æ›¸ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã®ç›¸æ‰‹å´ã«è¨¼æ˜æ›¸ã®æç¤ºã‚’è¦æ±‚ã™ã‚‹äº‹ãŒã§ãã€ãã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚„ã‚µãƒ¼ãƒãƒ¼ãŒèªè¨¼ã‚’å¿…è¦ã¨ã™ã‚‹ãªã‚‰ãã®è¨¼æ˜æ›¸ã‚’èªè¨¼ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚èªè¨¼ãŒå¤±æ•—ã—ãŸå ´åˆã€æ¥ç¶šã¯ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚èªè¨¼ã¯ä¸‹ä½å±¤ã®OpenSSLãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ãŒè‡ªå‹•çš„ã«è¡Œã„ã¾ã™ã€‚ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯èªè¨¼æ©Ÿæ§‹ã«ã¤ã„ã¦æ„è­˜ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã—ã‹ã—ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯èªè¨¼ãƒ—ãƒ­ã‚»ã‚¹ã®ãŸã‚ã«å¹¾ã¤ã‹ã®è¨¼æ˜æ›¸ã‚’æä¾›ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:2054
msgid ""
"Python uses files to contain certificates.  They should be formatted as "
"\"PEM\" (see :rfc:`1422`), which is a base-64 encoded form wrapped with a "
"header line and a footer line::"
msgstr ""
"Python ã¯è¨¼æ˜æ›¸ã‚’æ ¼ç´ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚ãã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ \"PEM\" (:rfc:`1422` å‚ç…§) ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¨ã„ã†"
"ã€ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã¨ãƒ•ãƒƒã‚¿ãƒ¼è¡Œã®é–“ã«base-64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸå½¢ã‚’ã¨ã£ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ ::"

#: ../../library/ssl.rst:2063
msgid "Certificate chains"
msgstr "è¨¼æ˜æ›¸ãƒã‚§ã‚¤ãƒ³"

#: ../../library/ssl.rst:2065
msgid ""
"The Python files which contain certificates can contain a sequence of "
"certificates, sometimes called a *certificate chain*.  This chain should "
"start with the specific certificate for the principal who \"is\" the client "
"or server, and then the certificate for the issuer of that certificate, and "
"then the certificate for the issuer of *that* certificate, and so on up the "
"chain till you get to a certificate which is *self-signed*, that is, a "
"certificate which has the same subject and issuer, sometimes called a *root "
"certificate*.  The certificates should just be concatenated together in the "
"certificate file.  For example, suppose we had a three certificate chain, "
"from our server certificate to the certificate of the certification "
"authority that signed our server certificate, to the root certificate of the"
" agency which issued the certification authority's certificate::"
msgstr ""
"PythonãŒåˆ©ç”¨ã™ã‚‹è¨¼æ˜æ›¸ã‚’æ ¼ç´ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€ã¨ãã«ã¯ *è¨¼æ˜æ›¸ãƒã‚§ã‚¤ãƒ³(certificate chain)* "
"ã¨å‘¼ã°ã‚Œã‚‹è¨¼æ˜æ›¸ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’æ ¼ç´ã—ã¾ã™ã€‚ã“ã®ãƒã‚§ã‚¤ãƒ³ã®å…ˆé ­ã«ã¯ã€ã¾ãšã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚„ã‚µãƒ¼ãƒãƒ¼ã§ã‚ã‚‹ principal "
"ã®è¨¼æ˜æ›¸ã‚’ç½®ãã€ãã‚Œä»¥é™ã«ã¯ã€ãã®è¨¼æ˜æ›¸ã®ç™ºè¡Œè€…(issuer)ã®è¨¼æ˜æ›¸ãªã©ã‚’ç¶šã‘ã€æœ€å¾Œã«è¨¼æ˜å¯¾è±¡(subject)ã¨ç™ºè¡Œè€…ãŒåŒã˜ *è‡ªå·±ç½²å"
"(self-signed)* è¨¼æ˜æ›¸ã§çµ‚ã‚ã‚Šã¾ã™ã€‚ã“ã®æœ€å¾Œã®è¨¼æ˜æ›¸ã¯ *ãƒ«ãƒ¼ãƒˆè¨¼æ˜æ›¸(root certificate* "
"ã¨å‘¼ã°ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‰ã®è¨¼æ˜æ›¸ãƒã‚§ã‚¤ãƒ³ã¯å˜ç´”ã«1ã¤ã®è¨¼æ˜æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ã«çµåˆã—ã¦ãã ã•ã„ã€‚ä¾‹ãˆã°ã€3ã¤ã®è¨¼æ˜æ›¸ã‹ã‚‰ãªã‚‹è¨¼æ˜æ›¸ãƒã‚§ã‚¤ãƒ³ãŒã‚ã‚‹å ´åˆã€ç§ãŸã¡ã®ã‚µãƒ¼ãƒãƒ¼ã®è¨¼æ˜æ›¸ã‹ã‚‰ã€ç§ãŸã¡ã®ã‚µãƒ¼ãƒãƒ¼ã«ç½²åã—ãŸèªè¨¼å±€ã®è¨¼æ˜æ›¸ã€ãã—ã¦èªè¨¼å±€ã®è¨¼æ˜æ›¸ã‚’ç™ºè¡Œã—ãŸæ©Ÿé–¢ã®ãƒ«ãƒ¼ãƒˆè¨¼æ˜æ›¸ã¨ç¶šãã¾ã™::"

#: ../../library/ssl.rst:2089
msgid "CA certificates"
msgstr "CA è¨¼æ˜æ›¸"

#: ../../library/ssl.rst:2091
msgid ""
"If you are going to require validation of the other side of the connection's"
" certificate, you need to provide a \"CA certs\" file, filled with the "
"certificate chains for each issuer you are willing to trust.  Again, this "
"file just contains these chains concatenated together.  For validation, "
"Python will use the first chain it finds in the file which matches.  The "
"platform's certificates file can be used by calling "
":meth:`SSLContext.load_default_certs`, this is done automatically with "
":func:`.create_default_context`."
msgstr ""
"ã‚‚ã—ç›¸æ‰‹ã‹ã‚‰é€ã‚‰ã‚Œã¦ããŸè¨¼æ˜æ›¸ã®èªè¨¼ã‚’ã—ãŸã„å ´åˆã€ä¿¡é ¼ã—ã¦ã„ã‚‹å„ç™ºè¡Œè€…ã®è¨¼æ˜æ›¸ãƒã‚§ã‚¤ãƒ³ãŒå…¥ã£ãŸ \"CA certs\" "
"ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æä¾›ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ç¹°ã‚Šè¿”ã—ã¾ã™ãŒã€ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯å˜ç´”ã«ã€å„ãƒã‚§ã‚¤ãƒ³ã‚’çµåˆã—ãŸã ã‘ã®ã‚‚ã®ã§ã™ã€‚èªè¨¼ã®ãŸã‚ã«ã€Pythonã¯ãã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¸­ã®æœ€åˆã«ãƒãƒƒãƒã—ãŸãƒã‚§ã‚¤ãƒ³ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚:meth:`SSLContext.load_default_certs`"
" ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã®è¨¼æ˜æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ã‚‚ä½¿ã‚ã‚Œã¾ã™ãŒã€ã“ã‚Œã¯ :func:`.create_default_context` "
"ã«ã‚ˆã£ã¦è‡ªå‹•çš„ã«è¡Œã‚ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:2100
msgid "Combined key and certificate"
msgstr "ç§˜å¯†éµã¨è¨¼æ˜æ›¸ã®çµ„ã¿åˆã‚ã›"

#: ../../library/ssl.rst:2102
msgid ""
"Often the private key is stored in the same file as the certificate; in this"
" case, only the ``certfile`` parameter to :meth:`SSLContext.load_cert_chain`"
" and :func:`wrap_socket` needs to be passed.  If the private key is stored "
"with the certificate, it should come before the first certificate in the "
"certificate chain::"
msgstr ""
"å¤šãã®å ´åˆã€è¨¼æ˜æ›¸ã¨åŒã˜ãƒ•ã‚¡ã‚¤ãƒ«ã«ç§˜å¯†éµã‚‚æ ¼ç´ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®å ´åˆã€ :meth:`SSLContext.load_cert_chain`, "
":func:`wrap_socket` ã«ã¯ ``certfile`` "
"å¼•æ•°ã ã‘ãŒå¿…è¦ã¨ã•ã‚Œã¾ã™ã€‚ç§˜å¯†éµãŒè¨¼æ˜æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ã«æ ¼ç´ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ç§˜å¯†éµã¯è¨¼æ˜æ›¸ãƒã‚§ã‚¤ãƒ³ã®æœ€åˆã®è¨¼æ˜æ›¸ã‚ˆã‚Šã‚‚å…ˆã«ãªã„ã¨ã„ã‘ã¾ã›ã‚“ã€‚ ::"

#: ../../library/ssl.rst:2116
msgid "Self-signed certificates"
msgstr "è‡ªå·±ç½²åè¨¼æ˜æ›¸"

#: ../../library/ssl.rst:2118
msgid ""
"If you are going to create a server that provides SSL-encrypted connection "
"services, you will need to acquire a certificate for that service.  There "
"are many ways of acquiring appropriate certificates, such as buying one from"
" a certification authority.  Another common practice is to generate a self-"
"signed certificate.  The simplest way to do this is with the OpenSSL "
"package, using something like the following::"
msgstr ""
"SSLæš—å·åŒ–æ¥ç¶šã‚µãƒ¼ãƒ“ã‚¹ã‚’æä¾›ã™ã‚‹ã‚µãƒ¼ãƒãƒ¼ã‚’å»ºã¦ã‚‹å ´åˆã€é©åˆ‡ãªè¨¼æ˜æ›¸ã‚’å–å¾—ã™ã‚‹ã«ã¯ã€èªè¨¼å±€ã‹ã‚‰è²·ã†ãªã©ã®å¹¾ã¤ã‹ã®æ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚ã¾ãŸã€è‡ªå·±ç½²åè¨¼æ˜æ›¸ã‚’ä½œã‚‹ã‚±ãƒ¼ã‚¹ã‚‚ã‚ã‚Šã¾ã™ã€‚"
" OpenSSLã‚’ä½¿ã£ã¦è‡ªå·±ç½²åè¨¼æ˜æ›¸ã‚’ä½œã‚‹ã«ã¯ã€æ¬¡ã®ã‚ˆã†ã«ã—ã¾ã™ã€‚ ::"

#: ../../library/ssl.rst:2147
msgid ""
"The disadvantage of a self-signed certificate is that it is its own root "
"certificate, and no one else will have it in their cache of known (and "
"trusted) root certificates."
msgstr "è‡ªå·±ç½²åè¨¼æ˜æ›¸ã®æ¬ ç‚¹ã¯ã€ãã‚Œè‡ªèº«ãŒãƒ«ãƒ¼ãƒˆè¨¼æ˜æ›¸ã§ã‚ã‚Šã€ä»–ã®äººã¯ãã®è¨¼æ˜æ›¸ã‚’æŒã£ã¦ã„ãªã„ (ãã—ã¦ä¿¡é ¼ã—ãªã„)ã“ã¨ã§ã™ã€‚"

#: ../../library/ssl.rst:2153
msgid "Examples"
msgstr "ä½¿ç”¨ä¾‹"

#: ../../library/ssl.rst:2156
msgid "Testing for SSL support"
msgstr "SSLã‚µãƒãƒ¼ãƒˆã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹"

#: ../../library/ssl.rst:2158
msgid ""
"To test for the presence of SSL support in a Python installation, user code "
"should use the following idiom::"
msgstr ""
"ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹PythonãŒSSLã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ãŸã‚ã«ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚³ãƒ¼ãƒ‰ã¯æ¬¡ã®ã‚¤ãƒ‡ã‚£ã‚ªãƒ ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ ::"

#: ../../library/ssl.rst:2169
msgid "Client-side operation"
msgstr "ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã®å‡¦ç†"

#: ../../library/ssl.rst:2171
msgid ""
"This example creates a SSL context with the recommended security settings "
"for client sockets, including automatic certificate verification::"
msgstr "ã“ã®ä¾‹ã§ã¯ã€è‡ªå‹•çš„ã«è¨¼æ˜æ›¸ã®æ¤œè¨¼ã‚’è¡Œã†ã“ã¨ã‚’å«ã‚€æœ›ã¾ã—ã„ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®šã§ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚½ã‚±ãƒƒãƒˆã® SSL ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œã‚Šã¾ã™::"

#: ../../library/ssl.rst:2176
msgid ""
"If you prefer to tune security settings yourself, you might create a context"
" from scratch (but beware that you might not get the settings right)::"
msgstr ""
"è‡ªåˆ†è‡ªèº«ã§ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®šã‚’èª¿æ•´ã—ãŸã„å ´åˆã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¸€ã‹ã‚‰ä½œã‚‹ã“ã¨ã¯ã§ãã¾ã™ "
"(ãŸã ã—ã€æ­£ã—ããªã„è¨­å®šã‚’ã—ã¦ã—ã¾ã„ãŒã¡ãªã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„)::"

#: ../../library/ssl.rst:2185
msgid ""
"(this snippet assumes your operating system places a bundle of all CA "
"certificates in ``/etc/ssl/certs/ca-bundle.crt``; if not, you'll get an "
"error and have to adjust the location)"
msgstr ""
"(ã“ã®ã‚¹ãƒ‹ãƒšãƒƒãƒˆã¯ã™ã¹ã¦ã® CA è¨¼æ˜æ›¸ãŒ ``/etc/ssl/certs/ca-bundle.crt`` ã«ãƒãƒ³ãƒ‰ãƒ«ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ä»®å®šã—ã¦ã„ã¾ã™;"
" ã‚‚ã—é•ã£ã¦ã„ã‚Œã°ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã®ã§ã€é©å®œä¿®æ­£ã—ã¦ãã ã•ã„)"

#: ../../library/ssl.rst:2189
msgid ""
"When you use the context to connect to a server, :const:`CERT_REQUIRED` "
"validates the server certificate: it ensures that the server certificate was"
" signed with one of the CA certificates, and checks the signature for "
"correctness::"
msgstr ""
"ã‚µãƒ¼ãƒã¸ã®æ¥ç¶šã«ã“ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½¿ã†ã¨ã€ :const:`CERT_REQUIRED` ã§ã‚µãƒ¼ãƒã®è¨¼æ˜æ›¸ã®æ¤œè¨¼ãŒè¡Œã‚ã‚Œã¾ã™: ã‚µãƒ¼ãƒã®è¨¼æ˜æ›¸ãŒ CA "
"è¨¼æ˜æ›¸ã®ã„ãšã‚Œã‹ã«ç½²åã•ã‚Œã¦ã„ã¦ã€ãã®ç½²åãŒæ­£ã—ã„ã“ã¨ã‚’ä¿éšœã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:2198
msgid "You may then fetch the certificate::"
msgstr "ãã—ã¦è¨¼æ˜æ›¸ã‚’æŒã£ã¦ãã‚‹ã“ã¨ãŒã§ãã¾ã™::"

#: ../../library/ssl.rst:2202
msgid ""
"Visual inspection shows that the certificate does identify the desired "
"service (that is, the HTTPS host ``www.python.org``)::"
msgstr ""
"è¨¼æ˜æ›¸ãŒã€æœŸå¾…ã—ã¦ã„ã‚‹ã‚µãƒ¼ãƒ“ã‚¹ (ã¤ã¾ã‚Šã€ HTTPS ãƒ›ã‚¹ãƒˆ ``www.python.org``) "
"ã®èº«å…ƒã‚’ç‰¹å®šã—ã¦ã„ã‚‹ã“ã¨ã‚’è¦–è¦šçš„ã«ç‚¹æ¤œã—ã¦ã¿ã¾ã—ã‚‡ã†::"

#: ../../library/ssl.rst:2245
msgid ""
"Now the SSL channel is established and the certificate verified, you can "
"proceed to talk with the server::"
msgstr "SSL ãƒãƒ£ãƒãƒ«ã¯ä»Šã‚„ç¢ºç«‹ã•ã‚Œã¦è¨¼æ˜æ›¸ãŒæ¤œè¨¼ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€ã‚µãƒ¼ãƒã¨ã®ãŠå–‹ã‚Šã‚’ç¶šã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™::"

#: ../../library/ssl.rst:2272
msgid "Server-side operation"
msgstr "ã‚µãƒ¼ãƒã‚µã‚¤ãƒ‰ã®å‡¦ç†"

#: ../../library/ssl.rst:2274
msgid ""
"For server operation, typically you'll need to have a server certificate, "
"and private key, each in a file.  You'll first create a context holding the "
"key and the certificate, so that clients can check your authenticity.  Then "
"you'll open a socket, bind it to a port, call :meth:`listen` on it, and "
"start waiting for clients to connect::"
msgstr ""
"ã‚µãƒ¼ãƒã‚µã‚¤ãƒ‰ã®å‡¦ç†ã§ã¯ã€é€šå¸¸ã€ã‚µãƒ¼ãƒãƒ¼è¨¼æ˜æ›¸ã¨ç§˜å¯†éµãŒãã‚Œãã‚Œãƒ•ã‚¡ã‚¤ãƒ«ã«æ ¼ç´ã•ã‚ŒãŸå½¢ã§å¿…è¦ã§ã™ã€‚æœ€åˆã«ç§˜å¯†éµã¨è¨¼æ˜æ›¸ãŒä¿æŒã•ã‚ŒãŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œæˆã—ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒã‚ãªãŸã®ä¿¡æ†‘æ€§ã‚’ãƒã‚§ãƒƒã‚¯ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ãã®ã®ã¡ã«ã‚½ã‚±ãƒƒãƒˆã‚’é–‹ãã€ãƒãƒ¼ãƒˆã«ãƒã‚¤ãƒ³ãƒ‰ã—ã€ãã®ã‚½ã‚±ãƒƒãƒˆã®"
" :meth:`listen` ã‚’å‘¼ã³ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã®æ¥ç¶šã‚’å¾…ã¡ã¾ã™ã€‚ ::"

#: ../../library/ssl.rst:2289
msgid ""
"When a client connects, you'll call :meth:`accept` on the socket to get the "
"new socket from the other end, and use the context's "
":meth:`SSLContext.wrap_socket` method to create a server-side SSL socket for"
" the connection::"
msgstr ""
"ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒæ¥ç¶šã—ã¦ããŸå ´åˆã€ :meth:`accept` ã‚’å‘¼ã‚“ã§æ–°ã—ã„ã‚½ã‚±ãƒƒãƒˆã‚’ä½œæˆã—ã€æ¥ç¶šã®ãŸã‚ã«ã‚µãƒ¼ãƒã‚µã‚¤ãƒ‰ã® SSL "
"ã‚½ã‚±ãƒƒãƒˆã‚’ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã® :meth:`SSLContext.wrap_socket` ãƒ¡ã‚½ãƒƒãƒ‰ã§ä½œã‚Šã¾ã™::"

#: ../../library/ssl.rst:2302
msgid ""
"Then you'll read data from the ``connstream`` and do something with it till "
"you are finished with the client (or the client is finished with you)::"
msgstr ""
"ãã—ã¦ã€ ``connstream`` ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨åˆ‡æ–­ã™ã‚‹(ã‚ã‚‹ã„ã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒåˆ‡æ–­ã—ã¦ãã‚‹)ã¾ã§ä½•ã‹å‡¦ç†ã‚’ã—ã¾ã™ã€‚ ::"

#: ../../library/ssl.rst:2316
msgid ""
"And go back to listening for new client connections (of course, a real "
"server would probably handle each client connection in a separate thread, or"
" put the sockets in :ref:`non-blocking mode <ssl-nonblocking>` and use an "
"event loop)."
msgstr ""
"ãã—ã¦æ–°ã—ã„ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆæ¥ç¶šã®ãŸã‚ã« listen ã«æˆ»ã‚Šã¾ã™ã€‚ "
"(ã‚‚ã¡ã‚ã‚“ç¾å®Ÿã®ã‚µãƒ¼ãƒã¯ã€ãŠãã‚‰ãå€‹ã€…ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆæ¥ç¶šã”ã¨ã«åˆ¥ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã§å‡¦ç†ã™ã‚‹ã‹ã€ã‚½ã‚±ãƒƒãƒˆã‚’ :ref:`ãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ <ssl-"
"nonblocking>` ã«ã—ã€ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã‚’ä½¿ã†ã§ã—ã‚‡ã†ã€‚)"

#: ../../library/ssl.rst:2324
msgid "Notes on non-blocking sockets"
msgstr "ãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã‚½ã‚±ãƒƒãƒˆã«ã¤ã„ã¦ã®æ³¨æ„äº‹é …"

#: ../../library/ssl.rst:2326
msgid ""
"SSL sockets behave slightly different than regular sockets in non-blocking "
"mode. When working with non-blocking sockets, there are thus several things "
"you need to be aware of:"
msgstr ""
"SSL "
"ã‚½ã‚±ãƒƒãƒˆã¯ãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã«ãŠã„ã¦ã¯ã€æ™®é€šã®ã‚½ã‚±ãƒƒãƒˆã¨ã¯å°‘ã—é•ã£ãŸæŒ¯ã‚‹èˆã„ã‚’ã—ã¾ã™ã€‚ã§ã™ã®ã§ãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã‚½ã‚±ãƒƒãƒˆã¨ã¨ã‚‚ã«ä½¿ã†å ´åˆã€ã„ãã¤ã‹æ°—ã‚’ã¤ã‘ãªã‘ã‚Œã°ãªã‚‰ãªã„äº‹é …ãŒã‚ã‚Šã¾ã™:"

#: ../../library/ssl.rst:2330
msgid ""
"Most :class:`SSLSocket` methods will raise either :exc:`SSLWantWriteError` "
"or :exc:`SSLWantReadError` instead of :exc:`BlockingIOError` if an I/O "
"operation would block. :exc:`SSLWantReadError` will be raised if a read "
"operation on the underlying socket is necessary, and "
":exc:`SSLWantWriteError` for a write operation on the underlying socket. "
"Note that attempts to *write* to an SSL socket may require *reading* from "
"the underlying socket first, and attempts to *read* from the SSL socket may "
"require a prior *write* to the underlying socket."
msgstr ""
"ã»ã¨ã‚“ã©ã® :class:`SSLSocket` ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ I/O æ“ä½œãŒãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹ã¨ :exc:`BlockingIOError` ã§ã¯ãªã "
":exc:`SSLWantWriteError` ã‹ :exc:`SSLWantReadError` ã®ã©ã¡ã‚‰ã‹ã‚’é€å‡ºã—ã¾ã™ã€‚ "
":exc:`SSLWantReadError` ã¯ä¸‹å±¤ã®ã‚½ã‚±ãƒƒãƒˆã§èª­ã¿å‡ºã—ãŒå¿…è¦ãªå ´åˆã«é€å‡ºã•ã‚Œã€ :exc:`SSLWantWriteError` "
"ã¯ä¸‹å±¤ã®ã‚½ã‚±ãƒƒãƒˆã§æ›¸ãè¾¼ã¿ãŒå¿…è¦ãªå ´åˆã«é€å‡ºã•ã‚Œã¾ã™ã€‚SSL ã‚½ã‚±ãƒƒãƒˆã«å¯¾ã—ã¦ *æ›¸ãè¾¼ã¿* ã‚’è©¦ã¿ã‚‹ã¨ä¸‹å±¤ã®ã‚½ã‚±ãƒƒãƒˆã‹ã‚‰æœ€åˆã« *èª­ã¿å‡ºã™* "
"å¿…è¦ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œãšã€SSL ã‚½ã‚±ãƒƒãƒˆã«å¯¾ã—ã¦ *èª­ã¿å‡ºã—* ã‚’è©¦ã¿ã‚‹ã¨ä¸‹å±¤ã®ã‚½ã‚±ãƒƒãƒˆã«å…ˆã« *æ›¸ãè¾¼ã‚€* "
"å¿…è¦ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:2342
msgid ""
"In earlier Python versions, the :meth:`!SSLSocket.send` method returned zero"
" instead of raising :exc:`SSLWantWriteError` or :exc:`SSLWantReadError`."
msgstr ""
"ä»¥å‰ã® Python ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ã€ :meth:`!SSLSocket.send` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :exc:`SSLWantWriteError` "
"ã¾ãŸã¯ :exc:`SSLWantReadError` ã‚’é€å‡ºã™ã‚‹ã®ã§ã¯ãªãã€ã‚¼ãƒ­ã‚’è¿”ã—ã¦ã„ã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:2346
msgid ""
"Calling :func:`~select.select` tells you that the OS-level socket can be "
"read from (or written to), but it does not imply that there is sufficient "
"data at the upper SSL layer.  For example, only part of an SSL frame might "
"have arrived.  Therefore, you must be ready to handle :meth:`SSLSocket.recv`"
" and :meth:`SSLSocket.send` failures, and retry after another call to "
":func:`~select.select`."
msgstr ""
":func:`~select.select` å‘¼ã³å‡ºã—ã¯ OS "
"ãƒ¬ãƒ™ãƒ«ã§ã®ã‚½ã‚±ãƒƒãƒˆãŒèª­ã¿å‡ºã—å¯èƒ½(ã¾ãŸã¯æ›¸ãè¾¼ã¿å¯èƒ½)ã«ãªã£ãŸã“ã¨ã‚’æ•™ãˆã¦ãã‚Œã¾ã™ãŒã€ä¸Šä½ã® SSL "
"ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§ã®ååˆ†ãªãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€SSL ãƒ•ãƒ¬ãƒ¼ãƒ ã®ä¸€éƒ¨ãŒå±Šã„ãŸã ã‘ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã§ã™ã‹ã‚‰ã€ "
":meth:`SSLSocket.recv` ã¨ :meth:`SSLSocket.send` ã®å¤±æ•—ã‚’å‡¦ç†ã™ã‚‹ã“ã¨ã«å‚™ãˆã€ã»ã‹ã® "
":func:`~select.select` å‘¼ã³å‡ºã—å¾Œã«ãƒªãƒˆãƒ©ã‚¤ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:2353
msgid ""
"Conversely, since the SSL layer has its own framing, a SSL socket may still "
"have data available for reading without :func:`~select.select` being aware "
"of it.  Therefore, you should first call :meth:`SSLSocket.recv` to drain any"
" potentially available data, and then only block on a :func:`~select.select`"
" call if still necessary."
msgstr ""
"åå¯¾ã«ã€SSL ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ç‹¬è‡ªã®æ çµ„ã¿ã‚’æŒã£ã¦ã„ã‚‹ãŸã‚ã€:func:`~select.select` ãŒæ°—ä»˜ã‹ãªã„èª­ã¿å‡ºã—å¯èƒ½ãªãƒ‡ãƒ¼ã‚¿ã‚’ SSL "
"ã‚½ã‚±ãƒƒãƒˆãŒæŒã£ã¦ã„ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ã—ãŸãŒã£ã¦ã€å…¥æ‰‹å¯èƒ½ãªå¯èƒ½æ€§ã®ã‚ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’ã™ã¹ã¦å¼•ãå‡ºã™ãŸã‚ã«æœ€åˆã« :meth:`SSLSocket.recv` "
"ã‚’å‘¼ã³å‡ºã—ã€æ¬¡ã«ãã‚Œã§ã‚‚ã¾ã å¿…è¦ãªå ´åˆã«ã ã‘ :func:`~select.select` å‘¼ã³å‡ºã—ã§ãƒ–ãƒ­ãƒƒã‚¯ã™ã¹ãã§ã™ã€‚"

#: ../../library/ssl.rst:2359
msgid ""
"(of course, similar provisions apply when using other primitives such as "
":func:`~select.poll`, or those in the :mod:`selectors` module)"
msgstr ""
"(å½“ç„¶ã®ã“ã¨ãªãŒã‚‰ã€ã»ã‹ã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã€ä¾‹ãˆã° :func:`~select.poll` ã‚„ :mod:`selectors` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã®ã‚‚ã®ã‚’ä½¿ã†éš›ã«ã‚‚ä¼¼ãŸä½†ã—æ›¸ããŒä»˜ãã¾ã™)"

#: ../../library/ssl.rst:2362
msgid ""
"The SSL handshake itself will be non-blocking: the "
":meth:`SSLSocket.do_handshake` method has to be retried until it returns "
"successfully.  Here is a synopsis using :func:`~select.select` to wait for "
"the socket's readiness::"
msgstr ""
"SSL ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ãã®ã‚‚ã®ãŒãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã«ãªã‚Šã¾ã™: :meth:`SSLSocket.do_handshake` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã¯æˆåŠŸã™ã‚‹ã¾ã§ãƒªãƒˆãƒ©ã‚¤ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ :func:`~select.select` "
"ã‚’ç”¨ã„ã¦ã‚½ã‚±ãƒƒãƒˆã®æº–å‚™ãŒæ•´ã†ã®ã‚’å¾…ã¤ãŸã‚ã«ã¯ã€ãŠã‚ˆãä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¾ã™::"

#: ../../library/ssl.rst:2378
msgid ""
"The :mod:`asyncio` module supports :ref:`non-blocking SSL sockets <ssl-"
"nonblocking>` and provides a higher level API. It polls for events using the"
" :mod:`selectors` module and handles :exc:`SSLWantWriteError`, "
":exc:`SSLWantReadError` and :exc:`BlockingIOError` exceptions. It runs the "
"SSL handshake asynchronously as well."
msgstr ""
":mod:`asyncio` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ :ref:`ãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚° SSL ã‚½ã‚±ãƒƒãƒˆ <ssl-nonblocking>` "
"ã‚’ã‚µãƒãƒ¼ãƒˆã—ã€ã‚ˆã‚Šé«˜ã„ãƒ¬ãƒ™ãƒ«ã® API ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚ :mod:`selectors` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã£ã¦ã‚¤ãƒ™ãƒ³ãƒˆã‚’ poll ã—ã€ "
":exc:`SSLWantWriteError`, :exc:`SSLWantReadError`, :exc:`BlockingIOError` "
"ä¾‹å¤–ã‚’å‡¦ç†ã—ã¾ã™ã€‚SSL ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã‚‚éåŒæœŸã«å®Ÿè¡Œã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:2387
msgid "Memory BIO Support"
msgstr "ãƒ¡ãƒ¢ãƒª BIO ã‚µãƒãƒ¼ãƒˆ"

#: ../../library/ssl.rst:2391
msgid ""
"Ever since the SSL module was introduced in Python 2.6, the "
":class:`SSLSocket` class has provided two related but distinct areas of "
"functionality:"
msgstr ""
"Python 2.6 ã§ SSL ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå°å…¥ã•ã‚Œã¦ä»¥é™ã€:class:`SSLSocket` "
"ã‚¯ãƒ©ã‚¹ã¯ã€ä»¥ä¸‹ã®äº’ã„ã«é–¢é€£ã™ã‚‹ãŒåˆ¥ã€…ã®æ©Ÿèƒ½ã‚’æä¾›ã—ã¦ãã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:2394
msgid "SSL protocol handling"
msgstr "SSL ãƒ—ãƒ­ãƒˆã‚³ãƒ«å‡¦ç†"

#: ../../library/ssl.rst:2395
msgid "Network IO"
msgstr "ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ IO"

#: ../../library/ssl.rst:2397
msgid ""
"The network IO API is identical to that provided by :class:`socket.socket`, "
"from which :class:`SSLSocket` also inherits. This allows an SSL socket to be"
" used as a drop-in replacement for a regular socket, making it very easy to "
"add SSL support to an existing application."
msgstr ""
"ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ IO API ã¯ã€:class:`socket.socket` ãŒæä¾›ã™ã‚‹ã‚‚ã®ã¨åŒã˜ã§ã™ã€‚:class:`SSLSocket`Â "
"ã‚‚ã€ãã®ã‚¯ãƒ©ã‚¹ã‹ã‚‰ç¶™æ‰¿ã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€SSL "
"ã‚½ã‚±ãƒƒãƒˆã¯æ¨™æº–ã®ã‚½ã‚±ãƒƒãƒˆã‚’ãã£ãã‚Šãã®ã¾ã¾ç½®ãæ›ãˆã‚‹ã‚‚ã®ã¨ã—ã¦ä½¿ç”¨ã§ãã‚‹ãŸã‚ã€æ—¢å­˜ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ SSL ã«å¯¾å¿œã•ã›ã‚‹ã®ãŒéå¸¸ã«ç°¡å˜ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/ssl.rst:2402
msgid ""
"Combining SSL protocol handling and network IO usually works well, but there"
" are some cases where it doesn't. An example is async IO frameworks that "
"want to use a different IO multiplexing model than the \"select/poll on a "
"file descriptor\" (readiness based) model that is assumed by "
":class:`socket.socket` and by the internal OpenSSL socket IO routines. This "
"is mostly relevant for platforms like Windows where this model is not "
"efficient. For this purpose, a reduced scope variant of :class:`SSLSocket` "
"called :class:`SSLObject` is provided."
msgstr ""
"SSL ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®å‡¦ç†ã¨ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ IO ã‚’çµ„ã¿åˆã‚ã›ãŸå ´åˆã€é€šå¸¸ã¯å•é¡Œãªãå‹•ä½œã—ã¾ã™ãŒã€å•é¡ŒãŒç™ºç”Ÿã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ä¸€ä¾‹ã‚’æŒ™ã’ã‚‹ã¨ã€éåŒæœŸ IO"
" ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ãŒåˆ¥ã®å¤šé‡åŒ–ãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€ã“ã‚Œã¯ :class:`socket.socket` ã¨å†…éƒ¨ OpenSSL ã‚½ã‚±ãƒƒãƒˆ IO "
"ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ãŒæƒ³å®šã™ã‚‹ã€Œãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ä¸Šã® select/pollã€ãƒ¢ãƒ‡ãƒ«ï¼ˆæº–å‚™çŠ¶æ…‹ãƒ™ãƒ¼ã‚¹ï¼‰ã¨ã¯ç•°ãªã‚Šã¾ã™ã€‚ã“ã‚Œã¯ã€ã“ã®ãƒ¢ãƒ‡ãƒ«ãŒéåŠ¹ç‡çš„ã«ãªã‚‹ "
"Windows ãªã©ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«ä¸»ã«è©²å½“ã—ã¾ã™ã€‚ãã®ãŸã‚ã€ã‚¹ã‚³ãƒ¼ãƒ—ã‚’é™å®šã—ãŸ :class:`SSLSocket` ã®å¤‰ç¨®ã€ "
":class:`SSLObject` ãŒæä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/ssl.rst:2413
msgid ""
"A reduced-scope variant of :class:`SSLSocket` representing an SSL protocol "
"instance that does not contain any network IO methods. This class is "
"typically used by framework authors that want to implement asynchronous IO "
"for SSL through memory buffers."
msgstr ""
"ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ IO ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å«ã¾ãªã„ SSL ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¡¨ã™ã€ã‚¹ã‚³ãƒ¼ãƒ—ã‚’é™å®šã—ãŸ :class:`SSLSocket` "
"ã®å¤‰ç¨®ã§ã™ã€‚ä¸€èˆ¬çš„ã«ã“ã€ã®ã‚¯ãƒ©ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã®ã¯ã€ãƒ¡ãƒ¢ãƒªãƒãƒƒãƒ•ã‚¡ã‚’é€šã˜ã¦ SSL ã®ãŸã‚ã®éåŒæœŸ IO ã‚’å®Ÿè£…ã™ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ä½œæˆè€…ã§ã™ã€‚"

#: ../../library/ssl.rst:2418
msgid ""
"This class implements an interface on top of a low-level SSL object as "
"implemented by OpenSSL. This object captures the state of an SSL connection "
"but does not provide any network IO itself. IO needs to be performed through"
" separate \"BIO\" objects which are OpenSSL's IO abstraction layer."
msgstr ""
"ã“ã®ã‚¯ãƒ©ã‚¹ã¯ã€OpenSSL ãŒå®Ÿè£…ã™ã‚‹ä½æ°´æº– SSL ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸Šã«ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã‚’å®Ÿè£…ã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ SSL "
"æ¥ç¶šã®çŠ¶æ…‹ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£ã—ã¾ã™ãŒã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ IO è‡ªä½“ã¯æä¾›ã—ã¾ã›ã‚“ã€‚IO ã¯ã€OpenSSL ã® IO "
"æŠ½è±¡ãƒ¬ã‚¤ãƒ¤ã§ã‚ã‚‹åˆ¥ã®ã€ŒBIOã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é€šã˜ã¦å®Ÿè¡Œã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/ssl.rst:2423
msgid ""
"This class has no public constructor.  An :class:`SSLObject` instance must "
"be created using the :meth:`~SSLContext.wrap_bio` method. This method will "
"create the :class:`SSLObject` instance and bind it to a pair of BIOs. The "
"*incoming* BIO is used to pass data from Python to the SSL protocol "
"instance, while the *outgoing* BIO is used to pass data the other way "
"around."
msgstr ""

#: ../../library/ssl.rst:2430
msgid "The following methods are available:"
msgstr "æ¬¡ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™:"

#: ../../library/ssl.rst:2432
msgid ":attr:`~SSLSocket.context`"
msgstr ":attr:`~SSLSocket.context`"

#: ../../library/ssl.rst:2433
msgid ":attr:`~SSLSocket.server_side`"
msgstr ":attr:`~SSLSocket.server_side`"

#: ../../library/ssl.rst:2434
msgid ":attr:`~SSLSocket.server_hostname`"
msgstr ":attr:`~SSLSocket.server_hostname`"

#: ../../library/ssl.rst:2435
msgid ":attr:`~SSLSocket.session`"
msgstr ":attr:`~SSLSocket.session`"

#: ../../library/ssl.rst:2436
msgid ":attr:`~SSLSocket.session_reused`"
msgstr ":attr:`~SSLSocket.session_reused`"

#: ../../library/ssl.rst:2437
msgid ":meth:`~SSLSocket.read`"
msgstr ":meth:`~SSLSocket.read`"

#: ../../library/ssl.rst:2438
msgid ":meth:`~SSLSocket.write`"
msgstr ":meth:`~SSLSocket.write`"

#: ../../library/ssl.rst:2439
msgid ":meth:`~SSLSocket.getpeercert`"
msgstr ":meth:`~SSLSocket.getpeercert`"

#: ../../library/ssl.rst:2440
msgid ":meth:`~SSLSocket.selected_npn_protocol`"
msgstr ":meth:`~SSLSocket.selected_npn_protocol`"

#: ../../library/ssl.rst:2441
msgid ":meth:`~SSLSocket.cipher`"
msgstr ":meth:`~SSLSocket.cipher`"

#: ../../library/ssl.rst:2442
msgid ":meth:`~SSLSocket.shared_ciphers`"
msgstr ":meth:`~SSLSocket.shared_ciphers`"

#: ../../library/ssl.rst:2443
msgid ":meth:`~SSLSocket.compression`"
msgstr ":meth:`~SSLSocket.compression`"

#: ../../library/ssl.rst:2444
msgid ":meth:`~SSLSocket.pending`"
msgstr ":meth:`~SSLSocket.pending`"

#: ../../library/ssl.rst:2445
msgid ":meth:`~SSLSocket.do_handshake`"
msgstr ":meth:`~SSLSocket.do_handshake`"

#: ../../library/ssl.rst:2446
msgid ":meth:`~SSLSocket.unwrap`"
msgstr ":meth:`~SSLSocket.unwrap`"

#: ../../library/ssl.rst:2447
msgid ":meth:`~SSLSocket.get_channel_binding`"
msgstr ":meth:`~SSLSocket.get_channel_binding`"

#: ../../library/ssl.rst:2449
msgid ""
"When compared to :class:`SSLSocket`, this object lacks the following "
"features:"
msgstr ":class:`SSLSocket` ã¨æ¯”è¼ƒã™ã‚‹ã¨ã€ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ä»¥ä¸‹ã®æ©Ÿèƒ½ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/ssl.rst:2452
msgid ""
"Any form of network IO; ``recv()`` and ``send()`` read and write only to the"
" underlying :class:`MemoryBIO` buffers."
msgstr ""

#: ../../library/ssl.rst:2455
msgid ""
"There is no *do_handshake_on_connect* machinery. You must always manually "
"call :meth:`~SSLSocket.do_handshake` to start the handshake."
msgstr ""
"*do_handshake_on_connect* æ©Ÿæ§‹ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚å¿…ãšæ‰‹å‹•ã§ :meth:`~SSLSocket.do_handshake` "
"ã‚’å‘¼ã‚“ã§ã€ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã‚’é–‹å§‹ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/ssl.rst:2458
msgid ""
"There is no handling of *suppress_ragged_eofs*. All end-of-file conditions "
"that are in violation of the protocol are reported via the "
":exc:`SSLEOFError` exception."
msgstr ""
"*suppress_ragged_eofs* ã¯å‡¦ç†ã•ã‚Œã¾ã›ã‚“ã€‚ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã«é•åã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«æœ«å°¾çŠ¶æ…‹ã¯ã€ :exc:`SSLEOFError` "
"ä¾‹å¤–ã‚’é€šã˜ã¦å ±å‘Šã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:2462
msgid ""
"The method :meth:`~SSLSocket.unwrap` call does not return anything, unlike "
"for an SSL socket where it returns the underlying socket."
msgstr ""
":meth:`~SSLSocket.unwrap` ãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—ã¯ã€ä¸‹å±¤ã®ã‚½ã‚±ãƒƒãƒˆã‚’è¿”ã™ SSL ã‚½ã‚±ãƒƒãƒˆã¨ã¯ç•°ãªã‚Šã€ä½•ã‚‚è¿”ã—ã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:2465
msgid ""
"The *server_name_callback* callback passed to "
":meth:`SSLContext.set_servername_callback` will get an :class:`SSLObject` "
"instance instead of a :class:`SSLSocket` instance as its first parameter."
msgstr ""
":meth:`SSLContext.set_servername_callback` ã«æ¸¡ã•ã‚Œã‚‹ *server_name_callback* "
"ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯ã€1 ã¤ç›®ã®å¼•æ•°ã¨ã—ã¦ :class:`SSLSocket` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã¯ãªã :class:`SSLObject` "
"ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚"

#: ../../library/ssl.rst:2469
msgid "Some notes related to the use of :class:`SSLObject`:"
msgstr ":class:`SSLObject` ã®ä½¿ç”¨ã«é–¢ã™ã‚‹æ³¨æ„:"

#: ../../library/ssl.rst:2471
msgid ""
"All IO on an :class:`SSLObject` is :ref:`non-blocking <ssl-nonblocking>`. "
"This means that for example :meth:`~SSLSocket.read` will raise an "
":exc:`SSLWantReadError` if it needs more data than the incoming BIO has "
"available."
msgstr ""
":class:`SSLObject` ä¸Šã®ã™ã¹ã¦ã® IO ã¯ :ref:`non-blocking <ssl-nonblocking>` "
"ã§ã™ã€‚ä¾‹ãˆã°ã€:meth:`~SSLSocket.read` ã¯å…¥åŠ› BIO "
"ãŒæŒã¤ãƒ‡ãƒ¼ã‚¿ã‚ˆã‚Šã‚‚å¤šãã®ãƒ‡ãƒ¼ã‚¿ã‚’å¿…è¦ã¨ã™ã‚‹å ´åˆã€:exc:`SSLWantReadError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:2476
msgid ""
"There is no module-level ``wrap_bio()`` call like there is for "
":meth:`~SSLContext.wrap_socket`. An :class:`SSLObject` is always created via"
" an :class:`SSLContext`."
msgstr ""
":meth:`~SSLContext.wrap_socket` ã«å¯¾ã—ã¦å­˜åœ¨ã™ã‚‹ã‚ˆã†ãªã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«ã® ``wrap_bio()`` "
"å‘¼ã³å‡ºã—ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚:class:`SSLObject` ã¯ã€å¸¸ã« :class:`SSLContext` ã‚’çµŒç”±ã—ã¦ä½œæˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:2480
msgid ""
":class:`SSLObject` instances must to created with "
":meth:`~SSLContext.wrap_bio`. In earlier versions, it was possible to create"
" instances directly. This was never documented or officially supported."
msgstr ""

#: ../../library/ssl.rst:2486
msgid ""
"An SSLObject communicates with the outside world using memory buffers. The "
"class :class:`MemoryBIO` provides a memory buffer that can be used for this "
"purpose.  It wraps an OpenSSL memory BIO (Basic IO) object:"
msgstr ""
"SSLObject ã¯ã€ãƒ¡ãƒ¢ãƒªãƒãƒƒãƒ•ã‚¡ã‚’ä½¿ç”¨ã—ã¦å¤–ç•Œã¨é€šä¿¡ã—ã¾ã™ã€‚:class:`MemoryBIO`Â ã‚¯ãƒ©ã‚¹ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã« OpenSSL ãƒ¡ãƒ¢ãƒª "
"BIO (Basic IO) ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ©ãƒƒãƒ—ã—ã€ã“ã®ç›®çš„ã«ä½¿ç”¨ã§ãã‚‹ãƒ¡ãƒ¢ãƒªãƒãƒƒãƒ•ã‚¡ã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:2492
msgid ""
"A memory buffer that can be used to pass data between Python and an SSL "
"protocol instance."
msgstr "Python ã¨ SSL ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹é–“ã§ãƒ‡ãƒ¼ã‚¿ã‚’ã‚„ã‚Šå–ã‚Šã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã§ãã‚‹ãƒ¡ãƒ¢ãƒªãƒãƒƒãƒ•ã‚¡ã€‚"

#: ../../library/ssl.rst:2497
msgid "Return the number of bytes currently in the memory buffer."
msgstr "ç¾åœ¨ãƒ¡ãƒ¢ãƒªãƒãƒƒãƒ•ã‚¡ä¸­ã«ã‚ã‚‹ãƒã‚¤ãƒˆæ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:2501
msgid ""
"A boolean indicating whether the memory BIO is current at the end-of-file "
"position."
msgstr "ãƒ¡ãƒ¢ãƒª BIOãŒç¾åœ¨ãƒ•ã‚¡ã‚¤ãƒ«ã®æœ«å°¾ã«ã‚ã‚‹ã‹ã‚’è¡¨ã™çœŸå½å€¤ã§ã™ã€‚"

#: ../../library/ssl.rst:2506
msgid ""
"Read up to *n* bytes from the memory buffer. If *n* is not specified or "
"negative, all bytes are returned."
msgstr "ãƒ¡ãƒ¢ãƒªãƒãƒƒãƒ•ã‚¡ã‹ã‚‰æœ€å¤§ *n* èª­ã¿å–ã‚Šã¾ã™ã€‚*n*Â ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„ã‹ã€è² å€¤ã®å ´åˆã€ã™ã¹ã¦ã®ãƒã‚¤ãƒˆãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:2511
msgid ""
"Write the bytes from *buf* to the memory BIO. The *buf* argument must be an "
"object supporting the buffer protocol."
msgstr ""
"*buf* ã‹ã‚‰ãƒ¡ãƒ¢ãƒª BIO ã«ãƒã‚¤ãƒˆã‚’æ›¸ãè¾¼ã¿ã¾ã™ã€‚*buf* å¼•æ•°ã¯ã€ãƒãƒƒãƒ•ã‚¡ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:2514
msgid ""
"The return value is the number of bytes written, which is always equal to "
"the length of *buf*."
msgstr "æˆ»ã‚Šå€¤ã¯ã€æ›¸ãè¾¼ã¾ã‚Œã‚‹ãƒã‚¤ãƒˆæ•°ã§ã‚ã‚Šã€å¸¸ã« *buf* ã®é•·ã•ã¨ç­‰ã—ããªã‚Šã¾ã™ã€‚"

#: ../../library/ssl.rst:2519
msgid ""
"Write an EOF marker to the memory BIO. After this method has been called, it"
" is illegal to call :meth:`~MemoryBIO.write`. The attribute :attr:`eof` will"
" become true after all data currently in the buffer has been read."
msgstr ""
"EOF ãƒãƒ¼ã‚«ãƒ¼ã‚’ãƒ¡ãƒ¢ãƒª BIO ã«æ›¸ãè¾¼ã¿ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚ŒãŸå¾Œã« :meth:`~MemoryBIO.write` "
"ã‚’å‘¼ã¶ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚:attr:`eof` å±æ€§ã¯ã€ãƒãƒƒãƒ•ã‚¡å†…ã®ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ãŒèª­ã¿å‡ºã•ã‚ŒãŸå¾Œã« True ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/ssl.rst:2525
msgid "SSL session"
msgstr "SSL ã‚»ãƒƒã‚·ãƒ§ãƒ³"

#: ../../library/ssl.rst:2531
msgid "Session object used by :attr:`~SSLSocket.session`."
msgstr ":attr:`~SSLSocket.session` ãŒä½¿ç”¨ã™ã‚‹ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚"

#: ../../library/ssl.rst:2543
msgid "Security considerations"
msgstr "ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã§è€ƒæ…®ã™ã¹ãç‚¹"

#: ../../library/ssl.rst:2546
msgid "Best defaults"
msgstr "æœ€å–„ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤"

#: ../../library/ssl.rst:2548
msgid ""
"For **client use**, if you don't have any special requirements for your "
"security policy, it is highly recommended that you use the "
":func:`create_default_context` function to create your SSL context. It will "
"load the system's trusted CA certificates, enable certificate validation and"
" hostname checking, and try to choose reasonably secure protocol and cipher "
"settings."
msgstr ""
"**ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã§ã®ä½¿ç”¨** ã§ã¯ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒãƒªã‚·ãƒ¼ã«ã‚ˆã‚‹ç‰¹æ®Šãªè¦ä»¶ãŒãªã„é™ã‚Šã¯ã€ :func:`create_default_context` "
"é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ SSL ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œæˆã™ã‚‹ã“ã¨ã‚’å¼·ããŠå‹§ã‚ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ã€ã‚·ã‚¹ãƒ†ãƒ ã®ä¿¡é ¼æ¸ˆã¿ CA "
"è¨¼æ˜æ›¸ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã€è¨¼æ˜æ›¸ã®æ¤œè¨¼ã¨ãƒ›ã‚¹ãƒˆåã®ãƒã‚§ãƒƒã‚¯ã‚’æœ‰åŠ¹åŒ–ã—ã€ååˆ†ã«ã‚»ã‚­ãƒ¥ã‚¢ãªãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨æš—å·ã‚’é¸æŠã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:2555
msgid ""
"For example, here is how you would use the :class:`smtplib.SMTP` class to "
"create a trusted, secure connection to a SMTP server::"
msgstr ""
"ä¾‹ã¨ã—ã¦ã€ :class:`smtplib.SMTP` ã‚¯ãƒ©ã‚¹ã‚’ä½¿ç”¨ã—ã¦ SMTP "
"ã‚µãƒ¼ãƒãƒ¼ã«å¯¾ã—ã¦ä¿¡é ¼ã§ãã‚‹ã‚»ã‚­ãƒ¥ã‚¢ãªæ¥ç¶šã‚’è¡Œã†æ–¹æ³•ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™::"

#: ../../library/ssl.rst:2564
msgid ""
"If a client certificate is needed for the connection, it can be added with "
":meth:`SSLContext.load_cert_chain`."
msgstr "æ¥ç¶šã«ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®è¨¼æ˜æ›¸ãŒå¿…è¦ãªå ´åˆã€ :meth:`SSLContext.load_cert_chain` ã«ã‚ˆã£ã¦è¿½åŠ ã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:2567
msgid ""
"By contrast, if you create the SSL context by calling the "
":class:`SSLContext` constructor yourself, it will not have certificate "
"validation nor hostname checking enabled by default.  If you do so, please "
"read the paragraphs below to achieve a good security level."
msgstr ""
"å¯¾ç…§çš„ã«ã€è‡ªåˆ†è‡ªèº«ã§ :class:`SSLContext` ã‚¯ãƒ©ã‚¹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’å‘¼ã³å‡ºã™ã“ã¨ã«ã‚ˆã£ã¦ SSL "
"ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œã‚‹ã¨ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯è¨¼æ˜æ›¸æ¤œè¨¼ã‚‚ãƒ›ã‚¹ãƒˆåãƒã‚§ãƒƒã‚¯ã‚‚æœ‰åŠ¹ã«ãªã‚Šã¾ã›ã‚“ã€‚è‡ªåˆ†ã§è¨­å®šã‚’è¡Œã†å ´åˆã¯ã€ååˆ†ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒ™ãƒ«ã‚’é”æˆã™ã‚‹ãŸã‚ã«ã€ä»¥ä¸‹ã®ãƒ‘ãƒ©ã‚°ãƒ©ãƒ•ã‚’ãŠèª­ã¿ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:2573
msgid "Manual settings"
msgstr "æ‰‹å‹•ã§ã®è¨­å®š"

#: ../../library/ssl.rst:2576
msgid "Verifying certificates"
msgstr "è¨¼æ˜æ›¸ã®æ¤œè¨¼"

#: ../../library/ssl.rst:2578
msgid ""
"When calling the :class:`SSLContext` constructor directly, "
":const:`CERT_NONE` is the default.  Since it does not authenticate the other"
" peer, it can be insecure, especially in client mode where most of time you "
"would like to ensure the authenticity of the server you're talking to. "
"Therefore, when in client mode, it is highly recommended to use "
":const:`CERT_REQUIRED`.  However, it is in itself not sufficient; you also "
"have to check that the server certificate, which can be obtained by calling "
":meth:`SSLSocket.getpeercert`, matches the desired service.  For many "
"protocols and applications, the service can be identified by the hostname; "
"in this case, the :func:`match_hostname` function can be used.  This common "
"check is automatically performed when :attr:`SSLContext.check_hostname` is "
"enabled."
msgstr ""
":class:`SSLContext` ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ç›´æ¥å‘¼ã³å‡ºã—ãŸå ´åˆã€ :const:`CERT_NONE` "
"ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚ã“ã‚Œã¯æ¥ç¶šå…ˆã®èº«å…ƒç‰¹å®šã‚’ã—ãªã„ã®ã§å®‰å…¨ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã—ã€ç‰¹ã«ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ¢ãƒ¼ãƒ‰ã§ã¯å¤§æŠµç›¸æ‰‹ã¨ãªã‚‹ã‚µãƒ¼ãƒã®ä¿¡æ†‘æ€§ã‚’ä¿éšœã—ãŸã„ã§ã—ã‚‡ã†ã€‚ã§ã™ã‹ã‚‰ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ¢ãƒ¼ãƒ‰ã§ã¯"
" :const:`CERT_REQUIRED` ã‚’å¼·ããŠå‹§ã‚ã—ã¾ã™ã€‚ã§ã™ãŒã€ãã‚Œã ã‘ã§ã¯ä¸ååˆ†ã§ã™; "
":meth:`SSLSocket.getpeercert` "
"ã‚’å‘¼ã³å‡ºã—ã¦ã‚µãƒ¼ãƒè¨¼æ˜æ›¸ãŒæœ›ã‚“ã ã‚µãƒ¼ãƒ“ã‚¹ã¨åˆè‡´ã™ã‚‹ã‹ã®ãƒã‚§ãƒƒã‚¯ã‚‚ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å¤šãã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ã¨ã£ã¦ã€ã‚µãƒ¼ãƒ“ã‚¹ã¯ãƒ›ã‚¹ãƒˆåã§ç‰¹å®šã•ã‚Œã¾ã™;"
" ã“ã®å ´åˆã€ :func:`match_hostname` ãŒä½¿ãˆã¾ã™ã€‚ã“ã‚Œã‚‰ã®å…±é€šçš„ãªãƒã‚§ãƒƒã‚¯ã¯ "
":attr:`SSLContext.check_hostname` ãŒæœ‰åŠ¹ãªå ´åˆã€è‡ªå‹•çš„ã«è¡Œã‚ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:2591
msgid ""
"Hostname matchings is now performed by OpenSSL. Python no longer uses "
":func:`match_hostname`."
msgstr ""

#: ../../library/ssl.rst:2595
msgid ""
"In server mode, if you want to authenticate your clients using the SSL layer"
" (rather than using a higher-level authentication mechanism), you'll also "
"have to specify :const:`CERT_REQUIRED` and similarly check the client "
"certificate."
msgstr ""
"ã‚µãƒ¼ãƒãƒ¢ãƒ¼ãƒ‰ã«ãŠã„ã¦ã€(ã‚ˆã‚Šä¸Šä½ã®ãƒ¬ãƒ™ãƒ«ã§ã®èªè¨¼ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã§ã¯ãªã) SSL ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ä½¿ã£ã¦ã‚ãªãŸã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’èªè¨¼ã—ãŸã„ãªã‚‰ã°ã€ "
":const:`CERT_REQUIRED` ã‚’æŒ‡å®šã—ã¦åŒã˜ã‚ˆã†ã«ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®è¨¼æ˜æ›¸ã‚’æ¤œè¨¼ã™ã¹ãã§ã—ã‚‡ã†ã€‚"

#: ../../library/ssl.rst:2601
msgid "Protocol versions"
msgstr "ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³"

#: ../../library/ssl.rst:2603
msgid ""
"SSL versions 2 and 3 are considered insecure and are therefore dangerous to "
"use.  If you want maximum compatibility between clients and servers, it is "
"recommended to use :const:`PROTOCOL_TLS_CLIENT` or "
":const:`PROTOCOL_TLS_SERVER` as the protocol version. SSLv2 and SSLv3 are "
"disabled by default."
msgstr ""
"SSL ãƒãƒ¼ã‚¸ãƒ§ãƒ³ 2 ã¨ 3 "
"ã¯å®‰å…¨æ€§ã«æ¬ ã‘ã‚‹ã¨è€ƒãˆã‚‰ã‚Œã¦ãŠã‚Šã€ä½¿ç”¨ã™ã‚‹ã®ã¯å±é™ºã§ã™ã€‚ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã‚µãƒ¼ãƒé–“ã®äº’æ›æ€§ã‚’æœ€å¤§é™ã«ç¢ºä¿ã—ãŸã„å ´åˆã€ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ã—ã¦ "
":const:`PROTOCOL_TLS_CLIENT` ã¾ãŸã¯ :const:`PROTOCOL_TLS_SERVER` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚ "
"SSLv2 ã¨ SSLv3 ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ç„¡åŠ¹ã«ãªã£ã¦ã„ã¾ã™ã€‚"

#: ../../library/ssl.rst:2616
msgid ""
"The SSL context created above will only allow TLSv1.2 and later (if "
"supported by your system) connections to a server. "
":const:`PROTOCOL_TLS_CLIENT` implies certificate validation and hostname "
"checks by default. You have to load certificates into the context."
msgstr ""
"ä¸Šè¨˜ã§ä½œæˆã—ãŸ SSL ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¯ã€TLSv1.2 ä»¥é™ (ã‚·ã‚¹ãƒ†ãƒ ã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹å ´åˆ) "
"ã§ã®ã‚µãƒ¼ãƒã¸ã®æ¥ç¶šã®ã¿ã‚’è¨±å¯ã—ã¾ã™ã€‚:const:`PROTOCOL_TLS_CLIENT` "
"ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§è¨¼æ˜æ›¸ã®æ¤œè¨¼ã¨ãƒ›ã‚¹ãƒˆåã®ãƒã‚§ãƒƒã‚¯ã‚’æ„å‘³ã—ã¾ã™ã€‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆä¸­ã«è¨¼æ˜æ›¸ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/ssl.rst:2623
msgid "Cipher selection"
msgstr "æš—å·ã®é¸æŠ"

#: ../../library/ssl.rst:2625
msgid ""
"If you have advanced security requirements, fine-tuning of the ciphers "
"enabled when negotiating a SSL session is possible through the "
":meth:`SSLContext.set_ciphers` method.  Starting from Python 3.2.3, the ssl "
"module disables certain weak ciphers by default, but you may want to further"
" restrict the cipher choice. Be sure to read OpenSSL's documentation about "
"the `cipher list format "
"<https://www.openssl.org/docs/manmaster/man1/ciphers.html#CIPHER-LIST-"
"FORMAT>`_. If you want to check which ciphers are enabled by a given cipher "
"list, use :meth:`SSLContext.get_ciphers` or the ``openssl ciphers`` command "
"on your system."
msgstr ""

#: ../../library/ssl.rst:2636
msgid "Multi-processing"
msgstr "ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ã‚¹åŒ–"

#: ../../library/ssl.rst:2638
msgid ""
"If using this module as part of a multi-processed application (using, for "
"example the :mod:`multiprocessing` or :mod:`concurrent.futures` modules), be"
" aware that OpenSSL's internal random number generator does not properly "
"handle forked processes.  Applications must change the PRNG state of the "
"parent process if they use any SSL feature with :func:`os.fork`.  Any "
"successful call of :func:`~ssl.RAND_add`, :func:`~ssl.RAND_bytes` or "
":func:`~ssl.RAND_pseudo_bytes` is sufficient."
msgstr ""
"(ä¾‹ãˆã° :mod:`multiprocessing` ã‚„ :mod:`concurrent.futures` "
"ã‚’ä½¿ã£ã¦ã€)ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ã‚¹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ä¸€éƒ¨ã¨ã—ã¦ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã†å ´åˆã€OpenSSL ã®å†…éƒ¨ã®ä¹±æ•°ç™ºç”Ÿå™¨ã¯ fork "
"ã—ãŸãƒ—ãƒ­ã‚»ã‚¹ã‚’é©åˆ‡ã«å‡¦ç†ã—ãªã„ã“ã¨ã«æ°—ã‚’ä»˜ã‘ã¦ä¸‹ã•ã„ã€‚SSL ã®æ©Ÿèƒ½ã‚’ :func:`os.fork` ã¨ã¨ã‚‚ã«ä½¿ã†å ´åˆã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯è¦ªãƒ—ãƒ­ã‚»ã‚¹ã®"
" PRNG çŠ¶æ…‹ã‚’å¤‰æ›´ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ :func:`~ssl.RAND_add`, :func:`~ssl.RAND_bytes`, "
":func:`~ssl.RAND_pseudo_bytes` ã®ã„ãšã‚Œã‹ã®å‘¼ã³å‡ºã—æˆåŠŸãŒã‚ã‚Œã°ååˆ†ã§ã™ã€‚"

#: ../../library/ssl.rst:2650
msgid "TLS 1.3"
msgstr ""

#: ../../library/ssl.rst:2654
msgid ""
"Python has provisional and experimental support for TLS 1.3 with OpenSSL "
"1.1.1.  The new protocol behaves slightly differently than previous version "
"of TLS/SSL.  Some new TLS 1.3 features are not yet available."
msgstr ""

#: ../../library/ssl.rst:2658
msgid ""
"TLS 1.3 uses a disjunct set of cipher suites. All AES-GCM and ChaCha20 "
"cipher suites are enabled by default.  The method "
":meth:`SSLContext.set_ciphers` cannot enable or disable any TLS 1.3 ciphers "
"yet, but :meth:`SSLContext.get_cipers` returns them."
msgstr ""

#: ../../library/ssl.rst:2662
msgid ""
"Session tickets are no longer sent as part of the initial handshake and are "
"handled differently.  :attr:`SSLSocket.session` and :class:`SSLSession` are "
"not compatible with TLS 1.3."
msgstr ""

#: ../../library/ssl.rst:2665
msgid ""
"Client-side certificates are also no longer verified during the initial "
"handshake.  A server can request a certificate at any time.  Clients process"
" certificate requests while they send or receive application data from the "
"server."
msgstr ""

#: ../../library/ssl.rst:2669
msgid ""
"TLS 1.3 features like early data, deferred TLS client cert request, "
"signature algorithm configuration, and rekeying are not supported yet."
msgstr ""

#: ../../library/ssl.rst:2676
msgid "LibreSSL support"
msgstr ""

#: ../../library/ssl.rst:2678
msgid ""
"LibreSSL is a fork of OpenSSL 1.0.1. The ssl module has limited support for "
"LibreSSL. Some features are not available when the ssl module is compiled "
"with LibreSSL."
msgstr ""

#: ../../library/ssl.rst:2682
msgid ""
"LibreSSL >= 2.6.1 no longer supports NPN. The methods "
":meth:`SSLContext.set_npn_protocols` and "
":meth:`SSLSocket.selected_npn_protocol` are not available."
msgstr ""

#: ../../library/ssl.rst:2685
msgid ""
":meth:`SSLContext.set_default_verify_paths` ignores the env vars "
":envvar:`SSL_CERT_FILE` and :envvar:`SSL_CERT_PATH` although "
":func:`get_default_verify_paths` still reports them."
msgstr ""

#: ../../library/ssl.rst:2693
msgid "Class :class:`socket.socket`"
msgstr ":class:`socket.socket` ã‚¯ãƒ©ã‚¹"

#: ../../library/ssl.rst:2693
msgid "Documentation of underlying :mod:`socket` class"
msgstr "ä¸‹ä½ãƒ¬ã‚¤ãƒ¤ãƒ¼ã® :mod:`socket` ã‚¯ãƒ©ã‚¹ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ"

#: ../../library/ssl.rst:2696
msgid ""
"`SSL/TLS Strong Encryption: An Introduction "
"<https://httpd.apache.org/docs/trunk/en/ssl/ssl_intro.html>`_"
msgstr ""
"`SSL/TLS Strong Encryption: An Introduction "
"<https://httpd.apache.org/docs/trunk/en/ssl/ssl_intro.html>`_"

#: ../../library/ssl.rst:2696
msgid "Intro from the Apache HTTP Server documentation"
msgstr ""

#: ../../library/ssl.rst:2699
msgid ""
":rfc:`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: "
"Certificate-Based Key Management <1422>`"
msgstr ""

#: ../../library/ssl.rst:2699
msgid "Steve Kent"
msgstr "Steve Kent"

#: ../../library/ssl.rst:2702
msgid ":rfc:`RFC 4086: Randomness Requirements for Security <4086>`"
msgstr ""

#: ../../library/ssl.rst:2702
msgid "Donald E., Jeffrey I. Schiller"
msgstr ""

#: ../../library/ssl.rst:2705
msgid ""
":rfc:`RFC 5280: Internet X.509 Public Key Infrastructure Certificate and "
"Certificate Revocation List (CRL) Profile <5280>`"
msgstr ""

#: ../../library/ssl.rst:2705
msgid "D. Cooper"
msgstr ""

#: ../../library/ssl.rst:2708
msgid ""
":rfc:`RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 "
"<5246>`"
msgstr ""

#: ../../library/ssl.rst:2708
msgid "T. Dierks et. al."
msgstr "T. Dierks et. al."

#: ../../library/ssl.rst:2711
msgid ":rfc:`RFC 6066: Transport Layer Security (TLS) Extensions <6066>`"
msgstr ""

#: ../../library/ssl.rst:2711
msgid "D. Eastlake"
msgstr "D. Eastlake"

#: ../../library/ssl.rst:2714
msgid ""
"`IANA TLS: Transport Layer Security (TLS) Parameters "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml>`_"
msgstr ""
"`IANA TLS: Transport Layer Security (TLS) Parameters "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml>`_"

#: ../../library/ssl.rst:2714
msgid "IANA"
msgstr "IANA"

#: ../../library/ssl.rst:2717
msgid ""
":rfc:`RFC 7525: Recommendations for Secure Use of Transport Layer Security "
"(TLS) and Datagram Transport Layer Security (DTLS) <7525>`"
msgstr ""

#: ../../library/ssl.rst:2717
msgid "IETF"
msgstr ""

#: ../../library/ssl.rst:2719
msgid ""
"`Mozilla's Server Side TLS recommendations "
"<https://wiki.mozilla.org/Security/Server_Side_TLS>`_"
msgstr ""

#: ../../library/ssl.rst:2720
msgid "Mozilla"
msgstr ""
