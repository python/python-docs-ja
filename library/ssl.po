# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# 秘湯 <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-07-08 13:48+0900\n"
"PO-Revision-Date: 2018-07-08 04:58+0000\n"
"Last-Translator: cocoatomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/ssl.rst:2
msgid ":mod:`ssl` --- TLS/SSL wrapper for socket objects"
msgstr ":mod:`ssl` --- ソケットオブジェクトに対する TLS/SSL ラッパー"

#: ../../library/ssl.rst:17
msgid "**Source code:** :source:`Lib/ssl.py`"
msgstr "**Source code:** :source:`Lib/ssl.py`"

#: ../../library/ssl.rst:21
msgid ""
"This module provides access to Transport Layer Security (often known as "
"\"Secure Sockets Layer\") encryption and peer authentication facilities for "
"network sockets, both client-side and server-side.  This module uses the "
"OpenSSL library. It is available on all modern Unix systems, Windows, Mac OS"
" X, and probably additional platforms, as long as OpenSSL is installed on "
"that platform."
msgstr "このモジュールは Transport Layer Security (よく \"Secure Sockets Layer\" という名前で知られています) 暗号化と、クライアントサイド、サーバーサイド両方のネットワークソケットのためのピア認証の仕組みを提供しています。このモジュールはOpenSSLライブラリを利用しています。OpenSSLは、全てのモダンなUnixシステム、Windows、Mac OS X、その他幾つかの OpenSSLがインストールされているプラットフォームで利用できます。"

#: ../../library/ssl.rst:27
msgid "Updated to support linking with OpenSSL 1.1.0"
msgstr ""

#: ../../library/ssl.rst:32
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs.  The installed version of OpenSSL may also "
"cause variations in behavior. For example, TLSv1.1 and TLSv1.2 come with "
"openssl version 1.0.1."
msgstr "OSのソケットAPIに対して実装されているので、幾つかの挙動はプラットフォーム依存になるかもしれません。インストールされているOpenSSLのバージョンの違いも挙動の違いの原因になるかもしれません。例えば、TLSv1.1, TLSv1.2 は openssl version 1.0.1 以降でのみ利用出来ます。"

#: ../../library/ssl.rst:38
msgid ""
"Don't use this module without reading the :ref:`ssl-security`.  Doing so may"
" lead to a false sense of security, as the default settings of the ssl "
"module are not necessarily appropriate for your application."
msgstr ":ref:`ssl-security` を読まずにこのモジュールを使用しないでください。SSL のデフォルト設定はアプリケーションに十分ではないので、読まない場合はセキュリティに誤った意識を持ってしまうかもしれません。"

#: ../../library/ssl.rst:43
msgid ""
"This section documents the objects and functions in the ``ssl`` module; for "
"more general information about TLS, SSL, and certificates, the reader is "
"referred to the documents in the \"See Also\" section at the bottom."
msgstr "このセクションでは、 ``ssl`` モジュールのオブジェクトと関数の解説します。 TLS, SSL, certificates に関するより一般的な情報は、末尾にある \"See Also\" のセクションを参照してください。"

#: ../../library/ssl.rst:47
msgid ""
"This module provides a class, :class:`ssl.SSLSocket`, which is derived from "
"the :class:`socket.socket` type, and provides a socket-like wrapper that "
"also encrypts and decrypts the data going over the socket with SSL.  It "
"supports additional methods such as :meth:`getpeercert`, which retrieves the"
" certificate of the other side of the connection, and :meth:`cipher`,which "
"retrieves the cipher being used for the secure connection."
msgstr "このモジュールは1つのクラス、 :class:`ssl.SSLSocket` を提供します。このクラスは :class:`socket.socket` クラスを継承していて、ソケットで通信されるデータをSSLで暗号化・復号するソケットに似たラッパーになります。また、このクラスは追加で、接続の相手側からの証明書を取得する :meth:`getpeercert` メソッド、セキュア接続で使うための暗号方式を取得する :meth:`cipher` のようなメソッドをサポートしています。"

#: ../../library/ssl.rst:54
msgid ""
"For more sophisticated applications, the :class:`ssl.SSLContext` class helps"
" manage settings and certificates, which can then be inherited by SSL "
"sockets created through the :meth:`SSLContext.wrap_socket` method."
msgstr "より洗練されたアプリケーションのために、 :class:`ssl.SSLContext` クラスが設定と証明書の管理の助けとなるでしょう。それは :meth:`SSLContext.wrap_socket` メソッドを通して SSL ソケットを作成することで引き継がれます。"

#: ../../library/ssl.rst:60
msgid "Functions, Constants, and Exceptions"
msgstr "関数、定数、例外"

#: ../../library/ssl.rst:64
msgid ""
"Raised to signal an error from the underlying SSL implementation (currently "
"provided by the OpenSSL library).  This signifies some problem in the "
"higher-level encryption and authentication layer that's superimposed on the "
"underlying network connection.  This error is a subtype of "
":exc:`socket.error`, which in turn is a subtype of :exc:`IOError`.  The "
"error code and message of :exc:`SSLError` instances are provided by the "
"OpenSSL library."
msgstr "(現在のところ OpenSSL ライブラリによって提供されている)下層の SSL 実装からのエラーを伝えるための例外です。このエラーは、低レベルなネットワークの上に載っている、高レベルな暗号化と認証レイヤーでの問題を通知します。このエラーは :exc:`socket.error` のサブタイプで、 :exc:`socket.error` は :exc:`IOError` のサブタイプです。 :exc:`SSLError` インスタンスのエラーコードとメッセージは OpenSSL ライブラリによるものです。"

#: ../../library/ssl.rst:74
msgid ""
"A string mnemonic designating the OpenSSL submodule in which the error "
"occurred, such as ``SSL``, ``PEM`` or ``X509``.  The range of possible "
"values depends on the OpenSSL version."
msgstr "エラーが起こった OpenSSL サブモジュールを示すニーモニック文字列で、 ``SSL``, ``PEM``, ``X509`` などです。取り得る値は OpenSSL のバージョンに依存します。"

#: ../../library/ssl.rst:82
msgid ""
"A string mnemonic designating the reason this error occurred, for example "
"``CERTIFICATE_VERIFY_FAILED``.  The range of possible values depends on the "
"OpenSSL version."
msgstr "エラーが起こった原因を示すニーモニック文字列で、 ``CERTIFICATE_VERIFY_FAILED`` などです。取り得る値は OpenSSL のバージョンに依存します。"

#: ../../library/ssl.rst:90
msgid ""
"A subclass of :exc:`SSLError` raised when trying to read or write and the "
"SSL connection has been closed cleanly.  Note that this doesn't mean that "
"the underlying transport (read TCP) has been closed."
msgstr "読み出しあるいは書き込みを試みようとした際に SSL コネクションが行儀よく閉じられてしまった場合に送出される :exc:`SSLError` サブクラス例外です。これは下層の転送(read TCP)が閉じたことは意味しないことに注意してください。"

#: ../../library/ssl.rst:98
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket "
"<ssl-nonblocking>` when trying to read or write data, but more data needs to"
" be received on the underlying TCP transport before the request can be "
"fulfilled."
msgstr "読み出しあるいは書き込みを試みようとした際に、リクエストが遂行される前に下層の TCP 転送で受け取る必要があるデータが不足した場合に :ref:`non-blocking SSL socket <ssl-nonblocking>` によって送出される :exc:`SSLError` サブクラス例外です。"

#: ../../library/ssl.rst:107
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket "
"<ssl-nonblocking>` when trying to read or write data, but more data needs to"
" be sent on the underlying TCP transport before the request can be "
"fulfilled."
msgstr "読み出しあるいは書き込みを試みようとした際に、リクエストが遂行される前に下層の TCP 転送が送信する必要があるデータが不足した場合に :ref:`non-blocking SSL socket <ssl-nonblocking>` によって送出される :exc:`SSLError` サブクラス例外です。"

#: ../../library/ssl.rst:116
msgid ""
"A subclass of :exc:`SSLError` raised when a system error was encountered "
"while trying to fulfill an operation on a SSL socket.  Unfortunately, there "
"is no easy way to inspect the original errno number."
msgstr "SSL ソケット上で操作を遂行しようとしていてシステムエラーが起こった場合に送出される :exc:`SSLError` サブクラス例外です。残念ながら元となった errno 番号を調べる簡単な方法はありません。"

#: ../../library/ssl.rst:124
msgid ""
"A subclass of :exc:`SSLError` raised when the SSL connection has been "
"terminated abruptly.  Generally, you shouldn't try to reuse the underlying "
"transport when this error is encountered."
msgstr "SSL コネクションが唐突に打ち切られた際に送出される :exc:`SSLError` サブクラス例外です。一般的に、このエラーが起こったら下層の転送を再利用しようと試みるべきではありません。"

#: ../../library/ssl.rst:132
msgid ""
"Raised to signal an error with a certificate (such as mismatching hostname)."
"  Certificate errors detected by OpenSSL, though, raise an :exc:`SSLError`."
msgstr "証明書のエラー(ホスト名のミスマッチのような)を通知するために送出されます。ただし、OpenSSL によって検出された場合の証明書エラーは :exc:`SSLError` です。"

#: ../../library/ssl.rst:138
msgid "Socket creation"
msgstr "ソケットの作成"

#: ../../library/ssl.rst:140
msgid ""
"The following function allows for standalone socket creation.  Starting from"
" Python 2.7.9, it can be more flexible to use :meth:`SSLContext.wrap_socket`"
" instead."
msgstr "以下に示す関数は、スタンドアロンでソケットを作りたい場合に使います。Python 2.7.9 からは、これよりもっと柔軟な :meth:`SSLContext.wrap_socket` が使えます。"

#: ../../library/ssl.rst:146
msgid ""
"Takes an instance ``sock`` of :class:`socket.socket`, and returns an "
"instance of :class:`ssl.SSLSocket`, a subtype of :class:`socket.socket`, "
"which wraps the underlying socket in an SSL context.  ``sock`` must be a "
":data:`~socket.SOCK_STREAM` socket; other socket types are unsupported."
msgstr ":class:`socket.socket` のインスタンス ``sock`` を受け取り、 :class:`socket.socket` のサブタイプである :class:`ssl.SSLSocket` のインスタンスを返します。 :class:`ssl.SSLSocket` は低レイヤのソケットをSSLコンテキストでラップします。 ``sock`` は :data:`~socket.SOCK_STREAM` ソケットでなければなりません; ほかのタイプのソケットはサポートされていません。"

#: ../../library/ssl.rst:151
msgid ""
"For client-side sockets, the context construction is lazy; if the underlying"
" socket isn't connected yet, the context construction will be performed "
"after :meth:`connect` is called on the socket.  For server-side sockets, if "
"the socket has no remote peer, it is assumed to be a listening socket, and "
"the server-side SSL wrapping is automatically performed on client "
"connections accepted via the :meth:`accept` method.  :func:`wrap_socket` may"
" raise :exc:`SSLError`."
msgstr "クライアントサイドソケットにおいて、コンテキストの生成は遅延されます。つまり、低レイヤのソケットがまだ接続されていない場合、コンテキストの生成はそのソケットの :meth:`connect` メソッドが呼ばれた後に行われます。サーバーサイドソケットの場合、そのソケットに接続先が居なければそれは listen 用ソケットだと判断されます。 :meth:`accept` メソッドで生成されるクライアント接続に対してのサーバーサイド SSLラップは自動的に行われます。 :func:`wrap_socket` は :exc:`SSLError` を送出することがあります。"

#: ../../library/ssl.rst:159
msgid ""
"The ``keyfile`` and ``certfile`` parameters specify optional files which "
"contain a certificate to be used to identify the local side of the "
"connection.  See the discussion of :ref:`ssl-certificates` for more "
"information on how the certificate is stored in the ``certfile``."
msgstr "オプションの ``keyfile`` と ``certfile`` 引数は、接続のこちら側を識別するために利用される証明書を含むファイルを指定します。証明書がどのように ``certfile`` に格納されるかについてのより詳しい情報は、 :ref:`ssl-certificates` を参照してください。"

#: ../../library/ssl.rst:164
msgid ""
"The parameter ``server_side`` is a boolean which identifies whether server-"
"side or client-side behavior is desired from this socket."
msgstr "``server_side`` 引数は真偽値で、このソケットがサーバーサイドとクライアントサイドのどちらの動作をするのかを指定します。"

#: ../../library/ssl.rst:167
msgid ""
"The parameter ``cert_reqs`` specifies whether a certificate is required from"
" the other side of the connection, and whether it will be validated if "
"provided.  It must be one of the three values :const:`CERT_NONE` "
"(certificates ignored), :const:`CERT_OPTIONAL` (not required, but validated "
"if provided), or :const:`CERT_REQUIRED` (required and validated).  If the "
"value of this parameter is not :const:`CERT_NONE`, then the ``ca_certs`` "
"parameter must point to a file of CA certificates."
msgstr "``cert_reqs`` 引数は、接続の相手側からの証明書を必要とするかどうかと、それを検証(validate)するかどうかを指定します。これは次の3つの定数のどれかで無ければなりません: :const:`CERT_NONE` (証明書は無視されます), :const:`CERT_OPTIONAL` (必要としないが、提供された場合は検証する), :const:`CERT_REQUIRED` (証明書を必要とし、検証する)。もしこの引数が :const:`CERT_NONE` 以外だった場合、 ``ca_certs`` 引数はCA証明書ファイルを指定していなければなりません。"

#: ../../library/ssl.rst:175
msgid ""
"The ``ca_certs`` file contains a set of concatenated \"certification "
"authority\" certificates, which are used to validate certificates passed "
"from the other end of the connection.  See the discussion of :ref:`ssl-"
"certificates` for more information about how to arrange the certificates in "
"this file."
msgstr "``ca_certs`` ファイルは、接続の相手側から渡された証明書を検証するために使う、一連のCA証明書を結合したものを含んでいます。このファイル内にどう証明書を並べるかについての詳しい情報は :ref:`ssl-certificates` を参照してください。"

#: ../../library/ssl.rst:181
msgid ""
"The parameter ``ssl_version`` specifies which version of the SSL protocol to"
" use.  Typically, the server chooses a particular protocol version, and the "
"client must adapt to the server's choice.  Most of the versions are not "
"interoperable with the other versions.  If not specified, the default is "
":data:`PROTOCOL_SSLv23`; it provides the most compatibility with other "
"versions."
msgstr "``ssl_version`` 引数は、使用するSSLプロトコルのバージョンを指定します。通常、サーバー側が特定のプロトコルバージョンを選び、クライアント側はサーバーの選んだプロトコルを受け入れなければなりません。ほとんどのバージョンは他のバージョンと互換性がありません。もしこの引数が指定されなかった場合、デフォルトは :data:`PROTOCOL_SSLv23` になります。このバージョンは、できるだけの互換性を確保するように選ばれています。"

#: ../../library/ssl.rst:188
msgid ""
"Here's a table showing which versions in a client (down the side) can "
"connect to which versions in a server (along the top):"
msgstr "次のテーブルは、どのクライアント側のバージョンがどのサーバー側のバージョンに接続できるかを示しています:"

#: ../../library/ssl.rst:194
msgid "*client* / **server**"
msgstr "*client* / **server**"

#: ../../library/ssl.rst:194
msgid "**SSLv2**"
msgstr "**SSLv2**"

#: ../../library/ssl.rst:194
msgid "**SSLv3**"
msgstr "**SSLv3**"

#: ../../library/ssl.rst:194
msgid "**SSLv23**"
msgstr "**SSLv23**"

#: ../../library/ssl.rst:194
msgid "**TLSv1**"
msgstr "**TLSv1**"

#: ../../library/ssl.rst:194
msgid "**TLSv1.1**"
msgstr "**TLSv1.1**"

#: ../../library/ssl.rst:194
msgid "**TLSv1.2**"
msgstr "**TLSv1.2**"

#: ../../library/ssl.rst:196
msgid "*SSLv2*"
msgstr "*SSLv2*"

#: ../../library/ssl.rst:196 ../../library/ssl.rst:196
#: ../../library/ssl.rst:197 ../../library/ssl.rst:197
#: ../../library/ssl.rst:198 ../../library/ssl.rst:198
#: ../../library/ssl.rst:198 ../../library/ssl.rst:198
#: ../../library/ssl.rst:198 ../../library/ssl.rst:199
#: ../../library/ssl.rst:199 ../../library/ssl.rst:200
#: ../../library/ssl.rst:200 ../../library/ssl.rst:201
#: ../../library/ssl.rst:201
msgid "yes"
msgstr "yes"

#: ../../library/ssl.rst:196 ../../library/ssl.rst:196
#: ../../library/ssl.rst:196 ../../library/ssl.rst:196
#: ../../library/ssl.rst:197 ../../library/ssl.rst:197
#: ../../library/ssl.rst:197 ../../library/ssl.rst:197
#: ../../library/ssl.rst:198 ../../library/ssl.rst:199
#: ../../library/ssl.rst:199 ../../library/ssl.rst:199
#: ../../library/ssl.rst:199 ../../library/ssl.rst:200
#: ../../library/ssl.rst:200 ../../library/ssl.rst:200
#: ../../library/ssl.rst:200 ../../library/ssl.rst:201
#: ../../library/ssl.rst:201 ../../library/ssl.rst:201
#: ../../library/ssl.rst:201
msgid "no"
msgstr "no"

#: ../../library/ssl.rst:197
msgid "*SSLv3*"
msgstr "*SSLv3*"

#: ../../library/ssl.rst:198
msgid "*SSLv23* [1]_"
msgstr ""

#: ../../library/ssl.rst:199
msgid "*TLSv1*"
msgstr "*TLSv1*"

#: ../../library/ssl.rst:200
msgid "*TLSv1.1*"
msgstr "*TLSv1.1*"

#: ../../library/ssl.rst:201
msgid "*TLSv1.2*"
msgstr "*TLSv1.2*"

#: ../../library/ssl.rst:204
msgid "Footnotes"
msgstr "脚注"

#: ../../library/ssl.rst:205
msgid ""
"TLS 1.3 protocol will be available with :data:`PROTOCOL_SSLv23` in OpenSSL "
">= 1.1.1. There is no dedicated PROTOCOL constant for just TLS 1.3."
msgstr ""

#: ../../library/ssl.rst:211
msgid ""
"Which connections succeed will vary depending on the version of OpenSSL.  "
"For example, before OpenSSL 1.0.0, an SSLv23 client would always attempt "
"SSLv2 connections."
msgstr "どの接続が成功するかは、 OpenSSL のバージョンに依存して大きく変わります。例えば、OpenSSL 1.0.0 以前は、SSLv23 クライアントは常に SSLv2 接続を試みていました。"

#: ../../library/ssl.rst:215
msgid ""
"The *ciphers* parameter sets the available ciphers for this SSL object. It "
"should be a string in the `OpenSSL cipher list format "
"<https://www.openssl.org/docs/manmaster/man1/ciphers.html>`_."
msgstr ""

#: ../../library/ssl.rst:219
msgid ""
"The parameter ``do_handshake_on_connect`` specifies whether to do the SSL "
"handshake automatically after doing a :meth:`socket.connect`, or whether the"
" application program will call it explicitly, by invoking the "
":meth:`SSLSocket.do_handshake` method.  Calling "
":meth:`SSLSocket.do_handshake` explicitly gives the program control over the"
" blocking behavior of the socket I/O involved in the handshake."
msgstr "``do_handshake_on_connect`` 引数は、 :meth:`socket.connect` の後に自動的に SSLハンドシェイクを行うか、それともアプリケーションが明示的に :meth:`SSLSocket.do_handshake` メソッドを実行するかを指定します。 :meth:`SSLSocket.do_handshake` を明示的に呼びだすことで、ハンドシェイクによるソケットI/Oのブロッキング動作を制御できます。"

#: ../../library/ssl.rst:226
msgid ""
"The parameter ``suppress_ragged_eofs`` specifies how the "
":meth:`SSLSocket.read` method should signal unexpected EOF from the other "
"end of the connection.  If specified as :const:`True` (the default), it "
"returns a normal EOF (an empty bytes object) in response to unexpected EOF "
"errors raised from the underlying socket; if :const:`False`, it will raise "
"the exceptions back to the caller."
msgstr "``suppress_ragged_eofs`` 引数は、 :meth:`SSLSocket.read` メソッドが、接続先から予期しないEOF を受け取った時に通知する方法を指定します。 :const:`True` (デフォルト) の場合、下位のソケットレイヤーから予期せぬEOFエラーが来た場合、通常のEOF (空のバイト列オブジェクト)を返します。 :const:`False` の場合、呼び出し元に例外を投げて通知します。"

#: ../../library/ssl.rst:233
msgid "New optional argument *ciphers*."
msgstr "新しいオプション引数 *ciphers*"

#: ../../library/ssl.rst:238
msgid "Context creation"
msgstr "コンテキストの作成"

#: ../../library/ssl.rst:240
msgid ""
"A convenience function helps create :class:`SSLContext` objects for common "
"purposes."
msgstr "コンビニエンス関数が、共通の目的で使用される :class:`SSLContext` オブジェクトを作成するのに役立ちます。"

#: ../../library/ssl.rst:245
msgid ""
"Return a new :class:`SSLContext` object with default settings for the given "
"*purpose*.  The settings are chosen by the :mod:`ssl` module, and usually "
"represent a higher security level than when calling the :class:`SSLContext` "
"constructor directly."
msgstr "新規の :class:`SSLContext` オブジェクトを、与えられた *purpose* のデフォルト設定で返します。設定は :mod:`ssl` モジュールで選択され、通常は :class:`SSLContext` のコンストラクタを直接呼び出すよりも高いセキュリティレベルを表現します。"

#: ../../library/ssl.rst:250
msgid ""
"*cafile*, *capath*, *cadata* represent optional CA certificates to trust for"
" certificate verification, as in :meth:`SSLContext.load_verify_locations`.  "
"If all three are :const:`None`, this function can choose to trust the "
"system's default CA certificates instead."
msgstr "*cafile*, *capath*, *cadata* は証明書の検証で信用するオプションの CA 証明書で、 :meth:`SSLContext.load_verify_locations` のものと同じです。これら 3 つ全てが :const:`None` であれば、この関数は代わりにシステムのデフォルトの CA 証明書を信用して選択することが出来ます。"

#: ../../library/ssl.rst:256
msgid ""
"The settings are: :data:`PROTOCOL_SSLv23`, :data:`OP_NO_SSLv2`, and "
":data:`OP_NO_SSLv3` with high encryption cipher suites without RC4 and "
"without unauthenticated cipher suites. Passing :data:`~Purpose.SERVER_AUTH` "
"as *purpose* sets :data:`~SSLContext.verify_mode` to :data:`CERT_REQUIRED` "
"and either loads CA certificates (when at least one of *cafile*, *capath* or"
" *cadata* is given) or uses :meth:`SSLContext.load_default_certs` to load "
"default CA certificates."
msgstr "これで作られる設定はこのようになります: RC4 を除く、高レベルで、未認証のものを含まない暗号化一式と :data:`PROTOCOL_SSLv23`, :data:`OP_NO_SSLv2`, :data:`OP_NO_SSLv3` 。 *purpose* に :data:`~Purpose.SERVER_AUTH` を渡すと、 :data:`~SSLContext.verify_mode` には :data:`CERT_REQUIRED` がセットされ、(*cafile*, *capath*, *cadata* のいずれかが与えられれば) CA 証明書がロードされるかまたはデフォルトの CA 証明書をロードするために :meth:`SSLContext.load_default_certs` が使われます。"

#: ../../library/ssl.rst:265
msgid ""
"The protocol, options, cipher and other settings may change to more "
"restrictive values anytime without prior deprecation.  The values represent "
"a fair balance between compatibility and security."
msgstr "プロトコル、オプション、暗号その他設定はもっと制限された、過去の廃れたものを含まない値にいつでも出来るでしょう。この値は互換性と安全性の公平なバランスを表明しています。"

#: ../../library/ssl.rst:269
msgid ""
"If your application needs specific settings, you should create a "
":class:`SSLContext` and apply the settings yourself."
msgstr "もしもあなたのアプリケーションがそのような設定を必要とするのであれば、 :class:`SSLContext` を作ってあなた自身の設定を適用すべきです。"

#: ../../library/ssl.rst:273
msgid ""
"If you find that when certain older clients or servers attempt to connect "
"with a :class:`SSLContext` created by this function that they get an error "
"stating \"Protocol or cipher suite mismatch\", it may be that they only "
"support SSL3.0 which this function excludes using the :data:`OP_NO_SSLv3`. "
"SSL3.0 is widely considered to be `completely broken "
"<https://en.wikipedia.org/wiki/POODLE>`_. If you still wish to continue to "
"use this function but still allow SSL 3.0 connections you can re-enable them"
" using::"
msgstr "ある種の古いクライアントやサーバが接続しようと試みてきた場合に、この関数で作られた :class:`SSLContext` が \"Protocol or cipher suite mismatch\" で始まるエラーを起こすのを目撃したらそれは、この関数が :data:`OP_NO_SSLv3` を使って除外している SSL 3.0 しかサポートしていないのでしょう。SSL 3.0 は `完璧にぶっ壊れている <https://en.wikipedia.org/wiki/POODLE>`_ ことが広く知られています。それでもまだこの関数を使って、ただし SSL 3.0 接続を許可したいと望むならば、これをこのように再有効化出来ます::"

#: ../../library/ssl.rst:289
msgid "RC4 was dropped from the default cipher string."
msgstr "デフォルトの暗号設定から RC4 が除かれました。"

#: ../../library/ssl.rst:293
msgid "ChaCha20/Poly1305 was added to the default cipher string."
msgstr "デフォルトの暗号化文字列に ChaCha20/Poly1305 が追加されました。"

#: ../../library/ssl.rst:295
msgid "3DES was dropped from the default cipher string."
msgstr "デフォルトの暗号化文字列から 3DES が除かれました。"

#: ../../library/ssl.rst:299
msgid ""
"TLS 1.3 cipher suites TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384, and "
"TLS_CHACHA20_POLY1305_SHA256 were added to the default cipher string."
msgstr ""

#: ../../library/ssl.rst:304
msgid ""
"Specifies whether or not server certificates are verified when creating "
"client HTTPS connections without specifying a particular SSL context."
msgstr ""

#: ../../library/ssl.rst:307
msgid ""
"Starting with Python 2.7.9, :mod:`httplib` and modules which use it, such as"
" :mod:`urllib2` and :mod:`xmlrpclib`, default to verifying remote server "
"certificates received when establishing client HTTPS connections. This "
"default verification checks that the certificate is signed by a Certificate "
"Authority in the system trust store and that the Common Name (or Subject "
"Alternate Name) on the presented certificate matches the requested host."
msgstr ""

#: ../../library/ssl.rst:314
msgid ""
"Setting *enable* to :const:`True` ensures this default behaviour is in "
"effect."
msgstr ""

#: ../../library/ssl.rst:317
msgid ""
"Setting *enable* to :const:`False` reverts the default HTTPS certificate "
"handling to that of Python 2.7.8 and earlier, allowing connections to "
"servers using self-signed certificates, servers using certificates signed by"
" a Certicate Authority not present in the system trust store, and servers "
"where the hostname does not match the presented server certificate."
msgstr ""

#: ../../library/ssl.rst:323
msgid ""
"The leading underscore on this function denotes that it intentionally does "
"not exist in any implementation of Python 3 and may not be present in all "
"Python 2.7 implementations. The portable approach to bypassing certificate "
"checks or the system trust store when necessary is for tools to enable that "
"on a case-by-case basis by explicitly passing in a suitably configured SSL "
"context, rather than reverting the default behaviour of the standard library"
" client modules."
msgstr ""

#: ../../library/ssl.rst:335
msgid ""
"`CVE-2014-9365 <http://cve.mitre.org/cgi-"
"bin/cvename.cgi?name=CVE-2014-9365>`_ -- HTTPS man-in-the-middle attack "
"against Python clients using default settings"
msgstr ""

#: ../../library/ssl.rst:337
msgid ":pep:`476` -- Enabling certificate verification by default for HTTPS"
msgstr ""

#: ../../library/ssl.rst:338
msgid ":pep:`493` -- HTTPS verification migration tools for Python 2.7"
msgstr ""

#: ../../library/ssl.rst:342
msgid "Random generation"
msgstr "乱数生成"

#: ../../library/ssl.rst:346
msgid ""
"OpenSSL has deprecated :func:`ssl.RAND_pseudo_bytes`, use "
":func:`ssl.RAND_bytes` instead."
msgstr "OpenSSL は :func:`ssl.RAND_pseudo_bytes` を廃止しました。代わりに :func:`ssl.RAND_bytes` を使用してください。"

#: ../../library/ssl.rst:352
msgid ""
"Return ``True`` if the SSL pseudo-random number generator has been seeded "
"with 'enough' randomness, and ``False`` otherwise.  You can use "
":func:`ssl.RAND_egd` and :func:`ssl.RAND_add` to increase the randomness of "
"the pseudo-random number generator."
msgstr "SSL 擬似乱数生成器が十分なランダム性(randomness)を受け取っている時に ``True`` を、それ以外の場合は `False` を返します。 :func:`ssl.RAND_egd` と :func:`ssl.RAND_add` を使って擬似乱数生成機にランダム性を加えることができます。"

#: ../../library/ssl.rst:359
msgid ""
"If you are running an entropy-gathering daemon (EGD) somewhere, and *path* "
"is the pathname of a socket connection open to it, this will read 256 bytes "
"of randomness from the socket, and add it to the SSL pseudo-random number "
"generator to increase the security of generated secret keys.  This is "
"typically only necessary on systems without better sources of randomness."
msgstr "もしエントロピー収集デーモン(EGD=entropy-gathering daemon)が動いていて、 *path* がEGDへのソケットのパスだった場合、この関数はそのソケットから 256バイトのランダム性を読み込み、SSL擬似乱数生成器にそれを渡すことで、生成される暗号鍵のセキュリティを向上させることができます。これは、より良いランダム性のソースが無いシステムでのみ必要です。"

#: ../../library/ssl.rst:365
msgid ""
"See http://egd.sourceforge.net/ or http://prngd.sourceforge.net/ for sources"
" of entropy-gathering daemons."
msgstr "エントロピー収集デーモンについては、 http://egd.sourceforge.net/ や http://prngd.sourceforge.net/ を参照してください。"

#: ../../library/ssl.rst:368
msgid "Availability: not available with LibreSSL and OpenSSL > 1.1.0"
msgstr "利用出来る環境: LibreSSL および 1.1.0 を超えるバージョンの OpenSSL では利用できません。"

#: ../../library/ssl.rst:372
msgid ""
"Mix the given *bytes* into the SSL pseudo-random number generator.  The "
"parameter *entropy* (a float) is a lower bound on the entropy contained in "
"string (so you can always use :const:`0.0`).  See :rfc:`1750` for more "
"information on sources of entropy."
msgstr "与えられた *bytes* をSSL擬似乱数生成器に混ぜます。 *entropy* 引数(float値)は、その文字列に含まれるエントロピーの下限(lower bound)です。 (なので、いつでも :const:`0.0` を使うことができます。) エントロピーのソースについてのより詳しい情報は、 :rfc:`1750` を参照してください。"

#: ../../library/ssl.rst:378
msgid "Certificate handling"
msgstr "証明書の取り扱い"

#: ../../library/ssl.rst:382
msgid ""
"Verify that *cert* (in decoded format as returned by "
":meth:`SSLSocket.getpeercert`) matches the given *hostname*.  The rules "
"applied are those for checking the identity of HTTPS servers as outlined in "
":rfc:`2818` and :rfc:`6125`, except that IP addresses are not currently "
"supported. In addition to HTTPS, this function should be suitable for "
"checking the identity of servers in various SSL-based protocols such as "
"FTPS, IMAPS, POPS and others."
msgstr "(:meth:`SSLSocket.getpeercert` が返してきたようなデコードされたフォーマットの) *cert* が、与えられた *hostname* に合致するかを検証します。HTTPS サーバの身元をチェックするために適用されるルールは :rfc:`2818`, :rfc:`6125` で概説されているものです。ただし IP アドレスによるものは現在サポートされていません。HTTPS に加え、この関数は他の SSL ベースのプロトコル、例えば FTPS, IMAPS, POPS などのサーバの身元をチェックするのに相応しいはずです。"

#: ../../library/ssl.rst:390
msgid ""
":exc:`CertificateError` is raised on failure. On success, the function "
"returns nothing::"
msgstr "失敗すれば :exc:`CertificateError` が送出されます。成功すれば、この関数は何も返しません::"

#: ../../library/ssl.rst:406
msgid ""
"Return the time in seconds since the Epoch, given the ``cert_time`` string "
"representing the \"notBefore\" or \"notAfter\" date from a certificate in "
"``\"%b %d %H:%M:%S %Y %Z\"`` strptime format (C locale)."
msgstr "``cert_time`` として証明書内の \"notBefore\" や \"notAfter\" の ``\"%b %d %H:%M:%S %Y %Z\"`` strptime フォーマット (C locale) 日付を渡すと、エポックからの積算秒を返します。"

#: ../../library/ssl.rst:411
msgid "Here's an example:"
msgstr "例です。 :"

#: ../../library/ssl.rst:423
msgid "\"notBefore\" or \"notAfter\" dates must use GMT (:rfc:`5280`)."
msgstr "\"notBefore\" や \"notAfter\" の日付には GMT を使わなければなりません(:rfc:`5280`)。"

#: ../../library/ssl.rst:425
msgid ""
"Interpret the input time as a time in UTC as specified by 'GMT' timezone in "
"the input string. Local timezone was used previously. Return an integer (no "
"fractions of a second in the input format)"
msgstr "入力文字列に指定された 'GMT' タイムゾーンを UTC として解釈するようになりました。以前はローカルタイムで解釈していました。また、整数を返すようになりました(入力に含まれる秒の端数を含まない)。"

#: ../../library/ssl.rst:433
msgid ""
"Given the address ``addr`` of an SSL-protected server, as a (*hostname*, "
"*port-number*) pair, fetches the server's certificate, and returns it as a "
"PEM-encoded string.  If ``ssl_version`` is specified, uses that version of "
"the SSL protocol to attempt to connect to the server.  If ``ca_certs`` is "
"specified, it should be a file containing a list of root certificates, the "
"same format as used for the same parameter in :func:`wrap_socket`.  The call"
" will attempt to validate the server certificate against that set of root "
"certificates, and will fail if the validation attempt fails."
msgstr "SSLで保護されたサーバーのアドレス ``addr`` を (*hostname*, *port-number*) の形で受け取り、そのサーバーから証明書を取得し、それを PEMエンコードされた文字列として返します。 ``ssl_version`` が指定された場合は、サーバーに接続を試みるときにそのバージョンのSSLプロトコルを利用します。 ``ca_certs`` が指定された場合、それは :func:`wrap_socket` の同名の引数と同じフォーマットで、ルート証明書のリストを含むファイルでなければなりません。この関数はサーバー証明書をルート証明書リストに対して認証し、認証が失敗した場合にこの関数も失敗します。"

#: ../../library/ssl.rst:444
msgid ""
"This function is now IPv6-compatible, and the default *ssl_version* is "
"changed from :data:`PROTOCOL_SSLv3` to :data:`PROTOCOL_SSLv23` for maximum "
"compatibility with modern servers."
msgstr "この関数は IPv6 互換になりました。 *ssl_version* のデフォルトが、最近のサーバへの最大限の互換性のために :data:`PROTOCOL_SSLv3` から :data:`PROTOCOL_SSLv23` に変更されました。"

#: ../../library/ssl.rst:450
msgid ""
"Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded "
"string version of the same certificate."
msgstr "DERエンコードされたバイト列として与えられた証明書から、 PEMエンコードされたバージョンの同じ証明書を返します。"

#: ../../library/ssl.rst:455
msgid ""
"Given a certificate as an ASCII PEM string, returns a DER-encoded sequence "
"of bytes for that same certificate."
msgstr "PEM 形式のASCII文字列として与えられた証明書から、同じ証明書をDERエンコードしたバイト列を返します。"

#: ../../library/ssl.rst:460
msgid ""
"Returns a named tuple with paths to OpenSSL's default cafile and capath. The"
" paths are the same as used by :meth:`SSLContext.set_default_verify_paths`. "
"The return value is a :term:`named tuple` ``DefaultVerifyPaths``:"
msgstr "OpenSSL デフォルトの cafile, capath を指すパスを名前付きタプルで返します。パスは :meth:`SSLContext.set_default_verify_paths` で使われるものと同じです。戻り値は :term:`named tuple` ``DefaultVerifyPaths`` です:"

#: ../../library/ssl.rst:465
msgid ""
":attr:`cafile` - resolved path to cafile or ``None`` if the file doesn't "
"exist,"
msgstr ":attr:`cafile` - cafile の解決済みパス、またはファイルが存在しない場合は ``None``"

#: ../../library/ssl.rst:466
msgid ""
":attr:`capath` - resolved path to capath or ``None`` if the directory "
"doesn't exist,"
msgstr ":attr:`capath` - capath の解決済みパス、またはディレクトリが存在しない場合は ``None``"

#: ../../library/ssl.rst:467
msgid ""
":attr:`openssl_cafile_env` - OpenSSL's environment key that points to a "
"cafile,"
msgstr ":attr:`openssl_cafile_env` - cafile を指す OpenSSL の環境変数"

#: ../../library/ssl.rst:468
msgid ":attr:`openssl_cafile` - hard coded path to a cafile,"
msgstr ":attr:`openssl_cafile` - OpenSSL にハードコードされた cafile のパス"

#: ../../library/ssl.rst:469
msgid ""
":attr:`openssl_capath_env` - OpenSSL's environment key that points to a "
"capath,"
msgstr ":attr:`openssl_capath_env` - capath を指す OpenSSL の環境変数"

#: ../../library/ssl.rst:470
msgid ":attr:`openssl_capath` - hard coded path to a capath directory"
msgstr ":attr:`openssl_capath` - OpenSSL にハードコードされた capath のパス"

#: ../../library/ssl.rst:472
msgid ""
"Availability: LibreSSL ignores the environment vars "
":attr:`openssl_cafile_env` and :attr:`openssl_capath_env`"
msgstr "利用出来る環境: LibreSSL では環境変数 :attr:`openssl_cafile_env` と :attr:`openssl_capath_env` が無視されます"

#: ../../library/ssl.rst:479
msgid ""
"Retrieve certificates from Windows' system cert store. *store_name* may be "
"one of ``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert "
"stores, too."
msgstr "Windows のシステム証明書ストアより証明書を抽出します。 *store_name* は ``CA``, ``ROOT``, ``MY`` のうちどれか一つでしょう。Windows は追加の証明書ストアを提供しているかもしれません。"

#: ../../library/ssl.rst:483
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either "
":const:`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 "
"ASN.1 data. Trust specifies the purpose of the certificate as a set of OIDS "
"or exactly ``True`` if the certificate is trustworthy for all purposes."
msgstr "この関数はタプル (cert_bytes, encoding_type, trust) のリストで返します。encoding_type は cert_bytes のエンコーディングを表します。X.509 ASN.1 に対する :const:`x509_asn` か PKCS#7 ASN.1 データに対する :const:`pkcs_7_asn` のいずれかです。trust は、証明書の目的を、OIDS を内容に持つ set として表すか、または証明書が全ての目的で信頼出来るならば ``True`` です。"

#: ../../library/ssl.rst:490 ../../library/ssl.rst:1332
msgid "Example::"
msgstr "例::"

#: ../../library/ssl.rst:496 ../../library/ssl.rst:511
msgid "Availability: Windows."
msgstr "利用出来る環境: Windows."

#: ../../library/ssl.rst:502
msgid ""
"Retrieve CRLs from Windows' system cert store. *store_name* may be one of "
"``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert stores, too."
msgstr "Windows のシステム証明書ストアより CRLs を抽出します。 *store_name* は ``CA``, ``ROOT``, ``MY`` のうちどれか一つでしょう。Windows は追加の証明書ストアを提供しているかもしれません。"

#: ../../library/ssl.rst:506
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either "
":const:`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 "
"ASN.1 data."
msgstr "この関数はタプル (cert_bytes, encoding_type, trust) のリストで返します。encoding_type は cert_bytes のエンコーディングを表します。X.509 ASN.1 に対する :const:`x509_asn` か PKCS#7 ASN.1 データに対する :const:`pkcs_7_asn` のいずれかです。"

#: ../../library/ssl.rst:517
msgid "Constants"
msgstr "定数"

#: ../../library/ssl.rst:521
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In this mode (the default), no "
"certificates will be required from the other side of the socket connection. "
"If a certificate is received from the other end, no attempt to validate it "
"is made."
msgstr ":attr:`SSLContext.verify_mode` または :func:`wrap_socket` の ``cert_reqs`` パラメータに使用する値です。このモード(これがデフォルトです)では、ソケット接続先からの証明書やその認証を必要としません。接続先から証明書を受け取っても検証は試みられません。"

#: ../../library/ssl.rst:527 ../../library/ssl.rst:1630
msgid "See the discussion of :ref:`ssl-security` below."
msgstr "このドキュメントの下の方の、 :ref:`ssl-security` に関する議論を参照してください。"

#: ../../library/ssl.rst:531
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In this mode no certificates will be "
"required from the other side of the socket connection; but if they are "
"provided, validation will be attempted and an :class:`SSLError` will be "
"raised on failure."
msgstr ":attr:`SSLContext.verify_mode` または :func:`wrap_socket` の ``cert_reqs`` パラメータに使用する値です。このモードでは、ソケット接続先からの証明書やその認証を必要としませんが、証明書が提供されれば検証が試みられ、検証失敗時には :class:`SSLError` が送出されます。"

#: ../../library/ssl.rst:537 ../../library/ssl.rst:548
msgid ""
"Use of this setting requires a valid set of CA certificates to be passed, "
"either to :meth:`SSLContext.load_verify_locations` or as a value of the "
"``ca_certs`` parameter to :func:`wrap_socket`."
msgstr "この設定では、正当なCA証明書のセットを :meth:`SSLContext.load_verify_locations` または :func:`wrap_socket` の ``ca_certs`` パラメータのどちらかに渡す必要があります。"

#: ../../library/ssl.rst:543
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In this mode, certificates are required "
"from the other side of the socket connection; an :class:`SSLError` will be "
"raised if no certificate is provided, or if its validation fails."
msgstr ":attr:`SSLContext.verify_mode` または :func:`wrap_socket` の ``cert_reqs`` パラメータに使用する値です。このモードでは、ソケット接続先からの証明書やその認証を必要とされ、証明書が提供されないかその検証失敗時には :class:`SSLError` が送出されます。"

#: ../../library/ssl.rst:554
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, "
"certificate revocation lists (CRLs) are not checked. By default OpenSSL does"
" neither require nor verify CRLs."
msgstr ":attr:`SSLContext.verify_flags` に渡せる値です。このモードでは、証明書失効リスト(CRLs)はチェックされません。デフォルトでは OpenSSL は CRLs を必要ともしませんし検証にも使いません。"

#: ../../library/ssl.rst:562
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, only the "
"peer cert is check but non of the intermediate CA certificates. The mode "
"requires a valid CRL that is signed by the peer cert's issuer (its direct "
"ancestor CA). If no proper has been loaded "
":attr:`SSLContext.load_verify_locations`, validation will fail."
msgstr ":attr:`SSLContext.verify_flags` に渡せる値です。このモードでは、接続先の証明書のチェックのみで仲介の CA 証明書はチェックしません。接続先証明書の発行者(その CA の直接の祖先)によって署名された妥当な CRL が必要です。 :attr:`SSLContext.load_verify_locations` が相応しいものをロードしていなければ、検証は失敗するでしょう。"

#: ../../library/ssl.rst:572
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, CRLs of "
"all certificates in the peer cert chain are checked."
msgstr ":attr:`SSLContext.verify_flags` に渡せる値です。このモードでは、接続先の証明書チェイン内の全ての証明書についての CRLs がチェックされます。"

#: ../../library/ssl.rst:579
msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to disable workarounds "
"for broken X.509 certificates."
msgstr ":attr:`SSLContext.verify_flags` に渡せる値で、壊れた X.509 証明書に対するワークアラウンドを無効にします。"

#: ../../library/ssl.rst:586
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL to "
"prefer trusted certificates when building the trust chain to validate a "
"certificate. This flag is enabled by default."
msgstr ":attr:`SSLContext.verify_flags` に渡せる値です。OpenSSL に対し、証明書検証のために信頼チェインを構築する際、信頼出来る証明書を選ぶように指示します。これはデフォルトで有効にされています。"

#: ../../library/ssl.rst:594
msgid ""
"Selects the highest protocol version that both the client and server "
"support. Despite the name, this option can select \"TLS\" protocols as well "
"as \"SSL\"."
msgstr "チャンネル暗号化プロトコルとして、クライアントとサーバの両方がサポートする中の、プロトコルバージョンが最も大きなものを選択します。その名前にも関わらず、このオプションは \"SSL\" とともに \"TLS\" プロトコルも選択できます。"

#: ../../library/ssl.rst:601
msgid "Alias for ``PROTOCOL_TLS``."
msgstr ""

#: ../../library/ssl.rst:603
msgid "Use ``PROTOCOL_TLS`` instead."
msgstr ""

#: ../../library/ssl.rst:607
msgid "Selects SSL version 2 as the channel encryption protocol."
msgstr "チャンネル暗号化プロトコルとして SSL バージョン2を選択します。"

#: ../../library/ssl.rst:609
msgid ""
"This protocol is not available if OpenSSL is compiled with the "
"``OPENSSL_NO_SSL2`` flag."
msgstr "このプロトコルは、 OpenSSL が ``OPENSSL_NO_SSL2`` フラグが有効な状態でコンパイルされている場合には利用できません。"

#: ../../library/ssl.rst:614
msgid "SSL version 2 is insecure.  Its use is highly discouraged."
msgstr "SSL version 2 は非セキュアです。このプロトコルは強く非推奨です。"

#: ../../library/ssl.rst:616
msgid "OpenSSL has removed support for SSLv2."
msgstr "OpenSSL は SSLv2 へのサポートを打切りました。"

#: ../../library/ssl.rst:620
msgid "Selects SSL version 3 as the channel encryption protocol."
msgstr "チャンネル暗号化プロトコルとしてSSLバージョン3を選択します。"

#: ../../library/ssl.rst:622
msgid ""
"This protocol is not be available if OpenSSL is compiled with the "
"``OPENSSL_NO_SSLv3`` flag."
msgstr "このプロトコルは、 OpenSSL が ``OPENSSL_NO_SSLv3`` フラグが有効な状態でコンパイルされている場合には利用できません。"

#: ../../library/ssl.rst:627
msgid "SSL version 3 is insecure.  Its use is highly discouraged."
msgstr "SSL version 3 は非セキュアです。このプロトコルは強く非推奨です。"

#: ../../library/ssl.rst:631 ../../library/ssl.rst:640
#: ../../library/ssl.rst:652 ../../library/ssl.rst:665
msgid ""
"OpenSSL has deprecated all version specific protocols. Use the default "
"protocol with flags like ``OP_NO_SSLv3`` instead."
msgstr ""

#: ../../library/ssl.rst:636
msgid "Selects TLS version 1.0 as the channel encryption protocol."
msgstr "チャンネル暗号化プロトコルとしてTLSバージョン1.0を選択します。"

#: ../../library/ssl.rst:645
msgid ""
"Selects TLS version 1.1 as the channel encryption protocol. Available only "
"with openssl version 1.0.1+."
msgstr "チャンネル暗号化プロトコルとしてTLSバージョン1.1を選択します。 openssl version 1.0.1+ のみで利用可能です。"

#: ../../library/ssl.rst:657
msgid ""
"Selects TLS version 1.2 as the channel encryption protocol. This is the most"
" modern version, and probably the best choice for maximum protection, if "
"both sides can speak it.  Available only with openssl version 1.0.1+."
msgstr "チャンネル暗号化プロトコルとしてTLSバージョン1.2を選択します。これは最も現代的で、接続の両サイドが利用できる場合は、たぶん最も安全な選択肢です。 openssl version 1.0.1+ のみで利用可能です。"

#: ../../library/ssl.rst:671
msgid ""
"Enables workarounds for various bugs present in other SSL implementations. "
"This option is set by default.  It does not necessarily set the same flags "
"as OpenSSL's ``SSL_OP_ALL`` constant."
msgstr "相手にする SSL 実装のさまざまなバグを回避するためのワークアラウンドを有効にします。このオプションはデフォルトで有効です。これを有効にする場合 OpenSSL 用の同じ意味のフラグ ``SSL_OP_ALL`` をセットする必要はありません。"

#: ../../library/ssl.rst:679
msgid ""
"Prevents an SSLv2 connection.  This option is only applicable in conjunction"
" with :const:`PROTOCOL_SSLv23`.  It prevents the peers from choosing SSLv2 "
"as the protocol version."
msgstr "SSLv2 接続が行われないようにします。このオプションは :const:`PROTOCOL_SSLv23` と組み合わせでのみ意味を持ちます。ピア間で SSLv2 がプロトコルバージョンとして選択されることを防ぎます。"

#: ../../library/ssl.rst:687
msgid ""
"Prevents an SSLv3 connection.  This option is only applicable in conjunction"
" with :const:`PROTOCOL_SSLv23`.  It prevents the peers from choosing SSLv3 "
"as the protocol version."
msgstr "SSLv3 接続が行われないようにします。このオプションは :const:`PROTOCOL_SSLv23` と組み合わせでのみ意味を持ちます。ピア間で SSLv3 がプロトコルバージョンとして選択されることを防ぎます。"

#: ../../library/ssl.rst:695
msgid ""
"Prevents a TLSv1 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_SSLv23`.  It prevents the peers from choosing TLSv1 as"
" the protocol version."
msgstr "TLSv1 接続が行われないようにします。このオプションは :const:`PROTOCOL_SSLv23` と組み合わせでのみ意味を持ちます。ピア間で TLSv1 がプロトコルバージョンとして選択されることを防ぎます。"

#: ../../library/ssl.rst:703
msgid ""
"Prevents a TLSv1.1 connection. This option is only applicable in conjunction"
" with :const:`PROTOCOL_SSLv23`. It prevents the peers from choosing TLSv1.1 "
"as the protocol version. Available only with openssl version 1.0.1+."
msgstr "TLSv1.1 接続が行われないようにします。このオプションは :const:`PROTOCOL_SSLv23` と組み合わせでのみ意味を持ちます。ピア間で TLSv1.1 がプロトコルバージョンとして選択されることを防ぎます。openssl version 1.0.1+ でのみ利用できます。"

#: ../../library/ssl.rst:711
msgid ""
"Prevents a TLSv1.2 connection. This option is only applicable in conjunction"
" with :const:`PROTOCOL_SSLv23`. It prevents the peers from choosing TLSv1.2 "
"as the protocol version. Available only with openssl version 1.0.1+."
msgstr "TLSv1.2 接続が行われないようにします。このオプションは :const:`PROTOCOL_SSLv23` と組み合わせでのみ意味を持ちます。ピア間で TLSv1.2 がプロトコルバージョンとして選択されることを防ぎます。openssl version 1.0.1+ でのみ利用できます。"

#: ../../library/ssl.rst:719
msgid ""
"Prevents a TLSv1.3 connection. This option is only applicable in conjunction"
" with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.3 as "
"the protocol version. TLS 1.3 is available with OpenSSL 1.1.1 or later. When"
" Python has been compiled against an older version of OpenSSL, the flag "
"defaults to *0*."
msgstr ""

#: ../../library/ssl.rst:729
msgid ""
"Use the server's cipher ordering preference, rather than the client's. This "
"option has no effect on client sockets and SSLv2 server sockets."
msgstr "暗号の優先順位として、クライアントのものではなくサーバのものを使います。このオプションはクライアントソケットと SSLv2 のサーバソケットでは効果はありません。"

#: ../../library/ssl.rst:736
msgid ""
"Prevents re-use of the same DH key for distinct SSL sessions.  This improves"
" forward secrecy but requires more computational resources. This option only"
" applies to server sockets."
msgstr "SSL セッションを区別するのに同じ DH 鍵を再利用しないようにします。これはセキュリティを向上させますが、より多くの計算機リソースを必要とします。このオプションはサーバソケットに適用されます。"

#: ../../library/ssl.rst:744
msgid ""
"Prevents re-use of the same ECDH key for distinct SSL sessions.  This "
"improves forward secrecy but requires more computational resources. This "
"option only applies to server sockets."
msgstr "SSL セッションを区別するのに同じ ECDH 鍵を再利用しないようにします。これはセキュリティを向上させますが、より多くの計算機リソースを必要とします。このオプションはサーバソケットに適用されます。"

#: ../../library/ssl.rst:752
msgid ""
"Disable compression on the SSL channel.  This is useful if the application "
"protocol supports its own compression scheme."
msgstr "SSL チャネルでの圧縮を無効にします。これはアプリケーションのプロトコルが自身の圧縮方法をサポートする場合に有用です。"

#: ../../library/ssl.rst:755
msgid "This option is only available with OpenSSL 1.0.0 and later."
msgstr "このオプションは OpenSSL 1.0.0以降のみで使用できます。"

#: ../../library/ssl.rst:761
msgid ""
"Whether the OpenSSL library has built-in support for the *Application-Layer "
"Protocol Negotiation* TLS extension as described in :rfc:`7301`."
msgstr "OpenSSL ライブラリが、組み込みで :rfc:`7301` で記述されている *Application-Layer Protocol Negotiation* TLS 拡張をサポートしているかどうか。"

#: ../../library/ssl.rst:768
msgid ""
"Whether the OpenSSL library has built-in support for Elliptic Curve-based "
"Diffie-Hellman key exchange.  This should be true unless the feature was "
"explicitly disabled by the distributor."
msgstr "OpenSSL ライブラリが、組み込みの楕円曲線ディフィー・ヘルマン鍵共有をサポートしているかどうか。これは、ディストリビュータが明示的に無効にしていない限りは、真であるはずです。"

#: ../../library/ssl.rst:776
msgid ""
"Whether the OpenSSL library has built-in support for the *Server Name "
"Indication* extension (as defined in :rfc:`4366`)."
msgstr "OpenSSL ライブラリが、組み込みで (:rfc:`4366` で記述されている) *Server Name Indication* 拡張をサポートしているかどうか。"

#: ../../library/ssl.rst:783
msgid ""
"Whether the OpenSSL library has built-in support for *Next Protocol "
"Negotiation* as described in the `NPN draft specification "
"<https://tools.ietf.org/html/draft-agl-tls-nextprotoneg>`_. When true, you "
"can use the :meth:`SSLContext.set_npn_protocols` method to advertise which "
"protocols you want to support."
msgstr "OpenSSL ライブラリが、組み込みで、`NPN draft specification <https://tools.ietf.org/html/draft-agl-tls-nextprotoneg>`_ で記述されている *Next Protocol Negotiation* をサポートしているかどうか。 true であれば、サポートしたいプロトコルを :meth:`SSLContext.set_npn_protocols` メソッドで提示することができます。"

#: ../../library/ssl.rst:793
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.3 protocol."
msgstr ""

#: ../../library/ssl.rst:799
msgid ""
"List of supported TLS channel binding types.  Strings in this list can be "
"used as arguments to :meth:`SSLSocket.get_channel_binding`."
msgstr "サポートされている TLS のチャネルバインディングのタイプのリスト。リスト内の文字列は :meth:`SSLSocket.get_channel_binding` の引数に渡せます。"

#: ../../library/ssl.rst:806
msgid "The version string of the OpenSSL library loaded by the interpreter::"
msgstr "インタプリタによってロードされた OpenSSL ライブラリのバージョン文字列::"

#: ../../library/ssl.rst:815
msgid ""
"A tuple of five integers representing version information about the OpenSSL "
"library::"
msgstr "OpenSSL ライブラリのバージョン情報を表す5つの整数のタプル::"

#: ../../library/ssl.rst:825
msgid "The raw version number of the OpenSSL library, as a single integer::"
msgstr "1つの整数の形式の、 OpenSSL ライブラリの生のバージョン番号::"

#: ../../library/ssl.rst:838
msgid ""
"Alert Descriptions from :rfc:`5246` and others. The `IANA TLS Alert Registry"
" <https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_ contains this list and references to the RFCs where their "
"meaning is defined."
msgstr ":rfc:`5246` その他からのアラートの種類です。 `IANA TLS Alert Registry <https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-6>`_ にはこのリストとその意味が定義された RFC へのリファレンスが含まれています。"

#: ../../library/ssl.rst:842
msgid ""
"Used as the return value of the callback function in "
":meth:`SSLContext.set_servername_callback`."
msgstr ":meth:`SSLContext.set_servername_callback` でのコールバック関数の戻り値として使われます。"

#: ../../library/ssl.rst:849
msgid ""
"Option for :func:`create_default_context` and "
":meth:`SSLContext.load_default_certs`.  This value indicates that the "
"context may be used to authenticate Web servers (therefore, it will be used "
"to create client-side sockets)."
msgstr ":func:`create_default_context` と :meth:`SSLContext.load_default_certs` に渡すオプションです。この値はコンテキストが Web サーバの認証に使われることを示します (ですので、クライアントサイドのソケットを作るのに使うことになるでしょう)。"

#: ../../library/ssl.rst:858
msgid ""
"Option for :func:`create_default_context` and "
":meth:`SSLContext.load_default_certs`.  This value indicates that the "
"context may be used to authenticate Web clients (therefore, it will be used "
"to create server-side sockets)."
msgstr ":func:`create_default_context` と :meth:`SSLContext.load_default_certs` に渡すオプションです。この値はコンテキストが Web クライアントの認証に使われることを示します (ですので、サーバサイドのソケットを作るのに使うことになるでしょう)。"

#: ../../library/ssl.rst:867
msgid "SSL Sockets"
msgstr "SSL ソケット"

#: ../../library/ssl.rst:869
msgid "SSL sockets provide the following methods of :ref:`socket-objects`:"
msgstr "SSL ソケットは :ref:`socket-objects` の以下のメソッドを提供します:"

#: ../../library/ssl.rst:871
msgid ":meth:`~socket.socket.accept()`"
msgstr ":meth:`~socket.socket.accept()`"

#: ../../library/ssl.rst:872
msgid ":meth:`~socket.socket.bind()`"
msgstr ":meth:`~socket.socket.bind()`"

#: ../../library/ssl.rst:873
msgid ":meth:`~socket.socket.close()`"
msgstr ":meth:`~socket.socket.close()`"

#: ../../library/ssl.rst:874
msgid ":meth:`~socket.socket.connect()`"
msgstr ":meth:`~socket.socket.connect()`"

#: ../../library/ssl.rst:875
msgid ":meth:`~socket.socket.fileno()`"
msgstr ":meth:`~socket.socket.fileno()`"

#: ../../library/ssl.rst:876
msgid ""
":meth:`~socket.socket.getpeername()`, :meth:`~socket.socket.getsockname()`"
msgstr ":meth:`~socket.socket.getpeername()`, :meth:`~socket.socket.getsockname()`"

#: ../../library/ssl.rst:877
msgid ""
":meth:`~socket.socket.getsockopt()`, :meth:`~socket.socket.setsockopt()`"
msgstr ":meth:`~socket.socket.getsockopt()`, :meth:`~socket.socket.setsockopt()`"

#: ../../library/ssl.rst:878
msgid ""
":meth:`~socket.socket.gettimeout()`, :meth:`~socket.socket.settimeout()`, "
":meth:`~socket.socket.setblocking()`"
msgstr ":meth:`~socket.socket.gettimeout()`, :meth:`~socket.socket.settimeout()`, :meth:`~socket.socket.setblocking()`"

#: ../../library/ssl.rst:880
msgid ":meth:`~socket.socket.listen()`"
msgstr ":meth:`~socket.socket.listen()`"

#: ../../library/ssl.rst:881
msgid ":meth:`~socket.socket.makefile()`"
msgstr ":meth:`~socket.socket.makefile()`"

#: ../../library/ssl.rst:882
msgid ""
":meth:`~socket.socket.recv()`, :meth:`~socket.socket.recv_into()` (but "
"passing a non-zero ``flags`` argument is not allowed)"
msgstr ":meth:`~socket.socket.recv()`, :meth:`~socket.socket.recv_into()` (非ゼロの ``flags`` は渡せません)"

#: ../../library/ssl.rst:884
msgid ""
":meth:`~socket.socket.send()`, :meth:`~socket.socket.sendall()` (with the "
"same limitation)"
msgstr ":meth:`~socket.socket.send()`, :meth:`~socket.socket.sendall()` (非ゼロの ``flags`` は渡せません)"

#: ../../library/ssl.rst:886
msgid ":meth:`~socket.socket.shutdown()`"
msgstr ":meth:`~socket.socket.shutdown()`"

#: ../../library/ssl.rst:888
msgid ""
"However, since the SSL (and TLS) protocol has its own framing atop of TCP, "
"the SSL sockets abstraction can, in certain respects, diverge from the "
"specification of normal, OS-level sockets.  See especially the :ref:`notes "
"on non-blocking sockets <ssl-nonblocking>`."
msgstr "SSL(およびTLS)プロトコルは TCP の上に独自の枠組みを持っているので、SSLソケットの抽象化は、いくつかの点で通常の OSレベルのソケットの仕様から逸脱することがあります。特に :ref:`ノンブロッキングソケットについての注釈 <ssl-nonblocking>` を参照してください。"

#: ../../library/ssl.rst:893
msgid "SSL sockets also have the following additional methods and attributes:"
msgstr "SSL ソケットには、以下に示す追加のメソッドと属性もあります:"

#: ../../library/ssl.rst:897
msgid "Perform the SSL setup handshake."
msgstr "SSL セットアップのハンドシェイクを実行します。"

#: ../../library/ssl.rst:901
msgid ""
"The handshake method also performs :func:`match_hostname` when the "
":attr:`~SSLContext.check_hostname` attribute of the socket's "
":attr:`~SSLSocket.context` is true."
msgstr "ソケットの :attr:`~SSLSocket.context` の属性 :attr:`~SSLContext.check_hostname` が真の場合に、ハンドシェイクメソッドが :func:`match_hostname` を実行するようになりました。"

#: ../../library/ssl.rst:907
msgid ""
"If there is no certificate for the peer on the other end of the connection, "
"return ``None``.  If the SSL handshake hasn't been done yet, raise "
":exc:`ValueError`."
msgstr "接続先に証明書が無い場合、 ``None`` を返します。SSL ハンドシェイクがまだ行われていない場合は、 :exc:`ValueError` が送出されます。"

#: ../../library/ssl.rst:911
msgid ""
"If the ``binary_form`` parameter is :const:`False`, and a certificate was "
"received from the peer, this method returns a :class:`dict` instance.  If "
"the certificate was not validated, the dict is empty.  If the certificate "
"was validated, it returns a dict with several keys, amongst them ``subject``"
" (the principal for which the certificate was issued) and ``issuer`` (the "
"principal issuing the certificate).  If a certificate contains an instance "
"of the *Subject Alternative Name* extension (see :rfc:`3280`), there will "
"also be a ``subjectAltName`` key in the dictionary."
msgstr "``binary_form`` が :const:`False` で接続先から証明書を取得した場合、このメソッドは :class:`dict` のインスタンスを返します。証明書が認証されていない場合、辞書は空です。証明書が認証されていた場合いくつかのキーを持った辞書を返し、 ``subject`` (証明書が発行された principal), ``issuer`` (証明書を発行した principal) を含みます。証明書が *Subject Alternative Name* 拡張(:rfc:`3280` を参照)のインスタンスを格納していた場合、 ``subjectAltName`` キーも辞書に含まれます。"

#: ../../library/ssl.rst:920
msgid ""
"The ``subject`` and ``issuer`` fields are tuples containing the sequence of "
"relative distinguished names (RDNs) given in the certificate's data "
"structure for the respective fields, and each RDN is a sequence of name-"
"value pairs.  Here is a real-world example::"
msgstr "``subject``, ``issuer`` フィールドは、証明書のそれぞれのフィールドについてのデータ構造で与えられる RDN (relative distinguishued name) のシーケンスを格納したタプルで、各 RDN は name-value ペアのシーケンスです。現実世界での例をお見せします::"

#: ../../library/ssl.rst:946
msgid ""
"To validate a certificate for a particular service, you can use the "
":func:`match_hostname` function."
msgstr "特定のサービスのために証明書の検証がしたければ、 :func:`match_hostname` 関数を使うことが出来ます。"

#: ../../library/ssl.rst:949
msgid ""
"If the ``binary_form`` parameter is :const:`True`, and a certificate was "
"provided, this method returns the DER-encoded form of the entire certificate"
" as a sequence of bytes, or :const:`None` if the peer did not provide a "
"certificate.  Whether the peer provides a certificate depends on the SSL "
"socket's role:"
msgstr "``binary_form`` 引数が :const:`True` だった場合、証明書が渡されていればこのメソッドはDERエンコードされた証明書全体をバイト列として返し、接続先が証明書を提示しなかった場合は :const:`None` を返します。接続先が証明書を提供するかどうかは SSL ソケットの役割に依存します:"

#: ../../library/ssl.rst:955
msgid ""
"for a client SSL socket, the server will always provide a certificate, "
"regardless of whether validation was required;"
msgstr "クライアント側ソケットでは、認証が要求されているかどうかに関わらず、サーバは常に証明書を提供します;"

#: ../../library/ssl.rst:958
msgid ""
"for a server SSL socket, the client will only provide a certificate when "
"requested by the server; therefore :meth:`getpeercert` will return "
":const:`None` if you used :const:`CERT_NONE` (rather than "
":const:`CERT_OPTIONAL` or :const:`CERT_REQUIRED`)."
msgstr "サーバ側ソケットでは、クライアントはサーバによって認証が要求されている場合にのみ証明書を提供します; ですので、 (:const:`CERT_OPTIONAL` や :const:`CERT_REQUIRED` ではなく) :const:`CERT_NONE` を使うと :meth:`getpeercert` は :const:`None` を返します。"

#: ../../library/ssl.rst:963
msgid ""
"The returned dictionary includes additional items such as ``issuer`` and "
"``notBefore``. Additionall :exc:`ValueError` is raised when the handshake "
"isn't done. The returned dictionary includes additional X509v3 extension "
"items such as ``crlDistributionPoints``, ``caIssuers`` and ``OCSP`` URIs."
msgstr "返される辞書に ``issuer``, ``notBefore`` のような追加アイテムを含むようになりました。加えて、ハンドシェイクが済んでいなければ :exc:`ValueError` を投げるようになりました。返される辞書に ``crlDistributionPoints``, ``caIssuers``, ``OCSP`` URI のような X509v3 拡張アイテムを含むようになりました。"

#: ../../library/ssl.rst:971
msgid ""
"Returns a three-value tuple containing the name of the cipher being used, "
"the version of the SSL protocol that defines its use, and the number of "
"secret bits being used.  If no connection has been established, returns "
"``None``."
msgstr "利用されている暗号の名前、その暗号の利用を定義しているSSLプロトコルのバージョン、利用されている鍵のbit長の3つの値を含むタプルを返します。もし接続が確立されていない場合、 ``None`` を返します。"

#: ../../library/ssl.rst:977
msgid ""
"Return the compression algorithm being used as a string, or ``None`` if the "
"connection isn't compressed."
msgstr "使われている圧縮アルゴリズムを文字列で返します。接続が圧縮されていなければ ``None`` を返します。"

#: ../../library/ssl.rst:980
msgid ""
"If the higher-level protocol supports its own compression mechanism, you can"
" use :data:`OP_NO_COMPRESSION` to disable SSL-level compression."
msgstr "上位レベルのプロトコルが自身で圧縮メカニズムをサポートする場合、SSL レベルでの圧縮を :data:`OP_NO_COMPRESSION` を使って無効に出来ます。"

#: ../../library/ssl.rst:987
msgid ""
"Get channel binding data for current connection, as a bytes object.  Returns"
" ``None`` if not connected or the handshake has not been completed."
msgstr "現在の接続におけるチャネルバインディングのデータを取得します。未接続あるいはハンドシェイクが完了していなければ ``None`` を返します。"

#: ../../library/ssl.rst:990
msgid ""
"The *cb_type* parameter allow selection of the desired channel binding type."
" Valid channel binding types are listed in the :data:`CHANNEL_BINDING_TYPES`"
" list.  Currently only the 'tls-unique' channel binding, defined by "
":rfc:`5929`, is supported.  :exc:`ValueError` will be raised if an "
"unsupported channel binding type is requested."
msgstr "*cb_type* パラメータにより、望みのチャネルバインディングのタイプを選択出来ます。チャネルバインディングのタイプの妥当なものは :data:`CHANNEL_BINDING_TYPES` でリストされています。現在のところは :rfc:`5929` で定義されている 'tls-unique' のみがサポートされています。未サポートのチャネルバインディングのタイプが要求された場合、 :exc:`ValueError` を送出します。"

#: ../../library/ssl.rst:1000
msgid ""
"Return the protocol that was selected during the TLS handshake.  If "
":meth:`SSLContext.set_alpn_protocols` was not called, if the other party "
"does not support ALPN, if this socket does not support any of the client's "
"proposed protocols, or if the handshake has not happened yet, ``None`` is "
"returned."
msgstr "TLS ハンドシェイクで選択されたプロトコルを返します。 :meth:`SSLContext.set_alpn_protocols` が呼ばれていない場合、相手側が ALPN をサポートしていない場合、クライアントが提案したプロトコルのどれもソケットがサポートしない場合、あるいはハンドシェイクがまだ行われていない場合には、 ``None`` が返されます。"

#: ../../library/ssl.rst:1010
msgid ""
"Return the higher-level protocol that was selected during the TLS/SSL "
"handshake. If :meth:`SSLContext.set_npn_protocols` was not called, or if the"
" other party does not support NPN, or if the handshake has not yet happened,"
" this will return ``None``."
msgstr "TLS/SSL ハンドシェイクで選択された上位レベルのプロトコルを返します。 :meth:`SSLContext.set_npn_protocols` が呼ばれていない場合、相手側が NPN をサポートしていない場合、あるいはハンドシェイクがまだ行われていない場合には、 ``None`` が返されます。"

#: ../../library/ssl.rst:1019
msgid ""
"Performs the SSL shutdown handshake, which removes the TLS layer from the "
"underlying socket, and returns the underlying socket object.  This can be "
"used to go from encrypted operation over a connection to unencrypted.  The "
"returned socket should always be used for further communication with the "
"other side of the connection, rather than the original socket."
msgstr "SSLシャットダウンハンドシェイクを実行します。これは下位レイヤーのソケットからTLSレイヤーを取り除き、下位レイヤーのソケットオブジェクトを返します。これは暗号化されたオペレーションから暗号化されていない接続に移行するときに利用されます。以降の通信には、オリジナルのソケットではなくこのメソッドが返したソケットのみを利用するべきです。"

#: ../../library/ssl.rst:1027
msgid ""
"Return the actual SSL protocol version negotiated by the connection as a "
"string, or ``None`` is no secure connection is established. As of this "
"writing, possible return values include ``\"SSLv2\"``, ``\"SSLv3\"``, "
"``\"TLSv1\"``, ``\"TLSv1.1\"`` and ``\"TLSv1.2\"``. Recent OpenSSL versions "
"may define more return values."
msgstr "コネクションによって実際にネゴシエイトされた SSL プロトコルバージョンを文字列で、または、セキュアなコネクションが確立していなければ ``None`` を返します。これを書いている時点では、 ``\"SSLv2\"``, ``\"SSLv3\"``, ``\"TLSv1\"``, ``\"TLSv1.1\"``, ``\"TLSv1.2\"`` などが返ります。最新の OpenSSL はもっと色々な値を定義しているかもしれません。"

#: ../../library/ssl.rst:1037
msgid ""
"The :class:`SSLContext` object this SSL socket is tied to.  If the SSL "
"socket was created using the top-level :func:`wrap_socket` function (rather "
"than :meth:`SSLContext.wrap_socket`), this is a custom context object "
"created for this SSL socket."
msgstr "この SSL ソケットに結び付けられた :class:`SSLContext` オブジェクトです。SSL ソケットが (:meth:`SSLContext.wrap_socket` ではなく)トップレベルの :func:`wrap_socket` 関数を使って作られた場合、これはこの SSL ソケットのために作られたカスタムコンテキストオブジェクトです。"

#: ../../library/ssl.rst:1046
msgid "SSL Contexts"
msgstr "SSL コンテキスト"

#: ../../library/ssl.rst:1050
msgid ""
"An SSL context holds various data longer-lived than single SSL connections, "
"such as SSL configuration options, certificate(s) and private key(s). It "
"also manages a cache of SSL sessions for server-side sockets, in order to "
"speed up repeated connections from the same clients."
msgstr "SSL コンテキストは、SSL 構成オプション、証明書(群)や秘密鍵(群)などのような、一回の SSL 接続よりも長生きするさまざまなデータを保持します。これはサーバサイドソケットの SSL セッションのキャッシュも管理し、同じクライアントからの繰り返しの接続時の速度向上に一役買います。"

#: ../../library/ssl.rst:1057
msgid ""
"Create a new SSL context.  You must pass *protocol* which must be one of the"
" ``PROTOCOL_*`` constants defined in this module. :data:`PROTOCOL_SSLv23` is"
" currently recommended for maximum interoperability."
msgstr "新しい SSL コンテキストを作成します。 *protocol* にはこのモジュールで定義されている ``PROTOCOL_*`` 定数のうち一つを指定しなければなりません。最大限の互換性のためには、現時点での推奨は :data:`PROTOCOL_SSLv23` です。"

#: ../../library/ssl.rst:1063
msgid ""
":func:`create_default_context` lets the :mod:`ssl` module choose security "
"settings for a given purpose."
msgstr ":func:`create_default_context` は :mod:`ssl` モジュールに、目的に合ったセキュリティ設定を選ばせます。"

#: ../../library/ssl.rst:1067
msgid ":class:`SSLContext` objects have the following methods and attributes:"
msgstr ":class:`SSLContext` オブジェクトは以下のメソッドと属性を持っています:"

#: ../../library/ssl.rst:1071
msgid ""
"Get statistics about quantities of loaded X.509 certificates, count of X.509"
" certificates flagged as CA certificates and certificate revocation lists as"
" dictionary."
msgstr "ロードされた X.509 証明書の数、CA 証明書で活性の X.509 証明書の数、証明書失効リストの数、についての統計情報を辞書として取得します。"

#: ../../library/ssl.rst:1075
msgid "Example for a context with one CA cert and one other cert::"
msgstr "一つの CA と他の一つの証明書を持ったコンテキストでの例です::"

#: ../../library/ssl.rst:1083
msgid ""
"Load a private key and the corresponding certificate.  The *certfile* string"
" must be the path to a single file in PEM format containing the certificate "
"as well as any number of CA certificates needed to establish the "
"certificate's authenticity.  The *keyfile* string, if present, must point to"
" a file containing the private key in.  Otherwise the private key will be "
"taken from *certfile* as well.  See the discussion of :ref:`ssl-"
"certificates` for more information on how the certificate is stored in the "
"*certfile*."
msgstr "秘密鍵と対応する証明書をロードします。 *certfile* は、証明書と、証明書認証で必要とされる任意の数の CA 証明書を含む、PEM フォーマットの単一ファイルへのパスでなければなりません。 *keyfile* を指定する場合は、秘密鍵が含まれるファイルを指さなければなりません。そうでなければ秘密鍵も *certfile* から取られます。 *certfile* に証明書をどのように格納すれば良いかについての詳しい情報は、 :ref:`ssl-certificates` の議論を参照してください。"

#: ../../library/ssl.rst:1092
msgid ""
"The *password* argument may be a function to call to get the password for "
"decrypting the private key.  It will only be called if the private key is "
"encrypted and a password is necessary.  It will be called with no arguments,"
" and it should return a string, bytes, or bytearray.  If the return value is"
" a string it will be encoded as UTF-8 before using it to decrypt the key. "
"Alternatively a string, bytes, or bytearray value may be supplied directly "
"as the *password* argument.  It will be ignored if the private key is not "
"encrypted and no password is needed."
msgstr "*password* 引数に、秘密鍵を復号するためのパスワードを返す関数を与えることが出来ます。その関数は秘密鍵が暗号化されていて、なおかつパスワードが必要な場合にのみ呼び出されます。その関数は引数なしで呼び出され、string, bytes, または bytearray を返さなければなりません。戻り値が string の場合は鍵を復号化するのに使う前に UTF-8 でエンコードされます。string の代わりに bytes や bytearray を返した場合は *password* 引数に直接供給されます。秘密鍵が暗号化されていなかったりパスワードを必要としない場合は、指定は無視されます。"

#: ../../library/ssl.rst:1101
msgid ""
"If the *password* argument is not specified and a password is required, "
"OpenSSL's built-in password prompting mechanism will be used to "
"interactively prompt the user for a password."
msgstr "*password* が与えられず、そしてパスワードが必要な場合には、OpenSSL 組み込みのパスワード問い合わせメカニズムが、ユーザに対話的にパスワードを問い合わせます。"

#: ../../library/ssl.rst:1105
msgid ""
"An :class:`SSLError` is raised if the private key doesn't match with the "
"certificate."
msgstr "秘密鍵が証明書に合致しなければ、 :class:`SSLError` が送出されます。"

#: ../../library/ssl.rst:1110
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from "
"default locations. On Windows it loads CA certs from the ``CA`` and ``ROOT``"
" system stores. On other systems it calls "
":meth:`SSLContext.set_default_verify_paths`. In the future the method may "
"load CA certificates from other locations, too."
msgstr "デフォルトの場所から \"認証局\" (CA=certification authority) 証明書ファイル一式をロードします。Windows では、CA 証明書はシステム記憶域の ``CA`` と ``ROOT`` からロードします。それ以外のシステムでは、この関数は :meth:`SSLContext.set_default_verify_paths` を呼び出します。将来的にはこのメソッドは、他の場所からも CA 証明書をロードするかもしれません。"

#: ../../library/ssl.rst:1116
msgid ""
"The *purpose* flag specifies what kind of CA certificates are loaded. The "
"default settings :data:`Purpose.SERVER_AUTH` loads certificates, that are "
"flagged and trusted for TLS web server authentication (client side sockets)."
" :data:`Purpose.CLIENT_AUTH` loads CA certificates for client certificate "
"verification on the server side."
msgstr "*purpose* フラグでどの種類の CA 証明書をロードするかを指定します。デフォルトの :data:`Purpose.SERVER_AUTH` は TLS web サーバの認証のために活性かつ信頼された証明書をロードします(クライアントサイドのソケット)。 :data:`Purpose.CLIENT_AUTH` はクライアント証明書の正当性検証をサーバサイドで行うための CA 証明書をロードします。"

#: ../../library/ssl.rst:1124
msgid ""
"Load a set of \"certification authority\" (CA) certificates used to validate"
" other peers' certificates when :data:`verify_mode` is other than "
":data:`CERT_NONE`.  At least one of *cafile* or *capath* must be specified."
msgstr ":data:`verify_mode` が :data:`CERT_NONE` でない場合に接続先の証明書ファイルの正当性検証に使われる \"認証局\" (CA=certification authority) 証明書ファイル一式をロードします。少なくとも *cafile* か *capath* のどちらかは指定しなければなりません。"

#: ../../library/ssl.rst:1128
msgid ""
"This method can also load certification revocation lists (CRLs) in PEM or "
"DER format. In order to make use of CRLs, :attr:`SSLContext.verify_flags` "
"must be configured properly."
msgstr "このメソッドは PEM または DER フォーマットの証明書失効リスト (CRLs=certification revocation lists)もロード出来ます。CRLs のために使うには、 :attr:`SSLContext.verify_flags` を適切に設定しなければなりません。"

#: ../../library/ssl.rst:1132
msgid ""
"The *cafile* string, if present, is the path to a file of concatenated CA "
"certificates in PEM format. See the discussion of :ref:`ssl-certificates` "
"for more information about how to arrange the certificates in this file."
msgstr "*cafile* を指定する場合は、PEM フォーマットで CA 証明書が結合されたファイルへのパスを指定してください。このファイル内で証明書をどのように編成すれば良いのかについての詳しい情報については、 :ref:`ssl-certificates` の議論を参照してください。"

#: ../../library/ssl.rst:1137
msgid ""
"The *capath* string, if present, is the path to a directory containing "
"several CA certificates in PEM format, following an `OpenSSL specific layout"
" "
"<https://www.openssl.org/docs/man1.1.0/ssl/SSL_CTX_load_verify_locations.html>`_."
msgstr ""

#: ../../library/ssl.rst:1142
msgid ""
"The *cadata* object, if present, is either an ASCII string of one or more "
"PEM-encoded certificates or a bytes-like object of DER-encoded certificates."
" Like with *capath* extra lines around PEM-encoded certificates are ignored "
"but at least one certificate must be present."
msgstr "*cadata* オブジェクトを指定する場合は、PEM エンコードの証明書一つ以上の ASCII 文字列か、DER エンコードの証明書のバイトライクなオブジェクトのどちらかを指定してください。PEM エンコードの証明書の周囲の余分な行は無視されますが、少なくとも一つの証明書が含まれている必要があります。"

#: ../../library/ssl.rst:1149
msgid ""
"Get a list of loaded \"certification authority\" (CA) certificates. If the "
"``binary_form`` parameter is :const:`False` each list entry is a dict like "
"the output of :meth:`SSLSocket.getpeercert`. Otherwise the method returns a "
"list of DER-encoded certificates. The returned list does not contain "
"certificates from *capath* unless a certificate was requested and loaded by "
"a SSL connection."
msgstr "ロードされた \"認証局\" (CA=certification authority) 証明書のリストを取得します。 ``binary_form`` パラメータが :const:`False` であれば、リストのそれぞれのエントリは :meth:`SSLSocket.getpeercert` が出力するような辞書になります。そうでない場合このメソッドは、DER エンコード形式の証明書のリストで返します。返却されるリストには、 SSL 接続によって要求されてロードされない限りは *capath* からの証明書は含みません。"

#: ../../library/ssl.rst:1157
msgid ""
"Certificates in a capath directory aren't loaded unless they have been used "
"at least once."
msgstr "capath ディレクトリ内の証明書は一度でも使われない限りはロードされません。"

#: ../../library/ssl.rst:1162
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from a "
"filesystem path defined when building the OpenSSL library.  Unfortunately, "
"there's no easy way to know whether this method succeeds: no error is "
"returned if no certificates are to be found.  When the OpenSSL library is "
"provided as part of the operating system, though, it is likely to be "
"configured properly."
msgstr "デフォルトの \"認証局\" (CA=certification authority) 証明書を、OpenSSL ライブラリがビルドされた際に定義されたファイルシステム上のパスからロードします。残念ながらこのメソッドが成功したかどうかを知るための簡単な方法はありません: 証明書が見つからなくてもエラーは返りません。OpenSSL ライブラリがオペレーティングシステムの一部として提供されている際にはどうやら適切に構成できるようですが。"

#: ../../library/ssl.rst:1171
msgid ""
"Set the available ciphers for sockets created with this context. It should "
"be a string in the `OpenSSL cipher list format "
"<https://www.openssl.org/docs/manmaster/man1/ciphers.html>`_. If no cipher "
"can be selected (because compile-time options or other configuration forbids"
" use of all the specified ciphers), an :class:`SSLError` will be raised."
msgstr ""

#: ../../library/ssl.rst:1179
msgid ""
"when connected, the :meth:`SSLSocket.cipher` method of SSL sockets will give"
" the currently selected cipher."
msgstr "接続時に SSL ソケットの :meth:`SSLSocket.cipher` メソッドが、現在選択されているその暗号を使います。"

#: ../../library/ssl.rst:1184
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of ASCII strings, like ``['http/1.1', "
"'spdy/2']``, ordered by preference. The selection of a protocol will happen "
"during the handshake, and will play out according to :rfc:`7301`. After a "
"successful handshake, the :meth:`SSLSocket.selected_alpn_protocol` method "
"will return the agreed-upon protocol."
msgstr "SSL/TLS ハンドシェイク時にソケットが提示すべきプロトコルを指定します。 ``['http/1.1', 'spdy/2']`` のような推奨順に並べた ASII 文字列のリストでなければなりません。プロトコルの選択は :rfc:`7301` に従いハンドシェイクの中で行われます。ハンドシェイクが正常に終了後、 :meth:`SSLSocket.selected_alpn_protocol` メソッドは合意されたプロトコルを返します。"

#: ../../library/ssl.rst:1191
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_ALPN` is "
"False."
msgstr "このメソッドは :data:`HAS_ALPN` が偽の場合 :exc:`NotImplementedError` を送出します。"

#: ../../library/ssl.rst:1194
msgid ""
"OpenSSL 1.1.0 to 1.1.0e will abort the handshake and raise :exc:`SSLError` "
"when both sides support ALPN but cannot agree on a protocol. 1.1.0f+ behaves"
" like 1.0.2, :meth:`SSLSocket.selected_alpn_protocol` returns None."
msgstr ""

#: ../../library/ssl.rst:1202
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of strings, like ``['http/1.1', 'spdy/2']``, "
"ordered by preference. The selection of a protocol will happen during the "
"handshake, and will play out according to the `NPN draft specification "
"<https://tools.ietf.org/html/draft-agl-tls-nextprotoneg>`_. After a "
"successful handshake, the :meth:`SSLSocket.selected_npn_protocol` method "
"will return the agreed-upon protocol."
msgstr "SSL/TLS ハンドシェイク時にソケットが提示すべきプロトコルを指定します。 ``['http/1.1', 'spdy/2']`` のような推奨順に並べた文字列のリストでなければなりません。プロトコルの選択は `NPN draft specification <https://tools.ietf.org/html/draft-agl-tls-nextprotoneg>`_ に従いハンドシェイクの中で行われます。ハンドシェイクが正常に終了後、 :meth:`SSLSocket.selected_alpn_protocol` メソッドは合意されたプロトコルを返します。"

#: ../../library/ssl.rst:1210
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_NPN` is "
"False."
msgstr "このメソッドは :data:`HAS_NPN` が偽の場合 :exc:`NotImplementedError` を送出します。"

#: ../../library/ssl.rst:1215
msgid ""
"Register a callback function that will be called after the TLS Client Hello "
"handshake message has been received by the SSL/TLS server when the TLS "
"client specifies a server name indication. The server name indication "
"mechanism is specified in :rfc:`6066` section 3 - Server Name Indication."
msgstr "TLS クライアントがサーバ名表示を指定した際の、SSL/TLS サーバによって TLS Client Hello ハンドシェイクメッセージが受け取られたあとで呼び出されるコールバック関数を登録します。サーバ名表示メカニズムは :rfc:`6066` セクション 3 - Server Name Indication で述べられています。"

#: ../../library/ssl.rst:1220
msgid ""
"Only one callback can be set per ``SSLContext``.  If *server_name_callback* "
"is ``None`` then the callback is disabled. Calling this function a "
"subsequent time will disable the previously registered callback."
msgstr "``SSLContext`` ごとに一つだけコールバックをセット出来ます。 *server_name_callback* を ``None`` にすればコールバックは無効になります。この関数を続けて呼ぶと、以前に登録されたコールバックを上書きします。"

#: ../../library/ssl.rst:1224
msgid ""
"The callback function, *server_name_callback*, will be called with three "
"arguments; the first being the :class:`ssl.SSLSocket`, the second is a "
"string that represents the server name that the client is intending to "
"communicate (or :const:`None` if the TLS Client Hello does not contain a "
"server name) and the third argument is the original :class:`SSLContext`. The"
" server name argument is the IDNA decoded server name."
msgstr "コールバック関数 *server_name_callback* は 3 つの引数で呼び出されます; 最初の引数は :class:`ssl.SSLSocket` です。2 つ目の引数は、クライアントが相手をしようと意図しているサーバ名を表す文字列 (または TLS Client Hello がサーバ名を含まない場合は ``None``) です。そして 3 つ目の引数はオリジナルの :class:`SSLContext` です。サーバ名引数は IDNA デコードされたサーバ名です。"

#: ../../library/ssl.rst:1231
msgid ""
"A typical use of this callback is to change the :class:`ssl.SSLSocket`'s "
":attr:`SSLSocket.context` attribute to a new object of type "
":class:`SSLContext` representing a certificate chain that matches the server"
" name."
msgstr "このコールバックの典型的な利用方法は、 :class:`ssl.SSLSocket` の :attr:`SSLSocket.context` 属性を、サーバ名に合致する証明書チェインを持つ新しい :class:`SSLContext` オブジェクトに変更することです。"

#: ../../library/ssl.rst:1236
msgid ""
"Due to the early negotiation phase of the TLS connection, only limited "
"methods and attributes are usable like "
":meth:`SSLSocket.selected_alpn_protocol` and :attr:`SSLSocket.context`. "
":meth:`SSLSocket.getpeercert`, :meth:`SSLSocket.getpeercert`, "
":meth:`SSLSocket.cipher` and :meth:`SSLSocket.compress` methods require that"
" the TLS connection has progressed beyond the TLS Client Hello and therefore"
" will not contain return meaningful values nor can they be called safely."
msgstr "TLS 接続の初期ネゴシエーションのフェーズですから、 :meth:`SSLSocket.selected_alpn_protocol`, :attr:`SSLSocket.context` のような限られたメソッドと属性のみ使えます。 :meth:`SSLSocket.getpeercert`, :meth:`SSLSocket.getpeercert`, :meth:`SSLSocket.cipher`, :meth:`SSLSocket.compress` メソッドは TLS 接続が TLS Client Hello よりも先に進行していることを必要としますから、これらは意味のある値を返しませんし、安全に呼び出すことも出来ません。"

#: ../../library/ssl.rst:1244
msgid ""
"The *server_name_callback* function must return ``None`` to allow the TLS "
"negotiation to continue.  If a TLS failure is required, a constant "
":const:`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>` can be "
"returned.  Other return values will result in a TLS fatal error with "
":const:`ALERT_DESCRIPTION_INTERNAL_ERROR`."
msgstr "TLS ネゴシエーションを継続させるならば、 *server_name_callback* 関数は ``None`` を返さなければなりません。TLS が失敗することを必要とするなら、 constant :const:`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>` を返してください。ここにない値を返すと、致命エラー :const:`ALERT_DESCRIPTION_INTERNAL_ERROR` を引き起こします。"

#: ../../library/ssl.rst:1250
msgid ""
"If there is an IDNA decoding error on the server name, the TLS connection "
"will terminate with an :const:`ALERT_DESCRIPTION_INTERNAL_ERROR` fatal TLS "
"alert message to the client."
msgstr "サーバ名に対する IDNA デコードのエラーがあれば、TLS 接続はクライアントに対する TLS の致命的アラートメッセージ :const:`ALERT_DESCRIPTION_INTERNAL_ERROR` とともに終了します。"

#: ../../library/ssl.rst:1254
msgid ""
"If an exception is raised from the *server_name_callback* function the TLS "
"connection will terminate with a fatal TLS alert message "
":const:`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`."
msgstr "*server_name_callback* 関数が例外を送出した場合、TLS 接続は TLS の致命的アラートメッセージ :const:`ALERT_DESCRIPTION_HANDSHAKE_FAILURE` とともに終了します。"

#: ../../library/ssl.rst:1258
msgid ""
"This method will raise :exc:`NotImplementedError` if the OpenSSL library had"
" OPENSSL_NO_TLSEXT defined when it was built."
msgstr "このメソッドは OpenSSL ライブラリが OPENSSL_NO_TLSEXT を定義してビルドされている場合、 :exc:`NotImplementedError` を送出します。"

#: ../../library/ssl.rst:1263
msgid ""
"Load the key generation parameters for Diffie-Helman (DH) key exchange. "
"Using DH key exchange improves forward secrecy at the expense of "
"computational resources (both on the server and on the client). The *dhfile*"
" parameter should be the path to a file containing DH parameters in PEM "
"format."
msgstr "ディフィー・ヘルマン(DH)鍵交換のための鍵生成パラメータをロードします。DH 鍵交換を用いることは、(サーバ、クライアントともに)計算機リソースに高い処理負荷をかけますがセキュリティを向上させます。 *dhfile* パラメータは PEM フォーマットの DH パラメータを含んだファイルへのパスでなければなりません。"

#: ../../library/ssl.rst:1269
msgid ""
"This setting doesn't apply to client sockets.  You can also use the "
":data:`OP_SINGLE_DH_USE` option to further improve security."
msgstr "この設定はクライアントソケットには適用されません。さらにセキュリティを改善するのに :data:`OP_SINGLE_DH_USE` オプションも利用できます。"

#: ../../library/ssl.rst:1274
msgid ""
"Set the curve name for Elliptic Curve-based Diffie-Hellman (ECDH) key "
"exchange.  ECDH is significantly faster than regular DH while arguably as "
"secure.  The *curve_name* parameter should be a string describing a well-"
"known elliptic curve, for example ``prime256v1`` for a widely supported "
"curve."
msgstr "楕円曲線ディフィー・ヘルマン(ECDH)鍵交換の曲線名を指定します。ECDH はもとの DH に較べて、ほぼ間違いなく同程度に安全である一方で、顕著に高速です。 *curve_name* パラメータは既知の楕円曲線を表す文字列でなければなりません。例えば ``prime256v1`` が広くサポートされている曲線です。"

#: ../../library/ssl.rst:1280
msgid ""
"This setting doesn't apply to client sockets.  You can also use the "
":data:`OP_SINGLE_ECDH_USE` option to further improve security."
msgstr "この設定はクライアントソケットには適用されません。さらにセキュリティを改善するのに :data:`OP_SINGLE_ECDH_USE` オプションも利用できます。"

#: ../../library/ssl.rst:1283
msgid "This method is not available if :data:`HAS_ECDH` is ``False``."
msgstr "このメソッドは :data:`HAS_ECDH` が ``False`` の場合は利用できません。"

#: ../../library/ssl.rst:1286
msgid ""
"`SSL/TLS & Perfect Forward Secrecy <http://vincent.bernat.im/en/blog/2011"
"-ssl-perfect-forward-secrecy.html>`_"
msgstr "`SSL/TLS & Perfect Forward Secrecy <http://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy.html>`_"

#: ../../library/ssl.rst:1287
msgid "Vincent Bernat."
msgstr "Vincent Bernat."

#: ../../library/ssl.rst:1293
msgid ""
"Wrap an existing Python socket *sock* and return an :class:`SSLSocket` "
"object.  *sock* must be a :data:`~socket.SOCK_STREAM` socket; other socket "
"types are unsupported."
msgstr "既存の Python ソケット *sock* をラップして :class:`ssl.SSLSocket` オブジェクトを返します。 *sock* は :data:`~socket.SOCK_STREAM` ソケットでなければなりません; ほかのタイプのソケットはサポートされていません。"

#: ../../library/ssl.rst:1297
msgid ""
"The returned SSL socket is tied to the context, its settings and "
"certificates.  The parameters *server_side*, *do_handshake_on_connect* and "
"*suppress_ragged_eofs* have the same meaning as in the top-level "
":func:`wrap_socket` function."
msgstr "返される SSL ソケットは、コンテキスト、その設定と証明書に関連付けられます。パラメータ *server_side*, *do_handshake_on_connect*, *suppress_ragged_eofs* はトップレベルの関数 :func:`wrap_socket` のものと同じ意味です。"

#: ../../library/ssl.rst:1302
msgid ""
"On client connections, the optional parameter *server_hostname* specifies "
"the hostname of the service which we are connecting to.  This allows a "
"single server to host multiple SSL-based services with distinct "
"certificates, quite similarly to HTTP virtual hosts. Specifying "
"*server_hostname* will raise a :exc:`ValueError` if *server_side* is true."
msgstr "クライアントサイドから接続では、 *server_hostname* で接続しようとしているサービスのホスト名を指定出来ます。これは HTTP バーチャルホストにかなり似て、シングルサーバで複数の SSL ベースのサービスを別々の証明書でホストしているようなサーバに対して使えます。 *server_side* が真の場合に *server_hostname* を指定すると :exc:`ValueError` を送出します。"

#: ../../library/ssl.rst:1308
msgid ""
"Always allow a server_hostname to be passed, even if OpenSSL does not have "
"SNI."
msgstr "OpenSSL が SNI をサポートしなくても server_hostname を許容するようになりました。"

#: ../../library/ssl.rst:1314
msgid ""
"Get statistics about the SSL sessions created or managed by this context. A "
"dictionary is returned which maps the names of each `piece of information "
"<https://www.openssl.org/docs/man1.1.0/ssl/SSL_CTX_sess_number.html>`_ to "
"their numeric values.  For example, here is the total number of hits and "
"misses in the session cache since the context was created::"
msgstr ""

#: ../../library/ssl.rst:1326
msgid ""
"Wether to match the peer cert's hostname with :func:`match_hostname` in "
":meth:`SSLSocket.do_handshake`. The context's "
":attr:`~SSLContext.verify_mode` must be set to :data:`CERT_OPTIONAL` or "
":data:`CERT_REQUIRED`, and you must pass *server_hostname* to "
":meth:`~SSLContext.wrap_socket` in order to match the hostname."
msgstr ":meth:`SSLSocket.do_handshake` 呼び出し時に、 :func:`match_hostname` を使って接続先証明書のホスト名の合致を見るかどうか。コンテキストの :attr:`~SSLContext.verify_mode` には :data:`CERT_OPTIONAL` か :data:`CERT_REQUIRED` をセットしなければなりません。また :meth:`~SSLContext.wrap_socket` にはホスト名の合致をみるための *server_hostname* を渡さなければなりません。"

#: ../../library/ssl.rst:1347
msgid "This features requires OpenSSL 0.9.8f or newer."
msgstr "この機能にはOpenSSL0.9.8f以降が必要です。"

#: ../../library/ssl.rst:1351
msgid ""
"An integer representing the set of SSL options enabled on this context. The "
"default value is :data:`OP_ALL`, but you can specify other options such as "
":data:`OP_NO_SSLv2` by ORing them together."
msgstr "このコンテキストで有効になっている SSL オプションを表す整数。デフォルトの値は :data:`OP_ALL` ですが、 :data:`OP_NO_SSLv2` のようなほかの値をビットOR演算で指定出来ます。"

#: ../../library/ssl.rst:1356
msgid ""
"With versions of OpenSSL older than 0.9.8m, it is only possible to set "
"options, not to clear them.  Attempting to clear an option (by resetting the"
" corresponding bits) will raise a ``ValueError``."
msgstr "OpenSSL の 0.9.8m より古いバージョンを使う場合、値はセットは出来ますがクリアが出来ません。オプションを(対応するビットをリセットすることで)クリアしようとすると ``ValueError`` が送出されます。"

#: ../../library/ssl.rst:1362
msgid ""
"The protocol version chosen when constructing the context.  This attribute "
"is read-only."
msgstr "コンテキストの構築時に選択されたプロトコルバージョン。この属性は読み取り専用です。"

#: ../../library/ssl.rst:1367
msgid ""
"The flags for certificate verification operations. You can set flags like "
":data:`VERIFY_CRL_CHECK_LEAF` by ORing them together. By default OpenSSL "
"does neither require nor verify certificate revocation lists (CRLs). "
"Available only with openssl version 0.9.8+."
msgstr "証明書の検証操作のためのフラグです。 :data:`VERIFY_CRL_CHECK_LEAF` などのフラグをビットOR演算でセット出来ます。デフォルトでは OpenSSL は証明書失効リスト(CRLs)を必要ともしませんし検証にも使いません。openssl version 0.9.8+ でのみ利用可能です。"

#: ../../library/ssl.rst:1374
msgid ""
"Whether to try to verify other peers' certificates and how to behave if "
"verification fails.  This attribute must be one of :data:`CERT_NONE`, "
":data:`CERT_OPTIONAL` or :data:`CERT_REQUIRED`."
msgstr "接続先の証明書の検証を試みるかどうか、また、検証が失敗した場合にどのように振舞うべきかを制御します。この属性は :data:`CERT_NONE`, :data:`CERT_OPTIONAL`, :data:`CERT_REQUIRED` のうちどれか一つでなければなりません。"

#: ../../library/ssl.rst:1386
msgid "Certificates"
msgstr "証明書"

#: ../../library/ssl.rst:1388
msgid ""
"Certificates in general are part of a public-key / private-key system.  In "
"this system, each *principal*, (which may be a machine, or a person, or an "
"organization) is assigned a unique two-part encryption key.  One part of the"
" key is public, and is called the *public key*; the other part is kept "
"secret, and is called the *private key*.  The two parts are related, in that"
" if you encrypt a message with one of the parts, you can decrypt it with the"
" other part, and **only** with the other part."
msgstr "証明書を大まかに説明すると、公開鍵/秘密鍵システムの一種です。このシステムでは、各 *principal* (これはマシン、人、組織などです) は、ユニークな2つの暗号鍵を割り当てられます。1つは公開され、 *公開鍵(public key)* と呼ばれます。もう一方は秘密にされ、 *秘密鍵(private key)* と呼ばれます。 2つの鍵は関連しており、片方の鍵で暗号化したメッセージは、もう片方の鍵 **のみ** で復号できます。"

#: ../../library/ssl.rst:1396
msgid ""
"A certificate contains information about two principals.  It contains the "
"name of a *subject*, and the subject's public key.  It also contains a "
"statement by a second principal, the *issuer*, that the subject is who they "
"claim to be, and that this is indeed the subject's public key.  The issuer's"
" statement is signed with the issuer's private key, which only the issuer "
"knows.  However, anyone can verify the issuer's statement by finding the "
"issuer's public key, decrypting the statement with it, and comparing it to "
"the other information in the certificate. The certificate also contains "
"information about the time period over which it is valid.  This is expressed"
" as two fields, called \"notBefore\" and \"notAfter\"."
msgstr ""

#: ../../library/ssl.rst:1406
msgid ""
"In the Python use of certificates, a client or server can use a certificate "
"to prove who they are.  The other side of a network connection can also be "
"required to produce a certificate, and that certificate can be validated to "
"the satisfaction of the client or server that requires such validation.  The"
" connection attempt can be set to raise an exception if the validation "
"fails. Validation is done automatically, by the underlying OpenSSL "
"framework; the application need not concern itself with its mechanics.  But "
"the application does usually need to provide sets of certificates to allow "
"this process to take place."
msgstr "Python において証明書を利用する場合、クライアントもサーバーも自分を証明するために証明書を利用することができます。ネットワーク接続の相手側に証明書の提示を要求する事ができ、そのクライアントやサーバーが認証を必要とするならその証明書を認証することができます。認証が失敗した場合、接続は例外を発生させます。認証は下位層のOpenSSLフレームワークが自動的に行います。アプリケーションは認証機構について意識する必要はありません。しかし、アプリケーションは認証プロセスのために幾つかの証明書を提供する必要があるかもしれません。"

#: ../../library/ssl.rst:1416
msgid ""
"Python uses files to contain certificates.  They should be formatted as "
"\"PEM\" (see :rfc:`1422`), which is a base-64 encoded form wrapped with a "
"header line and a footer line::"
msgstr "Python は証明書を格納したファイルを利用します。そのファイルは \"PEM\" (:rfc:`1422` 参照) フォーマットという、ヘッダー行とフッター行の間にbase-64エンコードされた形をとっている必要があります。 ::"

#: ../../library/ssl.rst:1425
msgid "Certificate chains"
msgstr "証明書チェイン"

#: ../../library/ssl.rst:1427
msgid ""
"The Python files which contain certificates can contain a sequence of "
"certificates, sometimes called a *certificate chain*.  This chain should "
"start with the specific certificate for the principal who \"is\" the client "
"or server, and then the certificate for the issuer of that certificate, and "
"then the certificate for the issuer of *that* certificate, and so on up the "
"chain till you get to a certificate which is *self-signed*, that is, a "
"certificate which has the same subject and issuer, sometimes called a *root "
"certificate*.  The certificates should just be concatenated together in the "
"certificate file.  For example, suppose we had a three certificate chain, "
"from our server certificate to the certificate of the certification "
"authority that signed our server certificate, to the root certificate of the"
" agency which issued the certification authority's certificate::"
msgstr "Pythonが利用する証明書を格納したファイルは、ときには *証明書チェイン(certificate chain)* と呼ばれる証明書のシーケンスを格納します。このチェインは、まずクライアントやサーバー自体の principal の証明書で始まらなければなりません。それ以降に続く証明書は、手前の証明書の発行者(issuer)の証明書になり、最後にsubject と発行者が同じ *自己署名(self-signed)* 証明書で終わります。この最後の証明書は *ルート証明書(root certificate* と呼ばれます。これらの証明書チェインは1つの証明書ファイルに結合されなければなりません。例えば、3つの証明書からなる証明書チェインがあるとします。私たちのサーバーの証明書から、私たちのサーバーに署名した認証局の証明書、そして認証局の証明書を発行した機関のルート証明書です。 ::"

#: ../../library/ssl.rst:1451
msgid "CA certificates"
msgstr "CA 証明書"

#: ../../library/ssl.rst:1453
msgid ""
"If you are going to require validation of the other side of the connection's"
" certificate, you need to provide a \"CA certs\" file, filled with the "
"certificate chains for each issuer you are willing to trust.  Again, this "
"file just contains these chains concatenated together.  For validation, "
"Python will use the first chain it finds in the file which matches.  The "
"platform's certificates file can be used by calling "
":meth:`SSLContext.load_default_certs`, this is done automatically with "
":func:`.create_default_context`."
msgstr "もし相手から送られてきた証明書の認証をしたい場合、信頼している各発行者の証明書チェインが入った \"CA certs\" ファイルを提供する必要があります。繰り返しますが、このファイルは単純に、各チェインを結合しただけのものです。認証のために、Pythonはそのファイルの中の最初にマッチしたチェインを利用します。:meth:`SSLContext.load_default_certs` を呼び出すことでプラットフォームの証明書ファイルも使われますが、これは :func:`.create_default_context` によって自動的に行われます。"

#: ../../library/ssl.rst:1462
msgid "Combined key and certificate"
msgstr "秘密鍵と証明書を一緒にする"

#: ../../library/ssl.rst:1464
msgid ""
"Often the private key is stored in the same file as the certificate; in this"
" case, only the ``certfile`` parameter to :meth:`SSLContext.load_cert_chain`"
" and :func:`wrap_socket` needs to be passed.  If the private key is stored "
"with the certificate, it should come before the first certificate in the "
"certificate chain::"
msgstr "多くの場合、証明書と同じファイルに秘密鍵も格納されています。この場合、 :meth:`SSLContext.load_cert_chain`, :func:`wrap_socket` には ``certfile`` 引数だけが必要とされます。秘密鍵が証明書ファイルに格納されている場合、秘密鍵は証明書チェインの最初の証明書よりも先にないといけません。 ::"

#: ../../library/ssl.rst:1478
msgid "Self-signed certificates"
msgstr "自己署名証明書"

#: ../../library/ssl.rst:1480
msgid ""
"If you are going to create a server that provides SSL-encrypted connection "
"services, you will need to acquire a certificate for that service.  There "
"are many ways of acquiring appropriate certificates, such as buying one from"
" a certification authority.  Another common practice is to generate a self-"
"signed certificate.  The simplest way to do this is with the OpenSSL "
"package, using something like the following::"
msgstr "SSL暗号化接続サービスを提供するサーバーを建てる場合、適切な証明書を取得するには、認証局から買うなどの幾つかの方法があります。また、自己署名証明書を作るケースもあります。 OpenSSLを使って自己署名証明書を作るには、次のようにします。 ::"

#: ../../library/ssl.rst:1509
msgid ""
"The disadvantage of a self-signed certificate is that it is its own root "
"certificate, and no one else will have it in their cache of known (and "
"trusted) root certificates."
msgstr "自己署名証明書の欠点は、それ自身がルート証明書であり、他の人はその証明書を持っていない (そして信頼しない)ことです。"

#: ../../library/ssl.rst:1515
msgid "Examples"
msgstr "例"

#: ../../library/ssl.rst:1518
msgid "Testing for SSL support"
msgstr "SSLサポートをテストする"

#: ../../library/ssl.rst:1520
msgid ""
"To test for the presence of SSL support in a Python installation, user code "
"should use the following idiom::"
msgstr "インストールされているPythonがSSLをサポートしているかどうかをテストするために、ユーザーコードは次のイディオムを利用することができます。 ::"

#: ../../library/ssl.rst:1531
msgid "Client-side operation"
msgstr "クライアントサイドの処理"

#: ../../library/ssl.rst:1533
msgid ""
"This example creates a SSL context with the recommended security settings "
"for client sockets, including automatic certificate verification::"
msgstr "この例では、自動的に証明書の検証を行うことを含む望ましいセキュリティ設定でクライアントソケットの SSL コンテキストを作ります::"

#: ../../library/ssl.rst:1538
msgid ""
"If you prefer to tune security settings yourself, you might create a context"
" from scratch (but beware that you might not get the settings right)::"
msgstr "あなた自身でセキュリティ設定を調整したいと望むなら、スクラッチからコンテキストを作ることは出来ます(ですが正しくない設定をしてしまいがちなことに警戒してください)"

#: ../../library/ssl.rst:1547
msgid ""
"(this snippet assumes your operating system places a bundle of all CA "
"certificates in ``/etc/ssl/certs/ca-bundle.crt``; if not, you'll get an "
"error and have to adjust the location)"
msgstr "(このスニペットは全ての CA 証明書が ``/etc/ssl/certs/ca-bundle.crt`` にバンドルされていることを仮定しています; もし違っていればエラーになりますので、適宜修正してください)"

#: ../../library/ssl.rst:1551
msgid ""
"When you use the context to connect to a server, :const:`CERT_REQUIRED` "
"validates the server certificate: it ensures that the server certificate was"
" signed with one of the CA certificates, and checks the signature for "
"correctness::"
msgstr "サーバへの接続にこのコンテキストを使うと、 :const:`CERT_REQUIRED` でサーバの証明書の検証が行われます: サーバの証明書が CA 証明書のいずれかに署名されていて、その署名が正しいことを保障します。"

#: ../../library/ssl.rst:1560
msgid "You may then fetch the certificate::"
msgstr "そして証明書を持ってくることが出来ます::"

#: ../../library/ssl.rst:1564
msgid ""
"Visual inspection shows that the certificate does identify the desired "
"service (that is, the HTTPS host ``www.python.org``)::"
msgstr "証明書が、期待しているサービス (つまり、 HTTPS ホスト ``www.python.org``) の身元を特定していることを視覚的に点検してみましょう::"

#: ../../library/ssl.rst:1607
msgid ""
"Now the SSL channel is established and the certificate verified, you can "
"proceed to talk with the server::"
msgstr "SSL チャネルは今や確立されて証明書が検証されているので、サーバとのお喋りを続けることが出来ます::"

#: ../../library/ssl.rst:1634
msgid "Server-side operation"
msgstr "サーバーサイドの処理"

#: ../../library/ssl.rst:1636
msgid ""
"For server operation, typically you'll need to have a server certificate, "
"and private key, each in a file.  You'll first create a context holding the "
"key and the certificate, so that clients can check your authenticity.  Then "
"you'll open a socket, bind it to a port, call :meth:`listen` on it, and "
"start waiting for clients to connect::"
msgstr "サーバーサイドの処理では、通常、サーバー証明書と秘密鍵がそれぞれファイルに格納された形で必要です。最初に秘密鍵と証明書が保持されたコンテキストを作成し、クライアントがあなたの信憑性をチェック出来るようにします。そののちにソケットを開き、ポートにバインドし、そのソケットの :meth:`listen` を呼び、クライアントからの接続を待ちます。 ::"

#: ../../library/ssl.rst:1651
msgid ""
"When a client connects, you'll call :meth:`accept` on the socket to get the "
"new socket from the other end, and use the context's "
":meth:`SSLContext.wrap_socket` method to create a server-side SSL socket for"
" the connection::"
msgstr "クライアントが接続してきた場合、 :meth:`accept` を呼んで新しいソケットを作成し、接続のためにサーバサイドの SSL ソケットを、コンテキストの :meth:`SSLContext.wrap_socket` メソッドで作ります::"

#: ../../library/ssl.rst:1664
msgid ""
"Then you'll read data from the ``connstream`` and do something with it till "
"you are finished with the client (or the client is finished with you)::"
msgstr "そして、 ``connstream`` からデータを読み、クライアントと切断する(あるいはクライアントが切断してくる)まで何か処理をします。 ::"

#: ../../library/ssl.rst:1678
msgid ""
"And go back to listening for new client connections (of course, a real "
"server would probably handle each client connection in a separate thread, or"
" put the sockets in non-blocking mode and use an event loop)."
msgstr "そして新しいクライアント接続のために listen に戻ります。 (もちろん現実のサーバは、おそらく個々のクライアント接続ごとに別のスレッドで処理するか、ソケットをノンブロッキングモードにし、イベントループを使うでしょう。)"

#: ../../library/ssl.rst:1686
msgid "Notes on non-blocking sockets"
msgstr "ノンブロッキングソケットについての注意事項"

#: ../../library/ssl.rst:1688
msgid ""
"When working with non-blocking sockets, there are several things you need to"
" be aware of:"
msgstr "ノンブロッキングソケットとともに使う場合、いくつか気をつけなければならない事項があります:"

#: ../../library/ssl.rst:1691
msgid ""
"Calling :func:`~select.select` tells you that the OS-level socket can be "
"read from (or written to), but it does not imply that there is sufficient "
"data at the upper SSL layer.  For example, only part of an SSL frame might "
"have arrived.  Therefore, you must be ready to handle :meth:`SSLSocket.recv`"
" and :meth:`SSLSocket.send` failures, and retry after another call to "
":func:`~select.select`."
msgstr ":func:`~select.select` 呼び出しは OS レベルでのソケットが読み出し可能(または書き込み可能)になったことを教えてくれますが、上位の SSL レイヤーでの十分なデータがあることを意味するわけではありません。例えば、SSL フレームの一部が届いただけかもしれません。ですから、 :meth:`SSLSocket.recv` と :meth:`SSLSocket.send` の失敗を処理することに備え、ほかの :func:`~select.select` 呼び出し後にリトライしなければなりません。"

#: ../../library/ssl.rst:1698
msgid ""
"Conversely, since the SSL layer has its own framing, a SSL socket may still "
"have data available for reading without :func:`~select.select` being aware "
"of it.  Therefore, you should first call :meth:`SSLSocket.recv` to drain any"
" potentially available data, and then only block on a :func:`~select.select`"
" call if still necessary."
msgstr "反対に、SSL レイヤーは自身で独自の枠組みを持っているために、読み出せるけれども :func:`~select.select` が気付くことのないデータを SSL ソケットが持っていることがあります。ですので、潜在的に入手可能なデータを飲み干すために最初に :meth:`SSLSocket.recv` を呼び出すべきであり、そののちでそれでもまだ必要な場合にだけ :func:`~select.select` でブロックすべきです。"

#: ../../library/ssl.rst:1704
msgid ""
"(of course, similar provisions apply when using other primitives such as "
":func:`~select.poll`, or those in the :mod:`selectors` module)"
msgstr "(当然のことながら、ほかのプリミティブ、例えば :func:`~select.poll` や :mod:`selectors` モジュール内のものを使う際にも似た但し書きが付きます)"

#: ../../library/ssl.rst:1707
msgid ""
"The SSL handshake itself will be non-blocking: the "
":meth:`SSLSocket.do_handshake` method has to be retried until it returns "
"successfully.  Here is a synopsis using :func:`~select.select` to wait for "
"the socket's readiness::"
msgstr "SSL ハンドシェイクそのものがノンブロッキングになります: :meth:`SSLSocket.do_handshake` メソッドは成功するまでリトライしなければなりません。 :func:`~select.select` を用いてソケットの準備が整うのを待つためには、およそ以下のようにします::"

#: ../../library/ssl.rst:1725
msgid "Security considerations"
msgstr "セキュリティで考慮すべき点"

#: ../../library/ssl.rst:1728
msgid "Best defaults"
msgstr "最善のデフォルト値"

#: ../../library/ssl.rst:1730
msgid ""
"For **client use**, if you don't have any special requirements for your "
"security policy, it is highly recommended that you use the "
":func:`create_default_context` function to create your SSL context. It will "
"load the system's trusted CA certificates, enable certificate validation and"
" hostname checking, and try to choose reasonably secure protocol and cipher "
"settings."
msgstr "**クライアントでの使用** では、あなたのセキュリティポリシーによる特殊な要件がない限りは、SSL コンテキストを作成するためには :func:`create_default_context` 関数を使用することを強くお勧めします。それはシステムが信頼した CA 証明書をロードし、証明書の検証を有効化し、ホスト名のチェックを行い、そしてセキュアなプロトコルとセキュアな暗号の分別ある設定を試みます。"

#: ../../library/ssl.rst:1737
msgid ""
"If a client certificate is needed for the connection, it can be added with "
":meth:`SSLContext.load_cert_chain`."
msgstr "接続にクライアントの証明書が必要な場合、 :meth:`SSLContext.load_cert_chain` によって追加出来ます。"

#: ../../library/ssl.rst:1740
msgid ""
"By contrast, if you create the SSL context by calling the "
":class:`SSLContext` constructor yourself, it will not have certificate "
"validation nor hostname checking enabled by default.  If you do so, please "
"read the paragraphs below to achieve a good security level."
msgstr "対照的に、 :class:`SSLContext` クラスのコンストラクタを自身で呼び出すことによって SSL コンテキストを作ると、デフォルトでは証明書検証もホスト名チェックも行わないものになります。もしそうするのであれば、良いセキュリティレベルを知るために、どうか下の方にあるパラグラフをお読みください。"

#: ../../library/ssl.rst:1746
msgid "Manual settings"
msgstr "手動での設定"

#: ../../library/ssl.rst:1749
msgid "Verifying certificates"
msgstr "証明書の検証"

#: ../../library/ssl.rst:1751
msgid ""
"When calling the :class:`SSLContext` constructor directly, "
":const:`CERT_NONE` is the default.  Since it does not authenticate the other"
" peer, it can be insecure, especially in client mode where most of time you "
"would like to ensure the authenticity of the server you're talking to. "
"Therefore, when in client mode, it is highly recommended to use "
":const:`CERT_REQUIRED`.  However, it is in itself not sufficient; you also "
"have to check that the server certificate, which can be obtained by calling "
":meth:`SSLSocket.getpeercert`, matches the desired service.  For many "
"protocols and applications, the service can be identified by the hostname; "
"in this case, the :func:`match_hostname` function can be used.  This common "
"check is automatically performed when :attr:`SSLContext.check_hostname` is "
"enabled."
msgstr ":class:`SSLContext` のコンストラクタを直接呼び出した場合、 :const:`CERT_NONE` がデフォルトとして使われます。これは接続先の身元特定をしないので安全ではありませんし、特にクライアントモードでは大抵相手となるサーバの信憑性を保障したいでしょう。ですから、クライアントモードでは :const:`CERT_REQUIRED` を強くお勧めします。ですが、それだけでは不十分です; :meth:`SSLSocket.getpeercert` を呼び出してサーバ証明書が望んだサービスと合致するかのチェックもしなければなりません。多くのプロトコルとアプリケーションにとって、サービスはホスト名で特定されます; この場合、 :func:`match_hostname` が使えます。これらの共通的なチェックは :attr:`SSLContext.check_hostname` が有効な場合、自動的に行われます。"

#: ../../library/ssl.rst:1764
msgid ""
"In server mode, if you want to authenticate your clients using the SSL layer"
" (rather than using a higher-level authentication mechanism), you'll also "
"have to specify :const:`CERT_REQUIRED` and similarly check the client "
"certificate."
msgstr "サーバモードにおいて、(より上位のレベルでの認証メカニズムではなく) SSL レイヤーを使ってあなたのクライアントを認証したいならば、 :const:`CERT_REQUIRED` を指定して同じようにクライアントの証明書を検証すべきでしょう。"

#: ../../library/ssl.rst:1770
msgid ""
"In client mode, :const:`CERT_OPTIONAL` and :const:`CERT_REQUIRED` are "
"equivalent unless anonymous ciphers are enabled (they are disabled by "
"default)."
msgstr "クライアントモードでは anonymous ciphers が有効(デフォルトでは無効)でない限り、 :const:`CERT_OPTIONAL` と :const:`CERT_REQUIRED` は同じ意味になります。"

#: ../../library/ssl.rst:1775
msgid "Protocol versions"
msgstr "プロトコルのバージョン"

#: ../../library/ssl.rst:1777
msgid ""
"SSL versions 2 and 3 are considered insecure and are therefore dangerous to "
"use.  If you want maximum compatibility between clients and servers, it is "
"recommended to use :const:`PROTOCOL_SSLv23` as the protocol version and then"
" disable SSLv2 and SSLv3 explicitly using the :data:`SSLContext.options` "
"attribute::"
msgstr "SSL versions 2 と 3 は非セキュアと考えられており、それゆえその使用は危険です。クライアントとサーバの最大限の互換性が欲しいならば、 :data:`SSLContext.options` 属性で明示的に SSLv2, SSLv3 を無効にして :const:`PROTOCOL_SSLv23` を使ってください::"

#: ../../library/ssl.rst:1787
msgid ""
"The SSL context created above will only allow TLSv1 and later (if supported "
"by your system) connections."
msgstr "上で作った SSL コンテキストは TLSv1 かそれ以降(あなたのシステムでサポートされていれば)だけでの接続を許可します。"

#: ../../library/ssl.rst:1791
msgid "Cipher selection"
msgstr "暗号の選択"

#: ../../library/ssl.rst:1793
msgid ""
"If you have advanced security requirements, fine-tuning of the ciphers "
"enabled when negotiating a SSL session is possible through the "
":meth:`SSLContext.set_ciphers` method.  Starting from Python 2.7.9, the ssl "
"module disables certain weak ciphers by default, but you may want to further"
" restrict the cipher choice. Be sure to read OpenSSL's documentation about "
"the `cipher list format <https://www.openssl.org/docs/apps/ciphers.html"
"#CIPHER-LIST-FORMAT>`_. If you want to check which ciphers are enabled by a "
"given cipher list, use the ``openssl ciphers`` command on your system."
msgstr ""

#: ../../library/ssl.rst:1803
msgid "Multi-processing"
msgstr "マルチプロセス化"

#: ../../library/ssl.rst:1805
msgid ""
"If using this module as part of a multi-processed application (using, for "
"example the :mod:`multiprocessing` or :mod:`concurrent.futures` modules), be"
" aware that OpenSSL's internal random number generator does not properly "
"handle forked processes.  Applications must change the PRNG state of the "
"parent process if they use any SSL feature with :func:`os.fork`.  Any "
"successful call of :func:`~ssl.RAND_add`, :func:`~ssl.RAND_bytes` or "
":func:`~ssl.RAND_pseudo_bytes` is sufficient."
msgstr "(例えば :mod:`multiprocessing` や :mod:`concurrent.futures` を使って、)マルチプロセスアプリケーションの一部としてこのモジュールを使う場合、OpenSSL の内部の乱数発生器は fork したプロセスを適切に処理しないことに気を付けて下さい。SSL の機能を :func:`os.fork` とともに使う場合、アプリケーションは親プロセスの PRNG 状態を変更しなければなりません。 :func:`~ssl.RAND_add`, :func:`~ssl.RAND_bytes`, :func:`~ssl.RAND_pseudo_bytes` のいずれかの呼び出し成功があれば十分です。"

#: ../../library/ssl.rst:1817
msgid "LibreSSL support"
msgstr ""

#: ../../library/ssl.rst:1819
msgid ""
"LibreSSL is a fork of OpenSSL 1.0.1. The ssl module has limited support for "
"LibreSSL. Some features are not available when the ssl module is compiled "
"with LibreSSL."
msgstr ""

#: ../../library/ssl.rst:1823
msgid ""
"LibreSSL >= 2.6.1 no longer supports NPN. The methods "
":meth:`SSLContext.set_npn_protocols` and "
":meth:`SSLSocket.selected_npn_protocol` are not available."
msgstr ""

#: ../../library/ssl.rst:1826
msgid ""
":meth:`SSLContext.set_default_verify_paths` ignores the env vars "
":envvar:`SSL_CERT_FILE` and :envvar:`SSL_CERT_PATH` although "
":func:`get_default_verify_paths` still reports them."
msgstr ""

#: ../../library/ssl.rst:1834
msgid "Class :class:`socket.socket`"
msgstr ":class:`socket.socket` クラス"

#: ../../library/ssl.rst:1834
msgid "Documentation of underlying :mod:`socket` class"
msgstr "下位レイヤーの :mod:`socket` クラスのドキュメント"

#: ../../library/ssl.rst:1837
msgid ""
"`SSL/TLS Strong Encryption: An Introduction "
"<https://httpd.apache.org/docs/trunk/en/ssl/ssl_intro.html>`_"
msgstr "`SSL/TLS Strong Encryption: An Introduction <https://httpd.apache.org/docs/trunk/en/ssl/ssl_intro.html>`_"

#: ../../library/ssl.rst:1837
msgid "Intro from the Apache webserver documentation"
msgstr "Apache WEBサーバのドキュメンテーションのイントロ"

#: ../../library/ssl.rst:1840
msgid ""
"`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: "
"Certificate-Based Key Management <https://www.ietf.org/rfc/rfc1422>`_"
msgstr "`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: Certificate-Based Key Management <https://www.ietf.org/rfc/rfc1422>`_"

#: ../../library/ssl.rst:1840
msgid "Steve Kent"
msgstr "Steve Kent"

#: ../../library/ssl.rst:1843
msgid ""
"`RFC 1750: Randomness Recommendations for Security "
"<https://www.ietf.org/rfc/rfc1750>`_"
msgstr "`RFC 1750: Randomness Recommendations for Security <https://www.ietf.org/rfc/rfc1750>`_"

#: ../../library/ssl.rst:1843
msgid "D. Eastlake et. al."
msgstr "D. Eastlake et. al."

#: ../../library/ssl.rst:1846
msgid ""
"`RFC 3280: Internet X.509 Public Key Infrastructure Certificate and CRL "
"Profile <https://www.ietf.org/rfc/rfc3280>`_"
msgstr "`RFC 3280: Internet X.509 Public Key Infrastructure Certificate and CRL Profile <https://www.ietf.org/rfc/rfc3280>`_"

#: ../../library/ssl.rst:1846
msgid "Housley et. al."
msgstr "Housley et. al."

#: ../../library/ssl.rst:1849
msgid ""
"`RFC 4366: Transport Layer Security (TLS) Extensions "
"<https://www.ietf.org/rfc/rfc4366>`_"
msgstr "`RFC 4366: Transport Layer Security (TLS) Extensions <https://www.ietf.org/rfc/rfc4366>`_"

#: ../../library/ssl.rst:1849
msgid "Blake-Wilson et. al."
msgstr "Blake-Wilson et. al."

#: ../../library/ssl.rst:1852
msgid ""
"`RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 "
"<https://tools.ietf.org/html/rfc5246>`_"
msgstr "`RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 <https://tools.ietf.org/html/rfc5246>`_"

#: ../../library/ssl.rst:1852
msgid "T. Dierks et. al."
msgstr "T. Dierks et. al."

#: ../../library/ssl.rst:1855
msgid ""
"`RFC 6066: Transport Layer Security (TLS) Extensions "
"<https://tools.ietf.org/html/rfc6066>`_"
msgstr "`RFC 6066: Transport Layer Security (TLS) Extensions <https://tools.ietf.org/html/rfc6066>`_"

#: ../../library/ssl.rst:1855
msgid "D. Eastlake"
msgstr "D. Eastlake"

#: ../../library/ssl.rst:1858
msgid ""
"`IANA TLS: Transport Layer Security (TLS) Parameters "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml>`_"
msgstr "`IANA TLS: Transport Layer Security (TLS) Parameters <https://www.iana.org/assignments/tls-parameters/tls-parameters.xml>`_"

#: ../../library/ssl.rst:1858
msgid "IANA"
msgstr "IANA"

#: ../../library/ssl.rst:1861
msgid ""
"`RFC 7525: Recommendations for Secure Use of Transport Layer Security (TLS) "
"and Datagram Transport Layer Security (DTLS) "
"<https://tools.ietf.org/html/rfc7525>`_"
msgstr ""

#: ../../library/ssl.rst:1861
msgid "IETF"
msgstr ""

#: ../../library/ssl.rst:1863
msgid ""
"`Mozilla's Server Side TLS recommendations "
"<https://wiki.mozilla.org/Security/Server_Side_TLS>`_"
msgstr ""

#: ../../library/ssl.rst:1864
msgid "Mozilla"
msgstr ""
