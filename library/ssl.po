# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-07-08 13:48+0900\n"
"PO-Revision-Date: 2018-07-08 04:58+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/ssl.rst:2
msgid ":mod:`ssl` --- TLS/SSL wrapper for socket objects"
msgstr ":mod:`ssl` --- ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹ TLS/SSL ãƒ©ãƒƒãƒ‘ãƒ¼"

#: ../../library/ssl.rst:17
msgid "**Source code:** :source:`Lib/ssl.py`"
msgstr "**Source code:** :source:`Lib/ssl.py`"

#: ../../library/ssl.rst:21
msgid ""
"This module provides access to Transport Layer Security (often known as "
"\"Secure Sockets Layer\") encryption and peer authentication facilities for "
"network sockets, both client-side and server-side.  This module uses the "
"OpenSSL library. It is available on all modern Unix systems, Windows, Mac OS"
" X, and probably additional platforms, as long as OpenSSL is installed on "
"that platform."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ Transport Layer Security (ã‚ˆã \"Secure Sockets Layer\" ã¨ã„ã†åå‰ã§çŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™) æš—å·åŒ–ã¨ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã€ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ä¸¡æ–¹ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚½ã‚±ãƒƒãƒˆã®ãŸã‚ã®ãƒ”ã‚¢èªè¨¼ã®ä»•çµ„ã¿ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯OpenSSLãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’åˆ©ç”¨ã—ã¦ã„ã¾ã™ã€‚OpenSSLã¯ã€å…¨ã¦ã®ãƒ¢ãƒ€ãƒ³ãªUnixã‚·ã‚¹ãƒ†ãƒ ã€Windowsã€Mac OS Xã€ãã®ä»–å¹¾ã¤ã‹ã® OpenSSLãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§åˆ©ç”¨ã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:27
msgid "Updated to support linking with OpenSSL 1.1.0"
msgstr ""

#: ../../library/ssl.rst:32
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs.  The installed version of OpenSSL may also "
"cause variations in behavior. For example, TLSv1.1 and TLSv1.2 come with "
"openssl version 1.0.1."
msgstr "OSã®ã‚½ã‚±ãƒƒãƒˆAPIã«å¯¾ã—ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€å¹¾ã¤ã‹ã®æŒ™å‹•ã¯ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ä¾å­˜ã«ãªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹OpenSSLã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®é•ã„ã‚‚æŒ™å‹•ã®é•ã„ã®åŸå› ã«ãªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€TLSv1.1, TLSv1.2 ã¯ openssl version 1.0.1 ä»¥é™ã§ã®ã¿åˆ©ç”¨å‡ºæ¥ã¾ã™ã€‚"

#: ../../library/ssl.rst:38
msgid ""
"Don't use this module without reading the :ref:`ssl-security`.  Doing so may"
" lead to a false sense of security, as the default settings of the ssl "
"module are not necessarily appropriate for your application."
msgstr ":ref:`ssl-security` ã‚’èª­ã¾ãšã«ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã—ãªã„ã§ãã ã•ã„ã€‚SSL ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã¯ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ååˆ†ã§ã¯ãªã„ã®ã§ã€èª­ã¾ãªã„å ´åˆã¯ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã«èª¤ã£ãŸæ„è­˜ã‚’æŒã£ã¦ã—ã¾ã†ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:43
msgid ""
"This section documents the objects and functions in the ``ssl`` module; for "
"more general information about TLS, SSL, and certificates, the reader is "
"referred to the documents in the \"See Also\" section at the bottom."
msgstr "ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€ ``ssl`` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨é–¢æ•°ã®è§£èª¬ã—ã¾ã™ã€‚ TLS, SSL, certificates ã«é–¢ã™ã‚‹ã‚ˆã‚Šä¸€èˆ¬çš„ãªæƒ…å ±ã¯ã€æœ«å°¾ã«ã‚ã‚‹ \"See Also\" ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:47
msgid ""
"This module provides a class, :class:`ssl.SSLSocket`, which is derived from "
"the :class:`socket.socket` type, and provides a socket-like wrapper that "
"also encrypts and decrypts the data going over the socket with SSL.  It "
"supports additional methods such as :meth:`getpeercert`, which retrieves the"
" certificate of the other side of the connection, and :meth:`cipher`,which "
"retrieves the cipher being used for the secure connection."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯1ã¤ã®ã‚¯ãƒ©ã‚¹ã€ :class:`ssl.SSLSocket` ã‚’æä¾›ã—ã¾ã™ã€‚ã“ã®ã‚¯ãƒ©ã‚¹ã¯ :class:`socket.socket` ã‚¯ãƒ©ã‚¹ã‚’ç¶™æ‰¿ã—ã¦ã„ã¦ã€ã‚½ã‚±ãƒƒãƒˆã§é€šä¿¡ã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’SSLã§æš—å·åŒ–ãƒ»å¾©å·ã™ã‚‹ã‚½ã‚±ãƒƒãƒˆã«ä¼¼ãŸãƒ©ãƒƒãƒ‘ãƒ¼ã«ãªã‚Šã¾ã™ã€‚ã¾ãŸã€ã“ã®ã‚¯ãƒ©ã‚¹ã¯è¿½åŠ ã§ã€æ¥ç¶šã®ç›¸æ‰‹å´ã‹ã‚‰ã®è¨¼æ˜æ›¸ã‚’å–å¾—ã™ã‚‹ :meth:`getpeercert` ãƒ¡ã‚½ãƒƒãƒ‰ã€ã‚»ã‚­ãƒ¥ã‚¢æ¥ç¶šã§ä½¿ã†ãŸã‚ã®æš—å·æ–¹å¼ã‚’å–å¾—ã™ã‚‹ :meth:`cipher` ã®ã‚ˆã†ãªãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/ssl.rst:54
msgid ""
"For more sophisticated applications, the :class:`ssl.SSLContext` class helps"
" manage settings and certificates, which can then be inherited by SSL "
"sockets created through the :meth:`SSLContext.wrap_socket` method."
msgstr "ã‚ˆã‚Šæ´—ç·´ã•ã‚ŒãŸã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãŸã‚ã«ã€ :class:`ssl.SSLContext` ã‚¯ãƒ©ã‚¹ãŒè¨­å®šã¨è¨¼æ˜æ›¸ã®ç®¡ç†ã®åŠ©ã‘ã¨ãªã‚‹ã§ã—ã‚‡ã†ã€‚ãã‚Œã¯ :meth:`SSLContext.wrap_socket` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’é€šã—ã¦ SSL ã‚½ã‚±ãƒƒãƒˆã‚’ä½œæˆã™ã‚‹ã“ã¨ã§å¼•ãç¶™ãŒã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:60
msgid "Functions, Constants, and Exceptions"
msgstr "é–¢æ•°ã€å®šæ•°ã€ä¾‹å¤–"

#: ../../library/ssl.rst:64
msgid ""
"Raised to signal an error from the underlying SSL implementation (currently "
"provided by the OpenSSL library).  This signifies some problem in the "
"higher-level encryption and authentication layer that's superimposed on the "
"underlying network connection.  This error is a subtype of "
":exc:`socket.error`, which in turn is a subtype of :exc:`IOError`.  The "
"error code and message of :exc:`SSLError` instances are provided by the "
"OpenSSL library."
msgstr "(ç¾åœ¨ã®ã¨ã“ã‚ OpenSSL ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã‚ˆã£ã¦æä¾›ã•ã‚Œã¦ã„ã‚‹)ä¸‹å±¤ã® SSL å®Ÿè£…ã‹ã‚‰ã®ã‚¨ãƒ©ãƒ¼ã‚’ä¼ãˆã‚‹ãŸã‚ã®ä¾‹å¤–ã§ã™ã€‚ã“ã®ã‚¨ãƒ©ãƒ¼ã¯ã€ä½ãƒ¬ãƒ™ãƒ«ãªãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®ä¸Šã«è¼‰ã£ã¦ã„ã‚‹ã€é«˜ãƒ¬ãƒ™ãƒ«ãªæš—å·åŒ–ã¨èªè¨¼ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§ã®å•é¡Œã‚’é€šçŸ¥ã—ã¾ã™ã€‚ã“ã®ã‚¨ãƒ©ãƒ¼ã¯ :exc:`socket.error` ã®ã‚µãƒ–ã‚¿ã‚¤ãƒ—ã§ã€ :exc:`socket.error` ã¯ :exc:`IOError` ã®ã‚µãƒ–ã‚¿ã‚¤ãƒ—ã§ã™ã€‚ :exc:`SSLError` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ OpenSSL ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã‚ˆã‚‹ã‚‚ã®ã§ã™ã€‚"

#: ../../library/ssl.rst:74
msgid ""
"A string mnemonic designating the OpenSSL submodule in which the error "
"occurred, such as ``SSL``, ``PEM`` or ``X509``.  The range of possible "
"values depends on the OpenSSL version."
msgstr "ã‚¨ãƒ©ãƒ¼ãŒèµ·ã“ã£ãŸ OpenSSL ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç¤ºã™ãƒ‹ãƒ¼ãƒ¢ãƒ‹ãƒƒã‚¯æ–‡å­—åˆ—ã§ã€ ``SSL``, ``PEM``, ``X509`` ãªã©ã§ã™ã€‚å–ã‚Šå¾—ã‚‹å€¤ã¯ OpenSSL ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ä¾å­˜ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:82
msgid ""
"A string mnemonic designating the reason this error occurred, for example "
"``CERTIFICATE_VERIFY_FAILED``.  The range of possible values depends on the "
"OpenSSL version."
msgstr "ã‚¨ãƒ©ãƒ¼ãŒèµ·ã“ã£ãŸåŸå› ã‚’ç¤ºã™ãƒ‹ãƒ¼ãƒ¢ãƒ‹ãƒƒã‚¯æ–‡å­—åˆ—ã§ã€ ``CERTIFICATE_VERIFY_FAILED`` ãªã©ã§ã™ã€‚å–ã‚Šå¾—ã‚‹å€¤ã¯ OpenSSL ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ä¾å­˜ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:90
msgid ""
"A subclass of :exc:`SSLError` raised when trying to read or write and the "
"SSL connection has been closed cleanly.  Note that this doesn't mean that "
"the underlying transport (read TCP) has been closed."
msgstr "èª­ã¿å‡ºã—ã‚ã‚‹ã„ã¯æ›¸ãè¾¼ã¿ã‚’è©¦ã¿ã‚ˆã†ã¨ã—ãŸéš›ã« SSL ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãŒè¡Œå„€ã‚ˆãé–‰ã˜ã‚‰ã‚Œã¦ã—ã¾ã£ãŸå ´åˆã«é€å‡ºã•ã‚Œã‚‹ :exc:`SSLError` ã‚µãƒ–ã‚¯ãƒ©ã‚¹ä¾‹å¤–ã§ã™ã€‚ã“ã‚Œã¯ä¸‹å±¤ã®è»¢é€(read TCP)ãŒé–‰ã˜ãŸã“ã¨ã¯æ„å‘³ã—ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:98
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket "
"<ssl-nonblocking>` when trying to read or write data, but more data needs to"
" be received on the underlying TCP transport before the request can be "
"fulfilled."
msgstr "èª­ã¿å‡ºã—ã‚ã‚‹ã„ã¯æ›¸ãè¾¼ã¿ã‚’è©¦ã¿ã‚ˆã†ã¨ã—ãŸéš›ã«ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒé‚è¡Œã•ã‚Œã‚‹å‰ã«ä¸‹å±¤ã® TCP è»¢é€ã§å—ã‘å–ã‚‹å¿…è¦ãŒã‚ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ãŸå ´åˆã« :ref:`non-blocking SSL socket <ssl-nonblocking>` ã«ã‚ˆã£ã¦é€å‡ºã•ã‚Œã‚‹ :exc:`SSLError` ã‚µãƒ–ã‚¯ãƒ©ã‚¹ä¾‹å¤–ã§ã™ã€‚"

#: ../../library/ssl.rst:107
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket "
"<ssl-nonblocking>` when trying to read or write data, but more data needs to"
" be sent on the underlying TCP transport before the request can be "
"fulfilled."
msgstr "èª­ã¿å‡ºã—ã‚ã‚‹ã„ã¯æ›¸ãè¾¼ã¿ã‚’è©¦ã¿ã‚ˆã†ã¨ã—ãŸéš›ã«ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒé‚è¡Œã•ã‚Œã‚‹å‰ã«ä¸‹å±¤ã® TCP è»¢é€ãŒé€ä¿¡ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ãŸå ´åˆã« :ref:`non-blocking SSL socket <ssl-nonblocking>` ã«ã‚ˆã£ã¦é€å‡ºã•ã‚Œã‚‹ :exc:`SSLError` ã‚µãƒ–ã‚¯ãƒ©ã‚¹ä¾‹å¤–ã§ã™ã€‚"

#: ../../library/ssl.rst:116
msgid ""
"A subclass of :exc:`SSLError` raised when a system error was encountered "
"while trying to fulfill an operation on a SSL socket.  Unfortunately, there "
"is no easy way to inspect the original errno number."
msgstr "SSL ã‚½ã‚±ãƒƒãƒˆä¸Šã§æ“ä½œã‚’é‚è¡Œã—ã‚ˆã†ã¨ã—ã¦ã„ã¦ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼ãŒèµ·ã“ã£ãŸå ´åˆã«é€å‡ºã•ã‚Œã‚‹ :exc:`SSLError` ã‚µãƒ–ã‚¯ãƒ©ã‚¹ä¾‹å¤–ã§ã™ã€‚æ®‹å¿µãªãŒã‚‰å…ƒã¨ãªã£ãŸ errno ç•ªå·ã‚’èª¿ã¹ã‚‹ç°¡å˜ãªæ–¹æ³•ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:124
msgid ""
"A subclass of :exc:`SSLError` raised when the SSL connection has been "
"terminated abruptly.  Generally, you shouldn't try to reuse the underlying "
"transport when this error is encountered."
msgstr "SSL ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãŒå”çªã«æ‰“ã¡åˆ‡ã‚‰ã‚ŒãŸéš›ã«é€å‡ºã•ã‚Œã‚‹ :exc:`SSLError` ã‚µãƒ–ã‚¯ãƒ©ã‚¹ä¾‹å¤–ã§ã™ã€‚ä¸€èˆ¬çš„ã«ã€ã“ã®ã‚¨ãƒ©ãƒ¼ãŒèµ·ã“ã£ãŸã‚‰ä¸‹å±¤ã®è»¢é€ã‚’å†åˆ©ç”¨ã—ã‚ˆã†ã¨è©¦ã¿ã‚‹ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:132
msgid ""
"Raised to signal an error with a certificate (such as mismatching hostname)."
"  Certificate errors detected by OpenSSL, though, raise an :exc:`SSLError`."
msgstr "è¨¼æ˜æ›¸ã®ã‚¨ãƒ©ãƒ¼(ãƒ›ã‚¹ãƒˆåã®ãƒŸã‚¹ãƒãƒƒãƒã®ã‚ˆã†ãª)ã‚’é€šçŸ¥ã™ã‚‹ãŸã‚ã«é€å‡ºã•ã‚Œã¾ã™ã€‚ãŸã ã—ã€OpenSSL ã«ã‚ˆã£ã¦æ¤œå‡ºã•ã‚ŒãŸå ´åˆã®è¨¼æ˜æ›¸ã‚¨ãƒ©ãƒ¼ã¯ :exc:`SSLError` ã§ã™ã€‚"

#: ../../library/ssl.rst:138
msgid "Socket creation"
msgstr "ã‚½ã‚±ãƒƒãƒˆã®ä½œæˆ"

#: ../../library/ssl.rst:140
msgid ""
"The following function allows for standalone socket creation.  Starting from"
" Python 2.7.9, it can be more flexible to use :meth:`SSLContext.wrap_socket`"
" instead."
msgstr "ä»¥ä¸‹ã«ç¤ºã™é–¢æ•°ã¯ã€ã‚¹ã‚¿ãƒ³ãƒ‰ã‚¢ãƒ­ãƒ³ã§ã‚½ã‚±ãƒƒãƒˆã‚’ä½œã‚ŠãŸã„å ´åˆã«ä½¿ã„ã¾ã™ã€‚Python 2.7.9 ã‹ã‚‰ã¯ã€ã“ã‚Œã‚ˆã‚Šã‚‚ã£ã¨æŸ”è»Ÿãª :meth:`SSLContext.wrap_socket` ãŒä½¿ãˆã¾ã™ã€‚"

#: ../../library/ssl.rst:146
msgid ""
"Takes an instance ``sock`` of :class:`socket.socket`, and returns an "
"instance of :class:`ssl.SSLSocket`, a subtype of :class:`socket.socket`, "
"which wraps the underlying socket in an SSL context.  ``sock`` must be a "
":data:`~socket.SOCK_STREAM` socket; other socket types are unsupported."
msgstr ":class:`socket.socket` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ ``sock`` ã‚’å—ã‘å–ã‚Šã€ :class:`socket.socket` ã®ã‚µãƒ–ã‚¿ã‚¤ãƒ—ã§ã‚ã‚‹ :class:`ssl.SSLSocket` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ :class:`ssl.SSLSocket` ã¯ä½ãƒ¬ã‚¤ãƒ¤ã®ã‚½ã‚±ãƒƒãƒˆã‚’SSLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ãƒ©ãƒƒãƒ—ã—ã¾ã™ã€‚ ``sock`` ã¯ :data:`~socket.SOCK_STREAM` ã‚½ã‚±ãƒƒãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“; ã»ã‹ã®ã‚¿ã‚¤ãƒ—ã®ã‚½ã‚±ãƒƒãƒˆã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:151
msgid ""
"For client-side sockets, the context construction is lazy; if the underlying"
" socket isn't connected yet, the context construction will be performed "
"after :meth:`connect` is called on the socket.  For server-side sockets, if "
"the socket has no remote peer, it is assumed to be a listening socket, and "
"the server-side SSL wrapping is automatically performed on client "
"connections accepted via the :meth:`accept` method.  :func:`wrap_socket` may"
" raise :exc:`SSLError`."
msgstr "ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã‚½ã‚±ãƒƒãƒˆã«ãŠã„ã¦ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ç”Ÿæˆã¯é…å»¶ã•ã‚Œã¾ã™ã€‚ã¤ã¾ã‚Šã€ä½ãƒ¬ã‚¤ãƒ¤ã®ã‚½ã‚±ãƒƒãƒˆãŒã¾ã æ¥ç¶šã•ã‚Œã¦ã„ãªã„å ´åˆã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ç”Ÿæˆã¯ãã®ã‚½ã‚±ãƒƒãƒˆã® :meth:`connect` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚ŒãŸå¾Œã«è¡Œã‚ã‚Œã¾ã™ã€‚ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã‚½ã‚±ãƒƒãƒˆã®å ´åˆã€ãã®ã‚½ã‚±ãƒƒãƒˆã«æ¥ç¶šå…ˆãŒå±…ãªã‘ã‚Œã°ãã‚Œã¯ listen ç”¨ã‚½ã‚±ãƒƒãƒˆã ã¨åˆ¤æ–­ã•ã‚Œã¾ã™ã€‚ :meth:`accept` ãƒ¡ã‚½ãƒƒãƒ‰ã§ç”Ÿæˆã•ã‚Œã‚‹ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆæ¥ç¶šã«å¯¾ã—ã¦ã®ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ SSLãƒ©ãƒƒãƒ—ã¯è‡ªå‹•çš„ã«è¡Œã‚ã‚Œã¾ã™ã€‚ :func:`wrap_socket` ã¯ :exc:`SSLError` ã‚’é€å‡ºã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/ssl.rst:159
msgid ""
"The ``keyfile`` and ``certfile`` parameters specify optional files which "
"contain a certificate to be used to identify the local side of the "
"connection.  See the discussion of :ref:`ssl-certificates` for more "
"information on how the certificate is stored in the ``certfile``."
msgstr "ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® ``keyfile`` ã¨ ``certfile`` å¼•æ•°ã¯ã€æ¥ç¶šã®ã“ã¡ã‚‰å´ã‚’è­˜åˆ¥ã™ã‚‹ãŸã‚ã«åˆ©ç”¨ã•ã‚Œã‚‹è¨¼æ˜æ›¸ã‚’å«ã‚€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ‡å®šã—ã¾ã™ã€‚è¨¼æ˜æ›¸ãŒã©ã®ã‚ˆã†ã« ``certfile`` ã«æ ¼ç´ã•ã‚Œã‚‹ã‹ã«ã¤ã„ã¦ã®ã‚ˆã‚Šè©³ã—ã„æƒ…å ±ã¯ã€ :ref:`ssl-certificates` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:164
msgid ""
"The parameter ``server_side`` is a boolean which identifies whether server-"
"side or client-side behavior is desired from this socket."
msgstr "``server_side`` å¼•æ•°ã¯çœŸå½å€¤ã§ã€ã“ã®ã‚½ã‚±ãƒƒãƒˆãŒã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã¨ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã®ã©ã¡ã‚‰ã®å‹•ä½œã‚’ã™ã‚‹ã®ã‹ã‚’æŒ‡å®šã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:167
msgid ""
"The parameter ``cert_reqs`` specifies whether a certificate is required from"
" the other side of the connection, and whether it will be validated if "
"provided.  It must be one of the three values :const:`CERT_NONE` "
"(certificates ignored), :const:`CERT_OPTIONAL` (not required, but validated "
"if provided), or :const:`CERT_REQUIRED` (required and validated).  If the "
"value of this parameter is not :const:`CERT_NONE`, then the ``ca_certs`` "
"parameter must point to a file of CA certificates."
msgstr "``cert_reqs`` å¼•æ•°ã¯ã€æ¥ç¶šã®ç›¸æ‰‹å´ã‹ã‚‰ã®è¨¼æ˜æ›¸ã‚’å¿…è¦ã¨ã™ã‚‹ã‹ã©ã†ã‹ã¨ã€ãã‚Œã‚’æ¤œè¨¼(validate)ã™ã‚‹ã‹ã©ã†ã‹ã‚’æŒ‡å®šã—ã¾ã™ã€‚ã“ã‚Œã¯æ¬¡ã®3ã¤ã®å®šæ•°ã®ã©ã‚Œã‹ã§ç„¡ã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“: :const:`CERT_NONE` (è¨¼æ˜æ›¸ã¯ç„¡è¦–ã•ã‚Œã¾ã™), :const:`CERT_OPTIONAL` (å¿…è¦ã¨ã—ãªã„ãŒã€æä¾›ã•ã‚ŒãŸå ´åˆã¯æ¤œè¨¼ã™ã‚‹), :const:`CERT_REQUIRED` (è¨¼æ˜æ›¸ã‚’å¿…è¦ã¨ã—ã€æ¤œè¨¼ã™ã‚‹)ã€‚ã‚‚ã—ã“ã®å¼•æ•°ãŒ :const:`CERT_NONE` ä»¥å¤–ã ã£ãŸå ´åˆã€ ``ca_certs`` å¼•æ•°ã¯CAè¨¼æ˜æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ‡å®šã—ã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:175
msgid ""
"The ``ca_certs`` file contains a set of concatenated \"certification "
"authority\" certificates, which are used to validate certificates passed "
"from the other end of the connection.  See the discussion of :ref:`ssl-"
"certificates` for more information about how to arrange the certificates in "
"this file."
msgstr "``ca_certs`` ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€æ¥ç¶šã®ç›¸æ‰‹å´ã‹ã‚‰æ¸¡ã•ã‚ŒãŸè¨¼æ˜æ›¸ã‚’æ¤œè¨¼ã™ã‚‹ãŸã‚ã«ä½¿ã†ã€ä¸€é€£ã®CAè¨¼æ˜æ›¸ã‚’çµåˆã—ãŸã‚‚ã®ã‚’å«ã‚“ã§ã„ã¾ã™ã€‚ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«å†…ã«ã©ã†è¨¼æ˜æ›¸ã‚’ä¸¦ã¹ã‚‹ã‹ã«ã¤ã„ã¦ã®è©³ã—ã„æƒ…å ±ã¯ :ref:`ssl-certificates` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:181
msgid ""
"The parameter ``ssl_version`` specifies which version of the SSL protocol to"
" use.  Typically, the server chooses a particular protocol version, and the "
"client must adapt to the server's choice.  Most of the versions are not "
"interoperable with the other versions.  If not specified, the default is "
":data:`PROTOCOL_SSLv23`; it provides the most compatibility with other "
"versions."
msgstr "``ssl_version`` å¼•æ•°ã¯ã€ä½¿ç”¨ã™ã‚‹SSLãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’æŒ‡å®šã—ã¾ã™ã€‚é€šå¸¸ã€ã‚µãƒ¼ãƒãƒ¼å´ãŒç‰¹å®šã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’é¸ã³ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã¯ã‚µãƒ¼ãƒãƒ¼ã®é¸ã‚“ã ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’å—ã‘å…¥ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã»ã¨ã‚“ã©ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯ä»–ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨äº’æ›æ€§ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã‚‚ã—ã“ã®å¼•æ•°ãŒæŒ‡å®šã•ã‚Œãªã‹ã£ãŸå ´åˆã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ :data:`PROTOCOL_SSLv23` ã«ãªã‚Šã¾ã™ã€‚ã“ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯ã€ã§ãã‚‹ã ã‘ã®äº’æ›æ€§ã‚’ç¢ºä¿ã™ã‚‹ã‚ˆã†ã«é¸ã°ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/ssl.rst:188
msgid ""
"Here's a table showing which versions in a client (down the side) can "
"connect to which versions in a server (along the top):"
msgstr "æ¬¡ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ã€ã©ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒã©ã®ã‚µãƒ¼ãƒãƒ¼å´ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«æ¥ç¶šã§ãã‚‹ã‹ã‚’ç¤ºã—ã¦ã„ã¾ã™:"

#: ../../library/ssl.rst:194
msgid "*client* / **server**"
msgstr "*client* / **server**"

#: ../../library/ssl.rst:194
msgid "**SSLv2**"
msgstr "**SSLv2**"

#: ../../library/ssl.rst:194
msgid "**SSLv3**"
msgstr "**SSLv3**"

#: ../../library/ssl.rst:194
msgid "**SSLv23**"
msgstr "**SSLv23**"

#: ../../library/ssl.rst:194
msgid "**TLSv1**"
msgstr "**TLSv1**"

#: ../../library/ssl.rst:194
msgid "**TLSv1.1**"
msgstr "**TLSv1.1**"

#: ../../library/ssl.rst:194
msgid "**TLSv1.2**"
msgstr "**TLSv1.2**"

#: ../../library/ssl.rst:196
msgid "*SSLv2*"
msgstr "*SSLv2*"

#: ../../library/ssl.rst:196 ../../library/ssl.rst:196
#: ../../library/ssl.rst:197 ../../library/ssl.rst:197
#: ../../library/ssl.rst:198 ../../library/ssl.rst:198
#: ../../library/ssl.rst:198 ../../library/ssl.rst:198
#: ../../library/ssl.rst:198 ../../library/ssl.rst:199
#: ../../library/ssl.rst:199 ../../library/ssl.rst:200
#: ../../library/ssl.rst:200 ../../library/ssl.rst:201
#: ../../library/ssl.rst:201
msgid "yes"
msgstr "yes"

#: ../../library/ssl.rst:196 ../../library/ssl.rst:196
#: ../../library/ssl.rst:196 ../../library/ssl.rst:196
#: ../../library/ssl.rst:197 ../../library/ssl.rst:197
#: ../../library/ssl.rst:197 ../../library/ssl.rst:197
#: ../../library/ssl.rst:198 ../../library/ssl.rst:199
#: ../../library/ssl.rst:199 ../../library/ssl.rst:199
#: ../../library/ssl.rst:199 ../../library/ssl.rst:200
#: ../../library/ssl.rst:200 ../../library/ssl.rst:200
#: ../../library/ssl.rst:200 ../../library/ssl.rst:201
#: ../../library/ssl.rst:201 ../../library/ssl.rst:201
#: ../../library/ssl.rst:201
msgid "no"
msgstr "no"

#: ../../library/ssl.rst:197
msgid "*SSLv3*"
msgstr "*SSLv3*"

#: ../../library/ssl.rst:198
msgid "*SSLv23* [1]_"
msgstr ""

#: ../../library/ssl.rst:199
msgid "*TLSv1*"
msgstr "*TLSv1*"

#: ../../library/ssl.rst:200
msgid "*TLSv1.1*"
msgstr "*TLSv1.1*"

#: ../../library/ssl.rst:201
msgid "*TLSv1.2*"
msgstr "*TLSv1.2*"

#: ../../library/ssl.rst:204
msgid "Footnotes"
msgstr "è„šæ³¨"

#: ../../library/ssl.rst:205
msgid ""
"TLS 1.3 protocol will be available with :data:`PROTOCOL_SSLv23` in OpenSSL "
">= 1.1.1. There is no dedicated PROTOCOL constant for just TLS 1.3."
msgstr ""

#: ../../library/ssl.rst:211
msgid ""
"Which connections succeed will vary depending on the version of OpenSSL.  "
"For example, before OpenSSL 1.0.0, an SSLv23 client would always attempt "
"SSLv2 connections."
msgstr "ã©ã®æ¥ç¶šãŒæˆåŠŸã™ã‚‹ã‹ã¯ã€ OpenSSL ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ä¾å­˜ã—ã¦å¤§ããå¤‰ã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€OpenSSL 1.0.0 ä»¥å‰ã¯ã€SSLv23 ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯å¸¸ã« SSLv2 æ¥ç¶šã‚’è©¦ã¿ã¦ã„ã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:215
msgid ""
"The *ciphers* parameter sets the available ciphers for this SSL object. It "
"should be a string in the `OpenSSL cipher list format "
"<https://www.openssl.org/docs/manmaster/man1/ciphers.html>`_."
msgstr ""

#: ../../library/ssl.rst:219
msgid ""
"The parameter ``do_handshake_on_connect`` specifies whether to do the SSL "
"handshake automatically after doing a :meth:`socket.connect`, or whether the"
" application program will call it explicitly, by invoking the "
":meth:`SSLSocket.do_handshake` method.  Calling "
":meth:`SSLSocket.do_handshake` explicitly gives the program control over the"
" blocking behavior of the socket I/O involved in the handshake."
msgstr "``do_handshake_on_connect`` å¼•æ•°ã¯ã€ :meth:`socket.connect` ã®å¾Œã«è‡ªå‹•çš„ã« SSLãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã‚’è¡Œã†ã‹ã€ãã‚Œã¨ã‚‚ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒæ˜ç¤ºçš„ã« :meth:`SSLSocket.do_handshake` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã‹ã‚’æŒ‡å®šã—ã¾ã™ã€‚ :meth:`SSLSocket.do_handshake` ã‚’æ˜ç¤ºçš„ã«å‘¼ã³ã ã™ã“ã¨ã§ã€ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã«ã‚ˆã‚‹ã‚½ã‚±ãƒƒãƒˆI/Oã®ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°å‹•ä½œã‚’åˆ¶å¾¡ã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:226
msgid ""
"The parameter ``suppress_ragged_eofs`` specifies how the "
":meth:`SSLSocket.read` method should signal unexpected EOF from the other "
"end of the connection.  If specified as :const:`True` (the default), it "
"returns a normal EOF (an empty bytes object) in response to unexpected EOF "
"errors raised from the underlying socket; if :const:`False`, it will raise "
"the exceptions back to the caller."
msgstr "``suppress_ragged_eofs`` å¼•æ•°ã¯ã€ :meth:`SSLSocket.read` ãƒ¡ã‚½ãƒƒãƒ‰ãŒã€æ¥ç¶šå…ˆã‹ã‚‰äºˆæœŸã—ãªã„EOF ã‚’å—ã‘å–ã£ãŸæ™‚ã«é€šçŸ¥ã™ã‚‹æ–¹æ³•ã‚’æŒ‡å®šã—ã¾ã™ã€‚ :const:`True` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ã®å ´åˆã€ä¸‹ä½ã®ã‚½ã‚±ãƒƒãƒˆãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰äºˆæœŸã›ã¬EOFã‚¨ãƒ©ãƒ¼ãŒæ¥ãŸå ´åˆã€é€šå¸¸ã®EOF (ç©ºã®ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ)ã‚’è¿”ã—ã¾ã™ã€‚ :const:`False` ã®å ´åˆã€å‘¼ã³å‡ºã—å…ƒã«ä¾‹å¤–ã‚’æŠ•ã’ã¦é€šçŸ¥ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:233
msgid "New optional argument *ciphers*."
msgstr "æ–°ã—ã„ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *ciphers*"

#: ../../library/ssl.rst:238
msgid "Context creation"
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ä½œæˆ"

#: ../../library/ssl.rst:240
msgid ""
"A convenience function helps create :class:`SSLContext` objects for common "
"purposes."
msgstr "ã‚³ãƒ³ãƒ“ãƒ‹ã‚¨ãƒ³ã‚¹é–¢æ•°ãŒã€å…±é€šã®ç›®çš„ã§ä½¿ç”¨ã•ã‚Œã‚‹ :class:`SSLContext` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ã®ã«å½¹ç«‹ã¡ã¾ã™ã€‚"

#: ../../library/ssl.rst:245
msgid ""
"Return a new :class:`SSLContext` object with default settings for the given "
"*purpose*.  The settings are chosen by the :mod:`ssl` module, and usually "
"represent a higher security level than when calling the :class:`SSLContext` "
"constructor directly."
msgstr "æ–°è¦ã® :class:`SSLContext` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã€ä¸ãˆã‚‰ã‚ŒãŸ *purpose* ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã§è¿”ã—ã¾ã™ã€‚è¨­å®šã¯ :mod:`ssl` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§é¸æŠã•ã‚Œã€é€šå¸¸ã¯ :class:`SSLContext` ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ç›´æ¥å‘¼ã³å‡ºã™ã‚ˆã‚Šã‚‚é«˜ã„ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒ™ãƒ«ã‚’è¡¨ç¾ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:250
msgid ""
"*cafile*, *capath*, *cadata* represent optional CA certificates to trust for"
" certificate verification, as in :meth:`SSLContext.load_verify_locations`.  "
"If all three are :const:`None`, this function can choose to trust the "
"system's default CA certificates instead."
msgstr "*cafile*, *capath*, *cadata* ã¯è¨¼æ˜æ›¸ã®æ¤œè¨¼ã§ä¿¡ç”¨ã™ã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® CA è¨¼æ˜æ›¸ã§ã€ :meth:`SSLContext.load_verify_locations` ã®ã‚‚ã®ã¨åŒã˜ã§ã™ã€‚ã“ã‚Œã‚‰ 3 ã¤å…¨ã¦ãŒ :const:`None` ã§ã‚ã‚Œã°ã€ã“ã®é–¢æ•°ã¯ä»£ã‚ã‚Šã«ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® CA è¨¼æ˜æ›¸ã‚’ä¿¡ç”¨ã—ã¦é¸æŠã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚"

#: ../../library/ssl.rst:256
msgid ""
"The settings are: :data:`PROTOCOL_SSLv23`, :data:`OP_NO_SSLv2`, and "
":data:`OP_NO_SSLv3` with high encryption cipher suites without RC4 and "
"without unauthenticated cipher suites. Passing :data:`~Purpose.SERVER_AUTH` "
"as *purpose* sets :data:`~SSLContext.verify_mode` to :data:`CERT_REQUIRED` "
"and either loads CA certificates (when at least one of *cafile*, *capath* or"
" *cadata* is given) or uses :meth:`SSLContext.load_default_certs` to load "
"default CA certificates."
msgstr "ã“ã‚Œã§ä½œã‚‰ã‚Œã‚‹è¨­å®šã¯ã“ã®ã‚ˆã†ã«ãªã‚Šã¾ã™: RC4 ã‚’é™¤ãã€é«˜ãƒ¬ãƒ™ãƒ«ã§ã€æœªèªè¨¼ã®ã‚‚ã®ã‚’å«ã¾ãªã„æš—å·åŒ–ä¸€å¼ã¨ :data:`PROTOCOL_SSLv23`, :data:`OP_NO_SSLv2`, :data:`OP_NO_SSLv3` ã€‚ *purpose* ã« :data:`~Purpose.SERVER_AUTH` ã‚’æ¸¡ã™ã¨ã€ :data:`~SSLContext.verify_mode` ã«ã¯ :data:`CERT_REQUIRED` ãŒã‚»ãƒƒãƒˆã•ã‚Œã€(*cafile*, *capath*, *cadata* ã®ã„ãšã‚Œã‹ãŒä¸ãˆã‚‰ã‚Œã‚Œã°) CA è¨¼æ˜æ›¸ãŒãƒ­ãƒ¼ãƒ‰ã•ã‚Œã‚‹ã‹ã¾ãŸã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® CA è¨¼æ˜æ›¸ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãŸã‚ã« :meth:`SSLContext.load_default_certs` ãŒä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:265
msgid ""
"The protocol, options, cipher and other settings may change to more "
"restrictive values anytime without prior deprecation.  The values represent "
"a fair balance between compatibility and security."
msgstr "ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã€æš—å·ãã®ä»–è¨­å®šã¯ã‚‚ã£ã¨åˆ¶é™ã•ã‚ŒãŸã€éå»ã®å»ƒã‚ŒãŸã‚‚ã®ã‚’å«ã¾ãªã„å€¤ã«ã„ã¤ã§ã‚‚å‡ºæ¥ã‚‹ã§ã—ã‚‡ã†ã€‚ã“ã®å€¤ã¯äº’æ›æ€§ã¨å®‰å…¨æ€§ã®å…¬å¹³ãªãƒãƒ©ãƒ³ã‚¹ã‚’è¡¨æ˜ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/ssl.rst:269
msgid ""
"If your application needs specific settings, you should create a "
":class:`SSLContext` and apply the settings yourself."
msgstr "ã‚‚ã—ã‚‚ã‚ãªãŸã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒãã®ã‚ˆã†ãªè¨­å®šã‚’å¿…è¦ã¨ã™ã‚‹ã®ã§ã‚ã‚Œã°ã€ :class:`SSLContext` ã‚’ä½œã£ã¦ã‚ãªãŸè‡ªèº«ã®è¨­å®šã‚’é©ç”¨ã™ã¹ãã§ã™ã€‚"

#: ../../library/ssl.rst:273
msgid ""
"If you find that when certain older clients or servers attempt to connect "
"with a :class:`SSLContext` created by this function that they get an error "
"stating \"Protocol or cipher suite mismatch\", it may be that they only "
"support SSL3.0 which this function excludes using the :data:`OP_NO_SSLv3`. "
"SSL3.0 is widely considered to be `completely broken "
"<https://en.wikipedia.org/wiki/POODLE>`_. If you still wish to continue to "
"use this function but still allow SSL 3.0 connections you can re-enable them"
" using::"
msgstr "ã‚ã‚‹ç¨®ã®å¤ã„ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚„ã‚µãƒ¼ãƒãŒæ¥ç¶šã—ã‚ˆã†ã¨è©¦ã¿ã¦ããŸå ´åˆã«ã€ã“ã®é–¢æ•°ã§ä½œã‚‰ã‚ŒãŸ :class:`SSLContext` ãŒ \"Protocol or cipher suite mismatch\" ã§å§‹ã¾ã‚‹ã‚¨ãƒ©ãƒ¼ã‚’èµ·ã“ã™ã®ã‚’ç›®æ’ƒã—ãŸã‚‰ãã‚Œã¯ã€ã“ã®é–¢æ•°ãŒ :data:`OP_NO_SSLv3` ã‚’ä½¿ã£ã¦é™¤å¤–ã—ã¦ã„ã‚‹ SSL 3.0 ã—ã‹ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„ã®ã§ã—ã‚‡ã†ã€‚SSL 3.0 ã¯ `å®Œç’§ã«ã¶ã£å£Šã‚Œã¦ã„ã‚‹ <https://en.wikipedia.org/wiki/POODLE>`_ ã“ã¨ãŒåºƒãçŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚ãã‚Œã§ã‚‚ã¾ã ã“ã®é–¢æ•°ã‚’ä½¿ã£ã¦ã€ãŸã ã— SSL 3.0 æ¥ç¶šã‚’è¨±å¯ã—ãŸã„ã¨æœ›ã‚€ãªã‚‰ã°ã€ã“ã‚Œã‚’ã“ã®ã‚ˆã†ã«å†æœ‰åŠ¹åŒ–å‡ºæ¥ã¾ã™::"

#: ../../library/ssl.rst:289
msgid "RC4 was dropped from the default cipher string."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æš—å·è¨­å®šã‹ã‚‰ RC4 ãŒé™¤ã‹ã‚Œã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:293
msgid "ChaCha20/Poly1305 was added to the default cipher string."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æš—å·åŒ–æ–‡å­—åˆ—ã« ChaCha20/Poly1305 ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:295
msgid "3DES was dropped from the default cipher string."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æš—å·åŒ–æ–‡å­—åˆ—ã‹ã‚‰ 3DES ãŒé™¤ã‹ã‚Œã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:299
msgid ""
"TLS 1.3 cipher suites TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384, and "
"TLS_CHACHA20_POLY1305_SHA256 were added to the default cipher string."
msgstr ""

#: ../../library/ssl.rst:304
msgid ""
"Specifies whether or not server certificates are verified when creating "
"client HTTPS connections without specifying a particular SSL context."
msgstr ""

#: ../../library/ssl.rst:307
msgid ""
"Starting with Python 2.7.9, :mod:`httplib` and modules which use it, such as"
" :mod:`urllib2` and :mod:`xmlrpclib`, default to verifying remote server "
"certificates received when establishing client HTTPS connections. This "
"default verification checks that the certificate is signed by a Certificate "
"Authority in the system trust store and that the Common Name (or Subject "
"Alternate Name) on the presented certificate matches the requested host."
msgstr ""

#: ../../library/ssl.rst:314
msgid ""
"Setting *enable* to :const:`True` ensures this default behaviour is in "
"effect."
msgstr ""

#: ../../library/ssl.rst:317
msgid ""
"Setting *enable* to :const:`False` reverts the default HTTPS certificate "
"handling to that of Python 2.7.8 and earlier, allowing connections to "
"servers using self-signed certificates, servers using certificates signed by"
" a Certicate Authority not present in the system trust store, and servers "
"where the hostname does not match the presented server certificate."
msgstr ""

#: ../../library/ssl.rst:323
msgid ""
"The leading underscore on this function denotes that it intentionally does "
"not exist in any implementation of Python 3 and may not be present in all "
"Python 2.7 implementations. The portable approach to bypassing certificate "
"checks or the system trust store when necessary is for tools to enable that "
"on a case-by-case basis by explicitly passing in a suitably configured SSL "
"context, rather than reverting the default behaviour of the standard library"
" client modules."
msgstr ""

#: ../../library/ssl.rst:335
msgid ""
"`CVE-2014-9365 <http://cve.mitre.org/cgi-"
"bin/cvename.cgi?name=CVE-2014-9365>`_ -- HTTPS man-in-the-middle attack "
"against Python clients using default settings"
msgstr ""

#: ../../library/ssl.rst:337
msgid ":pep:`476` -- Enabling certificate verification by default for HTTPS"
msgstr ""

#: ../../library/ssl.rst:338
msgid ":pep:`493` -- HTTPS verification migration tools for Python 2.7"
msgstr ""

#: ../../library/ssl.rst:342
msgid "Random generation"
msgstr "ä¹±æ•°ç”Ÿæˆ"

#: ../../library/ssl.rst:346
msgid ""
"OpenSSL has deprecated :func:`ssl.RAND_pseudo_bytes`, use "
":func:`ssl.RAND_bytes` instead."
msgstr "OpenSSL ã¯ :func:`ssl.RAND_pseudo_bytes` ã‚’å»ƒæ­¢ã—ã¾ã—ãŸã€‚ä»£ã‚ã‚Šã« :func:`ssl.RAND_bytes` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:352
msgid ""
"Return ``True`` if the SSL pseudo-random number generator has been seeded "
"with 'enough' randomness, and ``False`` otherwise.  You can use "
":func:`ssl.RAND_egd` and :func:`ssl.RAND_add` to increase the randomness of "
"the pseudo-random number generator."
msgstr "SSL æ“¬ä¼¼ä¹±æ•°ç”Ÿæˆå™¨ãŒååˆ†ãªãƒ©ãƒ³ãƒ€ãƒ æ€§(randomness)ã‚’å—ã‘å–ã£ã¦ã„ã‚‹æ™‚ã« ``True`` ã‚’ã€ãã‚Œä»¥å¤–ã®å ´åˆã¯ `False` ã‚’è¿”ã—ã¾ã™ã€‚ :func:`ssl.RAND_egd` ã¨ :func:`ssl.RAND_add` ã‚’ä½¿ã£ã¦æ“¬ä¼¼ä¹±æ•°ç”Ÿæˆæ©Ÿã«ãƒ©ãƒ³ãƒ€ãƒ æ€§ã‚’åŠ ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:359
msgid ""
"If you are running an entropy-gathering daemon (EGD) somewhere, and *path* "
"is the pathname of a socket connection open to it, this will read 256 bytes "
"of randomness from the socket, and add it to the SSL pseudo-random number "
"generator to increase the security of generated secret keys.  This is "
"typically only necessary on systems without better sources of randomness."
msgstr "ã‚‚ã—ã‚¨ãƒ³ãƒˆãƒ­ãƒ”ãƒ¼åé›†ãƒ‡ãƒ¼ãƒ¢ãƒ³(EGD=entropy-gathering daemon)ãŒå‹•ã„ã¦ã„ã¦ã€ *path* ãŒEGDã¸ã®ã‚½ã‚±ãƒƒãƒˆã®ãƒ‘ã‚¹ã ã£ãŸå ´åˆã€ã“ã®é–¢æ•°ã¯ãã®ã‚½ã‚±ãƒƒãƒˆã‹ã‚‰ 256ãƒã‚¤ãƒˆã®ãƒ©ãƒ³ãƒ€ãƒ æ€§ã‚’èª­ã¿è¾¼ã¿ã€SSLæ“¬ä¼¼ä¹±æ•°ç”Ÿæˆå™¨ã«ãã‚Œã‚’æ¸¡ã™ã“ã¨ã§ã€ç”Ÿæˆã•ã‚Œã‚‹æš—å·éµã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’å‘ä¸Šã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã¯ã€ã‚ˆã‚Šè‰¯ã„ãƒ©ãƒ³ãƒ€ãƒ æ€§ã®ã‚½ãƒ¼ã‚¹ãŒç„¡ã„ã‚·ã‚¹ãƒ†ãƒ ã§ã®ã¿å¿…è¦ã§ã™ã€‚"

#: ../../library/ssl.rst:365
msgid ""
"See http://egd.sourceforge.net/ or http://prngd.sourceforge.net/ for sources"
" of entropy-gathering daemons."
msgstr "ã‚¨ãƒ³ãƒˆãƒ­ãƒ”ãƒ¼åé›†ãƒ‡ãƒ¼ãƒ¢ãƒ³ã«ã¤ã„ã¦ã¯ã€ http://egd.sourceforge.net/ ã‚„ http://prngd.sourceforge.net/ ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:368
msgid "Availability: not available with LibreSSL and OpenSSL > 1.1.0"
msgstr "åˆ©ç”¨å‡ºæ¥ã‚‹ç’°å¢ƒ: LibreSSL ãŠã‚ˆã³ 1.1.0 ã‚’è¶…ãˆã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® OpenSSL ã§ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:372
msgid ""
"Mix the given *bytes* into the SSL pseudo-random number generator.  The "
"parameter *entropy* (a float) is a lower bound on the entropy contained in "
"string (so you can always use :const:`0.0`).  See :rfc:`1750` for more "
"information on sources of entropy."
msgstr "ä¸ãˆã‚‰ã‚ŒãŸ *bytes* ã‚’SSLæ“¬ä¼¼ä¹±æ•°ç”Ÿæˆå™¨ã«æ··ãœã¾ã™ã€‚ *entropy* å¼•æ•°(floatå€¤)ã¯ã€ãã®æ–‡å­—åˆ—ã«å«ã¾ã‚Œã‚‹ã‚¨ãƒ³ãƒˆãƒ­ãƒ”ãƒ¼ã®ä¸‹é™(lower bound)ã§ã™ã€‚ (ãªã®ã§ã€ã„ã¤ã§ã‚‚ :const:`0.0` ã‚’ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚) ã‚¨ãƒ³ãƒˆãƒ­ãƒ”ãƒ¼ã®ã‚½ãƒ¼ã‚¹ã«ã¤ã„ã¦ã®ã‚ˆã‚Šè©³ã—ã„æƒ…å ±ã¯ã€ :rfc:`1750` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:378
msgid "Certificate handling"
msgstr "è¨¼æ˜æ›¸ã®å–ã‚Šæ‰±ã„"

#: ../../library/ssl.rst:382
msgid ""
"Verify that *cert* (in decoded format as returned by "
":meth:`SSLSocket.getpeercert`) matches the given *hostname*.  The rules "
"applied are those for checking the identity of HTTPS servers as outlined in "
":rfc:`2818` and :rfc:`6125`, except that IP addresses are not currently "
"supported. In addition to HTTPS, this function should be suitable for "
"checking the identity of servers in various SSL-based protocols such as "
"FTPS, IMAPS, POPS and others."
msgstr "(:meth:`SSLSocket.getpeercert` ãŒè¿”ã—ã¦ããŸã‚ˆã†ãªãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®) *cert* ãŒã€ä¸ãˆã‚‰ã‚ŒãŸ *hostname* ã«åˆè‡´ã™ã‚‹ã‹ã‚’æ¤œè¨¼ã—ã¾ã™ã€‚HTTPS ã‚µãƒ¼ãƒã®èº«å…ƒã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ãŸã‚ã«é©ç”¨ã•ã‚Œã‚‹ãƒ«ãƒ¼ãƒ«ã¯ :rfc:`2818`, :rfc:`6125` ã§æ¦‚èª¬ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã§ã™ã€‚ãŸã ã— IP ã‚¢ãƒ‰ãƒ¬ã‚¹ã«ã‚ˆã‚‹ã‚‚ã®ã¯ç¾åœ¨ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚HTTPS ã«åŠ ãˆã€ã“ã®é–¢æ•°ã¯ä»–ã® SSL ãƒ™ãƒ¼ã‚¹ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã€ä¾‹ãˆã° FTPS, IMAPS, POPS ãªã©ã®ã‚µãƒ¼ãƒã®èº«å…ƒã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã®ã«ç›¸å¿œã—ã„ã¯ãšã§ã™ã€‚"

#: ../../library/ssl.rst:390
msgid ""
":exc:`CertificateError` is raised on failure. On success, the function "
"returns nothing::"
msgstr "å¤±æ•—ã™ã‚Œã° :exc:`CertificateError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚æˆåŠŸã™ã‚Œã°ã€ã“ã®é–¢æ•°ã¯ä½•ã‚‚è¿”ã—ã¾ã›ã‚“::"

#: ../../library/ssl.rst:406
msgid ""
"Return the time in seconds since the Epoch, given the ``cert_time`` string "
"representing the \"notBefore\" or \"notAfter\" date from a certificate in "
"``\"%b %d %H:%M:%S %Y %Z\"`` strptime format (C locale)."
msgstr "``cert_time`` ã¨ã—ã¦è¨¼æ˜æ›¸å†…ã® \"notBefore\" ã‚„ \"notAfter\" ã® ``\"%b %d %H:%M:%S %Y %Z\"`` strptime ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ (C locale) æ—¥ä»˜ã‚’æ¸¡ã™ã¨ã€ã‚¨ãƒãƒƒã‚¯ã‹ã‚‰ã®ç©ç®—ç§’ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:411
msgid "Here's an example:"
msgstr "ä¾‹ã§ã™ã€‚ :"

#: ../../library/ssl.rst:423
msgid "\"notBefore\" or \"notAfter\" dates must use GMT (:rfc:`5280`)."
msgstr "\"notBefore\" ã‚„ \"notAfter\" ã®æ—¥ä»˜ã«ã¯ GMT ã‚’ä½¿ã‚ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“(:rfc:`5280`)ã€‚"

#: ../../library/ssl.rst:425
msgid ""
"Interpret the input time as a time in UTC as specified by 'GMT' timezone in "
"the input string. Local timezone was used previously. Return an integer (no "
"fractions of a second in the input format)"
msgstr "å…¥åŠ›æ–‡å­—åˆ—ã«æŒ‡å®šã•ã‚ŒãŸ 'GMT' ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã‚’ UTC ã¨ã—ã¦è§£é‡ˆã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ä»¥å‰ã¯ãƒ­ãƒ¼ã‚«ãƒ«ã‚¿ã‚¤ãƒ ã§è§£é‡ˆã—ã¦ã„ã¾ã—ãŸã€‚ã¾ãŸã€æ•´æ•°ã‚’è¿”ã™ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸ(å…¥åŠ›ã«å«ã¾ã‚Œã‚‹ç§’ã®ç«¯æ•°ã‚’å«ã¾ãªã„)ã€‚"

#: ../../library/ssl.rst:433
msgid ""
"Given the address ``addr`` of an SSL-protected server, as a (*hostname*, "
"*port-number*) pair, fetches the server's certificate, and returns it as a "
"PEM-encoded string.  If ``ssl_version`` is specified, uses that version of "
"the SSL protocol to attempt to connect to the server.  If ``ca_certs`` is "
"specified, it should be a file containing a list of root certificates, the "
"same format as used for the same parameter in :func:`wrap_socket`.  The call"
" will attempt to validate the server certificate against that set of root "
"certificates, and will fail if the validation attempt fails."
msgstr "SSLã§ä¿è­·ã•ã‚ŒãŸã‚µãƒ¼ãƒãƒ¼ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ ``addr`` ã‚’ (*hostname*, *port-number*) ã®å½¢ã§å—ã‘å–ã‚Šã€ãã®ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰è¨¼æ˜æ›¸ã‚’å–å¾—ã—ã€ãã‚Œã‚’ PEMã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸæ–‡å­—åˆ—ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚ ``ssl_version`` ãŒæŒ‡å®šã•ã‚ŒãŸå ´åˆã¯ã€ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã‚’è©¦ã¿ã‚‹ã¨ãã«ãã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®SSLãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚ ``ca_certs`` ãŒæŒ‡å®šã•ã‚ŒãŸå ´åˆã€ãã‚Œã¯ :func:`wrap_socket` ã®åŒåã®å¼•æ•°ã¨åŒã˜ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§ã€ãƒ«ãƒ¼ãƒˆè¨¼æ˜æ›¸ã®ãƒªã‚¹ãƒˆã‚’å«ã‚€ãƒ•ã‚¡ã‚¤ãƒ«ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®é–¢æ•°ã¯ã‚µãƒ¼ãƒãƒ¼è¨¼æ˜æ›¸ã‚’ãƒ«ãƒ¼ãƒˆè¨¼æ˜æ›¸ãƒªã‚¹ãƒˆã«å¯¾ã—ã¦èªè¨¼ã—ã€èªè¨¼ãŒå¤±æ•—ã—ãŸå ´åˆã«ã“ã®é–¢æ•°ã‚‚å¤±æ•—ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:444
msgid ""
"This function is now IPv6-compatible, and the default *ssl_version* is "
"changed from :data:`PROTOCOL_SSLv3` to :data:`PROTOCOL_SSLv23` for maximum "
"compatibility with modern servers."
msgstr "ã“ã®é–¢æ•°ã¯ IPv6 äº’æ›ã«ãªã‚Šã¾ã—ãŸã€‚ *ssl_version* ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãŒã€æœ€è¿‘ã®ã‚µãƒ¼ãƒã¸ã®æœ€å¤§é™ã®äº’æ›æ€§ã®ãŸã‚ã« :data:`PROTOCOL_SSLv3` ã‹ã‚‰ :data:`PROTOCOL_SSLv23` ã«å¤‰æ›´ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:450
msgid ""
"Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded "
"string version of the same certificate."
msgstr "DERã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒã‚¤ãƒˆåˆ—ã¨ã—ã¦ä¸ãˆã‚‰ã‚ŒãŸè¨¼æ˜æ›¸ã‹ã‚‰ã€ PEMã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®åŒã˜è¨¼æ˜æ›¸ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:455
msgid ""
"Given a certificate as an ASCII PEM string, returns a DER-encoded sequence "
"of bytes for that same certificate."
msgstr "PEM å½¢å¼ã®ASCIIæ–‡å­—åˆ—ã¨ã—ã¦ä¸ãˆã‚‰ã‚ŒãŸè¨¼æ˜æ›¸ã‹ã‚‰ã€åŒã˜è¨¼æ˜æ›¸ã‚’DERã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ãŸãƒã‚¤ãƒˆåˆ—ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:460
msgid ""
"Returns a named tuple with paths to OpenSSL's default cafile and capath. The"
" paths are the same as used by :meth:`SSLContext.set_default_verify_paths`. "
"The return value is a :term:`named tuple` ``DefaultVerifyPaths``:"
msgstr "OpenSSL ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® cafile, capath ã‚’æŒ‡ã™ãƒ‘ã‚¹ã‚’åå‰ä»˜ãã‚¿ãƒ—ãƒ«ã§è¿”ã—ã¾ã™ã€‚ãƒ‘ã‚¹ã¯ :meth:`SSLContext.set_default_verify_paths` ã§ä½¿ã‚ã‚Œã‚‹ã‚‚ã®ã¨åŒã˜ã§ã™ã€‚æˆ»ã‚Šå€¤ã¯ :term:`named tuple` ``DefaultVerifyPaths`` ã§ã™:"

#: ../../library/ssl.rst:465
msgid ""
":attr:`cafile` - resolved path to cafile or ``None`` if the file doesn't "
"exist,"
msgstr ":attr:`cafile` - cafile ã®è§£æ±ºæ¸ˆã¿ãƒ‘ã‚¹ã€ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ ``None``"

#: ../../library/ssl.rst:466
msgid ""
":attr:`capath` - resolved path to capath or ``None`` if the directory "
"doesn't exist,"
msgstr ":attr:`capath` - capath ã®è§£æ±ºæ¸ˆã¿ãƒ‘ã‚¹ã€ã¾ãŸã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ ``None``"

#: ../../library/ssl.rst:467
msgid ""
":attr:`openssl_cafile_env` - OpenSSL's environment key that points to a "
"cafile,"
msgstr ":attr:`openssl_cafile_env` - cafile ã‚’æŒ‡ã™ OpenSSL ã®ç’°å¢ƒå¤‰æ•°"

#: ../../library/ssl.rst:468
msgid ":attr:`openssl_cafile` - hard coded path to a cafile,"
msgstr ":attr:`openssl_cafile` - OpenSSL ã«ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸ cafile ã®ãƒ‘ã‚¹"

#: ../../library/ssl.rst:469
msgid ""
":attr:`openssl_capath_env` - OpenSSL's environment key that points to a "
"capath,"
msgstr ":attr:`openssl_capath_env` - capath ã‚’æŒ‡ã™ OpenSSL ã®ç’°å¢ƒå¤‰æ•°"

#: ../../library/ssl.rst:470
msgid ":attr:`openssl_capath` - hard coded path to a capath directory"
msgstr ":attr:`openssl_capath` - OpenSSL ã«ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸ capath ã®ãƒ‘ã‚¹"

#: ../../library/ssl.rst:472
msgid ""
"Availability: LibreSSL ignores the environment vars "
":attr:`openssl_cafile_env` and :attr:`openssl_capath_env`"
msgstr "åˆ©ç”¨å‡ºæ¥ã‚‹ç’°å¢ƒ: LibreSSL ã§ã¯ç’°å¢ƒå¤‰æ•° :attr:`openssl_cafile_env` ã¨ :attr:`openssl_capath_env` ãŒç„¡è¦–ã•ã‚Œã¾ã™"

#: ../../library/ssl.rst:479
msgid ""
"Retrieve certificates from Windows' system cert store. *store_name* may be "
"one of ``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert "
"stores, too."
msgstr "Windows ã®ã‚·ã‚¹ãƒ†ãƒ è¨¼æ˜æ›¸ã‚¹ãƒˆã‚¢ã‚ˆã‚Šè¨¼æ˜æ›¸ã‚’æŠ½å‡ºã—ã¾ã™ã€‚ *store_name* ã¯ ``CA``, ``ROOT``, ``MY`` ã®ã†ã¡ã©ã‚Œã‹ä¸€ã¤ã§ã—ã‚‡ã†ã€‚Windows ã¯è¿½åŠ ã®è¨¼æ˜æ›¸ã‚¹ãƒˆã‚¢ã‚’æä¾›ã—ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:483
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either "
":const:`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 "
"ASN.1 data. Trust specifies the purpose of the certificate as a set of OIDS "
"or exactly ``True`` if the certificate is trustworthy for all purposes."
msgstr "ã“ã®é–¢æ•°ã¯ã‚¿ãƒ—ãƒ« (cert_bytes, encoding_type, trust) ã®ãƒªã‚¹ãƒˆã§è¿”ã—ã¾ã™ã€‚encoding_type ã¯ cert_bytes ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¡¨ã—ã¾ã™ã€‚X.509 ASN.1 ã«å¯¾ã™ã‚‹ :const:`x509_asn` ã‹ PKCS#7 ASN.1 ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã™ã‚‹ :const:`pkcs_7_asn` ã®ã„ãšã‚Œã‹ã§ã™ã€‚trust ã¯ã€è¨¼æ˜æ›¸ã®ç›®çš„ã‚’ã€OIDS ã‚’å†…å®¹ã«æŒã¤ set ã¨ã—ã¦è¡¨ã™ã‹ã€ã¾ãŸã¯è¨¼æ˜æ›¸ãŒå…¨ã¦ã®ç›®çš„ã§ä¿¡é ¼å‡ºæ¥ã‚‹ãªã‚‰ã° ``True`` ã§ã™ã€‚"

#: ../../library/ssl.rst:490 ../../library/ssl.rst:1332
msgid "Example::"
msgstr "ä¾‹::"

#: ../../library/ssl.rst:496 ../../library/ssl.rst:511
msgid "Availability: Windows."
msgstr "åˆ©ç”¨å‡ºæ¥ã‚‹ç’°å¢ƒ: Windows."

#: ../../library/ssl.rst:502
msgid ""
"Retrieve CRLs from Windows' system cert store. *store_name* may be one of "
"``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert stores, too."
msgstr "Windows ã®ã‚·ã‚¹ãƒ†ãƒ è¨¼æ˜æ›¸ã‚¹ãƒˆã‚¢ã‚ˆã‚Š CRLs ã‚’æŠ½å‡ºã—ã¾ã™ã€‚ *store_name* ã¯ ``CA``, ``ROOT``, ``MY`` ã®ã†ã¡ã©ã‚Œã‹ä¸€ã¤ã§ã—ã‚‡ã†ã€‚Windows ã¯è¿½åŠ ã®è¨¼æ˜æ›¸ã‚¹ãƒˆã‚¢ã‚’æä¾›ã—ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:506
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either "
":const:`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 "
"ASN.1 data."
msgstr "ã“ã®é–¢æ•°ã¯ã‚¿ãƒ—ãƒ« (cert_bytes, encoding_type, trust) ã®ãƒªã‚¹ãƒˆã§è¿”ã—ã¾ã™ã€‚encoding_type ã¯ cert_bytes ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¡¨ã—ã¾ã™ã€‚X.509 ASN.1 ã«å¯¾ã™ã‚‹ :const:`x509_asn` ã‹ PKCS#7 ASN.1 ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã™ã‚‹ :const:`pkcs_7_asn` ã®ã„ãšã‚Œã‹ã§ã™ã€‚"

#: ../../library/ssl.rst:517
msgid "Constants"
msgstr "å®šæ•°"

#: ../../library/ssl.rst:521
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In this mode (the default), no "
"certificates will be required from the other side of the socket connection. "
"If a certificate is received from the other end, no attempt to validate it "
"is made."
msgstr ":attr:`SSLContext.verify_mode` ã¾ãŸã¯ :func:`wrap_socket` ã® ``cert_reqs`` ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«ä½¿ç”¨ã™ã‚‹å€¤ã§ã™ã€‚ã“ã®ãƒ¢ãƒ¼ãƒ‰(ã“ã‚ŒãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã™)ã§ã¯ã€ã‚½ã‚±ãƒƒãƒˆæ¥ç¶šå…ˆã‹ã‚‰ã®è¨¼æ˜æ›¸ã‚„ãã®èªè¨¼ã‚’å¿…è¦ã¨ã—ã¾ã›ã‚“ã€‚æ¥ç¶šå…ˆã‹ã‚‰è¨¼æ˜æ›¸ã‚’å—ã‘å–ã£ã¦ã‚‚æ¤œè¨¼ã¯è©¦ã¿ã‚‰ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:527 ../../library/ssl.rst:1630
msgid "See the discussion of :ref:`ssl-security` below."
msgstr "ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ä¸‹ã®æ–¹ã®ã€ :ref:`ssl-security` ã«é–¢ã™ã‚‹è­°è«–ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:531
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In this mode no certificates will be "
"required from the other side of the socket connection; but if they are "
"provided, validation will be attempted and an :class:`SSLError` will be "
"raised on failure."
msgstr ":attr:`SSLContext.verify_mode` ã¾ãŸã¯ :func:`wrap_socket` ã® ``cert_reqs`` ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«ä½¿ç”¨ã™ã‚‹å€¤ã§ã™ã€‚ã“ã®ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€ã‚½ã‚±ãƒƒãƒˆæ¥ç¶šå…ˆã‹ã‚‰ã®è¨¼æ˜æ›¸ã‚„ãã®èªè¨¼ã‚’å¿…è¦ã¨ã—ã¾ã›ã‚“ãŒã€è¨¼æ˜æ›¸ãŒæä¾›ã•ã‚Œã‚Œã°æ¤œè¨¼ãŒè©¦ã¿ã‚‰ã‚Œã€æ¤œè¨¼å¤±æ•—æ™‚ã«ã¯ :class:`SSLError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:537 ../../library/ssl.rst:548
msgid ""
"Use of this setting requires a valid set of CA certificates to be passed, "
"either to :meth:`SSLContext.load_verify_locations` or as a value of the "
"``ca_certs`` parameter to :func:`wrap_socket`."
msgstr "ã“ã®è¨­å®šã§ã¯ã€æ­£å½“ãªCAè¨¼æ˜æ›¸ã®ã‚»ãƒƒãƒˆã‚’ :meth:`SSLContext.load_verify_locations` ã¾ãŸã¯ :func:`wrap_socket` ã® ``ca_certs`` ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ã©ã¡ã‚‰ã‹ã«æ¸¡ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/ssl.rst:543
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In this mode, certificates are required "
"from the other side of the socket connection; an :class:`SSLError` will be "
"raised if no certificate is provided, or if its validation fails."
msgstr ":attr:`SSLContext.verify_mode` ã¾ãŸã¯ :func:`wrap_socket` ã® ``cert_reqs`` ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«ä½¿ç”¨ã™ã‚‹å€¤ã§ã™ã€‚ã“ã®ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€ã‚½ã‚±ãƒƒãƒˆæ¥ç¶šå…ˆã‹ã‚‰ã®è¨¼æ˜æ›¸ã‚„ãã®èªè¨¼ã‚’å¿…è¦ã¨ã•ã‚Œã€è¨¼æ˜æ›¸ãŒæä¾›ã•ã‚Œãªã„ã‹ãã®æ¤œè¨¼å¤±æ•—æ™‚ã«ã¯ :class:`SSLError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:554
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, "
"certificate revocation lists (CRLs) are not checked. By default OpenSSL does"
" neither require nor verify CRLs."
msgstr ":attr:`SSLContext.verify_flags` ã«æ¸¡ã›ã‚‹å€¤ã§ã™ã€‚ã“ã®ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€è¨¼æ˜æ›¸å¤±åŠ¹ãƒªã‚¹ãƒˆ(CRLs)ã¯ãƒã‚§ãƒƒã‚¯ã•ã‚Œã¾ã›ã‚“ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ OpenSSL ã¯ CRLs ã‚’å¿…è¦ã¨ã‚‚ã—ã¾ã›ã‚“ã—æ¤œè¨¼ã«ã‚‚ä½¿ã„ã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:562
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, only the "
"peer cert is check but non of the intermediate CA certificates. The mode "
"requires a valid CRL that is signed by the peer cert's issuer (its direct "
"ancestor CA). If no proper has been loaded "
":attr:`SSLContext.load_verify_locations`, validation will fail."
msgstr ":attr:`SSLContext.verify_flags` ã«æ¸¡ã›ã‚‹å€¤ã§ã™ã€‚ã“ã®ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€æ¥ç¶šå…ˆã®è¨¼æ˜æ›¸ã®ãƒã‚§ãƒƒã‚¯ã®ã¿ã§ä»²ä»‹ã® CA è¨¼æ˜æ›¸ã¯ãƒã‚§ãƒƒã‚¯ã—ã¾ã›ã‚“ã€‚æ¥ç¶šå…ˆè¨¼æ˜æ›¸ã®ç™ºè¡Œè€…(ãã® CA ã®ç›´æ¥ã®ç¥–å…ˆ)ã«ã‚ˆã£ã¦ç½²åã•ã‚ŒãŸå¦¥å½“ãª CRL ãŒå¿…è¦ã§ã™ã€‚ :attr:`SSLContext.load_verify_locations` ãŒç›¸å¿œã—ã„ã‚‚ã®ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¦ã„ãªã‘ã‚Œã°ã€æ¤œè¨¼ã¯å¤±æ•—ã™ã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../library/ssl.rst:572
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, CRLs of "
"all certificates in the peer cert chain are checked."
msgstr ":attr:`SSLContext.verify_flags` ã«æ¸¡ã›ã‚‹å€¤ã§ã™ã€‚ã“ã®ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€æ¥ç¶šå…ˆã®è¨¼æ˜æ›¸ãƒã‚§ã‚¤ãƒ³å†…ã®å…¨ã¦ã®è¨¼æ˜æ›¸ã«ã¤ã„ã¦ã® CRLs ãŒãƒã‚§ãƒƒã‚¯ã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:579
msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to disable workarounds "
"for broken X.509 certificates."
msgstr ":attr:`SSLContext.verify_flags` ã«æ¸¡ã›ã‚‹å€¤ã§ã€å£Šã‚ŒãŸ X.509 è¨¼æ˜æ›¸ã«å¯¾ã™ã‚‹ãƒ¯ãƒ¼ã‚¯ã‚¢ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’ç„¡åŠ¹ã«ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:586
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL to "
"prefer trusted certificates when building the trust chain to validate a "
"certificate. This flag is enabled by default."
msgstr ":attr:`SSLContext.verify_flags` ã«æ¸¡ã›ã‚‹å€¤ã§ã™ã€‚OpenSSL ã«å¯¾ã—ã€è¨¼æ˜æ›¸æ¤œè¨¼ã®ãŸã‚ã«ä¿¡é ¼ãƒã‚§ã‚¤ãƒ³ã‚’æ§‹ç¯‰ã™ã‚‹éš›ã€ä¿¡é ¼å‡ºæ¥ã‚‹è¨¼æ˜æ›¸ã‚’é¸ã¶ã‚ˆã†ã«æŒ‡ç¤ºã—ã¾ã™ã€‚ã“ã‚Œã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§æœ‰åŠ¹ã«ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/ssl.rst:594
msgid ""
"Selects the highest protocol version that both the client and server "
"support. Despite the name, this option can select \"TLS\" protocols as well "
"as \"SSL\"."
msgstr "ãƒãƒ£ãƒ³ãƒãƒ«æš—å·åŒ–ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨ã—ã¦ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã‚µãƒ¼ãƒã®ä¸¡æ–¹ãŒã‚µãƒãƒ¼ãƒˆã™ã‚‹ä¸­ã®ã€ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒæœ€ã‚‚å¤§ããªã‚‚ã®ã‚’é¸æŠã—ã¾ã™ã€‚ãã®åå‰ã«ã‚‚é–¢ã‚ã‚‰ãšã€ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ \"SSL\" ã¨ã¨ã‚‚ã« \"TLS\" ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚‚é¸æŠã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:601
msgid "Alias for ``PROTOCOL_TLS``."
msgstr ""

#: ../../library/ssl.rst:603
msgid "Use ``PROTOCOL_TLS`` instead."
msgstr ""

#: ../../library/ssl.rst:607
msgid "Selects SSL version 2 as the channel encryption protocol."
msgstr "ãƒãƒ£ãƒ³ãƒãƒ«æš—å·åŒ–ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨ã—ã¦ SSL ãƒãƒ¼ã‚¸ãƒ§ãƒ³2ã‚’é¸æŠã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:609
msgid ""
"This protocol is not available if OpenSSL is compiled with the "
"``OPENSSL_NO_SSL2`` flag."
msgstr "ã“ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯ã€ OpenSSL ãŒ ``OPENSSL_NO_SSL2`` ãƒ•ãƒ©ã‚°ãŒæœ‰åŠ¹ãªçŠ¶æ…‹ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:614
msgid "SSL version 2 is insecure.  Its use is highly discouraged."
msgstr "SSL version 2 ã¯éã‚»ã‚­ãƒ¥ã‚¢ã§ã™ã€‚ã“ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯å¼·ãéæ¨å¥¨ã§ã™ã€‚"

#: ../../library/ssl.rst:616
msgid "OpenSSL has removed support for SSLv2."
msgstr "OpenSSL ã¯ SSLv2 ã¸ã®ã‚µãƒãƒ¼ãƒˆã‚’æ‰“åˆ‡ã‚Šã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:620
msgid "Selects SSL version 3 as the channel encryption protocol."
msgstr "ãƒãƒ£ãƒ³ãƒãƒ«æš—å·åŒ–ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨ã—ã¦SSLãƒãƒ¼ã‚¸ãƒ§ãƒ³3ã‚’é¸æŠã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:622
msgid ""
"This protocol is not be available if OpenSSL is compiled with the "
"``OPENSSL_NO_SSLv3`` flag."
msgstr "ã“ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯ã€ OpenSSL ãŒ ``OPENSSL_NO_SSLv3`` ãƒ•ãƒ©ã‚°ãŒæœ‰åŠ¹ãªçŠ¶æ…‹ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:627
msgid "SSL version 3 is insecure.  Its use is highly discouraged."
msgstr "SSL version 3 ã¯éã‚»ã‚­ãƒ¥ã‚¢ã§ã™ã€‚ã“ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯å¼·ãéæ¨å¥¨ã§ã™ã€‚"

#: ../../library/ssl.rst:631 ../../library/ssl.rst:640
#: ../../library/ssl.rst:652 ../../library/ssl.rst:665
msgid ""
"OpenSSL has deprecated all version specific protocols. Use the default "
"protocol with flags like ``OP_NO_SSLv3`` instead."
msgstr ""

#: ../../library/ssl.rst:636
msgid "Selects TLS version 1.0 as the channel encryption protocol."
msgstr "ãƒãƒ£ãƒ³ãƒãƒ«æš—å·åŒ–ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨ã—ã¦TLSãƒãƒ¼ã‚¸ãƒ§ãƒ³1.0ã‚’é¸æŠã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:645
msgid ""
"Selects TLS version 1.1 as the channel encryption protocol. Available only "
"with openssl version 1.0.1+."
msgstr "ãƒãƒ£ãƒ³ãƒãƒ«æš—å·åŒ–ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨ã—ã¦TLSãƒãƒ¼ã‚¸ãƒ§ãƒ³1.1ã‚’é¸æŠã—ã¾ã™ã€‚ openssl version 1.0.1+ ã®ã¿ã§åˆ©ç”¨å¯èƒ½ã§ã™ã€‚"

#: ../../library/ssl.rst:657
msgid ""
"Selects TLS version 1.2 as the channel encryption protocol. This is the most"
" modern version, and probably the best choice for maximum protection, if "
"both sides can speak it.  Available only with openssl version 1.0.1+."
msgstr "ãƒãƒ£ãƒ³ãƒãƒ«æš—å·åŒ–ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨ã—ã¦TLSãƒãƒ¼ã‚¸ãƒ§ãƒ³1.2ã‚’é¸æŠã—ã¾ã™ã€‚ã“ã‚Œã¯æœ€ã‚‚ç¾ä»£çš„ã§ã€æ¥ç¶šã®ä¸¡ã‚µã‚¤ãƒ‰ãŒåˆ©ç”¨ã§ãã‚‹å ´åˆã¯ã€ãŸã¶ã‚“æœ€ã‚‚å®‰å…¨ãªé¸æŠè‚¢ã§ã™ã€‚ openssl version 1.0.1+ ã®ã¿ã§åˆ©ç”¨å¯èƒ½ã§ã™ã€‚"

#: ../../library/ssl.rst:671
msgid ""
"Enables workarounds for various bugs present in other SSL implementations. "
"This option is set by default.  It does not necessarily set the same flags "
"as OpenSSL's ``SSL_OP_ALL`` constant."
msgstr "ç›¸æ‰‹ã«ã™ã‚‹ SSL å®Ÿè£…ã®ã•ã¾ã–ã¾ãªãƒã‚°ã‚’å›é¿ã™ã‚‹ãŸã‚ã®ãƒ¯ãƒ¼ã‚¯ã‚¢ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’æœ‰åŠ¹ã«ã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§æœ‰åŠ¹ã§ã™ã€‚ã“ã‚Œã‚’æœ‰åŠ¹ã«ã™ã‚‹å ´åˆ OpenSSL ç”¨ã®åŒã˜æ„å‘³ã®ãƒ•ãƒ©ã‚° ``SSL_OP_ALL`` ã‚’ã‚»ãƒƒãƒˆã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:679
msgid ""
"Prevents an SSLv2 connection.  This option is only applicable in conjunction"
" with :const:`PROTOCOL_SSLv23`.  It prevents the peers from choosing SSLv2 "
"as the protocol version."
msgstr "SSLv2 æ¥ç¶šãŒè¡Œã‚ã‚Œãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ :const:`PROTOCOL_SSLv23` ã¨çµ„ã¿åˆã‚ã›ã§ã®ã¿æ„å‘³ã‚’æŒã¡ã¾ã™ã€‚ãƒ”ã‚¢é–“ã§ SSLv2 ãŒãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ã—ã¦é¸æŠã•ã‚Œã‚‹ã“ã¨ã‚’é˜²ãã¾ã™ã€‚"

#: ../../library/ssl.rst:687
msgid ""
"Prevents an SSLv3 connection.  This option is only applicable in conjunction"
" with :const:`PROTOCOL_SSLv23`.  It prevents the peers from choosing SSLv3 "
"as the protocol version."
msgstr "SSLv3 æ¥ç¶šãŒè¡Œã‚ã‚Œãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ :const:`PROTOCOL_SSLv23` ã¨çµ„ã¿åˆã‚ã›ã§ã®ã¿æ„å‘³ã‚’æŒã¡ã¾ã™ã€‚ãƒ”ã‚¢é–“ã§ SSLv3 ãŒãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ã—ã¦é¸æŠã•ã‚Œã‚‹ã“ã¨ã‚’é˜²ãã¾ã™ã€‚"

#: ../../library/ssl.rst:695
msgid ""
"Prevents a TLSv1 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_SSLv23`.  It prevents the peers from choosing TLSv1 as"
" the protocol version."
msgstr "TLSv1 æ¥ç¶šãŒè¡Œã‚ã‚Œãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ :const:`PROTOCOL_SSLv23` ã¨çµ„ã¿åˆã‚ã›ã§ã®ã¿æ„å‘³ã‚’æŒã¡ã¾ã™ã€‚ãƒ”ã‚¢é–“ã§ TLSv1 ãŒãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ã—ã¦é¸æŠã•ã‚Œã‚‹ã“ã¨ã‚’é˜²ãã¾ã™ã€‚"

#: ../../library/ssl.rst:703
msgid ""
"Prevents a TLSv1.1 connection. This option is only applicable in conjunction"
" with :const:`PROTOCOL_SSLv23`. It prevents the peers from choosing TLSv1.1 "
"as the protocol version. Available only with openssl version 1.0.1+."
msgstr "TLSv1.1 æ¥ç¶šãŒè¡Œã‚ã‚Œãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ :const:`PROTOCOL_SSLv23` ã¨çµ„ã¿åˆã‚ã›ã§ã®ã¿æ„å‘³ã‚’æŒã¡ã¾ã™ã€‚ãƒ”ã‚¢é–“ã§ TLSv1.1 ãŒãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ã—ã¦é¸æŠã•ã‚Œã‚‹ã“ã¨ã‚’é˜²ãã¾ã™ã€‚openssl version 1.0.1+ ã§ã®ã¿åˆ©ç”¨ã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:711
msgid ""
"Prevents a TLSv1.2 connection. This option is only applicable in conjunction"
" with :const:`PROTOCOL_SSLv23`. It prevents the peers from choosing TLSv1.2 "
"as the protocol version. Available only with openssl version 1.0.1+."
msgstr "TLSv1.2 æ¥ç¶šãŒè¡Œã‚ã‚Œãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ :const:`PROTOCOL_SSLv23` ã¨çµ„ã¿åˆã‚ã›ã§ã®ã¿æ„å‘³ã‚’æŒã¡ã¾ã™ã€‚ãƒ”ã‚¢é–“ã§ TLSv1.2 ãŒãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ã—ã¦é¸æŠã•ã‚Œã‚‹ã“ã¨ã‚’é˜²ãã¾ã™ã€‚openssl version 1.0.1+ ã§ã®ã¿åˆ©ç”¨ã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:719
msgid ""
"Prevents a TLSv1.3 connection. This option is only applicable in conjunction"
" with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.3 as "
"the protocol version. TLS 1.3 is available with OpenSSL 1.1.1 or later. When"
" Python has been compiled against an older version of OpenSSL, the flag "
"defaults to *0*."
msgstr ""

#: ../../library/ssl.rst:729
msgid ""
"Use the server's cipher ordering preference, rather than the client's. This "
"option has no effect on client sockets and SSLv2 server sockets."
msgstr "æš—å·ã®å„ªå…ˆé †ä½ã¨ã—ã¦ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®ã‚‚ã®ã§ã¯ãªãã‚µãƒ¼ãƒã®ã‚‚ã®ã‚’ä½¿ã„ã¾ã™ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚½ã‚±ãƒƒãƒˆã¨ SSLv2 ã®ã‚µãƒ¼ãƒã‚½ã‚±ãƒƒãƒˆã§ã¯åŠ¹æœã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:736
msgid ""
"Prevents re-use of the same DH key for distinct SSL sessions.  This improves"
" forward secrecy but requires more computational resources. This option only"
" applies to server sockets."
msgstr "SSL ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’åŒºåˆ¥ã™ã‚‹ã®ã«åŒã˜ DH éµã‚’å†åˆ©ç”¨ã—ãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã‚Œã¯ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’å‘ä¸Šã•ã›ã¾ã™ãŒã€ã‚ˆã‚Šå¤šãã®è¨ˆç®—æ©Ÿãƒªã‚½ãƒ¼ã‚¹ã‚’å¿…è¦ã¨ã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ã‚µãƒ¼ãƒã‚½ã‚±ãƒƒãƒˆã«é©ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:744
msgid ""
"Prevents re-use of the same ECDH key for distinct SSL sessions.  This "
"improves forward secrecy but requires more computational resources. This "
"option only applies to server sockets."
msgstr "SSL ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’åŒºåˆ¥ã™ã‚‹ã®ã«åŒã˜ ECDH éµã‚’å†åˆ©ç”¨ã—ãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã‚Œã¯ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’å‘ä¸Šã•ã›ã¾ã™ãŒã€ã‚ˆã‚Šå¤šãã®è¨ˆç®—æ©Ÿãƒªã‚½ãƒ¼ã‚¹ã‚’å¿…è¦ã¨ã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ã‚µãƒ¼ãƒã‚½ã‚±ãƒƒãƒˆã«é©ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:752
msgid ""
"Disable compression on the SSL channel.  This is useful if the application "
"protocol supports its own compression scheme."
msgstr "SSL ãƒãƒ£ãƒãƒ«ã§ã®åœ§ç¸®ã‚’ç„¡åŠ¹ã«ã—ã¾ã™ã€‚ã“ã‚Œã¯ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãŒè‡ªèº«ã®åœ§ç¸®æ–¹æ³•ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å ´åˆã«æœ‰ç”¨ã§ã™ã€‚"

#: ../../library/ssl.rst:755
msgid "This option is only available with OpenSSL 1.0.0 and later."
msgstr "ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ OpenSSL 1.0.0ä»¥é™ã®ã¿ã§ä½¿ç”¨ã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:761
msgid ""
"Whether the OpenSSL library has built-in support for the *Application-Layer "
"Protocol Negotiation* TLS extension as described in :rfc:`7301`."
msgstr "OpenSSL ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã€çµ„ã¿è¾¼ã¿ã§ :rfc:`7301` ã§è¨˜è¿°ã•ã‚Œã¦ã„ã‚‹ *Application-Layer Protocol Negotiation* TLS æ‹¡å¼µã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã€‚"

#: ../../library/ssl.rst:768
msgid ""
"Whether the OpenSSL library has built-in support for Elliptic Curve-based "
"Diffie-Hellman key exchange.  This should be true unless the feature was "
"explicitly disabled by the distributor."
msgstr "OpenSSL ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã€çµ„ã¿è¾¼ã¿ã®æ¥•å††æ›²ç·šãƒ‡ã‚£ãƒ•ã‚£ãƒ¼ãƒ»ãƒ˜ãƒ«ãƒãƒ³éµå…±æœ‰ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã€‚ã“ã‚Œã¯ã€ãƒ‡ã‚£ã‚¹ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ã‚¿ãŒæ˜ç¤ºçš„ã«ç„¡åŠ¹ã«ã—ã¦ã„ãªã„é™ã‚Šã¯ã€çœŸã§ã‚ã‚‹ã¯ãšã§ã™ã€‚"

#: ../../library/ssl.rst:776
msgid ""
"Whether the OpenSSL library has built-in support for the *Server Name "
"Indication* extension (as defined in :rfc:`4366`)."
msgstr "OpenSSL ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã€çµ„ã¿è¾¼ã¿ã§ (:rfc:`4366` ã§è¨˜è¿°ã•ã‚Œã¦ã„ã‚‹) *Server Name Indication* æ‹¡å¼µã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã€‚"

#: ../../library/ssl.rst:783
msgid ""
"Whether the OpenSSL library has built-in support for *Next Protocol "
"Negotiation* as described in the `NPN draft specification "
"<https://tools.ietf.org/html/draft-agl-tls-nextprotoneg>`_. When true, you "
"can use the :meth:`SSLContext.set_npn_protocols` method to advertise which "
"protocols you want to support."
msgstr "OpenSSL ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã€çµ„ã¿è¾¼ã¿ã§ã€`NPN draft specification <https://tools.ietf.org/html/draft-agl-tls-nextprotoneg>`_ ã§è¨˜è¿°ã•ã‚Œã¦ã„ã‚‹ *Next Protocol Negotiation* ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã€‚ true ã§ã‚ã‚Œã°ã€ã‚µãƒãƒ¼ãƒˆã—ãŸã„ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ :meth:`SSLContext.set_npn_protocols` ãƒ¡ã‚½ãƒƒãƒ‰ã§æç¤ºã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:793
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.3 protocol."
msgstr ""

#: ../../library/ssl.rst:799
msgid ""
"List of supported TLS channel binding types.  Strings in this list can be "
"used as arguments to :meth:`SSLSocket.get_channel_binding`."
msgstr "ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ TLS ã®ãƒãƒ£ãƒãƒ«ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã®ã‚¿ã‚¤ãƒ—ã®ãƒªã‚¹ãƒˆã€‚ãƒªã‚¹ãƒˆå†…ã®æ–‡å­—åˆ—ã¯ :meth:`SSLSocket.get_channel_binding` ã®å¼•æ•°ã«æ¸¡ã›ã¾ã™ã€‚"

#: ../../library/ssl.rst:806
msgid "The version string of the OpenSSL library loaded by the interpreter::"
msgstr "ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ã‚ˆã£ã¦ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸ OpenSSL ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³æ–‡å­—åˆ—::"

#: ../../library/ssl.rst:815
msgid ""
"A tuple of five integers representing version information about the OpenSSL "
"library::"
msgstr "OpenSSL ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ã‚’è¡¨ã™5ã¤ã®æ•´æ•°ã®ã‚¿ãƒ—ãƒ«::"

#: ../../library/ssl.rst:825
msgid "The raw version number of the OpenSSL library, as a single integer::"
msgstr "1ã¤ã®æ•´æ•°ã®å½¢å¼ã®ã€ OpenSSL ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ç”Ÿã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·::"

#: ../../library/ssl.rst:838
msgid ""
"Alert Descriptions from :rfc:`5246` and others. The `IANA TLS Alert Registry"
" <https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_ contains this list and references to the RFCs where their "
"meaning is defined."
msgstr ":rfc:`5246` ãã®ä»–ã‹ã‚‰ã®ã‚¢ãƒ©ãƒ¼ãƒˆã®ç¨®é¡ã§ã™ã€‚ `IANA TLS Alert Registry <https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-6>`_ ã«ã¯ã“ã®ãƒªã‚¹ãƒˆã¨ãã®æ„å‘³ãŒå®šç¾©ã•ã‚ŒãŸ RFC ã¸ã®ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/ssl.rst:842
msgid ""
"Used as the return value of the callback function in "
":meth:`SSLContext.set_servername_callback`."
msgstr ":meth:`SSLContext.set_servername_callback` ã§ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã®æˆ»ã‚Šå€¤ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:849
msgid ""
"Option for :func:`create_default_context` and "
":meth:`SSLContext.load_default_certs`.  This value indicates that the "
"context may be used to authenticate Web servers (therefore, it will be used "
"to create client-side sockets)."
msgstr ":func:`create_default_context` ã¨ :meth:`SSLContext.load_default_certs` ã«æ¸¡ã™ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã™ã€‚ã“ã®å€¤ã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒ Web ã‚µãƒ¼ãƒã®èªè¨¼ã«ä½¿ã‚ã‚Œã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ (ã§ã™ã®ã§ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã®ã‚½ã‚±ãƒƒãƒˆã‚’ä½œã‚‹ã®ã«ä½¿ã†ã“ã¨ã«ãªã‚‹ã§ã—ã‚‡ã†)ã€‚"

#: ../../library/ssl.rst:858
msgid ""
"Option for :func:`create_default_context` and "
":meth:`SSLContext.load_default_certs`.  This value indicates that the "
"context may be used to authenticate Web clients (therefore, it will be used "
"to create server-side sockets)."
msgstr ":func:`create_default_context` ã¨ :meth:`SSLContext.load_default_certs` ã«æ¸¡ã™ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã™ã€‚ã“ã®å€¤ã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒ Web ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®èªè¨¼ã«ä½¿ã‚ã‚Œã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ (ã§ã™ã®ã§ã€ã‚µãƒ¼ãƒã‚µã‚¤ãƒ‰ã®ã‚½ã‚±ãƒƒãƒˆã‚’ä½œã‚‹ã®ã«ä½¿ã†ã“ã¨ã«ãªã‚‹ã§ã—ã‚‡ã†)ã€‚"

#: ../../library/ssl.rst:867
msgid "SSL Sockets"
msgstr "SSL ã‚½ã‚±ãƒƒãƒˆ"

#: ../../library/ssl.rst:869
msgid "SSL sockets provide the following methods of :ref:`socket-objects`:"
msgstr "SSL ã‚½ã‚±ãƒƒãƒˆã¯ :ref:`socket-objects` ã®ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã—ã¾ã™:"

#: ../../library/ssl.rst:871
msgid ":meth:`~socket.socket.accept()`"
msgstr ":meth:`~socket.socket.accept()`"

#: ../../library/ssl.rst:872
msgid ":meth:`~socket.socket.bind()`"
msgstr ":meth:`~socket.socket.bind()`"

#: ../../library/ssl.rst:873
msgid ":meth:`~socket.socket.close()`"
msgstr ":meth:`~socket.socket.close()`"

#: ../../library/ssl.rst:874
msgid ":meth:`~socket.socket.connect()`"
msgstr ":meth:`~socket.socket.connect()`"

#: ../../library/ssl.rst:875
msgid ":meth:`~socket.socket.fileno()`"
msgstr ":meth:`~socket.socket.fileno()`"

#: ../../library/ssl.rst:876
msgid ""
":meth:`~socket.socket.getpeername()`, :meth:`~socket.socket.getsockname()`"
msgstr ":meth:`~socket.socket.getpeername()`, :meth:`~socket.socket.getsockname()`"

#: ../../library/ssl.rst:877
msgid ""
":meth:`~socket.socket.getsockopt()`, :meth:`~socket.socket.setsockopt()`"
msgstr ":meth:`~socket.socket.getsockopt()`, :meth:`~socket.socket.setsockopt()`"

#: ../../library/ssl.rst:878
msgid ""
":meth:`~socket.socket.gettimeout()`, :meth:`~socket.socket.settimeout()`, "
":meth:`~socket.socket.setblocking()`"
msgstr ":meth:`~socket.socket.gettimeout()`, :meth:`~socket.socket.settimeout()`, :meth:`~socket.socket.setblocking()`"

#: ../../library/ssl.rst:880
msgid ":meth:`~socket.socket.listen()`"
msgstr ":meth:`~socket.socket.listen()`"

#: ../../library/ssl.rst:881
msgid ":meth:`~socket.socket.makefile()`"
msgstr ":meth:`~socket.socket.makefile()`"

#: ../../library/ssl.rst:882
msgid ""
":meth:`~socket.socket.recv()`, :meth:`~socket.socket.recv_into()` (but "
"passing a non-zero ``flags`` argument is not allowed)"
msgstr ":meth:`~socket.socket.recv()`, :meth:`~socket.socket.recv_into()` (éã‚¼ãƒ­ã® ``flags`` ã¯æ¸¡ã›ã¾ã›ã‚“)"

#: ../../library/ssl.rst:884
msgid ""
":meth:`~socket.socket.send()`, :meth:`~socket.socket.sendall()` (with the "
"same limitation)"
msgstr ":meth:`~socket.socket.send()`, :meth:`~socket.socket.sendall()` (éã‚¼ãƒ­ã® ``flags`` ã¯æ¸¡ã›ã¾ã›ã‚“)"

#: ../../library/ssl.rst:886
msgid ":meth:`~socket.socket.shutdown()`"
msgstr ":meth:`~socket.socket.shutdown()`"

#: ../../library/ssl.rst:888
msgid ""
"However, since the SSL (and TLS) protocol has its own framing atop of TCP, "
"the SSL sockets abstraction can, in certain respects, diverge from the "
"specification of normal, OS-level sockets.  See especially the :ref:`notes "
"on non-blocking sockets <ssl-nonblocking>`."
msgstr "SSL(ãŠã‚ˆã³TLS)ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯ TCP ã®ä¸Šã«ç‹¬è‡ªã®æ çµ„ã¿ã‚’æŒã£ã¦ã„ã‚‹ã®ã§ã€SSLã‚½ã‚±ãƒƒãƒˆã®æŠ½è±¡åŒ–ã¯ã€ã„ãã¤ã‹ã®ç‚¹ã§é€šå¸¸ã® OSãƒ¬ãƒ™ãƒ«ã®ã‚½ã‚±ãƒƒãƒˆã®ä»•æ§˜ã‹ã‚‰é€¸è„±ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ç‰¹ã« :ref:`ãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã‚½ã‚±ãƒƒãƒˆã«ã¤ã„ã¦ã®æ³¨é‡ˆ <ssl-nonblocking>` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:893
msgid "SSL sockets also have the following additional methods and attributes:"
msgstr "SSL ã‚½ã‚±ãƒƒãƒˆã«ã¯ã€ä»¥ä¸‹ã«ç¤ºã™è¿½åŠ ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨å±æ€§ã‚‚ã‚ã‚Šã¾ã™:"

#: ../../library/ssl.rst:897
msgid "Perform the SSL setup handshake."
msgstr "SSL ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã®ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:901
msgid ""
"The handshake method also performs :func:`match_hostname` when the "
":attr:`~SSLContext.check_hostname` attribute of the socket's "
":attr:`~SSLSocket.context` is true."
msgstr "ã‚½ã‚±ãƒƒãƒˆã® :attr:`~SSLSocket.context` ã®å±æ€§ :attr:`~SSLContext.check_hostname` ãŒçœŸã®å ´åˆã«ã€ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ãƒ¡ã‚½ãƒƒãƒ‰ãŒ :func:`match_hostname` ã‚’å®Ÿè¡Œã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:907
msgid ""
"If there is no certificate for the peer on the other end of the connection, "
"return ``None``.  If the SSL handshake hasn't been done yet, raise "
":exc:`ValueError`."
msgstr "æ¥ç¶šå…ˆã«è¨¼æ˜æ›¸ãŒç„¡ã„å ´åˆã€ ``None`` ã‚’è¿”ã—ã¾ã™ã€‚SSL ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ãŒã¾ã è¡Œã‚ã‚Œã¦ã„ãªã„å ´åˆã¯ã€ :exc:`ValueError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:911
msgid ""
"If the ``binary_form`` parameter is :const:`False`, and a certificate was "
"received from the peer, this method returns a :class:`dict` instance.  If "
"the certificate was not validated, the dict is empty.  If the certificate "
"was validated, it returns a dict with several keys, amongst them ``subject``"
" (the principal for which the certificate was issued) and ``issuer`` (the "
"principal issuing the certificate).  If a certificate contains an instance "
"of the *Subject Alternative Name* extension (see :rfc:`3280`), there will "
"also be a ``subjectAltName`` key in the dictionary."
msgstr "``binary_form`` ãŒ :const:`False` ã§æ¥ç¶šå…ˆã‹ã‚‰è¨¼æ˜æ›¸ã‚’å–å¾—ã—ãŸå ´åˆã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :class:`dict` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚è¨¼æ˜æ›¸ãŒèªè¨¼ã•ã‚Œã¦ã„ãªã„å ´åˆã€è¾æ›¸ã¯ç©ºã§ã™ã€‚è¨¼æ˜æ›¸ãŒèªè¨¼ã•ã‚Œã¦ã„ãŸå ´åˆã„ãã¤ã‹ã®ã‚­ãƒ¼ã‚’æŒã£ãŸè¾æ›¸ã‚’è¿”ã—ã€ ``subject`` (è¨¼æ˜æ›¸ãŒç™ºè¡Œã•ã‚ŒãŸ principal), ``issuer`` (è¨¼æ˜æ›¸ã‚’ç™ºè¡Œã—ãŸ principal) ã‚’å«ã¿ã¾ã™ã€‚è¨¼æ˜æ›¸ãŒ *Subject Alternative Name* æ‹¡å¼µ(:rfc:`3280` ã‚’å‚ç…§)ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ ¼ç´ã—ã¦ã„ãŸå ´åˆã€ ``subjectAltName`` ã‚­ãƒ¼ã‚‚è¾æ›¸ã«å«ã¾ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:920
msgid ""
"The ``subject`` and ``issuer`` fields are tuples containing the sequence of "
"relative distinguished names (RDNs) given in the certificate's data "
"structure for the respective fields, and each RDN is a sequence of name-"
"value pairs.  Here is a real-world example::"
msgstr "``subject``, ``issuer`` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ã€è¨¼æ˜æ›¸ã®ãã‚Œãã‚Œã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã¤ã„ã¦ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ä¸ãˆã‚‰ã‚Œã‚‹ RDN (relative distinguishued name) ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’æ ¼ç´ã—ãŸã‚¿ãƒ—ãƒ«ã§ã€å„ RDN ã¯ name-value ãƒšã‚¢ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã™ã€‚ç¾å®Ÿä¸–ç•Œã§ã®ä¾‹ã‚’ãŠè¦‹ã›ã—ã¾ã™::"

#: ../../library/ssl.rst:946
msgid ""
"To validate a certificate for a particular service, you can use the "
":func:`match_hostname` function."
msgstr "ç‰¹å®šã®ã‚µãƒ¼ãƒ“ã‚¹ã®ãŸã‚ã«è¨¼æ˜æ›¸ã®æ¤œè¨¼ãŒã—ãŸã‘ã‚Œã°ã€ :func:`match_hostname` é–¢æ•°ã‚’ä½¿ã†ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚"

#: ../../library/ssl.rst:949
msgid ""
"If the ``binary_form`` parameter is :const:`True`, and a certificate was "
"provided, this method returns the DER-encoded form of the entire certificate"
" as a sequence of bytes, or :const:`None` if the peer did not provide a "
"certificate.  Whether the peer provides a certificate depends on the SSL "
"socket's role:"
msgstr "``binary_form`` å¼•æ•°ãŒ :const:`True` ã ã£ãŸå ´åˆã€è¨¼æ˜æ›¸ãŒæ¸¡ã•ã‚Œã¦ã„ã‚Œã°ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯DERã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸè¨¼æ˜æ›¸å…¨ä½“ã‚’ãƒã‚¤ãƒˆåˆ—ã¨ã—ã¦è¿”ã—ã€æ¥ç¶šå…ˆãŒè¨¼æ˜æ›¸ã‚’æç¤ºã—ãªã‹ã£ãŸå ´åˆã¯ :const:`None` ã‚’è¿”ã—ã¾ã™ã€‚æ¥ç¶šå…ˆãŒè¨¼æ˜æ›¸ã‚’æä¾›ã™ã‚‹ã‹ã©ã†ã‹ã¯ SSL ã‚½ã‚±ãƒƒãƒˆã®å½¹å‰²ã«ä¾å­˜ã—ã¾ã™:"

#: ../../library/ssl.rst:955
msgid ""
"for a client SSL socket, the server will always provide a certificate, "
"regardless of whether validation was required;"
msgstr "ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã‚½ã‚±ãƒƒãƒˆã§ã¯ã€èªè¨¼ãŒè¦æ±‚ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã«é–¢ã‚ã‚‰ãšã€ã‚µãƒ¼ãƒã¯å¸¸ã«è¨¼æ˜æ›¸ã‚’æä¾›ã—ã¾ã™;"

#: ../../library/ssl.rst:958
msgid ""
"for a server SSL socket, the client will only provide a certificate when "
"requested by the server; therefore :meth:`getpeercert` will return "
":const:`None` if you used :const:`CERT_NONE` (rather than "
":const:`CERT_OPTIONAL` or :const:`CERT_REQUIRED`)."
msgstr "ã‚µãƒ¼ãƒå´ã‚½ã‚±ãƒƒãƒˆã§ã¯ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ã‚µãƒ¼ãƒã«ã‚ˆã£ã¦èªè¨¼ãŒè¦æ±‚ã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã®ã¿è¨¼æ˜æ›¸ã‚’æä¾›ã—ã¾ã™; ã§ã™ã®ã§ã€ (:const:`CERT_OPTIONAL` ã‚„ :const:`CERT_REQUIRED` ã§ã¯ãªã) :const:`CERT_NONE` ã‚’ä½¿ã†ã¨ :meth:`getpeercert` ã¯ :const:`None` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:963
msgid ""
"The returned dictionary includes additional items such as ``issuer`` and "
"``notBefore``. Additionall :exc:`ValueError` is raised when the handshake "
"isn't done. The returned dictionary includes additional X509v3 extension "
"items such as ``crlDistributionPoints``, ``caIssuers`` and ``OCSP`` URIs."
msgstr "è¿”ã•ã‚Œã‚‹è¾æ›¸ã« ``issuer``, ``notBefore`` ã®ã‚ˆã†ãªè¿½åŠ ã‚¢ã‚¤ãƒ†ãƒ ã‚’å«ã‚€ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚åŠ ãˆã¦ã€ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ãŒæ¸ˆã‚“ã§ã„ãªã‘ã‚Œã° :exc:`ValueError` ã‚’æŠ•ã’ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚è¿”ã•ã‚Œã‚‹è¾æ›¸ã« ``crlDistributionPoints``, ``caIssuers``, ``OCSP`` URI ã®ã‚ˆã†ãª X509v3 æ‹¡å¼µã‚¢ã‚¤ãƒ†ãƒ ã‚’å«ã‚€ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:971
msgid ""
"Returns a three-value tuple containing the name of the cipher being used, "
"the version of the SSL protocol that defines its use, and the number of "
"secret bits being used.  If no connection has been established, returns "
"``None``."
msgstr "åˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹æš—å·ã®åå‰ã€ãã®æš—å·ã®åˆ©ç”¨ã‚’å®šç¾©ã—ã¦ã„ã‚‹SSLãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã€åˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹éµã®bité•·ã®3ã¤ã®å€¤ã‚’å«ã‚€ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚ã‚‚ã—æ¥ç¶šãŒç¢ºç«‹ã•ã‚Œã¦ã„ãªã„å ´åˆã€ ``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:977
msgid ""
"Return the compression algorithm being used as a string, or ``None`` if the "
"connection isn't compressed."
msgstr "ä½¿ã‚ã‚Œã¦ã„ã‚‹åœ§ç¸®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’æ–‡å­—åˆ—ã§è¿”ã—ã¾ã™ã€‚æ¥ç¶šãŒåœ§ç¸®ã•ã‚Œã¦ã„ãªã‘ã‚Œã° ``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:980
msgid ""
"If the higher-level protocol supports its own compression mechanism, you can"
" use :data:`OP_NO_COMPRESSION` to disable SSL-level compression."
msgstr "ä¸Šä½ãƒ¬ãƒ™ãƒ«ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãŒè‡ªèº«ã§åœ§ç¸®ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å ´åˆã€SSL ãƒ¬ãƒ™ãƒ«ã§ã®åœ§ç¸®ã‚’ :data:`OP_NO_COMPRESSION` ã‚’ä½¿ã£ã¦ç„¡åŠ¹ã«å‡ºæ¥ã¾ã™ã€‚"

#: ../../library/ssl.rst:987
msgid ""
"Get channel binding data for current connection, as a bytes object.  Returns"
" ``None`` if not connected or the handshake has not been completed."
msgstr "ç¾åœ¨ã®æ¥ç¶šã«ãŠã‘ã‚‹ãƒãƒ£ãƒãƒ«ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¾ã™ã€‚æœªæ¥ç¶šã‚ã‚‹ã„ã¯ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ãŒå®Œäº†ã—ã¦ã„ãªã‘ã‚Œã° ``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:990
msgid ""
"The *cb_type* parameter allow selection of the desired channel binding type."
" Valid channel binding types are listed in the :data:`CHANNEL_BINDING_TYPES`"
" list.  Currently only the 'tls-unique' channel binding, defined by "
":rfc:`5929`, is supported.  :exc:`ValueError` will be raised if an "
"unsupported channel binding type is requested."
msgstr "*cb_type* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«ã‚ˆã‚Šã€æœ›ã¿ã®ãƒãƒ£ãƒãƒ«ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã®ã‚¿ã‚¤ãƒ—ã‚’é¸æŠå‡ºæ¥ã¾ã™ã€‚ãƒãƒ£ãƒãƒ«ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã®ã‚¿ã‚¤ãƒ—ã®å¦¥å½“ãªã‚‚ã®ã¯ :data:`CHANNEL_BINDING_TYPES` ã§ãƒªã‚¹ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚ç¾åœ¨ã®ã¨ã“ã‚ã¯ :rfc:`5929` ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ 'tls-unique' ã®ã¿ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚æœªã‚µãƒãƒ¼ãƒˆã®ãƒãƒ£ãƒãƒ«ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã®ã‚¿ã‚¤ãƒ—ãŒè¦æ±‚ã•ã‚ŒãŸå ´åˆã€ :exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1000
msgid ""
"Return the protocol that was selected during the TLS handshake.  If "
":meth:`SSLContext.set_alpn_protocols` was not called, if the other party "
"does not support ALPN, if this socket does not support any of the client's "
"proposed protocols, or if the handshake has not happened yet, ``None`` is "
"returned."
msgstr "TLS ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã§é¸æŠã•ã‚ŒãŸãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚ :meth:`SSLContext.set_alpn_protocols` ãŒå‘¼ã°ã‚Œã¦ã„ãªã„å ´åˆã€ç›¸æ‰‹å´ãŒ ALPN ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„å ´åˆã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒææ¡ˆã—ãŸãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ã©ã‚Œã‚‚ã‚½ã‚±ãƒƒãƒˆãŒã‚µãƒãƒ¼ãƒˆã—ãªã„å ´åˆã€ã‚ã‚‹ã„ã¯ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ãŒã¾ã è¡Œã‚ã‚Œã¦ã„ãªã„å ´åˆã«ã¯ã€ ``None`` ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:1010
msgid ""
"Return the higher-level protocol that was selected during the TLS/SSL "
"handshake. If :meth:`SSLContext.set_npn_protocols` was not called, or if the"
" other party does not support NPN, or if the handshake has not yet happened,"
" this will return ``None``."
msgstr "TLS/SSL ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã§é¸æŠã•ã‚ŒãŸä¸Šä½ãƒ¬ãƒ™ãƒ«ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚ :meth:`SSLContext.set_npn_protocols` ãŒå‘¼ã°ã‚Œã¦ã„ãªã„å ´åˆã€ç›¸æ‰‹å´ãŒ NPN ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„å ´åˆã€ã‚ã‚‹ã„ã¯ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ãŒã¾ã è¡Œã‚ã‚Œã¦ã„ãªã„å ´åˆã«ã¯ã€ ``None`` ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:1019
msgid ""
"Performs the SSL shutdown handshake, which removes the TLS layer from the "
"underlying socket, and returns the underlying socket object.  This can be "
"used to go from encrypted operation over a connection to unencrypted.  The "
"returned socket should always be used for further communication with the "
"other side of the connection, rather than the original socket."
msgstr "SSLã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚ã“ã‚Œã¯ä¸‹ä½ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚½ã‚±ãƒƒãƒˆã‹ã‚‰TLSãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å–ã‚Šé™¤ãã€ä¸‹ä½ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯æš—å·åŒ–ã•ã‚ŒãŸã‚ªãƒšãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‹ã‚‰æš—å·åŒ–ã•ã‚Œã¦ã„ãªã„æ¥ç¶šã«ç§»è¡Œã™ã‚‹ã¨ãã«åˆ©ç”¨ã•ã‚Œã¾ã™ã€‚ä»¥é™ã®é€šä¿¡ã«ã¯ã€ã‚ªãƒªã‚¸ãƒŠãƒ«ã®ã‚½ã‚±ãƒƒãƒˆã§ã¯ãªãã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¿”ã—ãŸã‚½ã‚±ãƒƒãƒˆã®ã¿ã‚’åˆ©ç”¨ã™ã‚‹ã¹ãã§ã™ã€‚"

#: ../../library/ssl.rst:1027
msgid ""
"Return the actual SSL protocol version negotiated by the connection as a "
"string, or ``None`` is no secure connection is established. As of this "
"writing, possible return values include ``\"SSLv2\"``, ``\"SSLv3\"``, "
"``\"TLSv1\"``, ``\"TLSv1.1\"`` and ``\"TLSv1.2\"``. Recent OpenSSL versions "
"may define more return values."
msgstr "ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã«ã‚ˆã£ã¦å®Ÿéš›ã«ãƒã‚´ã‚·ã‚¨ã‚¤ãƒˆã•ã‚ŒãŸ SSL ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’æ–‡å­—åˆ—ã§ã€ã¾ãŸã¯ã€ã‚»ã‚­ãƒ¥ã‚¢ãªã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãŒç¢ºç«‹ã—ã¦ã„ãªã‘ã‚Œã° ``None`` ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã‚’æ›¸ã„ã¦ã„ã‚‹æ™‚ç‚¹ã§ã¯ã€ ``\"SSLv2\"``, ``\"SSLv3\"``, ``\"TLSv1\"``, ``\"TLSv1.1\"``, ``\"TLSv1.2\"`` ãªã©ãŒè¿”ã‚Šã¾ã™ã€‚æœ€æ–°ã® OpenSSL ã¯ã‚‚ã£ã¨è‰²ã€…ãªå€¤ã‚’å®šç¾©ã—ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:1037
msgid ""
"The :class:`SSLContext` object this SSL socket is tied to.  If the SSL "
"socket was created using the top-level :func:`wrap_socket` function (rather "
"than :meth:`SSLContext.wrap_socket`), this is a custom context object "
"created for this SSL socket."
msgstr "ã“ã® SSL ã‚½ã‚±ãƒƒãƒˆã«çµã³ä»˜ã‘ã‚‰ã‚ŒãŸ :class:`SSLContext` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚SSL ã‚½ã‚±ãƒƒãƒˆãŒ (:meth:`SSLContext.wrap_socket` ã§ã¯ãªã)ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã® :func:`wrap_socket` é–¢æ•°ã‚’ä½¿ã£ã¦ä½œã‚‰ã‚ŒãŸå ´åˆã€ã“ã‚Œã¯ã“ã® SSL ã‚½ã‚±ãƒƒãƒˆã®ãŸã‚ã«ä½œã‚‰ã‚ŒãŸã‚«ã‚¹ã‚¿ãƒ ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚"

#: ../../library/ssl.rst:1046
msgid "SSL Contexts"
msgstr "SSL ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ"

#: ../../library/ssl.rst:1050
msgid ""
"An SSL context holds various data longer-lived than single SSL connections, "
"such as SSL configuration options, certificate(s) and private key(s). It "
"also manages a cache of SSL sessions for server-side sockets, in order to "
"speed up repeated connections from the same clients."
msgstr "SSL ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¯ã€SSL æ§‹æˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ã€è¨¼æ˜æ›¸(ç¾¤)ã‚„ç§˜å¯†éµ(ç¾¤)ãªã©ã®ã‚ˆã†ãªã€ä¸€å›ã® SSL æ¥ç¶šã‚ˆã‚Šã‚‚é•·ç”Ÿãã™ã‚‹ã•ã¾ã–ã¾ãªãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒã—ã¾ã™ã€‚ã“ã‚Œã¯ã‚µãƒ¼ãƒã‚µã‚¤ãƒ‰ã‚½ã‚±ãƒƒãƒˆã® SSL ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚‚ç®¡ç†ã—ã€åŒã˜ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã®ç¹°ã‚Šè¿”ã—ã®æ¥ç¶šæ™‚ã®é€Ÿåº¦å‘ä¸Šã«ä¸€å½¹è²·ã„ã¾ã™ã€‚"

#: ../../library/ssl.rst:1057
msgid ""
"Create a new SSL context.  You must pass *protocol* which must be one of the"
" ``PROTOCOL_*`` constants defined in this module. :data:`PROTOCOL_SSLv23` is"
" currently recommended for maximum interoperability."
msgstr "æ–°ã—ã„ SSL ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œæˆã—ã¾ã™ã€‚ *protocol* ã«ã¯ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ ``PROTOCOL_*`` å®šæ•°ã®ã†ã¡ä¸€ã¤ã‚’æŒ‡å®šã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚æœ€å¤§é™ã®äº’æ›æ€§ã®ãŸã‚ã«ã¯ã€ç¾æ™‚ç‚¹ã§ã®æ¨å¥¨ã¯ :data:`PROTOCOL_SSLv23` ã§ã™ã€‚"

#: ../../library/ssl.rst:1063
msgid ""
":func:`create_default_context` lets the :mod:`ssl` module choose security "
"settings for a given purpose."
msgstr ":func:`create_default_context` ã¯ :mod:`ssl` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã€ç›®çš„ã«åˆã£ãŸã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®šã‚’é¸ã°ã›ã¾ã™ã€‚"

#: ../../library/ssl.rst:1067
msgid ":class:`SSLContext` objects have the following methods and attributes:"
msgstr ":class:`SSLContext` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨å±æ€§ã‚’æŒã£ã¦ã„ã¾ã™:"

#: ../../library/ssl.rst:1071
msgid ""
"Get statistics about quantities of loaded X.509 certificates, count of X.509"
" certificates flagged as CA certificates and certificate revocation lists as"
" dictionary."
msgstr "ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸ X.509 è¨¼æ˜æ›¸ã®æ•°ã€CA è¨¼æ˜æ›¸ã§æ´»æ€§ã® X.509 è¨¼æ˜æ›¸ã®æ•°ã€è¨¼æ˜æ›¸å¤±åŠ¹ãƒªã‚¹ãƒˆã®æ•°ã€ã«ã¤ã„ã¦ã®çµ±è¨ˆæƒ…å ±ã‚’è¾æ›¸ã¨ã—ã¦å–å¾—ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1075
msgid "Example for a context with one CA cert and one other cert::"
msgstr "ä¸€ã¤ã® CA ã¨ä»–ã®ä¸€ã¤ã®è¨¼æ˜æ›¸ã‚’æŒã£ãŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ã®ä¾‹ã§ã™::"

#: ../../library/ssl.rst:1083
msgid ""
"Load a private key and the corresponding certificate.  The *certfile* string"
" must be the path to a single file in PEM format containing the certificate "
"as well as any number of CA certificates needed to establish the "
"certificate's authenticity.  The *keyfile* string, if present, must point to"
" a file containing the private key in.  Otherwise the private key will be "
"taken from *certfile* as well.  See the discussion of :ref:`ssl-"
"certificates` for more information on how the certificate is stored in the "
"*certfile*."
msgstr "ç§˜å¯†éµã¨å¯¾å¿œã™ã‚‹è¨¼æ˜æ›¸ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚ *certfile* ã¯ã€è¨¼æ˜æ›¸ã¨ã€è¨¼æ˜æ›¸èªè¨¼ã§å¿…è¦ã¨ã•ã‚Œã‚‹ä»»æ„ã®æ•°ã® CA è¨¼æ˜æ›¸ã‚’å«ã‚€ã€PEM ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ *keyfile* ã‚’æŒ‡å®šã™ã‚‹å ´åˆã¯ã€ç§˜å¯†éµãŒå«ã¾ã‚Œã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ‡ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãã†ã§ãªã‘ã‚Œã°ç§˜å¯†éµã‚‚ *certfile* ã‹ã‚‰å–ã‚‰ã‚Œã¾ã™ã€‚ *certfile* ã«è¨¼æ˜æ›¸ã‚’ã©ã®ã‚ˆã†ã«æ ¼ç´ã™ã‚Œã°è‰¯ã„ã‹ã«ã¤ã„ã¦ã®è©³ã—ã„æƒ…å ±ã¯ã€ :ref:`ssl-certificates` ã®è­°è«–ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:1092
msgid ""
"The *password* argument may be a function to call to get the password for "
"decrypting the private key.  It will only be called if the private key is "
"encrypted and a password is necessary.  It will be called with no arguments,"
" and it should return a string, bytes, or bytearray.  If the return value is"
" a string it will be encoded as UTF-8 before using it to decrypt the key. "
"Alternatively a string, bytes, or bytearray value may be supplied directly "
"as the *password* argument.  It will be ignored if the private key is not "
"encrypted and no password is needed."
msgstr "*password* å¼•æ•°ã«ã€ç§˜å¯†éµã‚’å¾©å·ã™ã‚‹ãŸã‚ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’è¿”ã™é–¢æ•°ã‚’ä¸ãˆã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚ãã®é–¢æ•°ã¯ç§˜å¯†éµãŒæš—å·åŒ–ã•ã‚Œã¦ã„ã¦ã€ãªãŠã‹ã¤ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒå¿…è¦ãªå ´åˆã«ã®ã¿å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ãã®é–¢æ•°ã¯å¼•æ•°ãªã—ã§å‘¼ã³å‡ºã•ã‚Œã€string, bytes, ã¾ãŸã¯ bytearray ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚æˆ»ã‚Šå€¤ãŒ string ã®å ´åˆã¯éµã‚’å¾©å·åŒ–ã™ã‚‹ã®ã«ä½¿ã†å‰ã« UTF-8 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚Œã¾ã™ã€‚string ã®ä»£ã‚ã‚Šã« bytes ã‚„ bytearray ã‚’è¿”ã—ãŸå ´åˆã¯ *password* å¼•æ•°ã«ç›´æ¥ä¾›çµ¦ã•ã‚Œã¾ã™ã€‚ç§˜å¯†éµãŒæš—å·åŒ–ã•ã‚Œã¦ã„ãªã‹ã£ãŸã‚Šãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å¿…è¦ã¨ã—ãªã„å ´åˆã¯ã€æŒ‡å®šã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:1101
msgid ""
"If the *password* argument is not specified and a password is required, "
"OpenSSL's built-in password prompting mechanism will be used to "
"interactively prompt the user for a password."
msgstr "*password* ãŒä¸ãˆã‚‰ã‚Œãšã€ãã—ã¦ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒå¿…è¦ãªå ´åˆã«ã¯ã€OpenSSL çµ„ã¿è¾¼ã¿ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å•ã„åˆã‚ã›ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ãŒã€ãƒ¦ãƒ¼ã‚¶ã«å¯¾è©±çš„ã«ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å•ã„åˆã‚ã›ã¾ã™ã€‚"

#: ../../library/ssl.rst:1105
msgid ""
"An :class:`SSLError` is raised if the private key doesn't match with the "
"certificate."
msgstr "ç§˜å¯†éµãŒè¨¼æ˜æ›¸ã«åˆè‡´ã—ãªã‘ã‚Œã°ã€ :class:`SSLError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:1110
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from "
"default locations. On Windows it loads CA certs from the ``CA`` and ``ROOT``"
" system stores. On other systems it calls "
":meth:`SSLContext.set_default_verify_paths`. In the future the method may "
"load CA certificates from other locations, too."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å ´æ‰€ã‹ã‚‰ \"èªè¨¼å±€\" (CA=certification authority) è¨¼æ˜æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ä¸€å¼ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚Windows ã§ã¯ã€CA è¨¼æ˜æ›¸ã¯ã‚·ã‚¹ãƒ†ãƒ è¨˜æ†¶åŸŸã® ``CA`` ã¨ ``ROOT`` ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚ãã‚Œä»¥å¤–ã®ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€ã“ã®é–¢æ•°ã¯ :meth:`SSLContext.set_default_verify_paths` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚å°†æ¥çš„ã«ã¯ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ä»–ã®å ´æ‰€ã‹ã‚‰ã‚‚ CA è¨¼æ˜æ›¸ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:1116
msgid ""
"The *purpose* flag specifies what kind of CA certificates are loaded. The "
"default settings :data:`Purpose.SERVER_AUTH` loads certificates, that are "
"flagged and trusted for TLS web server authentication (client side sockets)."
" :data:`Purpose.CLIENT_AUTH` loads CA certificates for client certificate "
"verification on the server side."
msgstr "*purpose* ãƒ•ãƒ©ã‚°ã§ã©ã®ç¨®é¡ã® CA è¨¼æ˜æ›¸ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã‹ã‚’æŒ‡å®šã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® :data:`Purpose.SERVER_AUTH` ã¯ TLS web ã‚µãƒ¼ãƒã®èªè¨¼ã®ãŸã‚ã«æ´»æ€§ã‹ã¤ä¿¡é ¼ã•ã‚ŒãŸè¨¼æ˜æ›¸ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™(ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã®ã‚½ã‚±ãƒƒãƒˆ)ã€‚ :data:`Purpose.CLIENT_AUTH` ã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆè¨¼æ˜æ›¸ã®æ­£å½“æ€§æ¤œè¨¼ã‚’ã‚µãƒ¼ãƒã‚µã‚¤ãƒ‰ã§è¡Œã†ãŸã‚ã® CA è¨¼æ˜æ›¸ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1124
msgid ""
"Load a set of \"certification authority\" (CA) certificates used to validate"
" other peers' certificates when :data:`verify_mode` is other than "
":data:`CERT_NONE`.  At least one of *cafile* or *capath* must be specified."
msgstr ":data:`verify_mode` ãŒ :data:`CERT_NONE` ã§ãªã„å ´åˆã«æ¥ç¶šå…ˆã®è¨¼æ˜æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ã®æ­£å½“æ€§æ¤œè¨¼ã«ä½¿ã‚ã‚Œã‚‹ \"èªè¨¼å±€\" (CA=certification authority) è¨¼æ˜æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ä¸€å¼ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚å°‘ãªãã¨ã‚‚ *cafile* ã‹ *capath* ã®ã©ã¡ã‚‰ã‹ã¯æŒ‡å®šã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:1128
msgid ""
"This method can also load certification revocation lists (CRLs) in PEM or "
"DER format. In order to make use of CRLs, :attr:`SSLContext.verify_flags` "
"must be configured properly."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ PEM ã¾ãŸã¯ DER ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®è¨¼æ˜æ›¸å¤±åŠ¹ãƒªã‚¹ãƒˆ (CRLs=certification revocation lists)ã‚‚ãƒ­ãƒ¼ãƒ‰å‡ºæ¥ã¾ã™ã€‚CRLs ã®ãŸã‚ã«ä½¿ã†ã«ã¯ã€ :attr:`SSLContext.verify_flags` ã‚’é©åˆ‡ã«è¨­å®šã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:1132
msgid ""
"The *cafile* string, if present, is the path to a file of concatenated CA "
"certificates in PEM format. See the discussion of :ref:`ssl-certificates` "
"for more information about how to arrange the certificates in this file."
msgstr "*cafile* ã‚’æŒ‡å®šã™ã‚‹å ´åˆã¯ã€PEM ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§ CA è¨¼æ˜æ›¸ãŒçµåˆã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«å†…ã§è¨¼æ˜æ›¸ã‚’ã©ã®ã‚ˆã†ã«ç·¨æˆã™ã‚Œã°è‰¯ã„ã®ã‹ã«ã¤ã„ã¦ã®è©³ã—ã„æƒ…å ±ã«ã¤ã„ã¦ã¯ã€ :ref:`ssl-certificates` ã®è­°è«–ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:1137
msgid ""
"The *capath* string, if present, is the path to a directory containing "
"several CA certificates in PEM format, following an `OpenSSL specific layout"
" "
"<https://www.openssl.org/docs/man1.1.0/ssl/SSL_CTX_load_verify_locations.html>`_."
msgstr ""

#: ../../library/ssl.rst:1142
msgid ""
"The *cadata* object, if present, is either an ASCII string of one or more "
"PEM-encoded certificates or a bytes-like object of DER-encoded certificates."
" Like with *capath* extra lines around PEM-encoded certificates are ignored "
"but at least one certificate must be present."
msgstr "*cadata* ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡å®šã™ã‚‹å ´åˆã¯ã€PEM ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã®è¨¼æ˜æ›¸ä¸€ã¤ä»¥ä¸Šã® ASCII æ–‡å­—åˆ—ã‹ã€DER ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã®è¨¼æ˜æ›¸ã®ãƒã‚¤ãƒˆãƒ©ã‚¤ã‚¯ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã©ã¡ã‚‰ã‹ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚PEM ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã®è¨¼æ˜æ›¸ã®å‘¨å›²ã®ä½™åˆ†ãªè¡Œã¯ç„¡è¦–ã•ã‚Œã¾ã™ãŒã€å°‘ãªãã¨ã‚‚ä¸€ã¤ã®è¨¼æ˜æ›¸ãŒå«ã¾ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/ssl.rst:1149
msgid ""
"Get a list of loaded \"certification authority\" (CA) certificates. If the "
"``binary_form`` parameter is :const:`False` each list entry is a dict like "
"the output of :meth:`SSLSocket.getpeercert`. Otherwise the method returns a "
"list of DER-encoded certificates. The returned list does not contain "
"certificates from *capath* unless a certificate was requested and loaded by "
"a SSL connection."
msgstr "ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸ \"èªè¨¼å±€\" (CA=certification authority) è¨¼æ˜æ›¸ã®ãƒªã‚¹ãƒˆã‚’å–å¾—ã—ã¾ã™ã€‚ ``binary_form`` ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒ :const:`False` ã§ã‚ã‚Œã°ã€ãƒªã‚¹ãƒˆã®ãã‚Œãã‚Œã®ã‚¨ãƒ³ãƒˆãƒªã¯ :meth:`SSLSocket.getpeercert` ãŒå‡ºåŠ›ã™ã‚‹ã‚ˆã†ãªè¾æ›¸ã«ãªã‚Šã¾ã™ã€‚ãã†ã§ãªã„å ´åˆã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€DER ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰å½¢å¼ã®è¨¼æ˜æ›¸ã®ãƒªã‚¹ãƒˆã§è¿”ã—ã¾ã™ã€‚è¿”å´ã•ã‚Œã‚‹ãƒªã‚¹ãƒˆã«ã¯ã€ SSL æ¥ç¶šã«ã‚ˆã£ã¦è¦æ±‚ã•ã‚Œã¦ãƒ­ãƒ¼ãƒ‰ã•ã‚Œãªã„é™ã‚Šã¯ *capath* ã‹ã‚‰ã®è¨¼æ˜æ›¸ã¯å«ã¿ã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:1157
msgid ""
"Certificates in a capath directory aren't loaded unless they have been used "
"at least once."
msgstr "capath ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã®è¨¼æ˜æ›¸ã¯ä¸€åº¦ã§ã‚‚ä½¿ã‚ã‚Œãªã„é™ã‚Šã¯ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:1162
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from a "
"filesystem path defined when building the OpenSSL library.  Unfortunately, "
"there's no easy way to know whether this method succeeds: no error is "
"returned if no certificates are to be found.  When the OpenSSL library is "
"provided as part of the operating system, though, it is likely to be "
"configured properly."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® \"èªè¨¼å±€\" (CA=certification authority) è¨¼æ˜æ›¸ã‚’ã€OpenSSL ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒãƒ“ãƒ«ãƒ‰ã•ã‚ŒãŸéš›ã«å®šç¾©ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ä¸Šã®ãƒ‘ã‚¹ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚æ®‹å¿µãªãŒã‚‰ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒæˆåŠŸã—ãŸã‹ã©ã†ã‹ã‚’çŸ¥ã‚‹ãŸã‚ã®ç°¡å˜ãªæ–¹æ³•ã¯ã‚ã‚Šã¾ã›ã‚“: è¨¼æ˜æ›¸ãŒè¦‹ã¤ã‹ã‚‰ãªãã¦ã‚‚ã‚¨ãƒ©ãƒ¼ã¯è¿”ã‚Šã¾ã›ã‚“ã€‚OpenSSL ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã®ä¸€éƒ¨ã¨ã—ã¦æä¾›ã•ã‚Œã¦ã„ã‚‹éš›ã«ã¯ã©ã†ã‚„ã‚‰é©åˆ‡ã«æ§‹æˆã§ãã‚‹ã‚ˆã†ã§ã™ãŒã€‚"

#: ../../library/ssl.rst:1171
msgid ""
"Set the available ciphers for sockets created with this context. It should "
"be a string in the `OpenSSL cipher list format "
"<https://www.openssl.org/docs/manmaster/man1/ciphers.html>`_. If no cipher "
"can be selected (because compile-time options or other configuration forbids"
" use of all the specified ciphers), an :class:`SSLError` will be raised."
msgstr ""

#: ../../library/ssl.rst:1179
msgid ""
"when connected, the :meth:`SSLSocket.cipher` method of SSL sockets will give"
" the currently selected cipher."
msgstr "æ¥ç¶šæ™‚ã« SSL ã‚½ã‚±ãƒƒãƒˆã® :meth:`SSLSocket.cipher` ãƒ¡ã‚½ãƒƒãƒ‰ãŒã€ç¾åœ¨é¸æŠã•ã‚Œã¦ã„ã‚‹ãã®æš—å·ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../library/ssl.rst:1184
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of ASCII strings, like ``['http/1.1', "
"'spdy/2']``, ordered by preference. The selection of a protocol will happen "
"during the handshake, and will play out according to :rfc:`7301`. After a "
"successful handshake, the :meth:`SSLSocket.selected_alpn_protocol` method "
"will return the agreed-upon protocol."
msgstr "SSL/TLS ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯æ™‚ã«ã‚½ã‚±ãƒƒãƒˆãŒæç¤ºã™ã¹ããƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’æŒ‡å®šã—ã¾ã™ã€‚ ``['http/1.1', 'spdy/2']`` ã®ã‚ˆã†ãªæ¨å¥¨é †ã«ä¸¦ã¹ãŸ ASII æ–‡å­—åˆ—ã®ãƒªã‚¹ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®é¸æŠã¯ :rfc:`7301` ã«å¾“ã„ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã®ä¸­ã§è¡Œã‚ã‚Œã¾ã™ã€‚ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ãŒæ­£å¸¸ã«çµ‚äº†å¾Œã€ :meth:`SSLSocket.selected_alpn_protocol` ãƒ¡ã‚½ãƒƒãƒ‰ã¯åˆæ„ã•ã‚ŒãŸãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1191
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_ALPN` is "
"False."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :data:`HAS_ALPN` ãŒå½ã®å ´åˆ :exc:`NotImplementedError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1194
msgid ""
"OpenSSL 1.1.0 to 1.1.0e will abort the handshake and raise :exc:`SSLError` "
"when both sides support ALPN but cannot agree on a protocol. 1.1.0f+ behaves"
" like 1.0.2, :meth:`SSLSocket.selected_alpn_protocol` returns None."
msgstr ""

#: ../../library/ssl.rst:1202
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of strings, like ``['http/1.1', 'spdy/2']``, "
"ordered by preference. The selection of a protocol will happen during the "
"handshake, and will play out according to the `NPN draft specification "
"<https://tools.ietf.org/html/draft-agl-tls-nextprotoneg>`_. After a "
"successful handshake, the :meth:`SSLSocket.selected_npn_protocol` method "
"will return the agreed-upon protocol."
msgstr "SSL/TLS ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯æ™‚ã«ã‚½ã‚±ãƒƒãƒˆãŒæç¤ºã™ã¹ããƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’æŒ‡å®šã—ã¾ã™ã€‚ ``['http/1.1', 'spdy/2']`` ã®ã‚ˆã†ãªæ¨å¥¨é †ã«ä¸¦ã¹ãŸæ–‡å­—åˆ—ã®ãƒªã‚¹ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®é¸æŠã¯ `NPN draft specification <https://tools.ietf.org/html/draft-agl-tls-nextprotoneg>`_ ã«å¾“ã„ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã®ä¸­ã§è¡Œã‚ã‚Œã¾ã™ã€‚ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ãŒæ­£å¸¸ã«çµ‚äº†å¾Œã€ :meth:`SSLSocket.selected_alpn_protocol` ãƒ¡ã‚½ãƒƒãƒ‰ã¯åˆæ„ã•ã‚ŒãŸãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1210
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_NPN` is "
"False."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :data:`HAS_NPN` ãŒå½ã®å ´åˆ :exc:`NotImplementedError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1215
msgid ""
"Register a callback function that will be called after the TLS Client Hello "
"handshake message has been received by the SSL/TLS server when the TLS "
"client specifies a server name indication. The server name indication "
"mechanism is specified in :rfc:`6066` section 3 - Server Name Indication."
msgstr "TLS ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒã‚µãƒ¼ãƒåè¡¨ç¤ºã‚’æŒ‡å®šã—ãŸéš›ã®ã€SSL/TLS ã‚µãƒ¼ãƒã«ã‚ˆã£ã¦ TLS Client Hello ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒå—ã‘å–ã‚‰ã‚ŒãŸã‚ã¨ã§å‘¼ã³å‡ºã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’ç™»éŒ²ã—ã¾ã™ã€‚ã‚µãƒ¼ãƒåè¡¨ç¤ºãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã¯ :rfc:`6066` ã‚»ã‚¯ã‚·ãƒ§ãƒ³ 3 - Server Name Indication ã§è¿°ã¹ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/ssl.rst:1220
msgid ""
"Only one callback can be set per ``SSLContext``.  If *server_name_callback* "
"is ``None`` then the callback is disabled. Calling this function a "
"subsequent time will disable the previously registered callback."
msgstr "``SSLContext`` ã”ã¨ã«ä¸€ã¤ã ã‘ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ã‚»ãƒƒãƒˆå‡ºæ¥ã¾ã™ã€‚ *server_name_callback* ã‚’ ``None`` ã«ã™ã‚Œã°ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯ç„¡åŠ¹ã«ãªã‚Šã¾ã™ã€‚ã“ã®é–¢æ•°ã‚’ç¶šã‘ã¦å‘¼ã¶ã¨ã€ä»¥å‰ã«ç™»éŒ²ã•ã‚ŒãŸã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ä¸Šæ›¸ãã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1224
msgid ""
"The callback function, *server_name_callback*, will be called with three "
"arguments; the first being the :class:`ssl.SSLSocket`, the second is a "
"string that represents the server name that the client is intending to "
"communicate (or :const:`None` if the TLS Client Hello does not contain a "
"server name) and the third argument is the original :class:`SSLContext`. The"
" server name argument is the IDNA decoded server name."
msgstr "ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•° *server_name_callback* ã¯ 3 ã¤ã®å¼•æ•°ã§å‘¼ã³å‡ºã•ã‚Œã¾ã™; æœ€åˆã®å¼•æ•°ã¯ :class:`ssl.SSLSocket` ã§ã™ã€‚2 ã¤ç›®ã®å¼•æ•°ã¯ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒç›¸æ‰‹ã‚’ã—ã‚ˆã†ã¨æ„å›³ã—ã¦ã„ã‚‹ã‚µãƒ¼ãƒåã‚’è¡¨ã™æ–‡å­—åˆ— (ã¾ãŸã¯ TLS Client Hello ãŒã‚µãƒ¼ãƒåã‚’å«ã¾ãªã„å ´åˆã¯ ``None``) ã§ã™ã€‚ãã—ã¦ 3 ã¤ç›®ã®å¼•æ•°ã¯ã‚ªãƒªã‚¸ãƒŠãƒ«ã® :class:`SSLContext` ã§ã™ã€‚ã‚µãƒ¼ãƒåå¼•æ•°ã¯ IDNA ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸã‚µãƒ¼ãƒåã§ã™ã€‚"

#: ../../library/ssl.rst:1231
msgid ""
"A typical use of this callback is to change the :class:`ssl.SSLSocket`'s "
":attr:`SSLSocket.context` attribute to a new object of type "
":class:`SSLContext` representing a certificate chain that matches the server"
" name."
msgstr "ã“ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®å…¸å‹çš„ãªåˆ©ç”¨æ–¹æ³•ã¯ã€ :class:`ssl.SSLSocket` ã® :attr:`SSLSocket.context` å±æ€§ã‚’ã€ã‚µãƒ¼ãƒåã«åˆè‡´ã™ã‚‹è¨¼æ˜æ›¸ãƒã‚§ã‚¤ãƒ³ã‚’æŒã¤æ–°ã—ã„ :class:`SSLContext` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›´ã™ã‚‹ã“ã¨ã§ã™ã€‚"

#: ../../library/ssl.rst:1236
msgid ""
"Due to the early negotiation phase of the TLS connection, only limited "
"methods and attributes are usable like "
":meth:`SSLSocket.selected_alpn_protocol` and :attr:`SSLSocket.context`. "
":meth:`SSLSocket.getpeercert`, :meth:`SSLSocket.getpeercert`, "
":meth:`SSLSocket.cipher` and :meth:`SSLSocket.compress` methods require that"
" the TLS connection has progressed beyond the TLS Client Hello and therefore"
" will not contain return meaningful values nor can they be called safely."
msgstr "TLS æ¥ç¶šã®åˆæœŸãƒã‚´ã‚·ã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ•ã‚§ãƒ¼ã‚ºã§ã™ã‹ã‚‰ã€ :meth:`SSLSocket.selected_alpn_protocol`, :attr:`SSLSocket.context` ã®ã‚ˆã†ãªé™ã‚‰ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã¨å±æ€§ã®ã¿ä½¿ãˆã¾ã™ã€‚ :meth:`SSLSocket.getpeercert`, :meth:`SSLSocket.getpeercert`, :meth:`SSLSocket.cipher`, :meth:`SSLSocket.compress` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ TLS æ¥ç¶šãŒ TLS Client Hello ã‚ˆã‚Šã‚‚å…ˆã«é€²è¡Œã—ã¦ã„ã‚‹ã“ã¨ã‚’å¿…è¦ã¨ã—ã¾ã™ã‹ã‚‰ã€ã“ã‚Œã‚‰ã¯æ„å‘³ã®ã‚ã‚‹å€¤ã‚’è¿”ã—ã¾ã›ã‚“ã—ã€å®‰å…¨ã«å‘¼ã³å‡ºã™ã“ã¨ã‚‚å‡ºæ¥ã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:1244
msgid ""
"The *server_name_callback* function must return ``None`` to allow the TLS "
"negotiation to continue.  If a TLS failure is required, a constant "
":const:`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>` can be "
"returned.  Other return values will result in a TLS fatal error with "
":const:`ALERT_DESCRIPTION_INTERNAL_ERROR`."
msgstr "TLS ãƒã‚´ã‚·ã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ç¶™ç¶šã•ã›ã‚‹ãªã‚‰ã°ã€ *server_name_callback* é–¢æ•°ã¯ ``None`` ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚TLS ãŒå¤±æ•—ã™ã‚‹ã“ã¨ã‚’å¿…è¦ã¨ã™ã‚‹ãªã‚‰ã€ constant :const:`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>` ã‚’è¿”ã—ã¦ãã ã•ã„ã€‚ã“ã“ã«ãªã„å€¤ã‚’è¿”ã™ã¨ã€è‡´å‘½ã‚¨ãƒ©ãƒ¼ :const:`ALERT_DESCRIPTION_INTERNAL_ERROR` ã‚’å¼•ãèµ·ã“ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1250
msgid ""
"If there is an IDNA decoding error on the server name, the TLS connection "
"will terminate with an :const:`ALERT_DESCRIPTION_INTERNAL_ERROR` fatal TLS "
"alert message to the client."
msgstr "ã‚µãƒ¼ãƒåã«å¯¾ã™ã‚‹ IDNA ãƒ‡ã‚³ãƒ¼ãƒ‰ã®ã‚¨ãƒ©ãƒ¼ãŒã‚ã‚Œã°ã€TLS æ¥ç¶šã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«å¯¾ã™ã‚‹ TLS ã®è‡´å‘½çš„ã‚¢ãƒ©ãƒ¼ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ :const:`ALERT_DESCRIPTION_INTERNAL_ERROR` ã¨ã¨ã‚‚ã«çµ‚äº†ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1254
msgid ""
"If an exception is raised from the *server_name_callback* function the TLS "
"connection will terminate with a fatal TLS alert message "
":const:`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`."
msgstr "*server_name_callback* é–¢æ•°ãŒä¾‹å¤–ã‚’é€å‡ºã—ãŸå ´åˆã€TLS æ¥ç¶šã¯ TLS ã®è‡´å‘½çš„ã‚¢ãƒ©ãƒ¼ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ :const:`ALERT_DESCRIPTION_HANDSHAKE_FAILURE` ã¨ã¨ã‚‚ã«çµ‚äº†ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1258
msgid ""
"This method will raise :exc:`NotImplementedError` if the OpenSSL library had"
" OPENSSL_NO_TLSEXT defined when it was built."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ OpenSSL ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒ OPENSSL_NO_TLSEXT ã‚’å®šç¾©ã—ã¦ãƒ“ãƒ«ãƒ‰ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ :exc:`NotImplementedError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1263
msgid ""
"Load the key generation parameters for Diffie-Helman (DH) key exchange. "
"Using DH key exchange improves forward secrecy at the expense of "
"computational resources (both on the server and on the client). The *dhfile*"
" parameter should be the path to a file containing DH parameters in PEM "
"format."
msgstr "ãƒ‡ã‚£ãƒ•ã‚£ãƒ¼ãƒ»ãƒ˜ãƒ«ãƒãƒ³(DH)éµäº¤æ›ã®ãŸã‚ã®éµç”Ÿæˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚DH éµäº¤æ›ã‚’ç”¨ã„ã‚‹ã“ã¨ã¯ã€(ã‚µãƒ¼ãƒã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã‚‚ã«)è¨ˆç®—æ©Ÿãƒªã‚½ãƒ¼ã‚¹ã«é«˜ã„å‡¦ç†è² è·ã‚’ã‹ã‘ã¾ã™ãŒã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’å‘ä¸Šã•ã›ã¾ã™ã€‚ *dhfile* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯ PEM ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã® DH ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å«ã‚“ã ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:1269
msgid ""
"This setting doesn't apply to client sockets.  You can also use the "
":data:`OP_SINGLE_DH_USE` option to further improve security."
msgstr "ã“ã®è¨­å®šã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚½ã‚±ãƒƒãƒˆã«ã¯é©ç”¨ã•ã‚Œã¾ã›ã‚“ã€‚ã•ã‚‰ã«ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’æ”¹å–„ã™ã‚‹ã®ã« :data:`OP_SINGLE_DH_USE` ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚‚åˆ©ç”¨ã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:1274
msgid ""
"Set the curve name for Elliptic Curve-based Diffie-Hellman (ECDH) key "
"exchange.  ECDH is significantly faster than regular DH while arguably as "
"secure.  The *curve_name* parameter should be a string describing a well-"
"known elliptic curve, for example ``prime256v1`` for a widely supported "
"curve."
msgstr "æ¥•å††æ›²ç·šãƒ‡ã‚£ãƒ•ã‚£ãƒ¼ãƒ»ãƒ˜ãƒ«ãƒãƒ³(ECDH)éµäº¤æ›ã®æ›²ç·šåã‚’æŒ‡å®šã—ã¾ã™ã€‚ECDH ã¯ã‚‚ã¨ã® DH ã«è¼ƒã¹ã¦ã€ã»ã¼é–“é•ã„ãªãåŒç¨‹åº¦ã«å®‰å…¨ã§ã‚ã‚‹ä¸€æ–¹ã§ã€é¡•è‘—ã«é«˜é€Ÿã§ã™ã€‚ *curve_name* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯æ—¢çŸ¥ã®æ¥•å††æ›²ç·šã‚’è¡¨ã™æ–‡å­—åˆ—ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ä¾‹ãˆã° ``prime256v1`` ãŒåºƒãã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹æ›²ç·šã§ã™ã€‚"

#: ../../library/ssl.rst:1280
msgid ""
"This setting doesn't apply to client sockets.  You can also use the "
":data:`OP_SINGLE_ECDH_USE` option to further improve security."
msgstr "ã“ã®è¨­å®šã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚½ã‚±ãƒƒãƒˆã«ã¯é©ç”¨ã•ã‚Œã¾ã›ã‚“ã€‚ã•ã‚‰ã«ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’æ”¹å–„ã™ã‚‹ã®ã« :data:`OP_SINGLE_ECDH_USE` ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚‚åˆ©ç”¨ã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:1283
msgid "This method is not available if :data:`HAS_ECDH` is ``False``."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :data:`HAS_ECDH` ãŒ ``False`` ã®å ´åˆã¯åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:1286
msgid ""
"`SSL/TLS & Perfect Forward Secrecy <http://vincent.bernat.im/en/blog/2011"
"-ssl-perfect-forward-secrecy.html>`_"
msgstr "`SSL/TLS & Perfect Forward Secrecy <http://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy.html>`_"

#: ../../library/ssl.rst:1287
msgid "Vincent Bernat."
msgstr "Vincent Bernat."

#: ../../library/ssl.rst:1293
msgid ""
"Wrap an existing Python socket *sock* and return an :class:`SSLSocket` "
"object.  *sock* must be a :data:`~socket.SOCK_STREAM` socket; other socket "
"types are unsupported."
msgstr "æ—¢å­˜ã® Python ã‚½ã‚±ãƒƒãƒˆ *sock* ã‚’ãƒ©ãƒƒãƒ—ã—ã¦ :class:`ssl.SSLSocket` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ *sock* ã¯ :data:`~socket.SOCK_STREAM` ã‚½ã‚±ãƒƒãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“; ã»ã‹ã®ã‚¿ã‚¤ãƒ—ã®ã‚½ã‚±ãƒƒãƒˆã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:1297
msgid ""
"The returned SSL socket is tied to the context, its settings and "
"certificates.  The parameters *server_side*, *do_handshake_on_connect* and "
"*suppress_ragged_eofs* have the same meaning as in the top-level "
":func:`wrap_socket` function."
msgstr "è¿”ã•ã‚Œã‚‹ SSL ã‚½ã‚±ãƒƒãƒˆã¯ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã€ãã®è¨­å®šã¨è¨¼æ˜æ›¸ã«é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¾ã™ã€‚ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ *server_side*, *do_handshake_on_connect*, *suppress_ragged_eofs* ã¯ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®é–¢æ•° :func:`wrap_socket` ã®ã‚‚ã®ã¨åŒã˜æ„å‘³ã§ã™ã€‚"

#: ../../library/ssl.rst:1302
msgid ""
"On client connections, the optional parameter *server_hostname* specifies "
"the hostname of the service which we are connecting to.  This allows a "
"single server to host multiple SSL-based services with distinct "
"certificates, quite similarly to HTTP virtual hosts. Specifying "
"*server_hostname* will raise a :exc:`ValueError` if *server_side* is true."
msgstr "ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã‹ã‚‰æ¥ç¶šã§ã¯ã€ *server_hostname* ã§æ¥ç¶šã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ã‚µãƒ¼ãƒ“ã‚¹ã®ãƒ›ã‚¹ãƒˆåã‚’æŒ‡å®šå‡ºæ¥ã¾ã™ã€‚ã“ã‚Œã¯ HTTP ãƒãƒ¼ãƒãƒ£ãƒ«ãƒ›ã‚¹ãƒˆã«ã‹ãªã‚Šä¼¼ã¦ã€ã‚·ãƒ³ã‚°ãƒ«ã‚µãƒ¼ãƒã§è¤‡æ•°ã® SSL ãƒ™ãƒ¼ã‚¹ã®ã‚µãƒ¼ãƒ“ã‚¹ã‚’åˆ¥ã€…ã®è¨¼æ˜æ›¸ã§ãƒ›ã‚¹ãƒˆã—ã¦ã„ã‚‹ã‚ˆã†ãªã‚µãƒ¼ãƒã«å¯¾ã—ã¦ä½¿ãˆã¾ã™ã€‚ *server_side* ãŒçœŸã®å ´åˆã« *server_hostname* ã‚’æŒ‡å®šã™ã‚‹ã¨ :exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1308
msgid ""
"Always allow a server_hostname to be passed, even if OpenSSL does not have "
"SNI."
msgstr "OpenSSL ãŒ SNI ã‚’ã‚µãƒãƒ¼ãƒˆã—ãªãã¦ã‚‚ server_hostname ã‚’è¨±å®¹ã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/ssl.rst:1314
msgid ""
"Get statistics about the SSL sessions created or managed by this context. A "
"dictionary is returned which maps the names of each `piece of information "
"<https://www.openssl.org/docs/man1.1.0/ssl/SSL_CTX_sess_number.html>`_ to "
"their numeric values.  For example, here is the total number of hits and "
"misses in the session cache since the context was created::"
msgstr ""

#: ../../library/ssl.rst:1326
msgid ""
"Wether to match the peer cert's hostname with :func:`match_hostname` in "
":meth:`SSLSocket.do_handshake`. The context's "
":attr:`~SSLContext.verify_mode` must be set to :data:`CERT_OPTIONAL` or "
":data:`CERT_REQUIRED`, and you must pass *server_hostname* to "
":meth:`~SSLContext.wrap_socket` in order to match the hostname."
msgstr ":meth:`SSLSocket.do_handshake` å‘¼ã³å‡ºã—æ™‚ã«ã€ :func:`match_hostname` ã‚’ä½¿ã£ã¦æ¥ç¶šå…ˆè¨¼æ˜æ›¸ã®ãƒ›ã‚¹ãƒˆåã®åˆè‡´ã‚’è¦‹ã‚‹ã‹ã©ã†ã‹ã€‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã® :attr:`~SSLContext.verify_mode` ã«ã¯ :data:`CERT_OPTIONAL` ã‹ :data:`CERT_REQUIRED` ã‚’ã‚»ãƒƒãƒˆã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã¾ãŸ :meth:`~SSLContext.wrap_socket` ã«ã¯ãƒ›ã‚¹ãƒˆåã®åˆè‡´ã‚’ã¿ã‚‹ãŸã‚ã® *server_hostname* ã‚’æ¸¡ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:1347
msgid "This features requires OpenSSL 0.9.8f or newer."
msgstr "ã“ã®æ©Ÿèƒ½ã«ã¯OpenSSL0.9.8fä»¥é™ãŒå¿…è¦ã§ã™ã€‚"

#: ../../library/ssl.rst:1351
msgid ""
"An integer representing the set of SSL options enabled on this context. The "
"default value is :data:`OP_ALL`, but you can specify other options such as "
":data:`OP_NO_SSLv2` by ORing them together."
msgstr "ã“ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§æœ‰åŠ¹ã«ãªã£ã¦ã„ã‚‹ SSL ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¡¨ã™æ•´æ•°ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å€¤ã¯ :data:`OP_ALL` ã§ã™ãŒã€ :data:`OP_NO_SSLv2` ã®ã‚ˆã†ãªã»ã‹ã®å€¤ã‚’ãƒ“ãƒƒãƒˆORæ¼”ç®—ã§æŒ‡å®šå‡ºæ¥ã¾ã™ã€‚"

#: ../../library/ssl.rst:1356
msgid ""
"With versions of OpenSSL older than 0.9.8m, it is only possible to set "
"options, not to clear them.  Attempting to clear an option (by resetting the"
" corresponding bits) will raise a ``ValueError``."
msgstr "OpenSSL ã® 0.9.8m ã‚ˆã‚Šå¤ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ä½¿ã†å ´åˆã€å€¤ã¯ã‚»ãƒƒãƒˆã¯å‡ºæ¥ã¾ã™ãŒã‚¯ãƒªã‚¢ãŒå‡ºæ¥ã¾ã›ã‚“ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’(å¯¾å¿œã™ã‚‹ãƒ“ãƒƒãƒˆã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹ã“ã¨ã§)ã‚¯ãƒªã‚¢ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ ``ValueError`` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:1362
msgid ""
"The protocol version chosen when constructing the context.  This attribute "
"is read-only."
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®æ§‹ç¯‰æ™‚ã«é¸æŠã•ã‚ŒãŸãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã€‚ã“ã®å±æ€§ã¯èª­ã¿å–ã‚Šå°‚ç”¨ã§ã™ã€‚"

#: ../../library/ssl.rst:1367
msgid ""
"The flags for certificate verification operations. You can set flags like "
":data:`VERIFY_CRL_CHECK_LEAF` by ORing them together. By default OpenSSL "
"does neither require nor verify certificate revocation lists (CRLs). "
"Available only with openssl version 0.9.8+."
msgstr "è¨¼æ˜æ›¸ã®æ¤œè¨¼æ“ä½œã®ãŸã‚ã®ãƒ•ãƒ©ã‚°ã§ã™ã€‚ :data:`VERIFY_CRL_CHECK_LEAF` ãªã©ã®ãƒ•ãƒ©ã‚°ã‚’ãƒ“ãƒƒãƒˆORæ¼”ç®—ã§ã‚»ãƒƒãƒˆå‡ºæ¥ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ OpenSSL ã¯è¨¼æ˜æ›¸å¤±åŠ¹ãƒªã‚¹ãƒˆ(CRLs)ã‚’å¿…è¦ã¨ã‚‚ã—ã¾ã›ã‚“ã—æ¤œè¨¼ã«ã‚‚ä½¿ã„ã¾ã›ã‚“ã€‚openssl version 0.9.8+ ã§ã®ã¿åˆ©ç”¨å¯èƒ½ã§ã™ã€‚"

#: ../../library/ssl.rst:1374
msgid ""
"Whether to try to verify other peers' certificates and how to behave if "
"verification fails.  This attribute must be one of :data:`CERT_NONE`, "
":data:`CERT_OPTIONAL` or :data:`CERT_REQUIRED`."
msgstr "æ¥ç¶šå…ˆã®è¨¼æ˜æ›¸ã®æ¤œè¨¼ã‚’è©¦ã¿ã‚‹ã‹ã©ã†ã‹ã€ã¾ãŸã€æ¤œè¨¼ãŒå¤±æ•—ã—ãŸå ´åˆã«ã©ã®ã‚ˆã†ã«æŒ¯èˆã†ã¹ãã‹ã‚’åˆ¶å¾¡ã—ã¾ã™ã€‚ã“ã®å±æ€§ã¯ :data:`CERT_NONE`, :data:`CERT_OPTIONAL`, :data:`CERT_REQUIRED` ã®ã†ã¡ã©ã‚Œã‹ä¸€ã¤ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:1386
msgid "Certificates"
msgstr "è¨¼æ˜æ›¸"

#: ../../library/ssl.rst:1388
msgid ""
"Certificates in general are part of a public-key / private-key system.  In "
"this system, each *principal*, (which may be a machine, or a person, or an "
"organization) is assigned a unique two-part encryption key.  One part of the"
" key is public, and is called the *public key*; the other part is kept "
"secret, and is called the *private key*.  The two parts are related, in that"
" if you encrypt a message with one of the parts, you can decrypt it with the"
" other part, and **only** with the other part."
msgstr "è¨¼æ˜æ›¸ã‚’å¤§ã¾ã‹ã«èª¬æ˜ã™ã‚‹ã¨ã€å…¬é–‹éµ/ç§˜å¯†éµã‚·ã‚¹ãƒ†ãƒ ã®ä¸€ç¨®ã§ã™ã€‚ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€å„ *principal* (ã“ã‚Œã¯ãƒã‚·ãƒ³ã€äººã€çµ„ç¹”ãªã©ã§ã™) ã¯ã€ãƒ¦ãƒ‹ãƒ¼ã‚¯ãª2ã¤ã®æš—å·éµã‚’å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¾ã™ã€‚1ã¤ã¯å…¬é–‹ã•ã‚Œã€ *å…¬é–‹éµ(public key)* ã¨å‘¼ã°ã‚Œã¾ã™ã€‚ã‚‚ã†ä¸€æ–¹ã¯ç§˜å¯†ã«ã•ã‚Œã€ *ç§˜å¯†éµ(private key)* ã¨å‘¼ã°ã‚Œã¾ã™ã€‚ 2ã¤ã®éµã¯é–¢é€£ã—ã¦ãŠã‚Šã€ç‰‡æ–¹ã®éµã§æš—å·åŒ–ã—ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ã€ã‚‚ã†ç‰‡æ–¹ã®éµ **ã®ã¿** ã§å¾©å·ã§ãã¾ã™ã€‚"

#: ../../library/ssl.rst:1396
msgid ""
"A certificate contains information about two principals.  It contains the "
"name of a *subject*, and the subject's public key.  It also contains a "
"statement by a second principal, the *issuer*, that the subject is who they "
"claim to be, and that this is indeed the subject's public key.  The issuer's"
" statement is signed with the issuer's private key, which only the issuer "
"knows.  However, anyone can verify the issuer's statement by finding the "
"issuer's public key, decrypting the statement with it, and comparing it to "
"the other information in the certificate. The certificate also contains "
"information about the time period over which it is valid.  This is expressed"
" as two fields, called \"notBefore\" and \"notAfter\"."
msgstr ""

#: ../../library/ssl.rst:1406
msgid ""
"In the Python use of certificates, a client or server can use a certificate "
"to prove who they are.  The other side of a network connection can also be "
"required to produce a certificate, and that certificate can be validated to "
"the satisfaction of the client or server that requires such validation.  The"
" connection attempt can be set to raise an exception if the validation "
"fails. Validation is done automatically, by the underlying OpenSSL "
"framework; the application need not concern itself with its mechanics.  But "
"the application does usually need to provide sets of certificates to allow "
"this process to take place."
msgstr "Python ã«ãŠã„ã¦è¨¼æ˜æ›¸ã‚’åˆ©ç”¨ã™ã‚‹å ´åˆã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚‚ã‚µãƒ¼ãƒãƒ¼ã‚‚è‡ªåˆ†ã‚’è¨¼æ˜ã™ã‚‹ãŸã‚ã«è¨¼æ˜æ›¸ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã®ç›¸æ‰‹å´ã«è¨¼æ˜æ›¸ã®æç¤ºã‚’è¦æ±‚ã™ã‚‹äº‹ãŒã§ãã€ãã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚„ã‚µãƒ¼ãƒãƒ¼ãŒèªè¨¼ã‚’å¿…è¦ã¨ã™ã‚‹ãªã‚‰ãã®è¨¼æ˜æ›¸ã‚’èªè¨¼ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚èªè¨¼ãŒå¤±æ•—ã—ãŸå ´åˆã€æ¥ç¶šã¯ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚èªè¨¼ã¯ä¸‹ä½å±¤ã®OpenSSLãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ãŒè‡ªå‹•çš„ã«è¡Œã„ã¾ã™ã€‚ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯èªè¨¼æ©Ÿæ§‹ã«ã¤ã„ã¦æ„è­˜ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã—ã‹ã—ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯èªè¨¼ãƒ—ãƒ­ã‚»ã‚¹ã®ãŸã‚ã«å¹¾ã¤ã‹ã®è¨¼æ˜æ›¸ã‚’æä¾›ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:1416
msgid ""
"Python uses files to contain certificates.  They should be formatted as "
"\"PEM\" (see :rfc:`1422`), which is a base-64 encoded form wrapped with a "
"header line and a footer line::"
msgstr "Python ã¯è¨¼æ˜æ›¸ã‚’æ ¼ç´ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚ãã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ \"PEM\" (:rfc:`1422` å‚ç…§) ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¨ã„ã†ã€ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã¨ãƒ•ãƒƒã‚¿ãƒ¼è¡Œã®é–“ã«base-64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸå½¢ã‚’ã¨ã£ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ ::"

#: ../../library/ssl.rst:1425
msgid "Certificate chains"
msgstr "è¨¼æ˜æ›¸ãƒã‚§ã‚¤ãƒ³"

#: ../../library/ssl.rst:1427
msgid ""
"The Python files which contain certificates can contain a sequence of "
"certificates, sometimes called a *certificate chain*.  This chain should "
"start with the specific certificate for the principal who \"is\" the client "
"or server, and then the certificate for the issuer of that certificate, and "
"then the certificate for the issuer of *that* certificate, and so on up the "
"chain till you get to a certificate which is *self-signed*, that is, a "
"certificate which has the same subject and issuer, sometimes called a *root "
"certificate*.  The certificates should just be concatenated together in the "
"certificate file.  For example, suppose we had a three certificate chain, "
"from our server certificate to the certificate of the certification "
"authority that signed our server certificate, to the root certificate of the"
" agency which issued the certification authority's certificate::"
msgstr "PythonãŒåˆ©ç”¨ã™ã‚‹è¨¼æ˜æ›¸ã‚’æ ¼ç´ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€ã¨ãã«ã¯ *è¨¼æ˜æ›¸ãƒã‚§ã‚¤ãƒ³(certificate chain)* ã¨å‘¼ã°ã‚Œã‚‹è¨¼æ˜æ›¸ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’æ ¼ç´ã—ã¾ã™ã€‚ã“ã®ãƒã‚§ã‚¤ãƒ³ã¯ã€ã¾ãšã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚„ã‚µãƒ¼ãƒãƒ¼è‡ªä½“ã® principal ã®è¨¼æ˜æ›¸ã§å§‹ã¾ã‚‰ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãã‚Œä»¥é™ã«ç¶šãè¨¼æ˜æ›¸ã¯ã€æ‰‹å‰ã®è¨¼æ˜æ›¸ã®ç™ºè¡Œè€…(issuer)ã®è¨¼æ˜æ›¸ã«ãªã‚Šã€æœ€å¾Œã«subject ã¨ç™ºè¡Œè€…ãŒåŒã˜ *è‡ªå·±ç½²å(self-signed)* è¨¼æ˜æ›¸ã§çµ‚ã‚ã‚Šã¾ã™ã€‚ã“ã®æœ€å¾Œã®è¨¼æ˜æ›¸ã¯ *ãƒ«ãƒ¼ãƒˆè¨¼æ˜æ›¸(root certificate* ã¨å‘¼ã°ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‰ã®è¨¼æ˜æ›¸ãƒã‚§ã‚¤ãƒ³ã¯1ã¤ã®è¨¼æ˜æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ã«çµåˆã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€3ã¤ã®è¨¼æ˜æ›¸ã‹ã‚‰ãªã‚‹è¨¼æ˜æ›¸ãƒã‚§ã‚¤ãƒ³ãŒã‚ã‚‹ã¨ã—ã¾ã™ã€‚ç§ãŸã¡ã®ã‚µãƒ¼ãƒãƒ¼ã®è¨¼æ˜æ›¸ã‹ã‚‰ã€ç§ãŸã¡ã®ã‚µãƒ¼ãƒãƒ¼ã«ç½²åã—ãŸèªè¨¼å±€ã®è¨¼æ˜æ›¸ã€ãã—ã¦èªè¨¼å±€ã®è¨¼æ˜æ›¸ã‚’ç™ºè¡Œã—ãŸæ©Ÿé–¢ã®ãƒ«ãƒ¼ãƒˆè¨¼æ˜æ›¸ã§ã™ã€‚ ::"

#: ../../library/ssl.rst:1451
msgid "CA certificates"
msgstr "CA è¨¼æ˜æ›¸"

#: ../../library/ssl.rst:1453
msgid ""
"If you are going to require validation of the other side of the connection's"
" certificate, you need to provide a \"CA certs\" file, filled with the "
"certificate chains for each issuer you are willing to trust.  Again, this "
"file just contains these chains concatenated together.  For validation, "
"Python will use the first chain it finds in the file which matches.  The "
"platform's certificates file can be used by calling "
":meth:`SSLContext.load_default_certs`, this is done automatically with "
":func:`.create_default_context`."
msgstr "ã‚‚ã—ç›¸æ‰‹ã‹ã‚‰é€ã‚‰ã‚Œã¦ããŸè¨¼æ˜æ›¸ã®èªè¨¼ã‚’ã—ãŸã„å ´åˆã€ä¿¡é ¼ã—ã¦ã„ã‚‹å„ç™ºè¡Œè€…ã®è¨¼æ˜æ›¸ãƒã‚§ã‚¤ãƒ³ãŒå…¥ã£ãŸ \"CA certs\" ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æä¾›ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ç¹°ã‚Šè¿”ã—ã¾ã™ãŒã€ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯å˜ç´”ã«ã€å„ãƒã‚§ã‚¤ãƒ³ã‚’çµåˆã—ãŸã ã‘ã®ã‚‚ã®ã§ã™ã€‚èªè¨¼ã®ãŸã‚ã«ã€Pythonã¯ãã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¸­ã®æœ€åˆã«ãƒãƒƒãƒã—ãŸãƒã‚§ã‚¤ãƒ³ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚:meth:`SSLContext.load_default_certs` ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã®è¨¼æ˜æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ã‚‚ä½¿ã‚ã‚Œã¾ã™ãŒã€ã“ã‚Œã¯ :func:`.create_default_context` ã«ã‚ˆã£ã¦è‡ªå‹•çš„ã«è¡Œã‚ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:1462
msgid "Combined key and certificate"
msgstr "ç§˜å¯†éµã¨è¨¼æ˜æ›¸ã‚’ä¸€ç·’ã«ã™ã‚‹"

#: ../../library/ssl.rst:1464
msgid ""
"Often the private key is stored in the same file as the certificate; in this"
" case, only the ``certfile`` parameter to :meth:`SSLContext.load_cert_chain`"
" and :func:`wrap_socket` needs to be passed.  If the private key is stored "
"with the certificate, it should come before the first certificate in the "
"certificate chain::"
msgstr "å¤šãã®å ´åˆã€è¨¼æ˜æ›¸ã¨åŒã˜ãƒ•ã‚¡ã‚¤ãƒ«ã«ç§˜å¯†éµã‚‚æ ¼ç´ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®å ´åˆã€ :meth:`SSLContext.load_cert_chain`, :func:`wrap_socket` ã«ã¯ ``certfile`` å¼•æ•°ã ã‘ãŒå¿…è¦ã¨ã•ã‚Œã¾ã™ã€‚ç§˜å¯†éµãŒè¨¼æ˜æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ã«æ ¼ç´ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ç§˜å¯†éµã¯è¨¼æ˜æ›¸ãƒã‚§ã‚¤ãƒ³ã®æœ€åˆã®è¨¼æ˜æ›¸ã‚ˆã‚Šã‚‚å…ˆã«ãªã„ã¨ã„ã‘ã¾ã›ã‚“ã€‚ ::"

#: ../../library/ssl.rst:1478
msgid "Self-signed certificates"
msgstr "è‡ªå·±ç½²åè¨¼æ˜æ›¸"

#: ../../library/ssl.rst:1480
msgid ""
"If you are going to create a server that provides SSL-encrypted connection "
"services, you will need to acquire a certificate for that service.  There "
"are many ways of acquiring appropriate certificates, such as buying one from"
" a certification authority.  Another common practice is to generate a self-"
"signed certificate.  The simplest way to do this is with the OpenSSL "
"package, using something like the following::"
msgstr "SSLæš—å·åŒ–æ¥ç¶šã‚µãƒ¼ãƒ“ã‚¹ã‚’æä¾›ã™ã‚‹ã‚µãƒ¼ãƒãƒ¼ã‚’å»ºã¦ã‚‹å ´åˆã€é©åˆ‡ãªè¨¼æ˜æ›¸ã‚’å–å¾—ã™ã‚‹ã«ã¯ã€èªè¨¼å±€ã‹ã‚‰è²·ã†ãªã©ã®å¹¾ã¤ã‹ã®æ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚ã¾ãŸã€è‡ªå·±ç½²åè¨¼æ˜æ›¸ã‚’ä½œã‚‹ã‚±ãƒ¼ã‚¹ã‚‚ã‚ã‚Šã¾ã™ã€‚ OpenSSLã‚’ä½¿ã£ã¦è‡ªå·±ç½²åè¨¼æ˜æ›¸ã‚’ä½œã‚‹ã«ã¯ã€æ¬¡ã®ã‚ˆã†ã«ã—ã¾ã™ã€‚ ::"

#: ../../library/ssl.rst:1509
msgid ""
"The disadvantage of a self-signed certificate is that it is its own root "
"certificate, and no one else will have it in their cache of known (and "
"trusted) root certificates."
msgstr "è‡ªå·±ç½²åè¨¼æ˜æ›¸ã®æ¬ ç‚¹ã¯ã€ãã‚Œè‡ªèº«ãŒãƒ«ãƒ¼ãƒˆè¨¼æ˜æ›¸ã§ã‚ã‚Šã€ä»–ã®äººã¯ãã®è¨¼æ˜æ›¸ã‚’æŒã£ã¦ã„ãªã„ (ãã—ã¦ä¿¡é ¼ã—ãªã„)ã“ã¨ã§ã™ã€‚"

#: ../../library/ssl.rst:1515
msgid "Examples"
msgstr "ä¾‹"

#: ../../library/ssl.rst:1518
msgid "Testing for SSL support"
msgstr "SSLã‚µãƒãƒ¼ãƒˆã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹"

#: ../../library/ssl.rst:1520
msgid ""
"To test for the presence of SSL support in a Python installation, user code "
"should use the following idiom::"
msgstr "ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹PythonãŒSSLã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ãŸã‚ã«ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚³ãƒ¼ãƒ‰ã¯æ¬¡ã®ã‚¤ãƒ‡ã‚£ã‚ªãƒ ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ ::"

#: ../../library/ssl.rst:1531
msgid "Client-side operation"
msgstr "ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã®å‡¦ç†"

#: ../../library/ssl.rst:1533
msgid ""
"This example creates a SSL context with the recommended security settings "
"for client sockets, including automatic certificate verification::"
msgstr "ã“ã®ä¾‹ã§ã¯ã€è‡ªå‹•çš„ã«è¨¼æ˜æ›¸ã®æ¤œè¨¼ã‚’è¡Œã†ã“ã¨ã‚’å«ã‚€æœ›ã¾ã—ã„ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®šã§ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚½ã‚±ãƒƒãƒˆã® SSL ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œã‚Šã¾ã™::"

#: ../../library/ssl.rst:1538
msgid ""
"If you prefer to tune security settings yourself, you might create a context"
" from scratch (but beware that you might not get the settings right)::"
msgstr "ã‚ãªãŸè‡ªèº«ã§ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®šã‚’èª¿æ•´ã—ãŸã„ã¨æœ›ã‚€ãªã‚‰ã€ã‚¹ã‚¯ãƒ©ãƒƒãƒã‹ã‚‰ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œã‚‹ã“ã¨ã¯å‡ºæ¥ã¾ã™(ã§ã™ãŒæ­£ã—ããªã„è¨­å®šã‚’ã—ã¦ã—ã¾ã„ãŒã¡ãªã“ã¨ã«è­¦æˆ’ã—ã¦ãã ã•ã„)"

#: ../../library/ssl.rst:1547
msgid ""
"(this snippet assumes your operating system places a bundle of all CA "
"certificates in ``/etc/ssl/certs/ca-bundle.crt``; if not, you'll get an "
"error and have to adjust the location)"
msgstr "(ã“ã®ã‚¹ãƒ‹ãƒšãƒƒãƒˆã¯å…¨ã¦ã® CA è¨¼æ˜æ›¸ãŒ ``/etc/ssl/certs/ca-bundle.crt`` ã«ãƒãƒ³ãƒ‰ãƒ«ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ä»®å®šã—ã¦ã„ã¾ã™; ã‚‚ã—é•ã£ã¦ã„ã‚Œã°ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã®ã§ã€é©å®œä¿®æ­£ã—ã¦ãã ã•ã„)"

#: ../../library/ssl.rst:1551
msgid ""
"When you use the context to connect to a server, :const:`CERT_REQUIRED` "
"validates the server certificate: it ensures that the server certificate was"
" signed with one of the CA certificates, and checks the signature for "
"correctness::"
msgstr "ã‚µãƒ¼ãƒã¸ã®æ¥ç¶šã«ã“ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½¿ã†ã¨ã€ :const:`CERT_REQUIRED` ã§ã‚µãƒ¼ãƒã®è¨¼æ˜æ›¸ã®æ¤œè¨¼ãŒè¡Œã‚ã‚Œã¾ã™: ã‚µãƒ¼ãƒã®è¨¼æ˜æ›¸ãŒ CA è¨¼æ˜æ›¸ã®ã„ãšã‚Œã‹ã«ç½²åã•ã‚Œã¦ã„ã¦ã€ãã®ç½²åãŒæ­£ã—ã„ã“ã¨ã‚’ä¿éšœã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1560
msgid "You may then fetch the certificate::"
msgstr "ãã—ã¦è¨¼æ˜æ›¸ã‚’æŒã£ã¦ãã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™::"

#: ../../library/ssl.rst:1564
msgid ""
"Visual inspection shows that the certificate does identify the desired "
"service (that is, the HTTPS host ``www.python.org``)::"
msgstr "è¨¼æ˜æ›¸ãŒã€æœŸå¾…ã—ã¦ã„ã‚‹ã‚µãƒ¼ãƒ“ã‚¹ (ã¤ã¾ã‚Šã€ HTTPS ãƒ›ã‚¹ãƒˆ ``www.python.org``) ã®èº«å…ƒã‚’ç‰¹å®šã—ã¦ã„ã‚‹ã“ã¨ã‚’è¦–è¦šçš„ã«ç‚¹æ¤œã—ã¦ã¿ã¾ã—ã‚‡ã†::"

#: ../../library/ssl.rst:1607
msgid ""
"Now the SSL channel is established and the certificate verified, you can "
"proceed to talk with the server::"
msgstr "SSL ãƒãƒ£ãƒãƒ«ã¯ä»Šã‚„ç¢ºç«‹ã•ã‚Œã¦è¨¼æ˜æ›¸ãŒæ¤œè¨¼ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€ã‚µãƒ¼ãƒã¨ã®ãŠå–‹ã‚Šã‚’ç¶šã‘ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™::"

#: ../../library/ssl.rst:1634
msgid "Server-side operation"
msgstr "ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã®å‡¦ç†"

#: ../../library/ssl.rst:1636
msgid ""
"For server operation, typically you'll need to have a server certificate, "
"and private key, each in a file.  You'll first create a context holding the "
"key and the certificate, so that clients can check your authenticity.  Then "
"you'll open a socket, bind it to a port, call :meth:`listen` on it, and "
"start waiting for clients to connect::"
msgstr "ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã®å‡¦ç†ã§ã¯ã€é€šå¸¸ã€ã‚µãƒ¼ãƒãƒ¼è¨¼æ˜æ›¸ã¨ç§˜å¯†éµãŒãã‚Œãã‚Œãƒ•ã‚¡ã‚¤ãƒ«ã«æ ¼ç´ã•ã‚ŒãŸå½¢ã§å¿…è¦ã§ã™ã€‚æœ€åˆã«ç§˜å¯†éµã¨è¨¼æ˜æ›¸ãŒä¿æŒã•ã‚ŒãŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œæˆã—ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒã‚ãªãŸã®ä¿¡æ†‘æ€§ã‚’ãƒã‚§ãƒƒã‚¯å‡ºæ¥ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ãã®ã®ã¡ã«ã‚½ã‚±ãƒƒãƒˆã‚’é–‹ãã€ãƒãƒ¼ãƒˆã«ãƒã‚¤ãƒ³ãƒ‰ã—ã€ãã®ã‚½ã‚±ãƒƒãƒˆã® :meth:`listen` ã‚’å‘¼ã³ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã®æ¥ç¶šã‚’å¾…ã¡ã¾ã™ã€‚ ::"

#: ../../library/ssl.rst:1651
msgid ""
"When a client connects, you'll call :meth:`accept` on the socket to get the "
"new socket from the other end, and use the context's "
":meth:`SSLContext.wrap_socket` method to create a server-side SSL socket for"
" the connection::"
msgstr "ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒæ¥ç¶šã—ã¦ããŸå ´åˆã€ :meth:`accept` ã‚’å‘¼ã‚“ã§æ–°ã—ã„ã‚½ã‚±ãƒƒãƒˆã‚’ä½œæˆã—ã€æ¥ç¶šã®ãŸã‚ã«ã‚µãƒ¼ãƒã‚µã‚¤ãƒ‰ã® SSL ã‚½ã‚±ãƒƒãƒˆã‚’ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã® :meth:`SSLContext.wrap_socket` ãƒ¡ã‚½ãƒƒãƒ‰ã§ä½œã‚Šã¾ã™::"

#: ../../library/ssl.rst:1664
msgid ""
"Then you'll read data from the ``connstream`` and do something with it till "
"you are finished with the client (or the client is finished with you)::"
msgstr "ãã—ã¦ã€ ``connstream`` ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨åˆ‡æ–­ã™ã‚‹(ã‚ã‚‹ã„ã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒåˆ‡æ–­ã—ã¦ãã‚‹)ã¾ã§ä½•ã‹å‡¦ç†ã‚’ã—ã¾ã™ã€‚ ::"

#: ../../library/ssl.rst:1678
msgid ""
"And go back to listening for new client connections (of course, a real "
"server would probably handle each client connection in a separate thread, or"
" put the sockets in non-blocking mode and use an event loop)."
msgstr "ãã—ã¦æ–°ã—ã„ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆæ¥ç¶šã®ãŸã‚ã« listen ã«æˆ»ã‚Šã¾ã™ã€‚ (ã‚‚ã¡ã‚ã‚“ç¾å®Ÿã®ã‚µãƒ¼ãƒã¯ã€ãŠãã‚‰ãå€‹ã€…ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆæ¥ç¶šã”ã¨ã«åˆ¥ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã§å‡¦ç†ã™ã‚‹ã‹ã€ã‚½ã‚±ãƒƒãƒˆã‚’ãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã«ã—ã€ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã‚’ä½¿ã†ã§ã—ã‚‡ã†ã€‚)"

#: ../../library/ssl.rst:1686
msgid "Notes on non-blocking sockets"
msgstr "ãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã‚½ã‚±ãƒƒãƒˆã«ã¤ã„ã¦ã®æ³¨æ„äº‹é …"

#: ../../library/ssl.rst:1688
msgid ""
"When working with non-blocking sockets, there are several things you need to"
" be aware of:"
msgstr "ãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã‚½ã‚±ãƒƒãƒˆã¨ã¨ã‚‚ã«ä½¿ã†å ´åˆã€ã„ãã¤ã‹æ°—ã‚’ã¤ã‘ãªã‘ã‚Œã°ãªã‚‰ãªã„äº‹é …ãŒã‚ã‚Šã¾ã™:"

#: ../../library/ssl.rst:1691
msgid ""
"Calling :func:`~select.select` tells you that the OS-level socket can be "
"read from (or written to), but it does not imply that there is sufficient "
"data at the upper SSL layer.  For example, only part of an SSL frame might "
"have arrived.  Therefore, you must be ready to handle :meth:`SSLSocket.recv`"
" and :meth:`SSLSocket.send` failures, and retry after another call to "
":func:`~select.select`."
msgstr ":func:`~select.select` å‘¼ã³å‡ºã—ã¯ OS ãƒ¬ãƒ™ãƒ«ã§ã®ã‚½ã‚±ãƒƒãƒˆãŒèª­ã¿å‡ºã—å¯èƒ½(ã¾ãŸã¯æ›¸ãè¾¼ã¿å¯èƒ½)ã«ãªã£ãŸã“ã¨ã‚’æ•™ãˆã¦ãã‚Œã¾ã™ãŒã€ä¸Šä½ã® SSL ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§ã®ååˆ†ãªãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€SSL ãƒ•ãƒ¬ãƒ¼ãƒ ã®ä¸€éƒ¨ãŒå±Šã„ãŸã ã‘ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã§ã™ã‹ã‚‰ã€ :meth:`SSLSocket.recv` ã¨ :meth:`SSLSocket.send` ã®å¤±æ•—ã‚’å‡¦ç†ã™ã‚‹ã“ã¨ã«å‚™ãˆã€ã»ã‹ã® :func:`~select.select` å‘¼ã³å‡ºã—å¾Œã«ãƒªãƒˆãƒ©ã‚¤ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ssl.rst:1698
msgid ""
"Conversely, since the SSL layer has its own framing, a SSL socket may still "
"have data available for reading without :func:`~select.select` being aware "
"of it.  Therefore, you should first call :meth:`SSLSocket.recv` to drain any"
" potentially available data, and then only block on a :func:`~select.select`"
" call if still necessary."
msgstr "åå¯¾ã«ã€SSL ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯è‡ªèº«ã§ç‹¬è‡ªã®æ çµ„ã¿ã‚’æŒã£ã¦ã„ã‚‹ãŸã‚ã«ã€èª­ã¿å‡ºã›ã‚‹ã‘ã‚Œã©ã‚‚ :func:`~select.select` ãŒæ°—ä»˜ãã“ã¨ã®ãªã„ãƒ‡ãƒ¼ã‚¿ã‚’ SSL ã‚½ã‚±ãƒƒãƒˆãŒæŒã£ã¦ã„ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã§ã™ã®ã§ã€æ½œåœ¨çš„ã«å…¥æ‰‹å¯èƒ½ãªãƒ‡ãƒ¼ã‚¿ã‚’é£²ã¿å¹²ã™ãŸã‚ã«æœ€åˆã« :meth:`SSLSocket.recv` ã‚’å‘¼ã³å‡ºã™ã¹ãã§ã‚ã‚Šã€ãã®ã®ã¡ã§ãã‚Œã§ã‚‚ã¾ã å¿…è¦ãªå ´åˆã«ã ã‘ :func:`~select.select` ã§ãƒ–ãƒ­ãƒƒã‚¯ã™ã¹ãã§ã™ã€‚"

#: ../../library/ssl.rst:1704
msgid ""
"(of course, similar provisions apply when using other primitives such as "
":func:`~select.poll`, or those in the :mod:`selectors` module)"
msgstr "(å½“ç„¶ã®ã“ã¨ãªãŒã‚‰ã€ã»ã‹ã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã€ä¾‹ãˆã° :func:`~select.poll` ã‚„ :mod:`selectors` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã®ã‚‚ã®ã‚’ä½¿ã†éš›ã«ã‚‚ä¼¼ãŸä½†ã—æ›¸ããŒä»˜ãã¾ã™)"

#: ../../library/ssl.rst:1707
msgid ""
"The SSL handshake itself will be non-blocking: the "
":meth:`SSLSocket.do_handshake` method has to be retried until it returns "
"successfully.  Here is a synopsis using :func:`~select.select` to wait for "
"the socket's readiness::"
msgstr "SSL ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ãã®ã‚‚ã®ãŒãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã«ãªã‚Šã¾ã™: :meth:`SSLSocket.do_handshake` ãƒ¡ã‚½ãƒƒãƒ‰ã¯æˆåŠŸã™ã‚‹ã¾ã§ãƒªãƒˆãƒ©ã‚¤ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ :func:`~select.select` ã‚’ç”¨ã„ã¦ã‚½ã‚±ãƒƒãƒˆã®æº–å‚™ãŒæ•´ã†ã®ã‚’å¾…ã¤ãŸã‚ã«ã¯ã€ãŠã‚ˆãä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¾ã™::"

#: ../../library/ssl.rst:1725
msgid "Security considerations"
msgstr "ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã§è€ƒæ…®ã™ã¹ãç‚¹"

#: ../../library/ssl.rst:1728
msgid "Best defaults"
msgstr "æœ€å–„ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤"

#: ../../library/ssl.rst:1730
msgid ""
"For **client use**, if you don't have any special requirements for your "
"security policy, it is highly recommended that you use the "
":func:`create_default_context` function to create your SSL context. It will "
"load the system's trusted CA certificates, enable certificate validation and"
" hostname checking, and try to choose reasonably secure protocol and cipher "
"settings."
msgstr "**ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã§ã®ä½¿ç”¨** ã§ã¯ã€ã‚ãªãŸã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒãƒªã‚·ãƒ¼ã«ã‚ˆã‚‹ç‰¹æ®Šãªè¦ä»¶ãŒãªã„é™ã‚Šã¯ã€SSL ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œæˆã™ã‚‹ãŸã‚ã«ã¯ :func:`create_default_context` é–¢æ•°ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’å¼·ããŠå‹§ã‚ã—ã¾ã™ã€‚ãã‚Œã¯ã‚·ã‚¹ãƒ†ãƒ ãŒä¿¡é ¼ã—ãŸ CA è¨¼æ˜æ›¸ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã€è¨¼æ˜æ›¸ã®æ¤œè¨¼ã‚’æœ‰åŠ¹åŒ–ã—ã€ãƒ›ã‚¹ãƒˆåã®ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã„ã€ãã—ã¦ã‚»ã‚­ãƒ¥ã‚¢ãªãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨ã‚»ã‚­ãƒ¥ã‚¢ãªæš—å·ã®åˆ†åˆ¥ã‚ã‚‹è¨­å®šã‚’è©¦ã¿ã¾ã™ã€‚"

#: ../../library/ssl.rst:1737
msgid ""
"If a client certificate is needed for the connection, it can be added with "
":meth:`SSLContext.load_cert_chain`."
msgstr "æ¥ç¶šã«ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®è¨¼æ˜æ›¸ãŒå¿…è¦ãªå ´åˆã€ :meth:`SSLContext.load_cert_chain` ã«ã‚ˆã£ã¦è¿½åŠ å‡ºæ¥ã¾ã™ã€‚"

#: ../../library/ssl.rst:1740
msgid ""
"By contrast, if you create the SSL context by calling the "
":class:`SSLContext` constructor yourself, it will not have certificate "
"validation nor hostname checking enabled by default.  If you do so, please "
"read the paragraphs below to achieve a good security level."
msgstr "å¯¾ç…§çš„ã«ã€ :class:`SSLContext` ã‚¯ãƒ©ã‚¹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’è‡ªèº«ã§å‘¼ã³å‡ºã™ã“ã¨ã«ã‚ˆã£ã¦ SSL ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œã‚‹ã¨ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯è¨¼æ˜æ›¸æ¤œè¨¼ã‚‚ãƒ›ã‚¹ãƒˆåãƒã‚§ãƒƒã‚¯ã‚‚è¡Œã‚ãªã„ã‚‚ã®ã«ãªã‚Šã¾ã™ã€‚ã‚‚ã—ãã†ã™ã‚‹ã®ã§ã‚ã‚Œã°ã€è‰¯ã„ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒ™ãƒ«ã‚’çŸ¥ã‚‹ãŸã‚ã«ã€ã©ã†ã‹ä¸‹ã®æ–¹ã«ã‚ã‚‹ãƒ‘ãƒ©ã‚°ãƒ©ãƒ•ã‚’ãŠèª­ã¿ãã ã•ã„ã€‚"

#: ../../library/ssl.rst:1746
msgid "Manual settings"
msgstr "æ‰‹å‹•ã§ã®è¨­å®š"

#: ../../library/ssl.rst:1749
msgid "Verifying certificates"
msgstr "è¨¼æ˜æ›¸ã®æ¤œè¨¼"

#: ../../library/ssl.rst:1751
msgid ""
"When calling the :class:`SSLContext` constructor directly, "
":const:`CERT_NONE` is the default.  Since it does not authenticate the other"
" peer, it can be insecure, especially in client mode where most of time you "
"would like to ensure the authenticity of the server you're talking to. "
"Therefore, when in client mode, it is highly recommended to use "
":const:`CERT_REQUIRED`.  However, it is in itself not sufficient; you also "
"have to check that the server certificate, which can be obtained by calling "
":meth:`SSLSocket.getpeercert`, matches the desired service.  For many "
"protocols and applications, the service can be identified by the hostname; "
"in this case, the :func:`match_hostname` function can be used.  This common "
"check is automatically performed when :attr:`SSLContext.check_hostname` is "
"enabled."
msgstr ":class:`SSLContext` ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ç›´æ¥å‘¼ã³å‡ºã—ãŸå ´åˆã€ :const:`CERT_NONE` ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚ã“ã‚Œã¯æ¥ç¶šå…ˆã®èº«å…ƒç‰¹å®šã‚’ã—ãªã„ã®ã§å®‰å…¨ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã—ã€ç‰¹ã«ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ¢ãƒ¼ãƒ‰ã§ã¯å¤§æŠµç›¸æ‰‹ã¨ãªã‚‹ã‚µãƒ¼ãƒã®ä¿¡æ†‘æ€§ã‚’ä¿éšœã—ãŸã„ã§ã—ã‚‡ã†ã€‚ã§ã™ã‹ã‚‰ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ¢ãƒ¼ãƒ‰ã§ã¯ :const:`CERT_REQUIRED` ã‚’å¼·ããŠå‹§ã‚ã—ã¾ã™ã€‚ã§ã™ãŒã€ãã‚Œã ã‘ã§ã¯ä¸ååˆ†ã§ã™; :meth:`SSLSocket.getpeercert` ã‚’å‘¼ã³å‡ºã—ã¦ã‚µãƒ¼ãƒè¨¼æ˜æ›¸ãŒæœ›ã‚“ã ã‚µãƒ¼ãƒ“ã‚¹ã¨åˆè‡´ã™ã‚‹ã‹ã®ãƒã‚§ãƒƒã‚¯ã‚‚ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å¤šãã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ã¨ã£ã¦ã€ã‚µãƒ¼ãƒ“ã‚¹ã¯ãƒ›ã‚¹ãƒˆåã§ç‰¹å®šã•ã‚Œã¾ã™; ã“ã®å ´åˆã€ :func:`match_hostname` ãŒä½¿ãˆã¾ã™ã€‚ã“ã‚Œã‚‰ã®å…±é€šçš„ãªãƒã‚§ãƒƒã‚¯ã¯ :attr:`SSLContext.check_hostname` ãŒæœ‰åŠ¹ãªå ´åˆã€è‡ªå‹•çš„ã«è¡Œã‚ã‚Œã¾ã™ã€‚"

#: ../../library/ssl.rst:1764
msgid ""
"In server mode, if you want to authenticate your clients using the SSL layer"
" (rather than using a higher-level authentication mechanism), you'll also "
"have to specify :const:`CERT_REQUIRED` and similarly check the client "
"certificate."
msgstr "ã‚µãƒ¼ãƒãƒ¢ãƒ¼ãƒ‰ã«ãŠã„ã¦ã€(ã‚ˆã‚Šä¸Šä½ã®ãƒ¬ãƒ™ãƒ«ã§ã®èªè¨¼ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã§ã¯ãªã) SSL ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ä½¿ã£ã¦ã‚ãªãŸã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’èªè¨¼ã—ãŸã„ãªã‚‰ã°ã€ :const:`CERT_REQUIRED` ã‚’æŒ‡å®šã—ã¦åŒã˜ã‚ˆã†ã«ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®è¨¼æ˜æ›¸ã‚’æ¤œè¨¼ã™ã¹ãã§ã—ã‚‡ã†ã€‚"

#: ../../library/ssl.rst:1770
msgid ""
"In client mode, :const:`CERT_OPTIONAL` and :const:`CERT_REQUIRED` are "
"equivalent unless anonymous ciphers are enabled (they are disabled by "
"default)."
msgstr "ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ¢ãƒ¼ãƒ‰ã§ã¯ anonymous ciphers ãŒæœ‰åŠ¹(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ç„¡åŠ¹)ã§ãªã„é™ã‚Šã€ :const:`CERT_OPTIONAL` ã¨ :const:`CERT_REQUIRED` ã¯åŒã˜æ„å‘³ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/ssl.rst:1775
msgid "Protocol versions"
msgstr "ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³"

#: ../../library/ssl.rst:1777
msgid ""
"SSL versions 2 and 3 are considered insecure and are therefore dangerous to "
"use.  If you want maximum compatibility between clients and servers, it is "
"recommended to use :const:`PROTOCOL_SSLv23` as the protocol version and then"
" disable SSLv2 and SSLv3 explicitly using the :data:`SSLContext.options` "
"attribute::"
msgstr "SSL versions 2 ã¨ 3 ã¯éã‚»ã‚­ãƒ¥ã‚¢ã¨è€ƒãˆã‚‰ã‚Œã¦ãŠã‚Šã€ãã‚Œã‚†ãˆãã®ä½¿ç”¨ã¯å±é™ºã§ã™ã€‚ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã‚µãƒ¼ãƒã®æœ€å¤§é™ã®äº’æ›æ€§ãŒæ¬²ã—ã„ãªã‚‰ã°ã€ :data:`SSLContext.options` å±æ€§ã§æ˜ç¤ºçš„ã« SSLv2, SSLv3 ã‚’ç„¡åŠ¹ã«ã—ã¦ :const:`PROTOCOL_SSLv23` ã‚’ä½¿ã£ã¦ãã ã•ã„::"

#: ../../library/ssl.rst:1787
msgid ""
"The SSL context created above will only allow TLSv1 and later (if supported "
"by your system) connections."
msgstr "ä¸Šã§ä½œã£ãŸ SSL ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¯ TLSv1 ã‹ãã‚Œä»¥é™(ã‚ãªãŸã®ã‚·ã‚¹ãƒ†ãƒ ã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚Œã°)ã ã‘ã§ã®æ¥ç¶šã‚’è¨±å¯ã—ã¾ã™ã€‚"

#: ../../library/ssl.rst:1791
msgid "Cipher selection"
msgstr "æš—å·ã®é¸æŠ"

#: ../../library/ssl.rst:1793
msgid ""
"If you have advanced security requirements, fine-tuning of the ciphers "
"enabled when negotiating a SSL session is possible through the "
":meth:`SSLContext.set_ciphers` method.  Starting from Python 2.7.9, the ssl "
"module disables certain weak ciphers by default, but you may want to further"
" restrict the cipher choice. Be sure to read OpenSSL's documentation about "
"the `cipher list format <https://www.openssl.org/docs/apps/ciphers.html"
"#CIPHER-LIST-FORMAT>`_. If you want to check which ciphers are enabled by a "
"given cipher list, use the ``openssl ciphers`` command on your system."
msgstr ""

#: ../../library/ssl.rst:1803
msgid "Multi-processing"
msgstr "ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ã‚¹åŒ–"

#: ../../library/ssl.rst:1805
msgid ""
"If using this module as part of a multi-processed application (using, for "
"example the :mod:`multiprocessing` or :mod:`concurrent.futures` modules), be"
" aware that OpenSSL's internal random number generator does not properly "
"handle forked processes.  Applications must change the PRNG state of the "
"parent process if they use any SSL feature with :func:`os.fork`.  Any "
"successful call of :func:`~ssl.RAND_add`, :func:`~ssl.RAND_bytes` or "
":func:`~ssl.RAND_pseudo_bytes` is sufficient."
msgstr "(ä¾‹ãˆã° :mod:`multiprocessing` ã‚„ :mod:`concurrent.futures` ã‚’ä½¿ã£ã¦ã€)ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ã‚¹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ä¸€éƒ¨ã¨ã—ã¦ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã†å ´åˆã€OpenSSL ã®å†…éƒ¨ã®ä¹±æ•°ç™ºç”Ÿå™¨ã¯ fork ã—ãŸãƒ—ãƒ­ã‚»ã‚¹ã‚’é©åˆ‡ã«å‡¦ç†ã—ãªã„ã“ã¨ã«æ°—ã‚’ä»˜ã‘ã¦ä¸‹ã•ã„ã€‚SSL ã®æ©Ÿèƒ½ã‚’ :func:`os.fork` ã¨ã¨ã‚‚ã«ä½¿ã†å ´åˆã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯è¦ªãƒ—ãƒ­ã‚»ã‚¹ã® PRNG çŠ¶æ…‹ã‚’å¤‰æ›´ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ :func:`~ssl.RAND_add`, :func:`~ssl.RAND_bytes`, :func:`~ssl.RAND_pseudo_bytes` ã®ã„ãšã‚Œã‹ã®å‘¼ã³å‡ºã—æˆåŠŸãŒã‚ã‚Œã°ååˆ†ã§ã™ã€‚"

#: ../../library/ssl.rst:1817
msgid "LibreSSL support"
msgstr ""

#: ../../library/ssl.rst:1819
msgid ""
"LibreSSL is a fork of OpenSSL 1.0.1. The ssl module has limited support for "
"LibreSSL. Some features are not available when the ssl module is compiled "
"with LibreSSL."
msgstr ""

#: ../../library/ssl.rst:1823
msgid ""
"LibreSSL >= 2.6.1 no longer supports NPN. The methods "
":meth:`SSLContext.set_npn_protocols` and "
":meth:`SSLSocket.selected_npn_protocol` are not available."
msgstr ""

#: ../../library/ssl.rst:1826
msgid ""
":meth:`SSLContext.set_default_verify_paths` ignores the env vars "
":envvar:`SSL_CERT_FILE` and :envvar:`SSL_CERT_PATH` although "
":func:`get_default_verify_paths` still reports them."
msgstr ""

#: ../../library/ssl.rst:1834
msgid "Class :class:`socket.socket`"
msgstr ":class:`socket.socket` ã‚¯ãƒ©ã‚¹"

#: ../../library/ssl.rst:1834
msgid "Documentation of underlying :mod:`socket` class"
msgstr "ä¸‹ä½ãƒ¬ã‚¤ãƒ¤ãƒ¼ã® :mod:`socket` ã‚¯ãƒ©ã‚¹ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ"

#: ../../library/ssl.rst:1837
msgid ""
"`SSL/TLS Strong Encryption: An Introduction "
"<https://httpd.apache.org/docs/trunk/en/ssl/ssl_intro.html>`_"
msgstr "`SSL/TLS Strong Encryption: An Introduction <https://httpd.apache.org/docs/trunk/en/ssl/ssl_intro.html>`_"

#: ../../library/ssl.rst:1837
msgid "Intro from the Apache webserver documentation"
msgstr "Apache WEBã‚µãƒ¼ãƒã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚¤ãƒ³ãƒˆãƒ­"

#: ../../library/ssl.rst:1840
msgid ""
"`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: "
"Certificate-Based Key Management <https://www.ietf.org/rfc/rfc1422>`_"
msgstr "`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: Certificate-Based Key Management <https://www.ietf.org/rfc/rfc1422>`_"

#: ../../library/ssl.rst:1840
msgid "Steve Kent"
msgstr "Steve Kent"

#: ../../library/ssl.rst:1843
msgid ""
"`RFC 1750: Randomness Recommendations for Security "
"<https://www.ietf.org/rfc/rfc1750>`_"
msgstr "`RFC 1750: Randomness Recommendations for Security <https://www.ietf.org/rfc/rfc1750>`_"

#: ../../library/ssl.rst:1843
msgid "D. Eastlake et. al."
msgstr "D. Eastlake et. al."

#: ../../library/ssl.rst:1846
msgid ""
"`RFC 3280: Internet X.509 Public Key Infrastructure Certificate and CRL "
"Profile <https://www.ietf.org/rfc/rfc3280>`_"
msgstr "`RFC 3280: Internet X.509 Public Key Infrastructure Certificate and CRL Profile <https://www.ietf.org/rfc/rfc3280>`_"

#: ../../library/ssl.rst:1846
msgid "Housley et. al."
msgstr "Housley et. al."

#: ../../library/ssl.rst:1849
msgid ""
"`RFC 4366: Transport Layer Security (TLS) Extensions "
"<https://www.ietf.org/rfc/rfc4366>`_"
msgstr "`RFC 4366: Transport Layer Security (TLS) Extensions <https://www.ietf.org/rfc/rfc4366>`_"

#: ../../library/ssl.rst:1849
msgid "Blake-Wilson et. al."
msgstr "Blake-Wilson et. al."

#: ../../library/ssl.rst:1852
msgid ""
"`RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 "
"<https://tools.ietf.org/html/rfc5246>`_"
msgstr "`RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 <https://tools.ietf.org/html/rfc5246>`_"

#: ../../library/ssl.rst:1852
msgid "T. Dierks et. al."
msgstr "T. Dierks et. al."

#: ../../library/ssl.rst:1855
msgid ""
"`RFC 6066: Transport Layer Security (TLS) Extensions "
"<https://tools.ietf.org/html/rfc6066>`_"
msgstr "`RFC 6066: Transport Layer Security (TLS) Extensions <https://tools.ietf.org/html/rfc6066>`_"

#: ../../library/ssl.rst:1855
msgid "D. Eastlake"
msgstr "D. Eastlake"

#: ../../library/ssl.rst:1858
msgid ""
"`IANA TLS: Transport Layer Security (TLS) Parameters "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml>`_"
msgstr "`IANA TLS: Transport Layer Security (TLS) Parameters <https://www.iana.org/assignments/tls-parameters/tls-parameters.xml>`_"

#: ../../library/ssl.rst:1858
msgid "IANA"
msgstr "IANA"

#: ../../library/ssl.rst:1861
msgid ""
"`RFC 7525: Recommendations for Secure Use of Transport Layer Security (TLS) "
"and Datagram Transport Layer Security (DTLS) "
"<https://tools.ietf.org/html/rfc7525>`_"
msgstr ""

#: ../../library/ssl.rst:1861
msgid "IETF"
msgstr ""

#: ../../library/ssl.rst:1863
msgid ""
"`Mozilla's Server Side TLS recommendations "
"<https://wiki.mozilla.org/Security/Server_Side_TLS>`_"
msgstr ""

#: ../../library/ssl.rst:1864
msgid "Mozilla"
msgstr ""
