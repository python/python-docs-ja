# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# tomo, 2021
# Atsuo Ishimoto <atsuoishimoto@gmail.com>, 2021
# Yuto Oguchi, 2021
# Takeshi Nakazato, 2022
# souma987, 2022
# Tetsuo Koyama <tkoyama010@gmail.com>, 2022
# 菊池 健志, 2023
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-03 14:14+0000\n"
"PO-Revision-Date: 2021-06-28 00:55+0000\n"
"Last-Translator: 菊池 健志, 2023\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncio-task.rst:6
msgid "Coroutines and Tasks"
msgstr "コルーチンと Task"

#: ../../library/asyncio-task.rst:8
msgid ""
"This section outlines high-level asyncio APIs to work with coroutines and "
"Tasks."
msgstr ""
"この節では、コルーチンと Task を利用する高レベルの asyncio の API の概略を解"
"説します。"

#: ../../library/asyncio-task.rst:19 ../../library/asyncio-task.rst:148
msgid "Coroutines"
msgstr "コルーチン"

#: ../../library/asyncio-task.rst:21
msgid "**Source code:** :source:`Lib/asyncio/coroutines.py`"
msgstr ""

#: ../../library/asyncio-task.rst:25
msgid ""
":term:`Coroutines <coroutine>` declared with the async/await syntax is the "
"preferred way of writing asyncio applications.  For example, the following "
"snippet of code prints \"hello\", waits 1 second, and then prints \"world\"::"
msgstr ""
"async/await 構文で宣言された :term:`コルーチン <coroutine>` は、 asyncio を"
"使ったアプリケーションを書くのに推奨される方法です。例えば、次のコードスニ"
"ペットは \"hello\" を出力し、そこから 1 秒待って \"world\" を出力します:: "

#: ../../library/asyncio-task.rst:41
msgid ""
"Note that simply calling a coroutine will not schedule it to be executed::"
msgstr ""
"単にコルーチンを呼び出しただけでは、コルーチンの実行スケジュールは予約されて"
"いないことに注意してください::"

#: ../../library/asyncio-task.rst:47
msgid "To actually run a coroutine, asyncio provides the following mechanisms:"
msgstr ""
"実際にコルーチンを実行するために、asyncio は以下のメカニズムを提供していま"
"す::"

#: ../../library/asyncio-task.rst:49
msgid ""
"The :func:`asyncio.run` function to run the top-level entry point \"main()\" "
"function (see the above example.)"
msgstr ""
"最上位のエントリーポイントである \"main()\" 関数を実行する :func:`asyncio."
"run` 関数 (上の例を参照してください。)"

#: ../../library/asyncio-task.rst:52
msgid ""
"Awaiting on a coroutine.  The following snippet of code will print \"hello\" "
"after waiting for 1 second, and then print \"world\" after waiting for "
"*another* 2 seconds::"
msgstr ""
"コルーチンを await すること。次のコード片は 1 秒間待機した後に \"hello\" と出"
"力し、 *更に* 2 秒間待機してから \"world\" と出力します::"

#: ../../library/asyncio-task.rst:73
msgid "Expected output::"
msgstr "予想される出力::"

#: ../../library/asyncio-task.rst:80
msgid ""
"The :func:`asyncio.create_task` function to run coroutines concurrently as "
"asyncio :class:`Tasks <Task>`."
msgstr ""
"asyncio の :class:`Tasks <Task>` としてコルーチンを並行して走らせる :func:"
"`asyncio.create_task` 関数。"

#: ../../library/asyncio-task.rst:83
msgid ""
"Let's modify the above example and run two ``say_after`` coroutines "
"*concurrently*::"
msgstr ""
"上のコード例を編集して、ふたつの ``say_after`` コルーチンを *並行して* 走らせ"
"てみましょう::"

#: ../../library/asyncio-task.rst:102
msgid ""
"Note that expected output now shows that the snippet runs 1 second faster "
"than before::"
msgstr ""
"予想される出力が、スニペットの実行が前回よりも 1 秒早いことを示していることに"
"注意してください::"

#: ../../library/asyncio-task.rst:110
msgid ""
"The :class:`asyncio.TaskGroup` class provides a more modern alternative to :"
"func:`create_task`. Using this API, the last example becomes::"
msgstr ""

#: ../../library/asyncio-task.rst:128
msgid "The timing and output should be the same as for the previous version."
msgstr ""

#: ../../library/asyncio-task.rst:130
msgid ":class:`asyncio.TaskGroup`."
msgstr ":class:`asyncio.TaskGroup`."

#: ../../library/asyncio-task.rst:137
msgid "Awaitables"
msgstr "Awaitable"

#: ../../library/asyncio-task.rst:139
msgid ""
"We say that an object is an **awaitable** object if it can be used in an :"
"keyword:`await` expression.  Many asyncio APIs are designed to accept "
"awaitables."
msgstr ""
"あるオブジェクトを :keyword:`await` 式の中で使うことができる場合、そのオブ"
"ジェクトを **awaitable** オブジェクトと言います。多くの asyncio API は "
"awaitable を受け取るように設計されています。"

#: ../../library/asyncio-task.rst:143
msgid ""
"There are three main types of *awaitable* objects: **coroutines**, "
"**Tasks**, and **Futures**."
msgstr ""
"*awaitable* オブジェクトには主に3つの種類があります: **コルーチン**, "
"**Task**, そして **Future** です"

#: ../../library/asyncio-task.rst:149
msgid ""
"Python coroutines are *awaitables* and therefore can be awaited from other "
"coroutines::"
msgstr ""
"Python のコルーチンは *awaitable* であり、他のコルーチンから待機されることが"
"できます::"

#: ../../library/asyncio-task.rst:170
msgid ""
"In this documentation the term \"coroutine\" can be used for two closely "
"related concepts:"
msgstr ""
"このドキュメントにおいて「コルーチン」という用語は以下2つの密接に関連した概念"
"に対して使用できます:"

#: ../../library/asyncio-task.rst:173
msgid "a *coroutine function*: an :keyword:`async def` function;"
msgstr "*コルーチン関数*: :keyword:`async def` 関数;"

#: ../../library/asyncio-task.rst:175
msgid ""
"a *coroutine object*: an object returned by calling a *coroutine function*."
msgstr ""
"*コルーチンオブジェクト*: *コルーチン関数* を呼び出すと返ってくるオブジェク"
"ト."

#: ../../library/asyncio-task.rst:180
msgid "Tasks"
msgstr "Task"

#: ../../library/asyncio-task.rst:181
msgid "*Tasks* are used to schedule coroutines *concurrently*."
msgstr "*Task* は、コルーチンを *並行に* スケジュールするのに使います。"

#: ../../library/asyncio-task.rst:183
msgid ""
"When a coroutine is wrapped into a *Task* with functions like :func:`asyncio."
"create_task` the coroutine is automatically scheduled to run soon::"
msgstr ""
":func:`asyncio.create_task` のような関数で、コルーチンが *Task* にラップされ"
"ているとき、自動的にコルーチンは即時実行されるようにスケジュールされます::"

#: ../../library/asyncio-task.rst:205
msgid "Futures"
msgstr "Future"

#: ../../library/asyncio-task.rst:206
msgid ""
"A :class:`Future` is a special **low-level** awaitable object that "
"represents an **eventual result** of an asynchronous operation."
msgstr ""
":class:`Future` は、非同期処理の **最終結果** を表現する特別な **低レベルの"
"** awaitable オブジェクトです。"

#: ../../library/asyncio-task.rst:209
msgid ""
"When a Future object is *awaited* it means that the coroutine will wait "
"until the Future is resolved in some other place."
msgstr ""
"Future オブジェクトが *待機 (await) されている* とは、Future がどこか他の場所"
"で解決されるまでコルーチンが待機するということです。"

#: ../../library/asyncio-task.rst:212
msgid ""
"Future objects in asyncio are needed to allow callback-based code to be used "
"with async/await."
msgstr ""
"asyncioのFutureオブジェクトを使うと、async/awaitとコールバック形式のコードを"
"併用できます。"

#: ../../library/asyncio-task.rst:215
msgid ""
"Normally **there is no need** to create Future objects at the application "
"level code."
msgstr ""
"通常、アプリケーション水準のコードで Future オブジェクトを作る **必要はありま"
"せん** 。"

#: ../../library/asyncio-task.rst:218
msgid ""
"Future objects, sometimes exposed by libraries and some asyncio APIs, can be "
"awaited::"
msgstr ""
"Future オブジェクトはライブラリや asyncio の API で表に出ることもあり、他の "
"awaitable を待機させられます::"

#: ../../library/asyncio-task.rst:230
msgid ""
"A good example of a low-level function that returns a Future object is :meth:"
"`loop.run_in_executor`."
msgstr ""
"Future オブジェクトを返す低レベル関数の良い例は :meth:`loop.run_in_executor` "
"です。"

#: ../../library/asyncio-task.rst:235
msgid "Creating Tasks"
msgstr "Task の作成"

#: ../../library/asyncio-task.rst:237
msgid "**Source code:** :source:`Lib/asyncio/tasks.py`"
msgstr "**ソースコード:** :source:`Lib/asyncio/tasks.py`"

#: ../../library/asyncio-task.rst:243
msgid ""
"Wrap the *coro* :ref:`coroutine <coroutine>` into a :class:`Task` and "
"schedule its execution.  Return the Task object."
msgstr ""
"*coro* :ref:`coroutine <coroutine>` を :class:`Task` でラップし、その実行をス"
"ケジュールします。\n"
"Task オブジェクトを返します。"

#: ../../library/asyncio-task.rst:246
msgid ""
"If *name* is not ``None``, it is set as the name of the task using :meth:"
"`Task.set_name`."
msgstr ""
"もし *name* が ``None`` でない場合、:meth:`Task.set_name` を使用し、*name* が"
"タスクの名前として設定されます。"

#: ../../library/asyncio-task.rst:249
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *coro* to run in. The current context "
"copy is created when no *context* is provided."
msgstr ""
"省略可能なキーワード引数 *context* によって、*coro* を実行するためのカスタム"
"の :class:`contextvars.Context` を指定できます。*context* が省略された場合、"
"現在のコンテキストのコピーが作成されます。"

#: ../../library/asyncio-task.rst:253
msgid ""
"The task is executed in the loop returned by :func:`get_running_loop`, :exc:"
"`RuntimeError` is raised if there is no running loop in current thread."
msgstr ""
"その Task オブジェクトは :func:`get_running_loop` から返されたループの中で実"
"行されます。現在のスレッドに実行中のループが無い場合は、 :exc:`RuntimeError` "
"が送出されます。"

#: ../../library/asyncio-task.rst:259
msgid ""
":meth:`asyncio.TaskGroup.create_task` is a newer alternative that allows for "
"convenient waiting for a group of related tasks."
msgstr ""

#: ../../library/asyncio-task.rst:264
msgid ""
"Save a reference to the result of this function, to avoid a task "
"disappearing mid-execution. The event loop only keeps weak references to "
"tasks. A task that isn't referenced elsewhere may get garbage collected at "
"any time, even before it's done. For reliable \"fire-and-forget\" background "
"tasks, gather them in a collection::"
msgstr ""
"タスクが実行中に消えないように、この関数の結果の参照を保存してください。イベ"
"ントループは弱い参照のみを保持します。ほかに参照元のないタスクは、完了してい"
"なくてもガーベジコレクションされる可能性があります。信頼性のある \"fire-and-"
"forget\" バックグラウンドタスクが必要な場合、コレクションを使ってください。"

#: ../../library/asyncio-task.rst:286 ../../library/asyncio-task.rst:1009
msgid "Added the *name* parameter."
msgstr "*name* パラメータを追加しました。"

#: ../../library/asyncio-task.rst:289
msgid "Added the *context* parameter."
msgstr "*context* パラメータを追加しました。"

#: ../../library/asyncio-task.rst:294
msgid "Task Cancellation"
msgstr "タスクのキャンセル"

#: ../../library/asyncio-task.rst:296
msgid ""
"Tasks can easily and safely be cancelled. When a task is cancelled, :exc:"
"`asyncio.CancelledError` will be raised in the task at the next opportunity."
msgstr ""
"タスクは簡単に、そして安全にキャンセルできます。タスクがキャンセルされた場"
"合、:exc:`asyncio.CancelledError` が次の機会に送出されます。"

#: ../../library/asyncio-task.rst:300
msgid ""
"It is recommended that coroutines use ``try/finally`` blocks to robustly "
"perform clean-up logic. In case :exc:`asyncio.CancelledError` is explicitly "
"caught, it should generally be propagated when clean-up is complete. Most "
"code can safely ignore :exc:`asyncio.CancelledError`."
msgstr ""
"クリーンアップのロジックをロバストに実行するため、コルーチンは ``try/"
"finally`` ブロックを使うことが推奨されています。:exc:`asyncio."
"CancelledError` が明示的にキャッチされた場合、一般的にはクリーンアップが完了"
"したときに伝播されるべきです。ほとんどの場合 :exc:`asyncio.CancelledError` は"
"安全に無視できます。"

#: ../../library/asyncio-task.rst:305
msgid ""
"The asyncio components that enable structured concurrency, like :class:"
"`asyncio.TaskGroup` and :func:`asyncio.timeout`, are implemented using "
"cancellation internally and might misbehave if a coroutine swallows :exc:"
"`asyncio.CancelledError`. Similarly, user code should not call :meth:"
"`uncancel <asyncio.Task.uncancel>`."
msgstr ""

#: ../../library/asyncio-task.rst:314
msgid "Task Groups"
msgstr ""

#: ../../library/asyncio-task.rst:316
msgid ""
"Task groups combine a task creation API with a convenient and reliable way "
"to wait for all tasks in the group to finish."
msgstr ""

#: ../../library/asyncio-task.rst:321
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>` holding a "
"group of tasks. Tasks can be added to the group using :meth:`create_task`. "
"All tasks are awaited when the context manager exits."
msgstr ""

#: ../../library/asyncio-task.rst:330
msgid ""
"Create a task in this task group. The signature matches that of :func:"
"`asyncio.create_task`."
msgstr ""

#: ../../library/asyncio-task.rst:333 ../../library/asyncio-task.rst:463
#: ../../library/asyncio-task.rst:591 ../../library/asyncio-task.rst:655
#: ../../library/asyncio-task.rst:681 ../../library/asyncio-task.rst:724
#: ../../library/asyncio-task.rst:820
msgid "Example::"
msgstr "以下はプログラム例です::"

#: ../../library/asyncio-task.rst:341
msgid ""
"The ``async with`` statement will wait for all tasks in the group to finish. "
"While waiting, new tasks may still be added to the group (for example, by "
"passing ``tg`` into one of the coroutines and calling ``tg.create_task()`` "
"in that coroutine). Once the last task has finished and the ``async with`` "
"block is exited, no new tasks may be added to the group."
msgstr ""

#: ../../library/asyncio-task.rst:348
msgid ""
"The first time any of the tasks belonging to the group fails with an "
"exception other than :exc:`asyncio.CancelledError`, the remaining tasks in "
"the group are cancelled. No further tasks can then be added to the group. At "
"this point, if the body of the ``async with`` statement is still active (i."
"e., :meth:`~object.__aexit__` hasn't been called yet), the task directly "
"containing the ``async with`` statement is also cancelled. The resulting :"
"exc:`asyncio.CancelledError` will interrupt an ``await``, but it will not "
"bubble out of the containing ``async with`` statement."
msgstr ""

#: ../../library/asyncio-task.rst:358
msgid ""
"Once all tasks have finished, if any tasks have failed with an exception "
"other than :exc:`asyncio.CancelledError`, those exceptions are combined in "
"an :exc:`ExceptionGroup` or :exc:`BaseExceptionGroup` (as appropriate; see "
"their documentation) which is then raised."
msgstr ""

#: ../../library/asyncio-task.rst:365
msgid ""
"Two base exceptions are treated specially: If any task fails with :exc:"
"`KeyboardInterrupt` or :exc:`SystemExit`, the task group still cancels the "
"remaining tasks and waits for them, but then the initial :exc:"
"`KeyboardInterrupt` or :exc:`SystemExit` is re-raised instead of :exc:"
"`ExceptionGroup` or :exc:`BaseExceptionGroup`."
msgstr ""

#: ../../library/asyncio-task.rst:371
msgid ""
"If the body of the ``async with`` statement exits with an exception (so :"
"meth:`~object.__aexit__` is called with an exception set), this is treated "
"the same as if one of the tasks failed: the remaining tasks are cancelled "
"and then waited for, and non-cancellation exceptions are grouped into an "
"exception group and raised. The exception passed into :meth:`~object."
"__aexit__`, unless it is :exc:`asyncio.CancelledError`, is also included in "
"the exception group. The same special case is made for :exc:"
"`KeyboardInterrupt` and :exc:`SystemExit` as in the previous paragraph."
msgstr ""

#: ../../library/asyncio-task.rst:385
msgid "Sleeping"
msgstr "スリープ"

#: ../../library/asyncio-task.rst:389
msgid "Block for *delay* seconds."
msgstr "*delay* 秒だけ停止します。"

#: ../../library/asyncio-task.rst:391
msgid ""
"If *result* is provided, it is returned to the caller when the coroutine "
"completes."
msgstr ""
"*result* が提供されている場合は、コルーチン完了時にそれが呼び出し元に返されま"
"す。"

#: ../../library/asyncio-task.rst:394
msgid ""
"``sleep()`` always suspends the current task, allowing other tasks to run."
msgstr ""
"``sleep()`` は常に現在の Task を一時中断し、他の Task が実行されるのを許可し"
"ます。"

#: ../../library/asyncio-task.rst:397
msgid ""
"Setting the delay to 0 provides an optimized path to allow other tasks to "
"run. This can be used by long-running functions to avoid blocking the event "
"loop for the full duration of the function call."
msgstr ""
"delay を 0 に設定することで、他のタスクを実行可能にする最適な方針を提供しま"
"す。この方法は、実行時間の長い関数が、その実行時間全体にわたってイベントルー"
"プをブロックしないようにするために利用できます。"

#: ../../library/asyncio-task.rst:403
msgid ""
"Example of coroutine displaying the current date every second for 5 seconds::"
msgstr "現在の時刻を5秒間、毎秒表示するコルーチンの例::"

#: ../../library/asyncio-task.rst:421 ../../library/asyncio-task.rst:512
#: ../../library/asyncio-task.rst:566 ../../library/asyncio-task.rst:719
#: ../../library/asyncio-task.rst:749 ../../library/asyncio-task.rst:801
#: ../../library/asyncio-task.rst:817 ../../library/asyncio-task.rst:826
msgid "Removed the *loop* parameter."
msgstr ""

#: ../../library/asyncio-task.rst:426
msgid "Running Tasks Concurrently"
msgstr "並行な Task 実行"

#: ../../library/asyncio-task.rst:430
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* sequence "
"*concurrently*."
msgstr ""
"*aws* シーケンスにある :ref:`awaitable オブジェクト <asyncio-awaitables>` を "
"*並行* 実行します。"

#: ../../library/asyncio-task.rst:433
msgid ""
"If any awaitable in *aws* is a coroutine, it is automatically scheduled as a "
"Task."
msgstr ""
"*aws* にある awaitable がコルーチンである場合、自動的に Task としてスケジュー"
"ルされます。"

#: ../../library/asyncio-task.rst:436
msgid ""
"If all awaitables are completed successfully, the result is an aggregate "
"list of returned values.  The order of result values corresponds to the "
"order of awaitables in *aws*."
msgstr ""
"全ての awaitable が正常終了した場合、その結果は返り値を集めたリストになりま"
"す。\n"
"返り値の順序は、 *aws* での awaitable の順序に相当します。"

#: ../../library/asyncio-task.rst:440
msgid ""
"If *return_exceptions* is ``False`` (default), the first raised exception is "
"immediately propagated to the task that awaits on ``gather()``.  Other "
"awaitables in the *aws* sequence **won't be cancelled** and will continue to "
"run."
msgstr ""
"*return_exceptions* が ``False`` である場合(デフォルト)、``gather()`` で "
"await しているタスクに対して、最初の例外が直接伝えられます。*aws* に並んでい"
"る他の awaitable は、**キャンセルされずに** 引き続いて実行されます。"

#: ../../library/asyncio-task.rst:445
msgid ""
"If *return_exceptions* is ``True``, exceptions are treated the same as "
"successful results, and aggregated in the result list."
msgstr ""
"*return_exceptions* が ``True`` だった場合、例外は成功した結果と同じように取"
"り扱われ、結果リストに集められます。"

#: ../../library/asyncio-task.rst:448
msgid ""
"If ``gather()`` is *cancelled*, all submitted awaitables (that have not "
"completed yet) are also *cancelled*."
msgstr ""
"``gather()`` が *キャンセル* された場合、起動された全ての (未完了の) "
"awaitable も *キャンセル* されます。"

#: ../../library/asyncio-task.rst:451
msgid ""
"If any Task or Future from the *aws* sequence is *cancelled*, it is treated "
"as if it raised :exc:`CancelledError` -- the ``gather()`` call is **not** "
"cancelled in this case.  This is to prevent the cancellation of one "
"submitted Task/Future to cause other Tasks/Futures to be cancelled."
msgstr ""
"*aws* シーケンスにある Task あるいは Future が *キャンセル* された場合、 :"
"exc:`CancelledError` を送出したかのうように扱われます。つまり、この場合 "
"``gather()`` 呼び出しはキャンセル *されません*。\n"
"これは、起動された 1 つの Task あるいは Future のキャンセルが、他の Task ある"
"いは Future のキャンセルを引き起こすのを避けるためです。"

#: ../../library/asyncio-task.rst:458
msgid ""
"A more modern way to create and run tasks concurrently and wait for their "
"completion is :class:`asyncio.TaskGroup`."
msgstr ""

#: ../../library/asyncio-task.rst:501
msgid ""
"If *return_exceptions* is False, cancelling gather() after it has been "
"marked done won't cancel any submitted awaitables. For instance, gather can "
"be marked done after propagating an exception to the caller, therefore, "
"calling ``gather.cancel()`` after catching an exception (raised by one of "
"the awaitables) from gather won't cancel any other awaitables."
msgstr ""
"*return_exceptions* が False の場合、いったん完了状態となった gather() をキャ"
"ンセルしても起動された awaitables がキャンセルされないことがあります。例え"
"ば、 gather は例外を呼び出し元に送出したあと完了状態になることがあるため、 "
"(起動した awaitable のいずれかから送出された) gather からの例外をキャッチした"
"後で ``gather.cancel()`` を呼び出しても、他の awaitable がキャンセルされない"
"可能性があります。"

#: ../../library/asyncio-task.rst:508
msgid ""
"If the *gather* itself is cancelled, the cancellation is propagated "
"regardless of *return_exceptions*."
msgstr ""
"*gather* 自身がキャンセルされた場合は、 *return_exceptions* の値に関わらず"
"キャンセルが伝搬されます。"

#: ../../library/asyncio-task.rst:515
msgid ""
"Deprecation warning is emitted if no positional arguments are provided or "
"not all positional arguments are Future-like objects and there is no running "
"event loop."
msgstr ""

#: ../../library/asyncio-task.rst:522
msgid "Shielding From Cancellation"
msgstr "キャンセルからの保護"

#: ../../library/asyncio-task.rst:526
msgid ""
"Protect an :ref:`awaitable object <asyncio-awaitables>` from being :meth:"
"`cancelled <Task.cancel>`."
msgstr ""
":meth:`キャンセル <Task.cancel>` から :ref:`awaitable オブジェクト <asyncio-"
"awaitables>` を保護します。"

#: ../../library/asyncio-task.rst:529 ../../library/asyncio-task.rst:701
msgid "If *aw* is a coroutine it is automatically scheduled as a Task."
msgstr ""
"*aw* がコルーチンだった場合、自動的に Task としてスケジュールされます。"

#: ../../library/asyncio-task.rst:531
msgid "The statement::"
msgstr "文::"

#: ../../library/asyncio-task.rst:536
msgid "is equivalent to::"
msgstr "は、以下と同じです ::"

#: ../../library/asyncio-task.rst:540
msgid ""
"*except* that if the coroutine containing it is cancelled, the Task running "
"in ``something()`` is not cancelled.  From the point of view of "
"``something()``, the cancellation did not happen. Although its caller is "
"still cancelled, so the \"await\" expression still raises a :exc:"
"`CancelledError`."
msgstr ""
"それを含むコルーチンがキャンセルされた場合を *除き*、``something()`` 内で動作"
"している Task はキャンセルされません。\n"
"``something()`` 側から見るとキャンセルは発生しません。\n"
"呼び出し元がキャンセルされた場合でも、 \"await\" 式は :exc:`CancelledError` "
"を送出します。"

#: ../../library/asyncio-task.rst:546
msgid ""
"If ``something()`` is cancelled by other means (i.e. from within itself) "
"that would also cancel ``shield()``."
msgstr ""
"注意: ``something()`` が他の理由 (例えば、原因が自分自身) でキャンセルされた"
"場合は ``shield()`` でも保護できません。"

#: ../../library/asyncio-task.rst:549
msgid ""
"If it is desired to completely ignore cancellation (not recommended) the "
"``shield()`` function should be combined with a try/except clause, as "
"follows::"
msgstr ""
"完全にキャンセルを無視したい場合 (推奨はしません) は、 ``shield()`` 関数は次"
"のように try/except 節と組み合わせることになるでしょう::"

#: ../../library/asyncio-task.rst:561
msgid ""
"Save a reference to tasks passed to this function, to avoid a task "
"disappearing mid-execution. The event loop only keeps weak references to "
"tasks. A task that isn't referenced elsewhere may get garbage collected at "
"any time, even before it's done."
msgstr ""

#: ../../library/asyncio-task.rst:569
msgid ""
"Deprecation warning is emitted if *aw* is not Future-like object and there "
"is no running event loop."
msgstr ""

#: ../../library/asyncio-task.rst:575
msgid "Timeouts"
msgstr "タイムアウト"

#: ../../library/asyncio-task.rst:579
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>` that can be "
"used to limit the amount of time spent waiting on something."
msgstr ""

#: ../../library/asyncio-task.rst:583
msgid ""
"*delay* can either be ``None``, or a float/int number of seconds to wait. If "
"*delay* is ``None``, no time limit will be applied; this can be useful if "
"the delay is unknown when the context manager is created."
msgstr ""

#: ../../library/asyncio-task.rst:588
msgid ""
"In either case, the context manager can be rescheduled after creation using :"
"meth:`Timeout.reschedule`."
msgstr ""

#: ../../library/asyncio-task.rst:597
msgid ""
"If ``long_running_task`` takes more than 10 seconds to complete, the context "
"manager will cancel the current task and handle the resulting :exc:`asyncio."
"CancelledError` internally, transforming it into an :exc:`asyncio."
"TimeoutError` which can be caught and handled."
msgstr ""

#: ../../library/asyncio-task.rst:604
msgid ""
"The :func:`asyncio.timeout` context manager is what transforms the :exc:"
"`asyncio.CancelledError` into an :exc:`asyncio.TimeoutError`, which means "
"the :exc:`asyncio.TimeoutError` can only be caught *outside* of the context "
"manager."
msgstr ""

#: ../../library/asyncio-task.rst:609
msgid "Example of catching :exc:`asyncio.TimeoutError`::"
msgstr ""

#: ../../library/asyncio-task.rst:620
msgid ""
"The context manager produced by :func:`asyncio.timeout` can be rescheduled "
"to a different deadline and inspected."
msgstr ""

#: ../../library/asyncio-task.rst:625
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>` that limits "
"time spent inside of it."
msgstr ""

#: ../../library/asyncio-task.rst:632
msgid ""
"Return the current deadline, or ``None`` if the current deadline is not set."
msgstr ""

#: ../../library/asyncio-task.rst:635
msgid ""
"The deadline is a float, consistent with the time returned by :meth:`loop."
"time`."
msgstr ""

#: ../../library/asyncio-task.rst:640
msgid "Change the time the timeout will trigger."
msgstr ""

#: ../../library/asyncio-task.rst:642
msgid ""
"If *when* is ``None``, any current deadline will be removed, and the context "
"manager will wait indefinitely."
msgstr ""

#: ../../library/asyncio-task.rst:645
msgid "If *when* is a float, it is set as the new deadline."
msgstr ""

#: ../../library/asyncio-task.rst:647
msgid ""
"if *when* is in the past, the timeout will trigger on the next iteration of "
"the event loop."
msgstr ""

#: ../../library/asyncio-task.rst:652
msgid "Return whether the context manager has exceeded its deadline (expired)."
msgstr ""

#: ../../library/asyncio-task.rst:672
msgid "Timeout context managers can be safely nested."
msgstr ""

#: ../../library/asyncio-task.rst:678
msgid ""
"Similar to :func:`asyncio.timeout`, except *when* is the absolute time to "
"stop waiting, or ``None``."
msgstr ""

#: ../../library/asyncio-task.rst:698
msgid ""
"Wait for the *aw* :ref:`awaitable <asyncio-awaitables>` to complete with a "
"timeout."
msgstr ""
"*aw* :ref:`awaitable <asyncio-awaitables>` が、完了するかタイムアウトになるの"
"を待ちます。"

#: ../../library/asyncio-task.rst:703
msgid ""
"*timeout* can either be ``None`` or a float or int number of seconds to wait "
"for.  If *timeout* is ``None``, block until the future completes."
msgstr ""
"*timeout* には ``None`` もしくは待つ秒数の浮動小数点数か整数を指定できま"
"す。\n"
"*timeout* が ``None`` の場合、 Future が完了するまで待ちます。"

#: ../../library/asyncio-task.rst:707
msgid ""
"If a timeout occurs, it cancels the task and raises :exc:`TimeoutError`."
msgstr ""

#: ../../library/asyncio-task.rst:710
msgid ""
"To avoid the task :meth:`cancellation <Task.cancel>`, wrap it in :func:"
"`shield`."
msgstr ""
"Task の :meth:`キャンセル <Task.cancel>` を避けるためには、 :func:`shield` の"
"中にラップしてください。"

#: ../../library/asyncio-task.rst:713
msgid ""
"The function will wait until the future is actually cancelled, so the total "
"wait time may exceed the *timeout*. If an exception happens during "
"cancellation, it is propagated."
msgstr ""
"この関数は future が実際にキャンセルされるまで待つため、待ち時間の合計は "
"*timeout*  を超えることがあります。キャンセル中に例外が発生した場合は、その例"
"外は伝達されます。"

#: ../../library/asyncio-task.rst:717
msgid "If the wait is cancelled, the future *aw* is also cancelled."
msgstr "待機が中止された場合 *aw* も中止されます。"

#: ../../library/asyncio-task.rst:744
msgid ""
"When *aw* is cancelled due to a timeout, ``wait_for`` waits for *aw* to be "
"cancelled.  Previously, it raised :exc:`TimeoutError` immediately."
msgstr ""

#: ../../library/asyncio-task.rst:754
msgid "Waiting Primitives"
msgstr "要素の終了待機"

#: ../../library/asyncio-task.rst:758
msgid ""
"Run :class:`~asyncio.Future` and :class:`~asyncio.Task` instances in the "
"*aws* iterable concurrently and block until the condition specified by "
"*return_when*."
msgstr ""

#: ../../library/asyncio-task.rst:762
msgid "The *aws* iterable must not be empty."
msgstr "イテラブル *aws* は空であってはなりません。"

#: ../../library/asyncio-task.rst:764
msgid "Returns two sets of Tasks/Futures: ``(done, pending)``."
msgstr "Task/Future からなる 2 つの集合 ``(done, pending)`` を返します。"

#: ../../library/asyncio-task.rst:766
msgid "Usage::"
msgstr "使い方::"

#: ../../library/asyncio-task.rst:770
msgid ""
"*timeout* (a float or int), if specified, can be used to control the maximum "
"number of seconds to wait before returning."
msgstr ""
"*timeout* (浮動小数点数または整数) が指定されていたら、処理を返すのを待つ最大"
"秒数を制御するのに使われます。"

#: ../../library/asyncio-task.rst:773
msgid ""
"Note that this function does not raise :exc:`TimeoutError`. Futures or Tasks "
"that aren't done when the timeout occurs are simply returned in the second "
"set."
msgstr ""

#: ../../library/asyncio-task.rst:777
msgid ""
"*return_when* indicates when this function should return.  It must be one of "
"the following constants:"
msgstr ""
"*return_when* でこの関数がいつ結果を返すか指定します。指定できる値は以下の 定"
"数のどれか一つです:"

#: ../../library/asyncio-task.rst:783
msgid "Constant"
msgstr "定数"

#: ../../library/asyncio-task.rst:783
msgid "Description"
msgstr "説明"

#: ../../library/asyncio-task.rst:785
msgid ":const:`FIRST_COMPLETED`"
msgstr ":const:`FIRST_COMPLETED`"

#: ../../library/asyncio-task.rst:785
msgid "The function will return when any future finishes or is cancelled."
msgstr "いずれかのフューチャが終了したかキャンセルされたときに返します。"

#: ../../library/asyncio-task.rst:788
msgid ":const:`FIRST_EXCEPTION`"
msgstr ":const:`FIRST_EXCEPTION`"

#: ../../library/asyncio-task.rst:788
msgid ""
"The function will return when any future finishes by raising an exception.  "
"If no future raises an exception then it is equivalent to :const:"
"`ALL_COMPLETED`."
msgstr ""
"いずれかのフューチャが例外の送出で終了した場合に返します。例外を送出した"
"フューチャがない場合は、:const:`ALL_COMPLETED` と等価になります。"

#: ../../library/asyncio-task.rst:794
msgid ":const:`ALL_COMPLETED`"
msgstr ":const:`ALL_COMPLETED`"

#: ../../library/asyncio-task.rst:794
msgid "The function will return when all futures finish or are cancelled."
msgstr "すべてのフューチャが終了したかキャンセルされたときに返します。"

#: ../../library/asyncio-task.rst:798
msgid ""
"Unlike :func:`~asyncio.wait_for`, ``wait()`` does not cancel the futures "
"when a timeout occurs."
msgstr ""
":func:`~asyncio.wait_for` と異なり、  ``wait()`` はタイムアウトが起きたとき"
"に Future をキャンセルしません。"

#: ../../library/asyncio-task.rst:804
msgid "Passing coroutine objects to ``wait()`` directly is forbidden."
msgstr ""

#: ../../library/asyncio-task.rst:809
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* iterable "
"concurrently.  Return an iterator of coroutines. Each coroutine returned can "
"be awaited to get the earliest next result from the iterable of the "
"remaining awaitables."
msgstr ""
"イテラブル *aws* 内の :ref:`awaitable オブジェクト <asyncio-awaitables>` を並"
"列実行します。コルーチンのイテレータを返します。戻り値の各コルーチンは、残り"
"の awaitable のうちで最も早く得られた結果を待ち受けることができます。"

#: ../../library/asyncio-task.rst:814
msgid ""
"Raises :exc:`TimeoutError` if the timeout occurs before all Futures are done."
msgstr ""

#: ../../library/asyncio-task.rst:829
msgid ""
"Deprecation warning is emitted if not all awaitable objects in the *aws* "
"iterable are Future-like objects and there is no running event loop."
msgstr ""

#: ../../library/asyncio-task.rst:835
msgid "Running in Threads"
msgstr "スレッド内での実行"

#: ../../library/asyncio-task.rst:839
msgid "Asynchronously run function *func* in a separate thread."
msgstr "別のスレッドで非同期的に関数 *func* を実行します。"

#: ../../library/asyncio-task.rst:841
msgid ""
"Any \\*args and \\*\\*kwargs supplied for this function are directly passed "
"to *func*. Also, the current :class:`contextvars.Context` is propagated, "
"allowing context variables from the event loop thread to be accessed in the "
"separate thread."
msgstr ""
"この関数に渡された \\*args と \\*\\*kwargs は関数 *func* に直接渡されます。ま"
"た、イベントループスレッドのコンテキスト変数に関数を実行するスレッドからアク"
"セスできるように、現在の :class:`contextvars.Context` も伝播されます。"

#: ../../library/asyncio-task.rst:846
msgid ""
"Return a coroutine that can be awaited to get the eventual result of *func*."
msgstr "関数 *func* の最終結果を待ち受けできるコルーチンを返します。"

#: ../../library/asyncio-task.rst:848
msgid ""
"This coroutine function is primarily intended to be used for executing IO-"
"bound functions/methods that would otherwise block the event loop if they "
"were run in the main thread. For example::"
msgstr ""

#: ../../library/asyncio-task.rst:878
msgid ""
"Directly calling ``blocking_io()`` in any coroutine would block the event "
"loop for its duration, resulting in an additional 1 second of run time. "
"Instead, by using ``asyncio.to_thread()``, we can run it in a separate "
"thread without blocking the event loop."
msgstr ""

#: ../../library/asyncio-task.rst:885
msgid ""
"Due to the :term:`GIL`, ``asyncio.to_thread()`` can typically only be used "
"to make IO-bound functions non-blocking. However, for extension modules that "
"release the GIL or alternative Python implementations that don't have one, "
"``asyncio.to_thread()`` can also be used for CPU-bound functions."
msgstr ""

#: ../../library/asyncio-task.rst:894
msgid "Scheduling From Other Threads"
msgstr "外部スレッドからのスケジュール"

#: ../../library/asyncio-task.rst:898
msgid "Submit a coroutine to the given event loop.  Thread-safe."
msgstr ""
"与えられたイベントループにコルーチンを送ります。\n"
"この処理は、スレッドセーフです。"

#: ../../library/asyncio-task.rst:900
msgid ""
"Return a :class:`concurrent.futures.Future` to wait for the result from "
"another OS thread."
msgstr ""
"他の OS スレッドから結果を待つための :class:`concurrent.futures.Future` を返"
"します。"

#: ../../library/asyncio-task.rst:903
msgid ""
"This function is meant to be called from a different OS thread than the one "
"where the event loop is running.  Example::"
msgstr ""
"この関数は、イベントループが動作しているスレッドとは異なる OS スレッドから呼"
"び出すためのものです。\n"
"例えば次のように使います::"

#: ../../library/asyncio-task.rst:915
msgid ""
"If an exception is raised in the coroutine, the returned Future will be "
"notified.  It can also be used to cancel the task in the event loop::"
msgstr ""
"コルーチンから例外が送出された場合、返された Future に通知されます。\n"
"これはイベントループの Task をキャンセルするのにも使えます::"

#: ../../library/asyncio-task.rst:929
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"このドキュメントの :ref:`asyncio-multithreading` 節を参照してください。"

#: ../../library/asyncio-task.rst:932
msgid ""
"Unlike other asyncio functions this function requires the *loop* argument to "
"be passed explicitly."
msgstr ""
"他の asyncio 関数とは異なり、この関数は明示的に渡される *loop* 引数を必要とし"
"ます。"

#: ../../library/asyncio-task.rst:939
msgid "Introspection"
msgstr "イントロスペクション"

#: ../../library/asyncio-task.rst:944
msgid ""
"Return the currently running :class:`Task` instance, or ``None`` if no task "
"is running."
msgstr ""
"現在実行中の :class:`Task` インスタンスを返します。実行中の Task が無い場合"
"は ``None`` を返します。"

#: ../../library/asyncio-task.rst:947
msgid ""
"If *loop* is ``None`` :func:`get_running_loop` is used to get the current "
"loop."
msgstr ""
"*loop* が ``None`` の場合、 :func:`get_running_loop` が現在のループを取得する"
"のに使われます。"

#: ../../library/asyncio-task.rst:955
msgid "Return a set of not yet finished :class:`Task` objects run by the loop."
msgstr ""
"ループで実行された :class:`Task` オブジェクトでまだ完了していないものの集合を"
"返します。"

#: ../../library/asyncio-task.rst:958
msgid ""
"If *loop* is ``None``, :func:`get_running_loop` is used for getting current "
"loop."
msgstr ""
"*loop* が ``None`` の場合、 :func:`get_running_loop` は現在のループを取得する"
"のに使われます。"

#: ../../library/asyncio-task.rst:965
msgid "Task Object"
msgstr "Task オブジェクト"

#: ../../library/asyncio-task.rst:969
msgid ""
"A :class:`Future-like <Future>` object that runs a Python :ref:`coroutine "
"<coroutine>`.  Not thread-safe."
msgstr ""
"Python :ref:`コルーチン <coroutine>` を実行する :class:`Future 類 <Future>` "
"オブジェクトです。\n"
"スレッドセーフではありません。"

#: ../../library/asyncio-task.rst:972
msgid ""
"Tasks are used to run coroutines in event loops. If a coroutine awaits on a "
"Future, the Task suspends the execution of the coroutine and waits for the "
"completion of the Future.  When the Future is *done*, the execution of the "
"wrapped coroutine resumes."
msgstr ""
"Task はイベントループのコルーチンを実行するのに使われます。\n"
"Future でコルーチンが待機している場合、 Task は自身のコルーチンの実行を一時停"
"止させ、 Future の完了を待ちます。\n"
"Future が *完了* したら、 Task が内包しているコルーチンの実行を再開します。"

#: ../../library/asyncio-task.rst:978
msgid ""
"Event loops use cooperative scheduling: an event loop runs one Task at a "
"time.  While a Task awaits for the completion of a Future, the event loop "
"runs other Tasks, callbacks, or performs IO operations."
msgstr ""
"イベントループは協調スケジューリングを使用します。つまり、イベントループは同"
"時に 1 つの Task のみ実行します。\n"
"Task が Future の完了を待っているときは、イベントループは他の Task やコール"
"バックを動作させるか、 IO 処理を実行します。"

#: ../../library/asyncio-task.rst:983
msgid ""
"Use the high-level :func:`asyncio.create_task` function to create Tasks, or "
"the low-level :meth:`loop.create_task` or :func:`ensure_future` functions.  "
"Manual instantiation of Tasks is discouraged."
msgstr ""
"Task を作成するには高レベルの :func:`asyncio.create_task` 関数、あるいは低レ"
"ベルの :meth:`loop.create_task` 関数や :func:`ensure_future` 関数を使用してく"
"ださい。\n"
"手作業での Task の実装は推奨されません。"

#: ../../library/asyncio-task.rst:988
msgid ""
"To cancel a running Task use the :meth:`cancel` method.  Calling it will "
"cause the Task to throw a :exc:`CancelledError` exception into the wrapped "
"coroutine.  If a coroutine is awaiting on a Future object during "
"cancellation, the Future object will be cancelled."
msgstr ""
"実行中のタスクをキャンセルするためには、:meth:`cancel` メソッドを使用します。"
"このメソッドを呼ぶと、タスクはそれを内包するコルーチンに対して :exc:"
"`CancelledError` 例外を送出します。キャンセルの際にコルーチンが Future オブ"
"ジェクトを待っていた場合、その Future オブジェクトはキャンセルされます。"

#: ../../library/asyncio-task.rst:993
msgid ""
":meth:`cancelled` can be used to check if the Task was cancelled. The method "
"returns ``True`` if the wrapped coroutine did not suppress the :exc:"
"`CancelledError` exception and was actually cancelled."
msgstr ""
":meth:`cancelled` は、タスクがキャンセルされたかを調べるのに使用できます。タ"
"スクを内包するコルーチンで :exc:`CancelledError` 例外が抑制されておらず、かつ"
"タスクが実際にキャンセルされている場合に、このメソッドは ``True`` を変えま"
"す。"

#: ../../library/asyncio-task.rst:998
msgid ""
":class:`asyncio.Task` inherits from :class:`Future` all of its APIs except :"
"meth:`Future.set_result` and :meth:`Future.set_exception`."
msgstr ""
":class:`asyncio.Task` は、:meth:`Future.set_result` と :meth:`Future."
"set_exception` を除いて、:class:`Future` の API をすべて継承しています。"

#: ../../library/asyncio-task.rst:1002
msgid ""
"Tasks support the :mod:`contextvars` module.  When a Task is created it "
"copies the current context and later runs its coroutine in the copied "
"context."
msgstr ""
"Task は :mod:`contextvars` モジュールをサポートします。Task が作られたときに"
"現在のコンテキストがコピーされ、のちに Task のコルーチンを実行する際に、コ"
"ピーされたコンテキストが使用されます。"

#: ../../library/asyncio-task.rst:1006
msgid "Added support for the :mod:`contextvars` module."
msgstr ":mod:`contextvars` モジュールのサポートを追加。"

#: ../../library/asyncio-task.rst:1012
msgid ""
"Deprecation warning is emitted if *loop* is not specified and there is no "
"running event loop."
msgstr ""

#: ../../library/asyncio-task.rst:1018
msgid "Return ``True`` if the Task is *done*."
msgstr "Task が *完了* しているなら ``True`` を返します。"

#: ../../library/asyncio-task.rst:1020
msgid ""
"A Task is *done* when the wrapped coroutine either returned a value, raised "
"an exception, or the Task was cancelled."
msgstr ""
"Task がラップしているコルーチンが値を返すか、例外を送出するか、または Task が"
"キャンセルされたとき、 Task は *完了* します。"

#: ../../library/asyncio-task.rst:1025
msgid "Return the result of the Task."
msgstr "Task の結果を返します。"

#: ../../library/asyncio-task.rst:1027
msgid ""
"If the Task is *done*, the result of the wrapped coroutine is returned (or "
"if the coroutine raised an exception, that exception is re-raised.)"
msgstr ""
"Task が *完了* している場合、ラップしているコルーチンの結果が返されます (コ"
"ルーチンが例外を送出された場合、その例外が例外が再送出されます)"

#: ../../library/asyncio-task.rst:1031 ../../library/asyncio-task.rst:1045
msgid ""
"If the Task has been *cancelled*, this method raises a :exc:`CancelledError` "
"exception."
msgstr ""
"Task が *キャンセル* されている場合、このメソッドは :exc:`CancelledError` 例"
"外を送出します。"

#: ../../library/asyncio-task.rst:1034
msgid ""
"If the Task's result isn't yet available, this method raises a :exc:"
"`InvalidStateError` exception."
msgstr ""
"Task の結果がまだ未設定の場合、このメソッドは :exc:`InvalidStateError` 例外を"
"送出します。"

#: ../../library/asyncio-task.rst:1039
msgid "Return the exception of the Task."
msgstr "Task の例外を返します。"

#: ../../library/asyncio-task.rst:1041
msgid ""
"If the wrapped coroutine raised an exception that exception is returned.  If "
"the wrapped coroutine returned normally this method returns ``None``."
msgstr ""
"ラップされたコルーチンが例外を送出した場合、その例外が返されます。ラップされ"
"たコルーチンが正常終了した場合、このメソッドは ``None`` を返します。"

#: ../../library/asyncio-task.rst:1048
msgid ""
"If the Task isn't *done* yet, this method raises an :exc:`InvalidStateError` "
"exception."
msgstr ""
"Task がまだ *完了* していない場合、このメソッドは :exc:`InvalidStateError` 例"
"外を送出します。"

#: ../../library/asyncio-task.rst:1053
msgid "Add a callback to be run when the Task is *done*."
msgstr "Task が *完了* したときに実行されるコールバックを追加します。"

#: ../../library/asyncio-task.rst:1055 ../../library/asyncio-task.rst:1064
msgid "This method should only be used in low-level callback-based code."
msgstr "このメソッドは低水準のコールバックベースのコードでのみ使うべきです。"

#: ../../library/asyncio-task.rst:1057
msgid ""
"See the documentation of :meth:`Future.add_done_callback` for more details."
msgstr ""
"詳細については :meth:`Future.add_done_callback` のドキュメントを参照してくだ"
"さい。"

#: ../../library/asyncio-task.rst:1062
msgid "Remove *callback* from the callbacks list."
msgstr "コールバックリストから *callback* を削除します。"

#: ../../library/asyncio-task.rst:1066
msgid ""
"See the documentation of :meth:`Future.remove_done_callback` for more "
"details."
msgstr ""
"詳細については :meth:`Future.remove_done_callback` のドキュメントを参照してく"
"ださい。"

#: ../../library/asyncio-task.rst:1071
msgid "Return the list of stack frames for this Task."
msgstr "このタスクのスタックフレームのリストを返します。"

#: ../../library/asyncio-task.rst:1073
msgid ""
"If the wrapped coroutine is not done, this returns the stack where it is "
"suspended.  If the coroutine has completed successfully or was cancelled, "
"this returns an empty list. If the coroutine was terminated by an exception, "
"this returns the list of traceback frames."
msgstr ""
"コルーチンが完了していない場合、これはサスペンドされた時点でのスタックを返し"
"ます。コルーチンが正常に処理を完了したか、キャンセルされていた場合は空のリス"
"トを返します。コルーチンが例外で終了した場合はトレースバックフレームのリスト"
"を返します。"

#: ../../library/asyncio-task.rst:1079
msgid "The frames are always ordered from oldest to newest."
msgstr "フレームは常に古いものから新しい物へ並んでいます。"

#: ../../library/asyncio-task.rst:1081
msgid "Only one stack frame is returned for a suspended coroutine."
msgstr ""
"サスペンドされているコルーチンの場合スタックフレームが 1 個だけ返されます。"

#: ../../library/asyncio-task.rst:1083
msgid ""
"The optional *limit* argument sets the maximum number of frames to return; "
"by default all available frames are returned. The ordering of the returned "
"list differs depending on whether a stack or a traceback is returned: the "
"newest frames of a stack are returned, but the oldest frames of a traceback "
"are returned.  (This matches the behavior of the traceback module.)"
msgstr ""
"オプション引数 *limit* は返すフレームの最大数を指定します; デフォルトでは取得"
"可能な全てのフレームを返します。返されるリストの順番は、スタックが返される"
"か、トレースバックが返されるかによって変わります: スタックでは新しい順に並ん"
"だリストが返されますが、トレースバックでは古い順に並んだリストが返されます"
"（これは traceback モジュールの振る舞いと一致します）。"

#: ../../library/asyncio-task.rst:1092
msgid "Print the stack or traceback for this Task."
msgstr "このタスクのスタックまたはトレースバックを出力します。"

#: ../../library/asyncio-task.rst:1094
msgid ""
"This produces output similar to that of the traceback module for the frames "
"retrieved by :meth:`get_stack`."
msgstr ""
"このメソッドは :meth:`get_stack` によって取得されるフレームに対し、 "
"traceback モジュールと同じような出力を生成します。"

#: ../../library/asyncio-task.rst:1097
msgid "The *limit* argument is passed to :meth:`get_stack` directly."
msgstr "引数 *limit* は :meth:`get_stack` にそのまま渡されます。"

#: ../../library/asyncio-task.rst:1099
msgid ""
"The *file* argument is an I/O stream to which the output is written; by "
"default output is written to :data:`sys.stdout`."
msgstr ""

#: ../../library/asyncio-task.rst:1104
msgid "Return the coroutine object wrapped by the :class:`Task`."
msgstr ":class:`Task` がラップしているコルーチンオブジェクトを返します。"

#: ../../library/asyncio-task.rst:1110
msgid "Return the name of the Task."
msgstr "Task の名前を返します。"

#: ../../library/asyncio-task.rst:1112
msgid ""
"If no name has been explicitly assigned to the Task, the default asyncio "
"Task implementation generates a default name during instantiation."
msgstr ""
"Task に対して明示的に名前が設定されていない場合, デフォルトの asyncio Task 実"
"装はタスクをインスタンス化する際にデフォルトの名前を生成します。"

#: ../../library/asyncio-task.rst:1120
msgid "Set the name of the Task."
msgstr "Task に名前を設定します。"

#: ../../library/asyncio-task.rst:1122
msgid ""
"The *value* argument can be any object, which is then converted to a string."
msgstr ""
"引数 *value* は文字列に変換可能なオブジェクトであれば何でもかまいません。"

#: ../../library/asyncio-task.rst:1125
msgid ""
"In the default Task implementation, the name will be visible in the :func:"
"`repr` output of a task object."
msgstr ""
"Task のデフォルト実装では、名前はオブジェクトの :func:`repr` メソッドの出力で"
"確認できます。"

#: ../../library/asyncio-task.rst:1132
msgid "Request the Task to be cancelled."
msgstr "このタスクに、自身のキャンセルを要求します。"

#: ../../library/asyncio-task.rst:1134
msgid ""
"This arranges for a :exc:`CancelledError` exception to be thrown into the "
"wrapped coroutine on the next cycle of the event loop."
msgstr ""
"このメソッドは、イベントループの次のステップにおいて、タスクがラップしている"
"コルーチン内で :exc:`CancelledError` 例外が送出されるように準備します。"

#: ../../library/asyncio-task.rst:1137
msgid ""
"The coroutine then has a chance to clean up or even deny the request by "
"suppressing the exception with a :keyword:`try` ... ... ``except "
"CancelledError`` ... :keyword:`finally` block. Therefore, unlike :meth:"
"`Future.cancel`, :meth:`Task.cancel` does not guarantee that the Task will "
"be cancelled, although suppressing cancellation completely is not common and "
"is actively discouraged."
msgstr ""
"コルーチン側では :keyword:`try` ... ... ``except CancelledError`` ... :"
"keyword:`finally` ブロックで例外を処理することにより、クリーンアップ処理を行"
"なったり、リクエストを拒否したりする機会が与えられます。この特性を使ってキャ"
"ンセル処理を完全に抑え込むことも可能であることから、 :meth:`Future.cancel` と"
"異なり、 :meth:`Task.cancel` は Task が実際にキャンセルされることを保証しませ"
"ん。ただしそのような処理は一般的ではありませんし、そのような処理をしないこと"
"が望ましいです。"

#: ../../library/asyncio-task.rst:1145
msgid "Added the *msg* parameter."
msgstr ""

#: ../../library/asyncio-task.rst:1148
msgid "The ``msg`` parameter is propagated from cancelled task to its awaiter."
msgstr ""

#: ../../library/asyncio-task.rst:1153
msgid ""
"The following example illustrates how coroutines can intercept the "
"cancellation request::"
msgstr ""
"以下の例は、コルーチンがどのようにしてキャンセルのリクエストを阻止するかを示"
"しています::"

#: ../../library/asyncio-task.rst:1192
msgid "Return ``True`` if the Task is *cancelled*."
msgstr "Task が *キャンセルされた* 場合に ``True`` を返します。"

#: ../../library/asyncio-task.rst:1194
msgid ""
"The Task is *cancelled* when the cancellation was requested with :meth:"
"`cancel` and the wrapped coroutine propagated the :exc:`CancelledError` "
"exception thrown into it."
msgstr ""
":meth:`cancel` メソッドによりキャンセルがリクエストされ、かつ Task がラップし"
"ているコルーチンが内部で送出された :exc:`CancelledError` 例外を伝達したと"
"き、 Task は実際に *キャンセル* されます。"

#: ../../library/asyncio-task.rst:1200
msgid "Decrement the count of cancellation requests to this Task."
msgstr ""

#: ../../library/asyncio-task.rst:1202
msgid "Returns the remaining number of cancellation requests."
msgstr ""

#: ../../library/asyncio-task.rst:1204
msgid ""
"Note that once execution of a cancelled task completed, further calls to :"
"meth:`uncancel` are ineffective."
msgstr ""

#: ../../library/asyncio-task.rst:1209
msgid ""
"This method is used by asyncio's internals and isn't expected to be used by "
"end-user code.  In particular, if a Task gets successfully uncancelled, this "
"allows for elements of structured concurrency like :ref:`taskgroups` and :"
"func:`asyncio.timeout` to continue running, isolating cancellation to the "
"respective structured block. For example::"
msgstr ""

#: ../../library/asyncio-task.rst:1227
msgid ""
"While the block with ``make_request()`` and ``make_another_request()`` might "
"get cancelled due to the timeout, ``unrelated_code()`` should continue "
"running even in case of the timeout.  This is implemented with :meth:"
"`uncancel`.  :class:`TaskGroup` context managers use :func:`uncancel` in a "
"similar fashion."
msgstr ""

#: ../../library/asyncio-task.rst:1235
msgid ""
"Return the number of pending cancellation requests to this Task, i.e., the "
"number of calls to :meth:`cancel` less the number of :meth:`uncancel` calls."
msgstr ""

#: ../../library/asyncio-task.rst:1239
msgid ""
"Note that if this number is greater than zero but the Task is still "
"executing, :meth:`cancelled` will still return ``False``. This is because "
"this number can be lowered by calling :meth:`uncancel`, which can lead to "
"the task not being cancelled after all if the cancellation requests go down "
"to zero."
msgstr ""

#: ../../library/asyncio-task.rst:1245
msgid ""
"This method is used by asyncio's internals and isn't expected to be used by "
"end-user code.  See :meth:`uncancel` for more details."
msgstr ""
