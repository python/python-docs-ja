# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# 秘湯 <xwhhsprings@gmail.com>, 2017
# Yusuke Miyazaki <miyazaki.dev@gmail.com>, 2017
# Arihiro TAKASE, 2017
# E. Kawashima, 2017
# Masato HASHIMOTO <cabezon.hashimoto@gmail.com>, 2018
# SHIMIZU Taku <shimizu.taku@gmail.com>, 2019
# Yuto <ogran.std@gmail.com>, 2019
# Naoki Nakamura <agent@sohzoh.com>, 2020
# tomo, 2020
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-09 12:40+0000\n"
"PO-Revision-Date: 2017-02-16 17:49+0000\n"
"Last-Translator: tomo, 2020\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncio-task.rst:6
msgid "Coroutines and Tasks"
msgstr "コルーチンと Task"

#: ../../library/asyncio-task.rst:8
msgid ""
"This section outlines high-level asyncio APIs to work with coroutines and "
"Tasks."
msgstr "この節では、コルーチンと Task を利用する高レベルの asyncio の API の概略を解説します。"

#: ../../library/asyncio-task.rst:19 ../../library/asyncio-task.rst:121
msgid "Coroutines"
msgstr "コルーチン"

#: ../../library/asyncio-task.rst:21
msgid ""
":term:`Coroutines <coroutine>` declared with the async/await syntax is the "
"preferred way of writing asyncio applications.  For example, the following "
"snippet of code (requires Python 3.7+) prints \"hello\", waits 1 second, and"
" then prints \"world\"::"
msgstr ""
"async/await 構文で宣言された :term:`コルーチン <coroutine>` は、 asyncio "
"を使ったアプリケーションを書くのに推奨される方法です。例えば、次のコードスニペット (Python 3.7 以降が必要) は \"hello\" "
"を出力し、そこから 1 秒待って \"world\" を出力します:: "

#: ../../library/asyncio-task.rst:37
msgid ""
"Note that simply calling a coroutine will not schedule it to be executed::"
msgstr "単にコルーチンを呼び出しただけでは、コルーチンの実行スケジュールは予約されていないことに注意してください::"

#: ../../library/asyncio-task.rst:43
msgid "To actually run a coroutine, asyncio provides three main mechanisms:"
msgstr "実際にコルーチンを走らせるために、 asyncio は3つの機構を提供しています:"

#: ../../library/asyncio-task.rst:45
msgid ""
"The :func:`asyncio.run` function to run the top-level entry point \"main()\""
" function (see the above example.)"
msgstr ""
"最上位のエントリーポイントである \"main()\" 関数を実行する :func:`asyncio.run` 関数 (上の例を参照してください。)"

#: ../../library/asyncio-task.rst:48
msgid ""
"Awaiting on a coroutine.  The following snippet of code will print \"hello\""
" after waiting for 1 second, and then print \"world\" after waiting for "
"*another* 2 seconds::"
msgstr ""
"コルーチンを await すること。次のコード片は 1 秒間待機した後に \"hello\" と出力し、 *更に* 2 秒間待機してから "
"\"world\" と出力します::"

#: ../../library/asyncio-task.rst:69
msgid "Expected output::"
msgstr "予想される出力::"

#: ../../library/asyncio-task.rst:76
msgid ""
"The :func:`asyncio.create_task` function to run coroutines concurrently as "
"asyncio :class:`Tasks <Task>`."
msgstr ""
"asyncio の :class:`Tasks <Task>` としてコルーチンを並行して走らせる "
":func:`asyncio.create_task` 関数。"

#: ../../library/asyncio-task.rst:79
msgid ""
"Let's modify the above example and run two ``say_after`` coroutines "
"*concurrently*::"
msgstr "上のコード例を編集して、ふたつの ``say_after`` コルーチンを *並行して* 走らせてみましょう::"

#: ../../library/asyncio-task.rst:98
msgid ""
"Note that expected output now shows that the snippet runs 1 second faster "
"than before::"
msgstr "予想される出力が、スニペットの実行が前回よりも 1 秒早いことを示していることに注意してください::"

#: ../../library/asyncio-task.rst:110
msgid "Awaitables"
msgstr "Awaitable"

#: ../../library/asyncio-task.rst:112
msgid ""
"We say that an object is an **awaitable** object if it can be used in an "
":keyword:`await` expression.  Many asyncio APIs are designed to accept "
"awaitables."
msgstr ""
"あるオブジェクトを :keyword:`await` 式の中で使うことができる場合、そのオブジェクトを **awaitable** "
"オブジェクトと言います。多くの asyncio API は awaitable を受け取るように設計されています。"

#: ../../library/asyncio-task.rst:116
msgid ""
"There are three main types of *awaitable* objects: **coroutines**, "
"**Tasks**, and **Futures**."
msgstr ""
"*awaitable* オブジェクトには主に3つの種類があります: **コルーチン**, **Task**, そして **Future** です"

#: ../../library/asyncio-task.rst:122
msgid ""
"Python coroutines are *awaitables* and therefore can be awaited from other "
"coroutines::"
msgstr "Python のコルーチンは *awaitable* であり、そのため他のコルーチンを待機させられます::"

#: ../../library/asyncio-task.rst:143
msgid ""
"In this documentation the term \"coroutine\" can be used for two closely "
"related concepts:"
msgstr "このドキュメントにおいて「コルーチン」という用語は以下2つの密接に関連した概念に対して使用できます:"

#: ../../library/asyncio-task.rst:146
msgid "a *coroutine function*: an :keyword:`async def` function;"
msgstr "*コルーチン関数*: :keyword:`async def` 関数;"

#: ../../library/asyncio-task.rst:148
msgid ""
"a *coroutine object*: an object returned by calling a *coroutine function*."
msgstr "*コルーチンオブジェクト*: *コルーチン関数* を呼び出すと返ってくるオブジェクト."

#: ../../library/asyncio-task.rst:151
msgid ""
"asyncio also supports legacy :ref:`generator-based "
"<asyncio_generator_based_coro>` coroutines."
msgstr ""
"asyncio は、古くからある :ref:`ジェネレータベース <asyncio_generator_based_coro>` "
"のコルーチンもサポートしています。"

#: ../../library/asyncio-task.rst:156
msgid "Tasks"
msgstr "Task"

#: ../../library/asyncio-task.rst:157
msgid "*Tasks* are used to schedule coroutines *concurrently*."
msgstr "*Task* は、コルーチンを *並行に* スケジュールするのに使います。"

#: ../../library/asyncio-task.rst:159
msgid ""
"When a coroutine is wrapped into a *Task* with functions like "
":func:`asyncio.create_task` the coroutine is automatically scheduled to run "
"soon::"
msgstr ""
":func:`asyncio.create_task` のような関数で、コルーチンが *Task* "
"にラップされているとき、自動的にコルーチンは即時実行されるようにスケジュールされます::"

#: ../../library/asyncio-task.rst:181
msgid "Futures"
msgstr "Future"

#: ../../library/asyncio-task.rst:182
msgid ""
"A :class:`Future` is a special **low-level** awaitable object that "
"represents an **eventual result** of an asynchronous operation."
msgstr ""
":class:`Future` は、非同期処理の **最終結果** を表現する特別な **低レベルの** awaitable オブジェクトです。"

#: ../../library/asyncio-task.rst:185
msgid ""
"When a Future object is *awaited* it means that the coroutine will wait "
"until the Future is resolved in some other place."
msgstr ""
"Future オブジェクトが他の awaitable を *待機させている* と言うときは、ある場所で Future "
"が解決されるまでコルーチンが待機するということです。"

#: ../../library/asyncio-task.rst:188
msgid ""
"Future objects in asyncio are needed to allow callback-based code to be used"
" with async/await."
msgstr ""
"asyncio での Future オブジェクトは、async/await "
"と共に使用できるようにするため、コールバック形式のコードを使用できるように設計すべきです。"

#: ../../library/asyncio-task.rst:191
msgid ""
"Normally **there is no need** to create Future objects at the application "
"level code."
msgstr "通常、アプリケーション水準のコードで Future オブジェクトを作る **必要はありません** 。"

#: ../../library/asyncio-task.rst:194
msgid ""
"Future objects, sometimes exposed by libraries and some asyncio APIs, can be"
" awaited::"
msgstr ""
"Future オブジェクトはライブラリや asyncio の API で表に出ることもあり、他の awaitable を待機させられます::"

#: ../../library/asyncio-task.rst:206
msgid ""
"A good example of a low-level function that returns a Future object is "
":meth:`loop.run_in_executor`."
msgstr "Future オブジェクトを返す低レベル関数の良い例は :meth:`loop.run_in_executor` です。"

#: ../../library/asyncio-task.rst:211
msgid "Running an asyncio Program"
msgstr "非同期プログラムの実行"

#: ../../library/asyncio-task.rst:215
msgid "Execute the :term:`coroutine` *coro* and return the result."
msgstr ":term:`coroutine` *coro* を実行し、結果を返します。"

#: ../../library/asyncio-task.rst:217
msgid ""
"This function runs the passed coroutine, taking care of managing the asyncio"
" event loop and *finalizing asynchronous generators*."
msgstr "この関数は、非同期イベントループの管理と *非同期ジェネレータの終了処理* を行いながら、渡されたコルーチンを実行します。"

#: ../../library/asyncio-task.rst:221
msgid ""
"This function cannot be called when another asyncio event loop is running in"
" the same thread."
msgstr "この関数は、同じスレッドで他の非同期イベントループが実行中のときは呼び出せません。"

#: ../../library/asyncio-task.rst:224
msgid "If *debug* is ``True``, the event loop will be run in debug mode."
msgstr "*debug* が ``True`` の場合、イベントループはデバッグモードで実行されます。"

#: ../../library/asyncio-task.rst:226
msgid ""
"This function always creates a new event loop and closes it at the end.  It "
"should be used as a main entry point for asyncio programs, and should "
"ideally only be called once."
msgstr ""
"この関数は常に新しいイベントループを作成し、終了したらそのイベントループを閉じます。\n"
"この関数は非同期プログラムのメインのエントリーポイントとして使われるべきで、理想的には 1 回だけ呼び出されるべきです。"

#: ../../library/asyncio-task.rst:230 ../../library/asyncio-task.rst:354
#: ../../library/asyncio-task.rst:463 ../../library/asyncio-task.rst:593
msgid "Example::"
msgstr "以下はプログラム例です::"

#: ../../library/asyncio-task.rst:242
msgid ""
"The source code for ``asyncio.run()`` can be found in "
":source:`Lib/asyncio/runners.py`."
msgstr "``asyncio.run()`` のソースコードは :source:`Lib/asyncio/runners.py` にあります。"

#: ../../library/asyncio-task.rst:246
msgid "Creating Tasks"
msgstr "Task の作成"

#: ../../library/asyncio-task.rst:250
msgid ""
"Wrap the *coro* :ref:`coroutine <coroutine>` into a :class:`Task` and "
"schedule its execution.  Return the Task object."
msgstr ""
"*coro* :ref:`coroutine <coroutine>` を :class:`Task` でラップし、その実行をスケジュールします。\n"
"Task オブジェクトを返します。"

#: ../../library/asyncio-task.rst:253
msgid ""
"If *name* is not ``None``, it is set as the name of the task using "
":meth:`Task.set_name`."
msgstr ""
"もし *name* が ``None`` でない場合、:meth:`Task.set_name` を使用し、*name* "
"がタスクの名前として設定されます。"

#: ../../library/asyncio-task.rst:256
msgid ""
"The task is executed in the loop returned by :func:`get_running_loop`, "
":exc:`RuntimeError` is raised if there is no running loop in current thread."
msgstr ""
"その Task オブジェクトは :func:`get_running_loop` "
"から返されたループの中で実行されます。現在のスレッドに実行中のループが無い場合は、 :exc:`RuntimeError` が送出されます。"

#: ../../library/asyncio-task.rst:260
msgid ""
"This function has been **added in Python 3.7**.  Prior to Python 3.7, the "
"low-level :func:`asyncio.ensure_future` function can be used instead::"
msgstr ""
"この関数は **Python 3.7 で追加** されました。\n"
"Python 3.7 より前では、代わりに低レベルの :func:`asyncio.ensure_future` 関数が使えます::"

#: ../../library/asyncio-task.rst:277 ../../library/asyncio-task.rst:716
msgid "Added the ``name`` parameter."
msgstr "``name`` パラメータが追加されました。"

#: ../../library/asyncio-task.rst:282
msgid "Sleeping"
msgstr "スリープ"

#: ../../library/asyncio-task.rst:286
msgid "Block for *delay* seconds."
msgstr "*delay* 秒だけ停止します。"

#: ../../library/asyncio-task.rst:288
msgid ""
"If *result* is provided, it is returned to the caller when the coroutine "
"completes."
msgstr "*result* が提供されている場合は、コルーチン完了時にそれが呼び出し元に返されます。"

#: ../../library/asyncio-task.rst:291
msgid ""
"``sleep()`` always suspends the current task, allowing other tasks to run."
msgstr "``sleep()`` は常に現在の Task を一時中断し、他の Task が実行されるのを許可します。"

#: ../../library/asyncio-task.rst:296 ../../library/asyncio-task.rst:351
#: ../../library/asyncio-task.rst:430 ../../library/asyncio-task.rst:460
#: ../../library/asyncio-task.rst:545 ../../library/asyncio-task.rst:592
#: ../../library/asyncio-task.rst:721
msgid "The *loop* parameter."
msgstr "*loop* パラメータ。"

#: ../../library/asyncio-task.rst:299
msgid ""
"Example of coroutine displaying the current date every second for 5 "
"seconds::"
msgstr "現在の時刻を5秒間、毎秒表示するコルーチンの例::"

#: ../../library/asyncio-task.rst:318
msgid "Running Tasks Concurrently"
msgstr "並行な Task 実行"

#: ../../library/asyncio-task.rst:322
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* sequence "
"*concurrently*."
msgstr ""
"*aws* シーケンスにある :ref:`awaitable オブジェクト <asyncio-awaitables>` を *並行* 実行します。"

#: ../../library/asyncio-task.rst:325
msgid ""
"If any awaitable in *aws* is a coroutine, it is automatically scheduled as a"
" Task."
msgstr "*aws* にある awaitable がコルーチンである場合、自動的に Task としてスケジュールされます。"

#: ../../library/asyncio-task.rst:328
msgid ""
"If all awaitables are completed successfully, the result is an aggregate "
"list of returned values.  The order of result values corresponds to the "
"order of awaitables in *aws*."
msgstr ""
"全ての awaitable が正常終了した場合、その結果は返り値を集めたリストになります。\n"
"返り値の順序は、 *aws* での awaitable の順序に相当します。"

#: ../../library/asyncio-task.rst:332
msgid ""
"If *return_exceptions* is ``False`` (default), the first raised exception is"
" immediately propagated to the task that awaits on ``gather()``.  Other "
"awaitables in the *aws* sequence **won't be cancelled** and will continue to"
" run."
msgstr ""
"*return_exceptions* が ``False`` である場合(デフォルト)、``gather()`` で await "
"しているタスクに対して、最初の例外が直接伝えられます。*aws* に並んでいる他の awaitable は、**キャンセルされずに** "
"引き続いて実行されます。"

#: ../../library/asyncio-task.rst:337
msgid ""
"If *return_exceptions* is ``True``, exceptions are treated the same as "
"successful results, and aggregated in the result list."
msgstr ""
"*return_exceptions* が ``True`` だった場合、例外は成功した結果と同じように取り扱われ、結果リストに集められます。"

#: ../../library/asyncio-task.rst:340
msgid ""
"If ``gather()`` is *cancelled*, all submitted awaitables (that have not "
"completed yet) are also *cancelled*."
msgstr ""
"``gather()`` が *キャンセル* された場合、起動された全ての (未完了の) awaitable も *キャンセル* されます。"

#: ../../library/asyncio-task.rst:343
msgid ""
"If any Task or Future from the *aws* sequence is *cancelled*, it is treated "
"as if it raised :exc:`CancelledError` -- the ``gather()`` call is **not** "
"cancelled in this case.  This is to prevent the cancellation of one "
"submitted Task/Future to cause other Tasks/Futures to be cancelled."
msgstr ""
"*aws* シーケンスにある Task あるいは Future が *キャンセル* された場合、 :exc:`CancelledError` を送出したかのうように扱われます。つまり、この場合 ``gather()`` 呼び出しはキャンセル *されません*。\n"
"これは、起動された 1 つの Task あるいは Future のキャンセルが、他の Task あるいは Future のキャンセルを引き起こすのを避けるためです。"

#: ../../library/asyncio-task.rst:388
msgid ""
"If the *gather* itself is cancelled, the cancellation is propagated "
"regardless of *return_exceptions*."
msgstr "*gather* 自身がキャンセルされた場合は、 *return_exceptions* の値に関わらずキャンセルが伝搬されます。"

#: ../../library/asyncio-task.rst:394
msgid "Shielding From Cancellation"
msgstr "キャンセルからの保護"

#: ../../library/asyncio-task.rst:398
msgid ""
"Protect an :ref:`awaitable object <asyncio-awaitables>` from being "
":meth:`cancelled <Task.cancel>`."
msgstr ""
":meth:`キャンセル <Task.cancel>` から :ref:`awaitable オブジェクト <asyncio-awaitables>` "
"を保護します。"

#: ../../library/asyncio-task.rst:401 ../../library/asyncio-task.rst:441
msgid "If *aw* is a coroutine it is automatically scheduled as a Task."
msgstr "*aw* がコルーチンだった場合、自動的に Task としてスケジュールされます。"

#: ../../library/asyncio-task.rst:403
msgid "The statement::"
msgstr "文::"

#: ../../library/asyncio-task.rst:407
msgid "is equivalent to::"
msgstr "は、以下と同じです ::"

#: ../../library/asyncio-task.rst:411
msgid ""
"*except* that if the coroutine containing it is cancelled, the Task running "
"in ``something()`` is not cancelled.  From the point of view of "
"``something()``, the cancellation did not happen. Although its caller is "
"still cancelled, so the \"await\" expression still raises a "
":exc:`CancelledError`."
msgstr ""
"それを含むコルーチンがキャンセルされた場合を *除き*、``something()`` 内で動作している Task はキャンセルされません。\n"
"``something()`` 側から見るとキャンセルは発生しません。\n"
"呼び出し元がキャンセルされた場合でも、 \"await\" 式は :exc:`CancelledError` を送出します。"

#: ../../library/asyncio-task.rst:417
msgid ""
"If ``something()`` is cancelled by other means (i.e. from within itself) "
"that would also cancel ``shield()``."
msgstr ""
"注意: ``something()`` が他の理由 (例えば、原因が自分自身) でキャンセルされた場合は ``shield()`` でも保護できません。"

#: ../../library/asyncio-task.rst:420
msgid ""
"If it is desired to completely ignore cancellation (not recommended) the "
"``shield()`` function should be combined with a try/except clause, as "
"follows::"
msgstr ""
"完全にキャンセルを無視したい場合 (推奨はしません) は、 ``shield()`` 関数は次のように try/except "
"節と組み合わせることになるでしょう::"

#: ../../library/asyncio-task.rst:434
msgid "Timeouts"
msgstr "タイムアウト"

#: ../../library/asyncio-task.rst:438
msgid ""
"Wait for the *aw* :ref:`awaitable <asyncio-awaitables>` to complete with a "
"timeout."
msgstr "*aw* :ref:`awaitable <asyncio-awaitables>` が、完了するかタイムアウトになるのを待ちます。"

#: ../../library/asyncio-task.rst:443
msgid ""
"*timeout* can either be ``None`` or a float or int number of seconds to wait"
" for.  If *timeout* is ``None``, block until the future completes."
msgstr ""
"*timeout* には ``None`` もしくは待つ秒数の浮動小数点数か整数を指定できます。\n"
"*timeout* が ``None`` の場合、 Future が完了するまで待ちます。"

#: ../../library/asyncio-task.rst:447
msgid ""
"If a timeout occurs, it cancels the task and raises "
":exc:`asyncio.TimeoutError`."
msgstr "タイムアウトが起きた場合は、 Task をキャンセルし :exc:`asyncio.TimeoutError` を送出します。"

#: ../../library/asyncio-task.rst:450
msgid ""
"To avoid the task :meth:`cancellation <Task.cancel>`, wrap it in "
":func:`shield`."
msgstr ""
"Task の :meth:`キャンセル <Task.cancel>` を避けるためには、 :func:`shield` の中にラップしてください。"

#: ../../library/asyncio-task.rst:453
msgid ""
"The function will wait until the future is actually cancelled, so the total "
"wait time may exceed the *timeout*."
msgstr "この関数は、 Future が実際にキャンセルされるまで待つので、全体の待ち時間は *timeout* を超えることもあります。"

#: ../../library/asyncio-task.rst:456
msgid "If the wait is cancelled, the future *aw* is also cancelled."
msgstr "待機が中止された場合 *aw* も中止されます。"

#: ../../library/asyncio-task.rst:483
msgid ""
"When *aw* is cancelled due to a timeout, ``wait_for`` waits for *aw* to be "
"cancelled.  Previously, it raised :exc:`asyncio.TimeoutError` immediately."
msgstr ""
"*aw* がタイムアウトでキャンセルされたとき、 ``wait_for`` は *aw* がキャンセルされるまで待ちます。\n"
"以前は、すぐに :exc:`asyncio.TimeoutError` を送出していました。"

#: ../../library/asyncio-task.rst:490
msgid "Waiting Primitives"
msgstr "要素の終了待機"

#: ../../library/asyncio-task.rst:495
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* set "
"concurrently and block until the condition specified by *return_when*."
msgstr ""
"*aws* 集合にある :ref:`awaitable オブジェクト <asyncio-awaitables>` を *並行* 実行し、 "
"*return_when* で指定した条件が満たされるまで待ちます。"

#: ../../library/asyncio-task.rst:499
msgid "Returns two sets of Tasks/Futures: ``(done, pending)``."
msgstr "Task と Future の 2 つ ``(done, pending)`` を返します。"

#: ../../library/asyncio-task.rst:501
msgid "Usage::"
msgstr "使い方::"

#: ../../library/asyncio-task.rst:505
msgid ""
"*timeout* (a float or int), if specified, can be used to control the maximum"
" number of seconds to wait before returning."
msgstr "*timeout* (浮動小数点数または整数) が指定されていたら、処理を返すのを待つ最大秒数を制御するのに使われます。"

#: ../../library/asyncio-task.rst:508
msgid ""
"Note that this function does not raise :exc:`asyncio.TimeoutError`. Futures "
"or Tasks that aren't done when the timeout occurs are simply returned in the"
" second set."
msgstr ""
"この関数は :exc:`asyncio.TimeoutError` を送出しないことに注意してください。\n"
"タイムアウトが起きたときに完了していなかった Future や Task は、2 つ目の集合の要素として返されるだけです。"

#: ../../library/asyncio-task.rst:512
msgid ""
"*return_when* indicates when this function should return.  It must be one of"
" the following constants:"
msgstr "*return_when* でこの関数がいつ結果を返すか指定します。指定できる値は以下の 定数のどれか一つです:"

#: ../../library/asyncio-task.rst:518
msgid "Constant"
msgstr "定数"

#: ../../library/asyncio-task.rst:518
msgid "Description"
msgstr "説明"

#: ../../library/asyncio-task.rst:520
msgid ":const:`FIRST_COMPLETED`"
msgstr ":const:`FIRST_COMPLETED`"

#: ../../library/asyncio-task.rst:520
msgid "The function will return when any future finishes or is cancelled."
msgstr "いずれかの Future が終了したかキャンセルされたときに返します。"

#: ../../library/asyncio-task.rst:523
msgid ":const:`FIRST_EXCEPTION`"
msgstr ":const:`FIRST_EXCEPTION`"

#: ../../library/asyncio-task.rst:523
msgid ""
"The function will return when any future finishes by raising an exception.  "
"If no future raises an exception then it is equivalent to "
":const:`ALL_COMPLETED`."
msgstr ""
"いずれかの Future が例外の送出で終了した場合に返します。\n"
"例外を送出したフューチャがない場合は、:const:`ALL_COMPLETED` と等価になります。"

#: ../../library/asyncio-task.rst:529
msgid ":const:`ALL_COMPLETED`"
msgstr ":const:`ALL_COMPLETED`"

#: ../../library/asyncio-task.rst:529
msgid "The function will return when all futures finish or are cancelled."
msgstr "すべての Future が終了したかキャンセルされたときに返します。"

#: ../../library/asyncio-task.rst:533
msgid ""
"Unlike :func:`~asyncio.wait_for`, ``wait()`` does not cancel the futures "
"when a timeout occurs."
msgstr ""
":func:`~asyncio.wait_for` と異なり、  ``wait()`` はタイムアウトが起きたときに Future "
"をキャンセルしません。"

#: ../../library/asyncio-task.rst:538
msgid ""
"If any awaitable in *aws* is a coroutine, it is automatically scheduled as a"
" Task.  Passing coroutines objects to ``wait()`` directly is deprecated as "
"it leads to :ref:`confusing behavior <asyncio_example_wait_coroutine>`."
msgstr ""
"*aws* にある awaitable のどれかがコルーチンの場合、自動的に Task としてスケジュールされます。\n"
"コルーチンオブジェクトを ``wait()`` に直接渡すのは :ref:`紛らわしい振る舞い <asyncio_example_wait_coroutine>` を引き起こすため非推奨です。"

#: ../../library/asyncio-task.rst:550
msgid ""
"``wait()`` schedules coroutines as Tasks automatically and later returns "
"those implicitly created Task objects in ``(done, pending)`` sets.  "
"Therefore the following code won't work as expected::"
msgstr ""
"``wait()`` は自動的にコルーチンを Task としてスケジュールし、その後、暗黙的に作成された Task オブジェクトを組になった集合 ``(done, pending)`` に入れて返します。\n"
"従って、次のコードは予想した通りには動作しません::"

#: ../../library/asyncio-task.rst:563
msgid "Here is how the above snippet can be fixed::"
msgstr "上のスクリプト片は次のように修正できます::"

#: ../../library/asyncio-task.rst:576
msgid "Passing coroutine objects to ``wait()`` directly is deprecated."
msgstr "``wait()`` にコルーチンオブジェクトを直接渡すのは非推奨です。"

#: ../../library/asyncio-task.rst:582
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* set "
"concurrently.  Return an iterator of :class:`Future` objects. Each Future "
"object returned represents the earliest result from the set of the remaining"
" awaitables."
msgstr ""
" *aws* 集合にある :ref:`awaitable オブジェクト <asyncio-awaitables>` を *並行* 実行します。\n"
":class:`Future` オブジェクトのイテレータを返します。\n"
"返されるそれぞれの Future オブジェクトは、残っている awaitable の集合の中で最も早かった結果に相当します。"

#: ../../library/asyncio-task.rst:587
msgid ""
"Raises :exc:`asyncio.TimeoutError` if the timeout occurs before all Futures "
"are done."
msgstr "全フューチャが終了する前にタイムアウトが発生した場合 :exc:`asyncio.TimeoutError` を送出します。"

#: ../../library/asyncio-task.rst:601
msgid "Scheduling From Other Threads"
msgstr "外部スレッドからのスケジュール"

#: ../../library/asyncio-task.rst:605
msgid "Submit a coroutine to the given event loop.  Thread-safe."
msgstr ""
"与えられたイベントループにコルーチンを送ります。\n"
"この処理は、スレッドセーフです。"

#: ../../library/asyncio-task.rst:607
msgid ""
"Return a :class:`concurrent.futures.Future` to wait for the result from "
"another OS thread."
msgstr "他の OS スレッドから結果を待つための :class:`concurrent.futures.Future` を返します。"

#: ../../library/asyncio-task.rst:610
msgid ""
"This function is meant to be called from a different OS thread than the one "
"where the event loop is running.  Example::"
msgstr ""
"この関数は、イベントループが動作しているスレッドとは異なる OS スレッドから呼び出すためのものです。\n"
"例えば次のように使います::"

#: ../../library/asyncio-task.rst:622
msgid ""
"If an exception is raised in the coroutine, the returned Future will be "
"notified.  It can also be used to cancel the task in the event loop::"
msgstr ""
"コルーチンから例外が送出された場合、返された Future に通知されます。\n"
"これはイベントループの Task をキャンセルするのにも使えます::"

#: ../../library/asyncio-task.rst:636
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr "このドキュメントの :ref:`asyncio-multithreading` 節を参照してください。"

#: ../../library/asyncio-task.rst:639
msgid ""
"Unlike other asyncio functions this function requires the *loop* argument to"
" be passed explicitly."
msgstr "他の asyncio 関数とは異なり、この関数は明示的に渡される *loop* 引数を必要とします。"

#: ../../library/asyncio-task.rst:646
msgid "Introspection"
msgstr "イントロスペクション"

#: ../../library/asyncio-task.rst:651
msgid ""
"Return the currently running :class:`Task` instance, or ``None`` if no task "
"is running."
msgstr "現在実行中の :class:`Task` インスタンスを返します。実行中の Task が無い場合は ``None`` を返します。"

#: ../../library/asyncio-task.rst:654
msgid ""
"If *loop* is ``None`` :func:`get_running_loop` is used to get the current "
"loop."
msgstr "*loop* が ``None`` の場合、 :func:`get_running_loop` が現在のループを取得するのに使われます。"

#: ../../library/asyncio-task.rst:662
msgid ""
"Return a set of not yet finished :class:`Task` objects run by the loop."
msgstr "ループで実行された :class:`Task` オブジェクトでまだ完了していないものの集合を返します。"

#: ../../library/asyncio-task.rst:665
msgid ""
"If *loop* is ``None``, :func:`get_running_loop` is used for getting current "
"loop."
msgstr "*loop* が ``None`` の場合、 :func:`get_running_loop` は現在のループを取得するのに使われます。"

#: ../../library/asyncio-task.rst:672
msgid "Task Object"
msgstr "Task オブジェクト"

#: ../../library/asyncio-task.rst:676
msgid ""
"A :class:`Future-like <Future>` object that runs a Python :ref:`coroutine "
"<coroutine>`.  Not thread-safe."
msgstr ""
"Python :ref:`コルーチン <coroutine>` を実行する :class:`Future 類 <Future>` オブジェクトです。\n"
"スレッドセーフではありません。"

#: ../../library/asyncio-task.rst:679
msgid ""
"Tasks are used to run coroutines in event loops. If a coroutine awaits on a "
"Future, the Task suspends the execution of the coroutine and waits for the "
"completion of the Future.  When the Future is *done*, the execution of the "
"wrapped coroutine resumes."
msgstr ""
"Task はイベントループのコルーチンを実行するのに使われます。\n"
"Future でコルーチンが待機している場合、 Task は自身のコルーチンの実行を一時停止させ、 Future の完了を待ちます。\n"
"Future が *完了* したら、 Task が内包しているコルーチンの実行を再開します。"

#: ../../library/asyncio-task.rst:685
msgid ""
"Event loops use cooperative scheduling: an event loop runs one Task at a "
"time.  While a Task awaits for the completion of a Future, the event loop "
"runs other Tasks, callbacks, or performs IO operations."
msgstr ""
"イベントループは協調スケジューリングを使用します。つまり、イベントループは同時に 1 つの Task のみ実行します。\n"
"Task が Future の完了を待っているときは、イベントループは他の Task やコールバックを動作させるか、 IO 処理を実行します。"

#: ../../library/asyncio-task.rst:690
msgid ""
"Use the high-level :func:`asyncio.create_task` function to create Tasks, or "
"the low-level :meth:`loop.create_task` or :func:`ensure_future` functions.  "
"Manual instantiation of Tasks is discouraged."
msgstr ""
"Task を作成するには高レベルの :func:`asyncio.create_task` 関数、あるいは低レベルの :meth:`loop.create_task` 関数や :func:`ensure_future` 関数を使用してください。\n"
"手作業での Task の実装は推奨されません。"

#: ../../library/asyncio-task.rst:695
msgid ""
"To cancel a running Task use the :meth:`cancel` method.  Calling it will "
"cause the Task to throw a :exc:`CancelledError` exception into the wrapped "
"coroutine.  If a coroutine is awaiting on a Future object during "
"cancellation, the Future object will be cancelled."
msgstr ""
"実行中のタスクをキャンセルするためには、:meth:`cancel` "
"メソッドを使用します。このメソッドを呼ぶと、タスクはそれを内包するコルーチンに対して :exc:`CancelledError` "
"例外を送出します。キャンセルの際にコルーチンが Future オブジェクトを待っていた場合、その Future オブジェクトはキャンセルされます。"

#: ../../library/asyncio-task.rst:700
msgid ""
":meth:`cancelled` can be used to check if the Task was cancelled. The method"
" returns ``True`` if the wrapped coroutine did not suppress the "
":exc:`CancelledError` exception and was actually cancelled."
msgstr ""
":meth:`cancelled` は、タスクがキャンセルされたかを調べるのに使用できます。タスクを内包するコルーチンで "
":exc:`CancelledError` 例外が抑制されておらず、かつタスクが実際にキャンセルされている場合に、このメソッドは ``True`` "
"を変えます。"

#: ../../library/asyncio-task.rst:705
msgid ""
":class:`asyncio.Task` inherits from :class:`Future` all of its APIs except "
":meth:`Future.set_result` and :meth:`Future.set_exception`."
msgstr ""
":class:`asyncio.Task` は、:meth:`Future.set_result` と "
":meth:`Future.set_exception` を除いて、:class:`Future` の API をすべて継承しています。"

#: ../../library/asyncio-task.rst:709
msgid ""
"Tasks support the :mod:`contextvars` module.  When a Task is created it "
"copies the current context and later runs its coroutine in the copied "
"context."
msgstr ""
"Task は :mod:`contextvars` モジュールをサポートします。Task が作られたときに現在のコンテキストがコピーされ、のちに "
"Task のコルーチンを実行する際に、コピーされたコンテキストが使用されます。"

#: ../../library/asyncio-task.rst:713
msgid "Added support for the :mod:`contextvars` module."
msgstr ":mod:`contextvars` モジュールのサポートを追加。"

#: ../../library/asyncio-task.rst:724
msgid "Request the Task to be cancelled."
msgstr "このタスクに、自身のキャンセルを要求します。"

#: ../../library/asyncio-task.rst:726
msgid ""
"This arranges for a :exc:`CancelledError` exception to be thrown into the "
"wrapped coroutine on the next cycle of the event loop."
msgstr ""

#: ../../library/asyncio-task.rst:729
msgid ""
"The coroutine then has a chance to clean up or even deny the request by "
"suppressing the exception with a :keyword:`try` ... ... ``except "
"CancelledError`` ... :keyword:`finally` block. Therefore, unlike "
":meth:`Future.cancel`, :meth:`Task.cancel` does not guarantee that the Task "
"will be cancelled, although suppressing cancellation completely is not "
"common and is actively discouraged."
msgstr ""

#: ../../library/asyncio-task.rst:739
msgid ""
"The following example illustrates how coroutines can intercept the "
"cancellation request::"
msgstr ""

#: ../../library/asyncio-task.rst:778
msgid "Return ``True`` if the Task is *cancelled*."
msgstr ""

#: ../../library/asyncio-task.rst:780
msgid ""
"The Task is *cancelled* when the cancellation was requested with "
":meth:`cancel` and the wrapped coroutine propagated the "
":exc:`CancelledError` exception thrown into it."
msgstr ""

#: ../../library/asyncio-task.rst:786
msgid "Return ``True`` if the Task is *done*."
msgstr ""

#: ../../library/asyncio-task.rst:788
msgid ""
"A Task is *done* when the wrapped coroutine either returned a value, raised "
"an exception, or the Task was cancelled."
msgstr ""

#: ../../library/asyncio-task.rst:793
msgid "Return the result of the Task."
msgstr ""

#: ../../library/asyncio-task.rst:795
msgid ""
"If the Task is *done*, the result of the wrapped coroutine is returned (or "
"if the coroutine raised an exception, that exception is re-raised.)"
msgstr ""

#: ../../library/asyncio-task.rst:799 ../../library/asyncio-task.rst:813
msgid ""
"If the Task has been *cancelled*, this method raises a :exc:`CancelledError`"
" exception."
msgstr ""

#: ../../library/asyncio-task.rst:802
msgid ""
"If the Task's result isn't yet available, this method raises a "
":exc:`InvalidStateError` exception."
msgstr ""

#: ../../library/asyncio-task.rst:807
msgid "Return the exception of the Task."
msgstr ""

#: ../../library/asyncio-task.rst:809
msgid ""
"If the wrapped coroutine raised an exception that exception is returned.  If"
" the wrapped coroutine returned normally this method returns ``None``."
msgstr ""

#: ../../library/asyncio-task.rst:816
msgid ""
"If the Task isn't *done* yet, this method raises an :exc:`InvalidStateError`"
" exception."
msgstr ""

#: ../../library/asyncio-task.rst:821
msgid "Add a callback to be run when the Task is *done*."
msgstr ""

#: ../../library/asyncio-task.rst:823 ../../library/asyncio-task.rst:832
msgid "This method should only be used in low-level callback-based code."
msgstr ""

#: ../../library/asyncio-task.rst:825
msgid ""
"See the documentation of :meth:`Future.add_done_callback` for more details."
msgstr ""

#: ../../library/asyncio-task.rst:830
msgid "Remove *callback* from the callbacks list."
msgstr ""

#: ../../library/asyncio-task.rst:834
msgid ""
"See the documentation of :meth:`Future.remove_done_callback` for more "
"details."
msgstr ""

#: ../../library/asyncio-task.rst:839
msgid "Return the list of stack frames for this Task."
msgstr ""

#: ../../library/asyncio-task.rst:841
msgid ""
"If the wrapped coroutine is not done, this returns the stack where it is "
"suspended.  If the coroutine has completed successfully or was cancelled, "
"this returns an empty list. If the coroutine was terminated by an exception,"
" this returns the list of traceback frames."
msgstr ""

#: ../../library/asyncio-task.rst:847
msgid "The frames are always ordered from oldest to newest."
msgstr "フレームは常に古いものから新しい物へ並んでいます。"

#: ../../library/asyncio-task.rst:849
msgid "Only one stack frame is returned for a suspended coroutine."
msgstr ""

#: ../../library/asyncio-task.rst:851
msgid ""
"The optional *limit* argument sets the maximum number of frames to return; "
"by default all available frames are returned. The ordering of the returned "
"list differs depending on whether a stack or a traceback is returned: the "
"newest frames of a stack are returned, but the oldest frames of a traceback "
"are returned.  (This matches the behavior of the traceback module.)"
msgstr ""

#: ../../library/asyncio-task.rst:860
msgid "Print the stack or traceback for this Task."
msgstr ""

#: ../../library/asyncio-task.rst:862
msgid ""
"This produces output similar to that of the traceback module for the frames "
"retrieved by :meth:`get_stack`."
msgstr ""

#: ../../library/asyncio-task.rst:865
msgid "The *limit* argument is passed to :meth:`get_stack` directly."
msgstr ""

#: ../../library/asyncio-task.rst:867
msgid ""
"The *file* argument is an I/O stream to which the output is written; by "
"default output is written to :data:`sys.stderr`."
msgstr ""

#: ../../library/asyncio-task.rst:872
msgid "Return the coroutine object wrapped by the :class:`Task`."
msgstr ""

#: ../../library/asyncio-task.rst:878
msgid "Return the name of the Task."
msgstr ""

#: ../../library/asyncio-task.rst:880
msgid ""
"If no name has been explicitly assigned to the Task, the default asyncio "
"Task implementation generates a default name during instantiation."
msgstr ""

#: ../../library/asyncio-task.rst:888
msgid "Set the name of the Task."
msgstr ""

#: ../../library/asyncio-task.rst:890
msgid ""
"The *value* argument can be any object, which is then converted to a string."
msgstr ""

#: ../../library/asyncio-task.rst:893
msgid ""
"In the default Task implementation, the name will be visible in the "
":func:`repr` output of a task object."
msgstr ""

#: ../../library/asyncio-task.rst:900
msgid "Return a set of all tasks for an event loop."
msgstr "イベントループのすべての Task の集合を返します。"

#: ../../library/asyncio-task.rst:902
msgid ""
"By default all tasks for the current event loop are returned. If *loop* is "
"``None``, the :func:`get_event_loop` function is used to get the current "
"loop."
msgstr ""

#: ../../library/asyncio-task.rst:908
msgid ""
"Do not call this as a task method. Use the :func:`asyncio.all_tasks` "
"function instead."
msgstr ""

#: ../../library/asyncio-task.rst:913
msgid "Return the currently running task or ``None``."
msgstr ""

#: ../../library/asyncio-task.rst:915
msgid ""
"If *loop* is ``None``, the :func:`get_event_loop` function is used to get "
"the current loop."
msgstr ""

#: ../../library/asyncio-task.rst:920
msgid ""
"Do not call this as a task method.  Use the :func:`asyncio.current_task` "
"function instead."
msgstr ""

#: ../../library/asyncio-task.rst:927
msgid "Generator-based Coroutines"
msgstr ""

#: ../../library/asyncio-task.rst:931
msgid ""
"Support for generator-based coroutines is **deprecated** and is scheduled "
"for removal in Python 3.10."
msgstr ""

#: ../../library/asyncio-task.rst:934
msgid ""
"Generator-based coroutines predate async/await syntax.  They are Python "
"generators that use ``yield from`` expressions to await on Futures and other"
" coroutines."
msgstr ""

#: ../../library/asyncio-task.rst:938
msgid ""
"Generator-based coroutines should be decorated with "
":func:`@asyncio.coroutine <asyncio.coroutine>`, although this is not "
"enforced."
msgstr ""

#: ../../library/asyncio-task.rst:945
msgid "Decorator to mark generator-based coroutines."
msgstr ""

#: ../../library/asyncio-task.rst:947
msgid ""
"This decorator enables legacy generator-based coroutines to be compatible "
"with async/await code::"
msgstr ""

#: ../../library/asyncio-task.rst:957
msgid "This decorator should not be used for :keyword:`async def` coroutines."
msgstr ""

#: ../../library/asyncio-task.rst:962
msgid "Use :keyword:`async def` instead."
msgstr ""

#: ../../library/asyncio-task.rst:966
msgid "Return ``True`` if *obj* is a :ref:`coroutine object <coroutine>`."
msgstr "*obj* が :ref:`コルーチンオブジェクト <coroutine>` であれば ``True`` を返します。"

#: ../../library/asyncio-task.rst:968
msgid ""
"This method is different from :func:`inspect.iscoroutine` because it returns"
" ``True`` for generator-based coroutines."
msgstr ""

#: ../../library/asyncio-task.rst:973
msgid "Return ``True`` if *func* is a :ref:`coroutine function <coroutine>`."
msgstr ""

#: ../../library/asyncio-task.rst:976
msgid ""
"This method is different from :func:`inspect.iscoroutinefunction` because it"
" returns ``True`` for generator-based coroutine functions decorated with "
":func:`@coroutine <coroutine>`."
msgstr ""
