# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-30 13:28+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncio-task.rst:4
msgid "Tasks and coroutines"
msgstr "ã‚¿ã‚¹ã‚¯ã¨ã‚³ãƒ«ãƒ¼ãƒãƒ³"

#: ../../library/asyncio-task.rst:6
msgid "**Source code:** :source:`Lib/asyncio/tasks.py`"
msgstr ""

#: ../../library/asyncio-task.rst:8
msgid "**Source code:** :source:`Lib/asyncio/coroutines.py`"
msgstr ""

#: ../../library/asyncio-task.rst:13
msgid "Coroutines"
msgstr "ã‚³ãƒ«ãƒ¼ãƒãƒ³"

#: ../../library/asyncio-task.rst:15
msgid ""
"Coroutines used with :mod:`asyncio` may be implemented using the "
":keyword:`async def` statement, or by using :term:`generators <generator>`. "
"The :keyword:`async def` type of coroutine was added in Python 3.5, and is "
"recommended if there is no need to support older Python versions."
msgstr ""
":mod:`asyncio` ã¨ä¸€ç·’ã«ä½¿ã†ã‚³ãƒ«ãƒ¼ãƒãƒ³ã¯ :keyword:`async def` æ–‡ã‚’ä½¿ã£ã¦å®Ÿè£…ã™ã‚‹ã‹ã€ã‚‚ã—ãã¯  "
":term:`ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ <generator>` ã‚’ä½¿ã£ã¦å®Ÿè£…ã—ã¾ã™ã€‚:keyword:`async def` å‹ã®ã‚³ãƒ«ãƒ¼ãƒãƒ³ã¯Python "
"3.5ã®æ™‚ã«è¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚3.5ã‚ˆã‚Šå‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®Pythonã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å¿…è¦ãŒãªã‘ã‚Œã° :keyword:`async def` "
"ã‚¿ã‚¤ãƒ—ã®ã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒæ¨å¥¨ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:20
msgid ""
"Generator-based coroutines should be decorated with "
":func:`@asyncio.coroutine <asyncio.coroutine>`, although this is not "
"strictly enforced. The decorator enables compatibility with :keyword:`async "
"def` coroutines, and also serves as documentation.  Generator-based "
"coroutines use the ``yield from`` syntax introduced in :pep:`380`, instead "
"of the original ``yield`` syntax."
msgstr ""
"å¿…é ˆã¨ã„ã†ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ã‚³ãƒ«ãƒ¼ãƒãƒ³ã¯ :func:`@asyncio.coroutine "
"<asyncio.coroutine>` ã§ãƒ‡ã‚³ãƒ¬ãƒ¼ãƒˆã™ã¹ãã§ã™ã€‚ :func:`@asyncio.coroutine "
"<asyncio.coroutine>` ã§ãƒ‡ã‚³ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã“ã¨ã§ :keyword:`async def` "
"å‹ã®ã‚³ãƒ«ãƒ¼ãƒãƒ³ã¨äº’æ›æ€§ã‚’æŒãŸã›ã‚‹ã“ã¨ãŒã§ãã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¨ã—ã¦ã‚‚å½¹ã«ç«‹ã¡ã¾ã™ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ã‚³ãƒ«ãƒ¼ãƒãƒ³ã¯ ``yield`` æ§‹æ–‡ã‚’ä½¿ã†ä»£ã‚ã‚Šã«ã€"
" :pep:`380` ã§å°å…¥ã•ã‚ŒãŸ ``yield from`` æ§‹æ–‡ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:27
msgid ""
"The word \"coroutine\", like the word \"generator\", is used for two "
"different (though related) concepts:"
msgstr "å˜èª \"ã‚³ãƒ«ãƒ¼ãƒãƒ³\" ã¯å˜èª \"ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼\" ã®ã‚ˆã†ã«ã€(é–¢é€£ã¯ã—ã¦ã„ã¾ã™ãŒ) ç•°ãªã‚‹ 2 ã¤ã®æ¦‚å¿µã§ä½¿ç”¨ã•ã‚Œã¾ã™:"

#: ../../library/asyncio-task.rst:30
msgid ""
"The function that defines a coroutine (a function definition using "
":keyword:`async def` or decorated with ``@asyncio.coroutine``).  If "
"disambiguation is needed we will call this a *coroutine function* "
"(:func:`iscoroutinefunction` returns ``True``)."
msgstr ""
"ã‚³ãƒ«ãƒ¼ãƒãƒ³ã‚’å®šç¾©ã—ãŸé–¢æ•° (:keyword:`async def` ã‚’ä½¿ç”¨ã™ã‚‹ã‹ ``@asyncio.coroutine`` ã§ãƒ‡ã‚³ãƒ¬ãƒ¼ãƒˆã•ã‚ŒãŸé–¢æ•°å®šç¾©)ã€‚\n"
"æ›–æ˜§ã•ã‚’é¿ã‘ã‚‹éš›ã¯ *ã‚³ãƒ«ãƒ¼ãƒãƒ³é–¢æ•°* ã¨å‘¼ã³ã¾ã™ (:func:`iscoroutinefunction` ã¯ ``True`` ã‚’è¿”ã—ã¾ã™)ã€‚"

#: ../../library/asyncio-task.rst:36
msgid ""
"The object obtained by calling a coroutine function.  This object represents"
" a computation or an I/O operation (usually a combination) that will "
"complete eventually.  If disambiguation is needed we will call it a "
"*coroutine object* (:func:`iscoroutine` returns ``True``)."
msgstr ""
"ã‚³ãƒ«ãƒ¼ãƒãƒ³é–¢æ•°ã®å‘¼ã³å‡ºã—ã«ã‚ˆã£ã¦å–å¾—ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ã„ã¤ã‹ã¯å®Œäº†ã™ã‚‹è¨ˆç®—ã¾ãŸã¯ I/O æ“ä½œ (é€šå¸¸ã¯ãã®çµ„ã¿åˆã‚ã›) "
"ã‚’è¡¨ã—ã¾ã™ã€‚æ›–æ˜§ã•ã®è§£æ¶ˆãŒå¿…è¦ãªå ´åˆã¯ã“ã‚Œã‚’ *ã‚³ãƒ«ãƒ¼ãƒãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ* (:func:`iscoroutine` ãŒ ``True`` ã‚’è¿”ã™) "
"ã¨å‘¼ã³ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:41
msgid "Things a coroutine can do:"
msgstr "ã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒã§ãã‚‹ã“ã¨:"

#: ../../library/asyncio-task.rst:43
msgid ""
"``result = await future`` or ``result = yield from future`` -- suspends the "
"coroutine until the future is done, then returns the future's result, or "
"raises an exception, which will be propagated.  (If the future is cancelled,"
" it will raise a ``CancelledError`` exception.)  Note that tasks are "
"futures, and everything said about futures also applies to tasks."
msgstr ""

#: ../../library/asyncio-task.rst:50
msgid ""
"``result = await coroutine`` or ``result = yield from coroutine`` -- wait "
"for another coroutine to produce a result (or raise an exception, which will"
" be propagated). The ``coroutine`` expression must be a *call* to another "
"coroutine."
msgstr ""

#: ../../library/asyncio-task.rst:55
msgid ""
"``return expression`` -- produce a result to the coroutine that is waiting "
"for this one using :keyword:`await` or ``yield from``."
msgstr ""

#: ../../library/asyncio-task.rst:58
msgid ""
"``raise exception`` -- raise an exception in the coroutine that is waiting "
"for this one using :keyword:`await` or ``yield from``."
msgstr ""

#: ../../library/asyncio-task.rst:61
msgid ""
"Calling a coroutine does not start its code running -- the coroutine object "
"returned by the call doesn't do anything until you schedule its execution.  "
"There are two basic ways to start it running: call ``await coroutine`` or "
"``yield from coroutine`` from another coroutine (assuming the other "
"coroutine is already running!), or schedule its execution using the "
":func:`ensure_future` function or the :meth:`AbstractEventLoop.create_task` "
"method."
msgstr ""

#: ../../library/asyncio-task.rst:70
msgid "Coroutines (and tasks) can only run when the event loop is running."
msgstr "ã‚³ãƒ«ãƒ¼ãƒãƒ³ (ãŠã‚ˆã³ã‚¿ã‚¹ã‚¯) ã¯ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ãŒå®Ÿè¡Œä¸­ã®å ´åˆã«ã®ã¿èµ·å‹•ã§ãã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:74
msgid ""
"Decorator to mark generator-based coroutines.  This enables the generator "
"use :keyword:`!yield from` to call :keyword:`async def` coroutines, and also"
" enables the generator to be called by :keyword:`async def` coroutines, for "
"instance using an :keyword:`await` expression."
msgstr ""

#: ../../library/asyncio-task.rst:80
msgid ""
"There is no need to decorate :keyword:`async def` coroutines themselves."
msgstr ":keyword:`async def` ã‚³ãƒ«ãƒ¼ãƒãƒ³è‡ªèº«ã‚’ãƒ‡ã‚³ãƒ¬ãƒ¼ãƒˆã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-task.rst:82
msgid ""
"If the generator is not yielded from before it is destroyed, an error "
"message is logged. See :ref:`Detect coroutines never scheduled <asyncio-"
"coroutine-not-scheduled>`."
msgstr ""

#: ../../library/asyncio-task.rst:88
msgid ""
"In this documentation, some methods are documented as coroutines, even if "
"they are plain Python functions returning a :class:`Future`. This is "
"intentional to have a freedom of tweaking the implementation of these "
"functions in the future. If such a function is needed to be used in a "
"callback-style code, wrap its result with :func:`ensure_future`."
msgstr ""

#: ../../library/asyncio-task.rst:98
msgid "Example: Hello World coroutine"
msgstr "ä¾‹: Hello World ã‚³ãƒ«ãƒ¼ãƒãƒ³"

#: ../../library/asyncio-task.rst:100
msgid "Example of coroutine displaying ``\"Hello World\"``::"
msgstr "``\"Hello World\"`` ã¨è¡¨ç¤ºã™ã‚‹ã‚³ãƒ«ãƒ¼ãƒãƒ³ã®ä¾‹::"

#: ../../library/asyncio-task.rst:114
msgid ""
"The :ref:`Hello World with call_soon() <asyncio-hello-world-callback>` "
"example uses the :meth:`AbstractEventLoop.call_soon` method to schedule a "
"callback."
msgstr ""

#: ../../library/asyncio-task.rst:122
msgid "Example: Coroutine displaying the current date"
msgstr "ä¾‹: ç¾åœ¨ã®æ—¥æ™‚ã‚’è¡¨ç¤ºã™ã‚‹ã‚³ãƒ«ãƒ¼ãƒãƒ³"

#: ../../library/asyncio-task.rst:124
msgid ""
"Example of coroutine displaying the current date every second during 5 "
"seconds using the :meth:`sleep` function::"
msgstr ":meth:`sleep` é–¢æ•°ã‚’ç”¨ã„ã¦ç¾åœ¨ã®æ™‚åˆ»ã‚’5ç§’é–“ã€æ¯ç§’è¡¨ç¤ºã™ã‚‹ã‚³ãƒ«ãƒ¼ãƒãƒ³ã®ä¾‹::"

#: ../../library/asyncio-task.rst:145
msgid ""
"The :ref:`display the current date with call_later() <asyncio-date-"
"callback>` example uses a callback with the "
":meth:`AbstractEventLoop.call_later` method."
msgstr ""

#: ../../library/asyncio-task.rst:151
msgid "Example: Chain coroutines"
msgstr "ä¾‹: ã‚³ãƒ«ãƒ¼ãƒãƒ³ã®ãƒã‚§ãƒ¼ãƒ³"

#: ../../library/asyncio-task.rst:153
msgid "Example chaining coroutines::"
msgstr "ã‚³ãƒ«ãƒ¼ãƒãƒ³ã‚’ãƒã‚§ãƒ¼ãƒ³ã™ã‚‹ä¾‹ã§ã™::"

#: ../../library/asyncio-task.rst:170
msgid ""
"``compute()`` is chained to ``print_sum()``: ``print_sum()`` coroutine waits"
" until ``compute()`` is completed before returning its result."
msgstr ""
"``compute()`` ã¯ ``print_sum()`` ã«ãƒã‚§ãƒ¼ãƒ³ã•ã‚Œã¾ã™: ``print_sum()`` ã‚³ãƒ«ãƒ¼ãƒãƒ³ã¯ "
"``compute()`` ãŒå®Œäº†ã™ã‚‹ã¾ã§å¾…ã¡ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:173
msgid "Sequence diagram of the example:"
msgstr "ã“ã®ä¾‹ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å›³ã§ã™:"

#: ../../library/asyncio-task.rst:178
msgid ""
"The \"Task\" is created by the :meth:`AbstractEventLoop.run_until_complete` "
"method when it gets a coroutine object instead of a task."
msgstr ""

#: ../../library/asyncio-task.rst:181
msgid ""
"The diagram shows the control flow, it does not describe exactly how things "
"work internally. For example, the sleep coroutine creates an internal future"
" which uses :meth:`AbstractEventLoop.call_later` to wake up the task in 1 "
"second."
msgstr ""

#: ../../library/asyncio-task.rst:187
msgid "InvalidStateError"
msgstr "InvalidStateError"

#: ../../library/asyncio-task.rst:191
msgid "The operation is not allowed in this state."
msgstr "æ“ä½œã¯ã“ã®çŠ¶æ…‹ã§ã¯è¨±å¯ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-task.rst:195
msgid "TimeoutError"
msgstr "TimeoutError"

#: ../../library/asyncio-task.rst:199
msgid "The operation exceeded the given deadline."
msgstr "æ“ä½œã¯ä¸ãˆã‚‰ã‚ŒãŸæœŸé™ã‚’è¶…ãˆã¾ã—ãŸã€‚"

#: ../../library/asyncio-task.rst:203
msgid ""
"This exception is different from the builtin :exc:`TimeoutError` exception!"
msgstr "ã“ã®ä¾‹å¤–ã¯çµ„ã¿è¾¼ã¿ã® :exc:`TimeoutError` ä¾‹å¤–ã¨ã¯ç•°ãªã‚Šã¾ã™ï¼"

#: ../../library/asyncio-task.rst:207
msgid "Future"
msgstr "ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼"

#: ../../library/asyncio-task.rst:211
msgid ""
"This class is *almost* compatible with :class:`concurrent.futures.Future`."
msgstr "ã“ã®ã‚¯ãƒ©ã‚¹ã¯ :class:`concurrent.futures.Future` ã¨ *ã»ã¼* äº’æ›ã§ã™ã€‚"

#: ../../library/asyncio-task.rst:213
msgid "Differences:"
msgstr "ç›¸é•ç‚¹:"

#: ../../library/asyncio-task.rst:215
msgid ""
":meth:`result` and :meth:`exception` do not take a timeout argument and "
"raise an exception when the future isn't done yet."
msgstr ""
":meth:`result` ãŠã‚ˆã³ :meth:`exception` "
"ã¯ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå¼•æ•°ã‚’å–ã‚‰ãšã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒã¾ã çµ‚äº†ã—ã¦ã„ãªã„ã¨ãä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:218
msgid ""
"Callbacks registered with :meth:`add_done_callback` are always called via "
"the event loop's :meth:`~AbstractEventLoop.call_soon`."
msgstr ""

#: ../../library/asyncio-task.rst:221
msgid ""
"This class is not compatible with the :func:`~concurrent.futures.wait` and "
":func:`~concurrent.futures.as_completed` functions in the "
":mod:`concurrent.futures` package."
msgstr ""
"ã“ã®ã‚¯ãƒ©ã‚¹ã¯ :mod:`concurrent.futures` ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã® :func:`~concurrent.futures.wait` ãŠã‚ˆã³"
" :func:`~concurrent.futures.as_completed` é–¢æ•°ã¨ã®äº’æ›æ€§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-task.rst:225 ../../library/asyncio-task.rst:392
msgid "This class is :ref:`not thread safe <asyncio-multithreading>`."
msgstr "ã“ã®ã‚¯ãƒ©ã‚¹ã¯ :ref:`ã‚¹ãƒ¬ãƒƒãƒ‰å®‰å…¨ã§ã¯ã‚ã‚Šã¾ã›ã‚“ <asyncio-multithreading>`ã€‚"

#: ../../library/asyncio-task.rst:229
msgid "Cancel the future and schedule callbacks."
msgstr "ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã¨ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã•ã‚ŒãŸã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:231
msgid ""
"If the future is already done or cancelled, return ``False``. Otherwise, "
"change the future's state to cancelled, schedule the callbacks and return "
"``True``."
msgstr ""
"ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒã™ã§ã«çµ‚äº†ã—ã¦ã„ã‚‹ã‹ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¦ã„ãŸå ´åˆ ``False`` "
"ã‚’è¿”ã—ã€ãã†ã§ãªã„å ´åˆãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®çŠ¶æ…‹ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã«å¤‰æ›´ã—ã€ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã—ã€``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:237
msgid "Return ``True`` if the future was cancelled."
msgstr "ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¦ã„ãŸå ´åˆ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:241
msgid "Return ``True`` if the future is done."
msgstr ""

#: ../../library/asyncio-task.rst:243
msgid ""
"Done means either that a result / exception are available, or that the "
"future was cancelled."
msgstr "çµ‚äº†ã¨ã¯ã€çµæœãŒè¿”ã•ã‚ŒãŸã€ä¾‹å¤–ãŒé€å‡ºã•ã‚ŒãŸã€ã‚ã‚‹ã„ã¯ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:248
msgid "Return the result this future represents."
msgstr "ã“ã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒè¡¨ã™çµæœã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:250
msgid ""
"If the future has been cancelled, raises :exc:`CancelledError`. If the "
"future's result isn't yet available, raises :exc:`InvalidStateError`. If the"
" future is done and has an exception set, this exception is raised."
msgstr ""
"ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¦ã„ãŸå ´åˆ :exc:`CancelledError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®çµæœãŒã¾ã åˆ©ç”¨ã§ããªã„å ´åˆ "
":exc:`InvalidStateError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒçµ‚äº†ã—ä¾‹å¤–ã®é›†åˆã‚’æŒã£ã¦ã„ãŸå ´åˆãã®ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:256
msgid "Return the exception that was set on this future."
msgstr "ã“ã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã§è¨­å®šã•ã‚ŒãŸä¾‹å¤–ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:258
msgid ""
"The exception (or ``None`` if no exception was set) is returned only if the "
"future is done. If the future has been cancelled, raises "
":exc:`CancelledError`. If the future isn't done yet, raises "
":exc:`InvalidStateError`."
msgstr ""
"ä¾‹å¤– (ä¾‹å¤–ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ ``None``) ã¯ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒçµ‚äº†ã—ãŸå ´åˆã®ã¿è¿”ã•ã‚Œã¾ã™ã€‚ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¦ã„ãŸå ´åˆ "
":exc:`CancelledError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒã¾ã çµ‚äº†ã—ã¦ã„ãªã„å ´åˆ :exc:`InvalidStateError` "
"ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:265
msgid "Add a callback to be run when the future becomes done."
msgstr "ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒçµ‚äº†ã—ãŸã¨ãã«å®Ÿè¡Œã™ã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’è¿½åŠ ã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:267
msgid ""
"The callback is called with a single argument - the future object. If the "
"future is already done when this is called, the callback is scheduled with "
":meth:`~AbstractEventLoop.call_soon`."
msgstr ""

#: ../../library/asyncio-task.rst:271
msgid ""
":ref:`Use functools.partial to pass parameters to the callback <asyncio-"
"pass-keywords>`. For example, "
"``fut.add_done_callback(functools.partial(print, \"Future:\", flush=True))``"
" will call ``print(\"Future:\", fut, flush=True)``."
msgstr ""
":ref:`å¼•æ•°ã‚’ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã«æ¸¡ã™ã«ã¯ functools.partial ã‚’ä½¿ã„ã¾ã™ <asyncio-pass-keywords>`ã€‚ä¾‹ãˆã° "
"``fut.add_done_callback(functools.partial(print, \"Future:\", flush=True))``"
" ã¯ ``print(\"Future:\", fut, flush=True)`` ã‚’å‘¼ã³ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:278
msgid "Remove all instances of a callback from the \"call when done\" list."
msgstr "\"çµ‚äº†æ™‚ã«å‘¼ã³å‡ºã™\" ãƒªã‚¹ãƒˆã‹ã‚‰ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®ã™ã¹ã¦ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’é™¤å»ã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:280
msgid "Returns the number of callbacks removed."
msgstr "é™¤å»ã•ã‚ŒãŸã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:284
msgid "Mark the future done and set its result."
msgstr "ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®çµ‚äº†ã‚’ãƒãƒ¼ã‚¯ã—ãã®çµæœã‚’è¨­å®šã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:286 ../../library/asyncio-task.rst:293
msgid ""
"If the future is already done when this method is called, raises "
":exc:`InvalidStateError`."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚ŒãŸã¨ãã«ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒã™ã§ã«çµ‚äº†ã—ã¦ã„ã‚‹å ´åˆã€:exc:`InvalidStateError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:291
msgid "Mark the future done and set an exception."
msgstr "ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®çµ‚äº†ã‚’ãƒãƒ¼ã‚¯ã—ä¾‹å¤–ã‚’è¨­å®šã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:298
msgid "Example: Future with run_until_complete()"
msgstr "ä¾‹: run_until_complete() ã‚’ä½¿ã£ãŸãƒ•ãƒ¥ãƒ¼ãƒãƒ£"

#: ../../library/asyncio-task.rst:300
msgid ""
"Example combining a :class:`Future` and a :ref:`coroutine function "
"<coroutine>`::"
msgstr ":class:`Future` ã¨ :ref:`ã‚³ãƒ«ãƒ¼ãƒãƒ³é–¢æ•° <coroutine>` ã‚’çµ„ã¿åˆã‚ã›ãŸä¾‹::"

#: ../../library/asyncio-task.rst:316
msgid ""
"The coroutine function is responsible for the computation (which takes 1 "
"second) and it stores the result into the future. The "
":meth:`~AbstractEventLoop.run_until_complete` method waits for the "
"completion of the future."
msgstr ""

#: ../../library/asyncio-task.rst:322
msgid ""
"The :meth:`~AbstractEventLoop.run_until_complete` method uses internally the"
" :meth:`~Future.add_done_callback` method to be notified when the future is "
"done."
msgstr ""

#: ../../library/asyncio-task.rst:328
msgid "Example: Future with run_forever()"
msgstr "ä¾‹: run_forever() ã‚’ä½¿ã£ãŸãƒ•ãƒ¥ãƒ¼ãƒãƒ£"

#: ../../library/asyncio-task.rst:330
msgid ""
"The previous example can be written differently using the "
":meth:`Future.add_done_callback` method to describe explicitly the control "
"flow::"
msgstr "ä¸Šã®ä¾‹ã‚’ :meth:`Future.add_done_callback` ãƒ¡ã‚½ãƒƒãƒ‰ä½¿ã£ã¦åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼ã‚’æ˜ç¤ºã—ã¦æ›¸ãã“ã¨ã‚‚ã§ãã¾ã™::"

#: ../../library/asyncio-task.rst:353
msgid ""
"In this example, the future is used to link ``slow_operation()`` to "
"``got_result()``: when ``slow_operation()`` is done, ``got_result()`` is "
"called with the result."
msgstr ""
"ã“ã®ä¾‹ã§ã¯ ``slow_operation()`` ã‚’ ``got_result()`` ã«ãƒªãƒ³ã‚¯ã™ã‚‹ãŸã‚ã« future "
"ã‚’ç”¨ã„ã¦ã„ã¾ã™ã€‚``slow_operation()`` ãŒçµ‚äº†ã—ãŸã¨ã ``got_result()`` ãŒçµæœã¨ä¾›ã«å‘¼ã°ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:359
msgid "Task"
msgstr "ã‚¿ã‚¹ã‚¯"

#: ../../library/asyncio-task.rst:363
msgid ""
"Schedule the execution of a :ref:`coroutine <coroutine>`: wrap it in a "
"future. A task is a subclass of :class:`Future`."
msgstr ""
":ref:`ã‚³ãƒ«ãƒ¼ãƒãƒ³ <coroutine>` ã®å®Ÿè¡Œã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã—ã¾ã™: ãã‚Œã‚’ãƒ•ãƒ¥ãƒ¼ãƒãƒ£å†…ã«ãƒ©ãƒƒãƒ—ã—ã¾ã™ã€‚ã‚¿ã‚¹ã‚¯ã¯ "
":class:`Future` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../library/asyncio-task.rst:366
msgid ""
"A task is responsible for executing a coroutine object in an event loop.  If"
" the wrapped coroutine yields from a future, the task suspends the execution"
" of the wrapped coroutine and waits for the completion of the future. When "
"the future is done, the execution of the wrapped coroutine restarts with the"
" result or the exception of the future."
msgstr ""

#: ../../library/asyncio-task.rst:372
msgid ""
"Event loops use cooperative scheduling: an event loop only runs one task at "
"a time. Other tasks may run in parallel if other event loops are running in "
"different threads. While a task waits for the completion of a future, the "
"event loop executes a new task."
msgstr ""
"ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã¯å”èª¿ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã‚’ä½¿ç”¨ã—ã¾ã™: 1 ã¤ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã¯åŒæ™‚ã« 1 "
"ã¤ã®ã‚¿ã‚¹ã‚¯ã®ã¿å®Ÿè¡Œã—ã¾ã™ã€‚ãã®ä»–ã®ã‚¿ã‚¹ã‚¯ã¯ã€ä»–ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ãŒç•°ãªã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã§å®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹å ´åˆã«ä¸¦åˆ—ã§å®Ÿè¡Œã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã‚¿ã‚¹ã‚¯ãŒãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®è¨ˆç®—ã‚’å¾…ã£ã¦ã„ã‚‹é–“ã€ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã¯æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:377
msgid ""
"The cancellation of a task is different from the cancelation of a future. "
"Calling :meth:`cancel` will throw a "
":exc:`~concurrent.futures.CancelledError` to the wrapped coroutine. "
":meth:`~Future.cancelled` only returns ``True`` if the wrapped coroutine did"
" not catch the :exc:`~concurrent.futures.CancelledError` exception, or "
"raised a :exc:`~concurrent.futures.CancelledError` exception."
msgstr ""
"ã‚¿ã‚¹ã‚¯ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã¯ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã¨ã¯ç•°ãªã‚Šã¾ã™ã€‚:meth:`cancel` ã¯ãƒ©ãƒƒãƒ—ã•ã‚ŒãŸã‚³ãƒ«ãƒ¼ãƒãƒ³ã« "
":exc:`~concurrent.futures.CancelledError` ã‚’é€å‡ºã—ã¾ã™ã€‚ãƒ©ãƒƒãƒ—ã•ã‚ŒãŸã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒ "
":exc:`~concurrent.futures.CancelledError` ä¾‹å¤–ã‚’è£œè¶³ã—ãªã‹ã£ãŸã€ã‚ã‚‹ã„ã¯ "
":exc:`~concurrent.futures.CancelledError` "
"ä¾‹å¤–ã‚’é€å‡ºã—ãªã‹ã£ãŸå ´åˆã€:meth:`~Future.cancelled` ã¯å¸¸ã« ``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:385
msgid ""
"If a pending task is destroyed, the execution of its wrapped :ref:`coroutine"
" <coroutine>` did not complete. It is probably a bug and a warning is "
"logged: see :ref:`Pending task destroyed <asyncio-pending-task-destroyed>`."
msgstr ""
"æœªå®Œã®ã‚¿ã‚¹ã‚¯ãŒç ´æ£„ã•ã‚ŒãŸå ´åˆã€ãã‚Œã®ãƒ©ãƒƒãƒ—ã•ã‚ŒãŸ :ref:`ã‚³ãƒ«ãƒ¼ãƒãƒ³ <coroutine>` "
"ã¯å®Œäº†ã—ã¾ã›ã‚“ã€‚ã“ã‚Œã¯ãŠãã‚‰ããƒã‚°ã§ã‚ã‚Šè­¦å‘ŠãŒãƒ­ã‚°ã«è¨˜éŒ²ã•ã‚Œã¾ã™: :ref:`æœªå®Œã®ã‚¿ã‚¹ã‚¯ã®ç ´æ£„ <asyncio-pending-task-"
"destroyed>` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/asyncio-task.rst:389
msgid ""
"Don't directly create :class:`Task` instances: use the :func:`ensure_future`"
" function or the :meth:`AbstractEventLoop.create_task` method."
msgstr ""

#: ../../library/asyncio-task.rst:396
msgid "Return a set of all tasks for an event loop."
msgstr "ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ— *loop* ã®ã™ã¹ã¦ã®ã‚¿ã‚¹ã‚¯ã®é›†åˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:398
msgid "By default all tasks for the current event loop are returned."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ç¾åœ¨ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã®å…¨ã‚¿ã‚¹ã‚¯ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:402
msgid "Return the currently running task in an event loop or ``None``."
msgstr "ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—å†…ã§ç¾åœ¨å®Ÿè¡Œä¸­ã®ã‚¿ã‚¹ã‚¯ã¾ãŸã¯ ``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:404
msgid "By default the current task for the current event loop is returned."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ç¾åœ¨ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã®ç¾åœ¨ã®ã‚¿ã‚¹ã‚¯ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:406
msgid ""
"``None`` is returned when called not in the context of a :class:`Task`."
msgstr ":class:`Task` ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆå†…ã‹ã‚‰å‘¼ã³å‡ºã•ã‚ŒãŸã®ã§ã¯ãªã„å ´åˆ ``None`` ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:410
msgid "Request that this task cancel itself."
msgstr "ã“ã®ã‚¿ã‚¹ã‚¯ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã‚’è‡ªèº«ã§è¦æ±‚ã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:412
msgid ""
"This arranges for a :exc:`~concurrent.futures.CancelledError` to be thrown "
"into the wrapped coroutine on the next cycle through the event loop. The "
"coroutine then has a chance to clean up or even deny the request using "
"try/except/finally."
msgstr ""
"ã“ã‚Œã¯ã€ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã‚’é€šã—ã¦æ¬¡ã®ã‚µã‚¤ã‚¯ãƒ«ã«ãŠã„ã¦ãƒ©ãƒƒãƒ—ã•ã‚ŒãŸã‚³ãƒ«ãƒ¼ãƒãƒ³ã«æŠ•å…¥ã•ã‚Œã‚‹ "
":exc:`~concurrent.futures.CancelledError` ã‚’æº–å‚™ã—ã¾ã™ã€‚ã‚³ãƒ«ãƒ¼ãƒãƒ³ã«ã¯ãã®å¾Œ "
"try/except/finally ã‚’ä½¿ç”¨ã—ã¦ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã™ã‚‹ã‹è¦æ±‚ã‚’æ‹’å¦ã™ã‚‹æ©Ÿä¼šãŒä¸ãˆã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:417
msgid ""
"Unlike :meth:`Future.cancel`, this does not guarantee that the task will be "
"cancelled: the exception might be caught and acted upon, delaying "
"cancellation of the task or preventing cancellation completely. The task may"
" also return a value or raise a different exception."
msgstr ""
":meth:`Future.cancel` ã¨ç•°ãªã‚Šã€ã“ã‚Œã¯ã‚¿ã‚¹ã‚¯ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã‚’ä¿è¨¼ã—ã¾ã›ã‚“: "
"ä¾‹å¤–ãŒè£œè¶³ã•ã‚Œãã‚ŒãŒå‡¦ç†ã•ã‚Œã‚‹ã“ã¨ã§ã€ã‚¿ã‚¹ã‚¯ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«å‡¦ç†ãŒé…å»¶ã—ãŸã‚Šã‚­ãƒ£ãƒ³ã‚»ãƒ«å‡¦ç†ãŒå®Œäº†ã—ãªã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ã¾ãŸã€ã‚¿ã‚¹ã‚¯ã¯æˆ»ã‚Šå€¤ã‚’è¿”ã™ã‹ç•°ãªã‚‹ä¾‹å¤–ã‚’é€å‡ºã™ã‚‹å ´åˆã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:422
msgid ""
"Immediately after this method is called, :meth:`~Future.cancelled` will not "
"return ``True`` (unless the task was already cancelled). A task will be "
"marked as cancelled when the wrapped coroutine terminates with a "
":exc:`~concurrent.futures.CancelledError` exception (even if :meth:`cancel` "
"was not called)."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚ŒãŸç›´å¾Œã¯ :meth:`~Future.cancelled` ã¯ ``True`` ã‚’è¿”ã—ã¾ã›ã‚“ "
"(ã‚¿ã‚¹ã‚¯ãŒã™ã§ã«ã‚­ãƒ£ãƒ³ã‚»ãƒ«æ¸ˆã¿ã®å ´åˆã¯é™¤ã)ã€‚ãƒ©ãƒƒãƒ—ã•ã‚ŒãŸã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒ "
":exc:`~concurrent.futures.CancelledError` ã§ä¸­æ­¢ã•ã‚ŒãŸã¨ãã€ã‚¿ã‚¹ã‚¯ã¯ (:meth:`cancel` "
"ãŒå‘¼ã°ã‚Œãªã‹ã£ãŸå ´åˆã§ã‚‚) ã‚­ãƒ£ãƒ³ã‚»ãƒ«æ¸ˆã¿ã¨ãƒãƒ¼ã‚¯ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:430
msgid "Return the list of stack frames for this task's coroutine."
msgstr "ã“ã®ã‚¿ã‚¹ã‚¯ã®ã‚³ãƒ«ãƒ¼ãƒãƒ³ã®ã‚¹ã‚¿ãƒƒã‚¯ãƒ•ãƒ¬ãƒ¼ãƒ ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:432
msgid ""
"If the coroutine is not done, this returns the stack where it is suspended."
"  If the coroutine has completed successfully or was cancelled, this returns"
" an empty list.  If the coroutine was terminated by an exception, this "
"returns the list of traceback frames."
msgstr ""

#: ../../library/asyncio-task.rst:438
msgid "The frames are always ordered from oldest to newest."
msgstr "ãƒ•ãƒ¬ãƒ¼ãƒ ã¯å¸¸ã«å¤ã„ã‚‚ã®ã‹ã‚‰æ–°ã—ã„ç‰©ã¸ä¸¦ã‚“ã§ã„ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:440
msgid ""
"The optional limit gives the maximum number of frames to return; by default "
"all available frames are returned.  Its meaning differs depending on whether"
" a stack or a traceback is returned: the newest frames of a stack are "
"returned, but the oldest frames of a traceback are returned. (This matches "
"the behavior of the traceback module.)"
msgstr ""
"ä»»æ„ã®å¼•æ•° *limit* ã«ã¯è¿”ã™ãƒ•ãƒ¬ãƒ¼ãƒ ã®æœ€å¤§æ•°ã‚’æŒ‡å®šã—ã¾ã™; "
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯æœ‰åŠ¹ãªã™ã¹ã¦ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãŒè¿”ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯è¿”ã•ã‚Œã‚‹å€¤ãŒã‚¹ã‚¿ãƒƒã‚¯ã‹ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‹ã«ã‚ˆã£ã¦æ„å‘³ãŒå¤‰ã‚ã‚Šã¾ã™: "
"ã‚¹ã‚¿ãƒƒã‚¯ã§ã¯æœ€æ–°ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰è¿”ã•ã‚Œã¾ã™ãŒã€ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã§ã¯æœ€å¤ã®ã‚‚ã®ã‹ã‚‰è¿”ã•ã‚Œã¾ã™ã€‚ (ã“ã‚Œã¯ traceback "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æŒ¯ã‚‹èˆã„ã¨ä¸€è‡´ã—ã¾ã™ã€‚)"

#: ../../library/asyncio-task.rst:446
msgid ""
"For reasons beyond our control, only one stack frame is returned for a "
"suspended coroutine."
msgstr "ã„ã‹ã‚“ã¨ã‚‚ã—ãŒãŸã„ç†ç”±ã«ã‚ˆã‚Šã€ã‚µã‚¹ãƒšãƒ³ãƒ‰ã•ã‚Œã¦ã„ã‚‹ã‚³ãƒ«ãƒ¼ãƒãƒ³ã®å ´åˆã‚¹ã‚¿ãƒƒã‚¯ãƒ•ãƒ¬ãƒ¼ãƒ ãŒ 1 å€‹ã ã‘è¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:451
msgid "Print the stack or traceback for this task's coroutine."
msgstr "ã“ã®ã‚¿ã‚¹ã‚¯ã®ã‚³ãƒ«ãƒ¼ãƒãƒ³ã®ã‚¹ã‚¿ãƒƒã‚¯ã‚ã‚‹ã„ã¯ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:453
msgid ""
"This produces output similar to that of the traceback module, for the frames"
" retrieved by get_stack().  The limit argument is passed to get_stack().  "
"The file argument is an I/O stream to which the output is written; by "
"default output is written to sys.stderr."
msgstr ""
"ã“ã®å‡ºåŠ›ã¯ get_stack() ã«ã‚ˆã£ã¦å›åã•ã‚ŒãŸãƒ•ãƒ¬ãƒ¼ãƒ ã§ã€traceback ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãã‚Œã¨åŒã˜ã§ã™ã€‚å¼•æ•° *limit* ã¯ "
"get_stack() ã«æ¸¡ã•ã‚Œã¾ã™ã€‚å¼•æ•° *file* ã¯å‡ºåŠ›ã‚’æ›¸ãè¾¼ã‚€ I/O ã‚¹ãƒˆãƒªãƒ¼ãƒ ã§ã™; ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ ``sys.stderr`` "
"ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:460
msgid "Example: Parallel execution of tasks"
msgstr "ä¾‹: ã‚¿ã‚¹ã‚¯ã®ä¸¦åˆ—å®Ÿè¡Œ"

#: ../../library/asyncio-task.rst:462
msgid "Example executing 3 tasks (A, B, C) in parallel::"
msgstr "3 å€‹ã®ã‚¿ã‚¹ã‚¯ (A, B, C) ã‚’ä¸¦åˆ—ã«å®Ÿè¡Œã™ã‚‹ä¾‹ã§ã™::"

#: ../../library/asyncio-task.rst:482
msgid "Output::"
msgstr "å‡ºåŠ›::"

#: ../../library/asyncio-task.rst:494
msgid ""
"A task is automatically scheduled for execution when it is created. The "
"event loop stops when all tasks are done."
msgstr "ã‚¿ã‚¹ã‚¯ã¯ä½œæˆã•ã‚ŒãŸã¨ãã«å®Ÿè¡Œã‚’è‡ªå‹•çš„ã«ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã•ã‚Œã¾ã™ã€‚ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã¯ã™ã¹ã¦ã®ã‚¿ã‚¹ã‚¯ãŒçµ‚äº†ã—ãŸã¨ãã«åœæ­¢ã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:499
msgid "Task functions"
msgstr "ã‚¿ã‚¹ã‚¯é–¢æ•°"

#: ../../library/asyncio-task.rst:503
msgid ""
"In the functions below, the optional *loop* argument allows explicitly "
"setting the event loop object used by the underlying task or coroutine.  If "
"it's not provided, the default event loop is used."
msgstr ""

#: ../../library/asyncio-task.rst:509
msgid ""
"Return an iterator whose values, when waited for, are :class:`Future` "
"instances."
msgstr "ãã®å€¤ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‹ã€å¾…æ©Ÿä¸­ã®ã¨ãã¯ :class:`Future` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:512
msgid ""
"Raises :exc:`asyncio.TimeoutError` if the timeout occurs before all Futures "
"are done."
msgstr "å…¨ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒçµ‚äº†ã™ã‚‹å‰ã«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒç™ºç”Ÿã—ãŸå ´åˆ :exc:`asyncio.TimeoutError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:515
msgid "Example::"
msgstr "ä»¥ä¸‹ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ä¾‹ã§ã™::"

#: ../../library/asyncio-task.rst:523
msgid "The futures ``f`` are not necessarily members of fs."
msgstr "ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ ``f`` ã¯ fs ã®ãƒ¡ãƒ³ãƒãƒ¼ã§ã‚ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-task.rst:527
msgid ""
"Schedule the execution of a :ref:`coroutine object <coroutine>`: wrap it in "
"a future. Return a :class:`Task` object."
msgstr ""
":ref:`ã‚³ãƒ«ãƒ¼ãƒãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <coroutine>` ã®å®Ÿè¡Œã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã—ã¾ã™: ã“ã®ã¨ããƒ•ãƒ¥ãƒ¼ãƒãƒ£ã«ãƒ©ãƒƒãƒ—ã—ã¾ã™ã€‚:class:`Task`"
" ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:530
msgid "If the argument is a :class:`Future`, it is returned directly."
msgstr "å¼•æ•°ãŒ :class:`Future` ã®å ´åˆã€ãã‚ŒãŒç›´æ¥è¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:534
msgid "The function accepts any :term:`awaitable` object."
msgstr ""

#: ../../library/asyncio-task.rst:539
msgid "The :meth:`AbstractEventLoop.create_task` method."
msgstr ""

#: ../../library/asyncio-task.rst:543
msgid "A deprecated alias to :func:`ensure_future`."
msgstr ":func:`ensure_future` ã¸ã®éæ¨å¥¨ãªã‚¨ã‚¤ãƒªã‚¢ã‚¹ã§ã™ã€‚"

#: ../../library/asyncio-task.rst:549
msgid ""
"Wrap a :class:`concurrent.futures.Future` object in a :class:`Future` "
"object."
msgstr ""

#: ../../library/asyncio-task.rst:554
msgid ""
"Return a future aggregating results from the given coroutine objects or "
"futures."
msgstr "ä¸ãˆã‚‰ã‚ŒãŸã‚³ãƒ«ãƒ¼ãƒãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚ã‚‹ã„ã¯ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‹ã‚‰ã®çµæœã‚’ä¸€ã¤ã«ã¾ã¨ã‚ãŸãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:557
msgid ""
"All futures must share the same event loop.  If all the tasks are done "
"successfully, the returned future's result is the list of results (in the "
"order of the original sequence, not necessarily the order of results "
"arrival).  If *return_exceptions* is true, exceptions in the tasks are "
"treated the same as successful results, and gathered in the result list; "
"otherwise, the first raised exception will be immediately propagated to the "
"returned future."
msgstr ""

#: ../../library/asyncio-task.rst:565
msgid ""
"Cancellation: if the outer Future is cancelled, all children (that have not "
"completed yet) are also cancelled.  If any child is cancelled, this is "
"treated as if it raised :exc:`~concurrent.futures.CancelledError` -- the "
"outer Future is *not* cancelled in this case.  (This is to prevent the "
"cancellation of one child to cause other children to be cancelled.)"
msgstr ""
"ã‚­ãƒ£ãƒ³ã‚»ãƒ«: å¤–å´ã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸå ´åˆã€ã™ã¹ã¦ã® (ã¾ã å®Œäº†ã—ã¦ã„ãªã„) "
"å­ãƒ—ãƒ­ã‚»ã‚¹ã‚‚ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã™ã€‚ã„ãšã‚Œã‹ã®å­ãƒ—ãƒ­ã‚»ã‚¹ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸå ´åˆã€ã“ã‚Œã¯ "
":exc:`~concurrent.futures.CancelledError` ã‚’é€å‡ºã™ã‚‹ã‚ˆã†ã«æ‰±ã„ã¾ã™ -- ã“ã®å ´åˆå¤–å´ã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«"
" *ã•ã‚Œã¾ã›ã‚“*ã€‚ (This is to prevent the cancellation of one child to cause other "
"children to be cancelled.)"

#: ../../library/asyncio-task.rst:571
msgid ""
"If the *gather* itself is cancelled, the cancellation is propagated "
"regardless of *return_exceptions*."
msgstr ""

#: ../../library/asyncio-task.rst:577
msgid ""
"Return ``True`` if *obj* is a :ref:`coroutine object <coroutine>`, which may"
" be based on a generator or an :keyword:`async def` coroutine."
msgstr ""

#: ../../library/asyncio-task.rst:582
msgid ""
"Return ``True`` if *func* is determined to be a :ref:`coroutine function "
"<coroutine>`, which may be a decorated generator function or an "
":keyword:`async def` function."
msgstr ""

#: ../../library/asyncio-task.rst:588
msgid "Submit a :ref:`coroutine object <coroutine>` to a given event loop."
msgstr ""

#: ../../library/asyncio-task.rst:590
msgid "Return a :class:`concurrent.futures.Future` to access the result."
msgstr ""

#: ../../library/asyncio-task.rst:592
msgid ""
"This function is meant to be called from a different thread than the one "
"where the event loop is running. Usage::"
msgstr ""

#: ../../library/asyncio-task.rst:602
msgid ""
"If an exception is raised in the coroutine, the returned future will be "
"notified. It can also be used to cancel the task in the event loop::"
msgstr ""

#: ../../library/asyncio-task.rst:615
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr "ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã® :ref:`asyncio-multithreading` ç¯€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/asyncio-task.rst:620
msgid ""
"Unlike other functions from the module, :func:`run_coroutine_threadsafe` "
"requires the *loop* argument to be passed explicitly."
msgstr ""

#: ../../library/asyncio-task.rst:628
msgid ""
"Create a :ref:`coroutine <coroutine>` that completes after a given time (in "
"seconds).  If *result* is provided, it is produced to the caller when the "
"coroutine completes."
msgstr ""
"ä¸ãˆã‚‰ã‚ŒãŸæ™‚é–“ (ç§’) å¾Œã«å®Œäº†ã™ã‚‹ :ref:`ã‚³ãƒ«ãƒ¼ãƒãƒ³ <coroutine>` ã‚’ä½œæˆã—ã¾ã™ã€‚*result* "
"ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã€ã‚³ãƒ«ãƒ¼ãƒãƒ³å®Œäº†æ™‚ã«ãã‚ŒãŒå‘¼ã³å‡ºã—å…ƒã«è¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:632
msgid ""
"The resolution of the sleep depends on the :ref:`granularity of the event "
"loop <asyncio-delayed-calls>`."
msgstr "ã‚¹ãƒªãƒ¼ãƒ—ã®åˆ†è§£èƒ½ã¯ :ref:`ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã®ç²’åº¦ <asyncio-delayed-calls>` ã«ä¾å­˜ã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:635 ../../library/asyncio-task.rst:699
msgid "This function is a :ref:`coroutine <coroutine>`."
msgstr "ã“ã®é–¢æ•°ã¯ :ref:`ã‚³ãƒ«ãƒ¼ãƒãƒ³ <coroutine>` ã§ã™ã€‚"

#: ../../library/asyncio-task.rst:639
msgid "Wait for a future, shielding it from cancellation."
msgstr "ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’å¾…æ©Ÿã—ã‚­ãƒ£ãƒ³ã‚»ãƒ«å‡¦ç†ã‹ã‚‰ä¿è­·ã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:641
msgid "The statement::"
msgstr "å‘½ä»¤æ–‡::"

#: ../../library/asyncio-task.rst:645
msgid "is exactly equivalent to the statement::"
msgstr "ä¸Šã®æ–‡ã¯ä»¥ä¸‹ã¨å®Œå…¨ã«ç­‰ä¾¡ã§ã™::"

#: ../../library/asyncio-task.rst:649
msgid ""
"*except* that if the coroutine containing it is cancelled, the task running "
"in ``something()`` is not cancelled.  From the point of view of "
"``something()``, the cancellation did not happen.  But its caller is still "
"cancelled, so the yield-from expression still raises "
":exc:`~concurrent.futures.CancelledError`.  Note: If ``something()`` is "
"cancelled by other means this will still cancel ``shield()``."
msgstr ""
"ãã‚Œã‚’å«ã‚€ã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸå ´åˆã‚’ *é™¤ã*ã€``something()`` "
"å†…ã§å‹•ä½œã™ã‚‹ã‚¿ã‚¹ã‚¯ã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã›ã‚“ã€‚``something()`` "
"å´ã‹ã‚‰è¦‹ã‚‹ã¨ã‚­ãƒ£ãƒ³ã‚»ãƒ«å‡¦ç†ã¯ç™ºç”Ÿã—ã¾ã›ã‚“ã€‚ãŸã ã—ã€å‘¼ã³å‡ºã—å…ƒãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸå ´åˆã¯ã€yield-from è¡¨ç¾ã¯ "
":exc:`~concurrent.futures.CancelledError` ã‚’é€å‡ºã—ã¾ã™ã€‚æ³¨æ„: ``something()`` "
"ãŒä»–ã®ç†ç”±ã§ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸå ´åˆã¯ ``shield()`` ã§ã‚‚ä¿è­·ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-task.rst:656
msgid ""
"If you want to completely ignore cancellation (not recommended) you can "
"combine ``shield()`` with a try/except clause, as follows::"
msgstr ""
"å®Œå…¨ã«ã‚­ãƒ£ãƒ³ã‚»ãƒ«å‡¦ç†ã‚’ç„¡è¦–ã•ã›ãŸã„å ´åˆ (æ¨å¥¨ã¯ã—ã¾ã›ã‚“) ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã« ``shield()`` ã¨ try/except "
"ç¯€ã®çµ„ã¿åˆã‚ã›ã§è¡Œã†ã“ã¨ãŒã§ãã¾ã™::"

#: ../../library/asyncio-task.rst:668
msgid ""
"Wait for the Futures and coroutine objects given by the sequence *futures* "
"to complete.  Coroutines will be wrapped in Tasks. Returns two sets of "
":class:`Future`: (done, pending)."
msgstr ""
"ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ *futures* ã§ä¸ãˆã‚‰ã‚ŒãŸãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŠã‚ˆã³ã‚³ãƒ«ãƒ¼ãƒãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå®Œäº†ã™ã‚‹ã¾ã§å¾…æ©Ÿã—ã¾ã™ã€‚ã‚³ãƒ«ãƒ¼ãƒãƒ³ã¯ã‚¿ã‚¹ã‚¯ã§ãƒ©ãƒƒãƒ—ã•ã‚Œã¾ã™ã€‚æˆ»ã‚Šå€¤ã¯"
" (å®Œäº†ã—ãŸ :class:`Future`, æœªå®Œã® :class:`Future`) ã® 2 å€‹ã®é›†åˆã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:672
msgid "The sequence *futures* must not be empty."
msgstr "ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ *futures* ã¯ç©ºã§ã‚ã£ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-task.rst:674
msgid ""
"*timeout* can be used to control the maximum number of seconds to wait "
"before returning.  *timeout* can be an int or float.  If *timeout* is not "
"specified or ``None``, there is no limit to the wait time."
msgstr ""
"*timeout* ã§çµæœã‚’è¿”ã™ã¾ã§å¾…æ©Ÿã™ã‚‹æœ€å¤§ç§’æ•°ã‚’æŒ‡å®šã§ãã¾ã™ã€‚*timeout* ã¯æ•´æ•°ã‹æµ®å‹•å°æ•°ç‚¹æ•°ã‚’ã¨ã‚Šã¾ã™ã€‚*timeout* "
"ãŒæŒ‡å®šã•ã‚Œãªã„ã‹ ``None`` ã®å ´åˆã€ç„¡æœŸé™ã«å¾…æ©Ÿã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:678
msgid ""
"*return_when* indicates when this function should return.  It must be one of"
" the following constants of the :mod:`concurrent.futures` module:"
msgstr ""
"*return_when* ã§ã“ã®é–¢æ•°ãŒã„ã¤çµæœã‚’è¿”ã™ã‹æŒ‡å®šã—ã¾ã™ã€‚æŒ‡å®šã§ãã‚‹å€¤ã¯ä»¥ä¸‹ã® :mod:`concurrent.futures` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®šæ•°ã®ã©ã‚Œã‹ä¸€ã¤ã§ã™:"

#: ../../library/asyncio-task.rst:684
msgid "Constant"
msgstr "å®šæ•°"

#: ../../library/asyncio-task.rst:684
msgid "Description"
msgstr "èª¬æ˜"

#: ../../library/asyncio-task.rst:686
msgid ":const:`FIRST_COMPLETED`"
msgstr ":const:`FIRST_COMPLETED`"

#: ../../library/asyncio-task.rst:686
msgid "The function will return when any future finishes or is cancelled."
msgstr "ã„ãšã‚Œã‹ã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒçµ‚äº†ã—ãŸã‹ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸã¨ãã«è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:689
msgid ":const:`FIRST_EXCEPTION`"
msgstr ":const:`FIRST_EXCEPTION`"

#: ../../library/asyncio-task.rst:689
msgid ""
"The function will return when any future finishes by raising an exception.  "
"If no future raises an exception then it is equivalent to "
":const:`ALL_COMPLETED`."
msgstr ""
"ã„ãšã‚Œã‹ã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒä¾‹å¤–ã®é€å‡ºã§çµ‚äº†ã—ãŸå ´åˆã«è¿”ã—ã¾ã™ã€‚ä¾‹å¤–ã‚’é€å‡ºã—ãŸãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒãªã„å ´åˆã¯ã€:const:`ALL_COMPLETED` "
"ã¨ç­‰ä¾¡ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:695
msgid ":const:`ALL_COMPLETED`"
msgstr ":const:`ALL_COMPLETED`"

#: ../../library/asyncio-task.rst:695
msgid "The function will return when all futures finish or are cancelled."
msgstr "ã™ã¹ã¦ã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒçµ‚äº†ã—ãŸã‹ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸã¨ãã«è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:701
msgid "Usage::"
msgstr "ä½¿ã„æ–¹::"

#: ../../library/asyncio-task.rst:707
msgid ""
"This does not raise :exc:`asyncio.TimeoutError`! Futures that aren't done "
"when the timeout occurs are returned in the second set."
msgstr ""
"ã“ã‚Œã¯ :exc:`asyncio.TimeoutError` "
"ã‚’é€å‡ºã—ã¾ã›ã‚“ã€‚ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒç™ºç”Ÿã—ã¦å®Œäº†ã—ãªã‹ã£ãŸãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã¯æˆ»ã‚Šå€¤ã®å¾Œè€…ã®é›†åˆã«å«ã¾ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:713
msgid ""
"Wait for the single :class:`Future` or :ref:`coroutine object <coroutine>` "
"to complete with timeout. If *timeout* is ``None``, block until the future "
"completes."
msgstr ""
"å˜ä¸€ã® :class:`Future` ã¾ãŸã¯ :ref:`ã‚³ãƒ«ãƒ¼ãƒãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <coroutine>` ã‚’æœŸé™ä»˜ãã§å¾…æ©Ÿã—ã¾ã™ã€‚*timeout*"
" ãŒ ``None`` ã®å ´åˆã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒå®Œäº†ã™ã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:717
msgid "Coroutine will be wrapped in :class:`Task`."
msgstr "ã‚³ãƒ«ãƒ¼ãƒãƒ³ã¯ :class:`Task` ã§ãƒ©ãƒƒãƒ—ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:719
msgid ""
"Returns result of the Future or coroutine.  When a timeout occurs, it "
"cancels the task and raises :exc:`asyncio.TimeoutError`. To avoid the task "
"cancellation, wrap it in :func:`shield`."
msgstr ""
"ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚ã‚‹ã„ã¯ã‚³ãƒ«ãƒ¼ãƒãƒ³ã®çµæœã‚’è¿”ã—ã¾ã™ã€‚ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒç™ºç”Ÿã—ãŸå ´åˆã€ã‚¿ã‚¹ã‚¯ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã— :exc:`asyncio.TimeoutError` "
"ã‚’é€å‡ºã—ã¾ã™ã€‚ã‚¿ã‚¹ã‚¯ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã‚’æŠ‘æ­¢ã—ãŸã„å ´åˆã¯ :func:`shield` ã§ãƒ©ãƒƒãƒ—ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/asyncio-task.rst:723
msgid "If the wait is cancelled, the future *fut* is also cancelled."
msgstr "å¾…æ©ŸãŒä¸­æ­¢ã•ã‚ŒãŸå ´åˆ *fut* ã‚‚ä¸­æ­¢ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-task.rst:725
msgid "This function is a :ref:`coroutine <coroutine>`, usage::"
msgstr "ã“ã®é–¢æ•°ã¯ :ref:`ã‚³ãƒ«ãƒ¼ãƒãƒ³ <coroutine>` ã§ã™ã€‚ä½¿ç”¨æ³•::"

#: ../../library/asyncio-task.rst:729
msgid "If the wait is cancelled, the future *fut* is now also cancelled."
msgstr "å¾…æ©ŸãŒä¸­æ­¢ã•ã‚ŒãŸå ´åˆ *fut* ã‚‚ä¸­æ­¢ã•ã‚Œã¾ã™ã€‚"
