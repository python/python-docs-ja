# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Yusuke Miyazaki <miyazaki.dev@gmail.com>, 2017
# Shun Sakurai, 2017
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2017
# Masato HASHIMOTO <cabezon.hashimoto@gmail.com>, 2017
# Arihiro TAKASE, 2017
# Naoki INADA <songofacandy@gmail.com>, 2017
# tomoğŸ§, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-10-17 09:30+0900\n"
"PO-Revision-Date: 2017-02-16 17:50+0000\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncore.rst:2
msgid ":mod:`asyncore` --- Asynchronous socket handler"
msgstr ":mod:`asyncore` --- éåŒæœŸã‚½ã‚±ãƒƒãƒˆãƒãƒ³ãƒ‰ãƒ©"

#: ../../library/asyncore.rst:13
msgid "**Source code:** :source:`Lib/asyncore.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/asyncore.py`"

#: ../../library/asyncore.rst:15
msgid "Please use :mod:`asyncio` instead."
msgstr "ä»£ã‚ã‚Šã« :mod:`asyncio` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚"

#: ../../library/asyncore.rst:22
msgid ""
"This module exists for backwards compatibility only.  For new code we "
"recommend using :mod:`asyncio`."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã ã‘ã«å­˜åœ¨ã—ã¾ã™ã€‚æ–°ã—ã„ã‚³ãƒ¼ãƒ‰ã§ã¯ :mod:`asyncio` ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ã€‚"

#: ../../library/asyncore.rst:25
msgid ""
"This module provides the basic infrastructure for writing asynchronous  "
"socket service clients and servers."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€éåŒæœŸã‚½ã‚±ãƒƒãƒˆã‚µãƒ¼ãƒ“ã‚¹ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ»ã‚µãƒ¼ãƒã‚’é–‹ç™ºã™ã‚‹ãŸã‚ã®åŸºç›¤ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/asyncore.rst:28
msgid ""
"There are only two ways to have a program on a single processor do  \"more "
"than one thing at a time.\" Multi-threaded programming is the  simplest and "
"most popular way to do it, but there is another very different technique, "
"that lets you have nearly all the advantages of  multi-threading, without "
"actually using multiple threads.  It's really  only practical if your "
"program is largely I/O bound.  If your program is processor bound, then pre-"
"emptive scheduled threads are probably what you really need.  Network "
"servers are rarely processor bound, however."
msgstr ""
"CPUãŒä¸€ã¤ã—ã‹ãªã„å ´åˆã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒ\"äºŒã¤ã®ã“ã¨ã‚’åŒæ™‚ã«\"å®Ÿè¡Œã™ã‚‹æ–¹æ³•ã¯äºŒã¤ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚‚ã£ã¨ã‚‚ç°¡å˜ã§ä¸€èˆ¬çš„ãªã®ã¯ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ã‚’åˆ©ç”¨ã™ã‚‹æ–¹æ³•ã§ã™ãŒã€ã“ã‚Œã¨ã¯ã¾ã£ãŸãç•°ãªã‚‹ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã§ã€ä¸€ã¤ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã ã‘ã§ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ã¨åŒã˜ã‚ˆã†ãªåŠ¹æœã‚’å¾—ã‚‰ã‚Œã‚‹ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã¯I/Oå‡¦ç†ãŒä¸­å¿ƒã§ã‚ã‚‹å ´åˆã«ã®ã¿æœ‰åŠ¹ã§ã€CPUè² è·ã®é«˜ã„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã¯åŠ¹æœãŒç„¡ãã€ã“ã®å ´åˆã«ã¯ãƒ—ãƒªã‚¨ãƒ³ãƒ—ãƒ†ã‚£ãƒ–ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ãŒå¯èƒ½ãªã‚¹ãƒ¬ãƒƒãƒ‰ãŒæœ‰åŠ¹ã§ã—ã‚‡ã†ã€‚ã—ã‹ã—ã€å¤šãã®å ´åˆã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚µãƒ¼ãƒã§ã¯CPUè² è·ã‚ˆã‚Šã¯IOè² è·ãŒå•é¡Œã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/asyncore.rst:37
msgid ""
"If your operating system supports the :c:func:`select` system call in its "
"I/O library (and nearly all do), then you can use it to juggle multiple "
"communication channels at once; doing other work while your I/O is taking "
"place in the \"background.\"  Although this strategy can seem strange and "
"complex, especially at first, it is in many ways easier to understand and "
"control than multi-threaded programming.  The :mod:`asyncore` module solves "
"many of the difficult problems for you, making the task of building "
"sophisticated high-performance network servers and clients a snap.  For "
"\"conversational\" applications and protocols the companion :mod:`asynchat` "
"module is invaluable."
msgstr ""
"ã‚‚ã—OSã®I/Oãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ« :c:func:`select` "
"ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹å ´åˆï¼ˆã»ã¨ã‚“ã©ã®å ´åˆã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ï¼‰ã€I/Oå‡¦ç†ã¯\"ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰\"ã§å®Ÿè¡Œã—ã€ãã®é–“ã«ä»–ã®å‡¦ç†ã‚’å®Ÿè¡Œã™ã‚Œã°ã€è¤‡æ•°ã®é€šä¿¡ãƒãƒ£ãƒãƒ«ã‚’åŒæ™‚ã«ã“ãªã™ã“ã¨ãŒã§ãã¾ã™ã€‚ä¸€è¦‹ã€ã“ã®æˆ¦ç•¥ã¯å¥‡å¦™ã§è¤‡é›‘ã«æ€ãˆã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€ã„ã‚ã„ã‚ãªé¢ã§ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ã‚ˆã‚Šã‚‚ç†è§£ã—ã‚„ã™ãã€åˆ¶å¾¡ã‚‚å®¹æ˜“ã§ã™ã€‚"
" :mod:`asyncore` "
"ã¯å¤šãã®è¤‡é›‘ãªå•é¡Œã‚’è§£æ±ºæ¸ˆã¿ãªã®ã§ã€æ´—ç·´ã•ã‚Œã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã«ã‚‚å„ªã‚ŒãŸãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚µãƒ¼ãƒã¨ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’ç°¡å˜ã«é–‹ç™ºã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã¨ãã«ã€ "
":mod:`asynchat` ã®ã‚ˆã†ãªã€å¯¾è©±å‹ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚„ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã«ã¯éå¸¸ã«æœ‰åŠ¹ã§ã—ã‚‡ã†ã€‚"

#: ../../library/asyncore.rst:48
msgid ""
"The basic idea behind both modules is to create one or more network "
"*channels*, instances of class :class:`asyncore.dispatcher` and "
":class:`asynchat.async_chat`.  Creating the channels adds them to a global "
"map, used by the :func:`loop` function if you do not provide it with your "
"own *map*."
msgstr ""
"åŸºæœ¬çš„ã«ã¯ã€ã“ã®äºŒã¤ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã†å ´åˆã¯ä¸€ã¤ä»¥ä¸Šã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ *ãƒãƒ£ãƒãƒ«* ã‚’ :class:`asyncore.dispatcher` "
"ã‚¯ãƒ©ã‚¹ã€ã¾ãŸã¯ :class:`asynchat.async_chat` "
"ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã—ã¦ä½œæˆã—ã¾ã™ã€‚ä½œæˆã•ã‚ŒãŸãƒãƒ£ãƒãƒ«ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒãƒƒãƒ—ã«ç™»éŒ²ã•ã‚Œã€ :func:`loop` é–¢æ•°ã§å‚ç…§ã•ã‚Œã¾ã™ã€‚ "
":func:`loop` ã«ã¯ã€å°‚ç”¨ã® *ãƒãƒƒãƒ—* ã‚’æ¸¡ã™äº‹ã‚‚å¯èƒ½ã§ã™ã€‚"

#: ../../library/asyncore.rst:54
msgid ""
"Once the initial channel(s) is(are) created, calling the :func:`loop` "
"function activates channel service, which continues until the last channel "
"(including any that have been added to the map during asynchronous service) "
"is closed."
msgstr ""
"ãƒãƒ£ãƒãƒ«ã‚’ç”Ÿæˆå¾Œã€ :func:`loop` "
"ã‚’å‘¼ã³å‡ºã™ã¨ãƒãƒ£ãƒãƒ«å‡¦ç†ãŒé–‹å§‹ã—ã€æœ€å¾Œã®ãƒãƒ£ãƒãƒ«ï¼ˆéåŒæœŸå‡¦ç†ä¸­ã«ãƒãƒƒãƒ—ã«è¿½åŠ ã•ã‚ŒãŸãƒãƒ£ãƒãƒ«ã‚’å«ã‚€ï¼‰ãŒé–‰ã˜ã‚‹ã¾ã§ç¶™ç¶šã—ã¾ã™ã€‚"

#: ../../library/asyncore.rst:61
msgid ""
"Enter a polling loop that terminates after count passes or all open channels"
" have been closed.  All arguments are optional.  The *count* parameter "
"defaults to ``None``, resulting in the loop terminating only when all "
"channels have been closed.  The *timeout* argument sets the timeout "
"parameter for the appropriate :func:`~select.select` or :func:`~select.poll`"
" call, measured in seconds; the default is 30 seconds.  The *use_poll* "
"parameter, if true, indicates that :func:`~select.poll` should be used in "
"preference to :func:`~select.select` (the default is ``False``)."
msgstr ""
"ãƒãƒ¼ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹ã—ã€count å›ãŒéãã‚‹ã‹ã€å…¨ã¦ã®ã‚ªãƒ¼ãƒ—ãƒ³æ¸ˆã¿ãƒãƒ£ãƒãƒ«ãŒã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚ŒãŸå ´åˆã®ã¿çµ‚äº†ã—ã¾ã™ã€‚å…¨ã¦ã®å¼•æ•°ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã™ã€‚å¼•æ•° "
"*count* ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ ``None`` ã§ã€ãƒ«ãƒ¼ãƒ—ã¯å…¨ã¦ã®ãƒãƒ£ãƒãƒ«ãŒã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚ŒãŸå ´åˆã®ã¿çµ‚äº†ã—ã¾ã™ã€‚å¼•æ•° *timeout* ã¯ "
":func:`~select.select` ã¾ãŸã¯ :func:`~select.poll` ã®å¼•æ•° timeout "
"ã¨ã—ã¦æ¸¡ã•ã‚Œã€ç§’å˜ä½ã§æŒ‡å®šã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ 30 ç§’ã§ã™ã€‚å¼•æ•° *use_poll* ãŒçœŸã®å ´åˆã€ :func:`~select.select` "
"ã§ã¯ãªã :func:`~select.poll` ãŒä½¿ã‚ã‚Œã¾ã™ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ ``False`` ã§ã™)ã€‚"

#: ../../library/asyncore.rst:70
msgid ""
"The *map* parameter is a dictionary whose items are the channels to watch. "
"As channels are closed they are deleted from their map.  If *map* is "
"omitted, a global map is used. Channels (instances of "
":class:`asyncore.dispatcher`, :class:`asynchat.async_chat` and subclasses "
"thereof) can freely be mixed in the map."
msgstr ""
"å¼•æ•° *map* ã«ã¯ã€ç›£è¦–ã™ã‚‹ãƒãƒ£ãƒãƒ«ã‚’ã‚¢ã‚¤ãƒ†ãƒ ã¨ã—ã¦æ ¼ç´ã—ãŸè¾æ›¸ã‚’æŒ‡å®šã—ã¾ã™ã€‚ãƒãƒ£ãƒãƒ«ãŒã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚ŒãŸæ™‚ã« *map* "
"ã‹ã‚‰ãã®ãƒãƒ£ãƒãƒ«ãŒå‰Šé™¤ã•ã‚Œã¾ã™ã€‚ *map* ãŒçœç•¥ã•ã‚ŒãŸå ´åˆã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªãƒãƒƒãƒ—ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ãƒãƒ£ãƒãƒ« "
"(:class:`asyncore.dispatcher`, :class:`asynchat.async_chat` ã¨ãã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹) "
"ã¯è‡ªç”±ã«æ··ãœã¦ map ã«å…¥ã‚Œã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/asyncore.rst:79
msgid ""
"The :class:`dispatcher` class is a thin wrapper around a low-level socket "
"object. To make it more useful, it has a few methods for event-handling "
"which are called from the asynchronous loop.   Otherwise, it can be treated "
"as a normal non-blocking socket object."
msgstr ""
":class:`dispatcher` "
"ã‚¯ãƒ©ã‚¹ã¯ã€ä½ãƒ¬ãƒ™ãƒ«ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è–„ã„ãƒ©ãƒƒãƒ‘ãƒ¼ã§ã™ã€‚ä¾¿å®œä¸Šã€éåŒæœŸãƒ«ãƒ¼ãƒ—ã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã‚‹ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã—ã¦ã„ã¾ã™ãŒã€ã“ã‚Œä»¥å¤–ã®ç‚¹ã§ã¯"
"ã€non-blockingãªã‚½ã‚±ãƒƒãƒˆã¨åŒæ§˜ã§ã™ã€‚"

#: ../../library/asyncore.rst:84
msgid ""
"The firing of low-level events at certain times or in certain connection "
"states tells the asynchronous loop that certain higher-level events have "
"taken place.  For example, if we have asked for a socket to connect to "
"another host, we know that the connection has been made when the socket "
"becomes writable for the first time (at this point you know that you may "
"write to it with the expectation of success).  The implied higher-level "
"events are:"
msgstr ""
"éåŒæœŸãƒ«ãƒ¼ãƒ—å†…ã§ä½ãƒ¬ãƒ™ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç”Ÿã—ãŸå ´åˆã€ç™ºç”Ÿã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚„ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®çŠ¶æ…‹ã‹ã‚‰ç‰¹å®šã®é«˜ãƒ¬ãƒ™ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆã¸ã¨ç½®ãæ›ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä¾‹ãˆã°ã‚½ã‚±ãƒƒãƒˆã‚’ä»–ã®ãƒ›ã‚¹ãƒˆã«æ¥ç¶šã™ã‚‹å ´åˆã€æœ€åˆã®æ›¸ãè¾¼ã¿å¯èƒ½ã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç”Ÿã™ã‚Œã°æ¥ç¶šãŒå®Œäº†ã—ãŸäº‹ãŒåˆ†ã‹ã‚Šã¾ã™(ã“ã®æ™‚ç‚¹ã§ã€ã‚½ã‚±ãƒƒãƒˆã¸ã®æ›¸ãè¾¼ã¿ã¯æˆåŠŸã™ã‚‹ã¨è€ƒãˆã‚‰ã‚Œã‚‹)ã€‚ã“ã®ã‚ˆã†ã«åˆ¤å®šã§ãã‚‹é«˜ãƒ¬ãƒ™ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™:"

#: ../../library/asyncore.rst:93
msgid "Event"
msgstr "Event"

#: ../../library/asyncore.rst:93
msgid "Description"
msgstr "èª¬æ˜"

#: ../../library/asyncore.rst:95
msgid "``handle_connect()``"
msgstr "``handle_connect()``"

#: ../../library/asyncore.rst:95
msgid "Implied by the first read or write event"
msgstr "æœ€åˆã«readã‚‚ã—ãã¯writeã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç”Ÿã—ãŸæ™‚"

#: ../../library/asyncore.rst:98
msgid "``handle_close()``"
msgstr "``handle_close()``"

#: ../../library/asyncore.rst:98
msgid "Implied by a read event with no data available"
msgstr "èª­ã¿è¾¼ã¿å¯èƒ½ãªãƒ‡ãƒ¼ã‚¿ãªã—ã§readã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç”Ÿã—ãŸæ™‚"

#: ../../library/asyncore.rst:101
msgid "``handle_accepted()``"
msgstr "``handle_accepted()``"

#: ../../library/asyncore.rst:101
msgid "Implied by a read event on a listening socket"
msgstr "listenä¸­ã®ã‚½ã‚±ãƒƒãƒˆã§readã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç”Ÿã—ãŸæ™‚"

#: ../../library/asyncore.rst:105
msgid ""
"During asynchronous processing, each mapped channel's :meth:`readable` and "
":meth:`writable` methods are used to determine whether the channel's socket "
"should be added to the list of channels :c:func:`select`\\ ed or "
":c:func:`poll`\\ ed for read and write events."
msgstr ""
"éåŒæœŸå‡¦ç†ä¸­ã€ãƒãƒƒãƒ—ã«ç™»éŒ²ã•ã‚ŒãŸãƒãƒ£ãƒãƒ«ã® :meth:`readable` ãƒ¡ã‚½ãƒƒãƒ‰ã¨ :meth:`writable` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã€ "
":c:func:`select` ã‹ :c:func:`poll` ã§read/writeã‚¤ãƒ™ãƒ³ãƒˆã‚’æ¤œå‡ºã™ã‚‹ãƒªã‚¹ãƒˆã«ç™»éŒ²ã™ã‚‹ã‹å¦ã‹ã‚’åˆ¤å®šã—ã¾ã™ã€‚"

#: ../../library/asyncore.rst:110
msgid ""
"Thus, the set of channel events is larger than the basic socket events.  The"
" full set of methods that can be overridden in your subclass follows:"
msgstr ""
"ã“ã®ã‚ˆã†ã«ã—ã¦ã€ãƒãƒ£ãƒãƒ«ã§ã¯ä½ãƒ¬ãƒ™ãƒ«ãªã‚½ã‚±ãƒƒãƒˆã‚¤ãƒ™ãƒ³ãƒˆã®ç¨®é¡ã‚ˆã‚Šå¤šãã®ç¨®é¡ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’æ¤œå‡ºã™ã‚‹äº‹ãŒã§ãã¾ã™ã€‚ä»¥ä¸‹ã«ã‚ã’ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã¯ã€ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚ªãƒ¼ãƒãƒ©ã‚¤ãƒ‰ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™:"

#: ../../library/asyncore.rst:116
msgid ""
"Called when the asynchronous loop detects that a :meth:`read` call on the "
"channel's socket will succeed."
msgstr "éåŒæœŸãƒ«ãƒ¼ãƒ—ã§ã€ãƒãƒ£ãƒãƒ«ã®ã‚½ã‚±ãƒƒãƒˆã® :meth:`read` ãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—ãŒæˆåŠŸã—ãŸæ™‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncore.rst:122
msgid ""
"Called when the asynchronous loop detects that a writable socket can be "
"written.  Often this method will implement the necessary buffering for "
"performance.  For example::"
msgstr ""
"éåŒæœŸãƒ«ãƒ¼ãƒ—ã§ã€æ›¸ãè¾¼ã¿å¯èƒ½ã‚½ã‚±ãƒƒãƒˆãŒå®Ÿéš›ã«æ›¸ãè¾¼ã¿å¯èƒ½ã«ãªã£ãŸæ™‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯ã€ã—ã°ã—ã°ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®å‘ä¸Šã®ãŸã‚ã«å¿…è¦ãªãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°ã‚’å®Ÿè£…ã—ã¾ã™ã€‚ä¾‹::"

#: ../../library/asyncore.rst:133
msgid ""
"Called when there is out of band (OOB) data for a socket connection.  This "
"will almost never happen, as OOB is tenuously supported and rarely used."
msgstr ""
"out of band "
"(OOB)ãƒ‡ãƒ¼ã‚¿ãŒæ¤œå‡ºã•ã‚ŒãŸæ™‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚OOBã¯ã‚ã¾ã‚Šã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ãŠã‚‰ãšã€ã¾ãŸæ»…å¤šã«ä½¿ã‚ã‚Œãªã„ã®ã§ã€:meth:`handle_expt` "
"ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã“ã¨ã¯ã»ã¨ã‚“ã©ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/asyncore.rst:139
msgid ""
"Called when the active opener's socket actually makes a connection.  Might "
"send a \"welcome\" banner, or initiate a protocol negotiation with the "
"remote endpoint, for example."
msgstr "ã‚½ã‚±ãƒƒãƒˆã®æ¥ç¶šãŒç¢ºç«‹ã—ãŸæ™‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚\"welcome\"ãƒãƒŠãƒ¼ã®é€ä¿¡ã€ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒã‚´ã‚·ã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–ãªã©ã‚’è¡Œã„ã¾ã™ã€‚"

#: ../../library/asyncore.rst:146
msgid "Called when the socket is closed."
msgstr "ã‚½ã‚±ãƒƒãƒˆãŒé–‰ã˜ãŸæ™‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncore.rst:151
msgid ""
"Called when an exception is raised and not otherwise handled.  The default "
"version prints a condensed traceback."
msgstr "æ•æ‰ã•ã‚Œãªã„ä¾‹å¤–ãŒç™ºç”Ÿã—ãŸæ™‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€çŸ­ç¸®ã—ãŸãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯æƒ…å ±ãŒå‡ºåŠ›ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncore.rst:157
msgid ""
"Called on listening channels (passive openers) when a connection can be "
"established with a new remote endpoint that has issued a :meth:`connect` "
"call for the local endpoint. Deprecated in version 3.2; use "
":meth:`handle_accepted` instead."
msgstr ""
"listen ä¸­ã®ãƒãƒ£ãƒãƒ« (å—å‹•çš„ã«ã‚ªãƒ¼ãƒ—ãƒ³ã—ãŸã‚‚ã®) ãŒãƒªãƒ¢ãƒ¼ãƒˆãƒ›ã‚¹ãƒˆã‹ã‚‰ã® :meth:`connect` ã§æ¥ç¶šã•ã‚Œã€æ¥ç¶šãŒç¢ºç«‹ã—ãŸæ™‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚\n"
"ãƒãƒ¼ã‚¸ãƒ§ãƒ³ 3.2 ã§éæ¨å¥¨ã«ãªã‚Šã¾ã—ãŸ; ä»£ã‚ã‚Šã« :meth:`handle_accepted` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚"

#: ../../library/asyncore.rst:167
msgid ""
"Called on listening channels (passive openers) when a connection has been "
"established with a new remote endpoint that has issued a :meth:`connect` "
"call for the local endpoint.  *sock* is a *new* socket object usable to send"
" and receive data on the connection, and *addr* is the address bound to the "
"socket on the other end of the connection."
msgstr ""
"listen ä¸­ã®ãƒãƒ£ãƒãƒ« (å—å‹•çš„ã«ã‚ªãƒ¼ãƒ—ãƒ³ã—ãŸã‚‚ã®) ãŒãƒªãƒ¢ãƒ¼ãƒˆãƒ›ã‚¹ãƒˆã‹ã‚‰ã® :meth:`connect` ã§æ¥ç¶šã•ã‚Œã€æ¥ç¶šãŒç¢ºç«‹ã—ãŸæ™‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚\n"
"*sock* ã¯ãã®æ¥ç¶šã§ãƒ‡ãƒ¼ã‚¿ã‚’é€å—ä¿¡ã™ã‚‹ã®ã«ä½¿ãˆã‚‹ *æ–°ã—ã„* ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã€ *addr* ã¯æ¥ç¶šã®å¯¾å‘ã®ã‚½ã‚±ãƒƒãƒˆã« bind ã•ã‚Œã¦ã„ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã™ã€‚"

#: ../../library/asyncore.rst:178
msgid ""
"Called each time around the asynchronous loop to determine whether a "
"channel's socket should be added to the list on which read events can occur."
"  The default method simply returns ``True``, indicating that by default, "
"all channels will be interested in read events."
msgstr ""
"éåŒæœŸãƒ«ãƒ¼ãƒ—ä¸­ã«å‘¼ã³å‡ºã•ã‚Œã€readã‚¤ãƒ™ãƒ³ãƒˆã®ç›£è¦–ãƒªã‚¹ãƒˆã«åŠ ãˆã‚‹ã‹å¦ã‹ã‚’æ±ºå®šã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯ ``True`` "
"ã‚’è¿”ã—ã€readã‚¤ãƒ™ãƒ³ãƒˆã®ç™ºç”Ÿã‚’ç›£è¦–ã—ã¾ã™ã€‚"

#: ../../library/asyncore.rst:186
msgid ""
"Called each time around the asynchronous loop to determine whether a "
"channel's socket should be added to the list on which write events can "
"occur.  The default method simply returns ``True``, indicating that by "
"default, all channels will be interested in write events."
msgstr ""
"éåŒæœŸãƒ«ãƒ¼ãƒ—ä¸­ã«å‘¼ã³å‡ºã•ã‚Œã€writeã‚¤ãƒ™ãƒ³ãƒˆã®ç›£è¦–ãƒªã‚¹ãƒˆã«åŠ ãˆã‚‹ã‹å¦ã‹ã‚’æ±ºå®šã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯ ``True`` "
"ã‚’è¿”ã—ã€writeã‚¤ãƒ™ãƒ³ãƒˆã®ç™ºç”Ÿã‚’ç›£è¦–ã—ã¾ã™ã€‚"

#: ../../library/asyncore.rst:192
msgid ""
"In addition, each channel delegates or extends many of the socket methods. "
"Most of these are nearly identical to their socket partners."
msgstr ""
"ã•ã‚‰ã«ã€ãƒãƒ£ãƒãƒ«ã«ã¯ã‚½ã‚±ãƒƒãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã»ã¼åŒã˜ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã€ãƒãƒ£ãƒãƒ«ã¯ã‚½ã‚±ãƒƒãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã®å¤šãã‚’å§”è­²ãƒ»æ‹¡å¼µã—ã¦ãŠã‚Šã€ã‚½ã‚±ãƒƒãƒˆã¨ã»ã¼åŒã˜ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã¾ã™ã€‚"

#: ../../library/asyncore.rst:198
msgid ""
"This is identical to the creation of a normal socket, and will use the same "
"options for creation.  Refer to the :mod:`socket` documentation for "
"information on creating sockets."
msgstr ""
"å¼•æ•°ã‚‚å«ã‚ã€é€šå¸¸ã®ã‚½ã‚±ãƒƒãƒˆç”Ÿæˆã¨åŒä¸€ã§ã™ã€‚ã‚½ã‚±ãƒƒãƒˆã®ç”Ÿæˆã«ã¤ã„ã¦ã¯ã€ :mod:`socket` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/asyncore.rst:202
msgid "*family* and *type* arguments can be omitted."
msgstr "*family* å¼•æ•°ã¨ *type* å¼•æ•°ãŒçœç•¥å¯èƒ½ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/asyncore.rst:208
msgid ""
"As with the normal socket object, *address* is a tuple with the first "
"element the host to connect to, and the second the port number."
msgstr "é€šå¸¸ã®ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨åŒæ§˜ã€*address* ã«ã¯ä¸€ç•ªç›®ã®å€¤ãŒæ¥ç¶šå…ˆãƒ›ã‚¹ãƒˆã€\\ 2ç•ªç›®ã®å€¤ãŒãƒãƒ¼ãƒˆç•ªå·ã§ã‚ã‚‹ã‚¿ãƒ—ãƒ«ã‚’æŒ‡å®šã—ã¾ã™ã€‚"

#: ../../library/asyncore.rst:214
msgid "Send *data* to the remote end-point of the socket."
msgstr "ãƒªãƒ¢ãƒ¼ãƒˆå´ã®ç«¯ç‚¹ã« *data* ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/asyncore.rst:219
msgid ""
"Read at most *buffer_size* bytes from the socket's remote end-point.  An "
"empty bytes object implies that the channel has been closed from the other "
"end."
msgstr ""
"ãƒªãƒ¢ãƒ¼ãƒˆå´ã®ç«¯ç‚¹ã‚ˆã‚Šã€æœ€å¤§ *buffer_size* "
"ãƒã‚¤ãƒˆã®ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚é•·ã•0ã®ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè¿”ã£ã¦ããŸå ´åˆã€ãƒãƒ£ãƒãƒ«ã¯ãƒªãƒ¢ãƒ¼ãƒˆã‹ã‚‰åˆ‡æ–­ã•ã‚ŒãŸäº‹ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/asyncore.rst:223
msgid ""
"Note that :meth:`recv` may raise :exc:`BlockingIOError` , even though "
":func:`select.select` or :func:`select.poll` has reported the socket ready "
"for reading."
msgstr ""
":func:`select.select` ã‚„ :func:`select.poll` ãŒã‚½ã‚±ãƒƒãƒˆãŒèª­ã¿è¾¼ã¿ã§ãã‚‹çŠ¶æ…‹ã«ã‚ã‚‹ã¨å ±å‘Šã—ãŸã¨ã—ã¦ã‚‚ã€ "
":meth:`recv` ãŒ :exc:`BlockingIOError` ã‚’é€å‡ºã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/asyncore.rst:230
msgid ""
"Listen for connections made to the socket.  The *backlog* argument specifies"
" the maximum number of queued connections and should be at least 1; the "
"maximum value is system-dependent (usually 5)."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã¸ã®æ¥ç¶šã‚’å¾…ã¡ã¾ã™ã€‚å¼•æ•° *backlog* ã¯ã€ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã§ãã‚‹ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®æœ€å¤§æ•° (1 ä»¥ä¸Š) "
"ã‚’æŒ‡å®šã—ã¾ã™ã€‚æœ€å¤§å€¤ã¯ã‚·ã‚¹ãƒ†ãƒ ã«ä¾å­˜ã—ã¾ã™ï¼ˆé€šå¸¸ã¯5)ã€‚"

#: ../../library/asyncore.rst:237
msgid ""
"Bind the socket to *address*.  The socket must not already be bound.  (The "
"format of *address* depends on the address family --- refer to the "
":mod:`socket` documentation for more information.)  To mark the socket as "
"re-usable (setting the :const:`SO_REUSEADDR` option), call the "
":class:`dispatcher` object's :meth:`set_reuse_addr` method."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã‚’ *address* ã«ãƒã‚¤ãƒ³ãƒ‰ã—ã¾ã™ã€‚ã‚½ã‚±ãƒƒãƒˆã¯ãƒã‚¤ãƒ³ãƒ‰æ¸ˆã¿ã§ã‚ã£ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ (*address* "
"ã®å½¢å¼ã¯ã€ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã«ä¾å­˜ã—ã¾ã™ã€‚ :mod:`socket` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‚ç…§ã®ã“ã¨ã€‚) ã‚½ã‚±ãƒƒãƒˆã‚’å†åˆ©ç”¨å¯èƒ½ã«ã™ã‚‹ "
"(:const:`SO_REUSEADDR` ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¨­å®šã™ã‚‹) ã«ã¯ã€ :class:`dispatcher` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® "
":meth:`set_reuse_addr` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¦ãã ã•ã„ã€‚"

#: ../../library/asyncore.rst:246
msgid ""
"Accept a connection.  The socket must be bound to an address and listening "
"for connections.  The return value can be either ``None`` or a pair ``(conn,"
" address)`` where *conn* is a *new* socket object usable to send and receive"
" data on the connection, and *address* is the address bound to the socket on"
" the other end of the connection. When ``None`` is returned it means the "
"connection didn't take place, in which case the server should just ignore "
"this event and keep listening for further incoming connections."
msgstr ""
"æ¥ç¶šã‚’å—ã‘å…¥ã‚Œã¾ã™ã€‚ã‚½ã‚±ãƒƒãƒˆã¯ã‚¢ãƒ‰ãƒ¬ã‚¹ã«ãƒã‚¤ãƒ³ãƒ‰æ¸ˆã¿ã§ã‚ã‚Šã€:meth:`listen` ã§æ¥ç¶šå¾…ã¡çŠ¶æ…‹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚æˆ»ã‚Šå€¤ã¯ ``None``"
" ã‹ ``(conn, address)`` ã®ãƒšã‚¢ã§ã€*conn* ã¯ãƒ‡ãƒ¼ã‚¿ã®é€å—ä¿¡ã‚’è¡Œã† **æ–°ã—ã„** ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€*address* "
"ã¯æ¥ç¶šå…ˆã‚½ã‚±ãƒƒãƒˆãŒãƒã‚¤ãƒ³ãƒ‰ã•ã‚Œã¦ã„ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã™ã€‚``None`` "
"ãŒè¿”ã•ã‚ŒãŸå ´åˆã€æ¥ç¶šãŒèµ·ã“ã‚‰ãªã‹ã£ãŸã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚ãã®å ´åˆã€ã‚µãƒ¼ãƒãƒ¼ã¯ã“ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç„¡è¦–ã—ã¦å¾Œç¶šã®æ¥ç¶šã‚’å¾…ã¡ç¶šã‘ã‚‹ã¹ãã§ã™ã€‚"

#: ../../library/asyncore.rst:258
msgid ""
"Close the socket.  All future operations on the socket object will fail. The"
" remote end-point will receive no more data (after queued data is flushed)."
"  Sockets are automatically closed when they are garbage-collected."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¾ã™ã€‚ä»¥é™ã®å…¨ã¦ã®æ“ä½œã¯å¤±æ•—ã—ã¾ã™ã€‚ãƒªãƒ¢ãƒ¼ãƒˆç«¯ç‚¹ã§ã¯ã€ã‚­ãƒ¥ãƒ¼ã«æºœã¾ã£ãŸãƒ‡ãƒ¼ã‚¿ä»¥å¤–ã€ã“ã‚Œä»¥é™ã®ãƒ‡ãƒ¼ã‚¿å—ä¿¡ã¯è¡Œãˆã¾ã›ã‚“ã€‚ã‚½ã‚±ãƒƒãƒˆã¯ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ãƒˆæ™‚ã«è‡ªå‹•çš„ã«ã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncore.rst:266
msgid ""
"A :class:`dispatcher` subclass which adds simple buffered output capability,"
" useful for simple clients. For more sophisticated usage use "
":class:`asynchat.async_chat`."
msgstr ""
":class:`dispatcher` "
"ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã€ã‚·ãƒ³ãƒ—ãƒ«ãªãƒãƒƒãƒ•ã‚¡ã•ã‚ŒãŸå‡ºåŠ›æ©Ÿèƒ½ã‚’æŒã¡ã¾ã™ã€‚ã‚·ãƒ³ãƒ—ãƒ«ãªã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«é©ã—ã¦ã„ã¾ã™ã€‚ã‚‚ã£ã¨é«˜ãƒ¬ãƒ™ãƒ«ãªå ´åˆã«ã¯ "
":class:`asynchat.async_chat` ã‚’åˆ©ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/asyncore.rst:272
msgid ""
"A file_dispatcher takes a file descriptor or :term:`file object` along with "
"an optional map argument and wraps it for use with the :c:func:`poll` or "
":c:func:`loop` functions.  If provided a file object or anything with a "
":c:func:`fileno` method, that method will be called and passed to the "
":class:`file_wrapper` constructor."
msgstr ""

#: ../../library/asyncore.rst:278 ../../library/asyncore.rst:287
msgid "Availability: Unix."
msgstr "åˆ©ç”¨ã§ãã‚‹ç’°å¢ƒ : Unix ã€‚"

#: ../../library/asyncore.rst:282
msgid ""
"A file_wrapper takes an integer file descriptor and calls :func:`os.dup` to "
"duplicate the handle so that the original handle may be closed independently"
" of the file_wrapper.  This class implements sufficient methods to emulate a"
" socket for use by the :class:`file_dispatcher` class."
msgstr ""

#: ../../library/asyncore.rst:293
msgid "asyncore Example basic HTTP client"
msgstr "asyncoreã®ä¾‹: ç°¡å˜ãªHTTPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ"

#: ../../library/asyncore.rst:295
msgid ""
"Here is a very basic HTTP client that uses the :class:`dispatcher` class to "
"implement its socket handling::"
msgstr ""
"åŸºæœ¬çš„ãªã‚µãƒ³ãƒ—ãƒ«ã¨ã—ã¦ã€ä»¥ä¸‹ã«éå¸¸ã«å˜ç´”ãªHTTPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’ç¤ºã—ã¾ã™ã€‚ã“ã®HTTPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ :class:`dispatcher` "
"ã‚¯ãƒ©ã‚¹ã§ã‚½ã‚±ãƒƒãƒˆã‚’åˆ©ç”¨ã—ã¦ã„ã¾ã™::"

#: ../../library/asyncore.rst:332
msgid "asyncore Example basic echo server"
msgstr "åŸºæœ¬çš„ãª echo ã‚µãƒ¼ãƒãƒ¼ã®ä¾‹"

#: ../../library/asyncore.rst:334
msgid ""
"Here is a basic echo server that uses the :class:`dispatcher` class to "
"accept connections and dispatches the incoming connections to a handler::"
msgstr ""
"ã“ã®ä¾‹ã®åŸºæœ¬çš„ãª echoã‚µãƒ¼ãƒãƒ¼ã¯ã€ :class:`dispatcher` ã‚’åˆ©ç”¨ã—ã¦æ¥ç¶šã‚’å—ã‘ã¤ã‘ã€æ¥ç¶šã‚’ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã«ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒã—ã¾ã™::"
