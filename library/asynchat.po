# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 01:01+0900\n"
"PO-Revision-Date: 2018-01-20 20:58+0000\n"
"Last-Translator: tomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/"
"language/ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asynchat.rst:2
msgid ":mod:`asynchat` --- Asynchronous socket command/response handler"
msgstr ":mod:`asynchat` --- 非同期ソケットコマンド/レスポンスハンドラ"

#: ../../library/asynchat.rst:9
msgid "**Source code:** :source:`Lib/asynchat.py`"
msgstr "**ソースコード:** :source:`Lib/asynchat.py`"

#: ../../library/asynchat.rst:13
msgid ""
"This module builds on the :mod:`asyncore` infrastructure, simplifying "
"asynchronous clients and servers and making it easier to handle protocols "
"whose elements are terminated by arbitrary strings, or are of variable "
"length. :mod:`asynchat` defines the abstract class :class:`async_chat` that "
"you subclass, providing implementations of the :meth:`collect_incoming_data` "
"and :meth:`found_terminator` methods. It uses the same asynchronous loop as :"
"mod:`asyncore`, and the two types of channel, :class:`asyncore.dispatcher` "
"and :class:`asynchat.async_chat`, can freely be mixed in the channel map. "
"Typically an :class:`asyncore.dispatcher` server channel generates new :"
"class:`asynchat.async_chat` channel objects as it receives incoming "
"connection requests."
msgstr ""
":mod:`asynchat` を使うと、 :mod:`asyncore` を基盤とした非同期なサーバ・クライ"
"アントをより簡単に開発する事ができます。 :mod:`asynchat` では、プロトコルの要"
"素が任意の文字列で終了するか、または可変長の文字列であるようなプロトコルを容"
"易に制御できるようになっています。 :mod:`asynchat` は、抽象クラス :class:"
"`async_chat` を定義しており、 :class:`async_chat` を継承して :meth:"
"`collect_incoming_data` メソッドと :meth:`found_terminator` メソッドを実装す"
"れば使うことができます。 :class:`async_chat` と :mod:`asyncore` は同じ非同期"
"ループを使用しており、 :class:`asyncore.dispatcher` も :class:`asynchat."
"async_chat` も同じチャネルマップに登録する事ができます。通常、 :class:"
"`asyncore.dispatcher` はサーバチャネルとして使用し、リクエストの受け付け時"
"に :class:`asynchat.async_chat` オブジェクトを生成します。"

#: ../../library/asynchat.rst:28
msgid ""
"This class is an abstract subclass of :class:`asyncore.dispatcher`. To make "
"practical use of the code you must subclass :class:`async_chat`, providing "
"meaningful :meth:`collect_incoming_data` and :meth:`found_terminator` "
"methods. The :class:`asyncore.dispatcher` methods can be used, although not "
"all make sense in a message/response context."
msgstr ""
"このクラスは、 :class:`asyncore.dispatcher` から継承した抽象クラスです。使用"
"する際には :class:`async_chat` のサブクラスを作成し、 :meth:"
"`collect_incoming_data` と :meth:`found_terminator` を定義しなければなりませ"
"ん。 :class:`asyncore.dispatcher` のメソッドを使用する事もできますが、メッ"
"セージ/レスポンス処理を中心に行う場合には使えないメソッドもあります。"

#: ../../library/asynchat.rst:35
msgid ""
"Like :class:`asyncore.dispatcher`, :class:`async_chat` defines a set of "
"events that are generated by an analysis of socket conditions after a :c:"
"func:`select` call. Once the polling loop has been started the :class:"
"`async_chat` object's methods are called by the event-processing framework "
"with no action on the part of the programmer."
msgstr ""
":class:`asyncore.dispatcher` と同様に、 :class:`async_chat` も :c:func:"
"`select` 呼出し後のソケットの状態からイベントを生成します。ポーリングループ開"
"始後、イベント処理フレームワークが自動的に :class:`async_chat` のメソッドを呼"
"び出しますので、プログラマが処理を記述する必要はありません。"

#: ../../library/asynchat.rst:41
msgid ""
"Two class attributes can be modified, to improve performance, or possibly "
"even to conserve memory."
msgstr ""
"パフォーマンスの向上やメモリの節約のために、2つのクラス属性を調整することがで"
"きます。"

#: ../../library/asynchat.rst:47
msgid "The asynchronous input buffer size (default ``4096``)."
msgstr "非同期入力バッファサイズ (デフォルト値: ``4096``)。"

#: ../../library/asynchat.rst:52
msgid "The asynchronous output buffer size (default ``4096``)."
msgstr "非同期出力バッファサイズ (デフォルト値: ``4096``)。"

#: ../../library/asynchat.rst:54
msgid ""
"Unlike :class:`asyncore.dispatcher`, :class:`async_chat` allows you to "
"define a first-in-first-out queue (fifo) of *producers*. A producer need "
"have only one method, :meth:`more`, which should return data to be "
"transmitted on the channel. The producer indicates exhaustion (*i.e.* that "
"it contains no more data) by having its :meth:`more` method return the empty "
"string. At this point the :class:`async_chat` object removes the producer "
"from the fifo and starts using the next producer, if any. When the producer "
"fifo is empty the :meth:`handle_write` method does nothing. You use the "
"channel object's :meth:`set_terminator` method to describe how to recognize "
"the end of, or an important breakpoint in, an incoming transmission from the "
"remote endpoint."
msgstr ""
":class:`asyncore.dispatcher` と違い、 :class:`async_chat` では *producer* の "
"first-in-first- outキュー(fifo)を作成する事ができます。producerは :meth:"
"`more` メソッドを必ず持ち、このメソッドでチャネル上に送出するデータを返しま"
"す。producerが枯渇状態 (*i.e.* これ以上のデータを持たない状態)にある場合、 :"
"meth:`more` は空文字列を返します。この時、 :class:`async_chat` は枯渇状態にあ"
"るproducerをfifoから除去し、次のproducerが存在すればそのproducerを使用しま"
"す。fifoにproducerが存在しない場合、 :meth:`handle_write` は何もしません。リ"
"モート端点からの入力の終了や重要な中断点を検出する場合は、 :meth:"
"`set_terminator` に記述します。"

#: ../../library/asynchat.rst:67
msgid ""
"To build a functioning :class:`async_chat` subclass your  input methods :"
"meth:`collect_incoming_data` and :meth:`found_terminator` must handle the "
"data that the channel receives asynchronously. The methods are described "
"below."
msgstr ""
":class:`async_chat` のサブクラスでは、入力メソッド :meth:"
"`collect_incoming_data` と :meth:`found_terminator` を定義し、チャネルが非同"
"期に受信するデータを処理します。これらのメソッドについては後ろで解説します。"

#: ../../library/asynchat.rst:75
msgid ""
"Pushes a ``None`` on to the producer fifo. When this producer is popped off "
"the fifo it causes the channel to be closed."
msgstr ""
"producer fifoのトップに ``None`` をプッシュします。このproducerがポップされる"
"と、チャネルがクローズします。"

#: ../../library/asynchat.rst:81
msgid ""
"Called with *data* holding an arbitrary amount of received data.  The "
"default method, which must be overridden, raises a :exc:"
"`NotImplementedError` exception."
msgstr ""
"チャネルが受信した不定長のデータを *data* に指定して呼び出されます。このメ"
"ソッドは必ずオーバライドする必要があり、デフォルトの実装では、 :exc:"
"`NotImplementedError` 例外を送出します。"

#: ../../library/asynchat.rst:88
msgid ""
"In emergencies this method will discard any data held in the input and/or "
"output buffers and the producer fifo."
msgstr "非常用のメソッドで、全ての入出力バッファとproducer fifoを廃棄します。"

#: ../../library/asynchat.rst:94
msgid ""
"Called when the incoming data stream  matches the termination condition set "
"by :meth:`set_terminator`. The default method, which must be overridden, "
"raises a :exc:`NotImplementedError` exception. The buffered input data "
"should be available via an instance attribute."
msgstr ""
"入力データストリームが、 :meth:`set_terminator` で指定した終了条件と一致した"
"場合に呼び出されます。このメソッドは必ずオーバライドする必要があり、デフォル"
"トの実装では、 :exc:`NotImplementedError` 例外を送出します。入力データを参照"
"する必要がある場合でも引数としては与えられないため、入力バッファをインスタン"
"ス属性として参照しなければなりません。"

#: ../../library/asynchat.rst:102
msgid "Returns the current terminator for the channel."
msgstr "現在のチャネルの終了条件を返します。"

#: ../../library/asynchat.rst:107
msgid ""
"Pushes data on to the channel's fifo to ensure its transmission. This is all "
"you need to do to have the channel write the data out to the network, "
"although it is possible to use your own producers in more complex schemes to "
"implement encryption and chunking, for example."
msgstr ""
"チャネルの fifo にデータをプッシュして転送します。データをチャネルに書き出す"
"ために必要なのはこれだけですが、データの暗号化やチャンク化などを行う場合には"
"独自の producer を使用する事もできます。"

#: ../../library/asynchat.rst:115
msgid ""
"Takes a producer object and adds it to the producer fifo associated with the "
"channel.  When all currently-pushed producers have been exhausted the "
"channel will consume this producer's data by calling its :meth:`more` method "
"and send the data to the remote endpoint."
msgstr ""
"指定したproducerオブジェクトをチャネルのfifoに追加します。これより前にpushさ"
"れたproducerが全て枯渇した後、チャネルはこのproducer から :meth:`more` メソッ"
"ドでデータを取得し、リモート端点に送信します。"

#: ../../library/asynchat.rst:123
msgid ""
"Sets the terminating condition to be recognized on the channel.  ``term`` "
"may be any of three types of value, corresponding to three different ways to "
"handle incoming protocol data."
msgstr ""
"チャネルで検出する終了条件を設定します。``term`` は入力プロトコルデータの処理"
"方式によって以下の3つの型の何れかを指定します。"

#: ../../library/asynchat.rst:128
msgid "term"
msgstr "term"

#: ../../library/asynchat.rst:128
msgid "Description"
msgstr "説明"

#: ../../library/asynchat.rst:130
msgid "*string*"
msgstr "*string*"

#: ../../library/asynchat.rst:130
msgid ""
"Will call :meth:`found_terminator` when the string is found in the input "
"stream"
msgstr ""
"入力ストリーム中でstringが検出された時、 :meth:`found_terminator` を呼び出し"
"ます"

#: ../../library/asynchat.rst:133
msgid "*integer*"
msgstr "*integer*"

#: ../../library/asynchat.rst:133
msgid ""
"Will call :meth:`found_terminator` when the indicated number of characters "
"have been received"
msgstr ""
"指定された文字数が読み込まれた時、 :meth:`found_terminator` を呼び出します"

#: ../../library/asynchat.rst:137
msgid "``None``"
msgstr "``None``"

#: ../../library/asynchat.rst:137
msgid "The channel continues to collect data forever"
msgstr "永久にデータを読み込みます"

#: ../../library/asynchat.rst:141
msgid ""
"Note that any data following the terminator will be available for reading by "
"the channel after :meth:`found_terminator` is called."
msgstr ""
"終了条件が成立しても、その後に続くデータは、 :meth:`found_terminator` の呼出"
"し後に再びチャネルを読み込めば取得する事ができます。"

#: ../../library/asynchat.rst:146
msgid "asynchat - Auxiliary Classes"
msgstr "asynchat - 補助クラス"

#: ../../library/asynchat.rst:150
msgid ""
"A :class:`fifo` holding data which has been pushed by the application but "
"not yet popped for writing to the channel.  A :class:`fifo` is a list used "
"to hold data and/or producers until they are required.  If the *list* "
"argument is provided then it should contain producers or data items to be "
"written to the channel."
msgstr ""
"アプリケーションからプッシュされ、まだチャネルに書き出されていないデータを保"
"持するための :class:`fifo` 。 :class:`fifo` は必要になるまでデータと "
"producer を保持するために使われるリストです。引数 *list* には、チャネルに出力"
"する producer またはデータを指定する事ができます。"

#: ../../library/asynchat.rst:159
msgid "Returns ``True`` if and only if the fifo is empty."
msgstr "fifoが空のとき(のみ)に ``True`` を返します。"

#: ../../library/asynchat.rst:164
msgid "Returns the least-recently :meth:`push`\\ ed item from the fifo."
msgstr "fifoに :meth:`push` されたアイテムのうち、最も古いアイテムを返します。"

#: ../../library/asynchat.rst:169
msgid ""
"Adds the given data (which may be a string or a producer object) to the "
"producer fifo."
msgstr "データ(文字列またはproducerオブジェクト)をproducer fifoに追加します。"

#: ../../library/asynchat.rst:175
msgid ""
"If the fifo is not empty, returns ``True, first()``, deleting the popped "
"item.  Returns ``False, None`` for an empty fifo."
msgstr ""
"fifoが空でなければ、``(True, first())`` を返し、ポップされたアイテムを削除し"
"ます。fifoが空であれば ``(False, None)`` を返します。"

#: ../../library/asynchat.rst:182
msgid "asynchat Example"
msgstr "asynchat 使用例"

#: ../../library/asynchat.rst:184
msgid ""
"The following partial example shows how HTTP requests can be read with :"
"class:`async_chat`.  A web server might create an :class:"
"`http_request_handler` object for each incoming client connection. Notice "
"that initially the channel terminator is set to match the blank line at the "
"end of the HTTP headers, and a flag indicates that the headers are being "
"read."
msgstr ""
"以下のサンプルは、 :class:`async_chat` でHTTPリクエストを読み込む処理の一部で"
"す。Webサーバは、クライアントからの接続毎に :class:`http_request_handler` オ"
"ブジェクトを作成します。最初はチャネルの終了条件に空行を指定してHTTPヘッダの"
"末尾までを検出し、その後ヘッダ読み込み済みを示すフラグを立てています。"

#: ../../library/asynchat.rst:191
msgid ""
"Once the headers have been read, if the request is of type POST (indicating "
"that further data are present in the input stream) then the ``Content-Length:"
"`` header is used to set a numeric terminator to read the right amount of "
"data from the channel."
msgstr ""
"ヘッダ読み込んだ後、リクエストの種類がPOSTであればデータが入力ストリームに流"
"れるため、``Content-Length:`` ヘッダの値を数値として終了条件に指定し、適切な"
"長さのデータをチャネルから読み込みます。"

#: ../../library/asynchat.rst:196
msgid ""
"The :meth:`handle_request` method is called once all relevant input has been "
"marshalled, after setting the channel terminator to ``None`` to ensure that "
"any extraneous data sent by the web client are ignored. ::"
msgstr ""
"必要な入力データを全て入手したら、チャネルの終了条件に ``None`` を指定して残"
"りのデータを無視するようにしています。この後、 :meth:`handle_request` が呼び"
"出されます。 ::"
