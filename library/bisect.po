# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-30 05:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: tomoğŸ§, 2017\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/bisect.rst:2
msgid ":mod:`bisect` --- Array bisection algorithm"
msgstr ":mod:`bisect` --- é…åˆ—äºŒåˆ†æ³•ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ "

#: ../../library/bisect.rst:10
msgid "**Source code:** :source:`Lib/bisect.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/bisect.py`"

#: ../../library/bisect.rst:14
msgid ""
"This module provides support for maintaining a list in sorted order without "
"having to sort the list after each insertion.  For long lists of items with "
"expensive comparison operations, this can be an improvement over the more "
"common approach.  The module is called :mod:`bisect` because it uses a basic"
" bisection algorithm to do its work.  The source code may be most useful as "
"a working example of the algorithm (the boundary conditions are already "
"right!)."
msgstr ""
"ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€æŒ¿å…¥ã®åº¦ã«ãƒªã‚¹ãƒˆã‚’ã‚½ãƒ¼ãƒˆã™ã‚‹ã“ã¨ãªãã€ãƒªã‚¹ãƒˆã‚’ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸé †åºã«ä¿ã¤ã“ã¨ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚å¤§é‡ã®æ¯”è¼ƒæ“ä½œã‚’ä¼´ã†ã‚ˆã†ãªã€ã‚¢ã‚¤ãƒ†ãƒ ãŒãŸãã•ã‚“ã‚ã‚‹ãƒªã‚¹ãƒˆã§ã¯ã€ã‚ˆã‚Šä¸€èˆ¬çš„ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã«æ¯”ã¹ã¦ã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒå‘ä¸Šã—ã¾ã™ã€‚å‹•ä½œã«åŸºæœ¬çš„ãªäºŒåˆ†æ³•ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ä½¿ã£ã¦ã„ã‚‹ã®ã§ã€"
" :mod:`bisect` ã¨å‘¼ã°ã‚Œã¦ã„ã¾ã™ã€‚ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¯ã“ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®å®Ÿä¾‹ã¨ã—ã¦ä¸€ç•ªå½¹ã«ç«‹ã¤ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ (å¢ƒç•Œæ¡ä»¶ã¯ã™ã§ã«æ­£ã—ã„ã§ã™!)ã€‚"

#: ../../library/bisect.rst:21
msgid "The following functions are provided:"
msgstr "æ¬¡ã®é–¢æ•°ãŒç”¨æ„ã•ã‚Œã¦ã„ã¾ã™:"

#: ../../library/bisect.rst:26
msgid ""
"Locate the insertion point for *x* in *a* to maintain sorted order. The "
"parameters *lo* and *hi* may be used to specify a subset of the list which "
"should be considered; by default the entire list is used.  If *x* is already"
" present in *a*, the insertion point will be before (to the left of) any "
"existing entries.  The return value is suitable for use as the first "
"parameter to ``list.insert()`` assuming that *a* is already sorted."
msgstr ""
"ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸé †åºã‚’ä¿ã£ãŸã¾ã¾ *x* ã‚’ *a* ã«æŒ¿å…¥ã§ãã‚‹ç‚¹ã‚’æ¢ã—å½“ã¦ã¾ã™ã€‚ãƒªã‚¹ãƒˆã®ä¸­ã‹ã‚‰æ¤œç´¢ã™ã‚‹éƒ¨åˆ†é›†åˆã‚’æŒ‡å®šã™ã‚‹ã«ã¯ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã® *lo* ã¨"
" *hi* ã‚’ä½¿ã„ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ãƒªã‚¹ãƒˆå…¨ä½“ãŒä½¿ã‚ã‚Œã¾ã™ã€‚*x* ãŒã™ã§ã« *a* "
"ã«å«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã€æŒ¿å…¥ç‚¹ã¯æ—¢å­˜ã®ã©ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚ˆã‚Šã‚‚å‰(å·¦)ã«ãªã‚Šã¾ã™ã€‚æˆ»ã‚Šå€¤ã¯ã€``list.insert()`` "
"ã®ç¬¬ä¸€å¼•æ•°ã¨ã—ã¦ä½¿ã†ã®ã«é©ã—ã¦ã„ã¾ã™ã€‚*a* ã¯ã™ã§ã«ã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã¨ã—ã¾ã™ã€‚"

#: ../../library/bisect.rst:33
msgid ""
"The returned insertion point *i* partitions the array *a* into two halves so"
" that ``all(val < x for val in a[lo:i])`` for the left side and ``all(val >="
" x for val in a[i:hi])`` for the right side."
msgstr ""
"è¿”ã•ã‚ŒãŸæŒ¿å…¥ç‚¹ *i* ã¯ã€é…åˆ— *a* ã‚’äºŒã¤ã«åˆ†ã‘ã€``all(val < x for val in a[lo:i])`` "
"ãŒå·¦å´ã«ã€``all(val >= x for val in a[i:hi])`` ãŒå³å´ã«ãªã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../library/bisect.rst:40
msgid ""
"Similar to :func:`bisect_left`, but returns an insertion point which comes "
"after (to the right of) any existing entries of *x* in *a*."
msgstr ""
":func:`bisect_left` ã¨ä¼¼ã¦ã„ã¾ã™ãŒã€ *a* ã«å«ã¾ã‚Œã‚‹ *x* "
"ã®ã†ã¡ã€ã©ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚ˆã‚Šã‚‚å¾Œã‚(å³)ã«ãã‚‹ã‚ˆã†ãªæŒ¿å…¥ç‚¹ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/bisect.rst:43
msgid ""
"The returned insertion point *i* partitions the array *a* into two halves so"
" that ``all(val <= x for val in a[lo:i])`` for the left side and ``all(val >"
" x for val in a[i:hi])`` for the right side."
msgstr ""
"è¿”ã•ã‚ŒãŸæŒ¿å…¥ç‚¹ *i* ã¯ã€é…åˆ— *a* ã‚’äºŒã¤ã«åˆ†ã‘ã€``all(val <= x for val in a[lo:i])`` "
"ãŒå·¦å´ã«ã€``all(val > x for val in a[i:hi])`` ãŒå³å´ã«ãªã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../library/bisect.rst:49
msgid ""
"Insert *x* in *a* in sorted order.  This is equivalent to "
"``a.insert(bisect.bisect_left(a, x, lo, hi), x)`` assuming that *a* is "
"already sorted.  Keep in mind that the O(log n) search is dominated by the "
"slow O(n) insertion step."
msgstr ""
"*x* ã‚’ *a* ã«ã‚½ãƒ¼ãƒˆé †ã§æŒ¿å…¥ã—ã¾ã™ã€‚ã“ã‚Œã¯ã€*a* "
"ãŒã™ã§ã«ã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹å ´åˆã€``a.insert(bisect.bisect_left(a, x, lo, hi), x)`` "
"ã¨ç­‰ä¾¡ã§ã™ã€‚ãªãŠã€O(log n) ã®æ¢ç´¢ã«å¯¾ã—ã¦ã€é…ã„ O(n) ã®æŒ¿å…¥ã®æ®µéšãŒå¾‹é€Ÿã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/bisect.rst:57
msgid ""
"Similar to :func:`insort_left`, but inserting *x* in *a* after any existing "
"entries of *x*."
msgstr ""
":func:`insort_left` ã¨ä¼¼ã¦ã„ã¾ã™ãŒã€ *a* ã«å«ã¾ã‚Œã‚‹ *x* ã®ã†ã¡ã€ã©ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚ˆã‚Šã‚‚å¾Œã‚ã« *x* ã‚’æŒ¿å…¥ã—ã¾ã™ã€‚"

#: ../../library/bisect.rst:62
msgid ""
"`SortedCollection recipe "
"<https://code.activestate.com/recipes/577197-sortedcollection/>`_ that uses "
"bisect to build a full-featured collection class with straight-forward "
"search methods and support for a key-function.  The keys are precomputed to "
"save unnecessary calls to the key function during searches."
msgstr ""
"bisect ã‚’åˆ©ç”¨ã—ã¦ã€ç›´æ¥ã®æ¢ç´¢ãŒã§ãã€ã‚­ãƒ¼é–¢æ•°ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã€å®Œå…¨ãªæ©Ÿèƒ½ã‚’æŒã¤ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚¯ãƒ©ã‚¹ã‚’çµ„ã¿ç«‹ã¦ã‚‹ `SortedCollection "
"recipe <https://code.activestate.com/recipes/577197-sortedcollection/>`_\\ "
"ã€‚ã‚­ãƒ¼ã¯ã€æ¢ç´¢ä¸­ã«ä¸å¿…è¦ãªå‘¼ã³å‡ºã—ã‚’ã•ã›ãªã„ãŸã‚ã«ã€äºˆã‚è¨ˆç®—ã—ã¦ãŠãã¾ã™ã€‚"

#: ../../library/bisect.rst:70
msgid "Searching Sorted Lists"
msgstr "ã‚½ãƒ¼ãƒˆæ¸ˆã¿ãƒªã‚¹ãƒˆã®æ¢ç´¢"

#: ../../library/bisect.rst:72
msgid ""
"The above :func:`bisect` functions are useful for finding insertion points "
"but can be tricky or awkward to use for common searching tasks. The "
"following five functions show how to transform them into the standard "
"lookups for sorted lists::"
msgstr ""
"ä¸Šè¨˜ã® :func:`bisect` é–¢æ•°ç¾¤ã¯æŒ¿å…¥ç‚¹ã‚’æ¢ç´¢ã™ã‚‹ã®ã«ã¯ä¾¿åˆ©ã§ã™ãŒã€æ™®é€šã®æ¢ç´¢ã‚¿ã‚¹ã‚¯ã«ä½¿ã†ã®ã¯ãƒˆãƒªãƒƒã‚­ãƒ¼ã ã£ãŸã‚Šä¸å™¨ç”¨ã ã£ãŸã‚Šã—ã¾ã™ã€‚ä»¥ä¸‹ã®"
" 5 é–¢æ•°ã¯ã€ã“ã‚Œã‚‰ã‚’ã©ã®ã‚ˆã†ã«æ¨™æº–ã®æ¢ç´¢ã‚„ã‚½ãƒ¼ãƒˆæ¸ˆã¿ãƒªã‚¹ãƒˆã«å¤‰æ›ã™ã‚‹ã‹ã‚’èª¬æ˜ã—ã¾ã™::"

#: ../../library/bisect.rst:114
msgid "Other Examples"
msgstr "ãã®ä»–ã®ä½¿ç”¨ä¾‹"

#: ../../library/bisect.rst:118
msgid ""
"The :func:`bisect` function can be useful for numeric table lookups. This "
"example uses :func:`bisect` to look up a letter grade for an exam score "
"(say) based on a set of ordered numeric breakpoints: 90 and up is an 'A', 80"
" to 89 is a 'B', and so on::"
msgstr ""
":func:`bisect` é–¢æ•°ã¯æ•°å€¤ãƒ†ãƒ¼ãƒ–ãƒ«ã®æ¢ç´¢ã«å½¹ã«ç«‹ã¡ã¾ã™ã€‚ã“ã®ä¾‹ã§ã¯ã€ :func:`bisect` "
"ã‚’ä½¿ã£ã¦ã€(ãŸã¨ãˆã°)é †åºã®ã¤ã„ãŸæ•°å€¤ã®åŒºåˆ‡ã‚Šç‚¹ã®é›†åˆã«åŸºã¥ã„ã¦ã€è©¦é¨“ã®æˆç¸¾ã®ç­‰ç´šã‚’è¡¨ã™æ–‡å­—ã‚’èª¿ã¹ã¾ã™ã€‚åŒºåˆ‡ã‚Šç‚¹ã¯ 90 ä»¥ä¸Šã¯ 'A'ã€ 80 ã‹ã‚‰ "
"89 ã¯ 'B'ã€ãªã©ã§ã™::"

#: ../../library/bisect.rst:130
msgid ""
"Unlike the :func:`sorted` function, it does not make sense for the "
":func:`bisect` functions to have *key* or *reversed* arguments because that "
"would lead to an inefficient design (successive calls to bisect functions "
"would not \"remember\" all of the previous key lookups)."
msgstr ""
":func:`sorted` é–¢æ•°ã¨é•ã„ã€ :func:`bisect` é–¢æ•°ã« *key* ã‚„ *reversed* "
"å¼•æ•°ã‚’ç”¨æ„ã™ã‚‹ã®ã¯ã€è¨­è¨ˆãŒéåŠ¹ç‡ã«ãªã‚‹ã®ã§ã€éåˆç†çš„ã§ã™ (é€£ç¶šã™ã‚‹ bisect é–¢æ•°ã®å‘¼ã³å‡ºã—ã¯å‰å›ã® key å‚ç…§ã®çµæœã‚’ \"è¨˜æ†¶\" "
"ã—ã¾ã›ã‚“)ã€‚"

#: ../../library/bisect.rst:135
msgid ""
"Instead, it is better to search a list of precomputed keys to find the index"
" of the record in question::"
msgstr "ä»£ã‚ã‚Šã«ã€äº‹å‰ã«è¨ˆç®—ã—ã¦ãŠã„ãŸã‚­ãƒ¼ã®ãƒªã‚¹ãƒˆã‹ã‚‰æ¤œç´¢ã—ã¦ã€ãƒ¬ã‚³ãƒ¼ãƒ‰ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¦‹ã¤ã‘ã¾ã™::"
