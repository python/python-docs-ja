# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-12-30 14:59+0000\n"
"PO-Revision-Date: 2022-11-05 17:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2022\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/re.rst:2
msgid ":mod:`re` --- Regular expression operations"
msgstr ":mod:`re` --- 正規表現操作"

#: ../../library/re.rst:10
msgid "**Source code:** :source:`Lib/re.py`"
msgstr "**ソースコード:** :source:`Lib/re.py`"

#: ../../library/re.rst:14
msgid ""
"This module provides regular expression matching operations similar to those "
"found in Perl."
msgstr ""
"このモジュールは Perl に見られる正規表現マッチング操作と同様のものを提供しま"
"す。"

#: ../../library/re.rst:17
msgid ""
"Both patterns and strings to be searched can be Unicode strings (:class:"
"`str`) as well as 8-bit strings (:class:`bytes`). However, Unicode strings "
"and 8-bit strings cannot be mixed: that is, you cannot match a Unicode "
"string with a byte pattern or vice-versa; similarly, when asking for a "
"substitution, the replacement string must be of the same type as both the "
"pattern and the search string."
msgstr ""
"パターンおよび検索される文字列には、Unicode 文字列 (:class:`str`) や 8 ビット"
"文字列 (:class:`bytes`) を使います。ただし、Unicode 文字列と 8 ビット文字列の"
"混在はできません。つまり、Unicode 文字列にバイト列のパターンでマッチングした"
"り、その逆はできません。同様に、置換時の置換文字列はパターンおよび検索文字列"
"の両方と同じ型でなくてはなりません。"

#: ../../library/re.rst:24
msgid ""
"Regular expressions use the backslash character (``'\\'``) to indicate "
"special forms or to allow special characters to be used without invoking "
"their special meaning.  This collides with Python's usage of the same "
"character for the same purpose in string literals; for example, to match a "
"literal backslash, one might have to write ``'\\\\\\\\'`` as the pattern "
"string, because the regular expression must be ``\\\\``, and each backslash "
"must be expressed as ``\\\\`` inside a regular Python string literal. Also, "
"please note that any invalid escape sequences in Python's usage of the "
"backslash in string literals now generate a :exc:`DeprecationWarning` and in "
"the future this will become a :exc:`SyntaxError`. This behaviour will happen "
"even if it is a valid escape sequence for a regular expression."
msgstr ""
"正規表現では、特殊な形式を表すためや、特殊文字をその特殊な意味を発動させず使"
"うために、バックスラッシュ文字 (``'\\'``) を使います。こうしたバックスラッ"
"シュの使い方は、 Python の文字列リテラルにおける同じ文字の使い方と衝突しま"
"す。例えば、リテラルのバックスラッシュにマッチさせるには、パターン文字列とし"
"て ``'\\\\\\\\'`` と書かなければなりません。なぜなら、正規表現は ``\\\\`` で"
"なければならないうえ、それぞれのバックスラッシュは標準の Python 文字列リテラ"
"ルで ``\\\\`` と表現せねばならないからです。 \n"
"Python の文字列リテラルにおいて、バックスラッシュの使用による不正なエスケープ"
"文字がある場合は、:exc:`DeprecationWarning` が発生し、将来的には :exc:"
"`SyntaxError` になることにも注意してください。この動作は、正規表現として有効"
"な文字列に対しても同様です。"

#: ../../library/re.rst:36
msgid ""
"The solution is to use Python's raw string notation for regular expression "
"patterns; backslashes are not handled in any special way in a string literal "
"prefixed with ``'r'``.  So ``r\"\\n\"`` is a two-character string containing "
"``'\\'`` and ``'n'``, while ``\"\\n\"`` is a one-character string containing "
"a newline.  Usually patterns will be expressed in Python code using this raw "
"string notation."
msgstr ""
"これを解決するには、正規表現パターンに Python の raw 文字列記法を使います。 "
"``'r'`` を前置した文字列リテラル内ではバックスラッシュが特別扱いされません。"
"従って ``\"\\n\"`` が改行一文字からなる文字列であるのに対して、 ``r\"\\n\"`` "
"は ``'\\'`` と ``'n'`` の二文字からなる文字列です。通常、 Python コード中で"
"は、パターンをこの raw 文字列記法を使って表現します。"

#: ../../library/re.rst:43
msgid ""
"It is important to note that most regular expression operations are "
"available as module-level functions and methods on :ref:`compiled regular "
"expressions <re-objects>`.  The functions are shortcuts that don't require "
"you to compile a regex object first, but miss some fine-tuning parameters."
msgstr ""
"重要なこととして、大抵の正規表現操作は、モジュールレベルの関数としても、 :"
"ref:`コンパイル済み正規表現 <re-objects>` のメソッドとしても利用できます。関"
"数は正規表現オブジェクトを前もってコンパイルする必要がない近道ですが、微調整"
"のための変数が減ります。"

#: ../../library/re.rst:51
msgid ""
"The third-party `regex <https://pypi.org/project/regex/>`_ module, which has "
"an API compatible with the standard library :mod:`re` module, but offers "
"additional functionality and a more thorough Unicode support."
msgstr ""
"サードパーティの `regex <https://pypi.org/project/regex/>`_ モジュールは、標"
"準ライブラリの :mod:`re` モジュールと互換な API を持ちながら、追加の機能とよ"
"り徹底した Unicode サポートを提供します。"

#: ../../library/re.rst:59
msgid "Regular Expression Syntax"
msgstr "正規表現のシンタックス"

#: ../../library/re.rst:61
msgid ""
"A regular expression (or RE) specifies a set of strings that matches it; the "
"functions in this module let you check if a particular string matches a "
"given regular expression (or if a given regular expression matches a "
"particular string, which comes down to the same thing)."
msgstr ""
"正規表現 (または RE) は、その表現にマッチ (match) する文字列の集合を指定しま"
"す。このモジュールの関数を使えば、ある文字列が与えられた正規表現にマッチする"
"か (または、与えられた正規表現がある文字列にマッチするか、と言い換えても同じ"
"ことになります) を検査できます。"

#: ../../library/re.rst:66
msgid ""
"Regular expressions can be concatenated to form new regular expressions; if "
"*A* and *B* are both regular expressions, then *AB* is also a regular "
"expression. In general, if a string *p* matches *A* and another string *q* "
"matches *B*, the string *pq* will match AB.  This holds unless *A* or *B* "
"contain low precedence operations; boundary conditions between *A* and *B*; "
"or have numbered group references.  Thus, complex expressions can easily be "
"constructed from simpler primitive expressions like the ones described "
"here.  For details of the theory and implementation of regular expressions, "
"consult the Friedl book [Frie09]_, or almost any textbook about compiler "
"construction."
msgstr ""
"正規表現を連結することで新しい正規表現を作れます。*A* と *B* がともに正規表現"
"であれば *AB* も正規表現です。一般的に、ある文字列 *p* が *A* にマッチし、別"
"の文字列 *q* が *B* にマッチするなら、文字列 *pq* は AB にマッチします。ただ"
"し、 *A* または *B* に優先度の低い演算が含まれる場合や、 *A* と *B* との間に"
"境界条件がある場合や、番号付けされたグループ参照をしている場合、を除きます。"
"こうして、ここで述べるような簡単な基本表現から、複雑な表現を容易に構築できま"
"す。正規表現に関する理論と実装の詳細については Friedl 本 [Frie09]_ か、コンパ"
"イラの構築に関するテキストを参照してください。"

#: ../../library/re.rst:76
msgid ""
"A brief explanation of the format of regular expressions follows.  For "
"further information and a gentler presentation, consult the :ref:`regex-"
"howto`."
msgstr ""
"以下で正規表現の形式を簡単に説明します。詳細な情報ややさしい説明は、 :ref:"
"`regex-howto` を参照してください。"

#: ../../library/re.rst:79
msgid ""
"Regular expressions can contain both special and ordinary characters. Most "
"ordinary characters, like ``'A'``, ``'a'``, or ``'0'``, are the simplest "
"regular expressions; they simply match themselves.  You can concatenate "
"ordinary characters, so ``last`` matches the string ``'last'``.  (In the "
"rest of this section, we'll write RE's in ``this special style``, usually "
"without quotes, and strings to be matched ``'in single quotes'``.)"
msgstr ""
"正規表現には、特殊文字と通常文字の両方を含められます。 ``'A'`` 、 ``'a'`` 、"
"または ``'0'`` のようなほとんどの通常文字は、最も単純な正規表現です。これは単"
"純に、その文字自体にマッチします。通常文字は連結できるので、 ``last`` は文字"
"列 ``'last'`` にマッチします。 (この節では以降、正規表現は一般にクオートを使"
"わず ``この特殊スタイルで`` 表記し、マッチ対象の文字列は、 ``'シングルクオー"
"トで括って'`` 表記します。)"

#: ../../library/re.rst:86
msgid ""
"Some characters, like ``'|'`` or ``'('``, are special. Special characters "
"either stand for classes of ordinary characters, or affect how the regular "
"expressions around them are interpreted."
msgstr ""
"``'|'`` や ``'('`` といったいくつかの文字は特殊です。特殊文字は通常文字の種別"
"を表したり、周辺の通常文字に対する解釈方法に影響します。"

#: ../../library/re.rst:90
msgid ""
"Repetition qualifiers (``*``, ``+``, ``?``, ``{m,n}``, etc) cannot be "
"directly nested. This avoids ambiguity with the non-greedy modifier suffix "
"``?``, and with other modifiers in other implementations. To apply a second "
"repetition to an inner repetition, parentheses may be used. For example, the "
"expression ``(?:a{6})*`` matches any multiple of six ``'a'`` characters."
msgstr ""
"繰り返しの修飾子 (``*``、 ``+``、 ``?``、 ``{m,n}`` など) は直接入れ子にはで"
"きません。これは、非貪欲な修飾子の接尾辞 ``?`` や他の実装での他の修飾子との曖"
"昧さを回避します。内側で繰り返したものをさらに繰り返すには、丸括弧が使えま"
"す。例えば、正規表現 ``(?:a{6})*`` は 6 の倍数個の ``'a'`` 文字にマッチしま"
"す。"

#: ../../library/re.rst:97
msgid "The special characters are:"
msgstr "特殊文字を以下に示します:"

#: ../../library/re.rst:104 ../../library/re.rst:1434
msgid "``.``"
msgstr "``.``"

#: ../../library/re.rst:102
msgid ""
"(Dot.)  In the default mode, this matches any character except a newline.  "
"If the :const:`DOTALL` flag has been specified, this matches any character "
"including a newline."
msgstr ""
"(ドット) デフォルトのモードでは改行以外の任意の文字にマッチします。 :const:"
"`DOTALL` フラグが指定されていれば改行も含む全ての文字にマッチします。"

#: ../../library/re.rst:110
msgid "``^``"
msgstr "``^``"

#: ../../library/re.rst:109
msgid ""
"(Caret.)  Matches the start of the string, and in :const:`MULTILINE` mode "
"also matches immediately after each newline."
msgstr ""
"(キャレット) 文字列の先頭にマッチし、 :const:`MULTILINE` モードでは各改行の直"
"後にもマッチします。"

#: ../../library/re.rst:121
msgid "``$``"
msgstr "``$``"

#: ../../library/re.rst:115
msgid ""
"Matches the end of the string or just before the newline at the end of the "
"string, and in :const:`MULTILINE` mode also matches before a newline.  "
"``foo`` matches both 'foo' and 'foobar', while the regular expression "
"``foo$`` matches only 'foo'.  More interestingly, searching for ``foo.$`` in "
"``'foo1\\nfoo2\\n'`` matches 'foo2' normally, but 'foo1' in :const:"
"`MULTILINE` mode; searching for a single ``$`` in ``'foo\\n'`` will find two "
"(empty) matches: one just before the newline, and one at the end of the "
"string."
msgstr ""
"文字列の末尾、あるいは文字列の末尾の改行の直前にマッチし、 :const:"
"`MULTILINE` モードでは改行の前にもマッチします。 ``foo`` は 'foo' と "
"'foobar' の両方にマッチしますが、正規表現 ``foo$`` は 'foo' だけにマッチしま"
"す。興味深いことに、 ``'foo1\\nfoo2\\n'`` を ``foo.$`` で検索した場合、通常"
"は 'foo2' だけにマッチしますが、 :const:`MULTILINE` モードでは 'foo1' にも"
"マッチします。 ``$`` だけで ``'foo\\n'`` を検索した場合、2 つの (空の) マッチ"
"を見つけます: 1つは改行の直前で、もう1つは文字列の末尾です。"

#: ../../library/re.rst:128
msgid "``*``"
msgstr "``*``"

#: ../../library/re.rst:126
msgid ""
"Causes the resulting RE to match 0 or more repetitions of the preceding RE, "
"as many repetitions as are possible.  ``ab*`` will match 'a', 'ab', or 'a' "
"followed by any number of 'b's."
msgstr ""
"直前の正規表現を 0 回以上、できるだけ多く繰り返したものにマッチさせる結果の正"
"規表現にします。例えば ``ab*`` は 'a'、'ab'、または 'a' に任意個数の 'b' を続"
"けたものにマッチします。"

#: ../../library/re.rst:135
msgid "``+``"
msgstr "``+``"

#: ../../library/re.rst:133
msgid ""
"Causes the resulting RE to match 1 or more repetitions of the preceding RE. "
"``ab+`` will match 'a' followed by any non-zero number of 'b's; it will not "
"match just 'a'."
msgstr ""
"直前の正規表現を 1 回以上繰り返したものにマッチさせる結果の正規表現にします。"
"例えば ``ab+`` は 'a' に 1 つ以上の 'b' が続いたものにマッチし、単なる 'a' に"
"はマッチしません。"

#: ../../library/re.rst:141
msgid "``?``"
msgstr "``?``"

#: ../../library/re.rst:140
msgid ""
"Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. "
"``ab?`` will match either 'a' or 'ab'."
msgstr ""
"直前の正規表現を 0 回か 1 回繰り返したものにマッチさせる結果の正規表現にしま"
"す。例えば ``ab?`` は 'a' あるいは 'ab' にマッチします。"

#: ../../library/re.rst:155
msgid "``*?``, ``+?``, ``??``"
msgstr "``*?``, ``+?``, ``??``"

#: ../../library/re.rst:149
msgid ""
"The ``'*'``, ``'+'``, and ``'?'`` qualifiers are all :dfn:`greedy`; they "
"match as much text as possible.  Sometimes this behaviour isn't desired; if "
"the RE ``<.*>`` is matched against ``'<a> b <c>'``, it will match the entire "
"string, and not just ``'<a>'``.  Adding ``?`` after the qualifier makes it "
"perform the match in :dfn:`non-greedy` or :dfn:`minimal` fashion; as *few* "
"characters as possible will be matched.  Using the RE ``<.*?>`` will match "
"only ``'<a>'``."
msgstr ""
"``'*'`` 、 ``'+'`` 、および ``'?'`` 修飾子は全て :dfn:`貪欲 (greedy)` マッチ"
"で、できるだけ多くのテキストにマッチします。この挙動が望ましくない時もありま"
"す。例えば正規表現 ``<.*>`` が ``'<a> b <c>'`` に対してマッチされると、 "
"``'<a>'`` だけでなく文字列全体にマッチしてしまいます。修飾子の後に ``?`` を追"
"加すると、 :dfn:`非貪欲 (non-greedy)` あるいは :dfn:`最小 (minimal)` のマッチ"
"が行われ、できるだけ *少ない* 文字にマッチします。正規表現 ``<.*?>`` を使う"
"と ``'<a>'`` だけにマッチします。"

#: ../../library/re.rst:163
msgid "``{m}``"
msgstr "``{m}``"

#: ../../library/re.rst:161
msgid ""
"Specifies that exactly *m* copies of the previous RE should be matched; "
"fewer matches cause the entire RE not to match.  For example, ``a{6}`` will "
"match exactly six ``'a'`` characters, but not five."
msgstr ""
"直前の正規表現をちょうど *m* 回繰り返したものにマッチさせるよう指定します。そ"
"れより少ないマッチでは正規表現全体がマッチしません。例えば、 ``a{6}`` は 6 個"
"ちょうどの ``'a'`` 文字にマッチしますが、 5 個ではマッチしません。"

#: ../../library/re.rst:172
msgid "``{m,n}``"
msgstr "``{m,n}``"

#: ../../library/re.rst:166
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible.  For "
"example, ``a{3,5}`` will match from 3 to 5 ``'a'`` characters.  Omitting *m* "
"specifies a lower bound of zero,  and omitting *n* specifies an infinite "
"upper bound.  As an example, ``a{4,}b`` will match ``'aaaab'`` or a thousand "
"``'a'`` characters followed by a ``'b'``, but not ``'aaab'``. The comma may "
"not be omitted or the modifier would be confused with the previously "
"described form."
msgstr ""
"直前の正規表現を *m* 回から *n* 回、できるだけ多く繰り返したものにマッチさせ"
"る結果の正規表現にします。例えば、``a{3,5}`` は、3 個から 5 個の ``'a'`` 文字"
"にマッチします。*m* を省略すると下限は 0 に指定され、*n* を省略すると上限は無"
"限に指定されます。例として、 ``a{4,}b`` は ``'aaaab'`` や、1,000 個の "
"``'a'`` 文字に ``'b'`` が続いたものにマッチしますが、``'aaab'`` にはマッチし"
"ません。コンマは省略できません、省略すると修飾子が上で述べた形式と混同されて"
"しまうからです。"

#: ../../library/re.rst:179
msgid "``{m,n}?``"
msgstr "``{m,n}?``"

#: ../../library/re.rst:175
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as *few* repetitions as possible.  This is "
"the non-greedy version of the previous qualifier.  For example, on the 6-"
"character string ``'aaaaaa'``, ``a{3,5}`` will match 5 ``'a'`` characters, "
"while ``a{3,5}?`` will only match 3 characters."
msgstr ""
"結果の正規表現は、前にある正規表現を、*m* 回から *n* 回まで繰り返したものに"
"マッチし、できるだけ *少なく* 繰り返したものにマッチするようにします。これ"
"は、前の修飾子の非貪欲版です。例えば、 6 文字文字列 ``'aaaaaa'`` では、 "
"``a{3,5}`` は、5 個の ``'a'`` 文字にマッチしますが、 ``a{3,5}?`` は 3 個の文"
"字にマッチするだけです。"

#: ../../library/re.rst:194
msgid "``\\``"
msgstr "``\\``"

#: ../../library/re.rst:184
msgid ""
"Either escapes special characters (permitting you to match characters like "
"``'*'``, ``'?'``, and so forth), or signals a special sequence; special "
"sequences are discussed below."
msgstr ""
"特殊文字をエスケープ ( ``'*'`` や ``'?'`` などの文字にマッチできるようにす"
"る) し、または特殊シーケンスを合図します。特殊シーケンスは後で議論します。"

#: ../../library/re.rst:188
msgid ""
"If you're not using a raw string to express the pattern, remember that "
"Python also uses the backslash as an escape sequence in string literals; if "
"the escape sequence isn't recognized by Python's parser, the backslash and "
"subsequent character are included in the resulting string.  However, if "
"Python would recognize the resulting sequence, the backslash should be "
"repeated twice.  This is complicated and hard to understand, so it's highly "
"recommended that you use raw strings for all but the simplest expressions."
msgstr ""
"パターンを表現するのに raw 文字列を使っていないのであれば、 Python ももまた、"
"バックスラッシュを文字列リテラルでエスケープシーケンスとして使うことを思い出"
"して下さい。そのエスケープシーケンスを Python のパーザが認識しないなら、その"
"バックスラッシュとそれに続く文字が結果の文字列に含まれます。しかし、Python が"
"結果のシーケンスを認識するなら、そのバックスラッシュは 2 回繰り返さなければい"
"けません。これは複雑で理解しにくいので、ごく単純な表現以外は、全て raw 文字列"
"を使うことを強く推奨します。"

#: ../../library/re.rst:254
msgid "``[]``"
msgstr "``[]``"

#: ../../library/re.rst:200
msgid "Used to indicate a set of characters.  In a set:"
msgstr "文字の集合を指定するのに使います。集合の中では:"

#: ../../library/re.rst:202
msgid ""
"Characters can be listed individually, e.g. ``[amk]`` will match ``'a'``, "
"``'m'``, or ``'k'``."
msgstr ""
"文字を個別に指定できます。 ``[amk]`` は ``'a'`` 、 ``'m'`` または ``'k'`` に"
"マッチします。"

#: ../../library/re.rst:207
msgid ""
"Ranges of characters can be indicated by giving two characters and "
"separating them by a ``'-'``, for example ``[a-z]`` will match any lowercase "
"ASCII letter, ``[0-5][0-9]`` will match all the two-digits numbers from "
"``00`` to ``59``, and ``[0-9A-Fa-f]`` will match any hexadecimal digit.  If "
"``-`` is escaped (e.g. ``[a\\-z]``) or if it's placed as the first or last "
"character (e.g. ``[-a]`` or ``[a-]``), it will match a literal ``'-'``."
msgstr ""
"連続した文字の範囲を、 ``'-'`` を2 つの文字で挟んで指定できます。例えば、 "
"``[a-z]`` はあらゆる小文字の ASCII 文字にマッチします。``[0-5][0-9]`` は "
"``00`` から ``59`` まで全ての 2 桁の数字にマッチします。``[0-9A-Fa-f]`` は任"
"意の 16 進数字にマッチします。``-`` がエスケープされているか (例: ``[a\\-"
"z]``)、先頭や末尾の文字にされていると (例: ``[-a]`` や ``[a-]``)、リテラル "
"``'-'`` にマッチします。"

#: ../../library/re.rst:214
msgid ""
"Special characters lose their special meaning inside sets.  For example, "
"``[(+*)]`` will match any of the literal characters ``'('``, ``'+'``, "
"``'*'``, or ``')'``."
msgstr ""
"集合の中では、特殊文字はその特殊な意味を失います。例えば ``[(+*)]`` はリテラ"
"ル文字 ``'('`` 、 ``'+'`` 、 ``'*'`` 、または ``')'`` のどれにでもマッチしま"
"す。"

#: ../../library/re.rst:220
msgid ""
"Character classes such as ``\\w`` or ``\\S`` (defined below) are also "
"accepted inside a set, although the characters they match depends on "
"whether :const:`ASCII` or :const:`LOCALE` mode is in force."
msgstr ""
"``\\w`` や ``\\S`` のような文字クラス (後述) も集合の中で受理されますが、それ"
"にマッチする文字は :const:`ASCII` や :const:`LOCALE` モードが有効であるかに依"
"存します。"

#: ../../library/re.rst:226
msgid ""
"Characters that are not within a range can be matched by :dfn:"
"`complementing` the set.  If the first character of the set is ``'^'``, all "
"the characters that are *not* in the set will be matched.  For example, "
"``[^5]`` will match any character except ``'5'``, and ``[^^]`` will match "
"any character except ``'^'``.  ``^`` has no special meaning if it's not the "
"first character in the set."
msgstr ""
":dfn:`補集合` をとって範囲内にない文字にマッチできます。集合の最初の文字が "
"``'^'`` なら、集合に *含まれない* 全ての文字にマッチします。例えば、 "
"``[^5]`` は ``'5'`` を除くあらゆる文字にマッチし、 ``[^^]`` は ``'^'`` を除く"
"あらゆる文字にマッチします。 ``^`` は集合の最初の文字でなければ特別の意味を持"
"ちません。"

#: ../../library/re.rst:233
msgid ""
"To match a literal ``']'`` inside a set, precede it with a backslash, or "
"place it at the beginning of the set.  For example, both ``[()[\\]{}]`` and "
"``[]()[{}]`` will both match a parenthesis."
msgstr ""
"集合の中でリテラル ``']'`` にマッチさせるには、その前にバックスラッシュをつけ"
"るか、集合の先頭に置きます。例えば、 ``[()[\\]{}]`` と ``[]()[{}]`` はどちら"
"も括弧にマッチします。"

#: ../../library/re.rst:242
msgid ""
"Support of nested sets and set operations as in `Unicode Technical Standard "
"#18`_ might be added in the future.  This would change the syntax, so to "
"facilitate this change a :exc:`FutureWarning` will be raised in ambiguous "
"cases for the time being. That includes sets starting with a literal ``'['`` "
"or containing literal character sequences ``'--'``, ``'&&'``, ``'~~'``, and "
"``'||'``.  To avoid a warning escape them with a backslash."
msgstr ""
"`Unicode Technical Standard #18`_ にあるような集合の入れ子や集合操作が将来追"
"加される可能性があります。これは構文を変化させるもので、この変化を容易にする"
"ために、さしあたって曖昧な事例には :exc:`FutureWarning` が送出されます。これ"
"はリテラル ``'['`` で始まる集合や、リテラル文字の連続 ``'--'`` 、 "
"``'&&'`` 、 ``'~~'`` および ``'||'`` を含む集合を含みます。警告を避けるには"
"バックスラッシュでエスケープしてください。"

#: ../../library/re.rst:252
msgid ""
":exc:`FutureWarning` is raised if a character set contains constructs that "
"will change semantically in the future."
msgstr ""
"文字セットが将来意味論的に変化する構造を含むなら :exc:`FutureWarning` が送出"
"されます。"

#: ../../library/re.rst:267
msgid "``|``"
msgstr "``|``"

#: ../../library/re.rst:259
msgid ""
"``A|B``, where *A* and *B* can be arbitrary REs, creates a regular "
"expression that will match either *A* or *B*.  An arbitrary number of REs "
"can be separated by the ``'|'`` in this way.  This can be used inside groups "
"(see below) as well.  As the target string is scanned, REs separated by "
"``'|'`` are tried from left to right. When one pattern completely matches, "
"that branch is accepted. This means that once *A* matches, *B* will not be "
"tested further, even if it would produce a longer overall match.  In other "
"words, the ``'|'`` operator is never greedy.  To match a literal ``'|'``, "
"use ``\\|``, or enclose it inside a character class, as in ``[|]``."
msgstr ""
"*A* と *B* を任意の正規表現として、 ``A|B`` は *A* と *B* のいずれかにマッチ"
"する正規表現を作成します。この方法で任意の数の正規表現を ``'|'`` で分離できま"
"す。これはグループ (下記参照) 中でも使えます。対象文字列を走査するとき、"
"``'|'`` で分離された正規表現は左から右へ順に試されます。一つのパターンが完全"
"にマッチしたとき、そのパターン枝が受理されます。つまり、ひとたび *A* がマッチ"
"してしまえば、例え *B* によって全体のマッチが長くなるとしても、 *B* はもはや"
"走査されません。言いかえると、 ``'|'`` 演算子は決して貪欲にはなりません。リテ"
"ラル ``'|'`` にマッチするには、 ``\\|`` を使うか、 ``[|]`` のように文字クラス"
"中に囲みます。"

#: ../../library/re.rst:277
msgid "``(...)``"
msgstr "``(...)``"

#: ../../library/re.rst:273
msgid ""
"Matches whatever regular expression is inside the parentheses, and indicates "
"the start and end of a group; the contents of a group can be retrieved after "
"a match has been performed, and can be matched later in the string with the "
"``\\number`` special sequence, described below.  To match the literals "
"``'('`` or ``')'``, use ``\\(`` or ``\\)``, or enclose them inside a "
"character class: ``[(]``, ``[)]``."
msgstr ""
"丸括弧で囲まれた正規表現にマッチするとともに、グループの開始と終了を表しま"
"す。グループの中身は以下で述べるように、マッチが実行された後で回収したり、そ"
"の文字列中で以降 ``\\number`` 特殊シーケンスでマッチしたりできます。リテラル "
"``'('`` や ``')'`` にマッチするには、``\\(`` や ``\\)`` を使うか、文字クラス"
"中に囲みます:  ``[(]``、 ``[)]`` 。"

#: ../../library/re.rst:286
msgid "``(?...)``"
msgstr "``(?...)``"

#: ../../library/re.rst:282
msgid ""
"This is an extension notation (a ``'?'`` following a ``'('`` is not "
"meaningful otherwise).  The first character after the ``'?'`` determines "
"what the meaning and further syntax of the construct is. Extensions usually "
"do not create a new group; ``(?P<name>...)`` is the only exception to this "
"rule. Following are the currently supported extensions."
msgstr ""
"これは拡張記法です (``'('`` に続く ``'?'`` はそれ以上の意味を持ちません) 。 "
"``'?'`` に続く最初の文字がこの構造の意味と特有の構文を決定します。拡張は一般"
"に新しいグループを作成しません。ただし ``(?P<name>...)`` はこの法則の唯一の例"
"外です。現在サポートされている拡張は以下の通りです。"

#: ../../library/re.rst:300
msgid "``(?aiLmsux)``"
msgstr "``(?aiLmsux)``"

#: ../../library/re.rst:289
msgid ""
"(One or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``.)  The group matches the empty string; the letters "
"set the corresponding flags: :const:`re.A` (ASCII-only matching), :const:`re."
"I` (ignore case), :const:`re.L` (locale dependent), :const:`re.M` (multi-"
"line), :const:`re.S` (dot matches all), :const:`re.U` (Unicode matching), "
"and :const:`re.X` (verbose), for the entire regular expression. (The flags "
"are described in :ref:`contents-of-module-re`.) This is useful if you wish "
"to include the flags as part of the regular expression, instead of passing a "
"*flag* argument to the :func:`re.compile` function.  Flags should be used "
"first in the expression string."
msgstr ""
"(``'a'`` 、 ``'i'`` 、 ``'L'`` 、 ``'m'`` 、 ``'s'`` 、 ``'u'`` 、 ``'x'`` の"
"集合から 1 文字以上。) このグループは空文字列にマッチします。文字は正規表現全"
"体に、対応するフラグを設定します。 :const:`re.A` (ASCII 限定マッチング)、 :"
"const:`re.I` (大文字・小文字を区別しない)、 :const:`re.L` (ロケール依存)、 :"
"const:`re.M` (複数行)、 :const:`re.S` (ドットが全てにマッチ)、 :const:`re.U` "
"(Unicode マッチング)、 :const:`re.X` (冗長)。 (各フラグについては :ref:"
"`contents-of-module-re` で説明します。) これは、 *flag* 引数を :func:`re."
"compile` 関数に渡すのではなく、フラグを正規表現の一部として含めたいときに便利"
"です。フラグは表現文字列の先頭で使うべきです。"

#: ../../library/re.rst:308
msgid "``(?:...)``"
msgstr "``(?:...)``"

#: ../../library/re.rst:305
msgid ""
"A non-capturing version of regular parentheses.  Matches whatever regular "
"expression is inside the parentheses, but the substring matched by the group "
"*cannot* be retrieved after performing a match or referenced later in the "
"pattern."
msgstr ""
"普通の丸括弧の、キャプチャしない版です。丸括弧で囲まれた正規表現にマッチしま"
"すが、このグループがマッチした部分文字列は、マッチを実行したあとで回収するこ"
"とも、そのパターン中で以降参照することも *できません* 。"

#: ../../library/re.rst:334
msgid "``(?aiLmsux-imsx:...)``"
msgstr "``(?aiLmsux-imsx:...)``"

#: ../../library/re.rst:311
msgid ""
"(Zero or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``, optionally followed by ``'-'`` followed by one or "
"more letters from the ``'i'``, ``'m'``, ``'s'``, ``'x'``.) The letters set "
"or remove the corresponding flags: :const:`re.A` (ASCII-only matching), :"
"const:`re.I` (ignore case), :const:`re.L` (locale dependent), :const:`re.M` "
"(multi-line), :const:`re.S` (dot matches all), :const:`re.U` (Unicode "
"matching), and :const:`re.X` (verbose), for the part of the expression. (The "
"flags are described in :ref:`contents-of-module-re`.)"
msgstr ""
"(``'a'`` 、 ``'i'`` 、 ``'L'`` 、 ``'m'`` 、 ``'s'`` 、 ``'u'`` 、 ``'x'`` の"
"集合から 0 文字以上、必要ならさらに ``'-'`` に続けて ``'i'`` 、 ``'m'`` 、 "
"``'s'`` 、 ``'x'`` の集合から 1 文字以上。) 文字は表現の一部に、対応するフラ"
"グを設定または除去します。 :const:`re.A` (ASCII 限定マッチング)、 :const:`re."
"I` (大文字・小文字を区別しない)、 :const:`re.L` (ロケール依存)、 :const:`re."
"M` (複数行)、 :const:`re.S` (ドットが全てにマッチ)、 :const:`re.U` (Unicode "
"マッチング)、 :const:`re.X` (冗長)。 (各フラグについては :ref:`contents-of-"
"module-re` で説明します。)"

#: ../../library/re.rst:321
msgid ""
"The letters ``'a'``, ``'L'`` and ``'u'`` are mutually exclusive when used as "
"inline flags, so they can't be combined or follow ``'-'``.  Instead, when "
"one of them appears in an inline group, it overrides the matching mode in "
"the enclosing group.  In Unicode patterns ``(?a:...)`` switches to ASCII-"
"only matching, and ``(?u:...)`` switches to Unicode matching (default).  In "
"byte pattern ``(?L:...)`` switches to locale depending matching, and ``(?"
"a:...)`` switches to ASCII-only matching (default). This override is only in "
"effect for the narrow inline group, and the original matching mode is "
"restored outside of the group."
msgstr ""
"文字 ``'a'`` 、 ``'L'`` および ``'u'`` は相互に排他であり、組み合わせること"
"も ``'-'`` に続けることもできません。その代わり、これらの内一つがインライング"
"ループ中に現れると、外側のグループでのマッチングモードを上書きします。 "
"Unicode パターン中では ``(?a:...)`` は ASCII 限定マッチングに切り替え、 ``(?"
"u:...)`` は Unicode マッチング (デフォルト) に切り替えます。バイト列パターン"
"中では、 ``(?L:...)`` はロケール依存マッチングに切り替え、 ``(?a:...)`` は "
"ASCII 限定マッチング (デフォルト) に切り替えます。この上書きは狭いインライン"
"グループにのみ影響し、元のマッチングモードはグループ外では復元されます。"

#: ../../library/re.rst:333
msgid "The letters ``'a'``, ``'L'`` and ``'u'`` also can be used in a group."
msgstr "文字 ``'a'`` 、 ``'L'`` および ``'u'`` もグループ中で使えます。"

#: ../../library/re.rst:361
msgid "``(?P<name>...)``"
msgstr "``(?P<name>...)``"

#: ../../library/re.rst:339
msgid ""
"Similar to regular parentheses, but the substring matched by the group is "
"accessible via the symbolic group name *name*.  Group names must be valid "
"Python identifiers, and each group name must be defined only once within a "
"regular expression.  A symbolic group is also a numbered group, just as if "
"the group were not named."
msgstr ""
"通常の丸括弧に似ていますが、このグループがマッチした部分文字列はシンボリック"
"グループ名 *name* でアクセスできます。グループ名は有効な Python 識別子でなけ"
"ればならず、各グループ名は 1 個の正規表現内で一度だけ定義されていなければなり"
"ません。シンボリックグループは、そのグループが名前付けされていなかったかのよ"
"うに番号付けされたグループでもあります。"

#: ../../library/re.rst:345
msgid ""
"Named groups can be referenced in three contexts.  If the pattern is ``(?"
"P<quote>['\"]).*?(?P=quote)`` (i.e. matching a string quoted with either "
"single or double quotes):"
msgstr ""
"名前付きグループは 3 つのコンテキストで参照できます。パターンが ``(?"
"P<quote>['\\\"]).*?(?P=quote)`` (シングルまたはダブルクオートで囲まれた文字列"
"にマッチ) ならば:"

#: ../../library/re.rst:350
msgid "Context of reference to group \"quote\""
msgstr "グループ \"quote\" を参照するコンテキスト"

#: ../../library/re.rst:350
msgid "Ways to reference it"
msgstr "参照する方法"

#: ../../library/re.rst:352
msgid "in the same pattern itself"
msgstr "その同じパターン中"

#: ../../library/re.rst:352
msgid "``(?P=quote)`` (as shown)"
msgstr "``(?P=quote)`` (示したとおり)"

#: ../../library/re.rst:353 ../../library/re.rst:360
msgid "``\\1``"
msgstr "``\\1``"

#: ../../library/re.rst:355
msgid "when processing match object *m*"
msgstr "マッチオブジェクト *m* の処理時"

#: ../../library/re.rst:355
msgid "``m.group('quote')``"
msgstr "``m.group('quote')``"

#: ../../library/re.rst:356
msgid "``m.end('quote')`` (etc.)"
msgstr "``m.end('quote')`` (など)"

#: ../../library/re.rst:358
msgid "in a string passed to the *repl* argument of ``re.sub()``"
msgstr "``re.sub()`` の *repl* 引数へ渡される文字列中"

#: ../../library/re.rst:358
msgid "``\\g<quote>``"
msgstr "``\\g<quote>``"

#: ../../library/re.rst:359
msgid "``\\g<1>``"
msgstr "``\\g<1>``"

#: ../../library/re.rst:367
msgid "``(?P=name)``"
msgstr "``(?P=name)``"

#: ../../library/re.rst:366
msgid ""
"A backreference to a named group; it matches whatever text was matched by "
"the earlier group named *name*."
msgstr ""
"名前付きグループへの後方参照です。これは *name* という名前の既出のグループが"
"マッチした文字列にマッチします。"

#: ../../library/re.rst:372
msgid "``(?#...)``"
msgstr "``(?#...)``"

#: ../../library/re.rst:372
msgid "A comment; the contents of the parentheses are simply ignored."
msgstr "コメントです。括弧の中身は単純に無視されます。"

#: ../../library/re.rst:379
msgid "``(?=...)``"
msgstr "``(?=...)``"

#: ../../library/re.rst:377
msgid ""
"Matches if ``...`` matches next, but doesn't consume any of the string.  "
"This is called a :dfn:`lookahead assertion`.  For example, ``Isaac (?"
"=Asimov)`` will match ``'Isaac '`` only if it's followed by ``'Asimov'``."
msgstr ""
"``...`` が次に続くものにマッチすればマッチしますが、文字列をまったく消費しま"
"せん。これは :dfn:`先読みアサーション (lookahead assertion)` と呼ばれます。例"
"えば、``Isaac (?=Asimov)`` は ``'Isaac '`` に、その後に ``'Asimov'`` が続く場"
"合にのみ、マッチします。"

#: ../../library/re.rst:386
msgid "``(?!...)``"
msgstr "``(?!...)``"

#: ../../library/re.rst:384
msgid ""
"Matches if ``...`` doesn't match next.  This is a :dfn:`negative lookahead "
"assertion`. For example, ``Isaac (?!Asimov)`` will match ``'Isaac '`` only "
"if it's *not* followed by ``'Asimov'``."
msgstr ""
"``...`` が次に続くものにマッチしなければマッチします。これは :dfn:`否定先読み"
"アサーション (negative lookahead assertion)` です。例えば、``Isaac (?!"
"Asimov)`` は ``'Isaac '`` に、その後に ``'Asimov'`` が続か *ない* 場合にの"
"み、マッチします。"

#: ../../library/re.rst:413
msgid "``(?<=...)``"
msgstr "``(?<=...)``"

#: ../../library/re.rst:391
msgid ""
"Matches if the current position in the string is preceded by a match for "
"``...`` that ends at the current position.  This is called a :dfn:`positive "
"lookbehind assertion`. ``(?<=abc)def`` will find a match in ``'abcdef'``, "
"since the lookbehind will back up 3 characters and check if the contained "
"pattern matches. The contained pattern must only match strings of some fixed "
"length, meaning that ``abc`` or ``a|b`` are allowed, but ``a*`` and ``a{3,4}"
"`` are not.  Note that patterns which start with positive lookbehind "
"assertions will not match at the beginning of the string being searched; you "
"will most likely want to use the :func:`search` function rather than the :"
"func:`match` function:"
msgstr ""
"その文字列における現在位置の前に、現在位置で終わる ``...`` とのマッチがあれ"
"ば、マッチします。これは :dfn:`後読みアサーション` と呼ばれます。``(?"
"<=abc)def`` は、後読みは 3 文字をバックアップし、含まれているパターンがマッチ"
"するか検査するので ``'abcdef'`` にマッチを見つけます。含まれるパターンは、固"
"定長の文字列にのみマッチしなければなりません。すなわち、 ``abc`` や ``a|b`` "
"は許されますが、``a*`` や ``a{3,4}`` は許されません。肯定後読みアサーションで"
"始まるパターンは、検索される文字列の先頭とは決してマッチしないことに注意して"
"下さい。:func:`match` 関数ではなく :func:`search` 関数を使う方が望ましいで"
"しょう:"

#: ../../library/re.rst:406
msgid "This example looks for a word following a hyphen:"
msgstr "この例ではハイフンに続く単語を探します:"

#: ../../library/re.rst:412
msgid "Added support for group references of fixed length."
msgstr "固定長のグループ参照をサポートするようになりました。"

#: ../../library/re.rst:422
msgid "``(?<!...)``"
msgstr "``(?<!...)``"

#: ../../library/re.rst:418
msgid ""
"Matches if the current position in the string is not preceded by a match for "
"``...``.  This is called a :dfn:`negative lookbehind assertion`.  Similar to "
"positive lookbehind assertions, the contained pattern must only match "
"strings of some fixed length.  Patterns which start with negative lookbehind "
"assertions may match at the beginning of the string being searched."
msgstr ""
"その文字列における現在位置の前に ``...`` とのマッチがなければ、マッチします。"
"これは :dfn:`否定後読みアサーション(negative lookbehind assertion)` と呼ばれ"
"ます。肯定後読みアサーションと同様に、含まれるパターンは固定長の文字列にのみ"
"マッチしなければなりません。否定後読みアサーションで始まるパターンは検索され"
"る文字列の先頭でマッチできます。"

#: ../../library/re.rst:434
msgid "``(?(id/name)yes-pattern|no-pattern)``"
msgstr "``(?(id/name)yes-pattern|no-pattern)``"

#: ../../library/re.rst:428
msgid ""
"Will try to match with ``yes-pattern`` if the group with given *id* or "
"*name* exists, and with ``no-pattern`` if it doesn't. ``no-pattern`` is "
"optional and can be omitted. For example, ``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?"
"(1)>|$)`` is a poor email matching pattern, which will match with "
"``'<user@host.com>'`` as well as ``'user@host.com'``, but not with "
"``'<user@host.com'`` nor ``'user@host.com>'``."
msgstr ""
"与えられた *id* や *name* のグループが存在すれば ``yes-pattern`` との、存在し"
"なければ ``no-pattern`` とのマッチを試みます。``no-pattern`` はオプションであ"
"り省略できます。例えば、``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>|$)`` は貧弱な E-"
"mail マッチングパターンで、``'<user@host.com>'`` や ``'user@host.com'`` には"
"マッチしますが、``'<user@host.com'`` や ``'user@host.com>'`` にはマッチしませ"
"ん。"

#: ../../library/re.rst:436
msgid ""
"The special sequences consist of ``'\\'`` and a character from the list "
"below. If the ordinary character is not an ASCII digit or an ASCII letter, "
"then the resulting RE will match the second character.  For example, ``\\$`` "
"matches the character ``'$'``."
msgstr ""
"特殊シーケンスは ``'\\'`` と以下のリストの文字から構成されます。通常文字が "
"ASCII 数字でも ASCII 文字でもなければ、結果の正規表現は 2 番目の文字にマッチ"
"します。例えば、``\\$`` は文字 ``'$'`` にマッチします。"

#: ../../library/re.rst:451
msgid "``\\number``"
msgstr "``\\number``"

#: ../../library/re.rst:444
msgid ""
"Matches the contents of the group of the same number.  Groups are numbered "
"starting from 1.  For example, ``(.+) \\1`` matches ``'the the'`` or ``'55 "
"55'``, but not ``'thethe'`` (note the space after the group).  This special "
"sequence can only be used to match one of the first 99 groups.  If the first "
"digit of *number* is 0, or *number* is 3 octal digits long, it will not be "
"interpreted as a group match, but as the character with octal value "
"*number*. Inside the ``'['`` and ``']'`` of a character class, all numeric "
"escapes are treated as characters."
msgstr ""
"同じ番号のグループの中身にマッチします。グループは 1 から始まる番号をつけられ"
"ます。例えば、 ``(.+) \\1`` は、 ``'the the'`` あるいは ``'55 55'`` にマッチ"
"しますが、 ``'thethe'`` にはマッチしません(グループの後のスペースに注意して下"
"さい)。この特殊シーケンスは最初の 99 グループのうちの一つとのマッチにのみ使え"
"ます。 *number* の最初の桁が 0 であるか、 *number* が 3 桁の 8 進数であれば、"
"それはグループのマッチとしてではなく、 8 進値 *number* を持つ文字として解釈さ"
"れます。文字クラスの ``'['`` と ``']'`` の間では全ての数値エスケープが文字と"
"して扱われます。"

#: ../../library/re.rst:456
msgid "``\\A``"
msgstr "``\\A``"

#: ../../library/re.rst:456
msgid "Matches only at the start of the string."
msgstr "文字列の先頭でのみマッチします。"

#: ../../library/re.rst:472
msgid "``\\b``"
msgstr "``\\b``"

#: ../../library/re.rst:461
msgid ""
"Matches the empty string, but only at the beginning or end of a word. A word "
"is defined as a sequence of word characters.  Note that formally, ``\\b`` is "
"defined as the boundary between a ``\\w`` and a ``\\W`` character (or vice "
"versa), or between ``\\w`` and the beginning/end of the string. This means "
"that ``r'\\bfoo\\b'`` matches ``'foo'``, ``'foo.'``, ``'(foo)'``, ``'bar foo "
"baz'`` but not ``'foobar'`` or ``'foo3'``."
msgstr ""
"空文字列にマッチしますが、単語の先頭か末尾でのみです。単語は単語文字の並びと"
"して定義されます。形式的には、 ``\\b`` は ``\\w`` と ``\\W`` 文字 (またはその"
"逆) との、あるいは ``\\w`` と文字列の先頭・末尾との境界として定義されます。例"
"えば、 ``r'\\bfoo\\b'`` は ``'foo'`` 、 ``'foo.'`` 、 ``'(foo)'`` 、 ``'bar "
"foo baz'`` にはマッチしますが、 ``'foobar'`` や ``'foo3'`` にはマッチしませ"
"ん。"

#: ../../library/re.rst:468
msgid ""
"By default Unicode alphanumerics are the ones used in Unicode patterns, but "
"this can be changed by using the :const:`ASCII` flag.  Word boundaries are "
"determined by the current locale if the :const:`LOCALE` flag is used. Inside "
"a character range, ``\\b`` represents the backspace character, for "
"compatibility with Python's string literals."
msgstr ""
"デフォルトの Unicode 英数字は Unicode パターン中で使われるものと同じですが、"
"これは :const:`ASCII` フラグを使って変更できます。 :const:`LOCALE` フラグが使"
"われているなら単語の境界は現在のロケールによって決定されます。Python の文字列"
"リテラルとの互換性のため、文字列範囲中では、 ``\\b`` は後退 (backspace) 文字"
"を表します。"

#: ../../library/re.rst:483
msgid "``\\B``"
msgstr "``\\B``"

#: ../../library/re.rst:477
msgid ""
"Matches the empty string, but only when it is *not* at the beginning or end "
"of a word.  This means that ``r'py\\B'`` matches ``'python'``, ``'py3'``, "
"``'py2'``, but not ``'py'``, ``'py.'``, or ``'py!'``. ``\\B`` is just the "
"opposite of ``\\b``, so word characters in Unicode patterns are Unicode "
"alphanumerics or the underscore, although this can be changed by using the :"
"const:`ASCII` flag.  Word boundaries are determined by the current locale if "
"the :const:`LOCALE` flag is used."
msgstr ""
"空文字列にマッチしますが、それが単語の先頭か末尾 *でない* ときのみです。つま"
"り ``r'py\\B'`` は ``'python'`` 、 ``'py3'`` 、``'py2'`` にマッチしますが、 "
"``'py'`` 、 ``'py.'`` 、 または ``'py!'`` にはマッチしません。 ``\\B`` は "
"``\\b`` のちょうど反対で、 Unicode パターンにおける単語文字は Unicode 英数字"
"およびアンダースコアですが、 これは :const:`ASCII` フラグを使って変更できま"
"す。 :const:`LOCALE` フラグが使われているなら単語の境界は現在のロケールによっ"
"て決定されます。"

#: ../../library/re.rst:495
msgid "``\\d``"
msgstr "``\\d``"

#: ../../library/re.rst:492 ../../library/re.rst:512 ../../library/re.rst:531
msgid "For Unicode (str) patterns:"
msgstr "Unicode (str) パターンでは:"

#: ../../library/re.rst:489
msgid ""
"Matches any Unicode decimal digit (that is, any character in Unicode "
"character category [Nd]).  This includes ``[0-9]``, and also many other "
"digit characters.  If the :const:`ASCII` flag is used only ``[0-9]`` is "
"matched."
msgstr ""
"任意の Unicode 10 進数字 (Unicode 文字カテゴリ [Nd]) にマッチします。これは "
"``[0-9]`` とその他多数の数字を含みます。 :const:`ASCII` フラグが使われている"
"なら ``[0-9]`` のみにマッチします。"

#: ../../library/re.rst:495 ../../library/re.rst:516 ../../library/re.rst:537
msgid "For 8-bit (bytes) patterns:"
msgstr "8 ビット (bytes) パターンでは:"

#: ../../library/re.rst:495
msgid "Matches any decimal digit; this is equivalent to ``[0-9]``."
msgstr "任意の 10 進数字にマッチします。これは ``[0-9]`` と等価です。"

#: ../../library/re.rst:502
msgid "``\\D``"
msgstr "``\\D``"

#: ../../library/re.rst:500
msgid ""
"Matches any character which is not a decimal digit. This is the opposite of "
"``\\d``. If the :const:`ASCII` flag is used this becomes the equivalent of "
"``[^0-9]``."
msgstr ""
"10 進数字でない任意の文字にマッチします。これは ``\\d`` の反対です。:const:"
"`ASCII` フラグが使われているならこれは ``[^0-9]`` と等価になります。"

#: ../../library/re.rst:516
msgid "``\\s``"
msgstr "``\\s``"

#: ../../library/re.rst:508
msgid ""
"Matches Unicode whitespace characters (which includes "
"``[ \\t\\n\\r\\f\\v]``, and also many other characters, for example the non-"
"breaking spaces mandated by typography rules in many languages). If the :"
"const:`ASCII` flag is used, only ``[ \\t\\n\\r\\f\\v]`` is matched."
msgstr ""
"Unicode 空白文字 (これは ``[ \\t\\n\\r\\f\\v]`` その他多くの文字、例えば多く"
"の言語におけるタイポグラフィ規則で定義されたノーブレークスペースなどを含みま"
"す) にマッチします。 :const:`ASCII` フラグが使われているなら、"
"``[ \\t\\n\\r\\f\\v]`` のみにマッチします。"

#: ../../library/re.rst:515
msgid ""
"Matches characters considered whitespace in the ASCII character set; this is "
"equivalent to ``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"ASCII 文字セットで空白文字と見なされる文字にマッチします。これは "
"``[ \\t\\n\\r\\f\\v]`` と等価です。"

#: ../../library/re.rst:523
msgid "``\\S``"
msgstr "``\\S``"

#: ../../library/re.rst:521
msgid ""
"Matches any character which is not a whitespace character. This is the "
"opposite of ``\\s``. If the :const:`ASCII` flag is used this becomes the "
"equivalent of ``[^ \\t\\n\\r\\f\\v]``."
msgstr ""
"空白文字ではない任意の文字にマッチします。これは ``\\s`` の反対です。:const:"
"`ASCII` フラグが使われているならこれは ``[^ \\t\\n\\r\\f\\v]`` と等価になりま"
"す。"

#: ../../library/re.rst:537
msgid "``\\w``"
msgstr "``\\w``"

#: ../../library/re.rst:529
msgid ""
"Matches Unicode word characters; this includes alphanumeric characters (as "
"defined by :meth:`str.isalnum`) as well as the underscore (``_``). If the :"
"const:`ASCII` flag is used, only ``[a-zA-Z0-9_]`` is matched."
msgstr ""

#: ../../library/re.rst:534
msgid ""
"Matches characters considered alphanumeric in the ASCII character set; this "
"is equivalent to ``[a-zA-Z0-9_]``.  If the :const:`LOCALE` flag is used, "
"matches characters considered alphanumeric in the current locale and the "
"underscore."
msgstr ""
"ASCII 文字セットで英数字と見なされる文字にマッチします。これは ``[a-zA-"
"Z0-9_]`` と等価です。:const:`LOCALE` フラグが使われているなら、現在のロケール"
"で英数字と見なされる文字およびアンダースコアにマッチします。"

#: ../../library/re.rst:546
msgid "``\\W``"
msgstr "``\\W``"

#: ../../library/re.rst:542
msgid ""
"Matches any character which is not a word character. This is the opposite of "
"``\\w``. If the :const:`ASCII` flag is used this becomes the equivalent of "
"``[^a-zA-Z0-9_]``.  If the :const:`LOCALE` flag is used, matches characters "
"which are neither alphanumeric in the current locale nor the underscore."
msgstr ""
"単語文字ではない任意の文字にマッチします。これは ``\\w`` の反対です。 :const:"
"`ASCII` フラグが使われているなら、これは ``[^a-zA-Z0-9_]`` と等価になりま"
"す。:const:`LOCALE` フラグが使われているなら、現在のロケールの英数字でもアン"
"ダースコアでもない文字にマッチします。"

#: ../../library/re.rst:551
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../../library/re.rst:551
msgid "Matches only at the end of the string."
msgstr "文字列の末尾でのみマッチします。"

#: ../../library/re.rst:567
msgid ""
"Most of the standard escapes supported by Python string literals are also "
"accepted by the regular expression parser::"
msgstr ""
"Python 文字列リテラルでサポートされている標準エスケープのほとんども正規表現"
"パーザで受理されます::"

#: ../../library/re.rst:574
msgid ""
"(Note that ``\\b`` is used to represent word boundaries, and means "
"\"backspace\" only inside character classes.)"
msgstr ""
"(``\\b`` は単語の境界を表すのに使われ、文字クラス中でのみ \"後退 "
"(backspace)\" 文字を意味することに注意してください。)"

#: ../../library/re.rst:577
msgid ""
"``'\\u'``, ``'\\U'``, and ``'\\N'`` escape sequences are only recognized in "
"Unicode patterns.  In bytes patterns they are errors.  Unknown escapes of "
"ASCII letters are reserved for future use and treated as errors."
msgstr ""
"``'\\u'``、``'\\U'`` および ``'\\N'`` エスケープシーケンスは、Unicode パター"
"ン内でのみ認識されます。バイト列ではエラーとなります。ASCII 文字のエスケープ"
"で未知のものは将来使うために予約されていて、エラーとして扱われます。 "

#: ../../library/re.rst:581
msgid ""
"Octal escapes are included in a limited form.  If the first digit is a 0, or "
"if there are three octal digits, it is considered an octal escape. "
"Otherwise, it is a group reference.  As for string literals, octal escapes "
"are always at most three digits in length."
msgstr ""
"8 進エスケープは限られた形式でのみ含まれます。その最初の桁が 0 であるか、それ"
"が 3 桁の 8 進数であるならば、それは 8 進エスケープと見なされます。そうでなけ"
"れば、それはグループ参照です。文字列リテラルでは、8 進エスケープは常にたかだ"
"か 3 桁長です。"

#: ../../library/re.rst:586
msgid "The ``'\\u'`` and ``'\\U'`` escape sequences have been added."
msgstr "``'\\u'`` と ``'\\U'`` エスケープシーケンスが追加されました。"

#: ../../library/re.rst:589
msgid ""
"Unknown escapes consisting of ``'\\'`` and an ASCII letter now are errors."
msgstr "``'\\'`` と ASCII 文字からなる未知のエスケープはエラーになります。"

#: ../../library/re.rst:592
msgid ""
"The ``'\\N{name}'`` escape sequence has been added. As in string literals, "
"it expands to the named Unicode character (e.g. ``'\\N{EM DASH}'``)."
msgstr ""
"``'\\N{name}'`` エスケープシーケンスが追加されました。文字列リテラルでは、同"
"名のUnicode 文字に展開されます。(``'\\N{EM DASH}'`` など)"

#: ../../library/re.rst:600
msgid "Module Contents"
msgstr "モジュールコンテンツ"

#: ../../library/re.rst:602
msgid ""
"The module defines several functions, constants, and an exception. Some of "
"the functions are simplified versions of the full featured methods for "
"compiled regular expressions.  Most non-trivial applications always use the "
"compiled form."
msgstr ""
"このモジュールはいくつかの関数、定数、例外を定義します。このうちいくつかの関"
"数は、コンパイル済み正規表現がそなえる完全な機能のメソッドを簡易にしたもので"
"す。些細なものを除くほとんどのアプリケーションは常にコンパイル済み形式を使い"
"ます。"

#: ../../library/re.rst:609
msgid "Flags"
msgstr ""

#: ../../library/re.rst:611
msgid ""
"Flag constants are now instances of :class:`RegexFlag`, which is a subclass "
"of :class:`enum.IntFlag`."
msgstr ""
"フラグ定数は、:class:`enum.IntFlag` のサブクラスである :class:`RegexFlag` の"
"インスタンスになりました。"

#: ../../library/re.rst:620
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` and "
"``\\S`` perform ASCII-only matching instead of full Unicode matching.  This "
"is only meaningful for Unicode patterns, and is ignored for byte patterns. "
"Corresponds to the inline flag ``(?a)``."
msgstr ""
"``\\w`` 、``\\W`` 、``\\b`` 、``\\B`` 、``\\d`` 、``\\D`` 、``\\s`` 、および "
"``\\S`` に、完全な Unicode マッチングではなく ASCII 限定マッチングを行わせま"
"す。これは Unicode パターンでのみ意味があり、バイト列パターンでは無視されま"
"す。インラインフラグの ``(?a)`` に相当します。"

#: ../../library/re.rst:625
msgid ""
"Note that for backward compatibility, the :const:`re.U` flag still exists "
"(as well as its synonym :const:`re.UNICODE` and its embedded counterpart ``(?"
"u)``), but these are redundant in Python 3 since matches are Unicode by "
"default for strings (and Unicode matching isn't allowed for bytes)."
msgstr ""
"後方互換性のため、:const:`re.U` フラグ (と同義の :const:`re.UNICODE` および埋"
"め込みで使用する ``(?u)``) はまだ存在しますが、Python 3 では文字列のマッチが"
"デフォルトで Unicode (そしてバイト列では Unicode マッチングが扱えない) なので"
"冗長です。"

#: ../../library/re.rst:634
msgid ""
"Display debug information about compiled expression. No corresponding inline "
"flag."
msgstr ""
"コンパイル済み表現に関するデバッグ情報を表示します。相当するインラインフラグ"
"はありません。"

#: ../../library/re.rst:641
msgid ""
"Perform case-insensitive matching; expressions like ``[A-Z]`` will also "
"match lowercase letters.  Full Unicode matching (such as ``Ü`` matching "
"``ü``) also works unless the :const:`re.ASCII` flag is used to disable non-"
"ASCII matches.  The current locale does not change the effect of this flag "
"unless the :const:`re.LOCALE` flag is also used. Corresponds to the inline "
"flag ``(?i)``."
msgstr ""
"大文字・小文字を区別しないマッチングを行います; ``[A-Z]`` のような正規表現は"
"小文字にもマッチします。\n"
":const:`re.ASCII` フラグを使い、非 ASCII マッチが無効化されていない限り、 "
"(``Ü`` が ``ü`` にマッチするような) 完全な Unicode マッチングも有効です。\n"
":const:`re.LOCALE` フラグも一緒に使われていない限り、現在のロケールがこのフラ"
"グの効果を変更することはありません。\n"
"インラインフラグの ``(?i)`` に相当します。"

#: ../../library/re.rst:648
msgid ""
"Note that when the Unicode patterns ``[a-z]`` or ``[A-Z]`` are used in "
"combination with the :const:`IGNORECASE` flag, they will match the 52 ASCII "
"letters and 4 additional non-ASCII letters: 'İ' (U+0130, Latin capital "
"letter I with dot above), 'ı' (U+0131, Latin small letter dotless i), "
"'ſ' (U+017F, Latin small letter long s) and 'K' (U+212A, Kelvin sign). If "
"the :const:`ASCII` flag is used, only letters 'a' to 'z' and 'A' to 'Z' are "
"matched."
msgstr ""
"Unicode パターン ``[a-z]`` または ``[A-Z]`` が :const:`IGNORECASE` フラグとあ"
"わせて使われたとき、52 の ASCII 文字に加えて 4 の非 ASCII 文字 'İ' (U+0130, "
"Latin capital letter I with dot above) 、 'ı' (U+0131, Latin small letter "
"dotless i) 、 'ſ' (U+017F, Latin small letter long s) および 'K' (U+212A, "
"Kelvin sign) にマッチすることに注意してください。 :const:`ASCII` フラグが使わ"
"れているなら、文字 'a' から 'z' および 'A' から 'Z' にのみマッチします。"

#: ../../library/re.rst:659
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale.  This flag can be used only with bytes "
"patterns.  The use of this flag is discouraged as the locale mechanism is "
"very unreliable, it only handles one \"culture\" at a time, and it only "
"works with 8-bit locales.  Unicode matching is already enabled by default in "
"Python 3 for Unicode (str) patterns, and it is able to handle different "
"locales/languages. Corresponds to the inline flag ``(?L)``."
msgstr ""
"``\\w`` 、 ``\\W`` 、 ``\\b`` 、 ``\\B`` および大文字・小文字を区別しないマッ"
"チングを、現在のロケールに依存させます。ロケールの仕組みは信頼できず、一度に"
"一つの \"文化\" しか扱えず、 8 ビットロケールでしか働かないので、このフラグを"
"使うことは推奨されません。Python 3 において Unicode (str) パターンでは "
"Unicode マッチングはデフォルトですでに有効にされていて、異なるロケールや言語"
"を扱えます。インラインフラグの ``(?L)`` に相当します。"

#: ../../library/re.rst:668
msgid ""
":const:`re.LOCALE` can be used only with bytes patterns and is not "
"compatible with :const:`re.ASCII`."
msgstr ""
":const:`re.LOCALE` はバイト列パターンにのみ使え、:const:`re.ASCII` と互換では"
"ありません。"

#: ../../library/re.rst:672
msgid ""
"Compiled regular expression objects with the :const:`re.LOCALE` flag no "
"longer depend on the locale at compile time.  Only the locale at matching "
"time affects the result of matching."
msgstr ""
":const:`re.LOCALE` フラグがあるコンパイル済み正規表現オブジェクトはコンパイル"
"時のロケールに依存しなくなりました。マッチング時のロケールのみがマッチングの"
"結果に影響します。"

#: ../../library/re.rst:681
msgid ""
"When specified, the pattern character ``'^'`` matches at the beginning of "
"the string and at the beginning of each line (immediately following each "
"newline); and the pattern character ``'$'`` matches at the end of the string "
"and at the end of each line (immediately preceding each newline).  By "
"default, ``'^'`` matches only at the beginning of the string, and ``'$'`` "
"only at the end of the string and immediately before the newline (if any) at "
"the end of the string. Corresponds to the inline flag ``(?m)``."
msgstr ""
"指定されていると、パターン文字 ``'^'`` は文字列の先頭で、および各行の先頭 (各"
"改行の直後) で、マッチします。そしてパターン文字 ``'$'`` は文字列の末尾で、お"
"よび各行の末尾 (各改行の直前) で、マッチします。デフォルトでは、 ``'^'`` は文"
"字列の先頭でのみ、``'$'`` は文字列の末尾および文字列の末尾の改行 (もしあれ"
"ば) の直前でのみマッチします。インラインフラグの ``(?m)`` に相当します。"

#: ../../library/re.rst:693
msgid ""
"Make the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline. "
"Corresponds to the inline flag ``(?s)``."
msgstr ""
"``'.'`` 特殊文字を、改行を含むあらゆる文字にマッチさせます。このフラグがなけ"
"れば、``'.'`` は、改行 *以外の* あらゆる文字とマッチします。インラインフラグ"
"の ``(?s)`` に相当します。"

#: ../../library/re.rst:703
msgid ""
"This flag allows you to write regular expressions that look nicer and are "
"more readable by allowing you to visually separate logical sections of the "
"pattern and add comments. Whitespace within the pattern is ignored, except "
"when in a character class, or when preceded by an unescaped backslash, or "
"within tokens like ``*?``, ``(?:`` or ``(?P<...>``. For example, ``(? :`` "
"and ``* ?`` are not allowed. When a line contains a ``#`` that is not in a "
"character class and is not preceded by an unescaped backslash, all "
"characters from the leftmost such ``#`` through the end of the line are "
"ignored."
msgstr ""

#: ../../library/re.rst:713
msgid ""
"This means that the two following regular expression objects that match a "
"decimal number are functionally equal::"
msgstr ""
"つまり、10 進数字にマッチする下記のふたつの正規表現オブジェクトは、機能的に等"
"価です::"

#: ../../library/re.rst:721
msgid "Corresponds to the inline flag ``(?x)``."
msgstr "インラインフラグの ``(?x)`` に相当します。"

#: ../../library/re.rst:725
msgid "Functions"
msgstr "関数"

#: ../../library/re.rst:729
msgid ""
"Compile a regular expression pattern into a :ref:`regular expression object "
"<re-objects>`, which can be used for matching using its :func:`~Pattern."
"match`, :func:`~Pattern.search` and other methods, described below."
msgstr ""
"正規表現パターンを :ref:`正規表現オブジェクト <re-objects>` にコンパイルし、"
"以下に述べる :func:`~Pattern.match` 、 :func:`~Pattern.search` その他のメソッ"
"ドを使ってマッチングに使えるようにします。"

#: ../../library/re.rst:734
msgid ""
"The expression's behaviour can be modified by specifying a *flags* value. "
"Values can be any of the following variables, combined using bitwise OR (the "
"``|`` operator)."
msgstr ""
"式の挙動は *flags* の値を指定することで加減できます。値は以下の変数のうち任意"
"のものを、ビット単位 OR ( ``|`` 演算子) で組み合わせたものです。"

#: ../../library/re.rst:738
msgid "The sequence ::"
msgstr "シーケンス ::"

#: ../../library/re.rst:743
msgid "is equivalent to ::"
msgstr "は、以下と同等です ::"

#: ../../library/re.rst:747
msgid ""
"but using :func:`re.compile` and saving the resulting regular expression "
"object for reuse is more efficient when the expression will be used several "
"times in a single program."
msgstr ""
"が、 :func:`re.compile` を使い、結果の正規表現オブジェクトを保存して再利用す"
"るほうが、一つのプログラムでその表現を何回も使うときに効率的です。"

#: ../../library/re.rst:753
msgid ""
"The compiled versions of the most recent patterns passed to :func:`re."
"compile` and the module-level matching functions are cached, so programs "
"that use only a few regular expressions at a time needn't worry about "
"compiling regular expressions."
msgstr ""
":func:`re.compile` やモジュールレベルのマッチング関数に渡された最新のパターン"
"はコンパイル済みのものがキャッシュされるので、一度に正規表現を少ししか使わな"
"いプログラムでは正規表現をコンパイルする必要はありません。"

#: ../../library/re.rst:761
msgid ""
"Scan through *string* looking for the first location where the regular "
"expression *pattern* produces a match, and return a corresponding :ref:"
"`match object <match-objects>`.  Return ``None`` if no position in the "
"string matches the pattern; note that this is different from finding a zero-"
"length match at some point in the string."
msgstr ""
"*string* を走査し、正規表現 *pattern* がマッチを生じさせる最初の場所を探し"
"て、対応する :ref:`マッチオブジェクト <match-objects>` を返します。文字列内に"
"パターンにマッチする場所がなければ ``None`` を返します。これは文字列のどこか"
"で長さ 0 のマッチを見つけるのとは異なることに注意してください。"

#: ../../library/re.rst:770
msgid ""
"If zero or more characters at the beginning of *string* match the regular "
"expression *pattern*, return a corresponding :ref:`match object <match-"
"objects>`.  Return ``None`` if the string does not match the pattern; note "
"that this is different from a zero-length match."
msgstr ""
"*string* の先頭で 0 個以上の文字が正規表現 *pattern* にマッチすれば、対応す"
"る :ref:`マッチオブジェクト <match-objects>` を返します。文字列がパターンに"
"マッチしなければ ``None`` を返します。これは長さ 0 のマッチとは異なることに注"
"意して下さい。"

#: ../../library/re.rst:775
msgid ""
"Note that even in :const:`MULTILINE` mode, :func:`re.match` will only match "
"at the beginning of the string and not at the beginning of each line."
msgstr ""
":const:`MULTILINE` モードにおいても、:func:`re.match` は各行の先頭でマッチす"
"るのではなく、文字列の先頭でのみマッチすることに注意してください。"

#: ../../library/re.rst:778
msgid ""
"If you want to locate a match anywhere in *string*, use :func:`search` "
"instead (see also :ref:`search-vs-match`)."
msgstr ""
"*string* 中のどこででもマッチさせたいなら、代わりに :func:`search` を使ってく"
"ださい (:ref:`search-vs-match` も参照してください)。"

#: ../../library/re.rst:784
msgid ""
"If the whole *string* matches the regular expression *pattern*, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if the "
"string does not match the pattern; note that this is different from a zero-"
"length match."
msgstr ""
"*string* 全体が正規表現 *pattern* にマッチするなら、対応する :ref:`マッチオブ"
"ジェクト <match-objects>` を返します。文字列がパターンにマッチしないなら "
"``None`` を返します。これは長さ 0 のマッチとは異なることに注意して下さい。"

#: ../../library/re.rst:794
msgid ""
"Split *string* by the occurrences of *pattern*.  If capturing parentheses "
"are used in *pattern*, then the text of all groups in the pattern are also "
"returned as part of the resulting list. If *maxsplit* is nonzero, at most "
"*maxsplit* splits occur, and the remainder of the string is returned as the "
"final element of the list. ::"
msgstr ""
"*string* を、出現した *pattern* で分割します。 *pattern* 中でキャプチャの丸括"
"弧が使われていれば、パターン中の全てのグループのテキストも結果のリストの一部"
"として返されます。*maxsplit* が 0 でなければ、分割は最大 *maxsplit* 回起こ"
"り、残りの文字列はリストの最終要素として返されます。 ::"

#: ../../library/re.rst:809
msgid ""
"If there are capturing groups in the separator and it matches at the start "
"of the string, the result will start with an empty string.  The same holds "
"for the end of the string::"
msgstr ""
"セパレータ中にキャプチャグループがあり、それが文字列の先頭にマッチするなら、"
"結果は空文字列で始まります。同じことが文字列の末尾にも言えます。"

#: ../../library/re.rst:816
msgid ""
"That way, separator components are always found at the same relative indices "
"within the result list."
msgstr ""
"そうして、結果のリストにおいて、セパレータの構成要素は常に同じ相対的インデッ"
"クスに見つかります。"

#: ../../library/re.rst:819
msgid ""
"Empty matches for the pattern split the string only when not adjacent to a "
"previous empty match."
msgstr ""
"パターンへの空マッチは、直前の空マッチに隣接していないときのみ文字列を分割し"
"ます。"

#: ../../library/re.rst:829 ../../library/re.rst:919 ../../library/re.rst:943
msgid "Added the optional flags argument."
msgstr "オプションの flags 引数が追加されました。"

#: ../../library/re.rst:832
msgid ""
"Added support of splitting on a pattern that could match an empty string."
msgstr "空文字列にマッチしうるパターンでの分割をサポートするようになりました。"

#: ../../library/re.rst:838
msgid ""
"Return all non-overlapping matches of *pattern* in *string*, as a list of "
"strings or tuples.  The *string* is scanned left-to-right, and matches are "
"returned in the order found.  Empty matches are included in the result."
msgstr ""

#: ../../library/re.rst:842
msgid ""
"The result depends on the number of capturing groups in the pattern. If "
"there are no groups, return a list of strings matching the whole pattern.  "
"If there is exactly one group, return a list of strings matching that "
"group.  If multiple groups are present, return a list of tuples of strings "
"matching the groups.  Non-capturing groups do not affect the form of the "
"result."
msgstr ""

#: ../../library/re.rst:854 ../../library/re.rst:865
msgid "Non-empty matches can now start just after a previous empty match."
msgstr "空でないマッチが前の空マッチの直後から始められるようになりました。"

#: ../../library/re.rst:860
msgid ""
"Return an :term:`iterator` yielding :ref:`match objects <match-objects>` "
"over all non-overlapping matches for the RE *pattern* in *string*.  The "
"*string* is scanned left-to-right, and matches are returned in the order "
"found.  Empty matches are included in the result."
msgstr ""
"*string* 中の正規表現 *pattern* の重複しないマッチ全てに渡る :ref:`マッチオブ"
"ジェクト <match-objects>` を yield する :term:`イテレータ <iterator>` を返し"
"ます。  *string* は左から右へ走査され、マッチは見つかった順で返されます。空"
"マッチは結果に含まれます。"

#: ../../library/re.rst:871
msgid ""
"Return the string obtained by replacing the leftmost non-overlapping "
"occurrences of *pattern* in *string* by the replacement *repl*.  If the "
"pattern isn't found, *string* is returned unchanged.  *repl* can be a string "
"or a function; if it is a string, any backslash escapes in it are "
"processed.  That is, ``\\n`` is converted to a single newline character, "
"``\\r`` is converted to a carriage return, and so forth.  Unknown escapes of "
"ASCII letters are reserved for future use and treated as errors.  Other "
"unknown escapes such as ``\\&`` are left alone. Backreferences, such as "
"``\\6``, are replaced with the substring matched by group 6 in the pattern. "
"For example::"
msgstr ""
"*string* 中に出現する最も左の重複しない *pattern* を置換 *repl* で置換するこ"
"とで得られる文字列を返します。\n"
"パターンが見つからない場合、 *string* がそのまま返されます。\n"
"*repl* は文字列または関数です。\n"
"*repl* が文字列の場合は、その中の全てのバックスラッシュエスケープが処理されま"
"す。\n"
"``\\n`` は 1 つの改行文字に変換され、 ``\\r`` はキャリッジリターンに変換され"
"る、などです。\n"
"ASCII 文字のエスケープで未知のものは将来使うために予約されていて、エラーとし"
"て扱われます。\n"
"それ以外の ``\\&`` のような未知のエスケープは残されます。\n"
"``\\6`` のような後方参照は、パターンのグループ 6 がマッチした部分文字列で置換"
"されます。\n"
"例えば::"

#: ../../library/re.rst:887
msgid ""
"If *repl* is a function, it is called for every non-overlapping occurrence "
"of *pattern*.  The function takes a single :ref:`match object <match-"
"objects>` argument, and returns the replacement string.  For example::"
msgstr ""
"*repl* が関数であれば、それは重複しない *pattern* が出現するたびに呼び出され"
"ます。この関数は一つの :ref:`マッチオブジェクト <match-objects>` 引数を取り、"
"置換文字列を返します。例えば::"

#: ../../library/re.rst:899
msgid "The pattern may be a string or a :ref:`pattern object <re-objects>`."
msgstr ""
"パターンは、文字列でも :ref:`パターンオブジェクト <re-objects>` でも構いませ"
"ん。"

#: ../../library/re.rst:901
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  If omitted or zero, "
"all occurrences will be replaced. Empty matches for the pattern are replaced "
"only when not adjacent to a previous empty match, so ``sub('x*', '-', "
"'abxd')`` returns ``'-a-b--d-'``."
msgstr ""
"オプション引数 *count* は出現したパターンを置換する最大の回数です。 *count* "
"は非負整数です。省略されるか 0 なら、出現した全てが置換されます。パターンへの"
"空マッチは前の空マッチに隣接していないときのみ置換されるので、 ``sub('x*', "
"'-', 'abxd')`` は ``'-a-b--d-'`` を返します。"

#: ../../library/re.rst:909
msgid ""
"In string-type *repl* arguments, in addition to the character escapes and "
"backreferences described above, ``\\g<name>`` will use the substring matched "
"by the group named ``name``, as defined by the ``(?P<name>...)`` syntax. "
"``\\g<number>`` uses the corresponding group number; ``\\g<2>`` is therefore "
"equivalent to ``\\2``, but isn't ambiguous in a replacement such as "
"``\\g<2>0``.  ``\\20`` would be interpreted as a reference to group 20, not "
"a reference to group 2 followed by the literal character ``'0'``.  The "
"backreference ``\\g<0>`` substitutes in the entire substring matched by the "
"RE."
msgstr ""
"文字列型 *repl* 引数では、上で述べた文字エスケープや後方参照に加えて、 "
"``\\g<name>`` は ``(?P<name>...)`` 構文で定義された ``name`` という名前のグ"
"ループがマッチした部分文字列を使い、 ``\\g<number>`` は対応するグループ番号を"
"使います。よって ``\\g<2>`` は ``\\2`` と等価ですが、 ``\\g<2>0`` のような置"
"換においても曖昧になりません。 ``\\20`` は、グループ 20 への参照として解釈さ"
"れ、グループ 2 への参照にリテラル文字 ``'0'`` が続いたものとしては解釈されま"
"せん。後方参照 ``\\g<0>`` は正規表現とマッチした部分文字列全体で置き換わりま"
"す。"

#: ../../library/re.rst:922 ../../library/re.rst:946 ../../library/re.rst:1180
msgid "Unmatched groups are replaced with an empty string."
msgstr "マッチしなかったグループは空文字列に置き換えられます。"

#: ../../library/re.rst:925
msgid ""
"Unknown escapes in *pattern* consisting of ``'\\'`` and an ASCII letter now "
"are errors."
msgstr ""
"*pattern* 中に ``'\\'`` と ASCII 文字からなる未知のエスケープがあると、エラー"
"になります。"

#: ../../library/re.rst:929
msgid ""
"Unknown escapes in *repl* consisting of ``'\\'`` and an ASCII letter now are "
"errors."
msgstr ""
"*repl* 中に ``'\\'`` と ASCII 文字からなる未知のエスケープがあると、エラーに"
"なります。"

#: ../../library/re.rst:933
msgid ""
"Empty matches for the pattern are replaced when adjacent to a previous non-"
"empty match."
msgstr ""
"パターンへの空マッチは前の空でないマッチに隣接しているとき置き換えられます。"

#: ../../library/re.rst:940
msgid ""
"Perform the same operation as :func:`sub`, but return a tuple ``(new_string, "
"number_of_subs_made)``."
msgstr ""
":func:`sub` と同じ操作を行いますが、タプル ``(new_string、 "
"number_of_subs_made)`` を返します。"

#: ../../library/re.rst:952
msgid ""
"Escape special characters in *pattern*. This is useful if you want to match "
"an arbitrary literal string that may have regular expression metacharacters "
"in it.  For example::"
msgstr ""
"*pattern* 中の特殊文字をエスケープします。これは正規表現メタ文字を含みうる任"
"意のリテラル文字列にマッチしたい時に便利です。"

#: ../../library/re.rst:967
msgid ""
"This function must not be used for the replacement string in :func:`sub` "
"and :func:`subn`, only backslashes should be escaped.  For example::"
msgstr ""
"この関数は、バックスラッシュのみをエスケープするべき :func:`sub` および :"
"func:`subn` における置換文字列に使われてはなりません。例えば::"

#: ../../library/re.rst:975
msgid "The ``'_'`` character is no longer escaped."
msgstr "``'_'`` 文字がエスケープされなくなりました。"

#: ../../library/re.rst:978
msgid ""
"Only characters that can have special meaning in a regular expression are "
"escaped. As a result, ``'!'``, ``'\"'``, ``'%'``, ``\"'\"``, ``','``, "
"``'/'``, ``':'``, ``';'``, ``'<'``, ``'='``, ``'>'``, ``'@'``, and ``\"`\"`` "
"are no longer escaped."
msgstr ""
"正規表現で特別な意味を持つ文字だけがエスケープされます。結果として、 "
"``'!'``、 ``'\"'``、 ``'%'``、 ``\"'\"``、 ``','``、 ``'/'``、 ``':'``、 "
"``';'``、 ``'<'``、 ``'='``、 ``'>'``、 ``'@'``、 と ``\"`\"`` はもはやエス"
"ケープされません。"

#: ../../library/re.rst:987
msgid "Clear the regular expression cache."
msgstr "正規表現キャッシュをクリアします。"

#: ../../library/re.rst:991
msgid "Exceptions"
msgstr "例外"

#: ../../library/re.rst:995
msgid ""
"Exception raised when a string passed to one of the functions here is not a "
"valid regular expression (for example, it might contain unmatched "
"parentheses) or when some other error occurs during compilation or "
"matching.  It is never an error if a string contains no match for a "
"pattern.  The error instance has the following additional attributes:"
msgstr ""
"ここの関数のいずれかに渡された文字列が有効な正規表現ではない (例: 括弧が対に"
"なっていない) とき、またはコンパイルやマッチングの際にその他なんらかのエラー"
"が発生した場合に送出される例外です。文字列にパターンとマッチする部分がなくて"
"も、それはエラーではありません。エラーインスタンスには、次のような追加の属性"
"があります。"

#: ../../library/re.rst:1003
msgid "The unformatted error message."
msgstr "フォーマットされていないエラーメッセージです。"

#: ../../library/re.rst:1007
msgid "The regular expression pattern."
msgstr "正規表現のパターンです。"

#: ../../library/re.rst:1011
msgid "The index in *pattern* where compilation failed (may be ``None``)."
msgstr ""
"*pattern* のコンパイルに失敗した場所のインデックスです (``None`` の場合もあり"
"ます)。"

#: ../../library/re.rst:1015
msgid "The line corresponding to *pos* (may be ``None``)."
msgstr "*pos* に対応する行です (``None`` の場合もあります)。"

#: ../../library/re.rst:1019
msgid "The column corresponding to *pos* (may be ``None``)."
msgstr "*pos* に対応する列です (``None`` の場合もあります)。"

#: ../../library/re.rst:1021
msgid "Added additional attributes."
msgstr "追加の属性が追加されました。"

#: ../../library/re.rst:1027
msgid "Regular Expression Objects"
msgstr "正規表現オブジェクト"

#: ../../library/re.rst:1029
msgid ""
"Compiled regular expression objects support the following methods and "
"attributes:"
msgstr ""
"コンパイル済み正規表現オブジェクトは以下のメソッドと属性をサポートします:"

#: ../../library/re.rst:1034
msgid ""
"Scan through *string* looking for the first location where this regular "
"expression produces a match, and return a corresponding :ref:`match object "
"<match-objects>`.  Return ``None`` if no position in the string matches the "
"pattern; note that this is different from finding a zero-length match at "
"some point in the string."
msgstr ""
"*string* を走査し、この正規表現がマッチを生じさせる最初の場所を探して、対応す"
"る :ref:`マッチオブジェクト <match-objects>` を返します。文字列内にパターンに"
"マッチする場所がなければ ``None`` を返します。これは文字列内のある場所で長さ"
"が 0 のマッチが見つかった場合とは異なることに注意してください。"

#: ../../library/re.rst:1040
msgid ""
"The optional second parameter *pos* gives an index in the string where the "
"search is to start; it defaults to ``0``.  This is not completely equivalent "
"to slicing the string; the ``'^'`` pattern character matches at the real "
"beginning of the string and at positions just after a newline, but not "
"necessarily at the index where the search is to start."
msgstr ""
"オプションの第二引数 *pos* は、文字列のどこから探し始めるかを指定するインデッ"
"クスで、デフォルトでは 0 です。これは文字列のスライスと完全には同じではありま"
"せん。パターン文字 ``'^'`` は本当の文字列の先頭と改行の直後でマッチしますが、"
"検索を開始するインデックスでマッチするとは限りません。"

#: ../../library/re.rst:1046
msgid ""
"The optional parameter *endpos* limits how far the string will be searched; "
"it will be as if the string is *endpos* characters long, so only the "
"characters from *pos* to ``endpos - 1`` will be searched for a match.  If "
"*endpos* is less than *pos*, no match will be found; otherwise, if *rx* is a "
"compiled regular expression object, ``rx.search(string, 0, 50)`` is "
"equivalent to ``rx.search(string[:50], 0)``. ::"
msgstr ""
"オプションの引数 *endpos* は文字列がどこまで検索されるかを制限します。文字列"
"の長さが *endpos* 文字だったかのようになるので、*pos* から ``endpos - 1`` の"
"文字に対してだけマッチを探します。*endpos* が *pos* よりも小さいと、マッチは"
"見つかりません。そうでなければ、*rx* をコンパイル済み正規表現オブジェクトとし"
"て、``rx.search(string, 0, 50)`` は ``rx.search(string[:50], 0)`` と等価で"
"す。 ::"

#: ../../library/re.rst:1061
msgid ""
"If zero or more characters at the *beginning* of *string* match this regular "
"expression, return a corresponding :ref:`match object <match-objects>`. "
"Return ``None`` if the string does not match the pattern; note that this is "
"different from a zero-length match."
msgstr ""
"*string* の *先頭* で 0 文字以上がこの正規表現とマッチするなら、対応する :"
"ref:`マッチオブジェクト <match-objects>` を返します。文字列がパターンにマッチ"
"しなければ ``None`` を返します。これは長さ 0 のマッチとは異なることに注意して"
"ください。"

#: ../../library/re.rst:1066 ../../library/re.rst:1084
msgid ""
"The optional *pos* and *endpos* parameters have the same meaning as for the :"
"meth:`~Pattern.search` method. ::"
msgstr ""
"オプションの *pos* および *endpos* 引数は :meth:`~Pattern.search` メソッドの"
"ものと同じ意味です。"

#: ../../library/re.rst:1074
msgid ""
"If you want to locate a match anywhere in *string*, use :meth:`~Pattern."
"search` instead (see also :ref:`search-vs-match`)."
msgstr ""
"*string* 中のどこででもマッチさせたいなら、代わりに :meth:`~Pattern.search` "
"を使ってください (:ref:`search-vs-match` も参照してください)。"

#: ../../library/re.rst:1080
msgid ""
"If the whole *string* matches this regular expression, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if the "
"string does not match the pattern; note that this is different from a zero-"
"length match."
msgstr ""
"*string* 全体がこの正規表現にマッチすれば、対応する :ref:`マッチオブジェクト "
"<match-objects>` を返します。文字列がパターンにマッチしなければ ``None`` を返"
"します。これは長さ 0 のマッチとは異なることに注意してください。"

#: ../../library/re.rst:1098
msgid "Identical to the :func:`split` function, using the compiled pattern."
msgstr ":func:`split` 関数にこのコンパイル済みパターンを使うのと同じです。"

#: ../../library/re.rst:1103
msgid ""
"Similar to the :func:`findall` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""
":func:`findall` 関数にこのコンパイル済みパターンを使うのと似ていますが、オプ"
"ションの *pos* および *endpos* 引数で :meth:`search` のように検索範囲を制限で"
"きます。"

#: ../../library/re.rst:1110
msgid ""
"Similar to the :func:`finditer` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""
":func:`finditer` 関数にこのコンパイル済みパターンを使うのと似ていますが、オプ"
"ションの *pos* および *endpos* 引数で :meth:`search` のように検索範囲を制限で"
"きます。"

#: ../../library/re.rst:1117
msgid "Identical to the :func:`sub` function, using the compiled pattern."
msgstr ":func:`sub` 関数にこのコンパイル済みパターンを使うのと同じです。"

#: ../../library/re.rst:1122
msgid "Identical to the :func:`subn` function, using the compiled pattern."
msgstr ":func:`subn` 関数にこのコンパイル済みパターンを使うのと同じです。"

#: ../../library/re.rst:1127
msgid ""
"The regex matching flags.  This is a combination of the flags given to :func:"
"`.compile`, any ``(?...)`` inline flags in the pattern, and implicit flags "
"such as :data:`UNICODE` if the pattern is a Unicode string."
msgstr ""
"正規表現のマッチングフラグです。これは :func:`.compile` に与えられたフラグ、"
"パターン中の ``(?...)`` インラインフラグ、およびパターンが Unicode 文字列だっ"
"た時の :data:`UNICODE` のような暗黙のフラグの組み合わせです。"

#: ../../library/re.rst:1134
msgid "The number of capturing groups in the pattern."
msgstr "パターン中のキャプチャグループの数です。"

#: ../../library/re.rst:1139
msgid ""
"A dictionary mapping any symbolic group names defined by ``(?P<id>)`` to "
"group numbers.  The dictionary is empty if no symbolic groups were used in "
"the pattern."
msgstr ""
"``(?P<id>)`` で定義されたあらゆるシンボリックグループ名をグループ番号へ写像す"
"る辞書です。シンボリックグループがパターン中で全く使われていなければ、この辞"
"書は空です。"

#: ../../library/re.rst:1146
msgid "The pattern string from which the pattern object was compiled."
msgstr "パターンオブジェクトがコンパイルされた元のパターン文字列です。"

#: ../../library/re.rst:1149
msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Compiled "
"regular expression objects are considered atomic."
msgstr ""
":func:`copy.copy` および :func:`copy.deepcopy` をサポートするようになりまし"
"た。コンパイル済み正規表現オブジェクトはアトミックであると見なされます。"

#: ../../library/re.rst:1157
msgid "Match Objects"
msgstr "マッチオブジェクト"

#: ../../library/re.rst:1159
msgid ""
"Match objects always have a boolean value of ``True``. Since :meth:`~Pattern."
"match` and :meth:`~Pattern.search` return ``None`` when there is no match, "
"you can test whether there was a match with a simple ``if`` statement::"
msgstr ""
"マッチオブジェクトのブール値は常に ``True`` です。 :meth:`~Pattern.match` お"
"よび :meth:`~Pattern.search` はマッチがないとき ``None`` を返すので、マッチが"
"あるか単純な ``if`` 文で判定できます。"

#: ../../library/re.rst:1168
msgid "Match objects support the following methods and attributes:"
msgstr "マッチオブジェクトは以下のメソッドおよび属性をサポートしています:"

#: ../../library/re.rst:1173
msgid ""
"Return the string obtained by doing backslash substitution on the template "
"string *template*, as done by the :meth:`~Pattern.sub` method. Escapes such "
"as ``\\n`` are converted to the appropriate characters, and numeric "
"backreferences (``\\1``, ``\\2``) and named backreferences (``\\g<1>``, "
"``\\g<name>``) are replaced by the contents of the corresponding group."
msgstr ""
"テンプレート文字列 *template* に :meth:`~Pattern.sub` メソッドの行うバックス"
"ラッシュ置換を行って得られる文字列を返します。 ``\\n`` のようなエスケープは適"
"切な文字に変換され、数後方参照 (``\\1``, ``\\2``) および名前付き後方参照 "
"(``\\g<1>``, ``\\g<name>``) は対応するグループの内容に置換されます。"

#: ../../library/re.rst:1185
msgid ""
"Returns one or more subgroups of the match.  If there is a single argument, "
"the result is a single string; if there are multiple arguments, the result "
"is a tuple with one item per argument. Without arguments, *group1* defaults "
"to zero (the whole match is returned). If a *groupN* argument is zero, the "
"corresponding return value is the entire matching string; if it is in the "
"inclusive range [1..99], it is the string matching the corresponding "
"parenthesized group.  If a group number is negative or larger than the "
"number of groups defined in the pattern, an :exc:`IndexError` exception is "
"raised. If a group is contained in a part of the pattern that did not match, "
"the corresponding result is ``None``. If a group is contained in a part of "
"the pattern that matched multiple times, the last match is returned. ::"
msgstr ""
"このマッチの 1 つ以上のサブグループを返します。引数が 1 つなら結果は 1 つの文"
"字列です。複数の引数があれば、結果は引数ごとに 1 項目のタプルです。引数がなけ"
"れば、 *group1* はデフォルトで 0 (マッチ全体が返される) です。 *groupN* 引数"
"が 0 なら、対応する返り値はマッチした文字列全体です。1 以上 99 以下なら、丸括"
"弧による対応するグループにマッチする文字列です。グループ番号が負であるかパ"
"ターン中で定義されたグループの数より大きければ、 :exc:`IndexError` 例外が送出"
"されます。あるグループがパターンのマッチしなかった部分に含まれているなら、対"
"応する結果は ``None`` です。あるグループがパターンの複数回マッチした部分に含"
"まれているなら、最後のマッチが返されます。 ::"

#: ../../library/re.rst:1207
msgid ""
"If the regular expression uses the ``(?P<name>...)`` syntax, the *groupN* "
"arguments may also be strings identifying groups by their group name.  If a "
"string argument is not used as a group name in the pattern, an :exc:"
"`IndexError` exception is raised."
msgstr ""
"正規表現が ``(?P<name>...)`` 構文を使うなら、 *groupN* 引数はグループ名でグ"
"ループを識別する文字列でも構いません。文字列引数がパターン中でグループ名とし"
"て使われていなければ、 :exc:`IndexError` 例外が送出されます。"

#: ../../library/re.rst:1212
msgid "A moderately complicated example::"
msgstr "やや複雑な例::"

#: ../../library/re.rst:1220
msgid "Named groups can also be referred to by their index::"
msgstr "名前付きグループはインデックスでも参照できます::"

#: ../../library/re.rst:1227
msgid "If a group matches multiple times, only the last match is accessible::"
msgstr ""
"あるグループが複数回マッチすると、その最後のマッチにのみアクセスできます::"

#: ../../library/re.rst:1236
msgid ""
"This is identical to ``m.group(g)``.  This allows easier access to an "
"individual group from a match::"
msgstr ""
"これは ``m.group(g)`` と同等です。これでマッチの個別のグループに簡単にアクセ"
"スできます::"

#: ../../library/re.rst:1252
msgid ""
"Return a tuple containing all the subgroups of the match, from 1 up to "
"however many groups are in the pattern.  The *default* argument is used for "
"groups that did not participate in the match; it defaults to ``None``."
msgstr ""
"このマッチの、1 からパターン中のグループ数まで、全てのサブグループを含むタプ"
"ルを返します。*default* 引数はマッチに関係しなかったグループに使われます。デ"
"フォルトでは ``None`` です。"

#: ../../library/re.rst:1256 ../../library/re.rst:1481
msgid "For example::"
msgstr "例えば::"

#: ../../library/re.rst:1262
msgid ""
"If we make the decimal place and everything after it optional, not all "
"groups might participate in the match.  These groups will default to "
"``None`` unless the *default* argument is given::"
msgstr ""
"少数位およびその後の全てをオプションにすると、全てのグループがマッチに関係す"
"るとは限りません。そういったグループは *default* 引数が与えられない限りデフォ"
"ルトで ``None`` になります。"

#: ../../library/re.rst:1275
msgid ""
"Return a dictionary containing all the *named* subgroups of the match, keyed "
"by the subgroup name.  The *default* argument is used for groups that did "
"not participate in the match; it defaults to ``None``.  For example::"
msgstr ""
"このマッチの、全ての *名前付き* サブグループを含む、サブグループ名をキーとす"
"る辞書を返します。 *default* 引数はマッチに関係しなかったグループに使われま"
"す。デフォルトは ``None`` です。例えば::"

#: ../../library/re.rst:1287
msgid ""
"Return the indices of the start and end of the substring matched by *group*; "
"*group* defaults to zero (meaning the whole matched substring). Return "
"``-1`` if *group* exists but did not contribute to the match.  For a match "
"object *m*, and a group *g* that did contribute to the match, the substring "
"matched by group *g* (equivalent to ``m.group(g)``) is ::"
msgstr ""
"*group* がマッチした部分文字列の先頭と末尾のインデックスを返します。 *group* "
"はデフォルトで 0 (マッチした部分文字列全体という意味) です。 *group* が存在し"
"てかつマッチには寄与していなかったなら ``-1`` を返します。マッチオブジェクト "
"*m* と、マッチに寄与したグループ *g* に対して、グループ *g* がマッチした部分"
"文字列 (``m.group(g)`` と等価です) は以下の通りです ::"

#: ../../library/re.rst:1295
msgid ""
"Note that ``m.start(group)`` will equal ``m.end(group)`` if *group* matched "
"a null string.  For example, after ``m = re.search('b(c?)', 'cba')``, ``m."
"start(0)`` is 1, ``m.end(0)`` is 2, ``m.start(1)`` and ``m.end(1)`` are both "
"2, and ``m.start(2)`` raises an :exc:`IndexError` exception."
msgstr ""
"*group* が空文字列にマッチしていたら ``m.start(group)`` は ``m.end(group)`` "
"と等しくなることに注意して下さい。例えば、 ``m = re.search('b(c?)', 'cba')`` "
"とすると、 ``m.start(0)`` は 1 で、 ``m.end(0)`` は 2 で、 ``m.start(1)`` と "
"``m.end(1)`` はともに 2 であり、 ``m.start(2)`` は :exc:`IndexError` 例外を発"
"生します。"

#: ../../library/re.rst:1300
msgid "An example that will remove *remove_this* from email addresses::"
msgstr "メールアドレスから *remove_this* を取り除く例::"

#: ../../library/re.rst:1310
msgid ""
"For a match *m*, return the 2-tuple ``(m.start(group), m.end(group))``. Note "
"that if *group* did not contribute to the match, this is ``(-1, -1)``. "
"*group* defaults to zero, the entire match."
msgstr ""
"マッチ *m* について、2 タプル ``(m.start(group), m.end(group))`` を返しま"
"す。 *group* がマッチに寄与していなければ、これは ``(-1, -1)`` です。 "
"*group* はデフォルトで 0 、マッチ全体です。"

#: ../../library/re.rst:1317
msgid ""
"The value of *pos* which was passed to the :meth:`~Pattern.search` or :meth:"
"`~Pattern.match` method of a :ref:`regex object <re-objects>`.  This is the "
"index into the string at which the RE engine started looking for a match."
msgstr ""
":ref:`正規表現オブジェクト <re-objects>` の :meth:`~Pattern.search` や :meth:"
"`~Pattern.match` に渡された *pos* の値です。これは正規表現エンジンがマッチを"
"探し始める位置の文字列のインデックスです。"

#: ../../library/re.rst:1324
msgid ""
"The value of *endpos* which was passed to the :meth:`~Pattern.search` or :"
"meth:`~Pattern.match` method of a :ref:`regex object <re-objects>`.  This is "
"the index into the string beyond which the RE engine will not go."
msgstr ""
":ref:`正規表現オブジェクト <re-objects>` の :meth:`~Pattern.search` や :meth:"
"`~Pattern.match` に渡された *endpos* の値です。これは正規表現エンジンがそれ以"
"上は進まない文字列のインデックスです。"

#: ../../library/re.rst:1331
msgid ""
"The integer index of the last matched capturing group, or ``None`` if no "
"group was matched at all. For example, the expressions ``(a)b``, ``((a)"
"(b))``, and ``((ab))`` will have ``lastindex == 1`` if applied to the string "
"``'ab'``, while the expression ``(a)(b)`` will have ``lastindex == 2``, if "
"applied to the same string."
msgstr ""
"最後にマッチしたキャプチャグループの整数インデックスです。どのグループも全く"
"マッチしなければ ``None`` です。例えば、表現 ``(a)b`` 、 ``((a)(b))`` や "
"``((ab))`` が ``'ab'`` に適用されると ``lastindex == 1`` となり、同じ文字列"
"に ``(a)(b)`` が適用されると ``lastindex == 2`` となります。"

#: ../../library/re.rst:1340
msgid ""
"The name of the last matched capturing group, or ``None`` if the group "
"didn't have a name, or if no group was matched at all."
msgstr ""
"最後にマッチしたキャプチャグループの名前です。そのグループに名前がないか、ど"
"のグループも全くマッチしていなければ ``None`` です。"

#: ../../library/re.rst:1346
msgid ""
"The :ref:`regular expression object <re-objects>` whose :meth:`~Pattern."
"match` or :meth:`~Pattern.search` method produced this match instance."
msgstr ""
"このマッチインスタンスを生じさせた :meth:`~Pattern.match` または :meth:"
"`~Pattern.search` メソッドの属する :ref:`正規表現オブジェクト <re-objects>` "
"です。"

#: ../../library/re.rst:1352
msgid "The string passed to :meth:`~Pattern.match` or :meth:`~Pattern.search`."
msgstr ""
":meth:`~Pattern.match` や :meth:`~Pattern.search` へ渡された文字列です。"

#: ../../library/re.rst:1355
msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Match objects "
"are considered atomic."
msgstr ""
":func:`copy.copy` および :func:`copy.deepcopy` をサポートするようになりまし"
"た。マッチオブジェクトはアトミックであると見なされます。"

#: ../../library/re.rst:1363
msgid "Regular Expression Examples"
msgstr "正規表現の例"

#: ../../library/re.rst:1367
msgid "Checking for a Pair"
msgstr "ペアの確認"

#: ../../library/re.rst:1369
msgid ""
"In this example, we'll use the following helper function to display match "
"objects a little more gracefully::"
msgstr ""
"この例では、マッチオブジェクトをより美しく表示するために、この補助関数を使用"
"します:: "

#: ../../library/re.rst:1377
msgid ""
"Suppose you are writing a poker program where a player's hand is represented "
"as a 5-character string with each character representing a card, \"a\" for "
"ace, \"k\" for king, \"q\" for queen, \"j\" for jack, \"t\" for 10, and "
"\"2\" through \"9\" representing the card with that value."
msgstr ""
"あなたがポーカープログラムを書いているとします。プレイヤーの手札は 5 文字の文"
"字列によって表され、それぞれの文字が 1 枚のカードを表します。 \"a\" はエー"
"ス、 \"k\" はキング、 \"q\" はクイーン、 \"j\" はジャック、 \"t\" は 10、そし"
"て \"2\" から \"9\" はその数字のカードを表します。"

#: ../../library/re.rst:1382
msgid "To see if a given string is a valid hand, one could do the following::"
msgstr "与えられた文字列が有効な手札であるか見るには、以下のようにできます::"

#: ../../library/re.rst:1392
msgid ""
"That last hand, ``\"727ak\"``, contained a pair, or two of the same valued "
"cards. To match this with a regular expression, one could use backreferences "
"as such::"
msgstr ""
"最後の手札、 ``\"727ak\"`` 、はペア、すなわち同じ値の 2 枚のカードを含みま"
"す。正規表現でこれにマッチするには、このように後方参照を使えます::"

#: ../../library/re.rst:1402
msgid ""
"To find out what card the pair consists of, one could use the :meth:`~Match."
"group` method of the match object in the following manner::"
msgstr ""
"ペアになっているのがどのカードか調べるには、このようにマッチオブジェクトの :"
"meth:`~Match.group` メソッドを使えます::"

#: ../../library/re.rst:1421
msgid "Simulating scanf()"
msgstr "scanf() をシミュレートする"

#: ../../library/re.rst:1425
msgid ""
"Python does not currently have an equivalent to :c:func:`scanf`.  Regular "
"expressions are generally more powerful, though also more verbose, than :c:"
"func:`scanf` format strings.  The table below offers some more-or-less "
"equivalent mappings between :c:func:`scanf` format tokens and regular "
"expressions."
msgstr ""
"Python には現在のところ、 :c:func:`scanf` に相当するものがありません。正規表"
"現は一般的に、 :c:func:`scanf` のフォーマット文字列より強力ですが、冗長でもあ"
"ります。以下の表に、 :c:func:`scanf` のフォーマットトークンと正規表現のおおよ"
"その対応付けを示します。"

#: ../../library/re.rst:1432
msgid ":c:func:`scanf` Token"
msgstr ":c:func:`scanf` トークン"

#: ../../library/re.rst:1432
msgid "Regular Expression"
msgstr "正規表現"

#: ../../library/re.rst:1434
msgid "``%c``"
msgstr "``%c``"

#: ../../library/re.rst:1436
msgid "``%5c``"
msgstr "``%5c``"

#: ../../library/re.rst:1436
msgid "``.{5}``"
msgstr "``.{5}``"

#: ../../library/re.rst:1438
msgid "``%d``"
msgstr "``%d``"

#: ../../library/re.rst:1438
msgid "``[-+]?\\d+``"
msgstr "``[-+]?\\d+``"

#: ../../library/re.rst:1440
msgid "``%e``, ``%E``, ``%f``, ``%g``"
msgstr "``%e``, ``%E``, ``%f``, ``%g``"

#: ../../library/re.rst:1440
msgid "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"
msgstr "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"

#: ../../library/re.rst:1442
msgid "``%i``"
msgstr "``%i``"

#: ../../library/re.rst:1442
msgid "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"
msgstr "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"

#: ../../library/re.rst:1444
msgid "``%o``"
msgstr "``%o``"

#: ../../library/re.rst:1444
msgid "``[-+]?[0-7]+``"
msgstr "``[-+]?[0-7]+``"

#: ../../library/re.rst:1446
msgid "``%s``"
msgstr "``%s``"

#: ../../library/re.rst:1446
msgid "``\\S+``"
msgstr "``\\S+``"

#: ../../library/re.rst:1448
msgid "``%u``"
msgstr "``%u``"

#: ../../library/re.rst:1448
msgid "``\\d+``"
msgstr "``\\d+``"

#: ../../library/re.rst:1450
msgid "``%x``, ``%X``"
msgstr "``%x``, ``%X``"

#: ../../library/re.rst:1450
msgid "``[-+]?(0[xX])?[\\dA-Fa-f]+``"
msgstr "``[-+]?(0[xX])?[\\dA-Fa-f]+``"

#: ../../library/re.rst:1453
msgid "To extract the filename and numbers from a string like ::"
msgstr "以下のような文字列からファイル名と数を抽出するには ::"

#: ../../library/re.rst:1457
msgid "you would use a :c:func:`scanf` format like ::"
msgstr "以下のように :c:func:`scanf` フォーマットを使えます ::"

#: ../../library/re.rst:1461
msgid "The equivalent regular expression would be ::"
msgstr "等価な正規表現はこうです ::"

#: ../../library/re.rst:1469
msgid "search() vs. match()"
msgstr "search() vs. match()"

#: ../../library/re.rst:1473
msgid ""
"Python offers different primitive operations based on regular expressions:"
msgstr ""

#: ../../library/re.rst:1475
msgid ":func:`re.match` checks for a match only at the beginning of the string"
msgstr ""

#: ../../library/re.rst:1476
msgid ""
":func:`re.search` checks for a match anywhere in the string (this is what "
"Perl does by default)"
msgstr ""

#: ../../library/re.rst:1478
msgid ":func:`re.fullmatch` checks for entire string to be a match"
msgstr ""

#: ../../library/re.rst:1490
msgid ""
"Regular expressions beginning with ``'^'`` can be used with :func:`search` "
"to restrict the match at the beginning of the string::"
msgstr ""
"``'^'`` で始まる正規表現を :func:`search` で使って、マッチを文字列の先頭での"
"みに制限できます::"

#: ../../library/re.rst:1498
msgid ""
"Note however that in :const:`MULTILINE` mode :func:`match` only matches at "
"the beginning of the string, whereas using :func:`search` with a regular "
"expression beginning with ``'^'`` will match at the beginning of each "
"line. ::"
msgstr ""
"ただし、 :const:`MULTILINE` モードにおいて :func:`match` は文字列の先頭でのみ"
"マッチし、 ``'^'`` で始まる正規表現で :func:`search` を使うと各行の先頭でマッ"
"チすることに注意してください。"

#: ../../library/re.rst:1508
msgid "Making a Phonebook"
msgstr "電話帳を作る"

#: ../../library/re.rst:1510
msgid ""
":func:`split` splits a string into a list delimited by the passed pattern.  "
"The method is invaluable for converting textual data into data structures "
"that can be easily read and modified by Python as demonstrated in the "
"following example that creates a phonebook."
msgstr ""
":func:`split` は渡されたパターンで文字列を分割してリストにします。このメソッ"
"ドは、テキストデータをデータ構造に変換して、読みやすくしたり、以下の例で実演"
"する電話帳作成のように Python で編集したりしやすくするのに、非常に役に立ちま"
"す。"

#: ../../library/re.rst:1515
msgid ""
"First, here is the input.  Normally it may come from a file, here we are "
"using triple-quoted string syntax"
msgstr ""
"最初に、入力を示します。通常、これはファイルからの入力になるでしょう。ここで"
"は、3重引用符の書式とします。"

#: ../../library/re.rst:1528
msgid ""
"The entries are separated by one or more newlines. Now we convert the string "
"into a list with each nonempty line having its own entry:"
msgstr ""
"各項目は 1 つ以上の改行で区切られています。まずは文字列を変換して、空行でない"
"各行を項目とするリストにします:"

#: ../../library/re.rst:1541
msgid ""
"Finally, split each entry into a list with first name, last name, telephone "
"number, and address.  We use the ``maxsplit`` parameter of :func:`split` "
"because the address has spaces, our splitting pattern, in it:"
msgstr ""
"そして各項目を、ファーストネーム、ラストネーム、電話番号、住所に分割してリス"
"トにします。分割パターンである空白文字は住所にも含まれるので、 :func:`split` "
"の ``maxsplit`` 引数を使います:"

#: ../../library/re.rst:1554
msgid ""
"The ``:?`` pattern matches the colon after the last name, so that it does "
"not occur in the result list.  With a ``maxsplit`` of ``4``, we could "
"separate the house number from the street name:"
msgstr ""
"この ``:?`` パターンはラストネームの次のコロンにマッチして、分割結果のリスト"
"に出てこないようにします。 ``maxsplit`` を ``4`` にすれば、家屋番号とストリー"
"ト名を分割できます:"

#: ../../library/re.rst:1569
msgid "Text Munging"
msgstr "テキストの秘匿"

#: ../../library/re.rst:1571
msgid ""
":func:`sub` replaces every occurrence of a pattern with a string or the "
"result of a function.  This example demonstrates using :func:`sub` with a "
"function to \"munge\" text, or randomize the order of all the characters in "
"each word of a sentence except for the first and last characters::"
msgstr ""
":func:`sub` は出現する各パターンを文字列で、または関数の返り値で置き換えま"
"す。この例ではテキストを「秘匿」する関数と合わせて :func:`sub` を使うところを"
"実演します。具体的には、文中の各単語について、最初と最後の文字を除く全ての文"
"字をランダムに並び替えます::"

#: ../../library/re.rst:1588
msgid "Finding all Adverbs"
msgstr "全ての副詞を見つける"

#: ../../library/re.rst:1590
msgid ""
":func:`findall` matches *all* occurrences of a pattern, not just the first "
"one as :func:`search` does.  For example, if a writer wanted to find all of "
"the adverbs in some text, they might use :func:`findall` in the following "
"manner::"
msgstr ""
":func:`search` は最初のパターンにのみマッチしますが、 :func:`findall` は出現"
"する *全ての* パターンにマッチします。例えば、ライターがあるテキストの全ての"
"副詞を見つけたいなら、以下のように :func:`findall` を使えます::"

#: ../../library/re.rst:1601
msgid "Finding all Adverbs and their Positions"
msgstr "全ての副詞とその位置を見つける"

#: ../../library/re.rst:1603
msgid ""
"If one wants more information about all matches of a pattern than the "
"matched text, :func:`finditer` is useful as it provides :ref:`match objects "
"<match-objects>` instead of strings.  Continuing with the previous example, "
"if a writer wanted to find all of the adverbs *and their positions* in some "
"text, they would use :func:`finditer` in the following manner::"
msgstr ""
"パターンの全てのマッチについて、マッチしたテキスト以上の情報が必要なら、文字"
"列ではなく :ref:`マッチオブジェクト <match-objects>` を返す :func:`finditer` "
"が便利です。先の例に続いて、ライターがあるテキストの全ての副詞 *およびその位"
"置* を見つけたいなら、以下のように :func:`finditer` を使えます::"

#: ../../library/re.rst:1617
msgid "Raw String Notation"
msgstr "Raw 文字列記法"

#: ../../library/re.rst:1619
msgid ""
"Raw string notation (``r\"text\"``) keeps regular expressions sane.  Without "
"it, every backslash (``'\\'``) in a regular expression would have to be "
"prefixed with another one to escape it.  For example, the two following "
"lines of code are functionally identical::"
msgstr ""
"Raw 文字列記法 (``r\"text\"``) で正規表現をまともに保てます。それがなければ、"
"正規表現中のバックスラッシュ (``'\\'``) を個々にバックスラッシュを前置してエ"
"スケープしなければなりません。例えば、以下の 2 行のコードは機能的に等価です::"

#: ../../library/re.rst:1629
msgid ""
"When one wants to match a literal backslash, it must be escaped in the "
"regular expression.  With raw string notation, this means ``r\"\\\\\"``.  "
"Without raw string notation, one must use ``\"\\\\\\\\\"``, making the "
"following lines of code functionally identical::"
msgstr ""
"リテラルのバックスラッシュにマッチさせたいなら、正規表現中ではエスケープする"
"必要があります。Raw 文字列記法では、``r\"\\\\\"``  になります。Raw 文字列記法"
"を用いないと、``\"\\\\\\\\\"`` としなくてはならず、以下のコードは機能的に等価"
"です::"

#: ../../library/re.rst:1641
msgid "Writing a Tokenizer"
msgstr "トークナイザを書く"

#: ../../library/re.rst:1643
msgid ""
"A `tokenizer or scanner <https://en.wikipedia.org/wiki/Lexical_analysis>`_ "
"analyzes a string to categorize groups of characters.  This is a useful "
"first step in writing a compiler or interpreter."
msgstr ""
"`トークナイザやスキャナ <https://en.wikipedia.org/wiki/Lexical_analysis>`_ は"
"文字列を解析し、文字のグループにカテゴリ分けします。これはコンパイラやインタ"
"プリタを書くうえで役立つ第一段階です。"

#: ../../library/re.rst:1647
msgid ""
"The text categories are specified with regular expressions.  The technique "
"is to combine those into a single master regular expression and to loop over "
"successive matches::"
msgstr ""
"テキストのカテゴリは正規表現で指定されます。この技法では、それらを一つのマス"
"ター正規表現に結合し、マッチの連続についてループします::"

#: ../../library/re.rst:1703
msgid "The tokenizer produces the following output::"
msgstr "このトークナイザは以下の出力を作成します::"

#: ../../library/re.rst:1726
msgid ""
"Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O'Reilly Media, "
"2009. The third edition of the book no longer covers Python at all, but the "
"first edition covered writing good regular expression patterns in great "
"detail."
msgstr ""
"Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O'Reilly Media, "
"2009. 当書の第三版ではもはや Python についてまったく取り扱っていませんが、初"
"版では良い正規表現を書くことを綿密に取り扱っていました。"
