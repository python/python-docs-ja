# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-12-31 18:01+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Akihiro Uchida <uchida@turbare.net>, 2017\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/re.rst:2
msgid ":mod:`re` --- Regular expression operations"
msgstr ":mod:`re` --- 正規表現操作"

#: ../../library/re.rst:10
msgid "**Source code:** :source:`Lib/re.py`"
msgstr "**ソースコード:** :source:`Lib/re.py`"

#: ../../library/re.rst:14
msgid ""
"This module provides regular expression matching operations similar to those"
" found in Perl."
msgstr "このモジュールは、Perl などと同様の正規表現マッチング操作を提供しています。"

#: ../../library/re.rst:17
msgid ""
"Both patterns and strings to be searched can be Unicode strings "
"(:class:`str`) as well as 8-bit strings (:class:`bytes`). However, Unicode "
"strings and 8-bit strings cannot be mixed: that is, you cannot match a "
"Unicode string with a byte pattern or vice-versa; similarly, when asking for"
" a substitution, the replacement string must be of the same type as both the"
" pattern and the search string."
msgstr ""
"パターンと文字列には Unicode 文字列 (:class:`str`) および 8 ビット文字列 (:class:`bytes`) "
"が使用できます。しかし、Unicode 文字列と8ビット文字列の混在はできません。すなわち、Unicode "
"文字列をバイト列のパターンでマッチングしたり、その逆はできません。同様に、置き換え時の置換文字列はパターンおよび検索文字列と同じ型でなくてはなりません。"

#: ../../library/re.rst:24
msgid ""
"Regular expressions use the backslash character (``'\\'``) to indicate "
"special forms or to allow special characters to be used without invoking "
"their special meaning.  This collides with Python's usage of the same "
"character for the same purpose in string literals; for example, to match a "
"literal backslash, one might have to write ``'\\\\\\\\'`` as the pattern "
"string, because the regular expression must be ``\\\\``, and each backslash "
"must be expressed as ``\\\\`` inside a regular Python string literal."
msgstr ""
"正規表現では、特殊な形式を表したり、特殊文字の持つ特別な意味を呼び出さずにその特殊な文字を使えるようにするために、バックスラッシュ文字 "
"(``'\\'``) を使います。こうしたバックスラッシュの使い方は、 Python "
"の文字列リテラルにおける同じバックスラッシュ文字と衝突を起こします。例えば、バックスラッシュ自体にマッチさせるには、パターン文字列として "
"``'\\\\\\\\'`` と書かなければなりません、というのも、正規表現は ``\\\\`` でなければならず、さらに正規な Python "
"文字列リテラルでは各々のバックスラッシュを ``\\\\`` と表現せねばならないからです。"

#: ../../library/re.rst:33
msgid ""
"The solution is to use Python's raw string notation for regular expression "
"patterns; backslashes are not handled in any special way in a string literal"
" prefixed with ``'r'``.  So ``r\"\\n\"`` is a two-character string "
"containing ``'\\'`` and ``'n'``, while ``\"\\n\"`` is a one-character string"
" containing a newline.  Usually patterns will be expressed in Python code "
"using this raw string notation."
msgstr ""
"正規表現パターンに Python の raw string 記法を使えばこの問題を解決できます。 ``'r'`` "
"を前置した文字列リテラル内ではバックスラッシュを特別扱いしません。従って、 ``\"\\n\"`` が改行一文字の入った文字列になるのに対して、 "
"``r\"\\n\"`` は ``'\\'`` と ``'n'`` という二つの文字の入った文字列になります。通常、 Python "
"コード中では、パターンをこの raw string 記法を使って表現します。"

#: ../../library/re.rst:40
msgid ""
"It is important to note that most regular expression operations are "
"available as module-level functions and methods on :ref:`compiled regular "
"expressions <re-objects>`.  The functions are shortcuts that don't require "
"you to compile a regex object first, but miss some fine-tuning parameters."
msgstr ""
"大抵の正規表現操作が、モジュールレベルの関数と、 :ref:`コンパイル済み正規表現 <re-objects>` "
"のメソッドとして提供されることに注意して下さい。関数は正規表現オブジェクトのコンパイルを必要としない近道ですが、いくつかのチューニング変数を失います。"

#: ../../library/re.rst:48
msgid ""
"The third-party `regex <https://pypi.python.org/pypi/regex/>`_ module, which"
" has an API compatible with the standard library :mod:`re` module, but "
"offers additional functionality and a more thorough Unicode support."
msgstr ""
"サードパーティの `regex <https://pypi.python.org/pypi/regex/>`_ モジュールは、標準ライブラリの "
":mod:`re` モジュールと互換な API を持ち、追加の機能とより徹底した Unicode サポートを提供します。"

#: ../../library/re.rst:56
msgid "Regular Expression Syntax"
msgstr "正規表現のシンタックス"

#: ../../library/re.rst:58
msgid ""
"A regular expression (or RE) specifies a set of strings that matches it; the"
" functions in this module let you check if a particular string matches a "
"given regular expression (or if a given regular expression matches a "
"particular string, which comes down to the same thing)."
msgstr ""
"正規表現 (すなわち RE) は、表現にマッチ (match) "
"する文字列の集合を表しています。このモジュールの関数を使えば、ある文字列が指定の正規表現にマッチするか "
"(または指定の正規表現がある文字列にマッチするか、つまりは同じことですが) を検査できます。"

#: ../../library/re.rst:63
msgid ""
"Regular expressions can be concatenated to form new regular expressions; if "
"*A* and *B* are both regular expressions, then *AB* is also a regular "
"expression. In general, if a string *p* matches *A* and another string *q* "
"matches *B*, the string *pq* will match AB.  This holds unless *A* or *B* "
"contain low precedence operations; boundary conditions between *A* and *B*; "
"or have numbered group references.  Thus, complex expressions can easily be "
"constructed from simpler primitive expressions like the ones described here."
"  For details of the theory and implementation of regular expressions, "
"consult the Friedl book referenced above, or almost any textbook about "
"compiler construction."
msgstr ""
"正規表現を連結すると新しい正規表現を作れます。 *A* と *B* がともに正規表現であれば *AB* も正規表現です。一般的に、文字列 *p* が A"
"　とマッチし、別の文字列 *q* が B とマッチすれば、文字列 *pq* は AB にマッチします。ただし、この状況が成り立つのは、 *A* と "
"*B* との間に境界条件がある場合や、番号付けされたグループ参照のような、優先度の低い演算を *A* や *B* "
"が含まない場合だけです。かくして、ここで述べるような、より簡単でプリミティブな正規表現から、複雑な正規表現を容易に構築できます。正規表現に関する理論と実装の詳細については上記の"
" Friedl 本か、コンパイラの構築に関する教科書を調べて下さい。"

#: ../../library/re.rst:73
msgid ""
"A brief explanation of the format of regular expressions follows.  For "
"further information and a gentler presentation, consult the :ref:`regex-"
"howto`."
msgstr ""
"以下で正規表現の形式に関する簡単な説明をしておきます。より詳細な情報やよりやさしい説明に関しては、 :ref:`regex-howto` "
"を参照してください。"

#: ../../library/re.rst:76
msgid ""
"Regular expressions can contain both special and ordinary characters. Most "
"ordinary characters, like ``'A'``, ``'a'``, or ``'0'``, are the simplest "
"regular expressions; they simply match themselves.  You can concatenate "
"ordinary characters, so ``last`` matches the string ``'last'``.  (In the "
"rest of this section, we'll write RE's in ``this special style``, usually "
"without quotes, and strings to be matched ``'in single quotes'``.)"
msgstr ""
"正規表現には、特殊文字と通常文字の両方を含められます。 ``'A'`` 、 ``'a'`` 、あるいは ``'0'`` "
"のようなほとんどの通常文字は最も簡単な正規表現になります。こうした文字は、単純にその文字自体にマッチします。通常の文字は連結できるので、 "
"``last`` は文字列 ``'last'`` とマッチします。 (この節の以降の説明では、正規表現を引用符を使わずに ``この表示スタイル: "
"special style`` で書き、マッチ対象の文字列は、 ``'引用符で括って'`` 書きます。)"

#: ../../library/re.rst:83
msgid ""
"Some characters, like ``'|'`` or ``'('``, are special. Special characters "
"either stand for classes of ordinary characters, or affect how the regular "
"expressions around them are interpreted."
msgstr ""
"``'|'`` や ``'('`` "
"といったいくつかの文字は特殊文字です。特殊文字は通常の文字の種別を表したり、あるいは特殊文字の周辺にある通常の文字に対する解釈方法に影響します。"

#: ../../library/re.rst:87
msgid ""
"Repetition qualifiers (``*``, ``+``, ``?``, ``{m,n}``, etc) cannot be "
"directly nested. This avoids ambiguity with the non-greedy modifier suffix "
"``?``, and with other modifiers in other implementations. To apply a second "
"repetition to an inner repetition, parentheses may be used. For example, the"
" expression ``(?:a{6})*`` matches any multiple of six ``'a'`` characters."
msgstr ""
"繰り返しの修飾子 (``*``, ``+``, ``?``, ``{m,n}`` など) は直接入れ子にはできません。\n"
"これによって、非貪欲な修飾子の接尾辞 ``?`` や他の実装での他の修飾子についての曖昧さを回避しています。\n"
"繰り返しのある正規表現の外側にさらに繰り返しを適用するには丸括弧が使えます。\n"
"例えば、正規表現 ``(?:a{6})*`` は6つの ``'a'`` の0回以上の繰り返しに適合します。"

#: ../../library/re.rst:94
msgid "The special characters are:"
msgstr "特殊文字を以下に示します:"

#: ../../library/re.rst:99 ../../library/re.rst:1282
msgid "``.``"
msgstr "``.``"

#: ../../library/re.rst:97
msgid ""
"(Dot.)  In the default mode, this matches any character except a newline.  "
"If the :const:`DOTALL` flag has been specified, this matches any character "
"including a newline."
msgstr ""
"(ドット) デフォルトのモードでは改行以外の任意の文字にマッチします。 :const:`DOTALL` "
"フラグが指定されていれば改行も含むすべての文字にマッチします。"

#: ../../library/re.rst:103
msgid "``^``"
msgstr "``^``"

#: ../../library/re.rst:102
msgid ""
"(Caret.)  Matches the start of the string, and in :const:`MULTILINE` mode "
"also matches immediately after each newline."
msgstr "(キャレット) 文字列の先頭とマッチします。 :const:`MULTILINE` モードでは各改行の直後にマッチします。"

#: ../../library/re.rst:112
msgid "``$``"
msgstr "``$``"

#: ../../library/re.rst:106
msgid ""
"Matches the end of the string or just before the newline at the end of the "
"string, and in :const:`MULTILINE` mode also matches before a newline.  "
"``foo`` matches both 'foo' and 'foobar', while the regular expression "
"``foo$`` matches only 'foo'.  More interestingly, searching for ``foo.$`` in"
" ``'foo1\\nfoo2\\n'`` matches 'foo2' normally, but 'foo1' in "
":const:`MULTILINE` mode; searching for a single ``$`` in ``'foo\\n'`` will "
"find two (empty) matches: one just before the newline, and one at the end of"
" the string."
msgstr ""
"文字列の末尾、あるいは文字列の末尾の改行の直前にマッチします。例えば、 ``foo`` は 'foo' と 'foobar' "
"の両方にマッチします。一方、正規表現 ``foo$`` は 'foo' だけとマッチします。興味深いことに、 ``'foo1\\nfoo2\\n'`` "
"を ``foo.$`` で検索した場合、通常のモードでは 'foo2' だけにマッチし、 :const:`MULTILINE` モードでは 'foo1'"
" にもマッチします。 ``$`` だけで ``'foo\\n'`` を検索した場合、2箇所 (内容は空) でマッチします: "
"1つは、改行の直前で、もう1つは、文字列の最後です。"

#: ../../library/re.rst:117
msgid "``*``"
msgstr "``*``"

#: ../../library/re.rst:115
msgid ""
"Causes the resulting RE to match 0 or more repetitions of the preceding RE, "
"as many repetitions as are possible.  ``ab*`` will match 'a', 'ab', or 'a' "
"followed by any number of 'b's."
msgstr ""
"直前にある RE に作用して、 RE を 0 回以上できるだけ多く繰り返したものにマッチさせるようにします。例えば ``ab*`` は "
"'a'、'ab'、あるいは 'a' に任意個数の'b' を続けたものにマッチします。"

#: ../../library/re.rst:122
msgid "``+``"
msgstr "``+``"

#: ../../library/re.rst:120
msgid ""
"Causes the resulting RE to match 1 or more repetitions of the preceding RE. "
"``ab+`` will match 'a' followed by any non-zero number of 'b's; it will not "
"match just 'a'."
msgstr ""
"直前にある RE に作用して、 RE を、1 回以上繰り返したものにマッチさせるようにします。例えば ``ab+`` は 'a' に一つ以上の 'b' "
"が続いたものにマッチし、 'a' 単体にはマッチしません。"

#: ../../library/re.rst:126
msgid "``?``"
msgstr "``?``"

#: ../../library/re.rst:125
msgid ""
"Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. "
"``ab?`` will match either 'a' or 'ab'."
msgstr ""
"直前にある RE に作用して、 RE を 0 回か 1 回繰り返したものにマッチさせるようにします。例えば ``ab?`` は 'a' あるいは "
"'ab' にマッチします。"

#: ../../library/re.rst:135
msgid "``*?``, ``+?``, ``??``"
msgstr "``*?``, ``+?``, ``??``"

#: ../../library/re.rst:129
msgid ""
"The ``'*'``, ``'+'``, and ``'?'`` qualifiers are all :dfn:`greedy`; they "
"match as much text as possible.  Sometimes this behaviour isn't desired; if "
"the RE ``<.*>`` is matched against ``'<a> b <c>'``, it will match the entire"
" string, and not just ``'<a>'``.  Adding ``?`` after the qualifier makes it "
"perform the match in :dfn:`non-greedy` or :dfn:`minimal` fashion; as *few* "
"characters as possible will be matched.  Using the RE ``<.*?>`` will match "
"only ``'<a>'``."
msgstr ""
"``'*'`` 、 ``'+'`` 、 ``'?'`` といった修飾子は、すべて :dfn:`貪欲 (greedy)` "
"マッチ、すなわちできるだけ多くのテキストにマッチするようになっています。時にはこの動作が望ましくない場合もあります。例えば正規表現 ``<.*>`` を"
" ``'<a> b <c>'`` にマッチさせると、 ``'<a>'`` だけにマッチするのではなく全文字列にマッチしてしまいます。 ``?`` "
"を修飾子の後に追加すると、 :dfn:`非貪欲 (non-greedy)` あるいは :dfn:`最小一致 (minimal)` "
"のマッチになり、できるだけ *少ない* 文字数のマッチになります。例えば正規表現 ``<.*?>`` を使うと ``'<a>'`` だけにマッチします。"

#: ../../library/re.rst:140
msgid "``{m}``"
msgstr "``{m}``"

#: ../../library/re.rst:138
msgid ""
"Specifies that exactly *m* copies of the previous RE should be matched; "
"fewer matches cause the entire RE not to match.  For example, ``a{6}`` will "
"match exactly six ``'a'`` characters, but not five."
msgstr ""
"前にある RE の *m* 回の正確なコピーとマッチすべきであることを指定します；マッチ回数が少なければ、RE 全体ではマッチしません。例えば、 "
"``a{6}`` は、正確に 6個の ``'a'`` 文字とマッチしますが、 5個ではマッチしません。"

#: ../../library/re.rst:149
msgid "``{m,n}``"
msgstr "``{m,n}``"

#: ../../library/re.rst:143
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible.  For "
"example, ``a{3,5}`` will match from 3 to 5 ``'a'`` characters.  Omitting *m*"
" specifies a lower bound of zero,  and omitting *n* specifies an infinite "
"upper bound.  As an example, ``a{4,}b`` will match ``'aaaab'`` or a thousand"
" ``'a'`` characters followed by a ``'b'``, but not ``'aaab'``. The comma may"
" not be omitted or the modifier would be confused with the previously "
"described form."
msgstr ""
"結果の RE は、前にある RE を、*m* 回から *n* "
"回まで繰り返したもので、できるだけ多く繰り返したものとマッチするように、マッチします。例えば、``a{3,5}`` は、3個から 5個の ``'a'``"
" 文字とマッチします。*m* を省略するとマッチ回数の下限として0を指定した事になり、*n* を省略することは、上限が無限であることを指定します;  "
"``a{4,}b`` は ``'aaaab'`` や、1,000 個の ``'a'`` 文字に ``'b'`` "
"が続いたものとマッチしますが、``'aaab'`` "
"とはマッチしません。コンマは省略できません、省略すると修飾子が上で述べた形式と混同されてしまうからです。"

#: ../../library/re.rst:156
msgid "``{m,n}?``"
msgstr "``{m,n}?``"

#: ../../library/re.rst:152
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as *few* repetitions as possible.  This is"
" the non-greedy version of the previous qualifier.  For example, on the "
"6-character string ``'aaaaaa'``, ``a{3,5}`` will match 5 ``'a'`` characters,"
" while ``a{3,5}?`` will only match 3 characters."
msgstr ""
"結果の RE は、前にある RE の *m* 回から *n* 回まで繰り返したもので、できるだけ *少なく* "
"繰り返したものとマッチするように、マッチします。これは、前の修飾子の控え目バージョンです。例えば、 6文字文字列 ``'aaaaaa'`` では、 "
"``a{3,5}`` は、5個の ``'a'`` 文字とマッチしますが、 ``a{3,5}?`` は3個の文字とマッチするだけです。"

#: ../../library/re.rst:169
msgid "``\\``"
msgstr "``\\``"

#: ../../library/re.rst:159
msgid ""
"Either escapes special characters (permitting you to match characters like "
"``'*'``, ``'?'``, and so forth), or signals a special sequence; special "
"sequences are discussed below."
msgstr ""
"特殊文字をエスケープする( ``'*'`` や ``'?'`` 等のような文字とのマッチをできるようにする) か、あるいは、特殊シーケンスの合図です; "
"特殊シーケンスは後で議論します。"

#: ../../library/re.rst:163
msgid ""
"If you're not using a raw string to express the pattern, remember that "
"Python also uses the backslash as an escape sequence in string literals; if "
"the escape sequence isn't recognized by Python's parser, the backslash and "
"subsequent character are included in the resulting string.  However, if "
"Python would recognize the resulting sequence, the backslash should be "
"repeated twice.  This is complicated and hard to understand, so it's highly "
"recommended that you use raw strings for all but the simplest expressions."
msgstr ""
"もしパターンを表現するのに raw string を使用していないのであれば、 Python "
"も、バックスラッシュを文字列リテラルでのエスケープシーケンスとして使っていることを覚えていて下さい。エスケープシーケンスを Python "
"の構文解析器が認識して処理しない場合、そのバックスラッシュとそれに続く文字は、結果の文字列にそのまま含まれます。しかし、Python "
"が結果のシーケンスを認識する場合は、バックスラッシュを 2回繰り返さなければいけません。これは複雑で理解しにくいので、最も簡単な表現以外は、すべて "
"raw string を使うことを強く推奨します。"

#: ../../library/re.rst:201
msgid "``[]``"
msgstr "``[]``"

#: ../../library/re.rst:172
msgid "Used to indicate a set of characters.  In a set:"
msgstr "文字の集合を指定するのに使用します。集合には以下のものが指定できます:"

#: ../../library/re.rst:174
msgid ""
"Characters can be listed individually, e.g. ``[amk]`` will match ``'a'``, "
"``'m'``, or ``'k'``."
msgstr "個別に指定できる文字。 ``[amk]`` は ``'a'``, ``'m'``, ``'k'`` とマッチします。"

#: ../../library/re.rst:177
msgid ""
"Ranges of characters can be indicated by giving two characters and "
"separating them by a ``'-'``, for example ``[a-z]`` will match any lowercase"
" ASCII letter, ``[0-5][0-9]`` will match all the two-digits numbers from "
"``00`` to ``59``, and ``[0-9A-Fa-f]`` will match any hexadecimal digit.  If "
"``-`` is escaped (e.g. ``[a\\-z]``) or if it's placed as the first or last "
"character (e.g. ``[-a]`` or ``[a-]``), it will match a literal ``'-'``."
msgstr ""
"連続した文字の範囲を、先頭と最後の2文字とその間に ``'-'`` を挟んだ形で指定できます。``[a-z]`` はすべての小文字の ASCII "
"文字とマッチします。``[0-5][0-9]`` は ``00`` から ``59`` までの、すべての 2 桁の数字とマッチします。``[0-9A-"
"Fa-f]`` は任意の 16 進数の数字とマッチします。``-`` が、エスケープされた場合 (例: "
"``[a\\-z]``)、あるいは先頭か末尾に置かれた場合 (例: ``[-a]`` や ``[a-]``)、リテラル ``'-'`` とマッチします。"

#: ../../library/re.rst:184
msgid ""
"Special characters lose their special meaning inside sets.  For example, "
"``[(+*)]`` will match any of the literal characters ``'('``, ``'+'``, "
"``'*'``, or ``')'``."
msgstr ""
"集合内では、特殊文字はその意味を失います。 ``[(+*)]`` はリテラル文字 ``'('`` ``'+'`` 、 ``'*'`` 、あるいは "
"``')'`` のいずれかとマッチします。"

#: ../../library/re.rst:188
msgid ""
"Character classes such as ``\\w`` or ``\\S`` (defined below) are also "
"accepted inside a set, although the characters they match depends on whether"
" :const:`ASCII` or :const:`LOCALE` mode is in force."
msgstr ""
"``\\w`` や ``\\S`` のような文字クラス (後述) も集合内に指定できますが、それらにマッチする文字は :const:`ASCII` か "
":const:`LOCALE` のどちらか有効にされているモードに依存します。"

#: ../../library/re.rst:192
msgid ""
"Characters that are not within a range can be matched by "
":dfn:`complementing` the set.  If the first character of the set is ``'^'``,"
" all the characters that are *not* in the set will be matched.  For example,"
" ``[^5]`` will match any character except ``'5'``, and ``[^^]`` will match "
"any character except ``'^'``.  ``^`` has no special meaning if it's not the "
"first character in the set."
msgstr ""
"範囲内にない文字とは、その集合の :dfn:`補集合` をとることでマッチできます。集合の最初の文字が ``'^'`` の時、集合に *ない* "
"文字すべてとマッチします。 ``[^5]`` は ``'5'`` を除くあらゆる文字にマッチします。 ``[^^]`` は ``'^'`` "
"を除くあらゆる文字にマッチします。 ``^`` は集合の最初の文字でない限り特別の意味を持ちません。"

#: ../../library/re.rst:199
msgid ""
"To match a literal ``']'`` inside a set, precede it with a backslash, or "
"place it at the beginning of the set.  For example, both ``[()[\\]{}]`` and "
"``[]()[{}]`` will both match a parenthesis."
msgstr ""
"集合内でリテラル ``']'`` をマッチさせるには、その前にバックスラッシュをつけるか、集合の先頭に置きます。 ``[()[\\]{}]`` と "
"``[]()[{}]`` はどちらも ``']'`` にマッチします。"

#: ../../library/re.rst:212
msgid "``|``"
msgstr "``|``"

#: ../../library/re.rst:204
msgid ""
"``A|B``, where *A* and *B* can be arbitrary REs, creates a regular "
"expression that will match either *A* or *B*.  An arbitrary number of REs "
"can be separated by the ``'|'`` in this way.  This can be used inside groups"
" (see below) as well.  As the target string is scanned, REs separated by "
"``'|'`` are tried from left to right. When one pattern completely matches, "
"that branch is accepted. This means that once *A* matches, *B* will not be "
"tested further, even if it would produce a longer overall match.  In other "
"words, the ``'|'`` operator is never greedy.  To match a literal ``'|'``, "
"use ``\\|``, or enclose it inside a character class, as in ``[|]``."
msgstr ""
"``A|B`` (*A* と *B* は任意の RE) は、 *A* か *B* のどちらかとマッチする正規表現を作成します。任意個数の RE "
"を、このように ``'|'`` で分離することができます。これはグループ (下記参照) "
"内部でも使えます。走査対象文字列をスキャンする中で、``'|'`` で分離された RE "
"は左から右への順に走査されます。一つでも完全にマッチしたパターンがあれば、そのパターン枝が受理されます。このことは、もし *A* がマッチすれば、たとえ"
" *B* によるマッチが全体としてより長いマッチになったとしても、 *B* を決して走査しないことを意味します。言いかえると、``'|'`` "
"演算子は決して貪欲 (greedy) にはなりません。リテラル ``'|'`` とマッチするには、``\\|`` を使うか、あるいは ``[|]`` "
"のように文字クラス内に入れます。"

#: ../../library/re.rst:219
msgid "``(...)``"
msgstr "``(...)``"

#: ../../library/re.rst:215
msgid ""
"Matches whatever regular expression is inside the parentheses, and indicates"
" the start and end of a group; the contents of a group can be retrieved "
"after a match has been performed, and can be matched later in the string "
"with the ``\\number`` special sequence, described below.  To match the "
"literals ``'('`` or ``')'``, use ``\\(`` or ``\\)``, or enclose them inside "
"a character class: ``[(]``, ``[)]``."
msgstr ""
"丸括弧の中にどのような正規表現があってもマッチし、丸括弧はグループの開始と終了を表します; "
"グループの中身は、マッチが実行された後に回収され、特殊シーケンス ``\\number`` (後述) で参照することができます。リテラル ``'('``"
" や ``')'`` とマッチするには、``\\(`` や ``\\)`` を使うか、それらを文字クラス内に入れます:  ``[(]``, "
"``[)]`` 。"

#: ../../library/re.rst:226
msgid "``(?...)``"
msgstr "``(?...)``"

#: ../../library/re.rst:222
msgid ""
"This is an extension notation (a ``'?'`` following a ``'('`` is not "
"meaningful otherwise).  The first character after the ``'?'`` determines "
"what the meaning and further syntax of the construct is. Extensions usually "
"do not create a new group; ``(?P<name>...)`` is the only exception to this "
"rule. Following are the currently supported extensions."
msgstr ""
"これは拡張記法です (``'('`` に続く ``'?'`` は他には意味がありません) 。 ``'?'`` "
"の後の最初の文字が、この構造の意味とこれ以上のシンタックスがどういうものであるかを決定します。拡張記法は普通新しいグループを作成しません； "
"``(?P<name>...)`` がこの規則の唯一の例外です。以下に現在サポートされている拡張記法を示します。"

#: ../../library/re.rst:240
msgid "``(?aiLmsux)``"
msgstr "``(?aiLmsux)``"

#: ../../library/re.rst:229
msgid ""
"(One or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``.)  The group matches the empty string; the letters"
" set the corresponding flags: :const:`re.A` (ASCII-only matching), "
":const:`re.I` (ignore case), :const:`re.L` (locale dependent), :const:`re.M`"
" (multi-line), :const:`re.S` (dot matches all), :const:`re.U` (Unicode "
"matching), and :const:`re.X` (verbose), for the entire regular expression. "
"(The flags are described in :ref:`contents-of-module-re`.) This is useful if"
" you wish to include the flags as part of the regular expression, instead of"
" passing a *flag* argument to the :func:`re.compile` function.  Flags should"
" be used first in the expression string."
msgstr ""
"(``'a'``, ``'i'``, ``'L'``, ``'m'``, ``'s'``, ``'u'``, ``'x'`` の集合にある文字を 1 個以上。)\n"
"グループは空文字列ともマッチします; 正規表現全体に対して、文字に対応するフラグ、 :const:`re.A` (ASCII 限定マッチ)、:const:`re.I` (大文字・小文字を区別しない)、:const:`re.L` (ロケール依存)、:const:`re.M` (MULTILINE モード)、:const:`re.S` (DOTALL モード)、 :const:`re.U` (Unicode マッチ)、 :const:`re.X` (冗長) を設定します。\n"
"(フラグについては :ref:`contents-of-module-re` を参照してください。)\n"
"これは、*flag* 引数を :func:`re.compile` 関数に渡すのではなく、そのフラグを正規表現の一部に含めたい場合に役立ちます。\n"
"フラグは正規表現文字列の先頭で使うべきです。"

#: ../../library/re.rst:246
msgid "``(?:...)``"
msgstr "``(?:...)``"

#: ../../library/re.rst:243
msgid ""
"A non-capturing version of regular parentheses.  Matches whatever regular "
"expression is inside the parentheses, but the substring matched by the group"
" *cannot* be retrieved after performing a match or referenced later in the "
"pattern."
msgstr ""
"正規表現の丸括弧の取り込まないバージョンです。どのような正規表現が丸括弧内にあってもマッチしますが、グループによってマッチされたサブ文字列は、マッチを実行したあと検索されることも、あるいは後でパターンで参照されることも"
" *できません* 。"

#: ../../library/re.rst:256
msgid "``(?imsx-imsx:...)``"
msgstr "``(?imsx-imsx:...)``"

#: ../../library/re.rst:249
msgid ""
"(Zero or more letters from the set ``'i'``, ``'m'``, ``'s'``, ``'x'``, "
"optionally followed by ``'-'`` followed by one or more letters from the same"
" set.)  The letters set or removes the corresponding flags: :const:`re.I` "
"(ignore case), :const:`re.M` (multi-line), :const:`re.S` (dot matches all), "
"and :const:`re.X` (verbose), for the part of the expression.  (The flags are"
" described in :ref:`contents-of-module-re`.)"
msgstr ""
"(``'i'``, ``'m'``, ``'s'``, ``'x'`` の集合にある文字を 0 個以上、それに続くオプショナルな ``'-'`` と先程と同じ集合にある文字を 1 個以上。)\n"
"正規表現の一部に対して、文字に対応するフラグ、:const:`re.I` (大文字・小文字を区別しない), :const:`re.M` (MULTILINE モード), :const:`re.S` (DOTALL モード), :const:`re.X` (冗長) を設定したり除去したりします。\n"
"(これらのフラグについては :ref:`contents-of-module-re` に解説があります。)"

#: ../../library/re.rst:281
msgid "``(?P<name>...)``"
msgstr "``(?P<name>...)``"

#: ../../library/re.rst:259
msgid ""
"Similar to regular parentheses, but the substring matched by the group is "
"accessible via the symbolic group name *name*.  Group names must be valid "
"Python identifiers, and each group name must be defined only once within a "
"regular expression.  A symbolic group is also a numbered group, just as if "
"the group were not named."
msgstr ""
"正規表現の丸括弧に似ていますが、グループによってマッチした部分文字列はシンボリック\\ グループ名 *name* "
"によってアクセス可能になります。グループ名は有効な Python 識別子でなければならず、グループ名は 1 "
"個の正規表現内で一意でなければなりません。シンボリックグループは番号付けもされており、番号によるアクセスも可能です。"

#: ../../library/re.rst:265
msgid ""
"Named groups can be referenced in three contexts.  If the pattern is "
"``(?P<quote>['\"]).*?(?P=quote)`` (i.e. matching a string quoted with either"
" single or double quotes):"
msgstr ""
"名前付きグループは 3 つのコンテキストで参照できます。パターンが ``(?P<quote>['\\\"]).*?(?P=quote)`` "
"(シングルまたはダブルクオートのどちらかにマッチ) の場合`:"

#: ../../library/re.rst:270
msgid "Context of reference to group \"quote\""
msgstr "グループ \"quote\" を参照するコンテキスト"

#: ../../library/re.rst:270
msgid "Ways to reference it"
msgstr "参照方法"

#: ../../library/re.rst:272
msgid "in the same pattern itself"
msgstr "同一パターンへの参照"

#: ../../library/re.rst:272
msgid "``(?P=quote)`` (as shown)"
msgstr "``(?P=quote)`` (そのまま)"

#: ../../library/re.rst:273 ../../library/re.rst:280
msgid "``\\1``"
msgstr "``\\1``"

#: ../../library/re.rst:275
msgid "when processing match object *m*"
msgstr "マッチオブジェクト *m* の処理時"

#: ../../library/re.rst:275
msgid "``m.group('quote')``"
msgstr "``m.group('quote')``"

#: ../../library/re.rst:276
msgid "``m.end('quote')`` (etc.)"
msgstr "``m.end('quote')`` (etc.)"

#: ../../library/re.rst:278
msgid "in a string passed to the *repl* argument of ``re.sub()``"
msgstr "``re.sub()`` の *repl* 引数へ渡される文字列"

#: ../../library/re.rst:278
msgid "``\\g<quote>``"
msgstr "``\\g<quote>``"

#: ../../library/re.rst:279
msgid "``\\g<1>``"
msgstr "``\\g<1>``"

#: ../../library/re.rst:285
msgid "``(?P=name)``"
msgstr "``(?P=name)``"

#: ../../library/re.rst:284
msgid ""
"A backreference to a named group; it matches whatever text was matched by "
"the earlier group named *name*."
msgstr "名前付きグループへの後方参照です; 既出のグループ名 *name* にマッチする文字列は何にでもマッチします。"

#: ../../library/re.rst:288
msgid "``(?#...)``"
msgstr "``(?#...)``"

#: ../../library/re.rst:288
msgid "A comment; the contents of the parentheses are simply ignored."
msgstr "コメントです；括弧の内容は単純に無視されます。"

#: ../../library/re.rst:293
msgid "``(?=...)``"
msgstr "``(?=...)``"

#: ../../library/re.rst:291
msgid ""
"Matches if ``...`` matches next, but doesn't consume any of the string.  "
"This is called a :dfn:`lookahead assertion`.  For example, ``Isaac "
"(?=Asimov)`` will match ``'Isaac '`` only if it's followed by ``'Asimov'``."
msgstr ""
"``...`` が次に続くものとマッチすればマッチしますが、文字列をまったく消費しません。これは :dfn:`先読みアサーション (lookahead "
"assertion)` と呼ばれます。例えば、``Isaac (?=Asimov)`` は、``'Isaac '`` に ``'Asimov'`` "
"が続く場合だけ、``'Isaac '`` とマッチします。"

#: ../../library/re.rst:298
msgid "``(?!...)``"
msgstr "``(?!...)``"

#: ../../library/re.rst:296
msgid ""
"Matches if ``...`` doesn't match next.  This is a :dfn:`negative lookahead "
"assertion`. For example, ``Isaac (?!Asimov)`` will match ``'Isaac '`` only "
"if it's *not* followed by ``'Asimov'``."
msgstr ""
"``...`` が次に続くものとマッチしなければマッチします。これは :dfn:`否定先読みアサーション (negative lookahead "
"assertion)` です。例えば、``Isaac (?!Asimov)`` は、``'Isaac '`` に ``'Asimov'`` が続か "
"*ない* 場合のみマッチします。"

#: ../../library/re.rst:323
msgid "``(?<=...)``"
msgstr "``(?<=...)``"

#: ../../library/re.rst:301
msgid ""
"Matches if the current position in the string is preceded by a match for "
"``...`` that ends at the current position.  This is called a :dfn:`positive "
"lookbehind assertion`. ``(?<=abc)def`` will find a match in ``'abcdef'``, "
"since the lookbehind will back up 3 characters and check if the contained "
"pattern matches. The contained pattern must only match strings of some fixed"
" length, meaning that ``abc`` or ``a|b`` are allowed, but ``a*`` and "
"``a{3,4}`` are not.  Note that patterns which start with positive lookbehind"
" assertions will not match at the beginning of the string being searched; "
"you will most likely want to use the :func:`search` function rather than the"
" :func:`match` function:"
msgstr ""
"文字列内の現在位置の前に、現在位置で終わる ``...`` とのマッチがあれば、マッチします。これは :dfn:`後読みアサーション` "
"と呼ばれます。``(?<=abc)def`` は ``'abcdef'`` にマッチを見つけます。後読みは 3 "
"文字をバックアップし、含まれているパターンとマッチするかどうか検査します。含まれるパターンは、固定長の文字列にのみマッチしなければなりません。すなわち、``abc``"
" や ``a|b`` は許されますが、``a*`` や ``a{3,4}`` "
"は許されません。肯定後読みアサーションで始まるパターンは、検索される文字列の先頭とは決してマッチしないことに注意して下さい; "
"この表現を使用するのは、おそらく :func:`match` 関数より :func:`search` 関数の方が適しています:"

#: ../../library/re.rst:316
msgid "This example looks for a word following a hyphen:"
msgstr "この例ではハイフンに続く単語を探します:"

#: ../../library/re.rst:322
msgid "Added support for group references of fixed length."
msgstr "固定長のグループ参照をサポートするようになりました。"

#: ../../library/re.rst:330
msgid "``(?<!...)``"
msgstr "``(?<!...)``"

#: ../../library/re.rst:326
msgid ""
"Matches if the current position in the string is not preceded by a match for"
" ``...``.  This is called a :dfn:`negative lookbehind assertion`.  Similar "
"to positive lookbehind assertions, the contained pattern must only match "
"strings of some fixed length.  Patterns which start with negative lookbehind"
" assertions may match at the beginning of the string being searched."
msgstr ""
"文字列内の現在位置の前に ``...`` とのマッチがない場合に、マッチします。これは :dfn:`否定後読みアサーション(negative "
"lookbehind assertion)` "
"と呼ばれます。肯定後読みアサーションと同様に、含まれるパターンは固定長さの文字列だけにマッチしなければなりません。否定後読みアサーションで始まるパターンは、検索される文字列の先頭とマッチできます。"

#: ../../library/re.rst:339
msgid "``(?(id/name)yes-pattern|no-pattern)``"
msgstr "``(?(id/name)yes-pattern|no-pattern)``"

#: ../../library/re.rst:333
msgid ""
"Will try to match with ``yes-pattern`` if the group with given *id* or "
"*name* exists, and with ``no-pattern`` if it doesn't. ``no-pattern`` is "
"optional and can be omitted. For example, "
"``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>|$)`` is a poor email matching pattern, "
"which will match with ``'<user@host.com>'`` as well as ``'user@host.com'``, "
"but not with ``'<user@host.com'`` nor ``'user@host.com>'``."
msgstr ""
"与えられたグループ *id* あるいは *name* が存在する場合、``yes-pattern`` とのマッチを、存在しない場合 ``no-"
"pattern`` とのマッチを試みます。``no-pattern`` "
"は省略可能です。例えば、``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>|$)`` は貧弱な E-mail "
"マッチングパターンで、``'<user@host.com>'`` や ``'user@host.com'`` "
"にマッチしますが、``'<user@host.com'`` や ``'user@host.com>'`` とはマッチしません。"

#: ../../library/re.rst:341
msgid ""
"The special sequences consist of ``'\\'`` and a character from the list "
"below. If the ordinary character is not an ASCII digit or an ASCII letter, "
"then the resulting RE will match the second character.  For example, ``\\$``"
" matches the character ``'$'``."
msgstr ""
"特殊シーケンスは ``'\\'`` と以下のリストの文字から構成されます。\n"
"ASCII の数値や ASCII の文字でない通常の文字の場合、 RE は 2 番目の文字とマッチします。\n"
"例えば、``\\$`` は文字 ``'$'`` とマッチします。"

#: ../../library/re.rst:354
msgid "``\\number``"
msgstr "``\\number``"

#: ../../library/re.rst:347
msgid ""
"Matches the contents of the group of the same number.  Groups are numbered "
"starting from 1.  For example, ``(.+) \\1`` matches ``'the the'`` or ``'55 "
"55'``, but not ``'thethe'`` (note the space after the group).  This special "
"sequence can only be used to match one of the first 99 groups.  If the first"
" digit of *number* is 0, or *number* is 3 octal digits long, it will not be "
"interpreted as a group match, but as the character with octal value "
"*number*. Inside the ``'['`` and ``']'`` of a character class, all numeric "
"escapes are treated as characters."
msgstr ""
"同じ番号のグループの中身とマッチします。グループは1から始まる番号をつけられます。例えば、 ``(.+) \\1`` は、 ``'the the'`` "
"あるいは ``'55 55'`` とマッチしますが、 ``'thethe'`` "
"とはマッチしません(グループの後のスペースに注意して下さい)。この特殊シーケンスは最初の 99 "
"グループのうちの一つとマッチするのに使うことができるだけです。もし *number* の最初の桁が 0 である、すなわち *number* が 3 "
"桁の8進数であれば、それはグループのマッチとは解釈されず、 8進数値 *number* を持つ文字として解釈されます。文字クラスの ``'['`` と "
"``']'`` の中の数値エスケープは、文字として扱われます。"

#: ../../library/re.rst:357
msgid "``\\A``"
msgstr "``\\A``"

#: ../../library/re.rst:357
msgid "Matches only at the start of the string."
msgstr "文字列の先頭だけにマッチします。"

#: ../../library/re.rst:371
msgid "``\\b``"
msgstr "``\\b``"

#: ../../library/re.rst:360
msgid ""
"Matches the empty string, but only at the beginning or end of a word. A word"
" is defined as a sequence of word characters.  Note that formally, ``\\b`` "
"is defined as the boundary between a ``\\w`` and a ``\\W`` character (or "
"vice versa), or between ``\\w`` and the beginning/end of the string. This "
"means that ``r'\\bfoo\\b'`` matches ``'foo'``, ``'foo.'``, ``'(foo)'``, "
"``'bar foo baz'`` but not ``'foobar'`` or ``'foo3'``."
msgstr ""
"空文字列とマッチしますが、単語の先頭か末尾の時だけです。\n"
"単語とは単語文字の並びとして定義されます。\n"
"形式的に記述すると、 ``\\b`` は ``\\w`` 文字および ``\\W`` 文字の間 (およびその逆)、あるいは ``\\w`` と文字列の開始/終了との間の境界として定義されています。\n"
"例えば、``r'\\bfoo\\b'`` は ``'foo'`` , ``'foo.'`` , ``'(foo)'``, ``'bar foo baz'`` にマッチしますが、``'foobar'``, ``'foo3'`` にはマッチしません。"

#: ../../library/re.rst:367
msgid ""
"By default Unicode alphanumerics are the ones used in Unicode patterns, but "
"this can be changed by using the :const:`ASCII` flag.  Word boundaries are "
"determined by the current locale if the :const:`LOCALE` flag is used. Inside"
" a character range, ``\\b`` represents the backspace character, for "
"compatibility with Python's string literals."
msgstr ""

#: ../../library/re.rst:380
msgid "``\\B``"
msgstr "``\\B``"

#: ../../library/re.rst:374
msgid ""
"Matches the empty string, but only when it is *not* at the beginning or end "
"of a word.  This means that ``r'py\\B'`` matches ``'python'``, ``'py3'``, "
"``'py2'``, but not ``'py'``, ``'py.'``, or ``'py!'``. ``\\B`` is just the "
"opposite of ``\\b``, so word characters in Unicode patterns are Unicode "
"alphanumerics or the underscore, although this can be changed by using the "
":const:`ASCII` flag.  Word boundaries are determined by the current locale "
"if the :const:`LOCALE` flag is used."
msgstr ""

#: ../../library/re.rst:392
msgid "``\\d``"
msgstr "``\\d``"

#: ../../library/re.rst:389 ../../library/re.rst:409 ../../library/re.rst:429
msgid "For Unicode (str) patterns:"
msgstr "ユニコード (str) パターンに対して:"

#: ../../library/re.rst:384
msgid ""
"Matches any Unicode decimal digit (that is, any character in Unicode "
"character category [Nd]).  This includes ``[0-9]``, and also many other "
"digit characters.  If the :const:`ASCII` flag is used only ``[0-9]`` is "
"matched (but the flag affects the entire regular expression, so in such "
"cases using an explicit ``[0-9]`` may be a better choice)."
msgstr ""
"任意の Unicode 10進数 (Unicode 文字カテゴリ [Nd]) とマッチします。これには ``[0-9]`` とその他の 10 "
"進数文字が含まれます。:const:`ASCII` が使用された場合、``[0-9]`` "
"のみマッチします。ただし、このフラグは正規表現全体に作用しますので、明示的に ``[0-9]`` と指定する方が良い場合があるかもしれません。"

#: ../../library/re.rst:392 ../../library/re.rst:413 ../../library/re.rst:435
msgid "For 8-bit (bytes) patterns:"
msgstr "8bit (bytes) パターンに対して:"

#: ../../library/re.rst:392
msgid "Matches any decimal digit; this is equivalent to ``[0-9]``."
msgstr "任意の 10 進数にマッチします; これは ``[0-9]`` と等価です。"

#: ../../library/re.rst:399
msgid "``\\D``"
msgstr "``\\D``"

#: ../../library/re.rst:395
msgid ""
"Matches any character which is not a decimal digit. This is the opposite of "
"``\\d``. If the :const:`ASCII` flag is used this becomes the equivalent of "
"``[^0-9]`` (but the flag affects the entire regular expression, so in such "
"cases using an explicit ``[^0-9]`` may be a better choice)."
msgstr ""
"任意の非 10 進数文字にマッチします。これは ``\\d`` の反対です。:const:`ASCII` フラグを使用すると ``[^0-9]`` "
"と等価になります (ただし、このフラグは正規表現全体に作用しますので、明示的に ``[^0-9]`` と指定する方が良いでしょう)。"

#: ../../library/re.rst:413
msgid "``\\s``"
msgstr "``\\s``"

#: ../../library/re.rst:403
msgid ""
"Matches Unicode whitespace characters (which includes ``[ "
"\\t\\n\\r\\f\\v]``, and also many other characters, for example the non-"
"breaking spaces mandated by typography rules in many languages). If the "
":const:`ASCII` flag is used, only ``[ \\t\\n\\r\\f\\v]`` is matched (but the"
" flag affects the entire regular expression, so in such cases using an "
"explicit ``[ \\t\\n\\r\\f\\v]`` may be a better choice)."
msgstr ""
"任意の空白文字とマッチします。これには ``[ \\t\\n\\r\\f\\v]`` "
"およびノーブレークスペースなど、多くの言語におけるタイポグラフィ規則で定義された文字が含まれます。:const:`ASCII` "
"フラグを使用すると、``[ \\t\\n\\r\\f\\v]`` のみにマッチします。ただし、このフラグは正規表現全体に作用しますので、明示的に ``["
" \\t\\n\\r\\f\\v]`` と指定する方が良い場合があるかもしれません。"

#: ../../library/re.rst:412
msgid ""
"Matches characters considered whitespace in the ASCII character set; this is"
" equivalent to ``[ \\t\\n\\r\\f\\v]``."
msgstr "ASCII 文字セットにおける空白文字とマッチします。これは ``[ \\t\\n\\r\\f\\v]`` と等価です。"

#: ../../library/re.rst:420
msgid "``\\S``"
msgstr "``\\S``"

#: ../../library/re.rst:416
msgid ""
"Matches any character which is not a whitespace character. This is the "
"opposite of ``\\s``. If the :const:`ASCII` flag is used this becomes the "
"equivalent of ``[^ \\t\\n\\r\\f\\v]`` (but the flag affects the entire "
"regular expression, so in such cases using an explicit ``[^ "
"\\t\\n\\r\\f\\v]`` may be a better choice)."
msgstr ""
"任意の非空白文字にマッチします。これは ``\\s`` の反対です。:const:`ASCII` フラグを使用すると ``[^ "
"\\t\\n\\r\\f\\v]`` と等価になります (ただし、このフラグは正規表現全体に作用しますので、明示的に ``[^ "
"\\t\\n\\r\\f\\v]`` と指定する方が良いでしょう)。"

#: ../../library/re.rst:435
msgid "``\\w``"
msgstr "``\\w``"

#: ../../library/re.rst:424
msgid ""
"Matches Unicode word characters; this includes most characters that can be "
"part of a word in any language, as well as numbers and the underscore. If "
"the :const:`ASCII` flag is used, only ``[a-zA-Z0-9_]`` is matched (but the "
"flag affects the entire regular expression, so in such cases using an "
"explicit ``[a-zA-Z0-9_]`` may be a better choice)."
msgstr ""
"任意の Unicode "
"単語文字にマッチします。これにはあらゆる言語で単語の一部になりうる文字、数字、およびアンダースコアが含まれます。:const:`ASCII` "
"フラグを使用すると ``[a-zA-Z0-9_]`` のみにマッチします。ただし、このフラグは正規表現全体に作用しますので、明示的に "
"``[a-zA-Z0-9_]`` と指定する方が良い場合があるかもしれません。"

#: ../../library/re.rst:432
msgid ""
"Matches characters considered alphanumeric in the ASCII character set; this "
"is equivalent to ``[a-zA-Z0-9_]``.  If the :const:`LOCALE` flag is used, "
"matches characters considered alphanumeric in the current locale and the "
"underscore."
msgstr ""
"ASCII 文字セットでの英数字とアンダースコアにマッチします。これは ``[a-zA-Z0-9_]`` と等価です。\n"
":const:`LOCALE` が使われている場合は、現在のロケールで英数字と見なせる文字とアンダースコアにマッチします。"

#: ../../library/re.rst:444
msgid "``\\W``"
msgstr "``\\W``"

#: ../../library/re.rst:438
msgid ""
"Matches any character which is not a word character. This is the opposite of"
" ``\\w``. If the :const:`ASCII` flag is used this becomes the equivalent of "
"``[^a-zA-Z0-9_]`` (but the flag affects the entire regular expression, so in"
" such cases using an explicit ``[^a-zA-Z0-9_]`` may be a better choice).  If"
" the :const:`LOCALE` flag is used, matches characters considered "
"alphanumeric in the current locale and the underscore."
msgstr ""
"任意の非単語文字にマッチします。これは ``\\w`` の反対です。:const:`ASCII` フラグを使用した場合、``[^a-zA-Z0-9_]`` と等価になります (ただし、このフラグは正規表現全体に作用しますので、明示的に ``[^a-zA-Z0-9_]`` と指定する方が良い場合があるかもしれません)。\n"
":const:`LOCALE` が使われている場合は、現在のロケールで英数字と見なせる文字とアンダースコアにマッチします。"

#: ../../library/re.rst:447
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../../library/re.rst:447
msgid "Matches only at the end of the string."
msgstr "文字列の末尾とのみマッチします。"

#: ../../library/re.rst:449
msgid ""
"Most of the standard escapes supported by Python string literals are also "
"accepted by the regular expression parser::"
msgstr "Python 文字列リテラルによってサポートされている標準エスケープのほとんども、正規表現パーザによって認識されます::"

#: ../../library/re.rst:456
msgid ""
"(Note that ``\\b`` is used to represent word boundaries, and means "
"\"backspace\" only inside character classes.)"
msgstr "(``\\b`` は単語の境界を表し、文字クラス内でのみ後退 (backspace) 文字を指すことに注意してください)"

#: ../../library/re.rst:459
msgid ""
"``'\\u'`` and ``'\\U'`` escape sequences are only recognized in Unicode "
"patterns.  In bytes patterns they are errors."
msgstr ""
"``'\\u'`` および ``'\\U'`` エスケープシーケンスは Unicode パターン内でのみ認識されます。バイト列ではエラーとなります。"

#: ../../library/re.rst:462
msgid ""
"Octal escapes are included in a limited form.  If the first digit is a 0, or"
" if there are three octal digits, it is considered an octal escape. "
"Otherwise, it is a group reference.  As for string literals, octal escapes "
"are always at most three digits in length."
msgstr ""
"8 進数エスケープは限られた形式で表します。最初の桁が 0 か、あるいは 3 桁の 8 進数ならば、8 "
"進数エスケープとみなされます。それ以外の場合はグループ参照になります。文字列リテラルに関しては、8 進数エスケープはほとんどの場合 3 桁長になります。"

#: ../../library/re.rst:467
msgid "The ``'\\u'`` and ``'\\U'`` escape sequences have been added."
msgstr "``'\\u'`` と ``'\\U'`` エスケープシーケンスが追加されました。"

#: ../../library/re.rst:470
msgid ""
"Unknown escapes consisting of ``'\\'`` and an ASCII letter now are errors."
msgstr "``'\\'`` と ASCII 文字からなる未知のエスケープはエラーになります。"

#: ../../library/re.rst:478
msgid "Mastering Regular Expressions"
msgstr "Mastering Regular Expressions 詳説正規表現"

#: ../../library/re.rst:477
msgid ""
"Book on regular expressions by Jeffrey Friedl, published by O'Reilly.  The "
"second edition of the book no longer covers Python at all, but the first "
"edition covered writing good regular expression patterns in great detail."
msgstr ""
"Jeffrey Friedl 著、O'Reilly 刊の正規表現に関する本です。この本の第2版\\ "
"ではPyhonについては触れていませんが、良い正規表現パターンの書き方を非常に\\ くわしく説明しています。"

#: ../../library/re.rst:486
msgid "Module Contents"
msgstr "モジュールコンテンツ"

#: ../../library/re.rst:488
msgid ""
"The module defines several functions, constants, and an exception. Some of "
"the functions are simplified versions of the full featured methods for "
"compiled regular expressions.  Most non-trivial applications always use the "
"compiled form."
msgstr ""
"このモジュールはいくつかの関数、定数、例外を定義します。この関数の一部はコンパイルした正規表現の完全版メソッドを簡略化したバージョンです。簡単なアプリケーションを除くほとんどで、コンパイルされた形式が用いられるのが普通です。"

#: ../../library/re.rst:493
msgid ""
"Flag constants are now instances of :class:`RegexFlag`, which is a subclass "
"of :class:`enum.IntFlag`."
msgstr ""
"フラグ定数は、:class:`enum.IntFlag` のサブクラスである :class:`RegexFlag` のインスタンスになりました、"

#: ../../library/re.rst:499
msgid ""
"Compile a regular expression pattern into a :ref:`regular expression object "
"<re-objects>`, which can be used for matching using its "
":func:`~regex.match`, :func:`~regex.search` and other methods, described "
"below."
msgstr ""
"正規表現パターンを :ref:`正規表現オブジェクト <re-objects>` にコンパイルします。このオブジェクトは、以下で述べる "
":func:`~regex.match` や :func:`~regex.search` や他のメソッドを使って、マッチングに使うことができます。"

#: ../../library/re.rst:504
msgid ""
"The expression's behaviour can be modified by specifying a *flags* value. "
"Values can be any of the following variables, combined using bitwise OR (the"
" ``|`` operator)."
msgstr ""
"式の動作は、 *flags* の値を指定することで加減することができます。値は以下の変数を、ビットごとの OR ( ``|`` "
"演算子)を使って組み合わせることができます。"

#: ../../library/re.rst:508
msgid "The sequence ::"
msgstr "シーケンス ::"

#: ../../library/re.rst:513
msgid "is equivalent to ::"
msgstr "は、以下と同等です ::"

#: ../../library/re.rst:517
msgid ""
"but using :func:`re.compile` and saving the resulting regular expression "
"object for reuse is more efficient when the expression will be used several "
"times in a single program."
msgstr ""
"ただし、その式を一つのプログラムで何回も使う場合には、 :func:`re.compile` "
"を使ってその結果の正規表現オブジェクトを再利用した方がより効率的です。"

#: ../../library/re.rst:523
msgid ""
"The compiled versions of the most recent patterns passed to "
":func:`re.compile` and the module-level matching functions are cached, so "
"programs that use only a few regular expressions at a time needn't worry "
"about compiling regular expressions."
msgstr ""
":func:`re.compile` "
"に渡されてコンパイルされた最新のパターンと、モジュールレベルのマッチング関数はキャッシュされるので、一度に少しの正規表現しか使わないプログラムは正規表現のコンパイルについて心配する必要はありません。"

#: ../../library/re.rst:532
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` and "
"``\\S`` perform ASCII-only matching instead of full Unicode matching.  This "
"is only meaningful for Unicode patterns, and is ignored for byte patterns. "
"Corresponds to the inline flag ``(?a)``."
msgstr ""
"``\\w``、``\\W``、``\\b``、``\\B``、``\\d``、``\\D``、``\\s``、および ``\\S`` において、ASCII 文字のみでマッチングを行います。これは Unicode パターンでのみ意味があり、バイト列パターンでは無視されます。\n"
"インラインフラグの ``(?a)`` に相当します。"

#: ../../library/re.rst:537
msgid ""
"Note that for backward compatibility, the :const:`re.U` flag still exists "
"(as well as its synonym :const:`re.UNICODE` and its embedded counterpart "
"``(?u)``), but these are redundant in Python 3 since matches are Unicode by "
"default for strings (and Unicode matching isn't allowed for bytes)."
msgstr ""
"後方互換性のため、:const:`re.U` フラグ (およびそれと同義の :const:`re.UNICODE` と埋め込みで使用する "
"``(?u)``) はまだ存在していますが、文字列のマッチのデフォルトが Unicode になった Python 3 では冗長です (そして "
"Unicode マッチングではバイト列は扱えません)。"

#: ../../library/re.rst:546
msgid ""
"Display debug information about compiled expression. No corresponding inline"
" flag."
msgstr ""
"コンパイルした表現に関するデバッグ情報を出力します。\n"
"相当するインラインフラグはありません。"

#: ../../library/re.rst:553
msgid ""
"Perform case-insensitive matching; expressions like ``[A-Z]`` will also "
"match lowercase letters.  Full Unicode matching (such as ``Ü`` matching "
"``ü``) also works unless the :const:`re.ASCII` flag is used to disable non-"
"ASCII matches.  The current locale does not change the effect of this flag "
"unless the :const:`re.LOCALE` flag is also used. Corresponds to the inline "
"flag ``(?i)``."
msgstr ""

#: ../../library/re.rst:560
msgid ""
"Note that when the Unicode patterns ``[a-z]`` or ``[A-Z]`` are used in "
"combination with the :const:`IGNORECASE` flag, they will match the 52 ASCII "
"letters and 4 additional non-ASCII letters: 'İ' (U+0130, Latin capital "
"letter I with dot above), 'ı' (U+0131, Latin small letter dotless i), 'ſ' "
"(U+017F, Latin small letter long s) and 'K' (U+212A, Kelvin sign). If the "
":const:`ASCII` flag is used, only letters 'a' to 'z' and 'A' to 'Z' are "
"matched (but the flag affects the entire regular expression, so in such "
"cases using an explicit ``(?-i:[a-zA-Z])`` may be a better choice)."
msgstr ""

#: ../../library/re.rst:573
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale.  This flag can be used only with bytes "
"patterns.  The use of this flag is discouraged as the locale mechanism is "
"very unreliable, it only handles one \"culture\" at a time, and it only "
"works with 8-bit locales.  Unicode matching is already enabled by default in"
" Python 3 for Unicode (str) patterns, and it is able to handle different "
"locales/languages. Corresponds to the inline flag ``(?L)``."
msgstr ""

#: ../../library/re.rst:582
msgid ""
":const:`re.LOCALE` can be used only with bytes patterns and is not "
"compatible with :const:`re.ASCII`."
msgstr ":const:`re.LOCALE` バイト列のパターンにのみ利用できます。:const:`re.ASCII` とは同時に指定できません。"

#: ../../library/re.rst:590
msgid ""
"When specified, the pattern character ``'^'`` matches at the beginning of "
"the string and at the beginning of each line (immediately following each "
"newline); and the pattern character ``'$'`` matches at the end of the string"
" and at the end of each line (immediately preceding each newline).  By "
"default, ``'^'`` matches only at the beginning of the string, and ``'$'`` "
"only at the end of the string and immediately before the newline (if any) at"
" the end of the string. Corresponds to the inline flag ``(?m)``."
msgstr ""

#: ../../library/re.rst:602
msgid ""
"Make the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline. "
"Corresponds to the inline flag ``(?s)``."
msgstr ""
"特殊文字 ``'.'`` を、改行を含むどんな文字にもマッチさせます; このフラグがなければ、``'.'`` は、改行 *以外の* 任意の文字とマッチします。\n"
"インラインフラグの ``(?s)`` に相当します。"

#: ../../library/re.rst:610
msgid ""
"This flag allows you to write regular expressions that look nicer and are "
"more readable by allowing you to visually separate logical sections of the "
"pattern and add comments. Whitespace within the pattern is ignored, except "
"when in a character class, or when preceded by an unescaped backslash, or "
"within tokens like ``*?``, ``(?:`` or ``(?P<...>``. When a line contains a "
"``#`` that is not in a character class and is not preceded by an unescaped "
"backslash, all characters from the leftmost such ``#`` through the end of "
"the line are ignored."
msgstr ""

#: ../../library/re.rst:619
msgid ""
"This means that the two following regular expression objects that match a "
"decimal number are functionally equal::"
msgstr "つまり、数字にマッチする下記のふたつの正規表現オブジェクトは、機能的に等価です。::"

#: ../../library/re.rst:627
msgid "Corresponds to the inline flag ``(?x)``."
msgstr "インラインフラグの ``(?x)`` に相当します。"

#: ../../library/re.rst:632
msgid ""
"Scan through *string* looking for the first location where the regular "
"expression *pattern* produces a match, and return a corresponding "
":ref:`match object <match-objects>`.  Return ``None`` if no position in the "
"string matches the pattern; note that this is different from finding a zero-"
"length match at some point in the string."
msgstr ""
"*string* を走査し、正規表現 *pattern* がマッチする最初の場所を探して、対応する :ref:`match オブジェクト <match-"
"objects>` を返します。文字列内にパターンにマッチする場所が無い場合は ``None`` を返します; これは文字列内のある場所で長さが 0 "
"のマッチが見つかった場合とは異なることに注意してください。"

#: ../../library/re.rst:641
msgid ""
"If zero or more characters at the beginning of *string* match the regular "
"expression *pattern*, return a corresponding :ref:`match object <match-"
"objects>`.  Return ``None`` if the string does not match the pattern; note "
"that this is different from a zero-length match."
msgstr ""
"もし *string* の先頭で 0 個以上の文字が正規表現 *pattern* とマッチすれば、対応する :ref:`マッチオブジェクト "
"<match-objects>` インスタンスを返します。文字列がパターンとマッチしなければ、``None`` を返します; "
"これは長さゼロのマッチとは異なることに注意して下さい。"

#: ../../library/re.rst:646
msgid ""
"Note that even in :const:`MULTILINE` mode, :func:`re.match` will only match "
"at the beginning of the string and not at the beginning of each line."
msgstr ""
":const:`MULTILINE` モードであっても、:func:`re.match` "
"は文字列の先頭のみにマッチし、各行の先頭にはマッチしないことに注意してください。"

#: ../../library/re.rst:649
msgid ""
"If you want to locate a match anywhere in *string*, use :func:`search` "
"instead (see also :ref:`search-vs-match`)."
msgstr ""
"*string* 内のどこでもマッチできるようにするには、代わりに :func:`search` を使ってください (:ref:`search-vs-"
"match` も参照してください)。"

#: ../../library/re.rst:655
msgid ""
"If the whole *string* matches the regular expression *pattern*, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if the "
"string does not match the pattern; note that this is different from a zero-"
"length match."
msgstr ""
"*string* 全体が正規表現 *pattern* にマッチした場合、対応する :ref:`match オブジェクト <match-objects>`"
" を返します。文字列にパターンにマッチする場所が無い場合は ``None`` を返します; これは長さが 0 "
"のマッチとは違うということを注意しておきます。"

#: ../../library/re.rst:665
msgid ""
"Split *string* by the occurrences of *pattern*.  If capturing parentheses "
"are used in *pattern*, then the text of all groups in the pattern are also "
"returned as part of the resulting list. If *maxsplit* is nonzero, at most "
"*maxsplit* splits occur, and the remainder of the string is returned as the "
"final element of the list. ::"
msgstr ""
"*string* を、*pattern* があるたびに分割します。キャプチャグループの丸括弧が *pattern* "
"で使われていれば、パターン内のすべてのグループのテキストも結果のリストの一部として返されます。*maxsplit* がゼロでなければ、最大 "
"*maxsplit* 個の分割が発生し、残りはリストの最終要素として返されます。 ::"

#: ../../library/re.rst:680
msgid ""
"If there are capturing groups in the separator and it matches at the start "
"of the string, the result will start with an empty string.  The same holds "
"for the end of the string::"
msgstr ""

#: ../../library/re.rst:687
msgid ""
"That way, separator components are always found at the same relative indices"
" within the result list."
msgstr "その場合、常に、分割要素が、分割結果のリストの相対的なインデックスに現れます。"

#: ../../library/re.rst:692
msgid ""
":func:`split` doesn't currently split a string on an empty pattern match. "
"For example::"
msgstr "現在、:func:`split` は空のパターンマッチでは文字列を分割しません。例えば、次のようになります::"

#: ../../library/re.rst:698
msgid ""
"Even though ``'x*'`` also matches 0 'x' before 'a', between 'b' and 'c', and"
" after 'c', currently these matches are ignored.  The correct behavior (i.e."
" splitting on empty matches too and returning ``['', 'a', 'b', 'c', '']``) "
"will be implemented in future versions of Python, but since this is a "
"backward incompatible change, a :exc:`FutureWarning` will be raised in the "
"meanwhile."
msgstr ""
"``'x*'`` は 'a' の前、 'b' と 'c' との間、 'c' の後の 0 個の 'x' "
"にもマッチしますが、現在これらのマッチは無視されます。正しい動作 (空のマッチでも文字列を分割し、``['', 'a', 'b', 'c', '']``"
" を返す) は、Python の将来のバージョンで実装されます。これは、後方互換生のない変更であるため、移行期間中は "
":exc:`FutureWarning` が送出されます。"

#: ../../library/re.rst:705
msgid ""
"Patterns that can only match empty strings currently never split the string."
"  Since this doesn't match the expected behavior, a :exc:`ValueError` will "
"be raised starting from Python 3.5::"
msgstr ""
"空の文字列のみとマッチするパターンは、現在文字列を全く分割しません。これは望ましい動作ではないため、Python 3.5 から "
":exc:`ValueError` が送出されます::"

#: ../../library/re.rst:715 ../../library/re.rst:787 ../../library/re.rst:807
msgid "Added the optional flags argument."
msgstr "オプションの flags 引数が追加されました。"

#: ../../library/re.rst:718
msgid ""
"Splitting on a pattern that could match an empty string now raises a "
"warning.  Patterns that can only match empty strings are now rejected."
msgstr ""
"空の文字列にマッチするパターンによって分割しようとすると、警告が送出されるようになりました。空の文字列のみとマッチするパターンは拒否されるようになりました。"

#: ../../library/re.rst:724
msgid ""
"Return all non-overlapping matches of *pattern* in *string*, as a list of "
"strings.  The *string* is scanned left-to-right, and matches are returned in"
" the order found.  If one or more groups are present in the pattern, return "
"a list of groups; this will be a list of tuples if the pattern has more than"
" one group.  Empty matches are included in the result unless they touch the "
"beginning of another match."
msgstr ""
"*pattern* の *string* へのマッチのうち、重複しない全てのマッチを文字列のリストとして返します。 *string* "
"は左から右へと走査され、マッチは見つかった順番で返されます。パターン中に何らかのグループがある場合、グループのリストを返します。グループが複数定義されていた場合、タプルのリストになります。他のマッチの開始部分に接触しないかぎり、空のマッチも結果に含められます。"

#: ../../library/re.rst:734
msgid ""
"Return an :term:`iterator` yielding :ref:`match objects <match-objects>` "
"over all non-overlapping matches for the RE *pattern* in *string*.  The "
"*string* is scanned left-to-right, and matches are returned in the order "
"found.  Empty matches are included in the result unless they touch the "
"beginning of another match."
msgstr ""
"*string* 内の RE *pattern* の重複しないマッチの :ref:`マッチオブジェクト <match-objects>` を yield"
" する :term:`イテレータ <iterator>` を返します。*string* "
"は左から右へと走査され、マッチは見つかった順番で返されます。他のマッチの開始部分に接触しないかぎり、空のマッチも結果に含められます。"

#: ../../library/re.rst:743
msgid ""
"Return the string obtained by replacing the leftmost non-overlapping "
"occurrences of *pattern* in *string* by the replacement *repl*.  If the "
"pattern isn't found, *string* is returned unchanged.  *repl* can be a string"
" or a function; if it is a string, any backslash escapes in it are "
"processed.  That is, ``\\n`` is converted to a single newline character, "
"``\\r`` is converted to a carriage return, and so forth.  Unknown escapes "
"such as ``\\&`` are left alone.  Backreferences, such as ``\\6``, are "
"replaced with the substring matched by group 6 in the pattern. For example::"
msgstr ""

#: ../../library/re.rst:757
msgid ""
"If *repl* is a function, it is called for every non-overlapping occurrence "
"of *pattern*.  The function takes a single :ref:`match object <match-"
"objects>` argument, and returns the replacement string.  For example::"
msgstr ""
"もし *repl* が関数であれば、重複しない *pattern* が発生するたびにその関数が呼ばれます。この関数は一つの "
":ref:`マッチオブジェクト <match-objects>` 引数を取り、置換文字列を返します。例えば::"

#: ../../library/re.rst:769
msgid "The pattern may be a string or a :ref:`pattern object <re-objects>`."
msgstr "パターンは、文字列でも :ref:`パターンオブジェクト <re-objects>` でも構いません。"

#: ../../library/re.rst:771
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  If omitted or zero,"
" all occurrences will be replaced. Empty matches for the pattern are "
"replaced only when not adjacent to a previous match, so ``sub('x*', '-', "
"'abc')`` returns ``'-a-b-c-'``."
msgstr ""
"省略可能な引数 *count* は、置換されるパターンの出現回数の最大値です； *count* "
"は非負の整数でなければなりません。もし省略されるかゼロであれば、出現したものがすべて置換されます。パターンのマッチが空であれば、以前のマッチと隣合わせでない時だけ置換されますので、"
" ``sub('x*', '-', 'abc')`` は ``'-a-b-c-'`` を返します。"

#: ../../library/re.rst:777
msgid ""
"In string-type *repl* arguments, in addition to the character escapes and "
"backreferences described above, ``\\g<name>`` will use the substring matched"
" by the group named ``name``, as defined by the ``(?P<name>...)`` syntax. "
"``\\g<number>`` uses the corresponding group number; ``\\g<2>`` is therefore"
" equivalent to ``\\2``, but isn't ambiguous in a replacement such as "
"``\\g<2>0``.  ``\\20`` would be interpreted as a reference to group 20, not "
"a reference to group 2 followed by the literal character ``'0'``.  The "
"backreference ``\\g<0>`` substitutes in the entire substring matched by the "
"RE."
msgstr ""
"文字列タイプ *repl* 引数では、上で述べた文字エスケープや後方参照の他に、 ``\\g<name>`` は、 ``(?P<name>...)`` "
"シンタックスで定義された ``name`` グループによるマッチ部分文字列を使用することになりますし、 ``\\g<number>`` "
"は対応するグループ番号への参照となります; ``\\g<2>`` はつまり ``\\2`` と等価ですが、 ``\\g<2>0`` "
"のような置換においても曖昧になりません。 ``\\20`` は、グループ 20への参照として解釈され、グループ 2 にリテラル文字 ``'0'`` "
"が続いたものへの参照としては解釈されないかもしれません。後方参照 ``\\g<0>`` は、RE とマッチするサブ文字列全体を置き換えます。"

#: ../../library/re.rst:790 ../../library/re.rst:810 ../../library/re.rst:1030
msgid "Unmatched groups are replaced with an empty string."
msgstr "マッチしないグループは空文字列に置き換えられます。"

#: ../../library/re.rst:793
msgid ""
"Unknown escapes in *pattern* consisting of ``'\\'`` and an ASCII letter now "
"are errors."
msgstr "*pattern* 中に ``'\\'`` と ASCII 文字からなる未知のエスケープがあると、エラーになります。"

#: ../../library/re.rst:799
msgid ""
"Deprecated since version 3.5, will be removed in version 3.7: Unknown "
"escapes in repl consisting of '\\' and an ASCII letter now raise a "
"deprecation warning and will be forbidden in Python 3.7."
msgstr ""
"バージョン 3.5 で非推奨、バージョン 3.7 で削除予定。'\\' および ASCII "
"文字からなる未知のエスケープは、非推奨の警告を送出し、Python 3.7 では禁止されます。"

#: ../../library/re.rst:799
msgid ""
"Unknown escapes in *repl* consisting of ``'\\'`` and an ASCII letter now "
"raise a deprecation warning and will be forbidden in Python 3.7."
msgstr ""

#: ../../library/re.rst:804
msgid ""
"Perform the same operation as :func:`sub`, but return a tuple ``(new_string,"
" number_of_subs_made)``."
msgstr ""
":func:`sub` と同じ操作を行いますが、タプル ``(new_string、 number_of_subs_made)`` を返します。"

#: ../../library/re.rst:816
msgid ""
"Escape all the characters in *pattern* except ASCII letters, numbers and "
"``'_'``. This is useful if you want to match an arbitrary literal string "
"that may have regular expression metacharacters in it.  For example::"
msgstr ""
"*pattern* に含まれる、ASCII 文字、数字、および ``'_'`` を除くすべての文字をエスケープします。\n"
"これは、もしその中に正規表現のメタ文字を持つかもしれない任意のリテラル文字列とマッチしたい時に役立ちます。\n"
"例えば::"

#: ../../library/re.rst:831
msgid ""
"This functions must not be used for the replacement string in :func:`sub` "
"and :func:`subn`, only backslashes should be escaped.  For example::"
msgstr ""

#: ../../library/re.rst:839
msgid "The ``'_'`` character is no longer escaped."
msgstr "``'_'`` 文字がエスケープされなくなりました。"

#: ../../library/re.rst:845
msgid "Clear the regular expression cache."
msgstr "正規表現キャッシュをクリアします。"

#: ../../library/re.rst:850
msgid ""
"Exception raised when a string passed to one of the functions here is not a "
"valid regular expression (for example, it might contain unmatched "
"parentheses) or when some other error occurs during compilation or matching."
"  It is never an error if a string contains no match for a pattern.  The "
"error instance has the following additional attributes:"
msgstr ""
"これらの関数のいずれかに渡された文字列が有効な正規表現ではない (例: 括弧が対になっていない) "
"場合、またはコンパイル時やマッチング時になんらかのエラーが発生した場合に発生する例外です。文字列にパターンとマッチする部分がなくても、それはエラーではありません。エラーインスタンスには、次のような追加の属性があります。"

#: ../../library/re.rst:858
msgid "The unformatted error message."
msgstr "フォーマットされていないエラーメッセージです。"

#: ../../library/re.rst:862
msgid "The regular expression pattern."
msgstr "正規表現のパターンです。"

#: ../../library/re.rst:866
msgid "The index in *pattern* where compilation failed (may be ``None``)."
msgstr "*pattern* のコンパイルに失敗した場所のインデックスです (``None`` の場合もあります)。"

#: ../../library/re.rst:870
msgid "The line corresponding to *pos* (may be ``None``)."
msgstr "*pos* に対応する行です (``None`` の場合もあります)。"

#: ../../library/re.rst:874
msgid "The column corresponding to *pos* (may be ``None``)."
msgstr "*pos* に対応する列です (``None`` の場合もあります)。"

#: ../../library/re.rst:876
msgid "Added additional attributes."
msgstr "追加の属性が追加されました。"

#: ../../library/re.rst:882
msgid "Regular Expression Objects"
msgstr "正規表現オブジェクト"

#: ../../library/re.rst:884
msgid ""
"Compiled regular expression objects support the following methods and "
"attributes:"
msgstr "コンパイル済み正規表現オブジェクトは以下のメソッドと属性をサポートします:"

#: ../../library/re.rst:889
msgid ""
"Scan through *string* looking for the first location where this regular "
"expression produces a match, and return a corresponding :ref:`match object "
"<match-objects>`.  Return ``None`` if no position in the string matches the "
"pattern; note that this is different from finding a zero-length match at "
"some point in the string."
msgstr ""
"*string* を走査し、正規表現がマッチする最初の場所を探して、対応する :ref:`match オブジェクト <match-objects>` "
"を返します。文字列内にパターンにマッチする場所がない場合は ``None`` を返します; これは文字列内のある場所で長さが 0 "
"のマッチが見つかった場合とは異なることに注意してください。"

#: ../../library/re.rst:895
msgid ""
"The optional second parameter *pos* gives an index in the string where the "
"search is to start; it defaults to ``0``.  This is not completely equivalent"
" to slicing the string; the ``'^'`` pattern character matches at the real "
"beginning of the string and at positions just after a newline, but not "
"necessarily at the index where the search is to start."
msgstr ""
"省略可能な、2つ目の引数 *pos* は、 string のどこから探し始めるかを指定する index で、デフォルトでは 0 "
"です。これは、文字列をスライスしてから検索するのと、完全には同じではありません。パターン文字 ``'^'`` "
"は本当の文字列の先頭と、改行の直後にマッチしますが、検索を開始する index がマッチするとは限りません。"

#: ../../library/re.rst:901
msgid ""
"The optional parameter *endpos* limits how far the string will be searched; "
"it will be as if the string is *endpos* characters long, so only the "
"characters from *pos* to ``endpos - 1`` will be searched for a match.  If "
"*endpos* is less than *pos*, no match will be found; otherwise, if *rx* is a"
" compiled regular expression object, ``rx.search(string, 0, 50)`` is "
"equivalent to ``rx.search(string[:50], 0)``. ::"
msgstr ""
"オプションの引数 *endpos* は文字列の検索範囲を制限します。\n"
"これは文字列の長さが *endpos* 文字だった場合と同じとみなし、*pos* から ``endpos - 1`` の範囲の文字に対してマッチを探します。\n"
"*endpos* が *pos* よりも小さい場合は、マッチは見つかりません;\n"
"それ以外の場合は、*rx* をコンパイルされた正規表現だとして、``rx.search(string, 0, 50)`` は ``rx.search(string[:50], 0)`` と等価です。::"

#: ../../library/re.rst:916
msgid ""
"If zero or more characters at the *beginning* of *string* match this regular"
" expression, return a corresponding :ref:`match object <match-objects>`. "
"Return ``None`` if the string does not match the pattern; note that this is "
"different from a zero-length match."
msgstr ""
"*string* の *先頭の* 0 個以上の文字がこの正規表現とマッチする場合、対応する :ref:`マッチオブジェクト <match-"
"objects>` を返します。文字列がパタンーとマッチしない場合、``None`` "
"を返します。これは長さゼロのマッチとは異なることに注意してください。"

#: ../../library/re.rst:921 ../../library/re.rst:939
msgid ""
"The optional *pos* and *endpos* parameters have the same meaning as for the "
":meth:`~regex.search` method. ::"
msgstr ""
"オプションの引数 *pos* と *endpos* 引数は、 :meth:`~regex.search` メソッドと同じ意味を持ちます。::"

#: ../../library/re.rst:929
msgid ""
"If you want to locate a match anywhere in *string*, use "
":meth:`~regex.search` instead (see also :ref:`search-vs-match`)."
msgstr ""
"*string* 内のどこでもマッチできるようにするには、代わりに :meth:`~regex.search` を使ってください (:ref"
":`search-vs-match` も参照してください)。"

#: ../../library/re.rst:935
msgid ""
"If the whole *string* matches this regular expression, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if the "
"string does not match the pattern; note that this is different from a zero-"
"length match."
msgstr ""
"*string* 全体がこの正規表現にマッチした場合、対応する :ref:`match オブジェクト <match-objects>` "
"を返します。文字列にパターンにマッチする場所が無い場合は ``None`` を返します; これは長さが 0 "
"のマッチとは違うということを注意しておきます。"

#: ../../library/re.rst:953
msgid "Identical to the :func:`split` function, using the compiled pattern."
msgstr ""
":func:`split` 関数と同様で、コンパイルしたパターンを使います。ただし、 :meth:`match` と同じように、省略可能な *pos*,"
" *endpos* 引数で検索範囲を指定することができます。"

#: ../../library/re.rst:958
msgid ""
"Similar to the :func:`findall` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""
":func:`findall` 関数と同じく、コンパイルしたパターンを使います。\n"
"ただし、 :meth:`search` と同じように、オプションの引数の *pos* と *endpos* で検索範囲を制限できます。"

#: ../../library/re.rst:965
msgid ""
"Similar to the :func:`finditer` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""
":func:`finditer` 関数と同じく、コンパイルしたパターンを使います。\n"
"ただし、 :meth:`search` と同じように、オプションの引数の *pos* と *endpos* で検索範囲を制限できます。"

#: ../../library/re.rst:972
msgid "Identical to the :func:`sub` function, using the compiled pattern."
msgstr ":func:`sub` 関数と同様で、コンパイルしたパターンを使います。"

#: ../../library/re.rst:977
msgid "Identical to the :func:`subn` function, using the compiled pattern."
msgstr ":func:`subn` 関数と同様で、コンパイルしたパターンを使います。"

#: ../../library/re.rst:982
msgid ""
"The regex matching flags.  This is a combination of the flags given to "
":func:`.compile`, any ``(?...)`` inline flags in the pattern, and implicit "
"flags such as :data:`UNICODE` if the pattern is a Unicode string."
msgstr ""
"正規表現のマッチングフラグです。これは :func:`.compile` で指定されたフラグ、パターン内の ``(?...)`` "
"インラインフラグ、およびパターンが Unicode 文字列だった時の :data:`UNICODE` のような暗黙のフラグとの組み合わせになりなす。"

#: ../../library/re.rst:989
msgid "The number of capturing groups in the pattern."
msgstr "パターンにあるキャプチャグループの数です。"

#: ../../library/re.rst:994
msgid ""
"A dictionary mapping any symbolic group names defined by ``(?P<id>)`` to "
"group numbers.  The dictionary is empty if no symbolic groups were used in "
"the pattern."
msgstr ""
"``(?P<id>)`` "
"で定義された任意の記号グループ名の、グループ番号への辞書マッピングです。もし記号グループがパターン内で何も使われていなければ、辞書は空です。"

#: ../../library/re.rst:1001
msgid "The pattern string from which the RE object was compiled."
msgstr "RE オブジェクトがコンパイルされたときに使用された元のパターン文字列です。"

#: ../../library/re.rst:1007
msgid "Match Objects"
msgstr "match オブジェクト"

#: ../../library/re.rst:1009
msgid ""
"Match objects always have a boolean value of ``True``. Since "
":meth:`~regex.match` and :meth:`~regex.search` return ``None`` when there is"
" no match, you can test whether there was a match with a simple ``if`` "
"statement::"
msgstr ""
"マッチオブジェクトは常にブール値 ``True`` を持ちます。 :meth:`~regex.match` と "
":meth:`~regex.search` はマッチしなかった場合に ``None`` を返すので、単純な ``if`` "
"ステートメントによってマッチしたかどうかをテストできます::"

#: ../../library/re.rst:1018
msgid "Match objects support the following methods and attributes:"
msgstr "マッチオブジェクトは以下のメソッドと属性をサポートしています:"

#: ../../library/re.rst:1023
msgid ""
"Return the string obtained by doing backslash substitution on the template "
"string *template*, as done by the :meth:`~regex.sub` method. Escapes such as"
" ``\\n`` are converted to the appropriate characters, and numeric "
"backreferences (``\\1``, ``\\2``) and named backreferences (``\\g<1>``, "
"``\\g<name>``) are replaced by the contents of the corresponding group."
msgstr ""
"テンプレート文字列 *template* に対し、:meth:`~regex.sub` "
"メソッドがするようなバックスラッシュ置換をして得られる文字列を返します。``\\n`` のようなエスケープは適切な文字に変換され、数値の後方参照 "
"(``\\1``, ``\\2``) と名前付きの後方参照 (``\\g<1>``, ``\\g<name>``) "
"は、対応するグループの内容で置き換えられます。"

#: ../../library/re.rst:1035
msgid ""
"Returns one or more subgroups of the match.  If there is a single argument, "
"the result is a single string; if there are multiple arguments, the result "
"is a tuple with one item per argument. Without arguments, *group1* defaults "
"to zero (the whole match is returned). If a *groupN* argument is zero, the "
"corresponding return value is the entire matching string; if it is in the "
"inclusive range [1..99], it is the string matching the corresponding "
"parenthesized group.  If a group number is negative or larger than the "
"number of groups defined in the pattern, an :exc:`IndexError` exception is "
"raised. If a group is contained in a part of the pattern that did not match,"
" the corresponding result is ``None``. If a group is contained in a part of "
"the pattern that matched multiple times, the last match is returned. ::"
msgstr ""

#: ../../library/re.rst:1057
msgid ""
"If the regular expression uses the ``(?P<name>...)`` syntax, the *groupN* "
"arguments may also be strings identifying groups by their group name.  If a "
"string argument is not used as a group name in the pattern, an "
":exc:`IndexError` exception is raised."
msgstr ""
"もし正規表現が ``(?P<name>...)`` シンタックスを使うならば、 *groupN* "
"引数は、それらのグループ名によってグループを識別する文字列であっても構いません。もし文字列引数がパターンのグループ名として使われていないものであれば、 "
":exc:`IndexError` 例外が発生します。"

#: ../../library/re.rst:1062
msgid "A moderately complicated example::"
msgstr ""

#: ../../library/re.rst:1070
msgid "Named groups can also be referred to by their index::"
msgstr ""

#: ../../library/re.rst:1077
msgid "If a group matches multiple times, only the last match is accessible::"
msgstr ""

#: ../../library/re.rst:1086
msgid ""
"This is identical to ``m.group(g)``.  This allows easier access to an "
"individual group from a match::"
msgstr ""

#: ../../library/re.rst:1102
msgid ""
"Return a tuple containing all the subgroups of the match, from 1 up to "
"however many groups are in the pattern.  The *default* argument is used for "
"groups that did not participate in the match; it defaults to ``None``."
msgstr ""
"パターンにマッチしたすべてのサブグループを含む、パターン内で指定されたグループ数分の要素を持つタプルを返します。引数 *default* "
"は、マッチに加わらなかったグループ用に使われ、デフォルトでは ``None`` です。"

#: ../../library/re.rst:1106 ../../library/re.rst:1326
msgid "For example::"
msgstr "例えば::"

#: ../../library/re.rst:1112
msgid ""
"If we make the decimal place and everything after it optional, not all "
"groups might participate in the match.  These groups will default to "
"``None`` unless the *default* argument is given::"
msgstr ""

#: ../../library/re.rst:1125
msgid ""
"Return a dictionary containing all the *named* subgroups of the match, keyed"
" by the subgroup name.  The *default* argument is used for groups that did "
"not participate in the match; it defaults to ``None``.  For example::"
msgstr ""

#: ../../library/re.rst:1137
msgid ""
"Return the indices of the start and end of the substring matched by *group*;"
" *group* defaults to zero (meaning the whole matched substring). Return "
"``-1`` if *group* exists but did not contribute to the match.  For a match "
"object *m*, and a group *g* that did contribute to the match, the substring "
"matched by group *g* (equivalent to ``m.group(g)``) is ::"
msgstr ""
"*group* とマッチした部分文字列の先頭と末尾のインデックスを返します。 *group* "
"は、デフォルトでは(マッチした部分文字列全体を意味する）ゼロです。 *group* が存在してもマッチに寄与しなかった場合は、 ``-1`` "
"を返します。マッチオブジェクト *m* および、マッチに寄与しなかったグループ *g* があって、グループ *g* とマッチしたサブ文字列 ( "
"``m.group(g)`` と同じ意味ですが ) は::"

#: ../../library/re.rst:1145
msgid ""
"Note that ``m.start(group)`` will equal ``m.end(group)`` if *group* matched "
"a null string.  For example, after ``m = re.search('b(c?)', 'cba')``, "
"``m.start(0)`` is 1, ``m.end(0)`` is 2, ``m.start(1)`` and ``m.end(1)`` are "
"both 2, and ``m.start(2)`` raises an :exc:`IndexError` exception."
msgstr ""
"です。もし *group* が空文字列とマッチすれば、 ``m.start(group)`` が ``m.end(group)`` "
"と等しくなることに注意して下さい。例えば、 ``m = re.search('b(c?)', 'cba')`` とすると、 ``m.start(0)``"
" は 1 で、 ``m.end(0)`` は 2 であり、 ``m.start(1)`` と ``m.end(1)`` はともに 2 であり、 "
"``m.start(2)`` は :exc:`IndexError` 例外を発生します。"

#: ../../library/re.rst:1150
msgid "An example that will remove *remove_this* from email addresses::"
msgstr ""

#: ../../library/re.rst:1160
msgid ""
"For a match *m*, return the 2-tuple ``(m.start(group), m.end(group))``. Note"
" that if *group* did not contribute to the match, this is ``(-1, -1)``. "
"*group* defaults to zero, the entire match."
msgstr ""
"マッチ *m* について、大きさ2のタプル ``(m.start(group), m.end(group))`` を返します。もし *group* "
"がマッチに寄与しなければ、``(-1, -1)`` になります。また *group* はデフォルトでゼロです。"

#: ../../library/re.rst:1167
msgid ""
"The value of *pos* which was passed to the :meth:`~regex.search` or "
":meth:`~regex.match` method of a :ref:`regex object <re-objects>`.  This is "
"the index into the string at which the RE engine started looking for a "
"match."
msgstr ""
":ref:`正規表現オブジェクト <re-objects>` の :meth:`~regex.search` か "
":meth:`~regex.match` に渡された *pos* の値です。これは RE エンジンがマッチを探し始める位置の文字列のインデックスです。"

#: ../../library/re.rst:1174
msgid ""
"The value of *endpos* which was passed to the :meth:`~regex.search` or "
":meth:`~regex.match` method of a :ref:`regex object <re-objects>`.  This is "
"the index into the string beyond which the RE engine will not go."
msgstr ""
":ref:`正規表現オブジェクト <re-objects>` の :meth:`~regex.search` か "
":meth:`~regex.match` に渡された *endpos* の値です。これは RE "
"エンジンがそれ以上は進まない位置の文字列のインデックスです。"

#: ../../library/re.rst:1181
msgid ""
"The integer index of the last matched capturing group, or ``None`` if no "
"group was matched at all. For example, the expressions ``(a)b``, "
"``((a)(b))``, and ``((ab))`` will have ``lastindex == 1`` if applied to the "
"string ``'ab'``, while the expression ``(a)(b)`` will have ``lastindex == "
"2``, if applied to the same string."
msgstr ""
"最後にマッチした取り込みグループの整数インデックスです。もしどのグループも全くマッチしなければ ``None`` です。例えば、 ``(a)b``, "
"``((a)(b))`` や ``((ab))`` といった表現が ``'ab'`` に適用された場合、 ``lastindex == 1`` "
"となり、同じ文字列に ``(a)(b)`` が適用された場合には ``lastindex == 2`` となるでしょう。"

#: ../../library/re.rst:1190
msgid ""
"The name of the last matched capturing group, or ``None`` if the group "
"didn't have a name, or if no group was matched at all."
msgstr ""
"最後にマッチした取り込みグループの名前です。もしグループに名前がないか、あるいはどのグループも全くマッチしなければ ``None`` です。"

#: ../../library/re.rst:1196
msgid ""
"The :ref:`regular expression object <re-objects>` whose :meth:`~regex.match`"
" or :meth:`~regex.search` method produced this match instance."
msgstr ""

#: ../../library/re.rst:1202
msgid "The string passed to :meth:`~regex.match` or :meth:`~regex.search`."
msgstr ":meth:`~regex.match` または :meth:`~regex.search` へ渡された文字列です。"

#: ../../library/re.rst:1208
msgid "Regular Expression Examples"
msgstr "正規表現の例"

#: ../../library/re.rst:1212
msgid "Checking for a Pair"
msgstr "ペアの確認"

#: ../../library/re.rst:1214
msgid ""
"In this example, we'll use the following helper function to display match "
"objects a little more gracefully:"
msgstr "この例では、マッチオブジェクトの表示を少し美しくするために、下記の補助関数を使用します :"

#: ../../library/re.rst:1224
msgid ""
"Suppose you are writing a poker program where a player's hand is represented"
" as a 5-character string with each character representing a card, \"a\" for "
"ace, \"k\" for king, \"q\" for queen, \"j\" for jack, \"t\" for 10, and "
"\"2\" through \"9\" representing the card with that value."
msgstr ""
"あなたがポーカープログラムを書いているとします。プレイヤーの持ち札はそれぞれの文字が1枚のカードを意味する5文字の文字列によって表現されます。 "
"\"a\" はエース、 \"k\" はキング、 \"q\" はクイーン、 \"j\" はジャック、 \"t\" は10、そして \"2\" から "
"\"9\" はそれぞれの数字のカードを表します。"

#: ../../library/re.rst:1229
msgid "To see if a given string is a valid hand, one could do the following::"
msgstr ""

#: ../../library/re.rst:1239
msgid ""
"That last hand, ``\"727ak\"``, contained a pair, or two of the same valued "
"cards. To match this with a regular expression, one could use backreferences"
" as such::"
msgstr ""

#: ../../library/re.rst:1249
msgid ""
"To find out what card the pair consists of, one could use the "
":meth:`~match.group` method of the match object in the following manner:"
msgstr ""
"どのカードのペアになっているかを調べるには、以下のようにマッチオブジェクトの :meth:`~match.group` メソッドを使います:"

#: ../../library/re.rst:1269
msgid "Simulating scanf()"
msgstr "scanf() をシミュレートする"

#: ../../library/re.rst:1273
msgid ""
"Python does not currently have an equivalent to :c:func:`scanf`.  Regular "
"expressions are generally more powerful, though also more verbose, than "
":c:func:`scanf` format strings.  The table below offers some more-or-less "
"equivalent mappings between :c:func:`scanf` format tokens and regular "
"expressions."
msgstr ""
"Python には現在のところ、 :c:func:`scanf` に相当するものがありません。正規表現は、 :c:func:`scanf` "
"のフォーマット文字列よりも、一般的により強力であり、また冗長でもあります。以下の表に、 :c:func:`scanf` "
"のフォーマットトークンと正規表現の大体同等な対応付けを示します。"

#: ../../library/re.rst:1280
msgid ":c:func:`scanf` Token"
msgstr ":c:func:`scanf` トークン"

#: ../../library/re.rst:1280
msgid "Regular Expression"
msgstr "正規表現"

#: ../../library/re.rst:1282
msgid "``%c``"
msgstr "``%c``"

#: ../../library/re.rst:1284
msgid "``%5c``"
msgstr "``%5c``"

#: ../../library/re.rst:1284
msgid "``.{5}``"
msgstr "``.{5}``"

#: ../../library/re.rst:1286
msgid "``%d``"
msgstr "``%d``"

#: ../../library/re.rst:1286
msgid "``[-+]?\\d+``"
msgstr "``[-+]?\\d+``"

#: ../../library/re.rst:1288
msgid "``%e``, ``%E``, ``%f``, ``%g``"
msgstr "``%e``, ``%E``, ``%f``, ``%g``"

#: ../../library/re.rst:1288
msgid "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"
msgstr "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"

#: ../../library/re.rst:1290
msgid "``%i``"
msgstr "``%i``"

#: ../../library/re.rst:1290
msgid "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"
msgstr "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"

#: ../../library/re.rst:1292
msgid "``%o``"
msgstr "``%o``"

#: ../../library/re.rst:1292
msgid "``[-+]?[0-7]+``"
msgstr "``[-+]?[0-7]+``"

#: ../../library/re.rst:1294
msgid "``%s``"
msgstr "``%s``"

#: ../../library/re.rst:1294
msgid "``\\S+``"
msgstr "``\\S+``"

#: ../../library/re.rst:1296
msgid "``%u``"
msgstr "``%u``"

#: ../../library/re.rst:1296
msgid "``\\d+``"
msgstr "``\\d+``"

#: ../../library/re.rst:1298
msgid "``%x``, ``%X``"
msgstr "``%x``, ``%X``"

#: ../../library/re.rst:1298
msgid "``[-+]?(0[xX])?[\\dA-Fa-f]+``"
msgstr "``[-+]?(0[xX])?[\\dA-Fa-f]+``"

#: ../../library/re.rst:1301
msgid "To extract the filename and numbers from a string like ::"
msgstr "以下のような文字列からファイル名と数値を抽出することを考えます ::"

#: ../../library/re.rst:1305
msgid "you would use a :c:func:`scanf` format like ::"
msgstr ":c:func:`scanf` フォーマットは次のように使います ::"

#: ../../library/re.rst:1309
msgid "The equivalent regular expression would be ::"
msgstr "同等な正規表現はこのようなものとなります ::"

#: ../../library/re.rst:1317
msgid "search() vs. match()"
msgstr "search() vs. match()"

#: ../../library/re.rst:1321
msgid ""
"Python offers two different primitive operations based on regular "
"expressions: :func:`re.match` checks for a match only at the beginning of "
"the string, while :func:`re.search` checks for a match anywhere in the "
"string (this is what Perl does by default)."
msgstr ""
"Python は正規表現ベースの 2 個の基本的な関数、文字列の先頭でのみのマッチを確認する :func:`re.match` "
"および、文字列内の位置にかかわらずマッチを確認する :func:`re.search` (Perl でのデフォルトの挙動) を提供しています。"

#: ../../library/re.rst:1332
msgid ""
"Regular expressions beginning with ``'^'`` can be used with :func:`search` "
"to restrict the match at the beginning of the string::"
msgstr "``'^'`` で始まる正規表現は、 :func:`search` において、マッチを文字列の先頭からに制限するために使用します::"

#: ../../library/re.rst:1340
msgid ""
"Note however that in :const:`MULTILINE` mode :func:`match` only matches at "
"the beginning of the string, whereas using :func:`search` with a regular "
"expression beginning with ``'^'`` will match at the beginning of each line. "
"::"
msgstr ""

#: ../../library/re.rst:1350
msgid "Making a Phonebook"
msgstr "電話帳の作成"

#: ../../library/re.rst:1352
msgid ""
":func:`split` splits a string into a list delimited by the passed pattern.  "
"The method is invaluable for converting textual data into data structures "
"that can be easily read and modified by Python as demonstrated in the "
"following example that creates a phonebook."
msgstr ""
":func:`split` "
"は文字列を与えられたパターンで分割し、リストにして返します。下記の、電話帳作成の例のように、このメソッドはテキストデータを読みやすくしたり、 "
"Python で編集したりしやすくする際に、非常に役に立ちます。"

#: ../../library/re.rst:1357
msgid ""
"First, here is the input.  Normally it may come from a file, here we are "
"using triple-quoted string syntax::"
msgstr ""

#: ../../library/re.rst:1368
msgid ""
"The entries are separated by one or more newlines. Now we convert the string"
" into a list with each nonempty line having its own entry:"
msgstr "個々の記録は、1つ以上の改行で区切られています。まずは、文字列から空行を除き、記録ごとのリストに変換しましょう。"

#: ../../library/re.rst:1381
msgid ""
"Finally, split each entry into a list with first name, last name, telephone "
"number, and address.  We use the ``maxsplit`` parameter of :func:`split` "
"because the address has spaces, our splitting pattern, in it:"
msgstr ""
"そして、各記録を、名、姓、電話番号、そして、住所に分割してリストにします。分割のためのパターンに使っている空白文字が、住所には含まれるため、 "
":func:`split` の ``maxsplit`` 引数を使います。 :"

#: ../../library/re.rst:1394
msgid ""
"The ``:?`` pattern matches the colon after the last name, so that it does "
"not occur in the result list.  With a ``maxsplit`` of ``4``, we could "
"separate the house number from the street name:"
msgstr ""
"パターン、 ``:?`` は姓に続くコロンにマッチします。そのため、コロンは分割結果のリストには現れません。 ``maxsplit`` を ``4`` "
"にすれば、ハウスナンバーと、ストリート名を分割することができます。 :"

#: ../../library/re.rst:1409
msgid "Text Munging"
msgstr "テキストの秘匿"

#: ../../library/re.rst:1411
msgid ""
":func:`sub` replaces every occurrence of a pattern with a string or the "
"result of a function.  This example demonstrates using :func:`sub` with a "
"function to \"munge\" text, or randomize the order of all the characters in "
"each word of a sentence except for the first and last characters::"
msgstr ""
":func:`sub` はパターンにマッチした部分を文字列や関数の返り値で置き換えます。この例では、「秘匿」する文字列に、関数と共に "
":func:`sub` を適用する例を示します。言い換えると、最初と最後の文字を除く、単語中の文字の位置をランダム化します。 ::"

#: ../../library/re.rst:1428
msgid "Finding all Adverbs"
msgstr "全ての副詞を見つける"

#: ../../library/re.rst:1430
msgid ""
":func:`findall` matches *all* occurrences of a pattern, not just the first "
"one as :func:`search` does.  For example, if one was a writer and wanted to "
"find all of the adverbs in some text, he or she might use :func:`findall` in"
" the following manner::"
msgstr ""
":func:`findall` は出現するパターン *すべてに* マッチします。:func:`search` "
"が最初のものだけにマッチするのとは違います。例えば、なにかの文章のすべての副詞を見つけたいとき、下記のように :func:`findall` "
"を使います::"

#: ../../library/re.rst:1441
msgid "Finding all Adverbs and their Positions"
msgstr "全ての副詞と、その位置を見つける"

#: ../../library/re.rst:1443
msgid ""
"If one wants more information about all matches of a pattern than the "
"matched text, :func:`finditer` is useful as it provides :ref:`match objects "
"<match-objects>` instead of strings.  Continuing with the previous example, "
"if one was a writer who wanted to find all of the adverbs *and their "
"positions* in some text, he or she would use :func:`finditer` in the "
"following manner::"
msgstr ""
"もし、パターンにマッチするものについて、マッチしたテキスト以上の情報を得たいと考えた時、文字列ではなく :ref:`マッチオブジェクト <match-"
"objects>` を返す :func:`finditer` が便利です。以下に例を示すように、なにかの文章のすべての副詞と、*その位置を* "
"調べたい時、以下のように :func:`finditer` を使います::"

#: ../../library/re.rst:1457
msgid "Raw String Notation"
msgstr "Raw String記法"

#: ../../library/re.rst:1459
msgid ""
"Raw string notation (``r\"text\"``) keeps regular expressions sane.  Without"
" it, every backslash (``'\\'``) in a regular expression would have to be "
"prefixed with another one to escape it.  For example, the two following "
"lines of code are functionally identical::"
msgstr ""
"Raw 文字列記法 (``r\"text\"``) により、バックスラッシュ (``'\\'``) "
"を個々にバックスラッシュでエスケープすることなしに、正規表現を正常な状態に保つことができます。例えば、以下の 2 つのコードは機能的に等価です::"

#: ../../library/re.rst:1469
msgid ""
"When one wants to match a literal backslash, it must be escaped in the "
"regular expression.  With raw string notation, this means ``r\"\\\\\"``.  "
"Without raw string notation, one must use ``\"\\\\\\\\\"``, making the "
"following lines of code functionally identical::"
msgstr ""
"文字通りのバックスラッシュにマッチさせたいなら、正規表現中ではエスケープする必要があります。Raw 文字列記法では、``r\"\\\\\"``  "
"になります。Raw 文字列記法を用いない場合、``\"\\\\\\\\\"`` としなくてはなりません。以下のコードは機能的に等価です::"

#: ../../library/re.rst:1481
msgid "Writing a Tokenizer"
msgstr "トークナイザを書く"

#: ../../library/re.rst:1483
msgid ""
"A `tokenizer or scanner <https://en.wikipedia.org/wiki/Lexical_analysis>`_ "
"analyzes a string to categorize groups of characters.  This is a useful "
"first step in writing a compiler or interpreter."
msgstr ""
"`トークナイザやスキャナ <https://en.wikipedia.org/wiki/Lexical_analysis>`_ "
"は文字列を解析し、文字のグループにカテゴリ分けします。これはコンパイラやインタプリタを作成する最初の一歩として役立ちます。"

#: ../../library/re.rst:1487
msgid ""
"The text categories are specified with regular expressions.  The technique "
"is to combine those into a single master regular expression and to loop over"
" successive matches::"
msgstr "テキストのカテゴリは正規表現で指定されます。技術的には、それらを一つのマスター正規表現に結合し、連続したマッチをループさせます::"

#: ../../library/re.rst:1537
msgid "The tokenizer produces the following output::"
msgstr "トークナイザは以下の出力を作成します::"
