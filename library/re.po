# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-20 13:46+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/re.rst:2
msgid ":mod:`re` --- Regular expression operations"
msgstr ":mod:`re` --- æ­£è¦è¡¨ç¾æ“ä½œ"

#: ../../library/re.rst:10
msgid "**Source code:** :source:`Lib/re.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/re.py`"

#: ../../library/re.rst:14
msgid ""
"This module provides regular expression matching operations similar to those"
" found in Perl."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€Perl ãªã©ã¨åŒæ§˜ã®æ­£è¦è¡¨ç¾ãƒãƒƒãƒãƒ³ã‚°æ“ä½œã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/re.rst:17
msgid ""
"Both patterns and strings to be searched can be Unicode strings "
"(:class:`str`) as well as 8-bit strings (:class:`bytes`). However, Unicode "
"strings and 8-bit strings cannot be mixed: that is, you cannot match a "
"Unicode string with a byte pattern or vice-versa; similarly, when asking for"
" a substitution, the replacement string must be of the same type as both the"
" pattern and the search string."
msgstr ""
"ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨æ–‡å­—åˆ—ã«ã¯ Unicode æ–‡å­—åˆ— (:class:`str`) ãŠã‚ˆã³ 8 ãƒ“ãƒƒãƒˆæ–‡å­—åˆ— (:class:`bytes`) "
"ãŒä½¿ç”¨ã§ãã¾ã™ã€‚ã—ã‹ã—ã€Unicode æ–‡å­—åˆ—ã¨8ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã®æ··åœ¨ã¯ã§ãã¾ã›ã‚“ã€‚ã™ãªã‚ã¡ã€Unicode "
"æ–‡å­—åˆ—ã‚’ãƒã‚¤ãƒˆåˆ—ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ãƒãƒƒãƒãƒ³ã‚°ã—ãŸã‚Šã€ãã®é€†ã¯ã§ãã¾ã›ã‚“ã€‚åŒæ§˜ã«ã€ç½®ãæ›ãˆæ™‚ã®ç½®æ›æ–‡å­—åˆ—ã¯ãƒ‘ã‚¿ãƒ¼ãƒ³ãŠã‚ˆã³æ¤œç´¢æ–‡å­—åˆ—ã¨åŒã˜å‹ã§ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:24
msgid ""
"Regular expressions use the backslash character (``'\\'``) to indicate "
"special forms or to allow special characters to be used without invoking "
"their special meaning.  This collides with Python's usage of the same "
"character for the same purpose in string literals; for example, to match a "
"literal backslash, one might have to write ``'\\\\\\\\'`` as the pattern "
"string, because the regular expression must be ``\\\\``, and each backslash "
"must be expressed as ``\\\\`` inside a regular Python string literal."
msgstr ""
"æ­£è¦è¡¨ç¾ã§ã¯ã€ç‰¹æ®Šãªå½¢å¼ã‚’è¡¨ã—ãŸã‚Šã€ç‰¹æ®Šæ–‡å­—ã®æŒã¤ç‰¹åˆ¥ãªæ„å‘³ã‚’å‘¼ã³å‡ºã•ãšã«ãã®ç‰¹æ®Šãªæ–‡å­—ã‚’ä½¿ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ã€ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥æ–‡å­— "
"(``'\\'``) ã‚’ä½¿ã„ã¾ã™ã€‚ã“ã†ã—ãŸãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã®ä½¿ã„æ–¹ã¯ã€ Python "
"ã®æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã«ãŠã‘ã‚‹åŒã˜ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥æ–‡å­—ã¨è¡çªã‚’èµ·ã“ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥è‡ªä½“ã«ãƒãƒƒãƒã•ã›ã‚‹ã«ã¯ã€ãƒ‘ã‚¿ãƒ¼ãƒ³æ–‡å­—åˆ—ã¨ã—ã¦ "
"``'\\\\\\\\'`` ã¨æ›¸ã‹ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€ã¨ã„ã†ã®ã‚‚ã€æ­£è¦è¡¨ç¾ã¯ ``\\\\`` ã§ãªã‘ã‚Œã°ãªã‚‰ãšã€ã•ã‚‰ã«æ­£è¦ãª Python "
"æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã§ã¯å„ã€…ã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’ ``\\\\`` ã¨è¡¨ç¾ã›ã­ã°ãªã‚‰ãªã„ã‹ã‚‰ã§ã™ã€‚"

#: ../../library/re.rst:33
msgid ""
"The solution is to use Python's raw string notation for regular expression "
"patterns; backslashes are not handled in any special way in a string literal"
" prefixed with ``'r'``.  So ``r\"\\n\"`` is a two-character string "
"containing ``'\\'`` and ``'n'``, while ``\"\\n\"`` is a one-character string"
" containing a newline.  Usually patterns will be expressed in Python code "
"using this raw string notation."
msgstr ""
"æ­£è¦è¡¨ç¾ãƒ‘ã‚¿ãƒ¼ãƒ³ã« Python ã® raw string è¨˜æ³•ã‚’ä½¿ãˆã°ã“ã®å•é¡Œã‚’è§£æ±ºã§ãã¾ã™ã€‚ ``'r'`` "
"ã‚’å‰ç½®ã—ãŸæ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«å†…ã§ã¯ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’ç‰¹åˆ¥æ‰±ã„ã—ã¾ã›ã‚“ã€‚å¾“ã£ã¦ã€ ``\"\\n\"`` ãŒæ”¹è¡Œä¸€æ–‡å­—ã®å…¥ã£ãŸæ–‡å­—åˆ—ã«ãªã‚‹ã®ã«å¯¾ã—ã¦ã€ "
"``r\"\\n\"`` ã¯ ``'\\'`` ã¨ ``'n'`` ã¨ã„ã†äºŒã¤ã®æ–‡å­—ã®å…¥ã£ãŸæ–‡å­—åˆ—ã«ãªã‚Šã¾ã™ã€‚é€šå¸¸ã€ Python "
"ã‚³ãƒ¼ãƒ‰ä¸­ã§ã¯ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ã“ã® raw string è¨˜æ³•ã‚’ä½¿ã£ã¦è¡¨ç¾ã—ã¾ã™ã€‚"

#: ../../library/re.rst:40
msgid ""
"It is important to note that most regular expression operations are "
"available as module-level functions and methods on :ref:`compiled regular "
"expressions <re-objects>`.  The functions are shortcuts that don't require "
"you to compile a regex object first, but miss some fine-tuning parameters."
msgstr ""
"å¤§æŠµã®æ­£è¦è¡¨ç¾æ“ä½œãŒã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«ã®é–¢æ•°ã¨ã€ :ref:`ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿æ­£è¦è¡¨ç¾ <re-objects>` "
"ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã—ã¦æä¾›ã•ã‚Œã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ä¸‹ã•ã„ã€‚é–¢æ•°ã¯æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚’å¿…è¦ã¨ã—ãªã„è¿‘é“ã§ã™ãŒã€ã„ãã¤ã‹ã®ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°å¤‰æ•°ã‚’å¤±ã„ã¾ã™ã€‚"

#: ../../library/re.rst:48
msgid ""
"The third-party `regex <https://pypi.org/project/regex/>`_ module, which has"
" an API compatible with the standard library :mod:`re` module, but offers "
"additional functionality and a more thorough Unicode support."
msgstr ""
"ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ã® `regex <https://pypi.org/project/regex/>`_ ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã® "
":mod:`re` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨äº’æ›ãª API ã‚’æŒã¡ã€è¿½åŠ ã®æ©Ÿèƒ½ã¨ã‚ˆã‚Šå¾¹åº•ã—ãŸ Unicode ã‚µãƒãƒ¼ãƒˆã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../library/re.rst:56
msgid "Regular Expression Syntax"
msgstr "æ­£è¦è¡¨ç¾ã®ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹"

#: ../../library/re.rst:58
msgid ""
"A regular expression (or RE) specifies a set of strings that matches it; the"
" functions in this module let you check if a particular string matches a "
"given regular expression (or if a given regular expression matches a "
"particular string, which comes down to the same thing)."
msgstr ""
"æ­£è¦è¡¨ç¾ (ã™ãªã‚ã¡ RE) ã¯ã€è¡¨ç¾ã«ãƒãƒƒãƒ (match) "
"ã™ã‚‹æ–‡å­—åˆ—ã®é›†åˆã‚’è¡¨ã—ã¦ã„ã¾ã™ã€‚ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®é–¢æ•°ã‚’ä½¿ãˆã°ã€ã‚ã‚‹æ–‡å­—åˆ—ãŒæŒ‡å®šã®æ­£è¦è¡¨ç¾ã«ãƒãƒƒãƒã™ã‚‹ã‹ "
"(ã¾ãŸã¯æŒ‡å®šã®æ­£è¦è¡¨ç¾ãŒã‚ã‚‹æ–‡å­—åˆ—ã«ãƒãƒƒãƒã™ã‚‹ã‹ã€ã¤ã¾ã‚Šã¯åŒã˜ã“ã¨ã§ã™ãŒ) ã‚’æ¤œæŸ»ã§ãã¾ã™ã€‚"

#: ../../library/re.rst:63
msgid ""
"Regular expressions can be concatenated to form new regular expressions; if "
"*A* and *B* are both regular expressions, then *AB* is also a regular "
"expression. In general, if a string *p* matches *A* and another string *q* "
"matches *B*, the string *pq* will match AB.  This holds unless *A* or *B* "
"contain low precedence operations; boundary conditions between *A* and *B*; "
"or have numbered group references.  Thus, complex expressions can easily be "
"constructed from simpler primitive expressions like the ones described here."
"  For details of the theory and implementation of regular expressions, "
"consult the Friedl book [Frie09]_, or almost any textbook about compiler "
"construction."
msgstr ""
"æ­£è¦è¡¨ç¾ã‚’é€£çµã™ã‚‹ã¨æ–°ã—ã„æ­£è¦è¡¨ç¾ã‚’ä½œã‚Œã¾ã™ã€‚*A* ã¨ *B* ãŒã¨ã‚‚ã«æ­£è¦è¡¨ç¾ã§ã‚ã‚Œã° *AB* ã‚‚æ­£è¦è¡¨ç¾ã§ã™ã€‚ä¸€èˆ¬çš„ã«ã€æ–‡å­—åˆ— *p* ãŒ "
"*A* ã¨ãƒãƒƒãƒã—ã€åˆ¥ã®æ–‡å­—åˆ— *q* ãŒ *B* ã¨ãƒãƒƒãƒã™ã‚Œã°ã€æ–‡å­—åˆ— *pq* ã¯ AB ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ãŸã ã—ã€ã“ã®çŠ¶æ³ãŒæˆã‚Šç«‹ã¤ã®ã¯ã€*A* "
"ã¨ *B* ã¨ã®é–“ã«å¢ƒç•Œæ¡ä»¶ãŒã‚ã‚‹å ´åˆã‚„ã€ç•ªå·ä»˜ã‘ã•ã‚ŒãŸã‚°ãƒ«ãƒ¼ãƒ—å‚ç…§ã®ã‚ˆã†ãªã€å„ªå…ˆåº¦ã®ä½ã„æ¼”ç®—ã‚’ *A* ã‚„ *B* "
"ãŒå«ã¾ãªã„å ´åˆã ã‘ã§ã™ã€‚ã“ã®ã‚ˆã†ã«ã—ã¦ã€ã“ã“ã§è¿°ã¹ã‚‹ã‚ˆã†ãªã€ã‚ˆã‚Šç°¡å˜ã§ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãªæ­£è¦è¡¨ç¾ã‹ã‚‰ã€è¤‡é›‘ãªæ­£è¦è¡¨ç¾ã‚’å®¹æ˜“ã«æ§‹ç¯‰ã§ãã¾ã™ã€‚æ­£è¦è¡¨ç¾ã«é–¢ã™ã‚‹ç†è«–ã¨å®Ÿè£…ã®è©³ç´°ã«ã¤ã„ã¦ã¯"
" Friedl æœ¬ [Frie09]_ ã‹ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®æ§‹ç¯‰ã«é–¢ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/re.rst:73
msgid ""
"A brief explanation of the format of regular expressions follows.  For "
"further information and a gentler presentation, consult the :ref:`regex-"
"howto`."
msgstr ""
"ä»¥ä¸‹ã§æ­£è¦è¡¨ç¾ã®å½¢å¼ã«é–¢ã™ã‚‹ç°¡å˜ãªèª¬æ˜ã‚’ã—ã¦ãŠãã¾ã™ã€‚ã‚ˆã‚Šè©³ç´°ãªæƒ…å ±ã‚„ã‚ˆã‚Šã‚„ã•ã—ã„èª¬æ˜ã«é–¢ã—ã¦ã¯ã€ :ref:`regex-howto` "
"ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/re.rst:76
msgid ""
"Regular expressions can contain both special and ordinary characters. Most "
"ordinary characters, like ``'A'``, ``'a'``, or ``'0'``, are the simplest "
"regular expressions; they simply match themselves.  You can concatenate "
"ordinary characters, so ``last`` matches the string ``'last'``.  (In the "
"rest of this section, we'll write RE's in ``this special style``, usually "
"without quotes, and strings to be matched ``'in single quotes'``.)"
msgstr ""
"æ­£è¦è¡¨ç¾ã«ã¯ã€ç‰¹æ®Šæ–‡å­—ã¨é€šå¸¸æ–‡å­—ã®ä¸¡æ–¹ã‚’å«ã‚ã‚‰ã‚Œã¾ã™ã€‚ ``'A'`` ã€ ``'a'`` ã€ã‚ã‚‹ã„ã¯ ``'0'`` "
"ã®ã‚ˆã†ãªã»ã¨ã‚“ã©ã®é€šå¸¸æ–‡å­—ã¯æœ€ã‚‚ç°¡å˜ãªæ­£è¦è¡¨ç¾ã«ãªã‚Šã¾ã™ã€‚ã“ã†ã—ãŸæ–‡å­—ã¯ã€å˜ç´”ã«ãã®æ–‡å­—è‡ªä½“ã«ãƒãƒƒãƒã—ã¾ã™ã€‚é€šå¸¸ã®æ–‡å­—ã¯é€£çµã§ãã‚‹ã®ã§ã€ "
"``last`` ã¯æ–‡å­—åˆ— ``'last'`` ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚ (ã“ã®ç¯€ã®ä»¥é™ã®èª¬æ˜ã§ã¯ã€æ­£è¦è¡¨ç¾ã‚’å¼•ç”¨ç¬¦ã‚’ä½¿ã‚ãšã« ``ã“ã®è¡¨ç¤ºã‚¹ã‚¿ã‚¤ãƒ«: "
"special style`` ã§æ›¸ãã€ãƒãƒƒãƒå¯¾è±¡ã®æ–‡å­—åˆ—ã¯ã€ ``'å¼•ç”¨ç¬¦ã§æ‹¬ã£ã¦'`` æ›¸ãã¾ã™ã€‚)"

#: ../../library/re.rst:83
msgid ""
"Some characters, like ``'|'`` or ``'('``, are special. Special characters "
"either stand for classes of ordinary characters, or affect how the regular "
"expressions around them are interpreted."
msgstr ""
"``'|'`` ã‚„ ``'('`` "
"ã¨ã„ã£ãŸã„ãã¤ã‹ã®æ–‡å­—ã¯ç‰¹æ®Šæ–‡å­—ã§ã™ã€‚ç‰¹æ®Šæ–‡å­—ã¯é€šå¸¸ã®æ–‡å­—ã®ç¨®åˆ¥ã‚’è¡¨ã—ãŸã‚Šã€ã‚ã‚‹ã„ã¯ç‰¹æ®Šæ–‡å­—ã®å‘¨è¾ºã«ã‚ã‚‹é€šå¸¸ã®æ–‡å­—ã«å¯¾ã™ã‚‹è§£é‡ˆæ–¹æ³•ã«å½±éŸ¿ã—ã¾ã™ã€‚"

#: ../../library/re.rst:87
msgid ""
"Repetition qualifiers (``*``, ``+``, ``?``, ``{m,n}``, etc) cannot be "
"directly nested. This avoids ambiguity with the non-greedy modifier suffix "
"``?``, and with other modifiers in other implementations. To apply a second "
"repetition to an inner repetition, parentheses may be used. For example, the"
" expression ``(?:a{6})*`` matches any multiple of six ``'a'`` characters."
msgstr ""
"ç¹°ã‚Šè¿”ã—ã®ä¿®é£¾å­ (``*``, ``+``, ``?``, ``{m,n}`` ãªã©) ã¯ç›´æ¥å…¥ã‚Œå­ã«ã¯ã§ãã¾ã›ã‚“ã€‚\n"
"ã“ã‚Œã«ã‚ˆã£ã¦ã€éè²ªæ¬²ãªä¿®é£¾å­ã®æ¥å°¾è¾ ``?`` ã‚„ä»–ã®å®Ÿè£…ã§ã®ä»–ã®ä¿®é£¾å­ã«ã¤ã„ã¦ã®æ›–æ˜§ã•ã‚’å›é¿ã—ã¦ã„ã¾ã™ã€‚\n"
"ç¹°ã‚Šè¿”ã—ã®ã‚ã‚‹æ­£è¦è¡¨ç¾ã®å¤–å´ã«ã•ã‚‰ã«ç¹°ã‚Šè¿”ã—ã‚’é©ç”¨ã™ã‚‹ã«ã¯ä¸¸æ‹¬å¼§ãŒä½¿ãˆã¾ã™ã€‚\n"
"ä¾‹ãˆã°ã€æ­£è¦è¡¨ç¾ ``(?:a{6})*`` ã¯6ã¤ã® ``'a'`` ã®0å›ä»¥ä¸Šã®ç¹°ã‚Šè¿”ã—ã«é©åˆã—ã¾ã™ã€‚"

#: ../../library/re.rst:94
msgid "The special characters are:"
msgstr "ç‰¹æ®Šæ–‡å­—ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™:"

#: ../../library/re.rst:99 ../../library/re.rst:1280
msgid "``.``"
msgstr "``.``"

#: ../../library/re.rst:97
msgid ""
"(Dot.)  In the default mode, this matches any character except a newline.  "
"If the :const:`DOTALL` flag has been specified, this matches any character "
"including a newline."
msgstr ""
"(ãƒ‰ãƒƒãƒˆ) ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ¢ãƒ¼ãƒ‰ã§ã¯æ”¹è¡Œä»¥å¤–ã®ä»»æ„ã®æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ :const:`DOTALL` "
"ãƒ•ãƒ©ã‚°ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚Œã°æ”¹è¡Œã‚‚å«ã‚€ã™ã¹ã¦ã®æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:103
msgid "``^``"
msgstr "``^``"

#: ../../library/re.rst:102
msgid ""
"(Caret.)  Matches the start of the string, and in :const:`MULTILINE` mode "
"also matches immediately after each newline."
msgstr "(ã‚­ãƒ£ãƒ¬ãƒƒãƒˆ) æ–‡å­—åˆ—ã®å…ˆé ­ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚ :const:`MULTILINE` ãƒ¢ãƒ¼ãƒ‰ã§ã¯å„æ”¹è¡Œã®ç›´å¾Œã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:112
msgid "``$``"
msgstr "``$``"

#: ../../library/re.rst:106
msgid ""
"Matches the end of the string or just before the newline at the end of the "
"string, and in :const:`MULTILINE` mode also matches before a newline.  "
"``foo`` matches both 'foo' and 'foobar', while the regular expression "
"``foo$`` matches only 'foo'.  More interestingly, searching for ``foo.$`` in"
" ``'foo1\\nfoo2\\n'`` matches 'foo2' normally, but 'foo1' in "
":const:`MULTILINE` mode; searching for a single ``$`` in ``'foo\\n'`` will "
"find two (empty) matches: one just before the newline, and one at the end of"
" the string."
msgstr ""
"æ–‡å­—åˆ—ã®æœ«å°¾ã€ã‚ã‚‹ã„ã¯æ–‡å­—åˆ—ã®æœ«å°¾ã®æ”¹è¡Œã®ç›´å‰ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ ``foo`` ã¯ 'foo' ã¨ 'foobar' "
"ã®ä¸¡æ–¹ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ä¸€æ–¹ã€æ­£è¦è¡¨ç¾ ``foo$`` ã¯ 'foo' ã ã‘ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚èˆˆå‘³æ·±ã„ã“ã¨ã«ã€ ``'foo1\\nfoo2\\n'`` "
"ã‚’ ``foo.$`` ã§æ¤œç´¢ã—ãŸå ´åˆã€é€šå¸¸ã®ãƒ¢ãƒ¼ãƒ‰ã§ã¯ 'foo2' ã ã‘ã«ãƒãƒƒãƒã—ã€ :const:`MULTILINE` ãƒ¢ãƒ¼ãƒ‰ã§ã¯ 'foo1'"
" ã«ã‚‚ãƒãƒƒãƒã—ã¾ã™ã€‚ ``$`` ã ã‘ã§ ``'foo\\n'`` ã‚’æ¤œç´¢ã—ãŸå ´åˆã€2ç®‡æ‰€ (å†…å®¹ã¯ç©º) ã§ãƒãƒƒãƒã—ã¾ã™: "
"1ã¤ã¯ã€æ”¹è¡Œã®ç›´å‰ã§ã€ã‚‚ã†1ã¤ã¯ã€æ–‡å­—åˆ—ã®æœ€å¾Œã§ã™ã€‚"

#: ../../library/re.rst:117
msgid "``*``"
msgstr "``*``"

#: ../../library/re.rst:115
msgid ""
"Causes the resulting RE to match 0 or more repetitions of the preceding RE, "
"as many repetitions as are possible.  ``ab*`` will match 'a', 'ab', or 'a' "
"followed by any number of 'b's."
msgstr ""
"ç›´å‰ã«ã‚ã‚‹ RE ã«ä½œç”¨ã—ã¦ã€ RE ã‚’ 0 å›ä»¥ä¸Šã§ãã‚‹ã ã‘å¤šãç¹°ã‚Šè¿”ã—ãŸã‚‚ã®ã«ãƒãƒƒãƒã•ã›ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ä¾‹ãˆã° ``ab*`` ã¯ "
"'a'ã€'ab'ã€ã‚ã‚‹ã„ã¯ 'a' ã«ä»»æ„å€‹æ•°ã®'b' ã‚’ç¶šã‘ãŸã‚‚ã®ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:122
msgid "``+``"
msgstr "``+``"

#: ../../library/re.rst:120
msgid ""
"Causes the resulting RE to match 1 or more repetitions of the preceding RE. "
"``ab+`` will match 'a' followed by any non-zero number of 'b's; it will not "
"match just 'a'."
msgstr ""
"ç›´å‰ã«ã‚ã‚‹ RE ã«ä½œç”¨ã—ã¦ã€ RE ã‚’ã€1 å›ä»¥ä¸Šç¹°ã‚Šè¿”ã—ãŸã‚‚ã®ã«ãƒãƒƒãƒã•ã›ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ä¾‹ãˆã° ``ab+`` ã¯ 'a' ã«ä¸€ã¤ä»¥ä¸Šã® 'b' "
"ãŒç¶šã„ãŸã‚‚ã®ã«ãƒãƒƒãƒã—ã€ 'a' å˜ä½“ã«ã¯ãƒãƒƒãƒã—ã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:126
msgid "``?``"
msgstr "``?``"

#: ../../library/re.rst:125
msgid ""
"Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. "
"``ab?`` will match either 'a' or 'ab'."
msgstr ""
"ç›´å‰ã«ã‚ã‚‹ RE ã«ä½œç”¨ã—ã¦ã€ RE ã‚’ 0 å›ã‹ 1 å›ç¹°ã‚Šè¿”ã—ãŸã‚‚ã®ã«ãƒãƒƒãƒã•ã›ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ä¾‹ãˆã° ``ab?`` ã¯ 'a' ã‚ã‚‹ã„ã¯ "
"'ab' ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:135
msgid "``*?``, ``+?``, ``??``"
msgstr "``*?``, ``+?``, ``??``"

#: ../../library/re.rst:129
msgid ""
"The ``'*'``, ``'+'``, and ``'?'`` qualifiers are all :dfn:`greedy`; they "
"match as much text as possible.  Sometimes this behaviour isn't desired; if "
"the RE ``<.*>`` is matched against ``'<a> b <c>'``, it will match the entire"
" string, and not just ``'<a>'``.  Adding ``?`` after the qualifier makes it "
"perform the match in :dfn:`non-greedy` or :dfn:`minimal` fashion; as *few* "
"characters as possible will be matched.  Using the RE ``<.*?>`` will match "
"only ``'<a>'``."
msgstr ""
"``'*'`` ã€ ``'+'`` ã€ ``'?'`` ã¨ã„ã£ãŸä¿®é£¾å­ã¯ã€ã™ã¹ã¦ :dfn:`è²ªæ¬² (greedy)` "
"ãƒãƒƒãƒã€ã™ãªã‚ã¡ã§ãã‚‹ã ã‘å¤šãã®ãƒ†ã‚­ã‚¹ãƒˆã«ãƒãƒƒãƒã™ã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚æ™‚ã«ã¯ã“ã®å‹•ä½œãŒæœ›ã¾ã—ããªã„å ´åˆã‚‚ã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°æ­£è¦è¡¨ç¾ ``<.*>`` ã‚’"
" ``'<a> b <c>'`` ã«ãƒãƒƒãƒã•ã›ã‚‹ã¨ã€ ``'<a>'`` ã ã‘ã«ãƒãƒƒãƒã™ã‚‹ã®ã§ã¯ãªãå…¨æ–‡å­—åˆ—ã«ãƒãƒƒãƒã—ã¦ã—ã¾ã„ã¾ã™ã€‚ ``?`` "
"ã‚’ä¿®é£¾å­ã®å¾Œã«è¿½åŠ ã™ã‚‹ã¨ã€ :dfn:`éè²ªæ¬² (non-greedy)` ã‚ã‚‹ã„ã¯ :dfn:`æœ€å°ä¸€è‡´ (minimal)` "
"ã®ãƒãƒƒãƒã«ãªã‚Šã€ã§ãã‚‹ã ã‘ *å°‘ãªã„* æ–‡å­—æ•°ã®ãƒãƒƒãƒã«ãªã‚Šã¾ã™ã€‚ä¾‹ãˆã°æ­£è¦è¡¨ç¾ ``<.*?>`` ã‚’ä½¿ã†ã¨ ``'<a>'`` ã ã‘ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:140
msgid "``{m}``"
msgstr "``{m}``"

#: ../../library/re.rst:138
msgid ""
"Specifies that exactly *m* copies of the previous RE should be matched; "
"fewer matches cause the entire RE not to match.  For example, ``a{6}`` will "
"match exactly six ``'a'`` characters, but not five."
msgstr ""
"å‰ã«ã‚ã‚‹ RE ã® *m* å›ã®æ­£ç¢ºãªã‚³ãƒ”ãƒ¼ã¨ãƒãƒƒãƒã™ã¹ãã§ã‚ã‚‹ã“ã¨ã‚’æŒ‡å®šã—ã¾ã™ï¼›ãƒãƒƒãƒå›æ•°ãŒå°‘ãªã‘ã‚Œã°ã€RE å…¨ä½“ã§ã¯ãƒãƒƒãƒã—ã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€ "
"``a{6}`` ã¯ã€æ­£ç¢ºã« 6å€‹ã® ``'a'`` æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™ãŒã€ 5å€‹ã§ã¯ãƒãƒƒãƒã—ã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:149
msgid "``{m,n}``"
msgstr "``{m,n}``"

#: ../../library/re.rst:143
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible.  For "
"example, ``a{3,5}`` will match from 3 to 5 ``'a'`` characters.  Omitting *m*"
" specifies a lower bound of zero,  and omitting *n* specifies an infinite "
"upper bound.  As an example, ``a{4,}b`` will match ``'aaaab'`` or a thousand"
" ``'a'`` characters followed by a ``'b'``, but not ``'aaab'``. The comma may"
" not be omitted or the modifier would be confused with the previously "
"described form."
msgstr ""
"çµæœã® RE ã¯ã€å‰ã«ã‚ã‚‹ RE ã‚’ã€*m* å›ã‹ã‚‰ *n* "
"å›ã¾ã§ç¹°ã‚Šè¿”ã—ãŸã‚‚ã®ã§ã€ã§ãã‚‹ã ã‘å¤šãç¹°ã‚Šè¿”ã—ãŸã‚‚ã®ã¨ãƒãƒƒãƒã™ã‚‹ã‚ˆã†ã«ã€ãƒãƒƒãƒã—ã¾ã™ã€‚ä¾‹ãˆã°ã€``a{3,5}`` ã¯ã€3å€‹ã‹ã‚‰ 5å€‹ã® ``'a'``"
" æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚*m* ã‚’çœç•¥ã™ã‚‹ã¨ãƒãƒƒãƒå›æ•°ã®ä¸‹é™ã¨ã—ã¦0ã‚’æŒ‡å®šã—ãŸäº‹ã«ãªã‚Šã€*n* ã‚’çœç•¥ã™ã‚‹ã“ã¨ã¯ã€ä¸Šé™ãŒç„¡é™ã§ã‚ã‚‹ã“ã¨ã‚’æŒ‡å®šã—ã¾ã™;  "
"``a{4,}b`` ã¯ ``'aaaab'`` ã‚„ã€1,000 å€‹ã® ``'a'`` æ–‡å­—ã« ``'b'`` "
"ãŒç¶šã„ãŸã‚‚ã®ã¨ãƒãƒƒãƒã—ã¾ã™ãŒã€``'aaab'`` "
"ã¨ã¯ãƒãƒƒãƒã—ã¾ã›ã‚“ã€‚ã‚³ãƒ³ãƒã¯çœç•¥ã§ãã¾ã›ã‚“ã€çœç•¥ã™ã‚‹ã¨ä¿®é£¾å­ãŒä¸Šã§è¿°ã¹ãŸå½¢å¼ã¨æ··åŒã•ã‚Œã¦ã—ã¾ã†ã‹ã‚‰ã§ã™ã€‚"

#: ../../library/re.rst:156
msgid "``{m,n}?``"
msgstr "``{m,n}?``"

#: ../../library/re.rst:152
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as *few* repetitions as possible.  This is"
" the non-greedy version of the previous qualifier.  For example, on the "
"6-character string ``'aaaaaa'``, ``a{3,5}`` will match 5 ``'a'`` characters,"
" while ``a{3,5}?`` will only match 3 characters."
msgstr ""
"çµæœã® RE ã¯ã€å‰ã«ã‚ã‚‹ RE ã® *m* å›ã‹ã‚‰ *n* å›ã¾ã§ç¹°ã‚Šè¿”ã—ãŸã‚‚ã®ã§ã€ã§ãã‚‹ã ã‘ *å°‘ãªã* "
"ç¹°ã‚Šè¿”ã—ãŸã‚‚ã®ã¨ãƒãƒƒãƒã™ã‚‹ã‚ˆã†ã«ã€ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã¯ã€å‰ã®ä¿®é£¾å­ã®æ§ãˆç›®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã™ã€‚ä¾‹ãˆã°ã€ 6æ–‡å­—æ–‡å­—åˆ— ``'aaaaaa'`` ã§ã¯ã€ "
"``a{3,5}`` ã¯ã€5å€‹ã® ``'a'`` æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™ãŒã€ ``a{3,5}?`` ã¯3å€‹ã®æ–‡å­—ã¨ãƒãƒƒãƒã™ã‚‹ã ã‘ã§ã™ã€‚"

#: ../../library/re.rst:169
msgid "``\\``"
msgstr "``\\``"

#: ../../library/re.rst:159
msgid ""
"Either escapes special characters (permitting you to match characters like "
"``'*'``, ``'?'``, and so forth), or signals a special sequence; special "
"sequences are discussed below."
msgstr ""
"ç‰¹æ®Šæ–‡å­—ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã™ã‚‹( ``'*'`` ã‚„ ``'?'`` ç­‰ã®ã‚ˆã†ãªæ–‡å­—ã¨ã®ãƒãƒƒãƒã‚’ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹) ã‹ã€ã‚ã‚‹ã„ã¯ã€ç‰¹æ®Šã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®åˆå›³ã§ã™; "
"ç‰¹æ®Šã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯å¾Œã§è­°è«–ã—ã¾ã™ã€‚"

#: ../../library/re.rst:163
msgid ""
"If you're not using a raw string to express the pattern, remember that "
"Python also uses the backslash as an escape sequence in string literals; if "
"the escape sequence isn't recognized by Python's parser, the backslash and "
"subsequent character are included in the resulting string.  However, if "
"Python would recognize the resulting sequence, the backslash should be "
"repeated twice.  This is complicated and hard to understand, so it's highly "
"recommended that you use raw strings for all but the simplest expressions."
msgstr ""
"ã‚‚ã—ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è¡¨ç¾ã™ã‚‹ã®ã« raw string ã‚’ä½¿ç”¨ã—ã¦ã„ãªã„ã®ã§ã‚ã‚Œã°ã€ Python "
"ã‚‚ã€ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã§ã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¨ã—ã¦ä½¿ã£ã¦ã„ã‚‹ã“ã¨ã‚’è¦šãˆã¦ã„ã¦ä¸‹ã•ã„ã€‚ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ Python "
"ã®æ§‹æ–‡è§£æå™¨ãŒèªè­˜ã—ã¦å‡¦ç†ã—ãªã„å ´åˆã€ãã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã¨ãã‚Œã«ç¶šãæ–‡å­—ã¯ã€çµæœã®æ–‡å­—åˆ—ã«ãã®ã¾ã¾å«ã¾ã‚Œã¾ã™ã€‚ã—ã‹ã—ã€Python "
"ãŒçµæœã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’èªè­˜ã™ã‚‹å ´åˆã¯ã€ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’ 2å›ç¹°ã‚Šè¿”ã•ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€‚ã“ã‚Œã¯è¤‡é›‘ã§ç†è§£ã—ã«ãã„ã®ã§ã€æœ€ã‚‚ç°¡å˜ãªè¡¨ç¾ä»¥å¤–ã¯ã€ã™ã¹ã¦ "
"raw string ã‚’ä½¿ã†ã“ã¨ã‚’å¼·ãæ¨å¥¨ã—ã¾ã™ã€‚"

#: ../../library/re.rst:201
msgid "``[]``"
msgstr "``[]``"

#: ../../library/re.rst:172
msgid "Used to indicate a set of characters.  In a set:"
msgstr "æ–‡å­—ã®é›†åˆã‚’æŒ‡å®šã™ã‚‹ã®ã«ä½¿ç”¨ã—ã¾ã™ã€‚é›†åˆã«ã¯ä»¥ä¸‹ã®ã‚‚ã®ãŒæŒ‡å®šã§ãã¾ã™:"

#: ../../library/re.rst:174
msgid ""
"Characters can be listed individually, e.g. ``[amk]`` will match ``'a'``, "
"``'m'``, or ``'k'``."
msgstr "å€‹åˆ¥ã«æŒ‡å®šã§ãã‚‹æ–‡å­—ã€‚ ``[amk]`` ã¯ ``'a'``, ``'m'``, ``'k'`` ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:177
msgid ""
"Ranges of characters can be indicated by giving two characters and "
"separating them by a ``'-'``, for example ``[a-z]`` will match any lowercase"
" ASCII letter, ``[0-5][0-9]`` will match all the two-digits numbers from "
"``00`` to ``59``, and ``[0-9A-Fa-f]`` will match any hexadecimal digit.  If "
"``-`` is escaped (e.g. ``[a\\-z]``) or if it's placed as the first or last "
"character (e.g. ``[-a]`` or ``[a-]``), it will match a literal ``'-'``."
msgstr ""
"é€£ç¶šã—ãŸæ–‡å­—ã®ç¯„å›²ã‚’ã€å…ˆé ­ã¨æœ€å¾Œã®2æ–‡å­—ã¨ãã®é–“ã« ``'-'`` ã‚’æŒŸã‚“ã å½¢ã§æŒ‡å®šã§ãã¾ã™ã€‚``[a-z]`` ã¯ã™ã¹ã¦ã®å°æ–‡å­—ã® ASCII "
"æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚``[0-5][0-9]`` ã¯ ``00`` ã‹ã‚‰ ``59`` ã¾ã§ã®ã€ã™ã¹ã¦ã® 2 æ¡ã®æ•°å­—ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚``[0-9A-"
"Fa-f]`` ã¯ä»»æ„ã® 16 é€²æ•°ã®æ•°å­—ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚``-`` ãŒã€ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚ŒãŸå ´åˆ (ä¾‹: "
"``[a\\-z]``)ã€ã‚ã‚‹ã„ã¯å…ˆé ­ã‹æœ«å°¾ã«ç½®ã‹ã‚ŒãŸå ´åˆ (ä¾‹: ``[-a]`` ã‚„ ``[a-]``)ã€ãƒªãƒ†ãƒ©ãƒ« ``'-'`` ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:184
msgid ""
"Special characters lose their special meaning inside sets.  For example, "
"``[(+*)]`` will match any of the literal characters ``'('``, ``'+'``, "
"``'*'``, or ``')'``."
msgstr ""
"é›†åˆå†…ã§ã¯ã€ç‰¹æ®Šæ–‡å­—ã¯ãã®æ„å‘³ã‚’å¤±ã„ã¾ã™ã€‚ ``[(+*)]`` ã¯ãƒªãƒ†ãƒ©ãƒ«æ–‡å­— ``'('`` ``'+'`` ã€ ``'*'`` ã€ã‚ã‚‹ã„ã¯ "
"``')'`` ã®ã„ãšã‚Œã‹ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:188
msgid ""
"Character classes such as ``\\w`` or ``\\S`` (defined below) are also "
"accepted inside a set, although the characters they match depends on whether"
" :const:`ASCII` or :const:`LOCALE` mode is in force."
msgstr ""
"``\\w`` ã‚„ ``\\S`` ã®ã‚ˆã†ãªæ–‡å­—ã‚¯ãƒ©ã‚¹ (å¾Œè¿°) ã‚‚é›†åˆå†…ã«æŒ‡å®šã§ãã¾ã™ãŒã€ãã‚Œã‚‰ã«ãƒãƒƒãƒã™ã‚‹æ–‡å­—ã¯ :const:`ASCII` ã‹ "
":const:`LOCALE` ã®ã©ã¡ã‚‰ã‹æœ‰åŠ¹ã«ã•ã‚Œã¦ã„ã‚‹ãƒ¢ãƒ¼ãƒ‰ã«ä¾å­˜ã—ã¾ã™ã€‚"

#: ../../library/re.rst:192
msgid ""
"Characters that are not within a range can be matched by "
":dfn:`complementing` the set.  If the first character of the set is ``'^'``,"
" all the characters that are *not* in the set will be matched.  For example,"
" ``[^5]`` will match any character except ``'5'``, and ``[^^]`` will match "
"any character except ``'^'``.  ``^`` has no special meaning if it's not the "
"first character in the set."
msgstr ""
"ç¯„å›²å†…ã«ãªã„æ–‡å­—ã¨ã¯ã€ãã®é›†åˆã® :dfn:`è£œé›†åˆ` ã‚’ã¨ã‚‹ã“ã¨ã§ãƒãƒƒãƒã§ãã¾ã™ã€‚é›†åˆã®æœ€åˆã®æ–‡å­—ãŒ ``'^'`` ã®æ™‚ã€é›†åˆã« *ãªã„* "
"æ–‡å­—ã™ã¹ã¦ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚ ``[^5]`` ã¯ ``'5'`` ã‚’é™¤ãã‚ã‚‰ã‚†ã‚‹æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ ``[^^]`` ã¯ ``'^'`` "
"ã‚’é™¤ãã‚ã‚‰ã‚†ã‚‹æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ ``^`` ã¯é›†åˆã®æœ€åˆã®æ–‡å­—ã§ãªã„é™ã‚Šç‰¹åˆ¥ã®æ„å‘³ã‚’æŒã¡ã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:199
msgid ""
"To match a literal ``']'`` inside a set, precede it with a backslash, or "
"place it at the beginning of the set.  For example, both ``[()[\\]{}]`` and "
"``[]()[{}]`` will both match a parenthesis."
msgstr ""
"é›†åˆå†…ã§ãƒªãƒ†ãƒ©ãƒ« ``']'`` ã‚’ãƒãƒƒãƒã•ã›ã‚‹ã«ã¯ã€ãã®å‰ã«ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’ã¤ã‘ã‚‹ã‹ã€é›†åˆã®å…ˆé ­ã«ç½®ãã¾ã™ã€‚ ``[()[\\]{}]`` ã¨ "
"``[]()[{}]`` ã¯ã©ã¡ã‚‰ã‚‚ ``']'`` ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:212
msgid "``|``"
msgstr "``|``"

#: ../../library/re.rst:204
msgid ""
"``A|B``, where *A* and *B* can be arbitrary REs, creates a regular "
"expression that will match either *A* or *B*.  An arbitrary number of REs "
"can be separated by the ``'|'`` in this way.  This can be used inside groups"
" (see below) as well.  As the target string is scanned, REs separated by "
"``'|'`` are tried from left to right. When one pattern completely matches, "
"that branch is accepted. This means that once *A* matches, *B* will not be "
"tested further, even if it would produce a longer overall match.  In other "
"words, the ``'|'`` operator is never greedy.  To match a literal ``'|'``, "
"use ``\\|``, or enclose it inside a character class, as in ``[|]``."
msgstr ""
"``A|B`` (*A* ã¨ *B* ã¯ä»»æ„ã® RE) ã¯ã€ *A* ã‹ *B* ã®ã©ã¡ã‚‰ã‹ã¨ãƒãƒƒãƒã™ã‚‹æ­£è¦è¡¨ç¾ã‚’ä½œæˆã—ã¾ã™ã€‚ä»»æ„å€‹æ•°ã® RE "
"ã‚’ã€ã“ã®ã‚ˆã†ã« ``'|'`` ã§åˆ†é›¢ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã¯ã‚°ãƒ«ãƒ¼ãƒ— (ä¸‹è¨˜å‚ç…§) "
"å†…éƒ¨ã§ã‚‚ä½¿ãˆã¾ã™ã€‚èµ°æŸ»å¯¾è±¡æ–‡å­—åˆ—ã‚’ã‚¹ã‚­ãƒ£ãƒ³ã™ã‚‹ä¸­ã§ã€``'|'`` ã§åˆ†é›¢ã•ã‚ŒãŸ RE "
"ã¯å·¦ã‹ã‚‰å³ã¸ã®é †ã«èµ°æŸ»ã•ã‚Œã¾ã™ã€‚ä¸€ã¤ã§ã‚‚å®Œå…¨ã«ãƒãƒƒãƒã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ãŒã‚ã‚Œã°ã€ãã®ãƒ‘ã‚¿ãƒ¼ãƒ³æãŒå—ç†ã•ã‚Œã¾ã™ã€‚ã“ã®ã“ã¨ã¯ã€ã‚‚ã— *A* ãŒãƒãƒƒãƒã™ã‚Œã°ã€ãŸã¨ãˆ"
" *B* ã«ã‚ˆã‚‹ãƒãƒƒãƒãŒå…¨ä½“ã¨ã—ã¦ã‚ˆã‚Šé•·ã„ãƒãƒƒãƒã«ãªã£ãŸã¨ã—ã¦ã‚‚ã€ *B* ã‚’æ±ºã—ã¦èµ°æŸ»ã—ãªã„ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚è¨€ã„ã‹ãˆã‚‹ã¨ã€``'|'`` "
"æ¼”ç®—å­ã¯æ±ºã—ã¦è²ªæ¬² (greedy) ã«ã¯ãªã‚Šã¾ã›ã‚“ã€‚ãƒªãƒ†ãƒ©ãƒ« ``'|'`` ã¨ãƒãƒƒãƒã™ã‚‹ã«ã¯ã€``\\|`` ã‚’ä½¿ã†ã‹ã€ã‚ã‚‹ã„ã¯ ``[|]`` "
"ã®ã‚ˆã†ã«æ–‡å­—ã‚¯ãƒ©ã‚¹å†…ã«å…¥ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:219
msgid "``(...)``"
msgstr "``(...)``"

#: ../../library/re.rst:215
msgid ""
"Matches whatever regular expression is inside the parentheses, and indicates"
" the start and end of a group; the contents of a group can be retrieved "
"after a match has been performed, and can be matched later in the string "
"with the ``\\number`` special sequence, described below.  To match the "
"literals ``'('`` or ``')'``, use ``\\(`` or ``\\)``, or enclose them inside "
"a character class: ``[(]``, ``[)]``."
msgstr ""
"ä¸¸æ‹¬å¼§ã®ä¸­ã«ã©ã®ã‚ˆã†ãªæ­£è¦è¡¨ç¾ãŒã‚ã£ã¦ã‚‚ãƒãƒƒãƒã—ã€ä¸¸æ‹¬å¼§ã¯ã‚°ãƒ«ãƒ¼ãƒ—ã®é–‹å§‹ã¨çµ‚äº†ã‚’è¡¨ã—ã¾ã™; "
"ã‚°ãƒ«ãƒ¼ãƒ—ã®ä¸­èº«ã¯ã€ãƒãƒƒãƒãŒå®Ÿè¡Œã•ã‚ŒãŸå¾Œã«å›åã•ã‚Œã€ç‰¹æ®Šã‚·ãƒ¼ã‚±ãƒ³ã‚¹ ``\\number`` (å¾Œè¿°) ã§å‚ç…§ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒªãƒ†ãƒ©ãƒ« ``'('``"
" ã‚„ ``')'`` ã¨ãƒãƒƒãƒã™ã‚‹ã«ã¯ã€``\\(`` ã‚„ ``\\)`` ã‚’ä½¿ã†ã‹ã€ãã‚Œã‚‰ã‚’æ–‡å­—ã‚¯ãƒ©ã‚¹å†…ã«å…¥ã‚Œã¾ã™:  ``[(]``, "
"``[)]`` ã€‚"

#: ../../library/re.rst:226
msgid "``(?...)``"
msgstr "``(?...)``"

#: ../../library/re.rst:222
msgid ""
"This is an extension notation (a ``'?'`` following a ``'('`` is not "
"meaningful otherwise).  The first character after the ``'?'`` determines "
"what the meaning and further syntax of the construct is. Extensions usually "
"do not create a new group; ``(?P<name>...)`` is the only exception to this "
"rule. Following are the currently supported extensions."
msgstr ""
"ã“ã‚Œã¯æ‹¡å¼µè¨˜æ³•ã§ã™ (``'('`` ã«ç¶šã ``'?'`` ã¯ä»–ã«ã¯æ„å‘³ãŒã‚ã‚Šã¾ã›ã‚“) ã€‚ ``'?'`` "
"ã®å¾Œã®æœ€åˆã®æ–‡å­—ãŒã€ã“ã®æ§‹é€ ã®æ„å‘³ã¨ã“ã‚Œä»¥ä¸Šã®ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ãŒã©ã†ã„ã†ã‚‚ã®ã§ã‚ã‚‹ã‹ã‚’æ±ºå®šã—ã¾ã™ã€‚æ‹¡å¼µè¨˜æ³•ã¯æ™®é€šæ–°ã—ã„ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆã—ã¾ã›ã‚“ï¼› "
"``(?P<name>...)`` ãŒã“ã®è¦å‰‡ã®å”¯ä¸€ã®ä¾‹å¤–ã§ã™ã€‚ä»¥ä¸‹ã«ç¾åœ¨ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹æ‹¡å¼µè¨˜æ³•ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/re.rst:240
msgid "``(?aiLmsux)``"
msgstr "``(?aiLmsux)``"

#: ../../library/re.rst:229
msgid ""
"(One or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``.)  The group matches the empty string; the letters"
" set the corresponding flags: :const:`re.A` (ASCII-only matching), "
":const:`re.I` (ignore case), :const:`re.L` (locale dependent), :const:`re.M`"
" (multi-line), :const:`re.S` (dot matches all), :const:`re.U` (Unicode "
"matching), and :const:`re.X` (verbose), for the entire regular expression. "
"(The flags are described in :ref:`contents-of-module-re`.) This is useful if"
" you wish to include the flags as part of the regular expression, instead of"
" passing a *flag* argument to the :func:`re.compile` function.  Flags should"
" be used first in the expression string."
msgstr ""
"(``'a'``, ``'i'``, ``'L'``, ``'m'``, ``'s'``, ``'u'``, ``'x'`` ã®é›†åˆã«ã‚ã‚‹æ–‡å­—ã‚’ 1 å€‹ä»¥ä¸Šã€‚)\n"
"ã‚°ãƒ«ãƒ¼ãƒ—ã¯ç©ºæ–‡å­—åˆ—ã¨ã‚‚ãƒãƒƒãƒã—ã¾ã™; æ­£è¦è¡¨ç¾å…¨ä½“ã«å¯¾ã—ã¦ã€æ–‡å­—ã«å¯¾å¿œã™ã‚‹ãƒ•ãƒ©ã‚°ã€ :const:`re.A` (ASCII é™å®šãƒãƒƒãƒ)ã€:const:`re.I` (å¤§æ–‡å­—ãƒ»å°æ–‡å­—ã‚’åŒºåˆ¥ã—ãªã„)ã€:const:`re.L` (ãƒ­ã‚±ãƒ¼ãƒ«ä¾å­˜)ã€:const:`re.M` (MULTILINE ãƒ¢ãƒ¼ãƒ‰)ã€:const:`re.S` (DOTALL ãƒ¢ãƒ¼ãƒ‰)ã€ :const:`re.U` (Unicode ãƒãƒƒãƒ)ã€ :const:`re.X` (å†—é•·) ã‚’è¨­å®šã—ã¾ã™ã€‚\n"
"(ãƒ•ãƒ©ã‚°ã«ã¤ã„ã¦ã¯ :ref:`contents-of-module-re` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚)\n"
"ã“ã‚Œã¯ã€*flag* å¼•æ•°ã‚’ :func:`re.compile` é–¢æ•°ã«æ¸¡ã™ã®ã§ã¯ãªãã€ãã®ãƒ•ãƒ©ã‚°ã‚’æ­£è¦è¡¨ç¾ã®ä¸€éƒ¨ã«å«ã‚ãŸã„å ´åˆã«å½¹ç«‹ã¡ã¾ã™ã€‚\n"
"ãƒ•ãƒ©ã‚°ã¯æ­£è¦è¡¨ç¾æ–‡å­—åˆ—ã®å…ˆé ­ã§ä½¿ã†ã¹ãã§ã™ã€‚"

#: ../../library/re.rst:246
msgid "``(?:...)``"
msgstr "``(?:...)``"

#: ../../library/re.rst:243
msgid ""
"A non-capturing version of regular parentheses.  Matches whatever regular "
"expression is inside the parentheses, but the substring matched by the group"
" *cannot* be retrieved after performing a match or referenced later in the "
"pattern."
msgstr ""
"æ­£è¦è¡¨ç¾ã®ä¸¸æ‹¬å¼§ã®å–ã‚Šè¾¼ã¾ãªã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã™ã€‚ã©ã®ã‚ˆã†ãªæ­£è¦è¡¨ç¾ãŒä¸¸æ‹¬å¼§å†…ã«ã‚ã£ã¦ã‚‚ãƒãƒƒãƒã—ã¾ã™ãŒã€ã‚°ãƒ«ãƒ¼ãƒ—ã«ã‚ˆã£ã¦ãƒãƒƒãƒã•ã‚ŒãŸã‚µãƒ–æ–‡å­—åˆ—ã¯ã€ãƒãƒƒãƒã‚’å®Ÿè¡Œã—ãŸã‚ã¨æ¤œç´¢ã•ã‚Œã‚‹ã“ã¨ã‚‚ã€ã‚ã‚‹ã„ã¯å¾Œã§ãƒ‘ã‚¿ãƒ¼ãƒ³ã§å‚ç…§ã•ã‚Œã‚‹ã“ã¨ã‚‚"
" *ã§ãã¾ã›ã‚“* ã€‚"

#: ../../library/re.rst:256
msgid "``(?imsx-imsx:...)``"
msgstr "``(?imsx-imsx:...)``"

#: ../../library/re.rst:249
msgid ""
"(Zero or more letters from the set ``'i'``, ``'m'``, ``'s'``, ``'x'``, "
"optionally followed by ``'-'`` followed by one or more letters from the same"
" set.)  The letters set or removes the corresponding flags: :const:`re.I` "
"(ignore case), :const:`re.M` (multi-line), :const:`re.S` (dot matches all), "
"and :const:`re.X` (verbose), for the part of the expression.  (The flags are"
" described in :ref:`contents-of-module-re`.)"
msgstr ""
"(``'i'``, ``'m'``, ``'s'``, ``'x'`` ã®é›†åˆã«ã‚ã‚‹æ–‡å­—ã‚’ 0 å€‹ä»¥ä¸Šã€ãã‚Œã«ç¶šãã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ãª ``'-'`` ã¨å…ˆç¨‹ã¨åŒã˜é›†åˆã«ã‚ã‚‹æ–‡å­—ã‚’ 1 å€‹ä»¥ä¸Šã€‚)\n"
"æ­£è¦è¡¨ç¾ã®ä¸€éƒ¨ã«å¯¾ã—ã¦ã€æ–‡å­—ã«å¯¾å¿œã™ã‚‹ãƒ•ãƒ©ã‚°ã€:const:`re.I` (å¤§æ–‡å­—ãƒ»å°æ–‡å­—ã‚’åŒºåˆ¥ã—ãªã„), :const:`re.M` (MULTILINE ãƒ¢ãƒ¼ãƒ‰), :const:`re.S` (DOTALL ãƒ¢ãƒ¼ãƒ‰), :const:`re.X` (å†—é•·) ã‚’è¨­å®šã—ãŸã‚Šé™¤å»ã—ãŸã‚Šã—ã¾ã™ã€‚\n"
"(ã“ã‚Œã‚‰ã®ãƒ•ãƒ©ã‚°ã«ã¤ã„ã¦ã¯ :ref:`contents-of-module-re` ã«è§£èª¬ãŒã‚ã‚Šã¾ã™ã€‚)"

#: ../../library/re.rst:281
msgid "``(?P<name>...)``"
msgstr "``(?P<name>...)``"

#: ../../library/re.rst:259
msgid ""
"Similar to regular parentheses, but the substring matched by the group is "
"accessible via the symbolic group name *name*.  Group names must be valid "
"Python identifiers, and each group name must be defined only once within a "
"regular expression.  A symbolic group is also a numbered group, just as if "
"the group were not named."
msgstr ""
"æ­£è¦è¡¨ç¾ã®ä¸¸æ‹¬å¼§ã«ä¼¼ã¦ã„ã¾ã™ãŒã€ã‚°ãƒ«ãƒ¼ãƒ—ã«ã‚ˆã£ã¦ãƒãƒƒãƒã—ãŸéƒ¨åˆ†æ–‡å­—åˆ—ã¯ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯\\ ã‚°ãƒ«ãƒ¼ãƒ—å *name* "
"ã«ã‚ˆã£ã¦ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ã«ãªã‚Šã¾ã™ã€‚ã‚°ãƒ«ãƒ¼ãƒ—åã¯æœ‰åŠ¹ãª Python è­˜åˆ¥å­ã§ãªã‘ã‚Œã°ãªã‚‰ãšã€ã‚°ãƒ«ãƒ¼ãƒ—åã¯ 1 "
"å€‹ã®æ­£è¦è¡¨ç¾å†…ã§ä¸€æ„ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ã‚°ãƒ«ãƒ¼ãƒ—ã¯ç•ªå·ä»˜ã‘ã‚‚ã•ã‚Œã¦ãŠã‚Šã€ç•ªå·ã«ã‚ˆã‚‹ã‚¢ã‚¯ã‚»ã‚¹ã‚‚å¯èƒ½ã§ã™ã€‚"

#: ../../library/re.rst:265
msgid ""
"Named groups can be referenced in three contexts.  If the pattern is "
"``(?P<quote>['\"]).*?(?P=quote)`` (i.e. matching a string quoted with either"
" single or double quotes):"
msgstr ""
"åå‰ä»˜ãã‚°ãƒ«ãƒ¼ãƒ—ã¯ 3 ã¤ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§å‚ç…§ã§ãã¾ã™ã€‚ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒ ``(?P<quote>['\\\"]).*?(?P=quote)`` "
"(ã‚·ãƒ³ã‚°ãƒ«ã¾ãŸã¯ãƒ€ãƒ–ãƒ«ã‚¯ã‚ªãƒ¼ãƒˆã®ã©ã¡ã‚‰ã‹ã«ãƒãƒƒãƒ) ã®å ´åˆ`:"

#: ../../library/re.rst:270
msgid "Context of reference to group \"quote\""
msgstr "ã‚°ãƒ«ãƒ¼ãƒ— \"quote\" ã‚’å‚ç…§ã™ã‚‹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ"

#: ../../library/re.rst:270
msgid "Ways to reference it"
msgstr "å‚ç…§æ–¹æ³•"

#: ../../library/re.rst:272
msgid "in the same pattern itself"
msgstr "åŒä¸€ãƒ‘ã‚¿ãƒ¼ãƒ³ã¸ã®å‚ç…§"

#: ../../library/re.rst:272
msgid "``(?P=quote)`` (as shown)"
msgstr "``(?P=quote)`` (ãã®ã¾ã¾)"

#: ../../library/re.rst:273 ../../library/re.rst:280
msgid "``\\1``"
msgstr "``\\1``"

#: ../../library/re.rst:275
msgid "when processing match object *m*"
msgstr "ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ *m* ã®å‡¦ç†æ™‚"

#: ../../library/re.rst:275
msgid "``m.group('quote')``"
msgstr "``m.group('quote')``"

#: ../../library/re.rst:276
msgid "``m.end('quote')`` (etc.)"
msgstr "``m.end('quote')`` (etc.)"

#: ../../library/re.rst:278
msgid "in a string passed to the *repl* argument of ``re.sub()``"
msgstr "``re.sub()`` ã® *repl* å¼•æ•°ã¸æ¸¡ã•ã‚Œã‚‹æ–‡å­—åˆ—"

#: ../../library/re.rst:278
msgid "``\\g<quote>``"
msgstr "``\\g<quote>``"

#: ../../library/re.rst:279
msgid "``\\g<1>``"
msgstr "``\\g<1>``"

#: ../../library/re.rst:285
msgid "``(?P=name)``"
msgstr "``(?P=name)``"

#: ../../library/re.rst:284
msgid ""
"A backreference to a named group; it matches whatever text was matched by "
"the earlier group named *name*."
msgstr "åå‰ä»˜ãã‚°ãƒ«ãƒ¼ãƒ—ã¸ã®å¾Œæ–¹å‚ç…§ã§ã™; æ—¢å‡ºã®ã‚°ãƒ«ãƒ¼ãƒ—å *name* ã«ãƒãƒƒãƒã™ã‚‹æ–‡å­—åˆ—ã¯ä½•ã«ã§ã‚‚ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:288
msgid "``(?#...)``"
msgstr "``(?#...)``"

#: ../../library/re.rst:288
msgid "A comment; the contents of the parentheses are simply ignored."
msgstr "ã‚³ãƒ¡ãƒ³ãƒˆã§ã™ï¼›æ‹¬å¼§ã®å†…å®¹ã¯å˜ç´”ã«ç„¡è¦–ã•ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:293
msgid "``(?=...)``"
msgstr "``(?=...)``"

#: ../../library/re.rst:291
msgid ""
"Matches if ``...`` matches next, but doesn't consume any of the string.  "
"This is called a :dfn:`lookahead assertion`.  For example, ``Isaac "
"(?=Asimov)`` will match ``'Isaac '`` only if it's followed by ``'Asimov'``."
msgstr ""
"``...`` ãŒæ¬¡ã«ç¶šãã‚‚ã®ã¨ãƒãƒƒãƒã™ã‚Œã°ãƒãƒƒãƒã—ã¾ã™ãŒã€æ–‡å­—åˆ—ã‚’ã¾ã£ãŸãæ¶ˆè²»ã—ã¾ã›ã‚“ã€‚ã“ã‚Œã¯ :dfn:`å…ˆèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ (lookahead "
"assertion)` ã¨å‘¼ã°ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€``Isaac (?=Asimov)`` ã¯ã€``'Isaac '`` ã« ``'Asimov'`` "
"ãŒç¶šãå ´åˆã ã‘ã€``'Isaac '`` ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:298
msgid "``(?!...)``"
msgstr "``(?!...)``"

#: ../../library/re.rst:296
msgid ""
"Matches if ``...`` doesn't match next.  This is a :dfn:`negative lookahead "
"assertion`. For example, ``Isaac (?!Asimov)`` will match ``'Isaac '`` only "
"if it's *not* followed by ``'Asimov'``."
msgstr ""
"``...`` ãŒæ¬¡ã«ç¶šãã‚‚ã®ã¨ãƒãƒƒãƒã—ãªã‘ã‚Œã°ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã¯ :dfn:`å¦å®šå…ˆèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ (negative lookahead "
"assertion)` ã§ã™ã€‚ä¾‹ãˆã°ã€``Isaac (?!Asimov)`` ã¯ã€``'Isaac '`` ã« ``'Asimov'`` ãŒç¶šã‹ "
"*ãªã„* å ´åˆã®ã¿ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:323
msgid "``(?<=...)``"
msgstr "``(?<=...)``"

#: ../../library/re.rst:301
msgid ""
"Matches if the current position in the string is preceded by a match for "
"``...`` that ends at the current position.  This is called a :dfn:`positive "
"lookbehind assertion`. ``(?<=abc)def`` will find a match in ``'abcdef'``, "
"since the lookbehind will back up 3 characters and check if the contained "
"pattern matches. The contained pattern must only match strings of some fixed"
" length, meaning that ``abc`` or ``a|b`` are allowed, but ``a*`` and "
"``a{3,4}`` are not.  Note that patterns which start with positive lookbehind"
" assertions will not match at the beginning of the string being searched; "
"you will most likely want to use the :func:`search` function rather than the"
" :func:`match` function:"
msgstr ""
"æ–‡å­—åˆ—å†…ã®ç¾åœ¨ä½ç½®ã®å‰ã«ã€ç¾åœ¨ä½ç½®ã§çµ‚ã‚ã‚‹ ``...`` ã¨ã®ãƒãƒƒãƒãŒã‚ã‚Œã°ã€ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã¯ :dfn:`å¾Œèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³` "
"ã¨å‘¼ã°ã‚Œã¾ã™ã€‚``(?<=abc)def`` ã¯ ``'abcdef'`` ã«ãƒãƒƒãƒã‚’è¦‹ã¤ã‘ã¾ã™ã€‚å¾Œèª­ã¿ã¯ 3 "
"æ–‡å­—ã‚’ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã—ã€å«ã¾ã‚Œã¦ã„ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ãƒãƒƒãƒã™ã‚‹ã‹ã©ã†ã‹æ¤œæŸ»ã—ã¾ã™ã€‚å«ã¾ã‚Œã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€å›ºå®šé•·ã®æ–‡å­—åˆ—ã«ã®ã¿ãƒãƒƒãƒã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã™ãªã‚ã¡ã€``abc``"
" ã‚„ ``a|b`` ã¯è¨±ã•ã‚Œã¾ã™ãŒã€``a*`` ã‚„ ``a{3,4}`` "
"ã¯è¨±ã•ã‚Œã¾ã›ã‚“ã€‚è‚¯å®šå¾Œèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã§å§‹ã¾ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€æ¤œç´¢ã•ã‚Œã‚‹æ–‡å­—åˆ—ã®å…ˆé ­ã¨ã¯æ±ºã—ã¦ãƒãƒƒãƒã—ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ä¸‹ã•ã„; "
"ã“ã®è¡¨ç¾ã‚’ä½¿ç”¨ã™ã‚‹ã®ã¯ã€ãŠãã‚‰ã :func:`match` é–¢æ•°ã‚ˆã‚Š :func:`search` é–¢æ•°ã®æ–¹ãŒé©ã—ã¦ã„ã¾ã™:"

#: ../../library/re.rst:316
msgid "This example looks for a word following a hyphen:"
msgstr "ã“ã®ä¾‹ã§ã¯ãƒã‚¤ãƒ•ãƒ³ã«ç¶šãå˜èªã‚’æ¢ã—ã¾ã™:"

#: ../../library/re.rst:322
msgid "Added support for group references of fixed length."
msgstr "å›ºå®šé•·ã®ã‚°ãƒ«ãƒ¼ãƒ—å‚ç…§ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/re.rst:330
msgid "``(?<!...)``"
msgstr "``(?<!...)``"

#: ../../library/re.rst:326
msgid ""
"Matches if the current position in the string is not preceded by a match for"
" ``...``.  This is called a :dfn:`negative lookbehind assertion`.  Similar "
"to positive lookbehind assertions, the contained pattern must only match "
"strings of some fixed length.  Patterns which start with negative lookbehind"
" assertions may match at the beginning of the string being searched."
msgstr ""
"æ–‡å­—åˆ—å†…ã®ç¾åœ¨ä½ç½®ã®å‰ã« ``...`` ã¨ã®ãƒãƒƒãƒãŒãªã„å ´åˆã«ã€ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã¯ :dfn:`å¦å®šå¾Œèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³(negative "
"lookbehind assertion)` "
"ã¨å‘¼ã°ã‚Œã¾ã™ã€‚è‚¯å®šå¾Œèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã¨åŒæ§˜ã«ã€å«ã¾ã‚Œã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯å›ºå®šé•·ã•ã®æ–‡å­—åˆ—ã ã‘ã«ãƒãƒƒãƒã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å¦å®šå¾Œèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã§å§‹ã¾ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€æ¤œç´¢ã•ã‚Œã‚‹æ–‡å­—åˆ—ã®å…ˆé ­ã¨ãƒãƒƒãƒã§ãã¾ã™ã€‚"

#: ../../library/re.rst:339
msgid "``(?(id/name)yes-pattern|no-pattern)``"
msgstr "``(?(id/name)yes-pattern|no-pattern)``"

#: ../../library/re.rst:333
msgid ""
"Will try to match with ``yes-pattern`` if the group with given *id* or "
"*name* exists, and with ``no-pattern`` if it doesn't. ``no-pattern`` is "
"optional and can be omitted. For example, "
"``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>|$)`` is a poor email matching pattern, "
"which will match with ``'<user@host.com>'`` as well as ``'user@host.com'``, "
"but not with ``'<user@host.com'`` nor ``'user@host.com>'``."
msgstr ""
"ä¸ãˆã‚‰ã‚ŒãŸã‚°ãƒ«ãƒ¼ãƒ— *id* ã‚ã‚‹ã„ã¯ *name* ãŒå­˜åœ¨ã™ã‚‹å ´åˆã€``yes-pattern`` ã¨ã®ãƒãƒƒãƒã‚’ã€å­˜åœ¨ã—ãªã„å ´åˆ ``no-"
"pattern`` ã¨ã®ãƒãƒƒãƒã‚’è©¦ã¿ã¾ã™ã€‚``no-pattern`` "
"ã¯çœç•¥å¯èƒ½ã§ã™ã€‚ä¾‹ãˆã°ã€``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>|$)`` ã¯è²§å¼±ãª E-mail "
"ãƒãƒƒãƒãƒ³ã‚°ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã€``'<user@host.com>'`` ã‚„ ``'user@host.com'`` "
"ã«ãƒãƒƒãƒã—ã¾ã™ãŒã€``'<user@host.com'`` ã‚„ ``'user@host.com>'`` ã¨ã¯ãƒãƒƒãƒã—ã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:341
msgid ""
"The special sequences consist of ``'\\'`` and a character from the list "
"below. If the ordinary character is not an ASCII digit or an ASCII letter, "
"then the resulting RE will match the second character.  For example, ``\\$``"
" matches the character ``'$'``."
msgstr ""
"ç‰¹æ®Šã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ ``'\\'`` ã¨ä»¥ä¸‹ã®ãƒªã‚¹ãƒˆã®æ–‡å­—ã‹ã‚‰æ§‹æˆã•ã‚Œã¾ã™ã€‚\n"
"ASCII ã®æ•°å€¤ã‚„ ASCII ã®æ–‡å­—ã§ãªã„é€šå¸¸ã®æ–‡å­—ã®å ´åˆã€ RE ã¯ 2 ç•ªç›®ã®æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚\n"
"ä¾‹ãˆã°ã€``\\$`` ã¯æ–‡å­— ``'$'`` ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:354
msgid "``\\number``"
msgstr "``\\number``"

#: ../../library/re.rst:347
msgid ""
"Matches the contents of the group of the same number.  Groups are numbered "
"starting from 1.  For example, ``(.+) \\1`` matches ``'the the'`` or ``'55 "
"55'``, but not ``'thethe'`` (note the space after the group).  This special "
"sequence can only be used to match one of the first 99 groups.  If the first"
" digit of *number* is 0, or *number* is 3 octal digits long, it will not be "
"interpreted as a group match, but as the character with octal value "
"*number*. Inside the ``'['`` and ``']'`` of a character class, all numeric "
"escapes are treated as characters."
msgstr ""
"åŒã˜ç•ªå·ã®ã‚°ãƒ«ãƒ¼ãƒ—ã®ä¸­èº«ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚ã‚°ãƒ«ãƒ¼ãƒ—ã¯1ã‹ã‚‰å§‹ã¾ã‚‹ç•ªå·ã‚’ã¤ã‘ã‚‰ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ ``(.+) \\1`` ã¯ã€ ``'the the'`` "
"ã‚ã‚‹ã„ã¯ ``'55 55'`` ã¨ãƒãƒƒãƒã—ã¾ã™ãŒã€ ``'thethe'`` "
"ã¨ã¯ãƒãƒƒãƒã—ã¾ã›ã‚“(ã‚°ãƒ«ãƒ¼ãƒ—ã®å¾Œã®ã‚¹ãƒšãƒ¼ã‚¹ã«æ³¨æ„ã—ã¦ä¸‹ã•ã„)ã€‚ã“ã®ç‰¹æ®Šã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯æœ€åˆã® 99 "
"ã‚°ãƒ«ãƒ¼ãƒ—ã®ã†ã¡ã®ä¸€ã¤ã¨ãƒãƒƒãƒã™ã‚‹ã®ã«ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã ã‘ã§ã™ã€‚ã‚‚ã— *number* ã®æœ€åˆã®æ¡ãŒ 0 ã§ã‚ã‚‹ã€ã™ãªã‚ã¡ *number* ãŒ 3 "
"æ¡ã®8é€²æ•°ã§ã‚ã‚Œã°ã€ãã‚Œã¯ã‚°ãƒ«ãƒ¼ãƒ—ã®ãƒãƒƒãƒã¨ã¯è§£é‡ˆã•ã‚Œãšã€ 8é€²æ•°å€¤ *number* ã‚’æŒã¤æ–‡å­—ã¨ã—ã¦è§£é‡ˆã•ã‚Œã¾ã™ã€‚æ–‡å­—ã‚¯ãƒ©ã‚¹ã® ``'['`` ã¨ "
"``']'`` ã®ä¸­ã®æ•°å€¤ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã¯ã€æ–‡å­—ã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:357
msgid "``\\A``"
msgstr "``\\A``"

#: ../../library/re.rst:357
msgid "Matches only at the start of the string."
msgstr "æ–‡å­—åˆ—ã®å…ˆé ­ã ã‘ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:371
msgid "``\\b``"
msgstr "``\\b``"

#: ../../library/re.rst:360
msgid ""
"Matches the empty string, but only at the beginning or end of a word. A word"
" is defined as a sequence of word characters.  Note that formally, ``\\b`` "
"is defined as the boundary between a ``\\w`` and a ``\\W`` character (or "
"vice versa), or between ``\\w`` and the beginning/end of the string. This "
"means that ``r'\\bfoo\\b'`` matches ``'foo'``, ``'foo.'``, ``'(foo)'``, "
"``'bar foo baz'`` but not ``'foobar'`` or ``'foo3'``."
msgstr ""
"ç©ºæ–‡å­—åˆ—ã¨ãƒãƒƒãƒã—ã¾ã™ãŒã€å˜èªã®å…ˆé ­ã‹æœ«å°¾ã®æ™‚ã ã‘ã§ã™ã€‚\n"
"å˜èªã¨ã¯å˜èªæ–‡å­—ã®ä¸¦ã³ã¨ã—ã¦å®šç¾©ã•ã‚Œã¾ã™ã€‚\n"
"å½¢å¼çš„ã«è¨˜è¿°ã™ã‚‹ã¨ã€ ``\\b`` ã¯ ``\\w`` æ–‡å­—ãŠã‚ˆã³ ``\\W`` æ–‡å­—ã®é–“ (ãŠã‚ˆã³ãã®é€†)ã€ã‚ã‚‹ã„ã¯ ``\\w`` ã¨æ–‡å­—åˆ—ã®é–‹å§‹/çµ‚äº†ã¨ã®é–“ã®å¢ƒç•Œã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚\n"
"ä¾‹ãˆã°ã€``r'\\bfoo\\b'`` ã¯ ``'foo'`` , ``'foo.'`` , ``'(foo)'``, ``'bar foo baz'`` ã«ãƒãƒƒãƒã—ã¾ã™ãŒã€``'foobar'``, ``'foo3'`` ã«ã¯ãƒãƒƒãƒã—ã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:367
msgid ""
"By default Unicode alphanumerics are the ones used in Unicode patterns, but "
"this can be changed by using the :const:`ASCII` flag.  Word boundaries are "
"determined by the current locale if the :const:`LOCALE` flag is used. Inside"
" a character range, ``\\b`` represents the backspace character, for "
"compatibility with Python's string literals."
msgstr ""

#: ../../library/re.rst:380
msgid "``\\B``"
msgstr "``\\B``"

#: ../../library/re.rst:374
msgid ""
"Matches the empty string, but only when it is *not* at the beginning or end "
"of a word.  This means that ``r'py\\B'`` matches ``'python'``, ``'py3'``, "
"``'py2'``, but not ``'py'``, ``'py.'``, or ``'py!'``. ``\\B`` is just the "
"opposite of ``\\b``, so word characters in Unicode patterns are Unicode "
"alphanumerics or the underscore, although this can be changed by using the "
":const:`ASCII` flag.  Word boundaries are determined by the current locale "
"if the :const:`LOCALE` flag is used."
msgstr ""

#: ../../library/re.rst:392
msgid "``\\d``"
msgstr "``\\d``"

#: ../../library/re.rst:389 ../../library/re.rst:409 ../../library/re.rst:429
msgid "For Unicode (str) patterns:"
msgstr "ãƒ¦ãƒ‹ã‚³ãƒ¼ãƒ‰ (str) ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¯¾ã—ã¦:"

#: ../../library/re.rst:384
msgid ""
"Matches any Unicode decimal digit (that is, any character in Unicode "
"character category [Nd]).  This includes ``[0-9]``, and also many other "
"digit characters.  If the :const:`ASCII` flag is used only ``[0-9]`` is "
"matched (but the flag affects the entire regular expression, so in such "
"cases using an explicit ``[0-9]`` may be a better choice)."
msgstr ""
"ä»»æ„ã® Unicode 10é€²æ•° (Unicode æ–‡å­—ã‚«ãƒ†ã‚´ãƒª [Nd]) ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã«ã¯ ``[0-9]`` ã¨ãã®ä»–ã® 10 "
"é€²æ•°æ–‡å­—ãŒå«ã¾ã‚Œã¾ã™ã€‚:const:`ASCII` ãŒä½¿ç”¨ã•ã‚ŒãŸå ´åˆã€``[0-9]`` "
"ã®ã¿ãƒãƒƒãƒã—ã¾ã™ã€‚ãŸã ã—ã€ã“ã®ãƒ•ãƒ©ã‚°ã¯æ­£è¦è¡¨ç¾å…¨ä½“ã«ä½œç”¨ã—ã¾ã™ã®ã§ã€æ˜ç¤ºçš„ã« ``[0-9]`` ã¨æŒ‡å®šã™ã‚‹æ–¹ãŒè‰¯ã„å ´åˆãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:392 ../../library/re.rst:413 ../../library/re.rst:435
msgid "For 8-bit (bytes) patterns:"
msgstr "8bit (bytes) ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¯¾ã—ã¦:"

#: ../../library/re.rst:392
msgid "Matches any decimal digit; this is equivalent to ``[0-9]``."
msgstr "ä»»æ„ã® 10 é€²æ•°ã«ãƒãƒƒãƒã—ã¾ã™; ã“ã‚Œã¯ ``[0-9]`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/re.rst:399
msgid "``\\D``"
msgstr "``\\D``"

#: ../../library/re.rst:395
msgid ""
"Matches any character which is not a decimal digit. This is the opposite of "
"``\\d``. If the :const:`ASCII` flag is used this becomes the equivalent of "
"``[^0-9]`` (but the flag affects the entire regular expression, so in such "
"cases using an explicit ``[^0-9]`` may be a better choice)."
msgstr ""
"ä»»æ„ã®é 10 é€²æ•°æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã¯ ``\\d`` ã®åå¯¾ã§ã™ã€‚:const:`ASCII` ãƒ•ãƒ©ã‚°ã‚’ä½¿ç”¨ã™ã‚‹ã¨ ``[^0-9]`` "
"ã¨ç­‰ä¾¡ã«ãªã‚Šã¾ã™ (ãŸã ã—ã€ã“ã®ãƒ•ãƒ©ã‚°ã¯æ­£è¦è¡¨ç¾å…¨ä½“ã«ä½œç”¨ã—ã¾ã™ã®ã§ã€æ˜ç¤ºçš„ã« ``[^0-9]`` ã¨æŒ‡å®šã™ã‚‹æ–¹ãŒè‰¯ã„ã§ã—ã‚‡ã†)ã€‚"

#: ../../library/re.rst:413
msgid "``\\s``"
msgstr "``\\s``"

#: ../../library/re.rst:403
msgid ""
"Matches Unicode whitespace characters (which includes ``[ "
"\\t\\n\\r\\f\\v]``, and also many other characters, for example the non-"
"breaking spaces mandated by typography rules in many languages). If the "
":const:`ASCII` flag is used, only ``[ \\t\\n\\r\\f\\v]`` is matched (but the"
" flag affects the entire regular expression, so in such cases using an "
"explicit ``[ \\t\\n\\r\\f\\v]`` may be a better choice)."
msgstr ""
"ä»»æ„ã®ç©ºç™½æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã«ã¯ ``[ \\t\\n\\r\\f\\v]`` "
"ãŠã‚ˆã³ãƒãƒ¼ãƒ–ãƒ¬ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ãªã©ã€å¤šãã®è¨€èªã«ãŠã‘ã‚‹ã‚¿ã‚¤ãƒã‚°ãƒ©ãƒ•ã‚£è¦å‰‡ã§å®šç¾©ã•ã‚ŒãŸæ–‡å­—ãŒå«ã¾ã‚Œã¾ã™ã€‚:const:`ASCII` "
"ãƒ•ãƒ©ã‚°ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€``[ \\t\\n\\r\\f\\v]`` ã®ã¿ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ãŸã ã—ã€ã“ã®ãƒ•ãƒ©ã‚°ã¯æ­£è¦è¡¨ç¾å…¨ä½“ã«ä½œç”¨ã—ã¾ã™ã®ã§ã€æ˜ç¤ºçš„ã« ``["
" \\t\\n\\r\\f\\v]`` ã¨æŒ‡å®šã™ã‚‹æ–¹ãŒè‰¯ã„å ´åˆãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:412
msgid ""
"Matches characters considered whitespace in the ASCII character set; this is"
" equivalent to ``[ \\t\\n\\r\\f\\v]``."
msgstr "ASCII æ–‡å­—ã‚»ãƒƒãƒˆã«ãŠã‘ã‚‹ç©ºç™½æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã¯ ``[ \\t\\n\\r\\f\\v]`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/re.rst:420
msgid "``\\S``"
msgstr "``\\S``"

#: ../../library/re.rst:416
msgid ""
"Matches any character which is not a whitespace character. This is the "
"opposite of ``\\s``. If the :const:`ASCII` flag is used this becomes the "
"equivalent of ``[^ \\t\\n\\r\\f\\v]`` (but the flag affects the entire "
"regular expression, so in such cases using an explicit ``[^ "
"\\t\\n\\r\\f\\v]`` may be a better choice)."
msgstr ""
"ä»»æ„ã®éç©ºç™½æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã¯ ``\\s`` ã®åå¯¾ã§ã™ã€‚:const:`ASCII` ãƒ•ãƒ©ã‚°ã‚’ä½¿ç”¨ã™ã‚‹ã¨ ``[^ "
"\\t\\n\\r\\f\\v]`` ã¨ç­‰ä¾¡ã«ãªã‚Šã¾ã™ (ãŸã ã—ã€ã“ã®ãƒ•ãƒ©ã‚°ã¯æ­£è¦è¡¨ç¾å…¨ä½“ã«ä½œç”¨ã—ã¾ã™ã®ã§ã€æ˜ç¤ºçš„ã« ``[^ "
"\\t\\n\\r\\f\\v]`` ã¨æŒ‡å®šã™ã‚‹æ–¹ãŒè‰¯ã„ã§ã—ã‚‡ã†)ã€‚"

#: ../../library/re.rst:435
msgid "``\\w``"
msgstr "``\\w``"

#: ../../library/re.rst:424
msgid ""
"Matches Unicode word characters; this includes most characters that can be "
"part of a word in any language, as well as numbers and the underscore. If "
"the :const:`ASCII` flag is used, only ``[a-zA-Z0-9_]`` is matched (but the "
"flag affects the entire regular expression, so in such cases using an "
"explicit ``[a-zA-Z0-9_]`` may be a better choice)."
msgstr ""
"ä»»æ„ã® Unicode "
"å˜èªæ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã«ã¯ã‚ã‚‰ã‚†ã‚‹è¨€èªã§å˜èªã®ä¸€éƒ¨ã«ãªã‚Šã†ã‚‹æ–‡å­—ã€æ•°å­—ã€ãŠã‚ˆã³ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ãŒå«ã¾ã‚Œã¾ã™ã€‚:const:`ASCII` "
"ãƒ•ãƒ©ã‚°ã‚’ä½¿ç”¨ã™ã‚‹ã¨ ``[a-zA-Z0-9_]`` ã®ã¿ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ãŸã ã—ã€ã“ã®ãƒ•ãƒ©ã‚°ã¯æ­£è¦è¡¨ç¾å…¨ä½“ã«ä½œç”¨ã—ã¾ã™ã®ã§ã€æ˜ç¤ºçš„ã« "
"``[a-zA-Z0-9_]`` ã¨æŒ‡å®šã™ã‚‹æ–¹ãŒè‰¯ã„å ´åˆãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:432
msgid ""
"Matches characters considered alphanumeric in the ASCII character set; this "
"is equivalent to ``[a-zA-Z0-9_]``.  If the :const:`LOCALE` flag is used, "
"matches characters considered alphanumeric in the current locale and the "
"underscore."
msgstr ""
"ASCII æ–‡å­—ã‚»ãƒƒãƒˆã§ã®è‹±æ•°å­—ã¨ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã¯ ``[a-zA-Z0-9_]`` ã¨ç­‰ä¾¡ã§ã™ã€‚\n"
":const:`LOCALE` ãŒä½¿ã‚ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ç¾åœ¨ã®ãƒ­ã‚±ãƒ¼ãƒ«ã§è‹±æ•°å­—ã¨è¦‹ãªã›ã‚‹æ–‡å­—ã¨ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:444
msgid "``\\W``"
msgstr "``\\W``"

#: ../../library/re.rst:438
msgid ""
"Matches any character which is not a word character. This is the opposite of"
" ``\\w``. If the :const:`ASCII` flag is used this becomes the equivalent of "
"``[^a-zA-Z0-9_]`` (but the flag affects the entire regular expression, so in"
" such cases using an explicit ``[^a-zA-Z0-9_]`` may be a better choice).  If"
" the :const:`LOCALE` flag is used, matches characters considered "
"alphanumeric in the current locale and the underscore."
msgstr ""
"ä»»æ„ã®éå˜èªæ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã¯ ``\\w`` ã®åå¯¾ã§ã™ã€‚:const:`ASCII` ãƒ•ãƒ©ã‚°ã‚’ä½¿ç”¨ã—ãŸå ´åˆã€``[^a-zA-Z0-9_]`` ã¨ç­‰ä¾¡ã«ãªã‚Šã¾ã™ (ãŸã ã—ã€ã“ã®ãƒ•ãƒ©ã‚°ã¯æ­£è¦è¡¨ç¾å…¨ä½“ã«ä½œç”¨ã—ã¾ã™ã®ã§ã€æ˜ç¤ºçš„ã« ``[^a-zA-Z0-9_]`` ã¨æŒ‡å®šã™ã‚‹æ–¹ãŒè‰¯ã„å ´åˆãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“)ã€‚\n"
":const:`LOCALE` ãŒä½¿ã‚ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ç¾åœ¨ã®ãƒ­ã‚±ãƒ¼ãƒ«ã§è‹±æ•°å­—ã¨è¦‹ãªã›ã‚‹æ–‡å­—ã¨ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:447
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../../library/re.rst:447
msgid "Matches only at the end of the string."
msgstr "æ–‡å­—åˆ—ã®æœ«å°¾ã¨ã®ã¿ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:449
msgid ""
"Most of the standard escapes supported by Python string literals are also "
"accepted by the regular expression parser::"
msgstr "Python æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã«ã‚ˆã£ã¦ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹æ¨™æº–ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã®ã»ã¨ã‚“ã©ã‚‚ã€æ­£è¦è¡¨ç¾ãƒ‘ãƒ¼ã‚¶ã«ã‚ˆã£ã¦èªè­˜ã•ã‚Œã¾ã™::"

#: ../../library/re.rst:456
msgid ""
"(Note that ``\\b`` is used to represent word boundaries, and means "
"\"backspace\" only inside character classes.)"
msgstr "(``\\b`` ã¯å˜èªã®å¢ƒç•Œã‚’è¡¨ã—ã€æ–‡å­—ã‚¯ãƒ©ã‚¹å†…ã§ã®ã¿å¾Œé€€ (backspace) æ–‡å­—ã‚’æŒ‡ã™ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„)"

#: ../../library/re.rst:459
msgid ""
"``'\\u'`` and ``'\\U'`` escape sequences are only recognized in Unicode "
"patterns.  In bytes patterns they are errors."
msgstr ""
"``'\\u'`` ãŠã‚ˆã³ ``'\\U'`` ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ Unicode ãƒ‘ã‚¿ãƒ¼ãƒ³å†…ã§ã®ã¿èªè­˜ã•ã‚Œã¾ã™ã€‚ãƒã‚¤ãƒˆåˆ—ã§ã¯ã‚¨ãƒ©ãƒ¼ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/re.rst:462
msgid ""
"Octal escapes are included in a limited form.  If the first digit is a 0, or"
" if there are three octal digits, it is considered an octal escape. "
"Otherwise, it is a group reference.  As for string literals, octal escapes "
"are always at most three digits in length."
msgstr ""
"8 é€²æ•°ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã¯é™ã‚‰ã‚ŒãŸå½¢å¼ã§è¡¨ã—ã¾ã™ã€‚æœ€åˆã®æ¡ãŒ 0 ã‹ã€ã‚ã‚‹ã„ã¯ 3 æ¡ã® 8 é€²æ•°ãªã‚‰ã°ã€8 "
"é€²æ•°ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ã‚°ãƒ«ãƒ¼ãƒ—å‚ç…§ã«ãªã‚Šã¾ã™ã€‚æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã«é–¢ã—ã¦ã¯ã€8 é€²æ•°ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã¯ã»ã¨ã‚“ã©ã®å ´åˆ 3 æ¡é•·ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/re.rst:467
msgid "The ``'\\u'`` and ``'\\U'`` escape sequences have been added."
msgstr "``'\\u'`` ã¨ ``'\\U'`` ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/re.rst:470
msgid ""
"Unknown escapes consisting of ``'\\'`` and an ASCII letter now are errors."
msgstr "``'\\'`` ã¨ ASCII æ–‡å­—ã‹ã‚‰ãªã‚‹æœªçŸ¥ã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã¯ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/re.rst:478
msgid "Module Contents"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚³ãƒ³ãƒ†ãƒ³ãƒ„"

#: ../../library/re.rst:480
msgid ""
"The module defines several functions, constants, and an exception. Some of "
"the functions are simplified versions of the full featured methods for "
"compiled regular expressions.  Most non-trivial applications always use the "
"compiled form."
msgstr ""
"ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã„ãã¤ã‹ã®é–¢æ•°ã€å®šæ•°ã€ä¾‹å¤–ã‚’å®šç¾©ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã®ä¸€éƒ¨ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ãŸæ­£è¦è¡¨ç¾ã®å®Œå…¨ç‰ˆãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç°¡ç•¥åŒ–ã—ãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã™ã€‚ç°¡å˜ãªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é™¤ãã»ã¨ã‚“ã©ã§ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸå½¢å¼ãŒç”¨ã„ã‚‰ã‚Œã‚‹ã®ãŒæ™®é€šã§ã™ã€‚"

#: ../../library/re.rst:485
msgid ""
"Flag constants are now instances of :class:`RegexFlag`, which is a subclass "
"of :class:`enum.IntFlag`."
msgstr ""
"ãƒ•ãƒ©ã‚°å®šæ•°ã¯ã€:class:`enum.IntFlag` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚ã‚‹ :class:`RegexFlag` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ãªã‚Šã¾ã—ãŸã€"

#: ../../library/re.rst:491
msgid ""
"Compile a regular expression pattern into a :ref:`regular expression object "
"<re-objects>`, which can be used for matching using its "
":func:`~regex.match`, :func:`~regex.search` and other methods, described "
"below."
msgstr ""
"æ­£è¦è¡¨ç¾ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ :ref:`æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <re-objects>` ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ä»¥ä¸‹ã§è¿°ã¹ã‚‹ "
":func:`~regex.match` ã‚„ :func:`~regex.search` ã‚„ä»–ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦ã€ãƒãƒƒãƒãƒ³ã‚°ã«ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/re.rst:496
msgid ""
"The expression's behaviour can be modified by specifying a *flags* value. "
"Values can be any of the following variables, combined using bitwise OR (the"
" ``|`` operator)."
msgstr ""
"å¼ã®å‹•ä½œã¯ã€ *flags* ã®å€¤ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã§åŠ æ¸›ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚å€¤ã¯ä»¥ä¸‹ã®å¤‰æ•°ã‚’ã€ãƒ“ãƒƒãƒˆã”ã¨ã® OR ( ``|`` "
"æ¼”ç®—å­)ã‚’ä½¿ã£ã¦çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/re.rst:500
msgid "The sequence ::"
msgstr "ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ ::"

#: ../../library/re.rst:505
msgid "is equivalent to ::"
msgstr "ã¯ã€ä»¥ä¸‹ã¨åŒç­‰ã§ã™ ::"

#: ../../library/re.rst:509
msgid ""
"but using :func:`re.compile` and saving the resulting regular expression "
"object for reuse is more efficient when the expression will be used several "
"times in a single program."
msgstr ""
"ãŸã ã—ã€ãã®å¼ã‚’ä¸€ã¤ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ä½•å›ã‚‚ä½¿ã†å ´åˆã«ã¯ã€ :func:`re.compile` "
"ã‚’ä½¿ã£ã¦ãã®çµæœã®æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å†åˆ©ç”¨ã—ãŸæ–¹ãŒã‚ˆã‚ŠåŠ¹ç‡çš„ã§ã™ã€‚"

#: ../../library/re.rst:515
msgid ""
"The compiled versions of the most recent patterns passed to "
":func:`re.compile` and the module-level matching functions are cached, so "
"programs that use only a few regular expressions at a time needn't worry "
"about compiling regular expressions."
msgstr ""
":func:`re.compile` "
"ã«æ¸¡ã•ã‚Œã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸæœ€æ–°ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«ã®ãƒãƒƒãƒãƒ³ã‚°é–¢æ•°ã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚Œã‚‹ã®ã§ã€ä¸€åº¦ã«å°‘ã—ã®æ­£è¦è¡¨ç¾ã—ã‹ä½¿ã‚ãªã„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯æ­£è¦è¡¨ç¾ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã«ã¤ã„ã¦å¿ƒé…ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:524
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` and "
"``\\S`` perform ASCII-only matching instead of full Unicode matching.  This "
"is only meaningful for Unicode patterns, and is ignored for byte patterns. "
"Corresponds to the inline flag ``(?a)``."
msgstr ""
"``\\w``ã€``\\W``ã€``\\b``ã€``\\B``ã€``\\d``ã€``\\D``ã€``\\s``ã€ãŠã‚ˆã³ ``\\S`` ã«ãŠã„ã¦ã€ASCII æ–‡å­—ã®ã¿ã§ãƒãƒƒãƒãƒ³ã‚°ã‚’è¡Œã„ã¾ã™ã€‚ã“ã‚Œã¯ Unicode ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã®ã¿æ„å‘³ãŒã‚ã‚Šã€ãƒã‚¤ãƒˆåˆ—ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚\n"
"ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒ•ãƒ©ã‚°ã® ``(?a)`` ã«ç›¸å½“ã—ã¾ã™ã€‚"

#: ../../library/re.rst:529
msgid ""
"Note that for backward compatibility, the :const:`re.U` flag still exists "
"(as well as its synonym :const:`re.UNICODE` and its embedded counterpart "
"``(?u)``), but these are redundant in Python 3 since matches are Unicode by "
"default for strings (and Unicode matching isn't allowed for bytes)."
msgstr ""
"å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã€:const:`re.U` ãƒ•ãƒ©ã‚° (ãŠã‚ˆã³ãã‚Œã¨åŒç¾©ã® :const:`re.UNICODE` ã¨åŸ‹ã‚è¾¼ã¿ã§ä½¿ç”¨ã™ã‚‹ "
"``(?u)``) ã¯ã¾ã å­˜åœ¨ã—ã¦ã„ã¾ã™ãŒã€æ–‡å­—åˆ—ã®ãƒãƒƒãƒã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãŒ Unicode ã«ãªã£ãŸ Python 3 ã§ã¯å†—é•·ã§ã™ (ãã—ã¦ "
"Unicode ãƒãƒƒãƒãƒ³ã‚°ã§ã¯ãƒã‚¤ãƒˆåˆ—ã¯æ‰±ãˆã¾ã›ã‚“)ã€‚"

#: ../../library/re.rst:538
msgid ""
"Display debug information about compiled expression. No corresponding inline"
" flag."
msgstr ""
"ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ãŸè¡¨ç¾ã«é–¢ã™ã‚‹ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚\n"
"ç›¸å½“ã™ã‚‹ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒ•ãƒ©ã‚°ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:545
msgid ""
"Perform case-insensitive matching; expressions like ``[A-Z]`` will also "
"match lowercase letters.  Full Unicode matching (such as ``Ãœ`` matching "
"``Ã¼``) also works unless the :const:`re.ASCII` flag is used to disable non-"
"ASCII matches.  The current locale does not change the effect of this flag "
"unless the :const:`re.LOCALE` flag is also used. Corresponds to the inline "
"flag ``(?i)``."
msgstr ""

#: ../../library/re.rst:552
msgid ""
"Note that when the Unicode patterns ``[a-z]`` or ``[A-Z]`` are used in "
"combination with the :const:`IGNORECASE` flag, they will match the 52 ASCII "
"letters and 4 additional non-ASCII letters: 'Ä°' (U+0130, Latin capital "
"letter I with dot above), 'Ä±' (U+0131, Latin small letter dotless i), 'Å¿' "
"(U+017F, Latin small letter long s) and 'â„ª' (U+212A, Kelvin sign). If the "
":const:`ASCII` flag is used, only letters 'a' to 'z' and 'A' to 'Z' are "
"matched (but the flag affects the entire regular expression, so in such "
"cases using an explicit ``(?-i:[a-zA-Z])`` may be a better choice)."
msgstr ""

#: ../../library/re.rst:565
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale.  This flag can be used only with bytes "
"patterns.  The use of this flag is discouraged as the locale mechanism is "
"very unreliable, it only handles one \"culture\" at a time, and it only "
"works with 8-bit locales.  Unicode matching is already enabled by default in"
" Python 3 for Unicode (str) patterns, and it is able to handle different "
"locales/languages. Corresponds to the inline flag ``(?L)``."
msgstr ""

#: ../../library/re.rst:574
msgid ""
":const:`re.LOCALE` can be used only with bytes patterns and is not "
"compatible with :const:`re.ASCII`."
msgstr ":const:`re.LOCALE` ãƒã‚¤ãƒˆåˆ—ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã®ã¿åˆ©ç”¨ã§ãã¾ã™ã€‚:const:`re.ASCII` ã¨ã¯åŒæ™‚ã«æŒ‡å®šã§ãã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:582
msgid ""
"When specified, the pattern character ``'^'`` matches at the beginning of "
"the string and at the beginning of each line (immediately following each "
"newline); and the pattern character ``'$'`` matches at the end of the string"
" and at the end of each line (immediately preceding each newline).  By "
"default, ``'^'`` matches only at the beginning of the string, and ``'$'`` "
"only at the end of the string and immediately before the newline (if any) at"
" the end of the string. Corresponds to the inline flag ``(?m)``."
msgstr ""
"æŒ‡å®šã•ã‚Œã‚‹ã¨ã€ãƒ‘ã‚¿ãƒ¼ãƒ³æ–‡å­— ``'^'`` ã¯ã€æ–‡å­—åˆ—ã®å…ˆé ­ãŠã‚ˆã³å„è¡Œã®å…ˆé ­ (å„æ”¹è¡Œã®ç›´å¾Œ) ã¨ãƒãƒƒãƒã—ã¾ã™; ãã—ã¦ãƒ‘ã‚¿ãƒ¼ãƒ³æ–‡å­— ``'$'`` "
"ã¯æ–‡å­—åˆ—ã®æœ«å°¾ãŠã‚ˆã³å„è¡Œã®æœ«å°¾ (æ”¹è¡Œã®ç›´å‰) ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€``'^'`` ã¯ã€æ–‡å­—åˆ—ã®å…ˆé ­ã¨ã ã‘ãƒãƒƒãƒã—ã€``'$'`` "
"ã¯ã€æ–‡å­—åˆ—ã®æœ«å°¾ãŠã‚ˆã³æ–‡å­—åˆ—ã®æœ«å°¾ã®æ”¹è¡Œã®ç›´å‰ (ã‚‚ã—ã‚ã‚Œã°) ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒ•ãƒ©ã‚°ã® ``(?m)`` ã«ç›¸å½“ã—ã¾ã™ã€‚"

#: ../../library/re.rst:594
msgid ""
"Make the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline. "
"Corresponds to the inline flag ``(?s)``."
msgstr ""
"ç‰¹æ®Šæ–‡å­— ``'.'`` ã‚’ã€æ”¹è¡Œã‚’å«ã‚€ã©ã‚“ãªæ–‡å­—ã«ã‚‚ãƒãƒƒãƒã•ã›ã¾ã™; ã“ã®ãƒ•ãƒ©ã‚°ãŒãªã‘ã‚Œã°ã€``'.'`` ã¯ã€æ”¹è¡Œ *ä»¥å¤–ã®* ä»»æ„ã®æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚\n"
"ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒ•ãƒ©ã‚°ã® ``(?s)`` ã«ç›¸å½“ã—ã¾ã™ã€‚"

#: ../../library/re.rst:602
msgid ""
"This flag allows you to write regular expressions that look nicer and are "
"more readable by allowing you to visually separate logical sections of the "
"pattern and add comments. Whitespace within the pattern is ignored, except "
"when in a character class, or when preceded by an unescaped backslash, or "
"within tokens like ``*?``, ``(?:`` or ``(?P<...>``. When a line contains a "
"``#`` that is not in a character class and is not preceded by an unescaped "
"backslash, all characters from the leftmost such ``#`` through the end of "
"the line are ignored."
msgstr ""

#: ../../library/re.rst:611
msgid ""
"This means that the two following regular expression objects that match a "
"decimal number are functionally equal::"
msgstr "ã¤ã¾ã‚Šã€æ•°å­—ã«ãƒãƒƒãƒã™ã‚‹ä¸‹è¨˜ã®ãµãŸã¤ã®æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€æ©Ÿèƒ½çš„ã«ç­‰ä¾¡ã§ã™ã€‚::"

#: ../../library/re.rst:619
msgid "Corresponds to the inline flag ``(?x)``."
msgstr "ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒ•ãƒ©ã‚°ã® ``(?x)`` ã«ç›¸å½“ã—ã¾ã™ã€‚"

#: ../../library/re.rst:624
msgid ""
"Scan through *string* looking for the first location where the regular "
"expression *pattern* produces a match, and return a corresponding "
":ref:`match object <match-objects>`.  Return ``None`` if no position in the "
"string matches the pattern; note that this is different from finding a zero-"
"length match at some point in the string."
msgstr ""
"*string* ã‚’èµ°æŸ»ã—ã€æ­£è¦è¡¨ç¾ *pattern* ãŒãƒãƒƒãƒã™ã‚‹æœ€åˆã®å ´æ‰€ã‚’æ¢ã—ã¦ã€å¯¾å¿œã™ã‚‹ :ref:`match ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <match-"
"objects>` ã‚’è¿”ã—ã¾ã™ã€‚æ–‡å­—åˆ—å†…ã«ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãƒãƒƒãƒã™ã‚‹å ´æ‰€ãŒç„¡ã„å ´åˆã¯ ``None`` ã‚’è¿”ã—ã¾ã™; ã“ã‚Œã¯æ–‡å­—åˆ—å†…ã®ã‚ã‚‹å ´æ‰€ã§é•·ã•ãŒ 0 "
"ã®ãƒãƒƒãƒãŒè¦‹ã¤ã‹ã£ãŸå ´åˆã¨ã¯ç•°ãªã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/re.rst:633
msgid ""
"If zero or more characters at the beginning of *string* match the regular "
"expression *pattern*, return a corresponding :ref:`match object <match-"
"objects>`.  Return ``None`` if the string does not match the pattern; note "
"that this is different from a zero-length match."
msgstr ""
"ã‚‚ã— *string* ã®å…ˆé ­ã§ 0 å€‹ä»¥ä¸Šã®æ–‡å­—ãŒæ­£è¦è¡¨ç¾ *pattern* ã¨ãƒãƒƒãƒã™ã‚Œã°ã€å¯¾å¿œã™ã‚‹ :ref:`ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ "
"<match-objects>` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚æ–‡å­—åˆ—ãŒãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ãƒãƒƒãƒã—ãªã‘ã‚Œã°ã€``None`` ã‚’è¿”ã—ã¾ã™; "
"ã“ã‚Œã¯é•·ã•ã‚¼ãƒ­ã®ãƒãƒƒãƒã¨ã¯ç•°ãªã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../library/re.rst:638
msgid ""
"Note that even in :const:`MULTILINE` mode, :func:`re.match` will only match "
"at the beginning of the string and not at the beginning of each line."
msgstr ""
":const:`MULTILINE` ãƒ¢ãƒ¼ãƒ‰ã§ã‚ã£ã¦ã‚‚ã€:func:`re.match` "
"ã¯æ–‡å­—åˆ—ã®å…ˆé ­ã®ã¿ã«ãƒãƒƒãƒã—ã€å„è¡Œã®å…ˆé ­ã«ã¯ãƒãƒƒãƒã—ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/re.rst:641
msgid ""
"If you want to locate a match anywhere in *string*, use :func:`search` "
"instead (see also :ref:`search-vs-match`)."
msgstr ""
"*string* å†…ã®ã©ã“ã§ã‚‚ãƒãƒƒãƒã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã«ã¯ã€ä»£ã‚ã‚Šã« :func:`search` ã‚’ä½¿ã£ã¦ãã ã•ã„ (:ref:`search-vs-"
"match` ã‚‚å‚ç…§ã—ã¦ãã ã•ã„)ã€‚"

#: ../../library/re.rst:647
msgid ""
"If the whole *string* matches the regular expression *pattern*, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if the "
"string does not match the pattern; note that this is different from a zero-"
"length match."
msgstr ""
"*string* å…¨ä½“ãŒæ­£è¦è¡¨ç¾ *pattern* ã«ãƒãƒƒãƒã—ãŸå ´åˆã€å¯¾å¿œã™ã‚‹ :ref:`match ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <match-objects>`"
" ã‚’è¿”ã—ã¾ã™ã€‚æ–‡å­—åˆ—ã«ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãƒãƒƒãƒã™ã‚‹å ´æ‰€ãŒç„¡ã„å ´åˆã¯ ``None`` ã‚’è¿”ã—ã¾ã™; ã“ã‚Œã¯é•·ã•ãŒ 0 "
"ã®ãƒãƒƒãƒã¨ã¯é•ã†ã¨ã„ã†ã“ã¨ã‚’æ³¨æ„ã—ã¦ãŠãã¾ã™ã€‚"

#: ../../library/re.rst:657
msgid ""
"Split *string* by the occurrences of *pattern*.  If capturing parentheses "
"are used in *pattern*, then the text of all groups in the pattern are also "
"returned as part of the resulting list. If *maxsplit* is nonzero, at most "
"*maxsplit* splits occur, and the remainder of the string is returned as the "
"final element of the list. ::"
msgstr ""
"*string* ã‚’ã€*pattern* ãŒã‚ã‚‹ãŸã³ã«åˆ†å‰²ã—ã¾ã™ã€‚ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚°ãƒ«ãƒ¼ãƒ—ã®ä¸¸æ‹¬å¼§ãŒ *pattern* "
"ã§ä½¿ã‚ã‚Œã¦ã„ã‚Œã°ã€ãƒ‘ã‚¿ãƒ¼ãƒ³å†…ã®ã™ã¹ã¦ã®ã‚°ãƒ«ãƒ¼ãƒ—ã®ãƒ†ã‚­ã‚¹ãƒˆã‚‚çµæœã®ãƒªã‚¹ãƒˆã®ä¸€éƒ¨ã¨ã—ã¦è¿”ã•ã‚Œã¾ã™ã€‚*maxsplit* ãŒã‚¼ãƒ­ã§ãªã‘ã‚Œã°ã€æœ€å¤§ "
"*maxsplit* å€‹ã®åˆ†å‰²ãŒç™ºç”Ÿã—ã€æ®‹ã‚Šã¯ãƒªã‚¹ãƒˆã®æœ€çµ‚è¦ç´ ã¨ã—ã¦è¿”ã•ã‚Œã¾ã™ã€‚ ::"

#: ../../library/re.rst:672
msgid ""
"If there are capturing groups in the separator and it matches at the start "
"of the string, the result will start with an empty string.  The same holds "
"for the end of the string::"
msgstr ""

#: ../../library/re.rst:679
msgid ""
"That way, separator components are always found at the same relative indices"
" within the result list."
msgstr "ãã®å ´åˆã€å¸¸ã«ã€åˆ†å‰²è¦ç´ ãŒã€åˆ†å‰²çµæœã®ãƒªã‚¹ãƒˆã®ç›¸å¯¾çš„ãªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«ç¾ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:684
msgid ""
":func:`split` doesn't currently split a string on an empty pattern match. "
"For example::"
msgstr "ç¾åœ¨ã€:func:`split` ã¯ç©ºã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã§ã¯æ–‡å­—åˆ—ã‚’åˆ†å‰²ã—ã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../library/re.rst:690
msgid ""
"Even though ``'x*'`` also matches 0 'x' before 'a', between 'b' and 'c', and"
" after 'c', currently these matches are ignored.  The correct behavior (i.e."
" splitting on empty matches too and returning ``['', 'a', 'b', 'c', '']``) "
"will be implemented in future versions of Python, but since this is a "
"backward incompatible change, a :exc:`FutureWarning` will be raised in the "
"meanwhile."
msgstr ""
"``'x*'`` ã¯ 'a' ã®å‰ã€ 'b' ã¨ 'c' ã¨ã®é–“ã€ 'c' ã®å¾Œã® 0 å€‹ã® 'x' "
"ã«ã‚‚ãƒãƒƒãƒã—ã¾ã™ãŒã€ç¾åœ¨ã“ã‚Œã‚‰ã®ãƒãƒƒãƒã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚æ­£ã—ã„å‹•ä½œ (ç©ºã®ãƒãƒƒãƒã§ã‚‚æ–‡å­—åˆ—ã‚’åˆ†å‰²ã—ã€``['', 'a', 'b', 'c', '']``"
" ã‚’è¿”ã™) ã¯ã€Python ã®å°†æ¥ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§å®Ÿè£…ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã€å¾Œæ–¹äº’æ›ç”Ÿã®ãªã„å¤‰æ›´ã§ã‚ã‚‹ãŸã‚ã€ç§»è¡ŒæœŸé–“ä¸­ã¯ "
":exc:`FutureWarning` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:697
msgid ""
"Patterns that can only match empty strings currently never split the string."
"  Since this doesn't match the expected behavior, a :exc:`ValueError` will "
"be raised starting from Python 3.5::"
msgstr ""
"ç©ºã®æ–‡å­—åˆ—ã®ã¿ã¨ãƒãƒƒãƒã™ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€ç¾åœ¨æ–‡å­—åˆ—ã‚’å…¨ãåˆ†å‰²ã—ã¾ã›ã‚“ã€‚ã“ã‚Œã¯æœ›ã¾ã—ã„å‹•ä½œã§ã¯ãªã„ãŸã‚ã€Python 3.5 ã‹ã‚‰ "
":exc:`ValueError` ãŒé€å‡ºã•ã‚Œã¾ã™::"

#: ../../library/re.rst:707 ../../library/re.rst:785 ../../library/re.rst:805
msgid "Added the optional flags argument."
msgstr "ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® flags å¼•æ•°ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/re.rst:710
msgid ""
"Splitting on a pattern that could match an empty string now raises a "
"warning.  Patterns that can only match empty strings are now rejected."
msgstr ""
"ç©ºã®æ–‡å­—åˆ—ã«ãƒãƒƒãƒã™ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã‚ˆã£ã¦åˆ†å‰²ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã€è­¦å‘ŠãŒé€å‡ºã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ç©ºã®æ–‡å­—åˆ—ã®ã¿ã¨ãƒãƒƒãƒã™ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯æ‹’å¦ã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/re.rst:717
msgid ""
"Return all non-overlapping matches of *pattern* in *string*, as a list of "
"strings.  The *string* is scanned left-to-right, and matches are returned in"
" the order found.  If one or more groups are present in the pattern, return "
"a list of groups; this will be a list of tuples if the pattern has more than"
" one group.  Empty matches are included in the result."
msgstr ""

#: ../../library/re.rst:725
msgid ""
"Due to the limitation of the current implementation the character following "
"an empty match is not included in a next match, so ``findall(r'^|\\w+', 'two"
" words')`` returns ``['', 'wo', 'words']`` (note missed \"t\").  This is "
"changed in Python 3.7."
msgstr ""

#: ../../library/re.rst:733
msgid ""
"Return an :term:`iterator` yielding :ref:`match objects <match-objects>` "
"over all non-overlapping matches for the RE *pattern* in *string*.  The "
"*string* is scanned left-to-right, and matches are returned in the order "
"found.  Empty matches are included in the result.  See also the note about "
":func:`findall`."
msgstr ""

#: ../../library/re.rst:741
msgid ""
"Return the string obtained by replacing the leftmost non-overlapping "
"occurrences of *pattern* in *string* by the replacement *repl*.  If the "
"pattern isn't found, *string* is returned unchanged.  *repl* can be a string"
" or a function; if it is a string, any backslash escapes in it are "
"processed.  That is, ``\\n`` is converted to a single newline character, "
"``\\r`` is converted to a carriage return, and so forth.  Unknown escapes "
"such as ``\\&`` are left alone.  Backreferences, such as ``\\6``, are "
"replaced with the substring matched by group 6 in the pattern. For example::"
msgstr ""

#: ../../library/re.rst:755
msgid ""
"If *repl* is a function, it is called for every non-overlapping occurrence "
"of *pattern*.  The function takes a single :ref:`match object <match-"
"objects>` argument, and returns the replacement string.  For example::"
msgstr ""
"ã‚‚ã— *repl* ãŒé–¢æ•°ã§ã‚ã‚Œã°ã€é‡è¤‡ã—ãªã„ *pattern* ãŒç™ºç”Ÿã™ã‚‹ãŸã³ã«ãã®é–¢æ•°ãŒå‘¼ã°ã‚Œã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ä¸€ã¤ã® "
":ref:`ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <match-objects>` å¼•æ•°ã‚’å–ã‚Šã€ç½®æ›æ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚ä¾‹ãˆã°::"

#: ../../library/re.rst:767
msgid "The pattern may be a string or a :ref:`pattern object <re-objects>`."
msgstr "ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€æ–‡å­—åˆ—ã§ã‚‚ :ref:`ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <re-objects>` ã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:769
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  If omitted or zero,"
" all occurrences will be replaced. Empty matches for the pattern are "
"replaced only when not adjacent to a previous match, so ``sub('x*', '-', "
"'abc')`` returns ``'-a-b-c-'``."
msgstr ""
"çœç•¥å¯èƒ½ãªå¼•æ•° *count* ã¯ã€ç½®æ›ã•ã‚Œã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å‡ºç¾å›æ•°ã®æœ€å¤§å€¤ã§ã™ï¼› *count* "
"ã¯éè² ã®æ•´æ•°ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚‚ã—çœç•¥ã•ã‚Œã‚‹ã‹ã‚¼ãƒ­ã§ã‚ã‚Œã°ã€å‡ºç¾ã—ãŸã‚‚ã®ãŒã™ã¹ã¦ç½®æ›ã•ã‚Œã¾ã™ã€‚ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ãƒãƒƒãƒãŒç©ºã§ã‚ã‚Œã°ã€ä»¥å‰ã®ãƒãƒƒãƒã¨éš£åˆã‚ã›ã§ãªã„æ™‚ã ã‘ç½®æ›ã•ã‚Œã¾ã™ã®ã§ã€"
" ``sub('x*', '-', 'abc')`` ã¯ ``'-a-b-c-'`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/re.rst:775
msgid ""
"In string-type *repl* arguments, in addition to the character escapes and "
"backreferences described above, ``\\g<name>`` will use the substring matched"
" by the group named ``name``, as defined by the ``(?P<name>...)`` syntax. "
"``\\g<number>`` uses the corresponding group number; ``\\g<2>`` is therefore"
" equivalent to ``\\2``, but isn't ambiguous in a replacement such as "
"``\\g<2>0``.  ``\\20`` would be interpreted as a reference to group 20, not "
"a reference to group 2 followed by the literal character ``'0'``.  The "
"backreference ``\\g<0>`` substitutes in the entire substring matched by the "
"RE."
msgstr ""
"æ–‡å­—åˆ—ã‚¿ã‚¤ãƒ— *repl* å¼•æ•°ã§ã¯ã€ä¸Šã§è¿°ã¹ãŸæ–‡å­—ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚„å¾Œæ–¹å‚ç…§ã®ä»–ã«ã€ ``\\g<name>`` ã¯ã€ ``(?P<name>...)`` "
"ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ã§å®šç¾©ã•ã‚ŒãŸ ``name`` ã‚°ãƒ«ãƒ¼ãƒ—ã«ã‚ˆã‚‹ãƒãƒƒãƒéƒ¨åˆ†æ–‡å­—åˆ—ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã—ã€ ``\\g<number>`` "
"ã¯å¯¾å¿œã™ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ç•ªå·ã¸ã®å‚ç…§ã¨ãªã‚Šã¾ã™; ``\\g<2>`` ã¯ã¤ã¾ã‚Š ``\\2`` ã¨ç­‰ä¾¡ã§ã™ãŒã€ ``\\g<2>0`` "
"ã®ã‚ˆã†ãªç½®æ›ã«ãŠã„ã¦ã‚‚æ›–æ˜§ã«ãªã‚Šã¾ã›ã‚“ã€‚ ``\\20`` ã¯ã€ã‚°ãƒ«ãƒ¼ãƒ— 20ã¸ã®å‚ç…§ã¨ã—ã¦è§£é‡ˆã•ã‚Œã€ã‚°ãƒ«ãƒ¼ãƒ— 2 ã«ãƒªãƒ†ãƒ©ãƒ«æ–‡å­— ``'0'`` "
"ãŒç¶šã„ãŸã‚‚ã®ã¸ã®å‚ç…§ã¨ã—ã¦ã¯è§£é‡ˆã•ã‚Œãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚å¾Œæ–¹å‚ç…§ ``\\g<0>`` ã¯ã€RE ã¨ãƒãƒƒãƒã™ã‚‹ã‚µãƒ–æ–‡å­—åˆ—å…¨ä½“ã‚’ç½®ãæ›ãˆã¾ã™ã€‚"

#: ../../library/re.rst:788 ../../library/re.rst:808 ../../library/re.rst:1028
msgid "Unmatched groups are replaced with an empty string."
msgstr "ãƒãƒƒãƒã—ãªã„ã‚°ãƒ«ãƒ¼ãƒ—ã¯ç©ºæ–‡å­—åˆ—ã«ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:791
msgid ""
"Unknown escapes in *pattern* consisting of ``'\\'`` and an ASCII letter now "
"are errors."
msgstr "*pattern* ä¸­ã« ``'\\'`` ã¨ ASCII æ–‡å­—ã‹ã‚‰ãªã‚‹æœªçŸ¥ã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ãŒã‚ã‚‹ã¨ã€ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/re.rst:797
msgid ""
"Unknown escapes in *repl* consisting of ``'\\'`` and an ASCII letter now "
"raise a deprecation warning and will be forbidden in Python 3.7."
msgstr ""

#: ../../library/re.rst:802
msgid ""
"Perform the same operation as :func:`sub`, but return a tuple ``(new_string,"
" number_of_subs_made)``."
msgstr ""
":func:`sub` ã¨åŒã˜æ“ä½œã‚’è¡Œã„ã¾ã™ãŒã€ã‚¿ãƒ—ãƒ« ``(new_stringã€ number_of_subs_made)`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/re.rst:814
msgid ""
"Escape all the characters in *pattern* except ASCII letters, numbers and "
"``'_'``. This is useful if you want to match an arbitrary literal string "
"that may have regular expression metacharacters in it.  For example::"
msgstr ""
"*pattern* ã«å«ã¾ã‚Œã‚‹ã€ASCII æ–‡å­—ã€æ•°å­—ã€ãŠã‚ˆã³ ``'_'`` ã‚’é™¤ãã™ã¹ã¦ã®æ–‡å­—ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã—ã¾ã™ã€‚\n"
"ã“ã‚Œã¯ã€ã‚‚ã—ãã®ä¸­ã«æ­£è¦è¡¨ç¾ã®ãƒ¡ã‚¿æ–‡å­—ã‚’æŒã¤ã‹ã‚‚ã—ã‚Œãªã„ä»»æ„ã®ãƒªãƒ†ãƒ©ãƒ«æ–‡å­—åˆ—ã¨ãƒãƒƒãƒã—ãŸã„æ™‚ã«å½¹ç«‹ã¡ã¾ã™ã€‚\n"
"ä¾‹ãˆã°::"

#: ../../library/re.rst:829
msgid ""
"This functions must not be used for the replacement string in :func:`sub` "
"and :func:`subn`, only backslashes should be escaped.  For example::"
msgstr ""

#: ../../library/re.rst:837
msgid "The ``'_'`` character is no longer escaped."
msgstr "``'_'`` æ–‡å­—ãŒã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚Œãªããªã‚Šã¾ã—ãŸã€‚"

#: ../../library/re.rst:843
msgid "Clear the regular expression cache."
msgstr "æ­£è¦è¡¨ç¾ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã€‚"

#: ../../library/re.rst:848
msgid ""
"Exception raised when a string passed to one of the functions here is not a "
"valid regular expression (for example, it might contain unmatched "
"parentheses) or when some other error occurs during compilation or matching."
"  It is never an error if a string contains no match for a pattern.  The "
"error instance has the following additional attributes:"
msgstr ""
"ã“ã‚Œã‚‰ã®é–¢æ•°ã®ã„ãšã‚Œã‹ã«æ¸¡ã•ã‚ŒãŸæ–‡å­—åˆ—ãŒæœ‰åŠ¹ãªæ­£è¦è¡¨ç¾ã§ã¯ãªã„ (ä¾‹: æ‹¬å¼§ãŒå¯¾ã«ãªã£ã¦ã„ãªã„) "
"å ´åˆã€ã¾ãŸã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã‚„ãƒãƒƒãƒãƒ³ã‚°æ™‚ã«ãªã‚“ã‚‰ã‹ã®ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã«ç™ºç”Ÿã™ã‚‹ä¾‹å¤–ã§ã™ã€‚æ–‡å­—åˆ—ã«ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ãƒãƒƒãƒã™ã‚‹éƒ¨åˆ†ãŒãªãã¦ã‚‚ã€ãã‚Œã¯ã‚¨ãƒ©ãƒ¼ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚¨ãƒ©ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ã¯ã€æ¬¡ã®ã‚ˆã†ãªè¿½åŠ ã®å±æ€§ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/re.rst:856
msgid "The unformatted error message."
msgstr "ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã•ã‚Œã¦ã„ãªã„ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§ã™ã€‚"

#: ../../library/re.rst:860
msgid "The regular expression pattern."
msgstr "æ­£è¦è¡¨ç¾ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚"

#: ../../library/re.rst:864
msgid "The index in *pattern* where compilation failed (may be ``None``)."
msgstr "*pattern* ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã«å¤±æ•—ã—ãŸå ´æ‰€ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã™ (``None`` ã®å ´åˆã‚‚ã‚ã‚Šã¾ã™)ã€‚"

#: ../../library/re.rst:868
msgid "The line corresponding to *pos* (may be ``None``)."
msgstr "*pos* ã«å¯¾å¿œã™ã‚‹è¡Œã§ã™ (``None`` ã®å ´åˆã‚‚ã‚ã‚Šã¾ã™)ã€‚"

#: ../../library/re.rst:872
msgid "The column corresponding to *pos* (may be ``None``)."
msgstr "*pos* ã«å¯¾å¿œã™ã‚‹åˆ—ã§ã™ (``None`` ã®å ´åˆã‚‚ã‚ã‚Šã¾ã™)ã€‚"

#: ../../library/re.rst:874
msgid "Added additional attributes."
msgstr "è¿½åŠ ã®å±æ€§ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/re.rst:880
msgid "Regular Expression Objects"
msgstr "æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/re.rst:882
msgid ""
"Compiled regular expression objects support the following methods and "
"attributes:"
msgstr "ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨å±æ€§ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™:"

#: ../../library/re.rst:887
msgid ""
"Scan through *string* looking for the first location where this regular "
"expression produces a match, and return a corresponding :ref:`match object "
"<match-objects>`.  Return ``None`` if no position in the string matches the "
"pattern; note that this is different from finding a zero-length match at "
"some point in the string."
msgstr ""
"*string* ã‚’èµ°æŸ»ã—ã€æ­£è¦è¡¨ç¾ãŒãƒãƒƒãƒã™ã‚‹æœ€åˆã®å ´æ‰€ã‚’æ¢ã—ã¦ã€å¯¾å¿œã™ã‚‹ :ref:`match ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <match-objects>` "
"ã‚’è¿”ã—ã¾ã™ã€‚æ–‡å­—åˆ—å†…ã«ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãƒãƒƒãƒã™ã‚‹å ´æ‰€ãŒãªã„å ´åˆã¯ ``None`` ã‚’è¿”ã—ã¾ã™; ã“ã‚Œã¯æ–‡å­—åˆ—å†…ã®ã‚ã‚‹å ´æ‰€ã§é•·ã•ãŒ 0 "
"ã®ãƒãƒƒãƒãŒè¦‹ã¤ã‹ã£ãŸå ´åˆã¨ã¯ç•°ãªã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/re.rst:893
msgid ""
"The optional second parameter *pos* gives an index in the string where the "
"search is to start; it defaults to ``0``.  This is not completely equivalent"
" to slicing the string; the ``'^'`` pattern character matches at the real "
"beginning of the string and at positions just after a newline, but not "
"necessarily at the index where the search is to start."
msgstr ""
"çœç•¥å¯èƒ½ãªã€2ã¤ç›®ã®å¼•æ•° *pos* ã¯ã€ string ã®ã©ã“ã‹ã‚‰æ¢ã—å§‹ã‚ã‚‹ã‹ã‚’æŒ‡å®šã™ã‚‹ index ã§ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ 0 "
"ã§ã™ã€‚ã“ã‚Œã¯ã€æ–‡å­—åˆ—ã‚’ã‚¹ãƒ©ã‚¤ã‚¹ã—ã¦ã‹ã‚‰æ¤œç´¢ã™ã‚‹ã®ã¨ã€å®Œå…¨ã«ã¯åŒã˜ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ‘ã‚¿ãƒ¼ãƒ³æ–‡å­— ``'^'`` "
"ã¯æœ¬å½“ã®æ–‡å­—åˆ—ã®å…ˆé ­ã¨ã€æ”¹è¡Œã®ç›´å¾Œã«ãƒãƒƒãƒã—ã¾ã™ãŒã€æ¤œç´¢ã‚’é–‹å§‹ã™ã‚‹ index ãŒãƒãƒƒãƒã™ã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:899
msgid ""
"The optional parameter *endpos* limits how far the string will be searched; "
"it will be as if the string is *endpos* characters long, so only the "
"characters from *pos* to ``endpos - 1`` will be searched for a match.  If "
"*endpos* is less than *pos*, no match will be found; otherwise, if *rx* is a"
" compiled regular expression object, ``rx.search(string, 0, 50)`` is "
"equivalent to ``rx.search(string[:50], 0)``. ::"
msgstr ""
"ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¼•æ•° *endpos* ã¯æ–‡å­—åˆ—ã®æ¤œç´¢ç¯„å›²ã‚’åˆ¶é™ã—ã¾ã™ã€‚\n"
"ã“ã‚Œã¯æ–‡å­—åˆ—ã®é•·ã•ãŒ *endpos* æ–‡å­—ã ã£ãŸå ´åˆã¨åŒã˜ã¨ã¿ãªã—ã€*pos* ã‹ã‚‰ ``endpos - 1`` ã®ç¯„å›²ã®æ–‡å­—ã«å¯¾ã—ã¦ãƒãƒƒãƒã‚’æ¢ã—ã¾ã™ã€‚\n"
"*endpos* ãŒ *pos* ã‚ˆã‚Šã‚‚å°ã•ã„å ´åˆã¯ã€ãƒãƒƒãƒã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“;\n"
"ãã‚Œä»¥å¤–ã®å ´åˆã¯ã€*rx* ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸæ­£è¦è¡¨ç¾ã ã¨ã—ã¦ã€``rx.search(string, 0, 50)`` ã¯ ``rx.search(string[:50], 0)`` ã¨ç­‰ä¾¡ã§ã™ã€‚::"

#: ../../library/re.rst:914
msgid ""
"If zero or more characters at the *beginning* of *string* match this regular"
" expression, return a corresponding :ref:`match object <match-objects>`. "
"Return ``None`` if the string does not match the pattern; note that this is "
"different from a zero-length match."
msgstr ""
"*string* ã® *å…ˆé ­ã®* 0 å€‹ä»¥ä¸Šã®æ–‡å­—ãŒã“ã®æ­£è¦è¡¨ç¾ã¨ãƒãƒƒãƒã™ã‚‹å ´åˆã€å¯¾å¿œã™ã‚‹ :ref:`ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <match-"
"objects>` ã‚’è¿”ã—ã¾ã™ã€‚æ–‡å­—åˆ—ãŒãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ãƒãƒƒãƒã—ãªã„å ´åˆã€``None`` "
"ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯é•·ã•ã‚¼ãƒ­ã®ãƒãƒƒãƒã¨ã¯ç•°ãªã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/re.rst:919 ../../library/re.rst:937
msgid ""
"The optional *pos* and *endpos* parameters have the same meaning as for the "
":meth:`~regex.search` method. ::"
msgstr ""
"ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¼•æ•° *pos* ã¨ *endpos* å¼•æ•°ã¯ã€ :meth:`~regex.search` ãƒ¡ã‚½ãƒƒãƒ‰ã¨åŒã˜æ„å‘³ã‚’æŒã¡ã¾ã™ã€‚::"

#: ../../library/re.rst:927
msgid ""
"If you want to locate a match anywhere in *string*, use "
":meth:`~regex.search` instead (see also :ref:`search-vs-match`)."
msgstr ""
"*string* å†…ã®ã©ã“ã§ã‚‚ãƒãƒƒãƒã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã«ã¯ã€ä»£ã‚ã‚Šã« :meth:`~regex.search` ã‚’ä½¿ã£ã¦ãã ã•ã„ (:ref"
":`search-vs-match` ã‚‚å‚ç…§ã—ã¦ãã ã•ã„)ã€‚"

#: ../../library/re.rst:933
msgid ""
"If the whole *string* matches this regular expression, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if the "
"string does not match the pattern; note that this is different from a zero-"
"length match."
msgstr ""
"*string* å…¨ä½“ãŒã“ã®æ­£è¦è¡¨ç¾ã«ãƒãƒƒãƒã—ãŸå ´åˆã€å¯¾å¿œã™ã‚‹ :ref:`match ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <match-objects>` "
"ã‚’è¿”ã—ã¾ã™ã€‚æ–‡å­—åˆ—ã«ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãƒãƒƒãƒã™ã‚‹å ´æ‰€ãŒç„¡ã„å ´åˆã¯ ``None`` ã‚’è¿”ã—ã¾ã™; ã“ã‚Œã¯é•·ã•ãŒ 0 "
"ã®ãƒãƒƒãƒã¨ã¯é•ã†ã¨ã„ã†ã“ã¨ã‚’æ³¨æ„ã—ã¦ãŠãã¾ã™ã€‚"

#: ../../library/re.rst:951
msgid "Identical to the :func:`split` function, using the compiled pattern."
msgstr ""
":func:`split` é–¢æ•°ã¨åŒæ§˜ã§ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ã„ã¾ã™ã€‚ãŸã ã—ã€ :meth:`match` ã¨åŒã˜ã‚ˆã†ã«ã€çœç•¥å¯èƒ½ãª *pos*,"
" *endpos* å¼•æ•°ã§æ¤œç´¢ç¯„å›²ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/re.rst:956
msgid ""
"Similar to the :func:`findall` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""
":func:`findall` é–¢æ•°ã¨åŒã˜ãã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ã„ã¾ã™ã€‚\n"
"ãŸã ã—ã€ :meth:`search` ã¨åŒã˜ã‚ˆã†ã«ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¼•æ•°ã® *pos* ã¨ *endpos* ã§æ¤œç´¢ç¯„å›²ã‚’åˆ¶é™ã§ãã¾ã™ã€‚"

#: ../../library/re.rst:963
msgid ""
"Similar to the :func:`finditer` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""
":func:`finditer` é–¢æ•°ã¨åŒã˜ãã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ã„ã¾ã™ã€‚\n"
"ãŸã ã—ã€ :meth:`search` ã¨åŒã˜ã‚ˆã†ã«ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¼•æ•°ã® *pos* ã¨ *endpos* ã§æ¤œç´¢ç¯„å›²ã‚’åˆ¶é™ã§ãã¾ã™ã€‚"

#: ../../library/re.rst:970
msgid "Identical to the :func:`sub` function, using the compiled pattern."
msgstr ":func:`sub` é–¢æ•°ã¨åŒæ§˜ã§ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../library/re.rst:975
msgid "Identical to the :func:`subn` function, using the compiled pattern."
msgstr ":func:`subn` é–¢æ•°ã¨åŒæ§˜ã§ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../library/re.rst:980
msgid ""
"The regex matching flags.  This is a combination of the flags given to "
":func:`.compile`, any ``(?...)`` inline flags in the pattern, and implicit "
"flags such as :data:`UNICODE` if the pattern is a Unicode string."
msgstr ""
"æ­£è¦è¡¨ç¾ã®ãƒãƒƒãƒãƒ³ã‚°ãƒ•ãƒ©ã‚°ã§ã™ã€‚ã“ã‚Œã¯ :func:`.compile` ã§æŒ‡å®šã•ã‚ŒãŸãƒ•ãƒ©ã‚°ã€ãƒ‘ã‚¿ãƒ¼ãƒ³å†…ã® ``(?...)`` "
"ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒ•ãƒ©ã‚°ã€ãŠã‚ˆã³ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒ Unicode æ–‡å­—åˆ—ã ã£ãŸæ™‚ã® :data:`UNICODE` ã®ã‚ˆã†ãªæš—é»™ã®ãƒ•ãƒ©ã‚°ã¨ã®çµ„ã¿åˆã‚ã›ã«ãªã‚Šãªã™ã€‚"

#: ../../library/re.rst:987
msgid "The number of capturing groups in the pattern."
msgstr "ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã‚ã‚‹ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚°ãƒ«ãƒ¼ãƒ—ã®æ•°ã§ã™ã€‚"

#: ../../library/re.rst:992
msgid ""
"A dictionary mapping any symbolic group names defined by ``(?P<id>)`` to "
"group numbers.  The dictionary is empty if no symbolic groups were used in "
"the pattern."
msgstr ""
"``(?P<id>)`` "
"ã§å®šç¾©ã•ã‚ŒãŸä»»æ„ã®è¨˜å·ã‚°ãƒ«ãƒ¼ãƒ—åã®ã€ã‚°ãƒ«ãƒ¼ãƒ—ç•ªå·ã¸ã®è¾æ›¸ãƒãƒƒãƒ”ãƒ³ã‚°ã§ã™ã€‚ã‚‚ã—è¨˜å·ã‚°ãƒ«ãƒ¼ãƒ—ãŒãƒ‘ã‚¿ãƒ¼ãƒ³å†…ã§ä½•ã‚‚ä½¿ã‚ã‚Œã¦ã„ãªã‘ã‚Œã°ã€è¾æ›¸ã¯ç©ºã§ã™ã€‚"

#: ../../library/re.rst:999
msgid "The pattern string from which the RE object was compiled."
msgstr "RE ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸã¨ãã«ä½¿ç”¨ã•ã‚ŒãŸå…ƒã®ãƒ‘ã‚¿ãƒ¼ãƒ³æ–‡å­—åˆ—ã§ã™ã€‚"

#: ../../library/re.rst:1005
msgid "Match Objects"
msgstr "match ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/re.rst:1007
msgid ""
"Match objects always have a boolean value of ``True``. Since "
":meth:`~regex.match` and :meth:`~regex.search` return ``None`` when there is"
" no match, you can test whether there was a match with a simple ``if`` "
"statement::"
msgstr ""
"ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¸¸ã«ãƒ–ãƒ¼ãƒ«å€¤ ``True`` ã‚’æŒã¡ã¾ã™ã€‚ :meth:`~regex.match` ã¨ "
":meth:`~regex.search` ã¯ãƒãƒƒãƒã—ãªã‹ã£ãŸå ´åˆã« ``None`` ã‚’è¿”ã™ã®ã§ã€å˜ç´”ãª ``if`` "
"ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã«ã‚ˆã£ã¦ãƒãƒƒãƒã—ãŸã‹ã©ã†ã‹ã‚’ãƒ†ã‚¹ãƒˆã§ãã¾ã™::"

#: ../../library/re.rst:1016
msgid "Match objects support the following methods and attributes:"
msgstr "ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨å±æ€§ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™:"

#: ../../library/re.rst:1021
msgid ""
"Return the string obtained by doing backslash substitution on the template "
"string *template*, as done by the :meth:`~regex.sub` method. Escapes such as"
" ``\\n`` are converted to the appropriate characters, and numeric "
"backreferences (``\\1``, ``\\2``) and named backreferences (``\\g<1>``, "
"``\\g<name>``) are replaced by the contents of the corresponding group."
msgstr ""
"ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆæ–‡å­—åˆ— *template* ã«å¯¾ã—ã€:meth:`~regex.sub` "
"ãƒ¡ã‚½ãƒƒãƒ‰ãŒã™ã‚‹ã‚ˆã†ãªãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ç½®æ›ã‚’ã—ã¦å¾—ã‚‰ã‚Œã‚‹æ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚``\\n`` ã®ã‚ˆã†ãªã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã¯é©åˆ‡ãªæ–‡å­—ã«å¤‰æ›ã•ã‚Œã€æ•°å€¤ã®å¾Œæ–¹å‚ç…§ "
"(``\\1``, ``\\2``) ã¨åå‰ä»˜ãã®å¾Œæ–¹å‚ç…§ (``\\g<1>``, ``\\g<name>``) "
"ã¯ã€å¯¾å¿œã™ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ã®å†…å®¹ã§ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:1033
msgid ""
"Returns one or more subgroups of the match.  If there is a single argument, "
"the result is a single string; if there are multiple arguments, the result "
"is a tuple with one item per argument. Without arguments, *group1* defaults "
"to zero (the whole match is returned). If a *groupN* argument is zero, the "
"corresponding return value is the entire matching string; if it is in the "
"inclusive range [1..99], it is the string matching the corresponding "
"parenthesized group.  If a group number is negative or larger than the "
"number of groups defined in the pattern, an :exc:`IndexError` exception is "
"raised. If a group is contained in a part of the pattern that did not match,"
" the corresponding result is ``None``. If a group is contained in a part of "
"the pattern that matched multiple times, the last match is returned. ::"
msgstr ""

#: ../../library/re.rst:1055
msgid ""
"If the regular expression uses the ``(?P<name>...)`` syntax, the *groupN* "
"arguments may also be strings identifying groups by their group name.  If a "
"string argument is not used as a group name in the pattern, an "
":exc:`IndexError` exception is raised."
msgstr ""
"ã‚‚ã—æ­£è¦è¡¨ç¾ãŒ ``(?P<name>...)`` ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ã‚’ä½¿ã†ãªã‚‰ã°ã€ *groupN* "
"å¼•æ•°ã¯ã€ãã‚Œã‚‰ã®ã‚°ãƒ«ãƒ¼ãƒ—åã«ã‚ˆã£ã¦ã‚°ãƒ«ãƒ¼ãƒ—ã‚’è­˜åˆ¥ã™ã‚‹æ–‡å­—åˆ—ã§ã‚ã£ã¦ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚ã‚‚ã—æ–‡å­—åˆ—å¼•æ•°ãŒãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã‚°ãƒ«ãƒ¼ãƒ—åã¨ã—ã¦ä½¿ã‚ã‚Œã¦ã„ãªã„ã‚‚ã®ã§ã‚ã‚Œã°ã€ "
":exc:`IndexError` ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/re.rst:1060
msgid "A moderately complicated example::"
msgstr ""

#: ../../library/re.rst:1068
msgid "Named groups can also be referred to by their index::"
msgstr ""

#: ../../library/re.rst:1075
msgid "If a group matches multiple times, only the last match is accessible::"
msgstr ""

#: ../../library/re.rst:1084
msgid ""
"This is identical to ``m.group(g)``.  This allows easier access to an "
"individual group from a match::"
msgstr ""

#: ../../library/re.rst:1100
msgid ""
"Return a tuple containing all the subgroups of the match, from 1 up to "
"however many groups are in the pattern.  The *default* argument is used for "
"groups that did not participate in the match; it defaults to ``None``."
msgstr ""
"ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãƒãƒƒãƒã—ãŸã™ã¹ã¦ã®ã‚µãƒ–ã‚°ãƒ«ãƒ¼ãƒ—ã‚’å«ã‚€ã€ãƒ‘ã‚¿ãƒ¼ãƒ³å†…ã§æŒ‡å®šã•ã‚ŒãŸã‚°ãƒ«ãƒ¼ãƒ—æ•°åˆ†ã®è¦ç´ ã‚’æŒã¤ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚å¼•æ•° *default* "
"ã¯ã€ãƒãƒƒãƒã«åŠ ã‚ã‚‰ãªã‹ã£ãŸã‚°ãƒ«ãƒ¼ãƒ—ç”¨ã«ä½¿ã‚ã‚Œã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ ``None`` ã§ã™ã€‚"

#: ../../library/re.rst:1104 ../../library/re.rst:1324
msgid "For example::"
msgstr "ä¾‹ãˆã°::"

#: ../../library/re.rst:1110
msgid ""
"If we make the decimal place and everything after it optional, not all "
"groups might participate in the match.  These groups will default to "
"``None`` unless the *default* argument is given::"
msgstr ""

#: ../../library/re.rst:1123
msgid ""
"Return a dictionary containing all the *named* subgroups of the match, keyed"
" by the subgroup name.  The *default* argument is used for groups that did "
"not participate in the match; it defaults to ``None``.  For example::"
msgstr ""

#: ../../library/re.rst:1135
msgid ""
"Return the indices of the start and end of the substring matched by *group*;"
" *group* defaults to zero (meaning the whole matched substring). Return "
"``-1`` if *group* exists but did not contribute to the match.  For a match "
"object *m*, and a group *g* that did contribute to the match, the substring "
"matched by group *g* (equivalent to ``m.group(g)``) is ::"
msgstr ""
"*group* ã¨ãƒãƒƒãƒã—ãŸéƒ¨åˆ†æ–‡å­—åˆ—ã®å…ˆé ­ã¨æœ«å°¾ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ *group* "
"ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯(ãƒãƒƒãƒã—ãŸéƒ¨åˆ†æ–‡å­—åˆ—å…¨ä½“ã‚’æ„å‘³ã™ã‚‹ï¼‰ã‚¼ãƒ­ã§ã™ã€‚ *group* ãŒå­˜åœ¨ã—ã¦ã‚‚ãƒãƒƒãƒã«å¯„ä¸ã—ãªã‹ã£ãŸå ´åˆã¯ã€ ``-1`` "
"ã‚’è¿”ã—ã¾ã™ã€‚ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ *m* ãŠã‚ˆã³ã€ãƒãƒƒãƒã«å¯„ä¸ã—ãªã‹ã£ãŸã‚°ãƒ«ãƒ¼ãƒ— *g* ãŒã‚ã£ã¦ã€ã‚°ãƒ«ãƒ¼ãƒ— *g* ã¨ãƒãƒƒãƒã—ãŸã‚µãƒ–æ–‡å­—åˆ— ( "
"``m.group(g)`` ã¨åŒã˜æ„å‘³ã§ã™ãŒ ) ã¯::"

#: ../../library/re.rst:1143
msgid ""
"Note that ``m.start(group)`` will equal ``m.end(group)`` if *group* matched "
"a null string.  For example, after ``m = re.search('b(c?)', 'cba')``, "
"``m.start(0)`` is 1, ``m.end(0)`` is 2, ``m.start(1)`` and ``m.end(1)`` are "
"both 2, and ``m.start(2)`` raises an :exc:`IndexError` exception."
msgstr ""
"ã§ã™ã€‚ã‚‚ã— *group* ãŒç©ºæ–‡å­—åˆ—ã¨ãƒãƒƒãƒã™ã‚Œã°ã€ ``m.start(group)`` ãŒ ``m.end(group)`` "
"ã¨ç­‰ã—ããªã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ä¸‹ã•ã„ã€‚ä¾‹ãˆã°ã€ ``m = re.search('b(c?)', 'cba')`` ã¨ã™ã‚‹ã¨ã€ ``m.start(0)``"
" ã¯ 1 ã§ã€ ``m.end(0)`` ã¯ 2 ã§ã‚ã‚Šã€ ``m.start(1)`` ã¨ ``m.end(1)`` ã¯ã¨ã‚‚ã« 2 ã§ã‚ã‚Šã€ "
"``m.start(2)`` ã¯ :exc:`IndexError` ä¾‹å¤–ã‚’ç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/re.rst:1148
msgid "An example that will remove *remove_this* from email addresses::"
msgstr ""

#: ../../library/re.rst:1158
msgid ""
"For a match *m*, return the 2-tuple ``(m.start(group), m.end(group))``. Note"
" that if *group* did not contribute to the match, this is ``(-1, -1)``. "
"*group* defaults to zero, the entire match."
msgstr ""
"ãƒãƒƒãƒ *m* ã«ã¤ã„ã¦ã€å¤§ãã•2ã®ã‚¿ãƒ—ãƒ« ``(m.start(group), m.end(group))`` ã‚’è¿”ã—ã¾ã™ã€‚ã‚‚ã— *group* "
"ãŒãƒãƒƒãƒã«å¯„ä¸ã—ãªã‘ã‚Œã°ã€``(-1, -1)`` ã«ãªã‚Šã¾ã™ã€‚ã¾ãŸ *group* ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã‚¼ãƒ­ã§ã™ã€‚"

#: ../../library/re.rst:1165
msgid ""
"The value of *pos* which was passed to the :meth:`~regex.search` or "
":meth:`~regex.match` method of a :ref:`regex object <re-objects>`.  This is "
"the index into the string at which the RE engine started looking for a "
"match."
msgstr ""
":ref:`æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <re-objects>` ã® :meth:`~regex.search` ã‹ "
":meth:`~regex.match` ã«æ¸¡ã•ã‚ŒãŸ *pos* ã®å€¤ã§ã™ã€‚ã“ã‚Œã¯ RE ã‚¨ãƒ³ã‚¸ãƒ³ãŒãƒãƒƒãƒã‚’æ¢ã—å§‹ã‚ã‚‹ä½ç½®ã®æ–‡å­—åˆ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã™ã€‚"

#: ../../library/re.rst:1172
msgid ""
"The value of *endpos* which was passed to the :meth:`~regex.search` or "
":meth:`~regex.match` method of a :ref:`regex object <re-objects>`.  This is "
"the index into the string beyond which the RE engine will not go."
msgstr ""
":ref:`æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <re-objects>` ã® :meth:`~regex.search` ã‹ "
":meth:`~regex.match` ã«æ¸¡ã•ã‚ŒãŸ *endpos* ã®å€¤ã§ã™ã€‚ã“ã‚Œã¯ RE "
"ã‚¨ãƒ³ã‚¸ãƒ³ãŒãã‚Œä»¥ä¸Šã¯é€²ã¾ãªã„ä½ç½®ã®æ–‡å­—åˆ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã™ã€‚"

#: ../../library/re.rst:1179
msgid ""
"The integer index of the last matched capturing group, or ``None`` if no "
"group was matched at all. For example, the expressions ``(a)b``, "
"``((a)(b))``, and ``((ab))`` will have ``lastindex == 1`` if applied to the "
"string ``'ab'``, while the expression ``(a)(b)`` will have ``lastindex == "
"2``, if applied to the same string."
msgstr ""
"æœ€å¾Œã«ãƒãƒƒãƒã—ãŸå–ã‚Šè¾¼ã¿ã‚°ãƒ«ãƒ¼ãƒ—ã®æ•´æ•°ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã™ã€‚ã‚‚ã—ã©ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚‚å…¨ããƒãƒƒãƒã—ãªã‘ã‚Œã° ``None`` ã§ã™ã€‚ä¾‹ãˆã°ã€ ``(a)b``, "
"``((a)(b))`` ã‚„ ``((ab))`` ã¨ã„ã£ãŸè¡¨ç¾ãŒ ``'ab'`` ã«é©ç”¨ã•ã‚ŒãŸå ´åˆã€ ``lastindex == 1`` "
"ã¨ãªã‚Šã€åŒã˜æ–‡å­—åˆ—ã« ``(a)(b)`` ãŒé©ç”¨ã•ã‚ŒãŸå ´åˆã«ã¯ ``lastindex == 2`` ã¨ãªã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../library/re.rst:1188
msgid ""
"The name of the last matched capturing group, or ``None`` if the group "
"didn't have a name, or if no group was matched at all."
msgstr ""
"æœ€å¾Œã«ãƒãƒƒãƒã—ãŸå–ã‚Šè¾¼ã¿ã‚°ãƒ«ãƒ¼ãƒ—ã®åå‰ã§ã™ã€‚ã‚‚ã—ã‚°ãƒ«ãƒ¼ãƒ—ã«åå‰ãŒãªã„ã‹ã€ã‚ã‚‹ã„ã¯ã©ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚‚å…¨ããƒãƒƒãƒã—ãªã‘ã‚Œã° ``None`` ã§ã™ã€‚"

#: ../../library/re.rst:1194
msgid ""
"The :ref:`regular expression object <re-objects>` whose :meth:`~regex.match`"
" or :meth:`~regex.search` method produced this match instance."
msgstr ""

#: ../../library/re.rst:1200
msgid "The string passed to :meth:`~regex.match` or :meth:`~regex.search`."
msgstr ":meth:`~regex.match` ã¾ãŸã¯ :meth:`~regex.search` ã¸æ¸¡ã•ã‚ŒãŸæ–‡å­—åˆ—ã§ã™ã€‚"

#: ../../library/re.rst:1206
msgid "Regular Expression Examples"
msgstr "æ­£è¦è¡¨ç¾ã®ä¾‹"

#: ../../library/re.rst:1210
msgid "Checking for a Pair"
msgstr "ãƒšã‚¢ã®ç¢ºèª"

#: ../../library/re.rst:1212
msgid ""
"In this example, we'll use the following helper function to display match "
"objects a little more gracefully:"
msgstr "ã“ã®ä¾‹ã§ã¯ã€ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è¡¨ç¤ºã‚’å°‘ã—ç¾ã—ãã™ã‚‹ãŸã‚ã«ã€ä¸‹è¨˜ã®è£œåŠ©é–¢æ•°ã‚’ä½¿ç”¨ã—ã¾ã™ :"

#: ../../library/re.rst:1222
msgid ""
"Suppose you are writing a poker program where a player's hand is represented"
" as a 5-character string with each character representing a card, \"a\" for "
"ace, \"k\" for king, \"q\" for queen, \"j\" for jack, \"t\" for 10, and "
"\"2\" through \"9\" representing the card with that value."
msgstr ""
"ã‚ãªãŸãŒãƒãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ã„ã¦ã„ã‚‹ã¨ã—ã¾ã™ã€‚ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æŒã¡æœ­ã¯ãã‚Œãã‚Œã®æ–‡å­—ãŒ1æšã®ã‚«ãƒ¼ãƒ‰ã‚’æ„å‘³ã™ã‚‹5æ–‡å­—ã®æ–‡å­—åˆ—ã«ã‚ˆã£ã¦è¡¨ç¾ã•ã‚Œã¾ã™ã€‚ "
"\"a\" ã¯ã‚¨ãƒ¼ã‚¹ã€ \"k\" ã¯ã‚­ãƒ³ã‚°ã€ \"q\" ã¯ã‚¯ã‚¤ãƒ¼ãƒ³ã€ \"j\" ã¯ã‚¸ãƒ£ãƒƒã‚¯ã€ \"t\" ã¯10ã€ãã—ã¦ \"2\" ã‹ã‚‰ "
"\"9\" ã¯ãã‚Œãã‚Œã®æ•°å­—ã®ã‚«ãƒ¼ãƒ‰ã‚’è¡¨ã—ã¾ã™ã€‚"

#: ../../library/re.rst:1227
msgid "To see if a given string is a valid hand, one could do the following::"
msgstr ""

#: ../../library/re.rst:1237
msgid ""
"That last hand, ``\"727ak\"``, contained a pair, or two of the same valued "
"cards. To match this with a regular expression, one could use backreferences"
" as such::"
msgstr ""

#: ../../library/re.rst:1247
msgid ""
"To find out what card the pair consists of, one could use the "
":meth:`~match.group` method of the match object in the following manner:"
msgstr ""
"ã©ã®ã‚«ãƒ¼ãƒ‰ã®ãƒšã‚¢ã«ãªã£ã¦ã„ã‚‹ã‹ã‚’èª¿ã¹ã‚‹ã«ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`~match.group` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã„ã¾ã™:"

#: ../../library/re.rst:1267
msgid "Simulating scanf()"
msgstr "scanf() ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹"

#: ../../library/re.rst:1271
msgid ""
"Python does not currently have an equivalent to :c:func:`scanf`.  Regular "
"expressions are generally more powerful, though also more verbose, than "
":c:func:`scanf` format strings.  The table below offers some more-or-less "
"equivalent mappings between :c:func:`scanf` format tokens and regular "
"expressions."
msgstr ""
"Python ã«ã¯ç¾åœ¨ã®ã¨ã“ã‚ã€ :c:func:`scanf` ã«ç›¸å½“ã™ã‚‹ã‚‚ã®ãŒã‚ã‚Šã¾ã›ã‚“ã€‚æ­£è¦è¡¨ç¾ã¯ã€ :c:func:`scanf` "
"ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ–‡å­—åˆ—ã‚ˆã‚Šã‚‚ã€ä¸€èˆ¬çš„ã«ã‚ˆã‚Šå¼·åŠ›ã§ã‚ã‚Šã€ã¾ãŸå†—é•·ã§ã‚‚ã‚ã‚Šã¾ã™ã€‚ä»¥ä¸‹ã®è¡¨ã«ã€ :c:func:`scanf` "
"ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒˆãƒ¼ã‚¯ãƒ³ã¨æ­£è¦è¡¨ç¾ã®å¤§ä½“åŒç­‰ãªå¯¾å¿œä»˜ã‘ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/re.rst:1278
msgid ":c:func:`scanf` Token"
msgstr ":c:func:`scanf` ãƒˆãƒ¼ã‚¯ãƒ³"

#: ../../library/re.rst:1278
msgid "Regular Expression"
msgstr "æ­£è¦è¡¨ç¾"

#: ../../library/re.rst:1280
msgid "``%c``"
msgstr "``%c``"

#: ../../library/re.rst:1282
msgid "``%5c``"
msgstr "``%5c``"

#: ../../library/re.rst:1282
msgid "``.{5}``"
msgstr "``.{5}``"

#: ../../library/re.rst:1284
msgid "``%d``"
msgstr "``%d``"

#: ../../library/re.rst:1284
msgid "``[-+]?\\d+``"
msgstr "``[-+]?\\d+``"

#: ../../library/re.rst:1286
msgid "``%e``, ``%E``, ``%f``, ``%g``"
msgstr "``%e``, ``%E``, ``%f``, ``%g``"

#: ../../library/re.rst:1286
msgid "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"
msgstr "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"

#: ../../library/re.rst:1288
msgid "``%i``"
msgstr "``%i``"

#: ../../library/re.rst:1288
msgid "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"
msgstr "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"

#: ../../library/re.rst:1290
msgid "``%o``"
msgstr "``%o``"

#: ../../library/re.rst:1290
msgid "``[-+]?[0-7]+``"
msgstr "``[-+]?[0-7]+``"

#: ../../library/re.rst:1292
msgid "``%s``"
msgstr "``%s``"

#: ../../library/re.rst:1292
msgid "``\\S+``"
msgstr "``\\S+``"

#: ../../library/re.rst:1294
msgid "``%u``"
msgstr "``%u``"

#: ../../library/re.rst:1294
msgid "``\\d+``"
msgstr "``\\d+``"

#: ../../library/re.rst:1296
msgid "``%x``, ``%X``"
msgstr "``%x``, ``%X``"

#: ../../library/re.rst:1296
msgid "``[-+]?(0[xX])?[\\dA-Fa-f]+``"
msgstr "``[-+]?(0[xX])?[\\dA-Fa-f]+``"

#: ../../library/re.rst:1299
msgid "To extract the filename and numbers from a string like ::"
msgstr "ä»¥ä¸‹ã®ã‚ˆã†ãªæ–‡å­—åˆ—ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«åã¨æ•°å€¤ã‚’æŠ½å‡ºã™ã‚‹ã“ã¨ã‚’è€ƒãˆã¾ã™ ::"

#: ../../library/re.rst:1303
msgid "you would use a :c:func:`scanf` format like ::"
msgstr ":c:func:`scanf` ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯æ¬¡ã®ã‚ˆã†ã«ä½¿ã„ã¾ã™ ::"

#: ../../library/re.rst:1307
msgid "The equivalent regular expression would be ::"
msgstr "åŒç­‰ãªæ­£è¦è¡¨ç¾ã¯ã“ã®ã‚ˆã†ãªã‚‚ã®ã¨ãªã‚Šã¾ã™ ::"

#: ../../library/re.rst:1315
msgid "search() vs. match()"
msgstr "search() vs. match()"

#: ../../library/re.rst:1319
msgid ""
"Python offers two different primitive operations based on regular "
"expressions: :func:`re.match` checks for a match only at the beginning of "
"the string, while :func:`re.search` checks for a match anywhere in the "
"string (this is what Perl does by default)."
msgstr ""
"Python ã¯æ­£è¦è¡¨ç¾ãƒ™ãƒ¼ã‚¹ã® 2 å€‹ã®åŸºæœ¬çš„ãªé–¢æ•°ã€æ–‡å­—åˆ—ã®å…ˆé ­ã§ã®ã¿ã®ãƒãƒƒãƒã‚’ç¢ºèªã™ã‚‹ :func:`re.match` "
"ãŠã‚ˆã³ã€æ–‡å­—åˆ—å†…ã®ä½ç½®ã«ã‹ã‹ã‚ã‚‰ãšãƒãƒƒãƒã‚’ç¢ºèªã™ã‚‹ :func:`re.search` (Perl ã§ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æŒ™å‹•) ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/re.rst:1330
msgid ""
"Regular expressions beginning with ``'^'`` can be used with :func:`search` "
"to restrict the match at the beginning of the string::"
msgstr "``'^'`` ã§å§‹ã¾ã‚‹æ­£è¦è¡¨ç¾ã¯ã€ :func:`search` ã«ãŠã„ã¦ã€ãƒãƒƒãƒã‚’æ–‡å­—åˆ—ã®å…ˆé ­ã‹ã‚‰ã«åˆ¶é™ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã—ã¾ã™::"

#: ../../library/re.rst:1338
msgid ""
"Note however that in :const:`MULTILINE` mode :func:`match` only matches at "
"the beginning of the string, whereas using :func:`search` with a regular "
"expression beginning with ``'^'`` will match at the beginning of each line. "
"::"
msgstr ""

#: ../../library/re.rst:1348
msgid "Making a Phonebook"
msgstr "é›»è©±å¸³ã®ä½œæˆ"

#: ../../library/re.rst:1350
msgid ""
":func:`split` splits a string into a list delimited by the passed pattern.  "
"The method is invaluable for converting textual data into data structures "
"that can be easily read and modified by Python as demonstrated in the "
"following example that creates a phonebook."
msgstr ""
":func:`split` "
"ã¯æ–‡å­—åˆ—ã‚’ä¸ãˆã‚‰ã‚ŒãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã§åˆ†å‰²ã—ã€ãƒªã‚¹ãƒˆã«ã—ã¦è¿”ã—ã¾ã™ã€‚ä¸‹è¨˜ã®ã€é›»è©±å¸³ä½œæˆã®ä¾‹ã®ã‚ˆã†ã«ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿ã‚„ã™ãã—ãŸã‚Šã€ "
"Python ã§ç·¨é›†ã—ãŸã‚Šã—ã‚„ã™ãã™ã‚‹éš›ã«ã€éå¸¸ã«å½¹ã«ç«‹ã¡ã¾ã™ã€‚"

#: ../../library/re.rst:1355
msgid ""
"First, here is the input.  Normally it may come from a file, here we are "
"using triple-quoted string syntax::"
msgstr ""

#: ../../library/re.rst:1366
msgid ""
"The entries are separated by one or more newlines. Now we convert the string"
" into a list with each nonempty line having its own entry:"
msgstr "å€‹ã€…ã®è¨˜éŒ²ã¯ã€1ã¤ä»¥ä¸Šã®æ”¹è¡Œã§åŒºåˆ‡ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚ã¾ãšã¯ã€æ–‡å­—åˆ—ã‹ã‚‰ç©ºè¡Œã‚’é™¤ãã€è¨˜éŒ²ã”ã¨ã®ãƒªã‚¹ãƒˆã«å¤‰æ›ã—ã¾ã—ã‚‡ã†ã€‚"

#: ../../library/re.rst:1379
msgid ""
"Finally, split each entry into a list with first name, last name, telephone "
"number, and address.  We use the ``maxsplit`` parameter of :func:`split` "
"because the address has spaces, our splitting pattern, in it:"
msgstr ""
"ãã—ã¦ã€å„è¨˜éŒ²ã‚’ã€åã€å§“ã€é›»è©±ç•ªå·ã€ãã—ã¦ã€ä½æ‰€ã«åˆ†å‰²ã—ã¦ãƒªã‚¹ãƒˆã«ã—ã¾ã™ã€‚åˆ†å‰²ã®ãŸã‚ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ä½¿ã£ã¦ã„ã‚‹ç©ºç™½æ–‡å­—ãŒã€ä½æ‰€ã«ã¯å«ã¾ã‚Œã‚‹ãŸã‚ã€ "
":func:`split` ã® ``maxsplit`` å¼•æ•°ã‚’ä½¿ã„ã¾ã™ã€‚ :"

#: ../../library/re.rst:1392
msgid ""
"The ``:?`` pattern matches the colon after the last name, so that it does "
"not occur in the result list.  With a ``maxsplit`` of ``4``, we could "
"separate the house number from the street name:"
msgstr ""
"ãƒ‘ã‚¿ãƒ¼ãƒ³ã€ ``:?`` ã¯å§“ã«ç¶šãã‚³ãƒ­ãƒ³ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ãã®ãŸã‚ã€ã‚³ãƒ­ãƒ³ã¯åˆ†å‰²çµæœã®ãƒªã‚¹ãƒˆã«ã¯ç¾ã‚Œã¾ã›ã‚“ã€‚ ``maxsplit`` ã‚’ ``4`` "
"ã«ã™ã‚Œã°ã€ãƒã‚¦ã‚¹ãƒŠãƒ³ãƒãƒ¼ã¨ã€ã‚¹ãƒˆãƒªãƒ¼ãƒˆåã‚’åˆ†å‰²ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ :"

#: ../../library/re.rst:1407
msgid "Text Munging"
msgstr "ãƒ†ã‚­ã‚¹ãƒˆã®ç§˜åŒ¿"

#: ../../library/re.rst:1409
msgid ""
":func:`sub` replaces every occurrence of a pattern with a string or the "
"result of a function.  This example demonstrates using :func:`sub` with a "
"function to \"munge\" text, or randomize the order of all the characters in "
"each word of a sentence except for the first and last characters::"
msgstr ""
":func:`sub` ã¯ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãƒãƒƒãƒã—ãŸéƒ¨åˆ†ã‚’æ–‡å­—åˆ—ã‚„é–¢æ•°ã®è¿”ã‚Šå€¤ã§ç½®ãæ›ãˆã¾ã™ã€‚ã“ã®ä¾‹ã§ã¯ã€ã€Œç§˜åŒ¿ã€ã™ã‚‹æ–‡å­—åˆ—ã«ã€é–¢æ•°ã¨å…±ã« "
":func:`sub` ã‚’é©ç”¨ã™ã‚‹ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚è¨€ã„æ›ãˆã‚‹ã¨ã€æœ€åˆã¨æœ€å¾Œã®æ–‡å­—ã‚’é™¤ãã€å˜èªä¸­ã®æ–‡å­—ã®ä½ç½®ã‚’ãƒ©ãƒ³ãƒ€ãƒ åŒ–ã—ã¾ã™ã€‚ ::"

#: ../../library/re.rst:1426
msgid "Finding all Adverbs"
msgstr "å…¨ã¦ã®å‰¯è©ã‚’è¦‹ã¤ã‘ã‚‹"

#: ../../library/re.rst:1428
msgid ""
":func:`findall` matches *all* occurrences of a pattern, not just the first "
"one as :func:`search` does.  For example, if a writer wanted to find all of "
"the adverbs in some text, they might use :func:`findall` in the following "
"manner::"
msgstr ""

#: ../../library/re.rst:1439
msgid "Finding all Adverbs and their Positions"
msgstr "å…¨ã¦ã®å‰¯è©ã¨ã€ãã®ä½ç½®ã‚’è¦‹ã¤ã‘ã‚‹"

#: ../../library/re.rst:1441
msgid ""
"If one wants more information about all matches of a pattern than the "
"matched text, :func:`finditer` is useful as it provides :ref:`match objects "
"<match-objects>` instead of strings.  Continuing with the previous example, "
"if a writer wanted to find all of the adverbs *and their positions* in some "
"text, they would use :func:`finditer` in the following manner::"
msgstr ""

#: ../../library/re.rst:1455
msgid "Raw String Notation"
msgstr "Raw Stringè¨˜æ³•"

#: ../../library/re.rst:1457
msgid ""
"Raw string notation (``r\"text\"``) keeps regular expressions sane.  Without"
" it, every backslash (``'\\'``) in a regular expression would have to be "
"prefixed with another one to escape it.  For example, the two following "
"lines of code are functionally identical::"
msgstr ""
"Raw æ–‡å­—åˆ—è¨˜æ³• (``r\"text\"``) ã«ã‚ˆã‚Šã€ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ (``'\\'``) "
"ã‚’å€‹ã€…ã«ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã§ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã™ã‚‹ã“ã¨ãªã—ã«ã€æ­£è¦è¡¨ç¾ã‚’æ­£å¸¸ãªçŠ¶æ…‹ã«ä¿ã¤ã“ã¨ãŒã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€ä»¥ä¸‹ã® 2 ã¤ã®ã‚³ãƒ¼ãƒ‰ã¯æ©Ÿèƒ½çš„ã«ç­‰ä¾¡ã§ã™::"

#: ../../library/re.rst:1467
msgid ""
"When one wants to match a literal backslash, it must be escaped in the "
"regular expression.  With raw string notation, this means ``r\"\\\\\"``.  "
"Without raw string notation, one must use ``\"\\\\\\\\\"``, making the "
"following lines of code functionally identical::"
msgstr ""
"æ–‡å­—é€šã‚Šã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã«ãƒãƒƒãƒã•ã›ãŸã„ãªã‚‰ã€æ­£è¦è¡¨ç¾ä¸­ã§ã¯ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚Raw æ–‡å­—åˆ—è¨˜æ³•ã§ã¯ã€``r\"\\\\\"``  "
"ã«ãªã‚Šã¾ã™ã€‚Raw æ–‡å­—åˆ—è¨˜æ³•ã‚’ç”¨ã„ãªã„å ´åˆã€``\"\\\\\\\\\"`` ã¨ã—ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¯æ©Ÿèƒ½çš„ã«ç­‰ä¾¡ã§ã™::"

#: ../../library/re.rst:1479
msgid "Writing a Tokenizer"
msgstr "ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚¶ã‚’æ›¸ã"

#: ../../library/re.rst:1481
msgid ""
"A `tokenizer or scanner <https://en.wikipedia.org/wiki/Lexical_analysis>`_ "
"analyzes a string to categorize groups of characters.  This is a useful "
"first step in writing a compiler or interpreter."
msgstr ""
"`ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚¶ã‚„ã‚¹ã‚­ãƒ£ãƒŠ <https://en.wikipedia.org/wiki/Lexical_analysis>`_ "
"ã¯æ–‡å­—åˆ—ã‚’è§£æã—ã€æ–‡å­—ã®ã‚°ãƒ«ãƒ¼ãƒ—ã«ã‚«ãƒ†ã‚´ãƒªåˆ†ã‘ã—ã¾ã™ã€‚ã“ã‚Œã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã‚„ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’ä½œæˆã™ã‚‹æœ€åˆã®ä¸€æ­©ã¨ã—ã¦å½¹ç«‹ã¡ã¾ã™ã€‚"

#: ../../library/re.rst:1485
msgid ""
"The text categories are specified with regular expressions.  The technique "
"is to combine those into a single master regular expression and to loop over"
" successive matches::"
msgstr "ãƒ†ã‚­ã‚¹ãƒˆã®ã‚«ãƒ†ã‚´ãƒªã¯æ­£è¦è¡¨ç¾ã§æŒ‡å®šã•ã‚Œã¾ã™ã€‚æŠ€è¡“çš„ã«ã¯ã€ãã‚Œã‚‰ã‚’ä¸€ã¤ã®ãƒã‚¹ã‚¿ãƒ¼æ­£è¦è¡¨ç¾ã«çµåˆã—ã€é€£ç¶šã—ãŸãƒãƒƒãƒã‚’ãƒ«ãƒ¼ãƒ—ã•ã›ã¾ã™::"

#: ../../library/re.rst:1535
msgid "The tokenizer produces the following output::"
msgstr "ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚¶ã¯ä»¥ä¸‹ã®å‡ºåŠ›ã‚’ä½œæˆã—ã¾ã™::"

#: ../../library/re.rst:1558
msgid ""
"Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O'Reilly Media, "
"2009. The third edition of the book no longer covers Python at all, but the "
"first edition covered writing good regular expression patterns in great "
"detail."
msgstr ""
