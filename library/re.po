# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# tomoğŸ§, 2017-2018
# Naoki INADA <songofacandy@gmail.com>, 2015-2016
# tomoğŸ§, 2017
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-20 13:43+0900\n"
"PO-Revision-Date: 2018-06-20 04:53+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/re.rst:3
msgid ":mod:`re` --- Regular expression operations"
msgstr ":mod:`re` --- æ­£è¦è¡¨ç¾æ“ä½œ"

#: ../../library/re.rst:11
msgid ""
"This module provides regular expression matching operations similar to those"
" found in Perl. Both patterns and strings to be searched can be Unicode "
"strings as well as 8-bit strings."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€ Perl ã§è¦‹ã‚‰ã‚Œã‚‹ã‚‚ã®ã¨åŒæ§˜ãªæ­£è¦è¡¨ç¾ãƒãƒƒãƒãƒ³ã‚°æ“ä½œã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨æ¤œç´¢å¯¾è±¡æ–‡å­—åˆ—ã®ä¸¡æ–¹ã«ã¤ã„ã¦ã€ 8 ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã¨ Unicode æ–‡å­—åˆ—ã‚’åŒã˜ã‚ˆã†ã«æ‰±ãˆã¾ã™ã€‚"

#: ../../library/re.rst:15
msgid ""
"Regular expressions use the backslash character (``'\\'``) to indicate "
"special forms or to allow special characters to be used without invoking "
"their special meaning.  This collides with Python's usage of the same "
"character for the same purpose in string literals; for example, to match a "
"literal backslash, one might have to write ``'\\\\\\\\'`` as the pattern "
"string, because the regular expression must be ``\\\\``, and each backslash "
"must be expressed as ``\\\\`` inside a regular Python string literal."
msgstr "æ­£è¦è¡¨ç¾ã§ã¯ã€ç‰¹æ®Šãªå½¢å¼ã‚’è¡¨ã—ãŸã‚Šã€ç‰¹æ®Šæ–‡å­—ã®æŒã¤ç‰¹åˆ¥ãªæ„å‘³ã‚’å‘¼ã³å‡ºã•ãšã«ãã®ç‰¹æ®Šãªæ–‡å­—ã‚’ä½¿ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ã€ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥æ–‡å­— (``'\\'``) ã‚’ä½¿ã„ã¾ã™ã€‚ã“ã†ã—ãŸãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã®ä½¿ã„æ–¹ã¯ã€ Python ã®æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã«ãŠã‘ã‚‹åŒã˜ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥æ–‡å­—ã¨è¡çªã‚’èµ·ã“ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥è‡ªä½“ã«ãƒãƒƒãƒã•ã›ã‚‹ã«ã¯ã€ãƒ‘ã‚¿ãƒ¼ãƒ³æ–‡å­—åˆ—ã¨ã—ã¦ ``'\\\\\\\\'`` ã¨æ›¸ã‹ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€ã¨ã„ã†ã®ã‚‚ã€æ­£è¦è¡¨ç¾ã¯ ``\\\\`` ã§ãªã‘ã‚Œã°ãªã‚‰ãšã€ã•ã‚‰ã«æ­£è¦ãª Python æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã§ã¯å„ã€…ã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’ ``\\\\`` ã¨è¡¨ç¾ã›ã­ã°ãªã‚‰ãªã„ã‹ã‚‰ã§ã™ã€‚"

#: ../../library/re.rst:24
msgid ""
"The solution is to use Python's raw string notation for regular expression "
"patterns; backslashes are not handled in any special way in a string literal"
" prefixed with ``'r'``.  So ``r\"\\n\"`` is a two-character string "
"containing ``'\\'`` and ``'n'``, while ``\"\\n\"`` is a one-character string"
" containing a newline.  Usually patterns will be expressed in Python code "
"using this raw string notation."
msgstr "æ­£è¦è¡¨ç¾ãƒ‘ã‚¿ãƒ¼ãƒ³ã« Python ã® raw string è¨˜æ³•ã‚’ä½¿ãˆã°ã“ã®å•é¡Œã‚’è§£æ±ºã§ãã¾ã™ã€‚ ``'r'`` ã‚’å‰ç½®ã—ãŸæ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«å†…ã§ã¯ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’ç‰¹åˆ¥æ‰±ã„ã—ã¾ã›ã‚“ã€‚å¾“ã£ã¦ã€ ``\"\\n\"`` ãŒæ”¹è¡Œä¸€æ–‡å­—ã®å…¥ã£ãŸæ–‡å­—åˆ—ã«ãªã‚‹ã®ã«å¯¾ã—ã¦ã€ ``r\"\\n\"`` ã¯ ``'\\'`` ã¨ ``'n'`` ã¨ã„ã†äºŒã¤ã®æ–‡å­—ã®å…¥ã£ãŸæ–‡å­—åˆ—ã«ãªã‚Šã¾ã™ã€‚é€šå¸¸ã€ Python ã‚³ãƒ¼ãƒ‰ä¸­ã§ã¯ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ã“ã® raw string è¨˜æ³•ã‚’ä½¿ã£ã¦è¡¨ç¾ã—ã¾ã™ã€‚"

#: ../../library/re.rst:31
msgid ""
"It is important to note that most regular expression operations are "
"available as module-level functions and :class:`RegexObject` methods.  The "
"functions are shortcuts that don't require you to compile a regex object "
"first, but miss some fine-tuning parameters."
msgstr "å¤§æŠµã®æ­£è¦è¡¨ç¾æ“ä½œãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«ã®é–¢æ•°ã¨ã€ :class:`RegexObject` ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã—ã¦æä¾›ã•ã‚Œã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ä¸‹ã•ã„ã€‚é–¢æ•°ã¯æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚’å¿…è¦ã¨ã—ãªã„è¿‘é“ã§ã™ãŒã€ã„ãã¤ã‹ã®ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°å¤‰æ•°ã‚’å¤±ã„ã¾ã™ã€‚"

#: ../../library/re.rst:38
msgid ""
"The third-party `regex <https://pypi.org/project/regex/>`_ module, which has"
" an API compatible with the standard library :mod:`re` module, but offers "
"additional functionality and a more thorough Unicode support."
msgstr "ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ã® `regex <https://pypi.org/project/regex/>`_ ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã® :mod:`re` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨äº’æ›ãª API ã‚’æŒã¡ã€è¿½åŠ ã®æ©Ÿèƒ½ã¨ã‚ˆã‚Šå¾¹åº•ã—ãŸ Unicode ã‚µãƒãƒ¼ãƒˆã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../library/re.rst:46
msgid "Regular Expression Syntax"
msgstr "æ­£è¦è¡¨ç¾ã®ã‚·ãƒ³ã‚¿ã‚¯ã‚¹"

#: ../../library/re.rst:48
msgid ""
"A regular expression (or RE) specifies a set of strings that matches it; the"
" functions in this module let you check if a particular string matches a "
"given regular expression (or if a given regular expression matches a "
"particular string, which comes down to the same thing)."
msgstr "æ­£è¦è¡¨ç¾ (ã™ãªã‚ã¡ RE) ã¯ã€è¡¨ç¾ã«ãƒãƒƒãƒ (match) ã™ã‚‹æ–‡å­—åˆ—ã®é›†åˆã‚’è¡¨ã—ã¦ã„ã¾ã™ã€‚ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®é–¢æ•°ã‚’ä½¿ãˆã°ã€ã‚ã‚‹æ–‡å­—åˆ—ãŒæŒ‡å®šã®æ­£è¦è¡¨ç¾ã«ãƒãƒƒãƒã™ã‚‹ã‹ (ã¾ãŸã¯æŒ‡å®šã®æ­£è¦è¡¨ç¾ãŒã‚ã‚‹æ–‡å­—åˆ—ã«ãƒãƒƒãƒã™ã‚‹ã‹ã€ã¤ã¾ã‚Šã¯åŒã˜ã“ã¨ã§ã™ãŒ) ã‚’æ¤œæŸ»ã§ãã¾ã™ã€‚"

#: ../../library/re.rst:53
msgid ""
"Regular expressions can be concatenated to form new regular expressions; if "
"*A* and *B* are both regular expressions, then *AB* is also a regular "
"expression. In general, if a string *p* matches *A* and another string *q* "
"matches *B*, the string *pq* will match AB.  This holds unless *A* or *B* "
"contain low precedence operations; boundary conditions between *A* and *B*; "
"or have numbered group references.  Thus, complex expressions can easily be "
"constructed from simpler primitive expressions like the ones described here."
"  For details of the theory and implementation of regular expressions, "
"consult the Friedl book referenced above, or almost any textbook about "
"compiler construction."
msgstr "æ­£è¦è¡¨ç¾ã‚’é€£çµã™ã‚‹ã¨æ–°ã—ã„æ­£è¦è¡¨ç¾ã‚’ä½œã‚Œã¾ã™ã€‚ *A* ã¨ *B* ãŒã¨ã‚‚ã«æ­£è¦è¡¨ç¾ã§ã‚ã‚Œã° *AB* ã‚‚æ­£è¦è¡¨ç¾ã§ã™ã€‚ä¸€èˆ¬çš„ã«ã€æ–‡å­—åˆ— *p* ãŒ Aã€€ã¨ãƒãƒƒãƒã—ã€åˆ¥ã®æ–‡å­—åˆ— *q* ãŒ B ã¨ãƒãƒƒãƒã™ã‚Œã°ã€æ–‡å­—åˆ— *pq* ã¯ AB ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ãŸã ã—ã€ã“ã®çŠ¶æ³ãŒæˆã‚Šç«‹ã¤ã®ã¯ã€ *A* ã¨ *B* ã¨ã®é–“ã«å¢ƒç•Œæ¡ä»¶ãŒã‚ã‚‹å ´åˆã‚„ã€ç•ªå·ä»˜ã‘ã•ã‚ŒãŸã‚°ãƒ«ãƒ¼ãƒ—å‚ç…§ã®ã‚ˆã†ãªã€å„ªå…ˆåº¦ã®ä½ã„æ¼”ç®—ã‚’ *A* ã‚„ *B* ãŒå«ã¾ãªã„å ´åˆã ã‘ã§ã™ã€‚ã‹ãã—ã¦ã€ã“ã“ã§è¿°ã¹ã‚‹ã‚ˆã†ãªã€ã‚ˆã‚Šç°¡å˜ã§ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãªæ­£è¦è¡¨ç¾ã‹ã‚‰ã€è¤‡é›‘ãªæ­£è¦è¡¨ç¾ã‚’å®¹æ˜“ã«æ§‹ç¯‰ã§ãã¾ã™ã€‚æ­£è¦è¡¨ç¾ã«é–¢ã™ã‚‹ç†è«–ã¨å®Ÿè£…ã®è©³ç´°ã«ã¤ã„ã¦ã¯ä¸Šè¨˜ã® Friedl æœ¬ã‹ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®æ§‹ç¯‰ã«é–¢ã™ã‚‹æ•™ç§‘æ›¸ã‚’èª¿ã¹ã¦ä¸‹ã•ã„ã€‚"

#: ../../library/re.rst:63
msgid ""
"A brief explanation of the format of regular expressions follows.  For "
"further information and a gentler presentation, consult the :ref:`regex-"
"howto`."
msgstr "ä»¥ä¸‹ã§æ­£è¦è¡¨ç¾ã®å½¢å¼ã«é–¢ã™ã‚‹ç°¡å˜ãªèª¬æ˜ã‚’ã—ã¦ãŠãã¾ã™ã€‚ã‚ˆã‚Šè©³ç´°ãªæƒ…å ±ã‚„ã‚ˆã‚Šã‚„ã•ã—ã„èª¬æ˜ã«é–¢ã—ã¦ã¯ã€ :ref:`regex-howto` ã‚’å‚ç…§ä¸‹ã•ã„ã€‚"

#: ../../library/re.rst:66
msgid ""
"Regular expressions can contain both special and ordinary characters. Most "
"ordinary characters, like ``'A'``, ``'a'``, or ``'0'``, are the simplest "
"regular expressions; they simply match themselves.  You can concatenate "
"ordinary characters, so ``last`` matches the string ``'last'``.  (In the "
"rest of this section, we'll write RE's in ``this special style``, usually "
"without quotes, and strings to be matched ``'in single quotes'``.)"
msgstr "æ­£è¦è¡¨ç¾ã«ã¯ã€ç‰¹æ®Šæ–‡å­—ã¨é€šå¸¸æ–‡å­—ã®ä¸¡æ–¹ã‚’å«ã‚ã‚‰ã‚Œã¾ã™ã€‚ ``'A'`` ã€ ``'a'`` ã€ã‚ã‚‹ã„ã¯ ``'0'`` ã®ã‚ˆã†ãªã»ã¨ã‚“ã©ã®é€šå¸¸æ–‡å­—ã¯æœ€ã‚‚ç°¡å˜ãªæ­£è¦è¡¨ç¾ã«ãªã‚Šã¾ã™ã€‚ã“ã†ã—ãŸæ–‡å­—ã¯ã€å˜ç´”ã«ãã®æ–‡å­—è‡ªä½“ã«ãƒãƒƒãƒã—ã¾ã™ã€‚é€šå¸¸ã®æ–‡å­—ã¯é€£çµã§ãã‚‹ã®ã§ã€ ``last`` ã¯æ–‡å­—åˆ— ``'last'`` ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚ (ã“ã®ç¯€ã®ä»¥é™ã®èª¬æ˜ã§ã¯ã€æ­£è¦è¡¨ç¾ã‚’å¼•ç”¨ç¬¦ã‚’ä½¿ã‚ãšã« ``ã“ã®è¡¨ç¤ºã‚¹ã‚¿ã‚¤ãƒ«: special style`` ã§æ›¸ãã€ãƒãƒƒãƒå¯¾è±¡ã®æ–‡å­—åˆ—ã¯ã€ ``'å¼•ç”¨ç¬¦ã§æ‹¬ã£ã¦'`` æ›¸ãã¾ã™ã€‚)"

#: ../../library/re.rst:73
msgid ""
"Some characters, like ``'|'`` or ``'('``, are special. Special characters "
"either stand for classes of ordinary characters, or affect how the regular "
"expressions around them are interpreted. Regular expression pattern strings "
"may not contain null bytes, but can specify the null byte using the "
"``\\number`` notation, e.g., ``'\\x00'``."
msgstr "``'|'`` ã‚„ ``'('`` ã¨ã„ã£ãŸã„ãã¤ã‹ã®æ–‡å­—ã¯ç‰¹æ®Šæ–‡å­—ã§ã™ã€‚ç‰¹æ®Šæ–‡å­—ã¯é€šå¸¸ã®æ–‡å­—ã®ç¨®åˆ¥ã‚’è¡¨ã—ãŸã‚Šã€ã‚ã‚‹ã„ã¯ç‰¹æ®Šæ–‡å­—ã®å‘¨è¾ºã«ã‚ã‚‹é€šå¸¸ã®æ–‡å­—ã«å¯¾ã™ã‚‹è§£é‡ˆæ–¹æ³•ã«å½±éŸ¿ã—ã¾ã™ã€‚æ­£è¦è¡¨ç¾ãƒ‘ã‚¿ãƒ¼ãƒ³æ–‡å­—åˆ—ã«ã¯ã€ null byte ã‚’å«ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ãŒã€ ``\\number`` è¨˜æ³•ã‚„ã€ ``'\\x00'`` ãªã©ã¨ã—ã¦æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/re.rst:79
msgid ""
"Repetition qualifiers (``*``, ``+``, ``?``, ``{m,n}``, etc) cannot be "
"directly nested. This avoids ambiguity with the non-greedy modifier suffix "
"``?``, and with other modifiers in other implementations. To apply a second "
"repetition to an inner repetition, parentheses may be used. For example, the"
" expression ``(?:a{6})*`` matches any multiple of six ``'a'`` characters."
msgstr "ç¹°ã‚Šè¿”ã—ã®ä¿®é£¾å­ (``*``, ``+``, ``?``, ``{m,n}`` ãªã©) ã¯ç›´æ¥å…¥ã‚Œå­ã«ã¯ã§ãã¾ã›ã‚“ã€‚\nã“ã‚Œã«ã‚ˆã£ã¦ã€éè²ªæ¬²ãªä¿®é£¾å­ã®æ¥å°¾è¾ ``?`` ã‚„ä»–ã®å®Ÿè£…ã§ã®ä»–ã®ä¿®é£¾å­ã«ã¤ã„ã¦ã®æ›–æ˜§ã•ã‚’å›é¿ã—ã¦ã„ã¾ã™ã€‚\nç¹°ã‚Šè¿”ã—ã®ã‚ã‚‹æ­£è¦è¡¨ç¾ã®å¤–å´ã«ã•ã‚‰ã«ç¹°ã‚Šè¿”ã—ã‚’é©ç”¨ã™ã‚‹ã«ã¯ä¸¸æ‹¬å¼§ãŒä½¿ãˆã¾ã™ã€‚\nä¾‹ãˆã°ã€æ­£è¦è¡¨ç¾ ``(?:a{6})*`` ã¯6ã¤ã® ``'a'`` ã®0å›ä»¥ä¸Šã®ç¹°ã‚Šè¿”ã—ã«é©åˆã—ã¾ã™ã€‚"

#: ../../library/re.rst:86
msgid "The special characters are:"
msgstr "ç‰¹æ®Šæ–‡å­—ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™:"

#: ../../library/re.rst:91
msgid "``'.'``"
msgstr "``'.'``"

#: ../../library/re.rst:89
msgid ""
"(Dot.)  In the default mode, this matches any character except a newline.  "
"If the :const:`DOTALL` flag has been specified, this matches any character "
"including a newline."
msgstr "(ãƒ‰ãƒƒãƒˆ) ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ¢ãƒ¼ãƒ‰ã§ã¯æ”¹è¡Œä»¥å¤–ã®ä»»æ„ã®æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ :const:`DOTALL` ãƒ•ãƒ©ã‚°ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚Œã°æ”¹è¡Œã‚‚å«ã‚€ã™ã¹ã¦ã®æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:95
msgid "``'^'``"
msgstr "``'^'``"

#: ../../library/re.rst:94
msgid ""
"(Caret.)  Matches the start of the string, and in :const:`MULTILINE` mode "
"also matches immediately after each newline."
msgstr "(ã‚­ãƒ£ãƒ¬ãƒƒãƒˆ) æ–‡å­—åˆ—ã®å…ˆé ­ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚ :const:`MULTILINE` ãƒ¢ãƒ¼ãƒ‰ã§ã¯å„æ”¹è¡Œã®ç›´å¾Œã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:104
msgid "``'$'``"
msgstr "``'$'``"

#: ../../library/re.rst:98
msgid ""
"Matches the end of the string or just before the newline at the end of the "
"string, and in :const:`MULTILINE` mode also matches before a newline.  "
"``foo`` matches both 'foo' and 'foobar', while the regular expression "
"``foo$`` matches only 'foo'.  More interestingly, searching for ``foo.$`` in"
" ``'foo1\\nfoo2\\n'`` matches 'foo2' normally, but 'foo1' in "
":const:`MULTILINE` mode; searching for a single ``$`` in ``'foo\\n'`` will "
"find two (empty) matches: one just before the newline, and one at the end of"
" the string."
msgstr "æ–‡å­—åˆ—ã®æœ«å°¾ã€ã‚ã‚‹ã„ã¯æ–‡å­—åˆ—ã®æœ«å°¾ã®æ”¹è¡Œã®ç›´å‰ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ ``foo`` ã¯ 'foo' ã¨ 'foobar' ã®ä¸¡æ–¹ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ä¸€æ–¹ã€æ­£è¦è¡¨ç¾ ``foo$`` ã¯ 'foo' ã ã‘ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚èˆˆå‘³æ·±ã„ã“ã¨ã«ã€ ``'foo1\\nfoo2\\n'`` ã‚’ ``foo.$`` ã§æ¤œç´¢ã—ãŸå ´åˆã€é€šå¸¸ã®ãƒ¢ãƒ¼ãƒ‰ã§ã¯ 'foo2' ã ã‘ã«ãƒãƒƒãƒã—ã€ :const:`MULTILINE` ãƒ¢ãƒ¼ãƒ‰ã§ã¯ 'foo1' ã«ã‚‚ãƒãƒƒãƒã—ã¾ã™ã€‚ ``$`` ã ã‘ã§ ``'foo\\n'`` ã‚’æ¤œç´¢ã—ãŸå ´åˆã€2ç®‡æ‰€ (å†…å®¹ã¯ç©º) ã§ãƒãƒƒãƒã—ã¾ã™: 1ã¤ã¯ã€æ”¹è¡Œã®ç›´å‰ã§ã€ã‚‚ã†1ã¤ã¯ã€æ–‡å­—åˆ—ã®æœ€å¾Œã§ã™ã€‚"

#: ../../library/re.rst:109
msgid "``'*'``"
msgstr "``'*'``"

#: ../../library/re.rst:107
msgid ""
"Causes the resulting RE to match 0 or more repetitions of the preceding RE, "
"as many repetitions as are possible.  ``ab*`` will match 'a', 'ab', or 'a' "
"followed by any number of 'b's."
msgstr "ç›´å‰ã«ã‚ã‚‹ RE ã«ä½œç”¨ã—ã¦ã€ RE ã‚’ 0 å›ä»¥ä¸Šã§ãã‚‹ã ã‘å¤šãç¹°ã‚Šè¿”ã—ãŸã‚‚ã®ã«ãƒãƒƒãƒã•ã›ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ä¾‹ãˆã° ``ab*`` ã¯ 'a'ã€'ab'ã€ã‚ã‚‹ã„ã¯ 'a' ã«ä»»æ„å€‹æ•°ã®'b' ã‚’ç¶šã‘ãŸã‚‚ã®ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:114
msgid "``'+'``"
msgstr "``'+'``"

#: ../../library/re.rst:112
msgid ""
"Causes the resulting RE to match 1 or more repetitions of the preceding RE. "
"``ab+`` will match 'a' followed by any non-zero number of 'b's; it will not "
"match just 'a'."
msgstr "ç›´å‰ã«ã‚ã‚‹ RE ã«ä½œç”¨ã—ã¦ã€ RE ã‚’ã€1 å›ä»¥ä¸Šç¹°ã‚Šè¿”ã—ãŸã‚‚ã®ã«ãƒãƒƒãƒã•ã›ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ä¾‹ãˆã° ``ab+`` ã¯ 'a' ã«ä¸€ã¤ä»¥ä¸Šã® 'b' ãŒç¶šã„ãŸã‚‚ã®ã«ãƒãƒƒãƒã—ã€ 'a' å˜ä½“ã«ã¯ãƒãƒƒãƒã—ã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:118
msgid "``'?'``"
msgstr "``'?'``"

#: ../../library/re.rst:117
msgid ""
"Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. "
"``ab?`` will match either 'a' or 'ab'."
msgstr "ç›´å‰ã«ã‚ã‚‹ RE ã«ä½œç”¨ã—ã¦ã€ RE ã‚’ 0 å›ã‹ 1 å›ç¹°ã‚Šè¿”ã—ãŸã‚‚ã®ã«ãƒãƒƒãƒã•ã›ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ä¾‹ãˆã° ``ab?`` ã¯ 'a' ã‚ã‚‹ã„ã¯ 'ab' ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:127
msgid "``*?``, ``+?``, ``??``"
msgstr "``*?``, ``+?``, ``??``"

#: ../../library/re.rst:121
msgid ""
"The ``'*'``, ``'+'``, and ``'?'`` qualifiers are all :dfn:`greedy`; they "
"match as much text as possible.  Sometimes this behaviour isn't desired; if "
"the RE ``<.*>`` is matched against ``<a> b <c>``, it will match the entire "
"string, and not just ``<a>``.  Adding ``?`` after the qualifier makes it "
"perform the match in :dfn:`non-greedy` or :dfn:`minimal` fashion; as *few* "
"characters as possible will be matched.  Using the RE ``<.*?>`` will match "
"only ``<a>``."
msgstr "``'*'`` ã€ ``'+'`` ã€ ``'?'`` ã¨ã„ã£ãŸä¿®é£¾å­ã¯ã€ã™ã¹ã¦ :dfn:`è²ªæ¬² (greedy)` ãƒãƒƒãƒã€ã™ãªã‚ã¡ã§ãã‚‹ã ã‘å¤šãã®ãƒ†ã‚­ã‚¹ãƒˆã«ãƒãƒƒãƒã™ã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚æ™‚ã«ã¯ã“ã®å‹•ä½œãŒæœ›ã¾ã—ããªã„å ´åˆã‚‚ã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°æ­£è¦è¡¨ç¾ ``<.*>`` ã‚’ ``<a> b <c>`` ã«ãƒãƒƒãƒã•ã›ã‚‹ã¨ã€ ``<a>`` ã ã‘ã«ãƒãƒƒãƒã™ã‚‹ã®ã§ã¯ãªãå…¨æ–‡å­—åˆ—ã«ãƒãƒƒãƒã—ã¦ã—ã¾ã„ã¾ã™ã€‚ ``?`` ã‚’ä¿®é£¾å­ã®å¾Œã«è¿½åŠ ã™ã‚‹ã¨ã€ :dfn:`éè²ªæ¬² (non-greedy)` ã‚ã‚‹ã„ã¯ :dfn:`æœ€å°ä¸€è‡´ (minimal)` ã®ãƒãƒƒãƒã«ãªã‚Šã€ã§ãã‚‹ã ã‘ *å°‘ãªã„* æ–‡å­—æ•°ã®ãƒãƒƒãƒã«ãªã‚Šã¾ã™ã€‚ä¾‹ãˆã°æ­£è¦è¡¨ç¾ ``<.*?>`` ã‚’ä½¿ã†ã¨ ``<a>`` ã ã‘ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:132
msgid "``{m}``"
msgstr "``{m}``"

#: ../../library/re.rst:130
msgid ""
"Specifies that exactly *m* copies of the previous RE should be matched; "
"fewer matches cause the entire RE not to match.  For example, ``a{6}`` will "
"match exactly six ``'a'`` characters, but not five."
msgstr "å‰ã«ã‚ã‚‹ RE ã® *m* å›ã®æ­£ç¢ºãªã‚³ãƒ”ãƒ¼ã¨ãƒãƒƒãƒã™ã¹ãã§ã‚ã‚‹ã“ã¨ã‚’æŒ‡å®šã—ã¾ã™ï¼›ãƒãƒƒãƒå›æ•°ãŒå°‘ãªã‘ã‚Œã°ã€RE å…¨ä½“ã§ã¯ãƒãƒƒãƒã—ã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€ ``a{6}`` ã¯ã€æ­£ç¢ºã« 6å€‹ã® ``'a'`` æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™ãŒã€ 5å€‹ã§ã¯ãƒãƒƒãƒã—ã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:141
msgid "``{m,n}``"
msgstr "``{m,n}``"

#: ../../library/re.rst:135
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible.  For "
"example, ``a{3,5}`` will match from 3 to 5 ``'a'`` characters.  Omitting *m*"
" specifies a lower bound of zero,  and omitting *n* specifies an infinite "
"upper bound.  As an example, ``a{4,}b`` will match ``aaaab`` or a thousand "
"``'a'`` characters followed by a ``b``, but not ``aaab``. The comma may not "
"be omitted or the modifier would be confused with the previously described "
"form."
msgstr "çµæœã® RE ã¯ã€å‰ã«ã‚ã‚‹ RE ã‚’ã€ *m* å›ã‹ã‚‰ *n* å›ã¾ã§ç¹°ã‚Šè¿”ã—ãŸã‚‚ã®ã§ã€ã§ãã‚‹ã ã‘å¤šãç¹°ã‚Šè¿”ã—ãŸã‚‚ã®ã¨ãƒãƒƒãƒã™ã‚‹ã‚ˆã†ã«ã€ãƒãƒƒãƒã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ ``a{3,5}`` ã¯ã€3å€‹ã‹ã‚‰ 5å€‹ã® ``'a'`` æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚ *m* ã‚’çœç•¥ã™ã‚‹ã¨ãƒãƒƒãƒå›æ•°ã®ä¸‹é™ã¨ã—ã¦0ã‚’æŒ‡å®šã—ãŸäº‹ã«ãªã‚Šã€ *n* ã‚’çœç•¥ã™ã‚‹ã“ã¨ã¯ã€ä¸Šé™ãŒç„¡é™ã§ã‚ã‚‹ã“ã¨ã‚’æŒ‡å®šã—ã¾ã™ï¼› ``a{4,}b`` ã¯ ``aaaab`` ã‚„ã€åƒå€‹ã® ``'a'`` æ–‡å­—ã« ``b`` ãŒç¶šã„ãŸã‚‚ã®ã¨ãƒãƒƒãƒã—ã¾ã™ãŒã€ ``aaab`` ã¨ã¯ãƒãƒƒãƒã—ã¾ã›ã‚“ã€‚ã‚³ãƒ³ãƒã¯çœç•¥ã§ãã¾ã›ã‚“ã€ãã†ã§ãªã„ã¨ä¿®é£¾å­ãŒä¸Šã§è¿°ã¹ãŸå½¢å¼ã¨æ··åŒã•ã‚Œã¦ã—ã¾ã†ã‹ã‚‰ã§ã™ã€‚"

#: ../../library/re.rst:148
msgid "``{m,n}?``"
msgstr "``{m,n}?``"

#: ../../library/re.rst:144
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as *few* repetitions as possible.  This is"
" the non-greedy version of the previous qualifier.  For example, on the "
"6-character string ``'aaaaaa'``, ``a{3,5}`` will match 5 ``'a'`` characters,"
" while ``a{3,5}?`` will only match 3 characters."
msgstr "çµæœã® RE ã¯ã€å‰ã«ã‚ã‚‹ RE ã® *m* å›ã‹ã‚‰ *n* å›ã¾ã§ç¹°ã‚Šè¿”ã—ãŸã‚‚ã®ã§ã€ã§ãã‚‹ã ã‘ *å°‘ãªã* ç¹°ã‚Šè¿”ã—ãŸã‚‚ã®ã¨ãƒãƒƒãƒã™ã‚‹ã‚ˆã†ã«ã€ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã¯ã€å‰ã®ä¿®é£¾å­ã®æ§ãˆç›®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã™ã€‚ä¾‹ãˆã°ã€ 6æ–‡å­—æ–‡å­—åˆ— ``'aaaaaa'`` ã§ã¯ã€ ``a{3,5}`` ã¯ã€5å€‹ã® ``'a'`` æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™ãŒã€ ``a{3,5}?`` ã¯3å€‹ã®æ–‡å­—ã¨ãƒãƒƒãƒã™ã‚‹ã ã‘ã§ã™ã€‚"

#: ../../library/re.rst:161
msgid "``'\\'``"
msgstr "``'\\'``"

#: ../../library/re.rst:151
msgid ""
"Either escapes special characters (permitting you to match characters like "
"``'*'``, ``'?'``, and so forth), or signals a special sequence; special "
"sequences are discussed below."
msgstr "ç‰¹æ®Šæ–‡å­—ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã™ã‚‹( ``'*'`` ã‚„ ``'?'`` ç­‰ã®ã‚ˆã†ãªæ–‡å­—ã¨ã®ãƒãƒƒãƒã‚’ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹) ã‹ã€ã‚ã‚‹ã„ã¯ã€ç‰¹æ®Šã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®åˆå›³ã§ã™; ç‰¹æ®Šã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯å¾Œã§è­°è«–ã—ã¾ã™ã€‚"

#: ../../library/re.rst:155
msgid ""
"If you're not using a raw string to express the pattern, remember that "
"Python also uses the backslash as an escape sequence in string literals; if "
"the escape sequence isn't recognized by Python's parser, the backslash and "
"subsequent character are included in the resulting string.  However, if "
"Python would recognize the resulting sequence, the backslash should be "
"repeated twice.  This is complicated and hard to understand, so it's highly "
"recommended that you use raw strings for all but the simplest expressions."
msgstr "ã‚‚ã—ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è¡¨ç¾ã™ã‚‹ã®ã« raw string ã‚’ä½¿ç”¨ã—ã¦ã„ãªã„ã®ã§ã‚ã‚Œã°ã€ Python ã‚‚ã€ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã§ã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¨ã—ã¦ä½¿ã£ã¦ã„ã‚‹ã“ã¨ã‚’è¦šãˆã¦ã„ã¦ä¸‹ã•ã„ï¼›ã‚‚ã—ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ Python ã®æ§‹æ–‡è§£æå™¨ãŒèªè­˜ã—ã¦å‡¦ç†ã—ãªã‘ã‚Œã°ã€ãã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã¨ãã‚Œã«ç¶šãæ–‡å­—ã¯ã€çµæœã®æ–‡å­—åˆ—ã«ãã®ã¾ã¾å«ã¾ã‚Œã¾ã™ã€‚ã—ã‹ã—ã€ã‚‚ã— Python ãŒçµæœã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’èªè­˜ã™ã‚‹ã®ã§ã‚ã‚Œã°ã€ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’ 2å›ç¹°ã‚Šè¿”ã•ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€‚ã“ã®ã“ã¨ã¯è¤‡é›‘ã§ç†è§£ã—ã«ãã„ã®ã§ã€æœ€ã‚‚ç°¡å˜ãªè¡¨ç¾ä»¥å¤–ã¯ã€ã™ã¹ã¦ raw string ã‚’ä½¿ã†ã“ã¨ã‚’ãœã²å‹§ã‚ã¾ã™ã€‚"

#: ../../library/re.rst:193
msgid "``[]``"
msgstr "``[]``"

#: ../../library/re.rst:164
msgid "Used to indicate a set of characters.  In a set:"
msgstr "æ–‡å­—ã®é›†åˆã‚’æŒ‡å®šã™ã‚‹ã®ã«ä½¿ç”¨ã—ã¾ã™ã€‚é›†åˆã«ã¯ä»¥ä¸‹ã®ã‚‚ã®ãŒæŒ‡å®šã§ãã¾ã™:"

#: ../../library/re.rst:166
msgid ""
"Characters can be listed individually, e.g. ``[amk]`` will match ``'a'``, "
"``'m'``, or ``'k'``."
msgstr "å€‹åˆ¥ã«æŒ‡å®šã§ãã‚‹æ–‡å­—ã€‚ ``[amk]`` ã¯ ``'a'``, ``'m'``, ``'k'`` ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:169
msgid ""
"Ranges of characters can be indicated by giving two characters and "
"separating them by a ``'-'``, for example ``[a-z]`` will match any lowercase"
" ASCII letter, ``[0-5][0-9]`` will match all the two-digits numbers from "
"``00`` to ``59``, and ``[0-9A-Fa-f]`` will match any hexadecimal digit.  If "
"``-`` is escaped (e.g. ``[a\\-z]``) or if it's placed as the first or last "
"character (e.g. ``[a-]``), it will match a literal ``'-'``."
msgstr "é€£ç¶šã—ãŸæ–‡å­—ã®ç¯„å›²ã‚’ã€å…ˆé ­ã¨æœ€å¾Œã®2æ–‡å­—ã¨ãã®é–“ã« ``'-'`` ã‚’æŒŸã‚“ã å½¢ã§æŒ‡å®šã§ãã¾ã™ã€‚ ``[a-z]`` ã¯ã™ã¹ã¦ã®å°æ–‡å­—ã® ASCII æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚ ``[0-5][0-9]`` ã¯ ``00`` ã‹ã‚‰ ``59`` ã¾ã§ã®ã€ã™ã¹ã¦ã® 2 æ¡ã®æ•°å­—ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚ ``[0-9A-Fa-f]`` ã¯ä»»æ„ã® 16 é€²æ•°ã®æ•°å­—ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚ ``-`` ãŒã€ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚ŒãŸå ´åˆ (ä¾‹: ``[a\\-z]``)ã€ã‚ã‚‹ã„ã¯å…ˆé ­ã‹æœ«å°¾ã«ç½®ã‹ã‚ŒãŸå ´åˆ (ä¾‹: ``[a-]``)ã€ãƒªãƒ†ãƒ©ãƒ« ``'-'`` ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:176
msgid ""
"Special characters lose their special meaning inside sets.  For example, "
"``[(+*)]`` will match any of the literal characters ``'('``, ``'+'``, "
"``'*'``, or ``')'``."
msgstr "é›†åˆå†…ã§ã¯ã€ç‰¹æ®Šæ–‡å­—ã¯ãã®æ„å‘³ã‚’å¤±ã„ã¾ã™ã€‚ ``[(+*)]`` ã¯ãƒªãƒ†ãƒ©ãƒ«æ–‡å­— ``'('`` ``'+'`` ã€ ``'*'`` ã€ã‚ã‚‹ã„ã¯ ``')'`` ã®ã„ãšã‚Œã‹ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:180
msgid ""
"Character classes such as ``\\w`` or ``\\S`` (defined below) are also "
"accepted inside a set, although the characters they match depends on whether"
" :const:`LOCALE` or  :const:`UNICODE` mode is in force."
msgstr "``\\w`` ã‚„ ``\\S`` ã®ã‚ˆã†ãªæ–‡å­—ã‚¯ãƒ©ã‚¹ (å¾Œè¿°) ã‚‚é›†åˆå†…ã«æŒ‡å®šã§ãã¾ã™ãŒã€ãã‚Œã‚‰ã«ãƒãƒƒãƒã™ã‚‹æ–‡å­—ã¯ :const:`LOCALE` ã‹ :const:`UNICODE` ã®ã©ã¡ã‚‰ã‹æœ‰åŠ¹ã«ã•ã‚Œã¦ã„ã‚‹ãƒ¢ãƒ¼ãƒ‰ã«ä¾å­˜ã—ã¾ã™ã€‚"

#: ../../library/re.rst:184
msgid ""
"Characters that are not within a range can be matched by "
":dfn:`complementing` the set.  If the first character of the set is ``'^'``,"
" all the characters that are *not* in the set will be matched.  For example,"
" ``[^5]`` will match any character except ``'5'``, and ``[^^]`` will match "
"any character except ``'^'``.  ``^`` has no special meaning if it's not the "
"first character in the set."
msgstr "ç¯„å›²å†…ã«ãªã„æ–‡å­—ã¨ã¯ã€ãã®é›†åˆã® :dfn:`è£œé›†åˆ` ã‚’ã¨ã‚‹ã“ã¨ã§ãƒãƒƒãƒã§ãã¾ã™ã€‚é›†åˆã®æœ€åˆã®æ–‡å­—ãŒ ``'^'`` ã®æ™‚ã€é›†åˆã« *ãªã„* æ–‡å­—ã™ã¹ã¦ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚ ``[^5]`` ã¯ ``'5'`` ã‚’é™¤ãã‚ã‚‰ã‚†ã‚‹æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ ``[^^]`` ã¯ ``'^'`` ã‚’é™¤ãã‚ã‚‰ã‚†ã‚‹æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ ``^`` ã¯é›†åˆã®æœ€åˆã®æ–‡å­—ã§ãªã„é™ã‚Šç‰¹åˆ¥ã®æ„å‘³ã‚’æŒã¡ã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:191
msgid ""
"To match a literal ``']'`` inside a set, precede it with a backslash, or "
"place it at the beginning of the set.  For example, both ``[()[\\]{}]`` and "
"``[]()[{}]`` will both match a parenthesis."
msgstr "é›†åˆå†…ã§ãƒªãƒ†ãƒ©ãƒ« ``']'`` ã‚’ãƒãƒƒãƒã•ã›ã‚‹ã«ã¯ã€ãã®å‰ã«ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’ã¤ã‘ã‚‹ã‹ã€é›†åˆã®å…ˆé ­ã«ç½®ãã¾ã™ã€‚ ``[()[\\]{}]`` ã¨ ``[]()[{}]`` ã¯ã©ã¡ã‚‰ã‚‚ ``']'`` ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:204
msgid "``'|'``"
msgstr "``'|'``"

#: ../../library/re.rst:196
msgid ""
"``A|B``, where A and B can be arbitrary REs, creates a regular expression "
"that will match either A or B.  An arbitrary number of REs can be separated "
"by the ``'|'`` in this way.  This can be used inside groups (see below) as "
"well.  As the target string is scanned, REs separated by ``'|'`` are tried "
"from left to right. When one pattern completely matches, that branch is "
"accepted. This means that once ``A`` matches, ``B`` will not be tested "
"further, even if it would produce a longer overall match.  In other words, "
"the ``'|'`` operator is never greedy.  To match a literal ``'|'``, use "
"``\\|``, or enclose it inside a character class, as in ``[|]``."
msgstr "``A|B`` ã¯ã€ã“ã“ã§ A ã¨ B ã¯ä»»æ„ã® RE ã§ã™ãŒã€ A ã‹ B ã®ã©ã¡ã‚‰ã‹ã¨ãƒãƒƒãƒã™ã‚‹æ­£è¦è¡¨ç¾ã‚’ä½œæˆã—ã¾ã™ã€‚ä»»æ„å€‹æ•°ã® RE ã‚’ã€ã“ã†ã„ã†é¢¨ã« ``'|'`` ã§åˆ†é›¢ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã¯ã‚°ãƒ«ãƒ¼ãƒ— (ä»¥ä¸‹å‚ç…§) å†…éƒ¨ã§ã‚‚åŒæ§˜ã«ä½¿ãˆã¾ã™ã€‚æ¤œæŸ»å¯¾è±¡æ–‡å­—åˆ—ã‚’ã‚¹ã‚­ãƒ£ãƒ³ã™ã‚‹ä¸­ã§ã€ ``'|'`` ã§åˆ†é›¢ã•ã‚ŒãŸ RE ã¯å·¦ã‹ã‚‰å³ã¸ã®é †ã«æ¤œæŸ»ã•ã‚Œã¾ã™ã€‚ä¸€ã¤ã§ã‚‚å®Œå…¨ã«ãƒãƒƒãƒã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ãŒã‚ã‚Œã°ã€ãã®ãƒ‘ã‚¿ãƒ¼ãƒ³æãŒå—ç†ã•ã‚Œã¾ã™ã€‚ã“ã®ã“ã¨ã¯ã€ã‚‚ã— ``A`` ãŒãƒãƒƒãƒã™ã‚Œã°ã€ãŸã¨ãˆ ``B`` ã«ã‚ˆã‚‹ãƒãƒƒãƒãŒå…¨ä½“ã¨ã—ã¦ã‚ˆã‚Šé•·ã„ãƒãƒƒãƒã«ãªã£ãŸã¨ã—ã¦ã‚‚ã€ ``B`` ã‚’æ±ºã—ã¦æ¤œæŸ»ã—ãªã„ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚è¨€ã„ã‹ãˆã‚‹ã¨ã€ ``'|'`` æ¼”ç®—å­ã¯æ±ºã—ã¦è²ªæ¬² (greedy) ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚æ–‡å­—é€šã‚Šã® ``'|'`` ã¨ãƒãƒƒãƒã™ã‚‹ã«ã¯ã€ ``\\|`` ã‚’ä½¿ã†ã‹ã€ã‚ã‚‹ã„ã¯ãã‚Œã‚’ ``[|]`` ã®ã‚ˆã†ã«æ–‡å­—ã‚¯ãƒ©ã‚¹å†…ã«å…¥ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:211
msgid "``(...)``"
msgstr "``(...)``"

#: ../../library/re.rst:207
msgid ""
"Matches whatever regular expression is inside the parentheses, and indicates"
" the start and end of a group; the contents of a group can be retrieved "
"after a match has been performed, and can be matched later in the string "
"with the ``\\number`` special sequence, described below.  To match the "
"literals ``'('`` or ``')'``, use ``\\(`` or ``\\)``, or enclose them inside "
"a character class: ``[(] [)]``."
msgstr "ä¸¸æ‹¬å¼§ã®ä¸­ã«ã©ã®ã‚ˆã†ãªæ­£è¦è¡¨ç¾ãŒã‚ã£ã¦ã‚‚ãƒãƒƒãƒã—ã€ã¾ãŸã‚°ãƒ«ãƒ¼ãƒ—ã®å…ˆé ­ã¨æœ«å°¾ã‚’è¡¨ã—ã¾ã™ï¼›ã‚°ãƒ«ãƒ¼ãƒ—ã®ä¸­èº«ã¯ã€ãƒãƒƒãƒãŒå®Ÿè¡Œã•ã‚ŒãŸå¾Œã«æ¤œç´¢ã•ã‚Œã€å¾Œè¿°ã™ã‚‹ ``\\number`` ç‰¹æ®Šã‚·ãƒ¼ã‚±ãƒ³ã‚¹ä»˜ãã®æ–‡å­—åˆ—å†…ã§ã€å¾Œã§ãƒãƒƒãƒã•ã‚Œã¾ã™ã€‚æ–‡å­—é€šã‚Šã® ``'('`` ã‚„ ``')'`` ã¨ãƒãƒƒãƒã™ã‚‹ã«ã¯ã€ ``\\(`` ã‚ã‚‹ã„ã¯ ``\\)`` ã‚’ä½¿ã†ã‹ã€ãã‚Œã‚‰ã‚’æ–‡å­—ã‚¯ãƒ©ã‚¹å†…ã«å…¥ã‚Œã¾ã™ï¼š ``[(] [)]`` ã€‚"

#: ../../library/re.rst:218
msgid "``(?...)``"
msgstr "``(?...)``"

#: ../../library/re.rst:214
msgid ""
"This is an extension notation (a ``'?'`` following a ``'('`` is not "
"meaningful otherwise).  The first character after the ``'?'`` determines "
"what the meaning and further syntax of the construct is. Extensions usually "
"do not create a new group; ``(?P<name>...)`` is the only exception to this "
"rule. Following are the currently supported extensions."
msgstr "ã“ã‚Œã¯æ‹¡å¼µè¨˜æ³•ã§ã™ (``'('`` ã«ç¶šã ``'?'`` ã¯ä»–ã«ã¯æ„å‘³ãŒã‚ã‚Šã¾ã›ã‚“) ã€‚ ``'?'`` ã®å¾Œã®æœ€åˆã®æ–‡å­—ãŒã€ã“ã®æ§‹é€ ã®æ„å‘³ã¨ã“ã‚Œä»¥ä¸Šã®ã‚·ãƒ³ã‚¿ã‚¯ã‚¹ãŒã©ã†ã„ã†ã‚‚ã®ã§ã‚ã‚‹ã‹ã‚’æ±ºå®šã—ã¾ã™ã€‚æ‹¡å¼µè¨˜æ³•ã¯æ™®é€šæ–°ã—ã„ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆã—ã¾ã›ã‚“ï¼› ``(?P<name>...)`` ãŒã“ã®è¦å‰‡ã®å”¯ä¸€ã®ä¾‹å¤–ã§ã™ã€‚ä»¥ä¸‹ã«ç¾åœ¨ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹æ‹¡å¼µè¨˜æ³•ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/re.rst:235
msgid "``(?iLmsux)``"
msgstr "``(?iLmsux)``"

#: ../../library/re.rst:221
msgid ""
"(One or more letters from the set ``'i'``, ``'L'``, ``'m'``, ``'s'``, "
"``'u'``, ``'x'``.)  The group matches the empty string; the letters set the "
"corresponding flags: :const:`re.I` (ignore case), :const:`re.L` (locale "
"dependent), :const:`re.M` (multi-line), :const:`re.S` (dot matches all), "
":const:`re.U` (Unicode dependent), and :const:`re.X` (verbose), for the "
"entire regular expression. (The flags are described in :ref:`contents-of-"
"module-re`.) This is useful if you wish to include the flags as part of the "
"regular expression, instead of passing a *flag* argument to the "
":func:`re.compile` function."
msgstr "( é›†åˆ ``'i'``, ``'L'``, ``'m'``, ``'s'``, ``'u'``, ``'x'`` ã‹ã‚‰1æ–‡å­—ä»¥ä¸Š) ã€‚ã‚°ãƒ«ãƒ¼ãƒ—ã¯ç©ºæ–‡å­—åˆ—ã¨ã‚‚ãƒãƒƒãƒã—ã¾ã™ï¼›æ–‡å­—ã¯ã€æ­£è¦è¡¨ç¾å…¨ä½“ã®å¯¾å¿œã™ã‚‹ãƒ•ãƒ©ã‚° (:const:`re.I` (å¤§æ–‡å­—ãƒ»å°æ–‡å­—ã‚’åŒºåˆ¥ã—ãªã„), :const:`re.L` (ãƒ­ã‚±ãƒ¼ãƒ«ä¾å­˜), :const:`re.M` (MULTILINEãƒ¢ãƒ¼ãƒ‰), :const:`re.S` (DOTALLãƒ¢ãƒ¼ãƒ‰), :const:`re.U` (Unicodeä¾å­˜), :const:`re.X` (å†—é•·) ) ã‚’è¨­å®šã—ã¾ã™ã€‚ (ãƒ•ãƒ©ã‚°ã«ã¤ã„ã¦ã¯ã€ :ref:`contents-of-module-re` ã«è¨˜è¿°ãŒã‚ã‚Šã¾ã™) ã“ã‚Œã¯ã€ã‚‚ã— *flag* å¼•æ•°ã‚’ :func:`re.compile` é–¢æ•°ã«æ¸¡ã•ãšã«ã€ãã®ãƒ•ãƒ©ã‚°ã‚’æ­£è¦è¡¨ç¾ã®ä¸€éƒ¨ã¨ã—ã¦å«ã‚ãŸã„ãªã‚‰ã°å½¹ã«ç«‹ã¡ã¾ã™ã€‚"

#: ../../library/re.rst:232
msgid ""
"Note that the ``(?x)`` flag changes how the expression is parsed. It should "
"be used first in the expression string, or after one or more whitespace "
"characters. If there are non-whitespace characters before the flag, the "
"results are undefined."
msgstr "``(?x)`` ãƒ•ãƒ©ã‚°ã¯ã€å¼ãŒæ§‹æ–‡è§£æã•ã‚Œã‚‹æ–¹æ³•ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ä¸‹ã•ã„ã€‚ã“ã‚Œã¯å¼æ–‡å­—åˆ—å†…ã®æœ€åˆã‹ã€ã‚ã‚‹ã„ã¯1ã¤ä»¥ä¸Šã®ç©ºç™½æ–‡å­—ã®å¾Œã§ä½¿ã†ã¹ãã§ã™ã€‚ã‚‚ã—ã“ã®ãƒ•ãƒ©ã‚°ã®å‰ã«éç©ºç™½æ–‡å­—ãŒã‚ã‚‹ã¨ã€ãã®çµæœã¯æœªå®šç¾©ã§ã™ã€‚"

#: ../../library/re.rst:241
msgid "``(?:...)``"
msgstr "``(?:...)``"

#: ../../library/re.rst:238
msgid ""
"A non-capturing version of regular parentheses.  Matches whatever regular "
"expression is inside the parentheses, but the substring matched by the group"
" *cannot* be retrieved after performing a match or referenced later in the "
"pattern."
msgstr "æ­£è¦è¡¨ç¾ã®ä¸¸æ‹¬å¼§ã®å–ã‚Šè¾¼ã¾ãªã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã™ã€‚ã©ã®ã‚ˆã†ãªæ­£è¦è¡¨ç¾ãŒä¸¸æ‹¬å¼§å†…ã«ã‚ã£ã¦ã‚‚ãƒãƒƒãƒã—ã¾ã™ãŒã€ã‚°ãƒ«ãƒ¼ãƒ—ã«ã‚ˆã£ã¦ãƒãƒƒãƒã•ã‚ŒãŸã‚µãƒ–æ–‡å­—åˆ—ã¯ã€ãƒãƒƒãƒã‚’å®Ÿè¡Œã—ãŸã‚ã¨æ¤œç´¢ã•ã‚Œã‚‹ã“ã¨ã‚‚ã€ã‚ã‚‹ã„ã¯å¾Œã§ãƒ‘ã‚¿ãƒ¼ãƒ³ã§å‚ç…§ã•ã‚Œã‚‹ã“ã¨ã‚‚ *ã§ãã¾ã›ã‚“* ã€‚"

#: ../../library/re.rst:266
msgid "``(?P<name>...)``"
msgstr "``(?P<name>...)``"

#: ../../library/re.rst:244
msgid ""
"Similar to regular parentheses, but the substring matched by the group is "
"accessible via the symbolic group name *name*.  Group names must be valid "
"Python identifiers, and each group name must be defined only once within a "
"regular expression.  A symbolic group is also a numbered group, just as if "
"the group were not named."
msgstr "æ­£è¦è¡¨ç¾ã®ä¸¸æ‹¬å¼§ã«ä¼¼ã¦ã„ã¾ã™ãŒã€ã‚°ãƒ«ãƒ¼ãƒ—ã«ã‚ˆã£ã¦ãƒãƒƒãƒã—ãŸéƒ¨åˆ†æ–‡å­—åˆ—ã¯ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯\\ ã‚°ãƒ«ãƒ¼ãƒ—å *name* ã«ã‚ˆã£ã¦ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ã«ãªã‚Šã¾ã™ã€‚ã‚°ãƒ«ãƒ¼ãƒ—åã¯æœ‰åŠ¹ãª Python è­˜åˆ¥å­ã§ãªã‘ã‚Œã°ãªã‚‰ãšã€ã‚°ãƒ«ãƒ¼ãƒ—åã¯ 1 å€‹ã®æ­£è¦è¡¨ç¾å†…ã§ä¸€æ„ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ã‚°ãƒ«ãƒ¼ãƒ—ã¯ç•ªå·ä»˜ã‘ã‚‚ã•ã‚Œã¦ãŠã‚Šã€ç•ªå·ã«ã‚ˆã‚‹ã‚¢ã‚¯ã‚»ã‚¹ã‚‚å¯èƒ½ã§ã™ã€‚"

#: ../../library/re.rst:250
msgid ""
"Named groups can be referenced in three contexts.  If the pattern is "
"``(?P<quote>['\"]).*?(?P=quote)`` (i.e. matching a string quoted with either"
" single or double quotes):"
msgstr "åå‰ä»˜ãã‚°ãƒ«ãƒ¼ãƒ—ã¯ 3 ã¤ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§å‚ç…§ã§ãã¾ã™ã€‚ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒ ``(?P<quote>['\\\"]).*?(?P=quote)`` (ã‚·ãƒ³ã‚°ãƒ«ã¾ãŸã¯ãƒ€ãƒ–ãƒ«ã‚¯ã‚ªãƒ¼ãƒˆã®ã©ã¡ã‚‰ã‹ã«ãƒãƒƒãƒ) ã®å ´åˆ`:"

#: ../../library/re.rst:255
msgid "Context of reference to group \"quote\""
msgstr "ã‚°ãƒ«ãƒ¼ãƒ— \"quote\" ã‚’å‚ç…§ã™ã‚‹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ"

#: ../../library/re.rst:255
msgid "Ways to reference it"
msgstr "å‚ç…§æ–¹æ³•"

#: ../../library/re.rst:257
msgid "in the same pattern itself"
msgstr "åŒä¸€ãƒ‘ã‚¿ãƒ¼ãƒ³ã¸ã®å‚ç…§"

#: ../../library/re.rst:257
msgid "``(?P=quote)`` (as shown)"
msgstr "``(?P=quote)`` (ãã®ã¾ã¾)"

#: ../../library/re.rst:258 ../../library/re.rst:265
msgid "``\\1``"
msgstr "``\\1``"

#: ../../library/re.rst:260
msgid "when processing match object ``m``"
msgstr "ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ``m`` ã®å‡¦ç†æ™‚"

#: ../../library/re.rst:260
msgid "``m.group('quote')``"
msgstr "``m.group('quote')``"

#: ../../library/re.rst:261
msgid "``m.end('quote')`` (etc.)"
msgstr "``m.end('quote')`` (etc.)"

#: ../../library/re.rst:263
msgid "in a string passed to the ``repl`` argument of ``re.sub()``"
msgstr "``re.sub()`` ã® ``repl`` å¼•æ•°ã¸æ¸¡ã•ã‚Œã‚‹æ–‡å­—åˆ—"

#: ../../library/re.rst:263
msgid "``\\g<quote>``"
msgstr "``\\g<quote>``"

#: ../../library/re.rst:264
msgid "``\\g<1>``"
msgstr "``\\g<1>``"

#: ../../library/re.rst:270
msgid "``(?P=name)``"
msgstr "``(?P=name)``"

#: ../../library/re.rst:269
msgid ""
"A backreference to a named group; it matches whatever text was matched by "
"the earlier group named *name*."
msgstr "åå‰ä»˜ãã‚°ãƒ«ãƒ¼ãƒ—ã¸ã®å¾Œæ–¹å‚ç…§ã§ã™; æ—¢å‡ºã®ã‚°ãƒ«ãƒ¼ãƒ—å *name* ã«ãƒãƒƒãƒã™ã‚‹æ–‡å­—åˆ—ã¯ä½•ã«ã§ã‚‚ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:273
msgid "``(?#...)``"
msgstr "``(?#...)``"

#: ../../library/re.rst:273
msgid "A comment; the contents of the parentheses are simply ignored."
msgstr "ã‚³ãƒ¡ãƒ³ãƒˆã§ã™ï¼›æ‹¬å¼§ã®å†…å®¹ã¯å˜ç´”ã«ç„¡è¦–ã•ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:278
msgid "``(?=...)``"
msgstr "``(?=...)``"

#: ../../library/re.rst:276
msgid ""
"Matches if ``...`` matches next, but doesn't consume any of the string.  "
"This is called a lookahead assertion.  For example, ``Isaac (?=Asimov)`` "
"will match ``'Isaac '`` only if it's followed by ``'Asimov'``."
msgstr "ã‚‚ã— ``...`` ãŒæ¬¡ã«ç¶šãã‚‚ã®ã¨ãƒãƒƒãƒã™ã‚Œã°ãƒãƒƒãƒã—ã¾ã™ãŒã€æ–‡å­—åˆ—ã‚’ã¾ã£ãŸãæ¶ˆè²»ã—ã¾ã›ã‚“ã€‚ã“ã‚Œã¯å…ˆèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ (lookahead assertion) ã¨å‘¼ã°ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ ``Isaac (?=Asimov)`` ã¯ã€ ``'Isaac '`` ã« ``'Asimov'`` ãŒç¶šãå ´åˆã ã‘ã€ ``'Isaac '`` ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:283
msgid "``(?!...)``"
msgstr "``(?!...)``"

#: ../../library/re.rst:281
msgid ""
"Matches if ``...`` doesn't match next.  This is a negative lookahead "
"assertion. For example, ``Isaac (?!Asimov)`` will match ``'Isaac '`` only if"
" it's *not* followed by ``'Asimov'``."
msgstr "ã‚‚ã— ``...`` ãŒæ¬¡ã«ç¶šãã‚‚ã®ã¨ãƒãƒƒãƒã—ãªã‘ã‚Œã°ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã¯å¦å®šå…ˆèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ (negative lookahead assertion) ã§ã™ã€‚ä¾‹ãˆã°ã€ ``Isaac (?!Asimov)`` ã¯ã€ ``'Isaac '`` ã« ``'Asimov'`` ãŒç¶šã‹ *ãªã„* å ´åˆã®ã¿ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:307
msgid "``(?<=...)``"
msgstr "``(?<=...)``"

#: ../../library/re.rst:286
msgid ""
"Matches if the current position in the string is preceded by a match for "
"``...`` that ends at the current position.  This is called a :dfn:`positive "
"lookbehind assertion`. ``(?<=abc)def`` will find a match in ``abcdef``, "
"since the lookbehind will back up 3 characters and check if the contained "
"pattern matches. The contained pattern must only match strings of some fixed"
" length, meaning that ``abc`` or ``a|b`` are allowed, but ``a*`` and "
"``a{3,4}`` are not.  Group references are not supported even if they match "
"strings of some fixed length. Note that patterns which start with positive "
"lookbehind assertions will not match at the beginning of the string being "
"searched; you will most likely want to use the :func:`search` function "
"rather than the :func:`match` function:"
msgstr "æ–‡å­—åˆ—å†…ã®ç¾åœ¨ä½ç½®ã®å‰ã«ã€ç¾åœ¨ä½ç½®ã§çµ‚ã‚ã‚‹ ``...`` ã¨ã®ãƒãƒƒãƒãŒã‚ã‚Œã°ã€ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã¯ :dfn:`å¾Œèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³` ã¨å‘¼ã°ã‚Œã¾ã™ã€‚ ``(?<=abc)def`` ã¯ ``abcdef`` ã«ãƒãƒƒãƒã‚’è¦‹ã¤ã‘ã¾ã™ã€‚å¾Œèª­ã¿ã¯ 3 æ–‡å­—ã‚’ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã—ã€å«ã¾ã‚Œã¦ã„ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ãƒãƒƒãƒã™ã‚‹ã‹ã©ã†ã‹æ¤œæŸ»ã—ã¾ã™ã€‚å«ã¾ã‚Œã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€å›ºå®šé•·ã®æ–‡å­—åˆ—ã«ã®ã¿ãƒãƒƒãƒã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã™ãªã‚ã¡ã€ ``abc`` ã‚„ ``a|b`` ã¯è¨±ã•ã‚Œã¾ã™ãŒã€ ``a*`` ã‚„ ``a{3,4}`` ã¯è¨±ã•ã‚Œã¾ã›ã‚“ã€‚ã‚°ãƒ«ãƒ¼ãƒ—å‚ç…§ã¯å›ºå®šé•·ã®æ–‡å­—åˆ—ã«ãƒãƒƒãƒã™ã‚‹ã¨ãã§ã•ãˆã‚µãƒãƒ¼ãƒˆã•ã‚Œã¾ã›ã‚“ã€‚è‚¯å®šå¾Œèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã§å§‹ã¾ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€æ¤œç´¢ã•ã‚Œã‚‹æ–‡å­—åˆ—ã®å…ˆé ­ã¨ã¯æ±ºã—ã¦ãƒãƒƒãƒã—ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ä¸‹ã•ã„; ã“ã®è¡¨ç¾ã‚’ä½¿ç”¨ã™ã‚‹ã®ã¯ã€ãŠãã‚‰ã :func:`match` é–¢æ•°ã‚ˆã‚Š :func:`search` é–¢æ•°ã®æ–¹ãŒé©ã—ã¦ã„ã¾ã™:"

#: ../../library/re.rst:303
msgid "This example looks for a word following a hyphen:"
msgstr "ã“ã®ä¾‹ã§ã¯ãƒã‚¤ãƒ•ãƒ³ã«ç¶šãå˜èªã‚’æ¢ã—ã¾ã™:"

#: ../../library/re.rst:315
msgid "``(?<!...)``"
msgstr "``(?<!...)``"

#: ../../library/re.rst:310
msgid ""
"Matches if the current position in the string is not preceded by a match for"
" ``...``.  This is called a :dfn:`negative lookbehind assertion`.  Similar "
"to positive lookbehind assertions, the contained pattern must only match "
"strings of some fixed length and shouldn't contain group references. "
"Patterns which start with negative lookbehind assertions may match at the "
"beginning of the string being searched."
msgstr "æ–‡å­—åˆ—å†…ã®ç¾åœ¨ä½ç½®ã®å‰ã« ``...`` ã¨ã®ãƒãƒƒãƒãŒãªã„å ´åˆã«ã€ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã¯ :dfn:`å¦å®šå¾Œèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³(negative lookbehind assertion)` ã¨å‘¼ã°ã‚Œã¾ã™ã€‚è‚¯å®šå¾Œèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã¨åŒæ§˜ã«ã€å«ã¾ã‚Œã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯å›ºå®šé•·ã•ã®æ–‡å­—åˆ—ã ã‘ã«ãƒãƒƒãƒã—ãªã‘ã‚Œã°ãªã‚‰ãšã€ã‚°ãƒ«ãƒ¼ãƒ—å‚ç…§ã‚’å«ã‚“ã§ã¯ãªã‚Šã¾ã›ã‚“ã€‚å¦å®šå¾Œèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã§å§‹ã¾ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€æ¤œç´¢ã•ã‚Œã‚‹æ–‡å­—åˆ—ã®å…ˆé ­ã¨ãƒãƒƒãƒã§ãã¾ã™ã€‚"

#: ../../library/re.rst:324
msgid "``(?(id/name)yes-pattern|no-pattern)``"
msgstr "``(?(id/name)yes-pattern|no-pattern)``"

#: ../../library/re.rst:318
msgid ""
"Will try to match with ``yes-pattern`` if the group with given *id* or "
"*name* exists, and with ``no-pattern`` if it doesn't. ``no-pattern`` is "
"optional and can be omitted. For example,  "
"``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>)`` is a poor email matching pattern, "
"which will match with ``'<user@host.com>'`` as well as ``'user@host.com'``, "
"but not with ``'<user@host.com'``."
msgstr "ã‚°ãƒ«ãƒ¼ãƒ—ã« *id* ãŒä¸ãˆã‚‰ã‚Œã¦ã„ã‚‹ã€ã‚‚ã—ãã¯ *name* ãŒã‚ã‚‹ã¨ãã€ ``yes-pattern`` ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚å­˜åœ¨ã—ãªã„ã¨ãã«ã¯ ``no-pattern`` ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚ ``no-pattern`` ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§çœç•¥ã§ãã¾ã™ã€‚ä¾‹ãˆã° ``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>)`` ã¯emailã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ãƒãƒƒãƒã™ã‚‹æœ€ä½é™ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚ã“ã‚Œã¯ ``'<user@host.com>'`` ã‚„ ``'user@host.com'`` ã«ã¯ãƒãƒƒãƒã—ã¾ã™ãŒã€ ``'<user@host.com'`` ã«ã¯ãƒãƒƒãƒã—ã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:326
msgid ""
"The special sequences consist of ``'\\'`` and a character from the list "
"below. If the ordinary character is not on the list, then the resulting RE "
"will match the second character.  For example, ``\\$`` matches the character"
" ``'$'``."
msgstr "ç‰¹æ®Šã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ ``'\\'`` ã¨ä»¥ä¸‹ã®ãƒªã‚¹ãƒˆã«ã‚ã‚‹æ–‡å­—ã‹ã‚‰æ§‹æˆã•ã‚Œã¾ã™ã€‚ã‚‚ã—ãƒªã‚¹ãƒˆã«ã‚ã‚‹ã®ãŒé€šå¸¸æ–‡å­—ã§ãªã„ãªã‚‰ã°ã€çµæœã® RE ã¯2ç•ªç›®ã®æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ ``\\$`` ã¯æ–‡å­— ``'$'`` ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:338
msgid "``\\number``"
msgstr "``\\number``"

#: ../../library/re.rst:331
msgid ""
"Matches the contents of the group of the same number.  Groups are numbered "
"starting from 1.  For example, ``(.+) \\1`` matches ``'the the'`` or ``'55 "
"55'``, but not ``'thethe'`` (note the space after the group).  This special "
"sequence can only be used to match one of the first 99 groups.  If the first"
" digit of *number* is 0, or *number* is 3 octal digits long, it will not be "
"interpreted as a group match, but as the character with octal value "
"*number*. Inside the ``'['`` and ``']'`` of a character class, all numeric "
"escapes are treated as characters."
msgstr "åŒã˜ç•ªå·ã®ã‚°ãƒ«ãƒ¼ãƒ—ã®ä¸­èº«ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚ã‚°ãƒ«ãƒ¼ãƒ—ã¯1ã‹ã‚‰å§‹ã¾ã‚‹ç•ªå·ã‚’ã¤ã‘ã‚‰ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ ``(.+) \\1`` ã¯ã€ ``'the the'`` ã‚ã‚‹ã„ã¯ ``'55 55'`` ã¨ãƒãƒƒãƒã—ã¾ã™ãŒã€ ``'thethe'`` ã¨ã¯ãƒãƒƒãƒã—ã¾ã›ã‚“(ã‚°ãƒ«ãƒ¼ãƒ—ã®å¾Œã®ã‚¹ãƒšãƒ¼ã‚¹ã«æ³¨æ„ã—ã¦ä¸‹ã•ã„)ã€‚ã“ã®ç‰¹æ®Šã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯æœ€åˆã® 99 ã‚°ãƒ«ãƒ¼ãƒ—ã®ã†ã¡ã®ä¸€ã¤ã¨ãƒãƒƒãƒã™ã‚‹ã®ã«ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã ã‘ã§ã™ã€‚ã‚‚ã— *number* ã®æœ€åˆã®æ¡ãŒ 0 ã§ã‚ã‚‹ã€ã™ãªã‚ã¡ *number* ãŒ 3 æ¡ã®8é€²æ•°ã§ã‚ã‚Œã°ã€ãã‚Œã¯ã‚°ãƒ«ãƒ¼ãƒ—ã®ãƒãƒƒãƒã¨ã¯è§£é‡ˆã•ã‚Œãšã€ 8é€²æ•°å€¤ *number* ã‚’æŒã¤æ–‡å­—ã¨ã—ã¦è§£é‡ˆã•ã‚Œã¾ã™ã€‚æ–‡å­—ã‚¯ãƒ©ã‚¹ã® ``'['`` ã¨ ``']'`` ã®ä¸­ã®æ•°å€¤ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã¯ã€æ–‡å­—ã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:341
msgid "``\\A``"
msgstr "``\\A``"

#: ../../library/re.rst:341
msgid "Matches only at the start of the string."
msgstr "æ–‡å­—åˆ—ã®å…ˆé ­ã ã‘ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:354
msgid "``\\b``"
msgstr "``\\b``"

#: ../../library/re.rst:344
msgid ""
"Matches the empty string, but only at the beginning or end of a word.  A "
"word is defined as a sequence of alphanumeric or underscore characters, so "
"the end of a word is indicated by whitespace or a non-alphanumeric, non-"
"underscore character. Note that formally, ``\\b`` is defined as the boundary"
" between a ``\\w`` and a ``\\W`` character (or vice versa), or between "
"``\\w`` and the beginning/end of the string, so the precise set of "
"characters deemed to be alphanumeric depends on the values of the "
"``UNICODE`` and ``LOCALE`` flags. For example, ``r'\\bfoo\\b'`` matches "
"``'foo'``, ``'foo.'``, ``'(foo)'``, ``'bar foo baz'`` but not ``'foobar'`` "
"or ``'foo3'``. Inside a character range, ``\\b`` represents the backspace "
"character, for compatibility with Python's string literals."
msgstr "ç©ºæ–‡å­—åˆ—ã¨ãƒãƒƒãƒã—ã¾ã™ãŒã€å˜èªã®å…ˆé ­ã‹æœ«å°¾ã®æ™‚ã ã‘ã§ã™ã€‚å˜èªã¨ã¯è‹±æ•°å­—ã¾ãŸã¯ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã‹ã‚‰ãªã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã€å˜èªã®çµ‚ã‚ã‚Šã¯ç©ºç™½æ–‡å­—ã€ã‚ã‚‹ã„ã¯ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã‚’é™¤ãè¨˜å·ã§è¡¨ã—ã¾ã™ã€‚ ``\\b`` ã¯ ``\\w`` ãŠã‚ˆã³ ``\\W`` ã®é–“ (ãŠã‚ˆã³ãã®é€†) ã‚ã‚‹ã„ã¯ ``\\w`` ã¨æ–‡å­—åˆ—ã®é–‹å§‹/çµ‚äº†ã¨ã®é–“ã®å¢ƒç•Œã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã®ã§ã€æ–‡å­—ã®æ­£ç¢ºãªé›†åˆã¯ ``UNICODE`` ã¨ ``LOCALE`` ãƒ•ãƒ©ã‚°ã®å€¤ã«ä¾å­˜ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ ``r'\\bfoo\\b'`` ã¯ ``'foo'`` , ``'foo.'`` , ``'(foo)'``, ``'bar foo baz'`` ã«ãƒãƒƒãƒã—ã¾ã™ãŒã€ ``'foobar'``, ``'foo3'`` ã«ã¯ãƒãƒƒãƒã—ã¾ã›ã‚“ã€‚æ–‡å­—ç¯„å›²å†…ã§ã¯ã€ ``\\b`` ã¯ Python ã®æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã¨ã®äº’æ›æ€§ã®ãŸã‚ã€å¾Œé€€ (backspace) æ–‡å­—ã‚’è¡¨ã—ã¾ã™ã€‚"

#: ../../library/re.rst:361
msgid "``\\B``"
msgstr "``\\B``"

#: ../../library/re.rst:357
msgid ""
"Matches the empty string, but only when it is *not* at the beginning or end "
"of a word.  This means that ``r'py\\B'`` matches ``'python'``, ``'py3'``, "
"``'py2'``, but not ``'py'``, ``'py.'``, or ``'py!'``. ``\\B`` is just the "
"opposite of ``\\b``, so is also subject to the settings of ``LOCALE`` and "
"``UNICODE``."
msgstr "ç©ºæ–‡å­—åˆ—ã¨ãƒãƒƒãƒã—ã¾ã™ãŒã€ãã‚ŒãŒå˜èªã®å…ˆé ­ã‚ã‚‹ã„ã¯æœ«å°¾ã« *ãªã„* æ™‚ã ã‘ã§ã™ã€‚ ``r'py\\B'`` ã¯ ``'python'``, ``'py3'``, ``'py2'`` ã«ã¯ãƒãƒƒãƒã—ã¾ã™ãŒã€ ``'py'``, ``'py.'``, ``'py!'`` ã«ã¯ãƒãƒƒãƒã—ã¾ã›ã‚“ã€‚ã“ã‚Œã¯ ``\\b`` ã®ã¡ã‚‡ã†ã©åå¯¾ã§ã™ã®ã§ã€åŒã˜ã‚ˆã†ã« ``LOCALE`` ã¨ ``UNICODE`` ã®è¨­å®šã«å½±éŸ¿ã•ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:367
msgid "``\\d``"
msgstr "``\\d``"

#: ../../library/re.rst:364
msgid ""
"When the :const:`UNICODE` flag is not specified, matches any decimal digit; "
"this is equivalent to the set ``[0-9]``.  With :const:`UNICODE`, it will "
"match whatever is classified as a decimal digit in the Unicode character "
"properties database."
msgstr ":const:`UNICODE` ãƒ•ãƒ©ã‚°ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã€ä»»æ„ã®åé€²æ•°ã¨ãƒãƒƒãƒã—ã¾ã™ï¼›ã“ã‚Œã¯é›†åˆ ``[0-9]`` ã¨åŒã˜æ„å‘³ã§ã™ã€‚ :const:`UNICODE` ãŒã‚ã‚‹å ´åˆã€Unicode æ–‡å­—ç‰¹æ€§ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã§åé€²æ•°å­—ã¨åˆ†é¡ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:373
msgid "``\\D``"
msgstr "``\\D``"

#: ../../library/re.rst:370
msgid ""
"When the :const:`UNICODE` flag is not specified, matches any non-digit "
"character; this is equivalent to the set  ``[^0-9]``.  With "
":const:`UNICODE`, it will match  anything other than character marked as "
"digits in the Unicode character  properties database."
msgstr ":const:`UNICODE` ãƒ•ãƒ©ã‚°ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã€ä»»æ„ã®éæ•°å­—æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™ï¼›ã“ã‚Œã¯é›†åˆ ``[^0-9]`` ã¨åŒã˜æ„å‘³ã§ã™ã€‚ :const:`UNICODE` ãŒã‚ã‚‹å ´åˆã€ã“ã‚Œã¯ Unicode æ–‡å­—ç‰¹æ€§ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã§æ•°å­—ã¨ãƒãƒ¼ã‚¯ä»˜ã‘ã•ã‚Œã¦ã„ã‚‹æ–‡å­—ä»¥å¤–ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:381
msgid "``\\s``"
msgstr "``\\s``"

#: ../../library/re.rst:376
msgid ""
"When the :const:`UNICODE` flag is not specified, it matches any whitespace "
"character, this is equivalent to the set ``[ \\t\\n\\r\\f\\v]``. The "
":const:`LOCALE` flag has no extra effect on matching of the space. If "
":const:`UNICODE` is set, this will match the characters ``[ "
"\\t\\n\\r\\f\\v]`` plus whatever is classified as space in the Unicode "
"character properties database."
msgstr ":const:`UNICODE` ãƒ•ãƒ©ã‚°ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã€ä»»æ„ã®ç©ºç™½æ–‡å­—ã¨ãƒãƒƒãƒã—ã€ã“ã‚Œã¯é›†åˆ ``[ \\t\\n\\r\\f\\v]`` ã¨åŒã˜æ„å‘³ã§ã™ã€‚ :const:`LOCALE` ãƒ•ãƒ©ã‚°ã¯ç©ºç™½æ–‡å­—ã¨ã®ãƒãƒƒãƒã«ã¤ã„ã¦ç‰¹åˆ¥ãªæ„å‘³ã‚’æŒã¡ã¾ã›ã‚“ã€‚ :const:`UNICODE` ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€ã“ã‚Œã¯ ``[ \\t\\n\\r\\f\\v]`` ã¨ Unicode æ–‡å­—ç‰¹æ€§ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã§ç©ºç™½ã¨åˆ†é¡ã•ã‚Œã¦ã„ã‚‹å…¨ã¦ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:389
msgid "``\\S``"
msgstr "``\\S``"

#: ../../library/re.rst:384
msgid ""
"When the :const:`UNICODE` flag is not specified, matches any non-whitespace "
"character; this is equivalent to the set ``[^ \\t\\n\\r\\f\\v]`` The "
":const:`LOCALE` flag has no extra effect on non-whitespace match.  If "
":const:`UNICODE` is set, then any character not marked as space in the "
"Unicode character properties database is matched."
msgstr ":const:`UNICODE` ãƒ•ãƒ©ã‚°ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã€ä»»æ„ã®éç©ºç™½æ–‡å­—ã¨ãƒãƒƒãƒã—ã€ã“ã‚Œã¯é›†åˆ ``[^ \\t\\n\\r\\f\\v]`` ã¨åŒã˜æ„å‘³ã§ã™ã€‚ :const:`LOCALE` ãƒ•ãƒ©ã‚°ã¯éç©ºç™½æ–‡å­—ã¨ã®ãƒãƒƒãƒã«ã¤ã„ã¦ç‰¹åˆ¥ãªæ„å‘³ã‚’æŒã¡ã¾ã›ã‚“ã€‚ :const:`UNICODE` ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€ã“ã‚Œã¯ Unicode æ–‡å­—ç‰¹æ€§ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã§éç©ºç™½ã¨åˆ†é¡ã•ã‚Œã¦ã„ã‚‹å…¨ã¦ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:397
msgid "``\\w``"
msgstr "``\\w``"

#: ../../library/re.rst:392
msgid ""
"When the :const:`LOCALE` and :const:`UNICODE` flags are not specified, "
"matches any alphanumeric character and the underscore; this is equivalent to"
" the set ``[a-zA-Z0-9_]``.  With :const:`LOCALE`, it will match the set "
"``[0-9_]`` plus whatever characters are defined as alphanumeric for the "
"current locale.  If :const:`UNICODE` is set, this will match the characters "
"``[0-9_]`` plus whatever is classified as alphanumeric in the Unicode "
"character properties database."
msgstr ":const:`LOCALE` ã¨ :const:`UNICODE` ãƒ•ãƒ©ã‚°ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„æ™‚ã¯ã€ä»»æ„ã®è‹±æ•°æ–‡å­—ãŠã‚ˆã³ä¸‹ç·šã¨ãƒãƒƒãƒã—ã¾ã™ï¼›ã“ã‚Œã¯ã€é›†åˆ ``[a-zA-Z0-9_]`` ã¨åŒã˜æ„å‘³ã§ã™ã€‚ :const:`LOCALE` ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã¨ã€é›†åˆ ``[0-9_]`` ãƒ—ãƒ©ã‚¹ç¾åœ¨ã®ãƒ­ã‚±ãƒ¼ãƒ«ç”¨ã«è‹±æ•°å­—ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹ä»»æ„ã®æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚ã‚‚ã— :const:`UNICODE` ãŒè¨­å®šã•ã‚Œã¦ã„ã‚Œã°ã€æ–‡å­— ``[0-9_]`` ãƒ—ãƒ©ã‚¹ Unicode æ–‡å­—ç‰¹æ€§ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã§è‹±æ•°å­—ã¨ã—ã¦åˆ†é¡ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:405
msgid "``\\W``"
msgstr "``\\W``"

#: ../../library/re.rst:400
msgid ""
"When the :const:`LOCALE` and :const:`UNICODE` flags are not specified, "
"matches any non-alphanumeric character; this is equivalent to the set "
"``[^a-zA-Z0-9_]``. With :const:`LOCALE`, it will match any character not in "
"the set ``[0-9_]``, and not defined as alphanumeric for the current locale. "
"If :const:`UNICODE` is set, this will match anything other than ``[0-9_]`` "
"plus characters classified as not alphanumeric in the Unicode character "
"properties database."
msgstr ":const:`LOCALE` ã¨ :const:`UNICODE` ãƒ•ãƒ©ã‚°ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„æ™‚ã€ä»»æ„ã®éè‹±æ•°æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™ï¼›ã“ã‚Œã¯é›†åˆ ``[^a-zA-Z0-9_]`` ã¨åŒã˜æ„å‘³ã§ã™ã€‚ :const:`LOCALE` ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹ã¨ã€é›†åˆ ``[0-9_]`` ã«ãªãã€ç¾åœ¨ã®ãƒ­ã‚±ãƒ¼ãƒ«ã§è‹±æ•°å­—ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ãªã„ä»»æ„ã®æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚ã‚‚ã— :const:`UNICODE` ãŒã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ã‚Œã°ã€ã“ã‚Œã¯ ``[0-9_]`` ä»¥å¤–ã¨ã€ãŠã‚ˆã³ Unicode æ–‡å­—ç‰¹æ€§ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã§éè‹±æ•°å­—ã¨åˆ†é¡ã•ã‚Œã¦ã„ã‚‹æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:408
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../../library/re.rst:408
msgid "Matches only at the end of the string."
msgstr "æ–‡å­—åˆ—ã®æœ«å°¾ã¨ã®ã¿ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:410
msgid ""
"If both :const:`LOCALE` and :const:`UNICODE` flags are included for a "
"particular sequence, then :const:`LOCALE` flag takes effect first followed "
"by the :const:`UNICODE`."
msgstr "ç‰¹å®šã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«å¯¾ã— :const:`LOCALE` ã¨ :const:`UNICODE` ã®ã©ã¡ã‚‰ã‚‚å½±éŸ¿ã—ã†ã‚‹å ´åˆã¯ã€ :const:`LOCALE` ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚Œã°å¿…ãš :const:`LOCALE` ã®åŠ¹æœã«å¾“ã„ã¾ã™ã€‚"

#: ../../library/re.rst:414
msgid ""
"Most of the standard escapes supported by Python string literals are also "
"accepted by the regular expression parser::"
msgstr "Python æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã«ã‚ˆã£ã¦ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹æ¨™æº–ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã®ã»ã¨ã‚“ã©ã‚‚ã€æ­£è¦è¡¨ç¾ãƒ‘ãƒ¼ã‚¶ã«èªè­˜ã•ã‚Œã¾ã™::"

#: ../../library/re.rst:421
msgid ""
"(Note that ``\\b`` is used to represent word boundaries, and means "
"\"backspace\" only inside character classes.)"
msgstr "(``\\b`` ã¯å˜èªã®å¢ƒç•Œã‚’è¡¨ã—ã€æ–‡å­—ã‚¯ãƒ©ã‚¹å†…ã§ã®ã¿å¾Œé€€ (backspace) æ–‡å­—ã‚’æŒ‡ã™ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„)"

#: ../../library/re.rst:424
msgid ""
"Octal escapes are included in a limited form: If the first digit is a 0, or "
"if there are three octal digits, it is considered an octal escape. "
"Otherwise, it is a group reference.  As for string literals, octal escapes "
"are always at most three digits in length."
msgstr "8é€²ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã¯åˆ¶é™ã•ã‚ŒãŸå½¢å¼ã§å«ã¾ã‚Œã¦ã„ã¾ã™ï¼šã‚‚ã—ç¬¬1æ¡ãŒ 0 ã§ã‚ã‚‹ã‹ã€ã‚‚ã—8é€²3æ¡ã§ã‚ã‚Œã°ã€ãã‚Œã¯ 8é€²ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã°ã€ãã‚Œã¯ã‚°ãƒ«ãƒ¼ãƒ—å‚ç…§ã§ã™ã€‚æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã«ã¤ã„ã¦ã€ 8é€²ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã¯ã»ã¨ã‚“ã©ã®å ´åˆ3æ¡é•·ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/re.rst:433
msgid "Mastering Regular Expressions"
msgstr "Mastering Regular Expressions è©³èª¬æ­£è¦è¡¨ç¾"

#: ../../library/re.rst:432
msgid ""
"Book on regular expressions by Jeffrey Friedl, published by O'Reilly.  The "
"second edition of the book no longer covers Python at all, but the first "
"edition covered writing good regular expression patterns in great detail."
msgstr "Jeffrey Friedl è‘—ã€O'Reilly åˆŠã®æ­£è¦è¡¨ç¾ã«é–¢ã™ã‚‹æœ¬ã§ã™ã€‚ã“ã®æœ¬ã®ç¬¬2ç‰ˆ\\ ã§ã¯Pyhonã«ã¤ã„ã¦ã¯è§¦ã‚Œã¦ã„ã¾ã›ã‚“ãŒã€è‰¯ã„æ­£è¦è¡¨ç¾ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ›¸ãæ–¹ã‚’éå¸¸ã«\\ ãã‚ã—ãèª¬æ˜ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/re.rst:441
msgid "Module Contents"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚³ãƒ³ãƒ†ãƒ³ãƒ„"

#: ../../library/re.rst:443
msgid ""
"The module defines several functions, constants, and an exception. Some of "
"the functions are simplified versions of the full featured methods for "
"compiled regular expressions.  Most non-trivial applications always use the "
"compiled form."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯å¹¾ã¤ã‹ã®é–¢æ•°ã€å®šæ•°ã€ä¾‹å¤–ã‚’å®šç¾©ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã®ã„ãã¤ã‹ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿æ­£è¦è¡¨ç¾å‘ã‘ã®å®Œå…¨ç‰ˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç°¡ç•¥åŒ–ã—ãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã™ã€‚ãã‚Œãªã‚Šã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ã»ã¨ã‚“ã©ã§ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸå½¢å¼ãŒç”¨ã„ã‚‰ã‚Œã‚‹ã®ãŒæ™®é€šã§ã™ã€‚"

#: ../../library/re.rst:451
msgid ""
"Compile a regular expression pattern into a regular expression object, which"
" can be used for matching using its :func:`~RegexObject.match` and "
":func:`~RegexObject.search` methods, described below."
msgstr "æ­£è¦è¡¨ç¾ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ä»¥ä¸‹ã§è¿°ã¹ã‚‹ :func:`~RegexObject.match` ã¨ :func:`~RegexObject.search` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦ã€ãƒãƒƒãƒãƒ³ã‚°ã«ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/re.rst:455
msgid ""
"The expression's behaviour can be modified by specifying a *flags* value. "
"Values can be any of the following variables, combined using bitwise OR (the"
" ``|`` operator)."
msgstr "å¼ã®å‹•ä½œã¯ã€ *flags* ã®å€¤ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã§åŠ æ¸›ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚å€¤ã¯ä»¥ä¸‹ã®å¤‰æ•°ã‚’ã€ãƒ“ãƒƒãƒˆã”ã¨ã® OR ( ``|`` æ¼”ç®—å­)ã‚’ä½¿ã£ã¦çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/re.rst:459
msgid "The sequence ::"
msgstr "ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ ::"

#: ../../library/re.rst:464
msgid "is equivalent to ::"
msgstr "ã¯ã€ ::"

#: ../../library/re.rst:468
msgid ""
"but using :func:`re.compile` and saving the resulting regular expression "
"object for reuse is more efficient when the expression will be used several "
"times in a single program."
msgstr "ã¨åŒã˜æ„å‘³ã§ã™ãŒã€ :func:`re.compile` ã‚’ä½¿ã£ã¦ãã®çµæœã®æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å†åˆ©ç”¨ã—ãŸæ–¹ãŒã€ãã®å¼ã‚’ä¸€ã¤ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ä½•å›ã‚‚ä½¿ã†æ™‚ã«ã¯ã‚ˆã‚ŠåŠ¹ç‡çš„ã§ã™ã€‚"

#: ../../library/re.rst:474
msgid ""
"The compiled versions of the most recent patterns passed to "
":func:`re.match`, :func:`re.search` or :func:`re.compile` are cached, so "
"programs that use only a few regular expressions at a time needn't worry "
"about compiling regular expressions."
msgstr "æœ€å¾Œã« :func:`re.match`, :func:`re.search`, :func:`re.compile` ã«æ¸¡ã•ã‚ŒãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸã‚‚ã®ãŒã‚­ãƒ£ãƒƒã‚·ãƒ¥ã¨ã—ã¦æ®‹ã‚Šã¾ã™ã€‚ãã®ãŸã‚ã€æ­£è¦è¡¨ç¾ã‚’ã²ã¨ã¤ã ã‘ã—ã‹ä½¿ã‚ãªã„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯æ­£è¦è¡¨ç¾ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚’æ°—ã«ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:482
msgid "Display debug information about compiled expression."
msgstr "ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ãŸè¡¨ç¾ã«é–¢ã™ã‚‹ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚"

#: ../../library/re.rst:488
msgid ""
"Perform case-insensitive matching; expressions like ``[A-Z]`` will match "
"lowercase letters, too.  This is not affected by the current locale.  To get"
" this effect on non-ASCII Unicode characters such as ``Ã¼`` and ``Ãœ``, add "
"the :const:`UNICODE` flag."
msgstr ""

#: ../../library/re.rst:497
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s`` and ``\\S`` dependent on "
"the current locale."
msgstr "``\\w`` ã€ ``\\W`` ã€ ``\\b`` ãŠã‚ˆã³ã€ ``\\B`` ã€ ``\\s`` ã¨ ``\\S`` ã‚’ã€ç¾åœ¨ã®ãƒ­ã‚±ãƒ¼ãƒ«ã«å¾“ã‚ã•ã›ã¾ã™ã€‚"

#: ../../library/re.rst:504
msgid ""
"When specified, the pattern character ``'^'`` matches at the beginning of "
"the string and at the beginning of each line (immediately following each "
"newline); and the pattern character ``'$'`` matches at the end of the string"
" and at the end of each line (immediately preceding each newline).  By "
"default, ``'^'`` matches only at the beginning of the string, and ``'$'`` "
"only at the end of the string and immediately before the newline (if any) at"
" the end of the string."
msgstr "æŒ‡å®šã•ã‚Œã‚‹ã¨ã€ãƒ‘ã‚¿ãƒ¼ãƒ³æ–‡å­— ``'^'`` ã¯ã€æ–‡å­—åˆ—ã®å…ˆé ­ãŠã‚ˆã³å„è¡Œã®å…ˆé ­(å„æ”¹è¡Œã®ç›´å¾Œ)ã¨ãƒãƒƒãƒã—ã¾ã™ï¼›ãã—ã¦ãƒ‘ã‚¿ãƒ¼ãƒ³æ–‡å­— ``'$'`` ã¯æ–‡å­—åˆ—ã®æœ«å°¾ãŠã‚ˆã³å„è¡Œã®æœ«å°¾ (æ”¹è¡Œã®ç›´å‰) ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ ``'^'`` ã¯ã€æ–‡å­—åˆ—ã®å…ˆé ­ã¨ã ã‘ãƒãƒƒãƒã—ã€ ``'$'`` ã¯ã€æ–‡å­—åˆ—ã®æœ«å°¾ãŠã‚ˆã³æ–‡å­—åˆ—ã®æœ«å°¾ã®æ”¹è¡Œã®ç›´å‰(ãŒã‚‚ã—ã‚ã‚Œã°)ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:515
msgid ""
"Make the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline."
msgstr "ç‰¹æ®Šæ–‡å­— ``'.'`` ã‚’ã€æ”¹è¡Œã‚’å«ã‚€ä»»æ„ã®æ–‡å­—ã¨ã€ã¨ã«ã‹ããƒãƒƒãƒã•ã›ã¾ã™ï¼›ã“ã®ãƒ•ãƒ©ã‚°ãŒãªã‘ã‚Œã°ã€ ``'.'`` ã¯ã€æ”¹è¡Œ *ä»¥å¤–ã®* ä»»æ„ã®æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:522
msgid ""
"Make the ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` and "
"``\\S`` sequences dependent on the Unicode character properties database. "
"Also enables non-ASCII matching for :const:`IGNORECASE`."
msgstr ""

#: ../../library/re.rst:532
msgid ""
"This flag allows you to write regular expressions that look nicer and are "
"more readable by allowing you to visually separate logical sections of the "
"pattern and add comments. Whitespace within the pattern is ignored, except "
"when in a character class, or when preceded by an unescaped backslash, or "
"within tokens like ``*?``, ``(?:`` or ``(?P<...>``. When a line contains a "
"``#`` that is not in a character class and is not preceded by an unescaped "
"backslash, all characters from the leftmost such ``#`` through the end of "
"the line are ignored."
msgstr ""

#: ../../library/re.rst:541
msgid ""
"This means that the two following regular expression objects that match a "
"decimal number are functionally equal::"
msgstr "ã¤ã¾ã‚Šã€æ•°å­—ã«ãƒãƒƒãƒã™ã‚‹ä¸‹è¨˜ã®ãµãŸã¤ã®æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€æ©Ÿèƒ½çš„ã«ç­‰ä¾¡ã§ã™ã€‚::"

#: ../../library/re.rst:552
msgid ""
"Scan through *string* looking for the first location where the regular "
"expression *pattern* produces a match, and return a corresponding "
":class:`MatchObject` instance. Return ``None`` if no position in the string "
"matches the pattern; note that this is different from finding a zero-length "
"match at some point in the string."
msgstr "*string* å…¨ä½“ã‚’èµ°æŸ»ã—ã¦ã€æ­£è¦è¡¨ç¾ *pattern* ãŒãƒãƒƒãƒã‚’ç™ºç”Ÿã™ã‚‹æœ€åˆã®ä½ç½®ã‚’æ¢ã—ã¦ã€å¯¾å¿œã™ã‚‹ :class:`MatchObject` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ã‚‚ã—æ–‡å­—åˆ—å†…ã«ã€ãã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ãƒãƒƒãƒã™ã‚‹ä½ç½®ãŒãªã„ãªã‚‰ã°ã€ ``None`` ã‚’è¿”ã—ã¾ã™ï¼›ã“ã‚Œã¯ã€æ–‡å­—åˆ—å†…ã®ã‚ã‚‹ç‚¹ã§é•·ã•ã‚¼ãƒ­ã®ãƒãƒƒãƒã‚’æ¢ã™ã“ã¨ã¨ã¯ç•°ãªã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../library/re.rst:561
msgid ""
"If zero or more characters at the beginning of *string* match the regular "
"expression *pattern*, return a corresponding :class:`MatchObject` instance. "
"Return ``None`` if the string does not match the pattern; note that this is "
"different from a zero-length match."
msgstr "ã‚‚ã— *string* ã®å…ˆé ­ã§ 0 å€‹ä»¥ä¸Šã®æ–‡å­—ãŒæ­£è¦è¡¨ç¾ *pattern* ã¨ãƒãƒƒãƒã™ã‚Œã°ã€å¯¾å¿œã™ã‚‹ :class:`MatchObject` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ã‚‚ã—æ–‡å­—åˆ—ãŒãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ãƒãƒƒãƒã—ãªã‘ã‚Œã°ã€ ``None`` ã‚’è¿”ã—ã¾ã™ï¼›ã“ã‚Œã¯é•·ã•ã‚¼ãƒ­ã®ãƒãƒƒãƒã¨ã¯ç•°ãªã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../library/re.rst:566
msgid ""
"Note that even in :const:`MULTILINE` mode, :func:`re.match` will only match "
"at the beginning of the string and not at the beginning of each line."
msgstr ":const:`MULTILINE` ãƒ¢ãƒ¼ãƒ‰ã§ã‚ã£ã¦ã‚‚ã€:func:`re.match` ã¯æ–‡å­—åˆ—ã®å…ˆé ­ã®ã¿ã«ãƒãƒƒãƒã—ã€å„è¡Œã®å…ˆé ­ã«ã¯ãƒãƒƒãƒã—ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/re.rst:569
msgid ""
"If you want to locate a match anywhere in *string*, use :func:`search` "
"instead (see also :ref:`search-vs-match`)."
msgstr "*string* ã®ã©ã“ã«ã§ã‚‚ãƒãƒƒãƒã•ã›ãŸã‘ã‚Œã°ã€ :func:`search` ã‚’ä½¿ã£ã¦ä¸‹ã•ã„ (:ref:`search-vs-match` ã‚‚å‚ç…§ã—ã¦ãã ã•ã„)ã€‚"

#: ../../library/re.rst:575
msgid ""
"Split *string* by the occurrences of *pattern*.  If capturing parentheses "
"are used in *pattern*, then the text of all groups in the pattern are also "
"returned as part of the resulting list. If *maxsplit* is nonzero, at most "
"*maxsplit* splits occur, and the remainder of the string is returned as the "
"final element of the list.  (Incompatibility note: in the original Python "
"1.5 release, *maxsplit* was ignored.  This has been fixed in later "
"releases.)"
msgstr "*string* ã‚’ã€ *pattern* ãŒã‚ã‚‹ãŸã³ã«åˆ†å‰²ã—ã¾ã™ã€‚ã‚‚ã—æ‹¬å¼§ã®ã‚­ãƒ£ãƒ—ãƒãƒ£ãŒ *pattern* ã§ä½¿ã‚ã‚Œã¦ã„ã‚Œã°ã€ãƒ‘ã‚¿ãƒ¼ãƒ³å†…ã®ã™ã¹ã¦ã®ã‚°ãƒ«ãƒ¼ãƒ—ã®ãƒ†ã‚­ã‚¹ãƒˆã‚‚çµæœã®ãƒªã‚¹ãƒˆã®ä¸€éƒ¨ã¨ã—ã¦è¿”ã•ã‚Œã¾ã™ã€‚ *maxsplit* ãŒã‚¼ãƒ­ã§ãªã‘ã‚Œã°ã€é«˜ã€… *maxsplit* å€‹ã®åˆ†å‰²ãŒç™ºç”Ÿã—ã€æ–‡å­—åˆ—ã®æ®‹ã‚Šã¯ã€ãƒªã‚¹ãƒˆã®æœ€çµ‚è¦ç´ ã¨ã—ã¦è¿”ã•ã‚Œã¾ã™ã€‚ (éäº’æ›æ€§ãƒãƒ¼ãƒˆï¼šã‚ªãƒªã‚¸ãƒŠãƒ«ã® Python 1.5 ãƒªãƒªãƒ¼ã‚¹ã§ã¯ã€ *maxsplit* ã¯ç„¡è¦–ã•ã‚Œã¦ã„ã¾ã—ãŸã€‚ã“ã‚Œã¯ãã®å¾Œã®ãƒªãƒªãƒ¼ã‚¹ã§ã¯ä¿®æ­£ã•ã‚Œã¾ã—ãŸã€‚)"

#: ../../library/re.rst:591
msgid ""
"If there are capturing groups in the separator and it matches at the start "
"of the string, the result will start with an empty string.  The same holds "
"for the end of the string:"
msgstr "ã‚‚ã—ã€æ•æ‰ã™ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ãŒåˆ†å‰²ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å«ã¾ã‚Œã€ãã‚ŒãŒæ–‡å­—åˆ—ã®å…ˆé ­ã«ã‚ã‚‹ãªã‚‰ã°ã€åˆ†å‰²çµæœã¯ã€ç©ºæ–‡å­—åˆ—ã‹ã‚‰å§‹ã¾ã‚Šã¾ã™ã€‚æ–‡å­—åˆ—æœ€å¾Œã«ãŠã„ã¦ã‚‚åŒæ§˜ã§ã™ã€‚"

#: ../../library/re.rst:598
msgid ""
"That way, separator components are always found at the same relative indices"
" within the result list (e.g., if there's one capturing group in the "
"separator, the 0th, the 2nd and so forth)."
msgstr "ãã®å ´åˆã€å¸¸ã«ã€åˆ†å‰²è¦ç´ ãŒã€åˆ†å‰²çµæœã®ãƒªã‚¹ãƒˆã®ç›¸å¯¾çš„ãªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«ç¾ã‚Œã¾ã™ã€‚ (ä¾‹ãˆã°ã€åˆ†å‰²å­ã®ä¸­ã«æ•æ‰ã™ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ãŒä¸€ã¤ã ã‘ã‚ã‚Œã°ã€0ç•ªç›®ã€2ç•ªç›®ã€ãã—ã¦ã€4ç•ªç›®ã§ã™)"

#: ../../library/re.rst:602
msgid ""
"Note that *split* will never split a string on an empty pattern match. For "
"example:"
msgstr "*split* ã¯ç©ºã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã§ã¯ã€æ–‡å­—åˆ—ã‚’åˆ†å‰²ã—ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ä¸‹ã•ã„ã€‚ä¾‹ãˆã°:"

#: ../../library/re.rst:610 ../../library/re.rst:632 ../../library/re.rst:645
#: ../../library/re.rst:695 ../../library/re.rst:704
msgid "Added the optional flags argument."
msgstr "ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® flags å¼•æ•°ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/re.rst:617
msgid ""
"Return all non-overlapping matches of *pattern* in *string*, as a list of "
"strings.  The *string* is scanned left-to-right, and matches are returned in"
" the order found.  If one or more groups are present in the pattern, return "
"a list of groups; this will be a list of tuples if the pattern has more than"
" one group.  Empty matches are included in the result."
msgstr ""

#: ../../library/re.rst:625
msgid ""
"Due to the limitation of the current implementation the character following "
"an empty match is not included in a next match, so ``findall(r'^|\\w+', 'two"
" words')`` returns ``['', 'wo', 'words']`` (note missed \"t\").  This is "
"changed in Python 3.7."
msgstr ""

#: ../../library/re.rst:638
msgid ""
"Return an :term:`iterator` yielding :class:`MatchObject` instances over all "
"non-overlapping matches for the RE *pattern* in *string*.  The *string* is "
"scanned left-to-right, and matches are returned in the order found.  Empty "
"matches are included in the result.  See also the note about "
":func:`findall`."
msgstr ""

#: ../../library/re.rst:651
msgid ""
"Return the string obtained by replacing the leftmost non-overlapping "
"occurrences of *pattern* in *string* by the replacement *repl*.  If the "
"pattern isn't found, *string* is returned unchanged.  *repl* can be a string"
" or a function; if it is a string, any backslash escapes in it are "
"processed.  That is, ``\\n`` is converted to a single newline character, "
"``\\r`` is converted to a carriage return, and so forth.  Unknown escapes "
"such as ``\\j`` are left alone.  Backreferences, such as ``\\6``, are "
"replaced with the substring matched by group 6 in the pattern. For example:"
msgstr "*string* å†…ã§ã€ *pattern* ã¨é‡è¤‡ã—ãªã„ãƒãƒƒãƒã®å†…ã€ä¸€ç•ªå·¦ã«ã‚ã‚‹ã‚‚ã®ã‚’ç½®æ› *repl* ã§ç½®æ›ã—ã¦å¾—ã‚‰ã‚ŒãŸæ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚ã‚‚ã—ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°ã€ *string* ã‚’å¤‰æ›´ã›ãšã«è¿”ã—ã¾ã™ã€‚ *repl* ã¯æ–‡å­—åˆ—ã§ã‚‚é–¢æ•°ã§ã‚‚æ§‹ã„ã¾ã›ã‚“ï¼›ã‚‚ã—ãã‚ŒãŒæ–‡å­—åˆ—ã§ã‚ã‚Œã°ã€ãã‚Œã«ã‚ã‚‹ä»»æ„ã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã¯å‡¦ç†ã•ã‚Œã¾ã™ã€‚ã™ãªã‚ã¡ã€ ``\\n`` ã¯å˜ä¸€ã®æ”¹è¡Œæ–‡å­—ã«å¤‰æ›ã•ã‚Œã€ ``\\r`` ã¯ã€ã‚­ãƒ£ãƒªãƒƒã‚¸ãƒªã‚¿ãƒ¼ãƒ³ã«å¤‰æ›ã•ã‚Œã¾ã™ã€ç­‰ã€…ã€‚ ``\\j`` ã®ã‚ˆã†ãªæœªçŸ¥ã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã¯ãã®ã¾ã¾ã«ã•ã‚Œã¾ã™ã€‚ ``\\6`` ã®ã‚ˆã†ãªå¾Œæ–¹å‚ç…§(backreference)ã¯ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã‚°ãƒ«ãƒ¼ãƒ— 6 ã¨ãƒãƒƒãƒã—ãŸã‚µãƒ–æ–‡å­—åˆ—ã§ç½®æ›ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°:"

#: ../../library/re.rst:665
msgid ""
"If *repl* is a function, it is called for every non-overlapping occurrence "
"of *pattern*.  The function takes a single match object argument, and "
"returns the replacement string.  For example:"
msgstr "ã‚‚ã— *repl* ãŒé–¢æ•°ã§ã‚ã‚Œã°ã€é‡è¤‡ã—ãªã„ *pattern* ãŒç™ºç”Ÿã™ã‚‹ãŸã³ã«ãã®é–¢æ•°ãŒå‘¼ã°ã‚Œã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ä¸€ã¤ã®ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå¼•æ•°ã‚’å–ã‚Šã€ç½®æ›æ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚ä¾‹ãˆã°:"

#: ../../library/re.rst:677
msgid "The pattern may be a string or an RE object."
msgstr "ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€æ–‡å­—åˆ—ã§ã‚‚ RE ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:679
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  If omitted or zero,"
" all occurrences will be replaced. Empty matches for the pattern are "
"replaced only when not adjacent to a previous match, so ``sub('x*', '-', "
"'abc')`` returns ``'-a-b-c-'``."
msgstr "çœç•¥å¯èƒ½ãªå¼•æ•° *count* ã¯ã€ç½®æ›ã•ã‚Œã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å‡ºç¾å›æ•°ã®æœ€å¤§å€¤ã§ã™ï¼› *count* ã¯éè² ã®æ•´æ•°ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚‚ã—çœç•¥ã•ã‚Œã‚‹ã‹ã‚¼ãƒ­ã§ã‚ã‚Œã°ã€å‡ºç¾ã—ãŸã‚‚ã®ãŒã™ã¹ã¦ç½®æ›ã•ã‚Œã¾ã™ã€‚ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ãƒãƒƒãƒãŒç©ºã§ã‚ã‚Œã°ã€ä»¥å‰ã®ãƒãƒƒãƒã¨éš£åˆã‚ã›ã§ãªã„æ™‚ã ã‘ç½®æ›ã•ã‚Œã¾ã™ã®ã§ã€ ``sub('x*', '-', 'abc')`` ã¯ ``'-a-b-c-'`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/re.rst:685
msgid ""
"In string-type *repl* arguments, in addition to the character escapes and "
"backreferences described above, ``\\g<name>`` will use the substring matched"
" by the group named ``name``, as defined by the ``(?P<name>...)`` syntax. "
"``\\g<number>`` uses the corresponding group number; ``\\g<2>`` is therefore"
" equivalent to ``\\2``, but isn't ambiguous in a replacement such as "
"``\\g<2>0``.  ``\\20`` would be interpreted as a reference to group 20, not "
"a reference to group 2 followed by the literal character ``'0'``.  The "
"backreference ``\\g<0>`` substitutes in the entire substring matched by the "
"RE."
msgstr "æ–‡å­—åˆ—ã‚¿ã‚¤ãƒ— *repl* å¼•æ•°ã§ã¯ã€ä¸Šã§è¿°ã¹ãŸæ–‡å­—ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚„å¾Œæ–¹å‚ç…§ã®ä»–ã«ã€ ``\\g<name>`` ã¯ã€ ``(?P<name>...)`` ã‚·ãƒ³ã‚¿ã‚¯ã‚¹ã§å®šç¾©ã•ã‚ŒãŸ ``name`` ã‚°ãƒ«ãƒ¼ãƒ—ã«ã‚ˆã‚‹ãƒãƒƒãƒéƒ¨åˆ†æ–‡å­—åˆ—ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã—ã€ ``\\g<number>`` ã¯å¯¾å¿œã™ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ç•ªå·ã¸ã®å‚ç…§ã¨ãªã‚Šã¾ã™; ``\\g<2>`` ã¯ã¤ã¾ã‚Š ``\\2`` ã¨ç­‰ä¾¡ã§ã™ãŒã€ ``\\g<2>0`` ã®ã‚ˆã†ãªç½®æ›ã«ãŠã„ã¦ã‚‚æ›–æ˜§ã«ãªã‚Šã¾ã›ã‚“ã€‚ ``\\20`` ã¯ã€ã‚°ãƒ«ãƒ¼ãƒ— 20ã¸ã®å‚ç…§ã¨ã—ã¦è§£é‡ˆã•ã‚Œã€ã‚°ãƒ«ãƒ¼ãƒ— 2 ã«ãƒªãƒ†ãƒ©ãƒ«æ–‡å­— ``'0'`` ãŒç¶šã„ãŸã‚‚ã®ã¸ã®å‚ç…§ã¨ã—ã¦ã¯è§£é‡ˆã•ã‚Œãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚å¾Œæ–¹å‚ç…§ ``\\g<0>`` ã¯ã€RE ã¨ãƒãƒƒãƒã™ã‚‹ã‚µãƒ–æ–‡å­—åˆ—å…¨ä½“ã‚’ç½®ãæ›ãˆã¾ã™ã€‚"

#: ../../library/re.rst:701
msgid ""
"Perform the same operation as :func:`sub`, but return a tuple ``(new_string,"
" number_of_subs_made)``."
msgstr ":func:`sub` ã¨åŒã˜æ“ä½œã‚’è¡Œã„ã¾ã™ãŒã€ã‚¿ãƒ—ãƒ« ``(new_stringã€ number_of_subs_made)`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/re.rst:710
msgid ""
"Escape all the characters in *pattern* except ASCII letters and numbers. "
"This is useful if you want to match an arbitrary literal string that may "
"have regular expression metacharacters in it.  For example::"
msgstr ""

#: ../../library/re.rst:728
msgid "Clear the regular expression cache."
msgstr "æ­£è¦è¡¨ç¾ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã€‚"

#: ../../library/re.rst:733
msgid ""
"Exception raised when a string passed to one of the functions here is not a "
"valid regular expression (for example, it might contain unmatched "
"parentheses) or when some other error occurs during compilation or matching."
"  It is never an error if a string contains no match for a pattern."
msgstr "ã“ã“ã§ã®é–¢æ•°ã®ä¸€ã¤ã«æ¸¡ã•ã‚ŒãŸæ–‡å­—åˆ—ãŒã€æ­£ã—ã„æ­£è¦è¡¨ç¾ã§ã¯ãªã„æ™‚ (ä¾‹ãˆã°ã€ãã®æ‹¬å¼§ãŒå¯¾ã«ãªã£ã¦ã„ãªã‹ã£ãŸ)ã€ã‚ã‚‹ã„ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚„ãƒãƒƒãƒãƒ³ã‚°ã®é–“ã«ãªã‚“ã‚‰ã‹ã®ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸã¨ãã€ç™ºç”Ÿã™ã‚‹ä¾‹å¤–ã§ã™ã€‚ãŸã¨ãˆæ–‡å­—åˆ—ãŒãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ãƒãƒƒãƒã—ãªãã¦ã‚‚ã€æ±ºã—ã¦ã‚¨ãƒ©ãƒ¼ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:742
msgid "Regular Expression Objects"
msgstr "æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/re.rst:746
msgid ""
"The :class:`RegexObject` class supports the following methods and "
"attributes:"
msgstr ":class:`RegexObject` ã‚¯ãƒ©ã‚¹ã¯ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨å±æ€§ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™:"

#: ../../library/re.rst:750
msgid ""
"Scan through *string* looking for a location where this regular expression "
"produces a match, and return a corresponding :class:`MatchObject` instance. "
"Return ``None`` if no position in the string matches the pattern; note that "
"this is different from finding a zero-length match at some point in the "
"string."
msgstr "*string* ã‚’èµ°æŸ»ã—ã¦ã€ã“ã®æ­£è¦è¡¨ç¾ãŒãƒãƒƒãƒã™ã‚‹å ´æ‰€ã‚’æ¢ã—ã€å¯¾å¿œã™ã‚‹ :class:`MatchObject` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ string ã®ã©ã“ã«ã‚‚ãƒãƒƒãƒã—ãªã„å ´åˆã¯ ``None`` ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯ã€ string å†…ã®ã©ã“ã‹ã§é•·ã•0ã§ãƒãƒƒãƒã—ãŸå ´åˆã¨ç•°ãªã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/re.rst:755
msgid ""
"The optional second parameter *pos* gives an index in the string where the "
"search is to start; it defaults to ``0``.  This is not completely equivalent"
" to slicing the string; the ``'^'`` pattern character matches at the real "
"beginning of the string and at positions just after a newline, but not "
"necessarily at the index where the search is to start."
msgstr "çœç•¥å¯èƒ½ãªã€2ã¤ç›®ã®å¼•æ•° *pos* ã¯ã€ string ã®ã©ã“ã‹ã‚‰æ¢ã—å§‹ã‚ã‚‹ã‹ã‚’æŒ‡å®šã™ã‚‹ index ã§ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ 0 ã§ã™ã€‚ã“ã‚Œã¯ã€æ–‡å­—åˆ—ã‚’ã‚¹ãƒ©ã‚¤ã‚¹ã—ã¦ã‹ã‚‰æ¤œç´¢ã™ã‚‹ã®ã¨ã€å®Œå…¨ã«ã¯åŒã˜ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ‘ã‚¿ãƒ¼ãƒ³æ–‡å­— ``'^'`` ã¯æœ¬å½“ã®æ–‡å­—åˆ—ã®å…ˆé ­ã¨ã€æ”¹è¡Œã®ç›´å¾Œã«ãƒãƒƒãƒã—ã¾ã™ãŒã€æ¤œç´¢ã‚’é–‹å§‹ã™ã‚‹ index ãŒãƒãƒƒãƒã™ã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:761
msgid ""
"The optional parameter *endpos* limits how far the string will be searched; "
"it will be as if the string is *endpos* characters long, so only the "
"characters from *pos* to ``endpos - 1`` will be searched for a match.  If "
"*endpos* is less than *pos*, no match will be found, otherwise, if *rx* is a"
" compiled regular expression object, ``rx.search(string, 0, 50)`` is "
"equivalent to ``rx.search(string[:50], 0)``."
msgstr "çœç•¥å¯èƒ½ãªå¼•æ•° *endpos* ã¯ string ã®ã©ã“ã¾ã§ã‚’æ¤œç´¢ã™ã‚‹ã‹ã‚’åˆ¶é™ã—ã¾ã™ã€‚ã“ã‚Œã¯ string ã®é•·ã•ãŒ *endpos* æ–‡å­—ã ã£ãŸå ´åˆã¨åŒã˜ã‚ˆã†ã«å‹•ä½œã—ã¾ã™ã€‚ã¤ã¾ã‚Šã€ *pos* ã‹ã‚‰ ``endpos - 1`` ã®ç¯„å›²ã®æ–‡å­—ã«å¯¾ã—ã¦ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã—ã¾ã™ã€‚ *endpos* ãŒ *pos* ã‚ˆã‚Šã‚‚å°ã•ã„å ´åˆã¯ã€ãƒãƒƒãƒã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ã€ *rx* ãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸæ­£è¦è¡¨ç¾ã¨ã—ã¦ã€ ``rx.search(string, 0, 50)`` ã¯ ``rx.search(string[:50], 0)`` ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/re.rst:776
msgid ""
"If zero or more characters at the *beginning* of *string* match this regular"
" expression, return a corresponding :class:`MatchObject` instance.  Return "
"``None`` if the string does not match the pattern; note that this is "
"different from a zero-length match."
msgstr "ã‚‚ã— *string* ã® **å…ˆé ­ã®** 0 å€‹ä»¥ä¸Šã®æ–‡å­—ãŒã“ã®æ­£è¦è¡¨ç¾ã¨ãƒãƒƒãƒã™ã‚Œã°ã€å¯¾å¿œã™ã‚‹ :class:`MatchObject` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ã‚‚ã—æ–‡å­—åˆ—ãŒãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ãƒãƒƒãƒã—ãªã‘ã‚Œã°ã€ ``None`` ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯é•·ã•ã‚¼ãƒ­ã®ãƒãƒƒãƒã¨ã¯ç•°ãªã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../library/re.rst:781
msgid ""
"The optional *pos* and *endpos* parameters have the same meaning as for the "
":meth:`~RegexObject.search` method."
msgstr "çœç•¥å¯èƒ½ãªå¼•æ•° *pos* ã¨ *endpos* å¼•æ•°ã¯ã€ :meth:`~RegexObject.search` ãƒ¡ã‚½ãƒƒãƒ‰ã¨åŒã˜æ„å‘³ã‚’æŒã¡ã¾ã™ã€‚"

#: ../../library/re.rst:789
msgid ""
"If you want to locate a match anywhere in *string*, use "
":meth:`~RegexObject.search` instead (see also :ref:`search-vs-match`)."
msgstr "*string* ã®ã©ã“ã«ã§ã‚‚ãƒãƒƒãƒã•ã›ãŸã‘ã‚Œã°ã€ä»£ã‚ã‚Šã« :meth:`~RegexObject.search` ã‚’ä½¿ã£ã¦ä¸‹ã•ã„( :ref:`search-vs-match`) ã‚‚å‚ç…§ã—ã¦ãã ã•ã„)ã€‚"

#: ../../library/re.rst:795
msgid "Identical to the :func:`split` function, using the compiled pattern."
msgstr ":func:`split` é–¢æ•°ã¨åŒæ§˜ã§ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ã„ã¾ã™ã€‚ãŸã ã—ã€ :meth:`match` ã¨åŒã˜ã‚ˆã†ã«ã€çœç•¥å¯èƒ½ãª *pos*, *endpos* å¼•æ•°ã§æ¤œç´¢ç¯„å›²ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/re.rst:800
msgid ""
"Similar to the :func:`findall` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`match`."
msgstr ":func:`findall` é–¢æ•°ã¨åŒæ§˜ã§ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ã„ã¾ã™ã€‚ãŸã ã—ã€ :meth:`match` ã¨åŒã˜ã‚ˆã†ã«ã€çœç•¥å¯èƒ½ãª *pos*, *endpos* å¼•æ•°ã§æ¤œç´¢ç¯„å›²ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/re.rst:807
msgid ""
"Similar to the :func:`finditer` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`match`."
msgstr ":func:`finditer` é–¢æ•°ã¨åŒæ§˜ã§ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ã„ã¾ã™ã€‚ãŸã ã—ã€ :meth:`match` ã¨åŒã˜ã‚ˆã†ã«ã€çœç•¥å¯èƒ½ãª *pos*, *endpos* å¼•æ•°ã§æ¤œç´¢ç¯„å›²ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/re.rst:814
msgid "Identical to the :func:`sub` function, using the compiled pattern."
msgstr ":func:`sub` é–¢æ•°ã¨åŒæ§˜ã§ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../library/re.rst:819
msgid "Identical to the :func:`subn` function, using the compiled pattern."
msgstr ":func:`subn` é–¢æ•°ã¨åŒæ§˜ã§ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../library/re.rst:824
msgid ""
"The regex matching flags.  This is a combination of the flags given to "
":func:`.compile` and any ``(?...)`` inline flags in the pattern."
msgstr "æ­£è¦è¡¨ç¾ã®ãƒãƒƒãƒãƒ³ã‚°ãƒ•ãƒ©ã‚°ã§ã™ã€‚ã“ã‚Œã¯ :func:`.compile` ã§æŒ‡å®šã•ã‚ŒãŸãƒ•ãƒ©ã‚°ã€ãŠã‚ˆã³ãƒ‘ã‚¿ãƒ¼ãƒ³å†…ã® ``(?...)`` ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒ•ãƒ©ã‚°ã¨ã®çµ„ã¿åˆã‚ã›ã«ãªã‚Šãªã™ã€‚"

#: ../../library/re.rst:830
msgid "The number of capturing groups in the pattern."
msgstr "ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã‚ã‚‹ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚°ãƒ«ãƒ¼ãƒ—ã®æ•°ã§ã™ã€‚"

#: ../../library/re.rst:835
msgid ""
"A dictionary mapping any symbolic group names defined by ``(?P<id>)`` to "
"group numbers.  The dictionary is empty if no symbolic groups were used in "
"the pattern."
msgstr "``(?P<id>)`` ã§å®šç¾©ã•ã‚ŒãŸä»»æ„ã®è¨˜å·ã‚°ãƒ«ãƒ¼ãƒ—åã®ã€ã‚°ãƒ«ãƒ¼ãƒ—ç•ªå·ã¸ã®è¾æ›¸ãƒãƒƒãƒ”ãƒ³ã‚°ã§ã™ã€‚ã‚‚ã—è¨˜å·ã‚°ãƒ«ãƒ¼ãƒ—ãŒãƒ‘ã‚¿ãƒ¼ãƒ³å†…ã§ä½•ã‚‚ä½¿ã‚ã‚Œã¦ã„ãªã‘ã‚Œã°ã€è¾æ›¸ã¯ç©ºã§ã™ã€‚"

#: ../../library/re.rst:842
msgid "The pattern string from which the RE object was compiled."
msgstr "RE ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãã‚Œã‹ã‚‰ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸãƒ‘ã‚¿ãƒ¼ãƒ³æ–‡å­—åˆ—ã§ã™ã€‚"

#: ../../library/re.rst:848
msgid "Match Objects"
msgstr "MatchObject ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/re.rst:852
msgid ""
"Match objects always have a boolean value of ``True``. Since "
":meth:`~regex.match` and :meth:`~regex.search` return ``None`` when there is"
" no match, you can test whether there was a match with a simple ``if`` "
"statement::"
msgstr "ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¸¸ã«ãƒ–ãƒ¼ãƒ«å€¤ ``True`` ã‚’æŒã¡ã¾ã™ã€‚ :meth:`~regex.match` ã¨ :meth:`~regex.search` ã¯ãƒãƒƒãƒã—ãªã‹ã£ãŸå ´åˆã« ``None`` ã‚’è¿”ã™ã®ã§ã€å˜ç´”ãª ``if`` ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã«ã‚ˆã£ã¦ãƒãƒƒãƒã—ãŸã‹ã©ã†ã‹ã‚’ãƒ†ã‚¹ãƒˆã§ãã¾ã™::"

#: ../../library/re.rst:861
msgid "Match objects support the following methods and attributes:"
msgstr "ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨å±æ€§ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™:"

#: ../../library/re.rst:866
msgid ""
"Return the string obtained by doing backslash substitution on the template "
"string *template*, as done by the :meth:`~RegexObject.sub` method.  Escapes "
"such as ``\\n`` are converted to the appropriate characters, and numeric "
"backreferences (``\\1``, ``\\2``) and named backreferences (``\\g<1>``, "
"``\\g<name>``) are replaced by the contents of the corresponding group."
msgstr "ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆæ–‡å­—åˆ— *template* ã«ã€ :meth:`~RegexObject.sub` ãƒ¡ã‚½ãƒƒãƒ‰ãŒã™ã‚‹ã‚ˆã†ãªãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ç½®æ›ã‚’ã—ã¦å¾—ã‚‰ã‚Œã‚‹æ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚ ``\\n`` ã®ã‚ˆã†ãªã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã¯é©å½“ãªæ–‡å­—ã«å¤‰æ›ã•ã‚Œã€æ•°å€¤ã®å¾Œæ–¹å‚ç…§ (``\\1``, ``\\2``) ã¨åå‰ä»˜ãã®å¾Œæ–¹å‚ç…§ (``\\g<1>``, ``\\g<name>``) ã¯ã€å¯¾å¿œã™ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ã®å†…å®¹ã§ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:875
msgid ""
"Returns one or more subgroups of the match.  If there is a single argument, "
"the result is a single string; if there are multiple arguments, the result "
"is a tuple with one item per argument. Without arguments, *group1* defaults "
"to zero (the whole match is returned). If a *groupN* argument is zero, the "
"corresponding return value is the entire matching string; if it is in the "
"inclusive range [1..99], it is the string matching the corresponding "
"parenthesized group.  If a group number is negative or larger than the "
"number of groups defined in the pattern, an :exc:`IndexError` exception is "
"raised. If a group is contained in a part of the pattern that did not match,"
" the corresponding result is ``None``. If a group is contained in a part of "
"the pattern that matched multiple times, the last match is returned."
msgstr "ãƒãƒƒãƒã—ãŸ1å€‹ä»¥ä¸Šã®ã‚µãƒ–ã‚°ãƒ«ãƒ¼ãƒ—ã‚’è¿”ã—ã¾ã™ã€‚ã‚‚ã—å¼•æ•°ã§ä¸€ã¤ã§ã‚ã‚Œã°ã€ãã®çµæœã¯ä¸€ã¤ã®æ–‡å­—åˆ—ã§ã™ã€‚è¤‡æ•°ã®å¼•æ•°ãŒã‚ã‚Œã°ã€ãã®çµæœã¯ã€å¼•æ•°ã”ã¨ã«ä¸€é …ç›®ã‚’æŒã¤ã‚¿ãƒ—ãƒ«ã§ã™ã€‚å¼•æ•°ãŒãªã‘ã‚Œã°ã€ *group1* ã¯ãƒ‡ãƒ•ã‚©ãƒ¼ãƒ«ãƒˆã§ã‚¼ãƒ­ã§ã™(ãƒãƒƒãƒã—ãŸã‚‚ã®ã™ã¹ã¦ãŒè¿”ã•ã‚Œã¾ã™)ã€‚ã‚‚ã— *groupN* å¼•æ•°ãŒã‚¼ãƒ­ã§ã‚ã‚Œã°ã€å¯¾å¿œã™ã‚‹æˆ»ã‚Šå€¤ã¯ã€ãƒãƒƒãƒã™ã‚‹æ–‡å­—åˆ—å…¨ä½“ã§ã™ã€‚ã‚‚ã—ãã‚ŒãŒç¯„å›² [1..99] å†…ã§ã‚ã‚Œã°ã€ãã‚Œã¯ã€å¯¾å¿œã™ã‚‹ä¸¸æ‹¬å¼§ã¤ãã‚°ãƒ«ãƒ¼ãƒ—ã¨ãƒãƒƒãƒã™ã‚‹æ–‡å­—åˆ—ã§ã™ã€‚ã‚‚ã—ã‚°ãƒ«ãƒ¼ãƒ—ç•ªå·ãŒè² ã§ã‚ã‚‹ã‹ã€ã‚ã‚‹ã„ã¯ãƒ‘ã‚¿ãƒ¼ãƒ³ã§å®šç¾©ã•ã‚ŒãŸã‚°ãƒ«ãƒ¼ãƒ—ã®æ•°ã‚ˆã‚Šå¤§ãã‘ã‚Œã°ã€ :exc:`IndexError` ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã™ã€‚ã‚°ãƒ«ãƒ¼ãƒ—ãŒãƒãƒƒãƒã—ãªã‹ã£ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã®ä¸€éƒ¨ã«å«ã¾ã‚Œã¦ã„ã‚Œã°ã€å¯¾å¿œã™ã‚‹çµæœã¯ ``None`` ã§ã™ã€‚ã‚°ãƒ«ãƒ¼ãƒ—ãŒã€è¤‡æ•°å›ãƒãƒƒãƒã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã®ä¸€éƒ¨ã«å«ã¾ã‚Œã¦ã„ã‚Œã°ã€æœ€å¾Œã®ãƒãƒƒãƒãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:897
msgid ""
"If the regular expression uses the ``(?P<name>...)`` syntax, the *groupN* "
"arguments may also be strings identifying groups by their group name.  If a "
"string argument is not used as a group name in the pattern, an "
":exc:`IndexError` exception is raised."
msgstr "ã‚‚ã—æ­£è¦è¡¨ç¾ãŒ ``(?P<name>...)`` ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ã‚’ä½¿ã†ãªã‚‰ã°ã€ *groupN* å¼•æ•°ã¯ã€ãã‚Œã‚‰ã®ã‚°ãƒ«ãƒ¼ãƒ—åã«ã‚ˆã£ã¦ã‚°ãƒ«ãƒ¼ãƒ—ã‚’è­˜åˆ¥ã™ã‚‹æ–‡å­—åˆ—ã§ã‚ã£ã¦ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚ã‚‚ã—æ–‡å­—åˆ—å¼•æ•°ãŒãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã‚°ãƒ«ãƒ¼ãƒ—åã¨ã—ã¦ä½¿ã‚ã‚Œã¦ã„ãªã„ã‚‚ã®ã§ã‚ã‚Œã°ã€ :exc:`IndexError` ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/re.rst:902
msgid "A moderately complicated example:"
msgstr "é©åº¦ã«è¤‡é›‘ãªä¾‹é¡Œ:"

#: ../../library/re.rst:910
msgid "Named groups can also be referred to by their index:"
msgstr "åå‰ã®ä»˜ã‘ã‚‰ã‚ŒãŸã‚°ãƒ«ãƒ¼ãƒ—ã¯ã€ãã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«ã‚ˆã£ã¦ã‚‚å‚ç…§ã§ãã¾ã™ã€‚"

#: ../../library/re.rst:917
msgid "If a group matches multiple times, only the last match is accessible:"
msgstr "ã‚‚ã—ã€ã‚°ãƒ«ãƒ¼ãƒ—ãŒè¤‡æ•°å›ãƒãƒƒãƒã™ã‚‹å ´åˆã€æœ€å¾Œã®ãƒãƒƒãƒã ã‘ãŒåˆ©ç”¨å¯èƒ½ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/re.rst:926
msgid ""
"Return a tuple containing all the subgroups of the match, from 1 up to "
"however many groups are in the pattern.  The *default* argument is used for "
"groups that did not participate in the match; it defaults to ``None``.  "
"(Incompatibility note: in the original Python 1.5 release, if the tuple was "
"one element long, a string would be returned instead.  In later versions "
"(from 1.5.1 on), a singleton tuple is returned in such cases.)"
msgstr "ãƒãƒƒãƒã®ã€1ã‹ã‚‰ãƒ‘ã‚¿ãƒ¼ãƒ³å†…ã«ã‚ã‚‹å…¨ã‚°ãƒ«ãƒ¼ãƒ—æ•°ã¾ã§ã®ã™ã¹ã¦ã®ã‚µãƒ–ã‚°ãƒ«ãƒ¼ãƒ—ã‚’å«ã‚€ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚ *default* å¼•æ•°ã¯ã€ãƒãƒƒãƒã«åŠ ã‚ã‚‰ãªã‹ã£ãŸã‚°ãƒ«ãƒ¼ãƒ—ç”¨ã«ä½¿ã‚ã‚Œã€ãƒ‡ãƒ•ã‚©ãƒ¼ãƒ«ãƒˆã§ã¯ ``None`` ã§ã™ã€‚ (éäº’æ›æ€§ãƒãƒ¼ãƒˆï¼šã‚ªãƒªã‚¸ãƒŠãƒ«ã® Python 1.5 ãƒªãƒªãƒ¼ã‚¹ã§ã¯ã€ãŸã¨ãˆã‚¿ãƒ—ãƒ«ãŒä¸€è¦ç´ é•·ã§ã‚ã£ã¦ã‚‚ã€ãã®ä»£ã‚ã‚Šã«æ–‡å­—åˆ—ã‚’è¿”ã—ã¦ã„ã¾ã—ãŸã€‚ (1.5.1 ä»¥é™ã®)å¾Œã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ã€ãã®ã‚ˆã†ãªå ´åˆã«ã¯ã€è¦ç´ ãŒã²ã¨ã¤ã®ã‚¿ãƒ—ãƒ«ãŒè¿”ã•ã‚Œã¾ã™ã€‚)"

#: ../../library/re.rst:933
msgid "For example:"
msgstr "ä¾‹ãˆã°:"

#: ../../library/re.rst:939
msgid ""
"If we make the decimal place and everything after it optional, not all "
"groups might participate in the match.  These groups will default to "
"``None`` unless the *default* argument is given:"
msgstr "ã‚‚ã—ã€æ•´æ•°éƒ¨ã«ã®ã¿ç€ç›®ã—ã€ã‚ã¨ã®éƒ¨åˆ†ã‚’ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¨ã—ãŸå ´åˆã€ãƒãƒƒãƒã®ä¸­ã«ç¾ã‚Œãªã„ã‚°ãƒ«ãƒ¼ãƒ—ãŒã‚ã‚‹ã‹ã‚‚çŸ¥ã‚Œã¾ã›ã‚“ã€‚ãã‚Œã‚‰ã®ã‚°ãƒ«ãƒ¼ãƒ—ã¯ã€ *default* å¼•æ•°ãŒä¸ãˆã‚‰ã‚Œã¦ã„ãªã„å ´åˆã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ ``None`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/re.rst:952
msgid ""
"Return a dictionary containing all the *named* subgroups of the match, keyed"
" by the subgroup name.  The *default* argument is used for groups that did "
"not participate in the match; it defaults to ``None``.  For example:"
msgstr "ãƒãƒƒãƒã®ã€ã™ã¹ã¦ã® *åå‰ã¤ãã®* ã‚µãƒ–ã‚°ãƒ«ãƒ¼ãƒ—ã‚’å«ã‚€ã€ã‚µãƒ–ã‚°ãƒ«ãƒ¼ãƒ—åã§ã‚­ãƒ¼ä»˜ã‘ã•ã‚ŒãŸè¾æ›¸ã‚’è¿”ã—ã¾ã™ã€‚ *default* å¼•æ•°ã¯ãƒãƒƒãƒã«åŠ ã‚ã‚‰ãªã‹ã£ãŸã‚°ãƒ«ãƒ¼ãƒ—ã«ä½¿ã‚ã‚Œã€ãƒ‡ãƒ•ã‚©ãƒ¼ãƒ«ãƒˆã§ã¯ ``None`` ã§ã™ã€‚ä¾‹ãˆã°ã€"

#: ../../library/re.rst:964
msgid ""
"Return the indices of the start and end of the substring matched by *group*;"
" *group* defaults to zero (meaning the whole matched substring). Return "
"``-1`` if *group* exists but did not contribute to the match.  For a match "
"object *m*, and a group *g* that did contribute to the match, the substring "
"matched by group *g* (equivalent to ``m.group(g)``) is ::"
msgstr "*group* ã¨ãƒãƒƒãƒã—ãŸéƒ¨åˆ†æ–‡å­—åˆ—ã®å…ˆé ­ã¨æœ«å°¾ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ *group* ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯(ãƒãƒƒãƒã—ãŸéƒ¨åˆ†æ–‡å­—åˆ—å…¨ä½“ã‚’æ„å‘³ã™ã‚‹ï¼‰ã‚¼ãƒ­ã§ã™ã€‚ *group* ãŒå­˜åœ¨ã—ã¦ã‚‚ãƒãƒƒãƒã«å¯„ä¸ã—ãªã‹ã£ãŸå ´åˆã¯ã€ ``-1`` ã‚’è¿”ã—ã¾ã™ã€‚ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ *m* ãŠã‚ˆã³ã€ãƒãƒƒãƒã«å¯„ä¸ã—ãªã‹ã£ãŸã‚°ãƒ«ãƒ¼ãƒ— *g* ãŒã‚ã£ã¦ã€ã‚°ãƒ«ãƒ¼ãƒ— *g* ã¨ãƒãƒƒãƒã—ãŸã‚µãƒ–æ–‡å­—åˆ— ( ``m.group(g)`` ã¨åŒã˜æ„å‘³ã§ã™ãŒ ) ã¯::"

#: ../../library/re.rst:972
msgid ""
"Note that ``m.start(group)`` will equal ``m.end(group)`` if *group* matched "
"a null string.  For example, after ``m = re.search('b(c?)', 'cba')``, "
"``m.start(0)`` is 1, ``m.end(0)`` is 2, ``m.start(1)`` and ``m.end(1)`` are "
"both 2, and ``m.start(2)`` raises an :exc:`IndexError` exception."
msgstr "ã§ã™ã€‚ã‚‚ã— *group* ãŒç©ºæ–‡å­—åˆ—ã¨ãƒãƒƒãƒã™ã‚Œã°ã€ ``m.start(group)`` ãŒ ``m.end(group)`` ã¨ç­‰ã—ããªã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ä¸‹ã•ã„ã€‚ä¾‹ãˆã°ã€ ``m = re.search('b(c?)', 'cba')`` ã¨ã™ã‚‹ã¨ã€ ``m.start(0)`` ã¯ 1 ã§ã€ ``m.end(0)`` ã¯ 2 ã§ã‚ã‚Šã€ ``m.start(1)`` ã¨ ``m.end(1)`` ã¯ã¨ã‚‚ã« 2 ã§ã‚ã‚Šã€ ``m.start(2)`` ã¯ :exc:`IndexError` ä¾‹å¤–ã‚’ç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/re.rst:977
msgid "An example that will remove *remove_this* from email addresses:"
msgstr "ä¾‹ã¨ã—ã¦ã€é›»å­ãƒ¡ãƒ¼ãƒ«ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰ *remove_this* ã‚’å–ã‚Šé™¤ãå ´åˆã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/re.rst:987
msgid ""
"For :class:`MatchObject` *m*, return the 2-tuple ``(m.start(group), "
"m.end(group))``. Note that if *group* did not contribute to the match, this "
"is ``(-1, -1)``.  *group* defaults to zero, the entire match."
msgstr ":class:`MatchObject` *m* ã«ã¤ã„ã¦ã€å¤§ãã•2ã®ã‚¿ãƒ—ãƒ« ``(m.start(group), m.end(group))`` ã‚’è¿”ã—ã¾ã™ã€‚ã‚‚ã— *group* ãŒãƒãƒƒãƒã«å¯„ä¸ã—ãªã‹ã£ãŸã‚‰ã€ã“ã‚Œã¯ ``(-1, -1)`` ã§ã™ã€‚ã¾ãŸ *group* ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã‚¼ãƒ­ã§ã™ã€‚"

#: ../../library/re.rst:994
msgid ""
"The value of *pos* which was passed to the :meth:`~RegexObject.search` or "
":meth:`~RegexObject.match` method of the :class:`RegexObject`.  This is the "
"index into the string at which the RE engine started looking for a match."
msgstr ":class:`RegexObject` ã® :meth:`~RegexObject.search` ã‹ :meth:`~RegexObject.match` ã«æ¸¡ã•ã‚ŒãŸ *pos* ã®å€¤ã§ã™ã€‚ã“ã‚Œã¯ RE ã‚¨ãƒ³ã‚¸ãƒ³ãŒãƒãƒƒãƒã‚’æ¢ã—å§‹ã‚ã‚‹ä½ç½®ã®æ–‡å­—åˆ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã™ã€‚"

#: ../../library/re.rst:1001
msgid ""
"The value of *endpos* which was passed to the :meth:`~RegexObject.search` or"
" :meth:`~RegexObject.match` method of the :class:`RegexObject`.  This is the"
" index into the string beyond which the RE engine will not go."
msgstr ":class:`RegexObject` ã® :meth:`~RegexObject.search` ã‹ :meth:`~RegexObject.match` ã«æ¸¡ã•ã‚ŒãŸ *endpos* ã®å€¤ã§ã™ã€‚ã“ã‚Œã¯ RE ã‚¨ãƒ³ã‚¸ãƒ³ãŒãã‚Œä»¥ä¸Šã¯é€²ã¾ãªã„ä½ç½®ã®æ–‡å­—åˆ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã™ã€‚"

#: ../../library/re.rst:1008
msgid ""
"The integer index of the last matched capturing group, or ``None`` if no "
"group was matched at all. For example, the expressions ``(a)b``, "
"``((a)(b))``, and ``((ab))`` will have ``lastindex == 1`` if applied to the "
"string ``'ab'``, while the expression ``(a)(b)`` will have ``lastindex == "
"2``, if applied to the same string."
msgstr "æœ€å¾Œã«ãƒãƒƒãƒã—ãŸå–ã‚Šè¾¼ã¿ã‚°ãƒ«ãƒ¼ãƒ—ã®æ•´æ•°ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã™ã€‚ã‚‚ã—ã©ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚‚å…¨ããƒãƒƒãƒã—ãªã‘ã‚Œã° ``None`` ã§ã™ã€‚ä¾‹ãˆã°ã€ ``(a)b``, ``((a)(b))`` ã‚„ ``((ab))`` ã¨ã„ã£ãŸè¡¨ç¾ãŒ ``'ab'`` ã«é©ç”¨ã•ã‚ŒãŸå ´åˆã€ ``lastindex == 1`` ã¨ãªã‚Šã€åŒã˜æ–‡å­—åˆ—ã« ``(a)(b)`` ãŒé©ç”¨ã•ã‚ŒãŸå ´åˆã«ã¯ ``lastindex == 2`` ã¨ãªã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../library/re.rst:1017
msgid ""
"The name of the last matched capturing group, or ``None`` if the group "
"didn't have a name, or if no group was matched at all."
msgstr "æœ€å¾Œã«ãƒãƒƒãƒã—ãŸå–ã‚Šè¾¼ã¿ã‚°ãƒ«ãƒ¼ãƒ—ã®åå‰ã§ã™ã€‚ã‚‚ã—ã‚°ãƒ«ãƒ¼ãƒ—ã«åå‰ãŒãªã„ã‹ã€ã‚ã‚‹ã„ã¯ã©ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚‚å…¨ããƒãƒƒãƒã—ãªã‘ã‚Œã° ``None`` ã§ã™ã€‚"

#: ../../library/re.rst:1023
msgid ""
"The regular expression object whose :meth:`~RegexObject.match` or "
":meth:`~RegexObject.search` method produced this :class:`MatchObject` "
"instance."
msgstr "ã“ã® :class:`MatchObject` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ :meth:`~RegexObject.match` ã‚ã‚‹ã„ã¯ :meth:`~RegexObject.search` ãƒ¡ã‚½ãƒƒãƒ‰ã§ç”Ÿæˆã—ãŸæ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚"

#: ../../library/re.rst:1030
msgid ""
"The string passed to :meth:`~RegexObject.match` or "
":meth:`~RegexObject.search`."
msgstr ":meth:`~RegexObject.match` ã‚ã‚‹ã„ã¯ :meth:`~RegexObject.search` ã«æ¸¡ã•ã‚ŒãŸæ–‡å­—åˆ—ã§ã™ã€‚"

#: ../../library/re.rst:1035
msgid "Examples"
msgstr "ä¾‹"

#: ../../library/re.rst:1039
msgid "Checking For a Pair"
msgstr "ãƒšã‚¢ã®ç¢ºèª"

#: ../../library/re.rst:1041
msgid ""
"In this example, we'll use the following helper function to display match "
"objects a little more gracefully:"
msgstr "ã“ã®ä¾‹ã§ã¯ã€ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è¡¨ç¤ºã‚’å°‘ã—ç¾ã—ãã™ã‚‹ãŸã‚ã«ã€ä¸‹è¨˜ã®è£œåŠ©é–¢æ•°ã‚’ä½¿ç”¨ã—ã¾ã™ :"

#: ../../library/re.rst:1051
msgid ""
"Suppose you are writing a poker program where a player's hand is represented"
" as a 5-character string with each character representing a card, \"a\" for "
"ace, \"k\" for king, \"q\" for queen, \"j\" for jack, \"t\" for 10, and "
"\"2\" through \"9\" representing the card with that value."
msgstr "ã‚ãªãŸãŒãƒãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ã„ã¦ã„ã‚‹ã¨ã—ã¾ã™ã€‚ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æŒã¡æœ­ã¯ãã‚Œãã‚Œã®æ–‡å­—ãŒ1æšã®ã‚«ãƒ¼ãƒ‰ã‚’æ„å‘³ã™ã‚‹5æ–‡å­—ã®æ–‡å­—åˆ—ã«ã‚ˆã£ã¦è¡¨ç¾ã•ã‚Œã¾ã™ã€‚ \"a\" ã¯ã‚¨ãƒ¼ã‚¹ã€ \"k\" ã¯ã‚­ãƒ³ã‚°ã€ \"q\" ã¯ã‚¯ã‚¤ãƒ¼ãƒ³ã€ \"j\" ã¯ã‚¸ãƒ£ãƒƒã‚¯ \"t\" ã¯10ã€ãã—ã¦ \"2\" ã‹ã‚‰ \"9\" ã¯ãã‚Œãã‚Œã®æ•°å­—ã®ã‚«ãƒ¼ãƒ‰ã‚’è¡¨ã—ã¾ã™ã€‚"

#: ../../library/re.rst:1056
msgid "To see if a given string is a valid hand, one could do the following:"
msgstr "ä¸ãˆã‚‰ã‚ŒãŸæ–‡å­—åˆ—ãŒã€æŒã¡æœ­ã¨ã—ã¦æœ‰åŠ¹ã‹ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã«ã€ä¸‹è¨˜ã®ã‚ˆã†ã«ã™ã‚‹ã‹ã‚‚çŸ¥ã‚Œã¾ã›ã‚“ã€‚ :"

#: ../../library/re.rst:1066
msgid ""
"That last hand, ``\"727ak\"``, contained a pair, or two of the same valued "
"cards. To match this with a regular expression, one could use backreferences"
" as such:"
msgstr "æœ€å¾Œã®æŒã¡æœ­ ``\"727ak\"`` ã¯ã€ãƒšã‚¢ã‚’å«ã‚“ã§ã„ã¾ã™ã€‚è¨€ã„æ›ãˆã‚‹ã¨åŒã˜å€¤ã®ã‚«ãƒ¼ãƒ‰ãŒ2æšã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚’æ­£è¦è¡¨ç¾ã«ãƒãƒƒãƒã•ã›ã‚‹ãŸã‚ã«ã€å¾Œæ–¹å‚ç…§ã‚’ä½¿ã†å ´åˆã‚‚ã‚ã‚Šã¾ã™ :"

#: ../../library/re.rst:1076
msgid ""
"To find out what card the pair consists of, one could use the "
":meth:`~MatchObject.group` method of :class:`MatchObject` in the following "
"manner:"
msgstr "ã©ã®ã‚«ãƒ¼ãƒ‰ã®ãƒšã‚¢ã«ãªã£ã¦ã„ã‚‹ã‹ã‚’èª¿ã¹ã‚‹ãŸã‚ã€ä¸‹è¨˜ã®ã‚ˆã†ã« :class:`MatchObject` ã® :meth:`~RegexObject.group` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã†å ´åˆãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/re.rst:1097
msgid "Simulating scanf()"
msgstr "scanf() ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹"

#: ../../library/re.rst:1101
msgid ""
"Python does not currently have an equivalent to :c:func:`scanf`.  Regular "
"expressions are generally more powerful, though also more verbose, than "
":c:func:`scanf` format strings.  The table below offers some more-or-less "
"equivalent mappings between :c:func:`scanf` format tokens and regular "
"expressions."
msgstr "Python ã«ã¯ç¾åœ¨ã®ã¨ã“ã‚ã€ :c:func:`scanf` ã«ç›¸å½“ã™ã‚‹ã‚‚ã®ãŒã‚ã‚Šã¾ã›ã‚“ã€‚æ­£è¦è¡¨ç¾ã¯ã€ :c:func:`scanf` ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ–‡å­—åˆ—ã‚ˆã‚Šã‚‚ã€ä¸€èˆ¬çš„ã«ã‚ˆã‚Šå¼·åŠ›ã§ã‚ã‚Šã€ã¾ãŸå†—é•·ã§ã‚‚ã‚ã‚Šã¾ã™ã€‚ä»¥ä¸‹ã®è¡¨ã«ã€ :c:func:`scanf` ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒˆãƒ¼ã‚¯ãƒ³ã¨æ­£è¦è¡¨ç¾ã®å¤§ä½“åŒç­‰ãªå¯¾å¿œä»˜ã‘ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/re.rst:1108
msgid ":c:func:`scanf` Token"
msgstr ":c:func:`scanf` ãƒˆãƒ¼ã‚¯ãƒ³"

#: ../../library/re.rst:1108
msgid "Regular Expression"
msgstr "æ­£è¦è¡¨ç¾"

#: ../../library/re.rst:1110
msgid "``%c``"
msgstr "``%c``"

#: ../../library/re.rst:1110
msgid "``.``"
msgstr "``.``"

#: ../../library/re.rst:1112
msgid "``%5c``"
msgstr "``%5c``"

#: ../../library/re.rst:1112
msgid "``.{5}``"
msgstr "``.{5}``"

#: ../../library/re.rst:1114
msgid "``%d``"
msgstr "``%d``"

#: ../../library/re.rst:1114
msgid "``[-+]?\\d+``"
msgstr "``[-+]?\\d+``"

#: ../../library/re.rst:1116
msgid "``%e``, ``%E``, ``%f``, ``%g``"
msgstr "``%e``, ``%E``, ``%f``, ``%g``"

#: ../../library/re.rst:1116
msgid "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"
msgstr "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"

#: ../../library/re.rst:1118
msgid "``%i``"
msgstr "``%i``"

#: ../../library/re.rst:1118
msgid "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"
msgstr "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"

#: ../../library/re.rst:1120
msgid "``%o``"
msgstr "``%o``"

#: ../../library/re.rst:1120
msgid "``[-+]?[0-7]+``"
msgstr "``[-+]?[0-7]+``"

#: ../../library/re.rst:1122
msgid "``%s``"
msgstr "``%s``"

#: ../../library/re.rst:1122
msgid "``\\S+``"
msgstr "``\\S+``"

#: ../../library/re.rst:1124
msgid "``%u``"
msgstr "``%u``"

#: ../../library/re.rst:1124
msgid "``\\d+``"
msgstr "``\\d+``"

#: ../../library/re.rst:1126
msgid "``%x``, ``%X``"
msgstr "``%x``, ``%X``"

#: ../../library/re.rst:1126
msgid "``[-+]?(0[xX])?[\\dA-Fa-f]+``"
msgstr "``[-+]?(0[xX])?[\\dA-Fa-f]+``"

#: ../../library/re.rst:1129
msgid "To extract the filename and numbers from a string like ::"
msgstr "ä»¥ä¸‹ã®ã‚ˆã†ãªæ–‡å­—åˆ—ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«åã¨æ•°å€¤ã‚’æŠ½å‡ºã™ã‚‹ã“ã¨ã‚’è€ƒãˆã¾ã™ ::"

#: ../../library/re.rst:1133
msgid "you would use a :c:func:`scanf` format like ::"
msgstr "ã“ã®ã‚ˆã†ã« :c:func:`scanf` ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ä½¿ã†ã§ã—ã‚‡ã† ::"

#: ../../library/re.rst:1137
msgid "The equivalent regular expression would be ::"
msgstr "åŒç­‰ãªæ­£è¦è¡¨ç¾ã¯ã“ã®ã‚ˆã†ãªã‚‚ã®ã¨ãªã‚Šã¾ã™ ::"

#: ../../library/re.rst:1145
msgid "search() vs. match()"
msgstr "search() vs. match()"

#: ../../library/re.rst:1149
msgid ""
"Python offers two different primitive operations based on regular "
"expressions: :func:`re.match` checks for a match only at the beginning of "
"the string, while :func:`re.search` checks for a match anywhere in the "
"string (this is what Perl does by default)."
msgstr "Python ã¯æ­£è¦è¡¨ç¾ãƒ™ãƒ¼ã‚¹ã® 2 å€‹ã®åŸºæœ¬çš„ãªé–¢æ•°ã€æ–‡å­—åˆ—ã®å…ˆé ­ã§ã®ã¿ã®ãƒãƒƒãƒã‚’ç¢ºèªã™ã‚‹ :func:`re.match` ãŠã‚ˆã³ã€æ–‡å­—åˆ—å†…ã®ä½ç½®ã«ã‹ã‹ã‚ã‚‰ãšãƒãƒƒãƒã‚’ç¢ºèªã™ã‚‹ :func:`re.search` (Perl ã§ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æŒ™å‹•) ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/re.rst:1154
msgid "For example::"
msgstr "ä¾‹ãˆã°::"

#: ../../library/re.rst:1160
msgid ""
"Regular expressions beginning with ``'^'`` can be used with :func:`search` "
"to restrict the match at the beginning of the string::"
msgstr "``'^'`` ã§å§‹ã¾ã‚‹æ­£è¦è¡¨ç¾ã¯ã€ :func:`search` ã«ãŠã„ã¦ã€ãƒãƒƒãƒã‚’æ–‡å­—åˆ—ã®å…ˆé ­ã‹ã‚‰ã«åˆ¶é™ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã—ã¾ã™::"

#: ../../library/re.rst:1168
msgid ""
"Note however that in :const:`MULTILINE` mode :func:`match` only matches at "
"the beginning of the string, whereas using :func:`search` with a regular "
"expression beginning with ``'^'`` will match at the beginning of each line."
msgstr "ãŸã ã—ã€ :const:`MULTILINE` ãƒ¢ãƒ¼ãƒ‰ã® :func:`match` ã§ã¯æ–‡å­—åˆ—ã®å…ˆé ­ã«ã®ã¿ãƒãƒƒãƒã™ã‚‹ã®ã«å¯¾ã—ã€æ­£è¦è¡¨ç¾ã« ``'^'`` ã‚’ä½¿ã£ãŸ :func:`search` ã§ã¯å„è¡Œã®å…ˆé ­ã«ã‚‚ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:1178
msgid "Making a Phonebook"
msgstr "é›»è©±å¸³ã®ä½œæˆ"

#: ../../library/re.rst:1180
msgid ""
":func:`split` splits a string into a list delimited by the passed pattern.  "
"The method is invaluable for converting textual data into data structures "
"that can be easily read and modified by Python as demonstrated in the "
"following example that creates a phonebook."
msgstr ":func:`split` ã¯æ–‡å­—åˆ—ã‚’ä¸ãˆã‚‰ã‚ŒãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã§åˆ†å‰²ã—ã€ãƒªã‚¹ãƒˆã«ã—ã¦è¿”ã—ã¾ã™ã€‚ä¸‹è¨˜ã®ã€é›»è©±å¸³ä½œæˆã®ä¾‹ã®ã‚ˆã†ã«ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿ã‚„ã™ãã—ãŸã‚Šã€ Python ã§ç·¨é›†ã—ãŸã‚Šã—ã‚„ã™ãã™ã‚‹éš›ã«ã€éå¸¸ã«å½¹ã«ç«‹ã¡ã¾ã™ã€‚"

#: ../../library/re.rst:1185
msgid ""
"First, here is the input.  Normally it may come from a file, here we are "
"using triple-quoted string syntax:"
msgstr "æœ€åˆã«ã€å…¥åŠ›ã‚’ç¤ºã—ã¾ã™ã€‚é€šå¸¸ã€ã“ã‚Œã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã®å…¥åŠ›ã«ãªã‚‹ã§ã—ã‚‡ã†ã€‚ã“ã“ã§ã¯ã€3é‡å¼•ç”¨ç¬¦ã®æ›¸å¼ã¨ã—ã¾ã™ :"

#: ../../library/re.rst:1196
msgid ""
"The entries are separated by one or more newlines. Now we convert the string"
" into a list with each nonempty line having its own entry:"
msgstr "å€‹ã€…ã®è¨˜éŒ²ã¯ã€1ã¤ä»¥ä¸Šã®æ”¹è¡Œã§åŒºåˆ‡ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚ã¾ãšã¯ã€æ–‡å­—åˆ—ã‹ã‚‰ç©ºè¡Œã‚’é™¤ãã€è¨˜éŒ²ã”ã¨ã®ãƒªã‚¹ãƒˆã«å¤‰æ›ã—ã¾ã—ã‚‡ã†ã€‚"

#: ../../library/re.rst:1209
msgid ""
"Finally, split each entry into a list with first name, last name, telephone "
"number, and address.  We use the ``maxsplit`` parameter of :func:`split` "
"because the address has spaces, our splitting pattern, in it:"
msgstr "ãã—ã¦ã€å„è¨˜éŒ²ã‚’ã€åã€å§“ã€é›»è©±ç•ªå·ã€ãã—ã¦ã€ä½æ‰€ã«åˆ†å‰²ã—ã¦ãƒªã‚¹ãƒˆã«ã—ã¾ã™ã€‚åˆ†å‰²ã®ãŸã‚ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ä½¿ã£ã¦ã„ã‚‹ç©ºç™½æ–‡å­—ãŒã€ä½æ‰€ã«ã¯å«ã¾ã‚Œã‚‹ãŸã‚ã€ :func:`split` ã® ``maxsplit`` å¼•æ•°ã‚’ä½¿ã„ã¾ã™ã€‚ :"

#: ../../library/re.rst:1222
msgid ""
"The ``:?`` pattern matches the colon after the last name, so that it does "
"not occur in the result list.  With a ``maxsplit`` of ``4``, we could "
"separate the house number from the street name:"
msgstr "ãƒ‘ã‚¿ãƒ¼ãƒ³ã€ ``:?`` ã¯å§“ã«ç¶šãã‚³ãƒ­ãƒ³ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ãã®ãŸã‚ã€ã‚³ãƒ­ãƒ³ã¯åˆ†å‰²çµæœã®ãƒªã‚¹ãƒˆã«ã¯ç¾ã‚Œã¾ã›ã‚“ã€‚ ``maxsplit`` ã‚’ ``4`` ã«ã™ã‚Œã°ã€ãƒã‚¦ã‚¹ãƒŠãƒ³ãƒãƒ¼ã¨ã€ã‚¹ãƒˆãƒªãƒ¼ãƒˆåã‚’åˆ†å‰²ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ :"

#: ../../library/re.rst:1237
msgid "Text Munging"
msgstr "ãƒ†ã‚­ã‚¹ãƒˆã®ç§˜åŒ¿"

#: ../../library/re.rst:1239
msgid ""
":func:`sub` replaces every occurrence of a pattern with a string or the "
"result of a function.  This example demonstrates using :func:`sub` with a "
"function to \"munge\" text, or randomize the order of all the characters in "
"each word of a sentence except for the first and last characters::"
msgstr ":func:`sub` ã¯ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãƒãƒƒãƒã—ãŸéƒ¨åˆ†ã‚’æ–‡å­—åˆ—ã‚„é–¢æ•°ã®è¿”ã‚Šå€¤ã§ç½®ãæ›ãˆã¾ã™ã€‚ã“ã®ä¾‹ã§ã¯ã€\"ç§˜åŒ¿\" ã™ã‚‹æ–‡å­—åˆ—ã«ã€é–¢æ•°ã¨å…±ã« :func:`sub` ã‚’é©ç”¨ã™ã‚‹ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚è¨€ã„æ›ãˆã‚‹ã¨ã€æœ€åˆã¨æœ€å¾Œã®æ–‡å­—ã‚’é™¤ãã€å˜èªä¸­ã®æ–‡å­—ã®ä½ç½®ã‚’ãƒ©ãƒ³ãƒ€ãƒ åŒ–ã—ã¾ã™ã€‚ ::"

#: ../../library/re.rst:1256
msgid "Finding all Adverbs"
msgstr "å…¨ã¦ã®å‰¯è©ã‚’è¦‹ã¤ã‘ã‚‹"

#: ../../library/re.rst:1258
msgid ""
":func:`findall` matches *all* occurrences of a pattern, not just the first "
"one as :func:`search` does.  For example, if a writer wanted to find all of "
"the adverbs in some text, they might use :func:`findall` in the following "
"manner:"
msgstr ""

#: ../../library/re.rst:1269
msgid "Finding all Adverbs and their Positions"
msgstr "å…¨ã¦ã®å‰¯è©ã¨ã€ãã®ä½ç½®ã‚’è¦‹ã¤ã‘ã‚‹"

#: ../../library/re.rst:1271
msgid ""
"If one wants more information about all matches of a pattern than the "
"matched text, :func:`finditer` is useful as it provides instances of "
":class:`MatchObject` instead of strings.  Continuing with the previous "
"example, if a writer wanted to find all of the adverbs *and their positions*"
" in some text, they would use :func:`finditer` in the following manner:"
msgstr ""

#: ../../library/re.rst:1285
msgid "Raw String Notation"
msgstr "Raw Stringè¨˜æ³•"

#: ../../library/re.rst:1287
msgid ""
"Raw string notation (``r\"text\"``) keeps regular expressions sane.  Without"
" it, every backslash (``'\\'``) in a regular expression would have to be "
"prefixed with another one to escape it.  For example, the two following "
"lines of code are functionally identical:"
msgstr "Raw stringè¨˜æ³• (``r\"text\"``) ã«ã‚ˆã‚Šã€ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ (``'\\'``) ã‚’å€‹ã€…ã«ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã§ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã™ã‚‹ã“ã¨ãªã—ã«ã€æ­£è¦è¡¨ç¾ã‚’æ­£å¸¸ãªçŠ¶æ…‹ã«ä¿ã¡ã¾ã™ã€‚ä¾‹ãˆã°ã€ä¸‹è¨˜ã®2ã¤ã®ã‚³ãƒ¼ãƒ‰ã¯æ©Ÿèƒ½çš„ã«ç­‰ä¾¡ã§ã™ã€‚ :"

#: ../../library/re.rst:1297
msgid ""
"When one wants to match a literal backslash, it must be escaped in the "
"regular expression.  With raw string notation, this means ``r\"\\\\\"``.  "
"Without raw string notation, one must use ``\"\\\\\\\\\"``, making the "
"following lines of code functionally identical:"
msgstr "æ–‡å­—é€šã‚Šã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã«ãƒãƒƒãƒã•ã›ãŸã„ãªã‚‰ã€æ­£è¦è¡¨ç¾ä¸­ã§ã¯ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ Raw stringè¨˜æ³•ã§ã¯ã€ ``r\"\\\\\"`` ã¨ã„ã†ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ Raw stringè¨˜æ³•ã‚’ç”¨ã„ãªã„å ´åˆã€ ``\"\\\\\\\\\"`` ã¨ã—ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ä¸‹è¨˜ã®ã‚³ãƒ¼ãƒ‰ã¯æ©Ÿèƒ½çš„ã«ç­‰ä¾¡ã§ã™ã€‚ :"
