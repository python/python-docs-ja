# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Masato HASHIMOTO <cabezon.hashimoto@gmail.com>, 2017
# Nozomu Kaneko <nozom.kaneko@gmail.com>, 2017
# Shun Sakurai, 2017
# Naoki INADA <songofacandy@gmail.com>, 2017
# Akihiro Uchida <uchida@turbare.net>, 2017
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2017
# Arihiro TAKASE, 2018
# tomoğŸ§, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-11-10 09:42+0900\n"
"PO-Revision-Date: 2017-02-16 23:24+0000\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/re.rst:2
msgid ":mod:`re` --- Regular expression operations"
msgstr ":mod:`re` --- æ­£è¦è¡¨ç¾æ“ä½œ"

#: ../../library/re.rst:10
msgid "**Source code:** :source:`Lib/re.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/re.py`"

#: ../../library/re.rst:14
msgid ""
"This module provides regular expression matching operations similar to those"
" found in Perl."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ Perl ã«è¦‹ã‚‰ã‚Œã‚‹æ­£è¦è¡¨ç¾ãƒãƒƒãƒãƒ³ã‚°æ“ä½œã¨åŒæ§˜ã®ã‚‚ã®ã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../library/re.rst:17
msgid ""
"Both patterns and strings to be searched can be Unicode strings "
"(:class:`str`) as well as 8-bit strings (:class:`bytes`). However, Unicode "
"strings and 8-bit strings cannot be mixed: that is, you cannot match a "
"Unicode string with a byte pattern or vice-versa; similarly, when asking for"
" a substitution, the replacement string must be of the same type as both the"
" pattern and the search string."
msgstr ""
"ãƒ‘ã‚¿ãƒ¼ãƒ³ãŠã‚ˆã³æ¤œç´¢ã•ã‚Œã‚‹æ–‡å­—åˆ—ã«ã¯ã€Unicode æ–‡å­—åˆ— (:class:`str`) ã‚„ 8 ãƒ“ãƒƒãƒˆæ–‡å­—åˆ— (:class:`bytes`) "
"ã‚’ä½¿ã„ã¾ã™ã€‚ãŸã ã—ã€Unicode æ–‡å­—åˆ—ã¨ 8 ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã®æ··åœ¨ã¯ã§ãã¾ã›ã‚“ã€‚ã¤ã¾ã‚Šã€Unicode "
"æ–‡å­—åˆ—ã«ãƒã‚¤ãƒˆåˆ—ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ãƒãƒƒãƒãƒ³ã‚°ã—ãŸã‚Šã€ãã®é€†ã¯ã§ãã¾ã›ã‚“ã€‚åŒæ§˜ã«ã€ç½®æ›æ™‚ã®ç½®æ›æ–‡å­—åˆ—ã¯ãƒ‘ã‚¿ãƒ¼ãƒ³ãŠã‚ˆã³æ¤œç´¢æ–‡å­—åˆ—ã®ä¸¡æ–¹ã¨åŒã˜å‹ã§ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:24
msgid ""
"Regular expressions use the backslash character (``'\\'``) to indicate "
"special forms or to allow special characters to be used without invoking "
"their special meaning.  This collides with Python's usage of the same "
"character for the same purpose in string literals; for example, to match a "
"literal backslash, one might have to write ``'\\\\\\\\'`` as the pattern "
"string, because the regular expression must be ``\\\\``, and each backslash "
"must be expressed as ``\\\\`` inside a regular Python string literal."
msgstr ""
"æ­£è¦è¡¨ç¾ã§ã¯ã€ç‰¹æ®Šãªå½¢å¼ã‚’è¡¨ã™ãŸã‚ã‚„ã€ç‰¹æ®Šæ–‡å­—ã‚’ãã®ç‰¹æ®Šãªæ„å‘³ã‚’ç™ºå‹•ã•ã›ãšä½¿ã†ãŸã‚ã«ã€ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥æ–‡å­— (``'\\'``) "
"ã‚’ä½¿ã„ã¾ã™ã€‚ã“ã†ã—ãŸãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã®ä½¿ã„æ–¹ã¯ã€ Python "
"ã®æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã«ãŠã‘ã‚‹åŒã˜æ–‡å­—ã®ä½¿ã„æ–¹ã¨è¡çªã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ãƒªãƒ†ãƒ©ãƒ«ã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã«ãƒãƒƒãƒã•ã›ã‚‹ã«ã¯ã€ãƒ‘ã‚¿ãƒ¼ãƒ³æ–‡å­—åˆ—ã¨ã—ã¦ "
"``'\\\\\\\\'`` ã¨æ›¸ã‹ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãªãœãªã‚‰ã€æ­£è¦è¡¨ç¾ã¯ ``\\\\`` "
"ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„ã†ãˆã€ãã‚Œãã‚Œã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã¯æ¨™æº–ã® Python æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã§ ``\\\\`` ã¨è¡¨ç¾ã›ã­ã°ãªã‚‰ãªã„ã‹ã‚‰ã§ã™ã€‚"

#: ../../library/re.rst:33
msgid ""
"The solution is to use Python's raw string notation for regular expression "
"patterns; backslashes are not handled in any special way in a string literal"
" prefixed with ``'r'``.  So ``r\"\\n\"`` is a two-character string "
"containing ``'\\'`` and ``'n'``, while ``\"\\n\"`` is a one-character string"
" containing a newline.  Usually patterns will be expressed in Python code "
"using this raw string notation."
msgstr ""
"ã“ã‚Œã‚’è§£æ±ºã™ã‚‹ã«ã¯ã€æ­£è¦è¡¨ç¾ãƒ‘ã‚¿ãƒ¼ãƒ³ã« Python ã® raw æ–‡å­—åˆ—è¨˜æ³•ã‚’ä½¿ã„ã¾ã™ã€‚ ``'r'`` "
"ã‚’å‰ç½®ã—ãŸæ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«å†…ã§ã¯ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ãŒç‰¹åˆ¥æ‰±ã„ã•ã‚Œã¾ã›ã‚“ã€‚å¾“ã£ã¦ ``\"\\n\"`` ãŒæ”¹è¡Œä¸€æ–‡å­—ã‹ã‚‰ãªã‚‹æ–‡å­—åˆ—ã§ã‚ã‚‹ã®ã«å¯¾ã—ã¦ã€ "
"``r\"\\n\"`` ã¯ ``'\\'`` ã¨ ``'n'`` ã®äºŒæ–‡å­—ã‹ã‚‰ãªã‚‹æ–‡å­—åˆ—ã§ã™ã€‚é€šå¸¸ã€ Python ã‚³ãƒ¼ãƒ‰ä¸­ã§ã¯ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ã“ã® "
"raw æ–‡å­—åˆ—è¨˜æ³•ã‚’ä½¿ã£ã¦è¡¨ç¾ã—ã¾ã™ã€‚"

#: ../../library/re.rst:40
msgid ""
"It is important to note that most regular expression operations are "
"available as module-level functions and methods on :ref:`compiled regular "
"expressions <re-objects>`.  The functions are shortcuts that don't require "
"you to compile a regex object first, but miss some fine-tuning parameters."
msgstr ""
"é‡è¦ãªã“ã¨ã¨ã—ã¦ã€å¤§æŠµã®æ­£è¦è¡¨ç¾æ“ä½œã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«ã®é–¢æ•°ã¨ã—ã¦ã‚‚ã€ :ref:`ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿æ­£è¦è¡¨ç¾ <re-objects>` "
"ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã—ã¦ã‚‚åˆ©ç”¨ã§ãã¾ã™ã€‚é–¢æ•°ã¯æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‰ã‚‚ã£ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹å¿…è¦ãŒãªã„è¿‘é“ã§ã™ãŒã€å¾®èª¿æ•´ã®ãŸã‚ã®å¤‰æ•°ãŒæ¸›ã‚Šã¾ã™ã€‚"

#: ../../library/re.rst:48
msgid ""
"The third-party `regex <https://pypi.org/project/regex/>`_ module, which has"
" an API compatible with the standard library :mod:`re` module, but offers "
"additional functionality and a more thorough Unicode support."
msgstr ""
"ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ã® `regex <https://pypi.org/project/regex/>`_ ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã® "
":mod:`re` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨äº’æ›ãª API ã‚’æŒã¡ãªãŒã‚‰ã€è¿½åŠ ã®æ©Ÿèƒ½ã¨ã‚ˆã‚Šå¾¹åº•ã—ãŸ Unicode ã‚µãƒãƒ¼ãƒˆã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../library/re.rst:56
msgid "Regular Expression Syntax"
msgstr "æ­£è¦è¡¨ç¾ã®ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹"

#: ../../library/re.rst:58
msgid ""
"A regular expression (or RE) specifies a set of strings that matches it; the"
" functions in this module let you check if a particular string matches a "
"given regular expression (or if a given regular expression matches a "
"particular string, which comes down to the same thing)."
msgstr ""
"æ­£è¦è¡¨ç¾ (ã¾ãŸã¯ RE) ã¯ã€ãã®è¡¨ç¾ã«ãƒãƒƒãƒ (match) "
"ã™ã‚‹æ–‡å­—åˆ—ã®é›†åˆã‚’æŒ‡å®šã—ã¾ã™ã€‚ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®é–¢æ•°ã‚’ä½¿ãˆã°ã€ã‚ã‚‹æ–‡å­—åˆ—ãŒä¸ãˆã‚‰ã‚ŒãŸæ­£è¦è¡¨ç¾ã«ãƒãƒƒãƒã™ã‚‹ã‹ "
"(ã¾ãŸã¯ã€ä¸ãˆã‚‰ã‚ŒãŸæ­£è¦è¡¨ç¾ãŒã‚ã‚‹æ–‡å­—åˆ—ã«ãƒãƒƒãƒã™ã‚‹ã‹ã€ã¨è¨€ã„æ›ãˆã¦ã‚‚åŒã˜ã“ã¨ã«ãªã‚Šã¾ã™) ã‚’æ¤œæŸ»ã§ãã¾ã™ã€‚"

#: ../../library/re.rst:63
msgid ""
"Regular expressions can be concatenated to form new regular expressions; if "
"*A* and *B* are both regular expressions, then *AB* is also a regular "
"expression. In general, if a string *p* matches *A* and another string *q* "
"matches *B*, the string *pq* will match AB.  This holds unless *A* or *B* "
"contain low precedence operations; boundary conditions between *A* and *B*; "
"or have numbered group references.  Thus, complex expressions can easily be "
"constructed from simpler primitive expressions like the ones described here."
"  For details of the theory and implementation of regular expressions, "
"consult the Friedl book [Frie09]_, or almost any textbook about compiler "
"construction."
msgstr ""
"æ­£è¦è¡¨ç¾ã‚’é€£çµã™ã‚‹ã“ã¨ã§æ–°ã—ã„æ­£è¦è¡¨ç¾ã‚’ä½œã‚Œã¾ã™ã€‚*A* ã¨ *B* ãŒã¨ã‚‚ã«æ­£è¦è¡¨ç¾ã§ã‚ã‚Œã° *AB* ã‚‚æ­£è¦è¡¨ç¾ã§ã™ã€‚ä¸€èˆ¬çš„ã«ã€ã‚ã‚‹æ–‡å­—åˆ— *p* "
"ãŒ *A* ã«ãƒãƒƒãƒã—ã€åˆ¥ã®æ–‡å­—åˆ— *q* ãŒ *B* ã«ãƒãƒƒãƒã™ã‚‹ãªã‚‰ã€æ–‡å­—åˆ— *pq* ã¯ AB ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ãŸã ã—ã€ *A* ã¾ãŸã¯ *B* "
"ã«å„ªå…ˆåº¦ã®ä½ã„æ¼”ç®—ãŒå«ã¾ã‚Œã‚‹å ´åˆã‚„ã€ *A* ã¨ *B* "
"ã¨ã®é–“ã«å¢ƒç•Œæ¡ä»¶ãŒã‚ã‚‹å ´åˆã‚„ã€ç•ªå·ä»˜ã‘ã•ã‚ŒãŸã‚°ãƒ«ãƒ¼ãƒ—å‚ç…§ã‚’ã—ã¦ã„ã‚‹å ´åˆã€ã‚’é™¤ãã¾ã™ã€‚ã“ã†ã—ã¦ã€ã“ã“ã§è¿°ã¹ã‚‹ã‚ˆã†ãªç°¡å˜ãªåŸºæœ¬è¡¨ç¾ã‹ã‚‰ã€è¤‡é›‘ãªè¡¨ç¾ã‚’å®¹æ˜“ã«æ§‹ç¯‰ã§ãã¾ã™ã€‚æ­£è¦è¡¨ç¾ã«é–¢ã™ã‚‹ç†è«–ã¨å®Ÿè£…ã®è©³ç´°ã«ã¤ã„ã¦ã¯"
" Friedl æœ¬ [Frie09]_ ã‹ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®æ§‹ç¯‰ã«é–¢ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/re.rst:73
msgid ""
"A brief explanation of the format of regular expressions follows.  For "
"further information and a gentler presentation, consult the :ref:`regex-"
"howto`."
msgstr "ä»¥ä¸‹ã§æ­£è¦è¡¨ç¾ã®å½¢å¼ã‚’ç°¡å˜ã«èª¬æ˜ã—ã¾ã™ã€‚è©³ç´°ãªæƒ…å ±ã‚„ã‚„ã•ã—ã„èª¬æ˜ã¯ã€ :ref:`regex-howto` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/re.rst:76
msgid ""
"Regular expressions can contain both special and ordinary characters. Most "
"ordinary characters, like ``'A'``, ``'a'``, or ``'0'``, are the simplest "
"regular expressions; they simply match themselves.  You can concatenate "
"ordinary characters, so ``last`` matches the string ``'last'``.  (In the "
"rest of this section, we'll write RE's in ``this special style``, usually "
"without quotes, and strings to be matched ``'in single quotes'``.)"
msgstr ""
"æ­£è¦è¡¨ç¾ã«ã¯ã€ç‰¹æ®Šæ–‡å­—ã¨é€šå¸¸æ–‡å­—ã®ä¸¡æ–¹ã‚’å«ã‚ã‚‰ã‚Œã¾ã™ã€‚ ``'A'`` ã€ ``'a'`` ã€ã¾ãŸã¯ ``'0'`` "
"ã®ã‚ˆã†ãªã»ã¨ã‚“ã©ã®é€šå¸¸æ–‡å­—ã¯ã€æœ€ã‚‚å˜ç´”ãªæ­£è¦è¡¨ç¾ã§ã™ã€‚ã“ã‚Œã¯å˜ç´”ã«ã€ãã®æ–‡å­—è‡ªä½“ã«ãƒãƒƒãƒã—ã¾ã™ã€‚é€šå¸¸æ–‡å­—ã¯é€£çµã§ãã‚‹ã®ã§ã€ ``last`` ã¯æ–‡å­—åˆ— "
"``'last'`` ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ (ã“ã®ç¯€ã§ã¯ä»¥é™ã€æ­£è¦è¡¨ç¾ã¯ä¸€èˆ¬ã«ã‚¯ã‚ªãƒ¼ãƒˆã‚’ä½¿ã‚ãš ``ã“ã®ç‰¹æ®Šã‚¹ã‚¿ã‚¤ãƒ«ã§`` è¡¨è¨˜ã—ã€ãƒãƒƒãƒå¯¾è±¡ã®æ–‡å­—åˆ—ã¯ã€ "
"``'ã‚·ãƒ³ã‚°ãƒ«ã‚¯ã‚ªãƒ¼ãƒˆã§æ‹¬ã£ã¦'`` è¡¨è¨˜ã—ã¾ã™ã€‚)"

#: ../../library/re.rst:83
msgid ""
"Some characters, like ``'|'`` or ``'('``, are special. Special characters "
"either stand for classes of ordinary characters, or affect how the regular "
"expressions around them are interpreted."
msgstr ""
"``'|'`` ã‚„ ``'('`` ã¨ã„ã£ãŸã„ãã¤ã‹ã®æ–‡å­—ã¯ç‰¹æ®Šã§ã™ã€‚ç‰¹æ®Šæ–‡å­—ã¯é€šå¸¸æ–‡å­—ã®ç¨®åˆ¥ã‚’è¡¨ã—ãŸã‚Šã€å‘¨è¾ºã®é€šå¸¸æ–‡å­—ã«å¯¾ã™ã‚‹è§£é‡ˆæ–¹æ³•ã«å½±éŸ¿ã—ã¾ã™ã€‚"

#: ../../library/re.rst:87
msgid ""
"Repetition qualifiers (``*``, ``+``, ``?``, ``{m,n}``, etc) cannot be "
"directly nested. This avoids ambiguity with the non-greedy modifier suffix "
"``?``, and with other modifiers in other implementations. To apply a second "
"repetition to an inner repetition, parentheses may be used. For example, the"
" expression ``(?:a{6})*`` matches any multiple of six ``'a'`` characters."
msgstr ""
"ç¹°ã‚Šè¿”ã—ã®ä¿®é£¾å­ (``*``ã€ ``+``ã€ ``?``ã€ ``{m,n}`` ãªã©) ã¯ç›´æ¥å…¥ã‚Œå­ã«ã¯ã§ãã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã€éè²ªæ¬²ãªä¿®é£¾å­ã®æ¥å°¾è¾ "
"``?`` ã‚„ä»–ã®å®Ÿè£…ã§ã®ä»–ã®ä¿®é£¾å­ã¨ã®æ›–æ˜§ã•ã‚’å›é¿ã—ã¾ã™ã€‚å†…å´ã§ç¹°ã‚Šè¿”ã—ãŸã‚‚ã®ã‚’ã•ã‚‰ã«ç¹°ã‚Šè¿”ã™ã«ã¯ã€ä¸¸æ‹¬å¼§ãŒä½¿ãˆã¾ã™ã€‚ä¾‹ãˆã°ã€æ­£è¦è¡¨ç¾ "
"``(?:a{6})*`` ã¯ 6 ã®å€æ•°å€‹ã® ``'a'`` æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:94
msgid "The special characters are:"
msgstr "ç‰¹æ®Šæ–‡å­—ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™:"

#: ../../library/re.rst:101 ../../library/re.rst:1398
msgid "``.``"
msgstr "``.``"

#: ../../library/re.rst:99
msgid ""
"(Dot.)  In the default mode, this matches any character except a newline.  "
"If the :const:`DOTALL` flag has been specified, this matches any character "
"including a newline."
msgstr ""
"(ãƒ‰ãƒƒãƒˆ) ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ¢ãƒ¼ãƒ‰ã§ã¯æ”¹è¡Œä»¥å¤–ã®ä»»æ„ã®æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ :const:`DOTALL` "
"ãƒ•ãƒ©ã‚°ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚Œã°æ”¹è¡Œã‚‚å«ã‚€å…¨ã¦ã®æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:107
msgid "``^``"
msgstr "``^``"

#: ../../library/re.rst:106
msgid ""
"(Caret.)  Matches the start of the string, and in :const:`MULTILINE` mode "
"also matches immediately after each newline."
msgstr "(ã‚­ãƒ£ãƒ¬ãƒƒãƒˆ) æ–‡å­—åˆ—ã®å…ˆé ­ã«ãƒãƒƒãƒã—ã€ :const:`MULTILINE` ãƒ¢ãƒ¼ãƒ‰ã§ã¯å„æ”¹è¡Œã®ç›´å¾Œã«ã‚‚ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:118
msgid "``$``"
msgstr "``$``"

#: ../../library/re.rst:112
msgid ""
"Matches the end of the string or just before the newline at the end of the "
"string, and in :const:`MULTILINE` mode also matches before a newline.  "
"``foo`` matches both 'foo' and 'foobar', while the regular expression "
"``foo$`` matches only 'foo'.  More interestingly, searching for ``foo.$`` in"
" ``'foo1\\nfoo2\\n'`` matches 'foo2' normally, but 'foo1' in "
":const:`MULTILINE` mode; searching for a single ``$`` in ``'foo\\n'`` will "
"find two (empty) matches: one just before the newline, and one at the end of"
" the string."
msgstr ""
"æ–‡å­—åˆ—ã®æœ«å°¾ã€ã‚ã‚‹ã„ã¯æ–‡å­—åˆ—ã®æœ«å°¾ã®æ”¹è¡Œã®ç›´å‰ã«ãƒãƒƒãƒã—ã€ :const:`MULTILINE` ãƒ¢ãƒ¼ãƒ‰ã§ã¯æ”¹è¡Œã®å‰ã«ã‚‚ãƒãƒƒãƒã—ã¾ã™ã€‚ ``foo`` "
"ã¯ 'foo' ã¨ 'foobar' ã®ä¸¡æ–¹ã«ãƒãƒƒãƒã—ã¾ã™ãŒã€æ­£è¦è¡¨ç¾ ``foo$`` ã¯ 'foo' ã ã‘ã«ãƒãƒƒãƒã—ã¾ã™ã€‚èˆˆå‘³æ·±ã„ã“ã¨ã«ã€ "
"``'foo1\\nfoo2\\n'`` ã‚’ ``foo.$`` ã§æ¤œç´¢ã—ãŸå ´åˆã€é€šå¸¸ã¯ 'foo2' ã ã‘ã«ãƒãƒƒãƒã—ã¾ã™ãŒã€ "
":const:`MULTILINE` ãƒ¢ãƒ¼ãƒ‰ã§ã¯ 'foo1' ã«ã‚‚ãƒãƒƒãƒã—ã¾ã™ã€‚ ``$`` ã ã‘ã§ ``'foo\\n'`` ã‚’æ¤œç´¢ã—ãŸå ´åˆã€2 "
"ã¤ã® (ç©ºã®) ãƒãƒƒãƒã‚’è¦‹ã¤ã‘ã¾ã™: 1ã¤ã¯æ”¹è¡Œã®ç›´å‰ã§ã€ã‚‚ã†1ã¤ã¯æ–‡å­—åˆ—ã®æœ«å°¾ã§ã™ã€‚"

#: ../../library/re.rst:125
msgid "``*``"
msgstr "``*``"

#: ../../library/re.rst:123
msgid ""
"Causes the resulting RE to match 0 or more repetitions of the preceding RE, "
"as many repetitions as are possible.  ``ab*`` will match 'a', 'ab', or 'a' "
"followed by any number of 'b's."
msgstr ""
"ç›´å‰ã®æ­£è¦è¡¨ç¾ã‚’ 0 å›ä»¥ä¸Šã€ã§ãã‚‹ã ã‘å¤šãç¹°ã‚Šè¿”ã—ãŸã‚‚ã®ã«ãƒãƒƒãƒã•ã›ã‚‹çµæœã®æ­£è¦è¡¨ç¾ã«ã—ã¾ã™ã€‚ä¾‹ãˆã° ``ab*`` ã¯ 'a'ã€'ab'ã€ã¾ãŸã¯ "
"'a' ã«ä»»æ„å€‹æ•°ã® 'b' ã‚’ç¶šã‘ãŸã‚‚ã®ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:132
msgid "``+``"
msgstr "``+``"

#: ../../library/re.rst:130
msgid ""
"Causes the resulting RE to match 1 or more repetitions of the preceding RE. "
"``ab+`` will match 'a' followed by any non-zero number of 'b's; it will not "
"match just 'a'."
msgstr ""
"ç›´å‰ã®æ­£è¦è¡¨ç¾ã‚’ 1 å›ä»¥ä¸Šç¹°ã‚Šè¿”ã—ãŸã‚‚ã®ã«ãƒãƒƒãƒã•ã›ã‚‹çµæœã®æ­£è¦è¡¨ç¾ã«ã—ã¾ã™ã€‚ä¾‹ãˆã° ``ab+`` ã¯ 'a' ã« 1 ã¤ä»¥ä¸Šã® 'b' "
"ãŒç¶šã„ãŸã‚‚ã®ã«ãƒãƒƒãƒã—ã€å˜ãªã‚‹ 'a' ã«ã¯ãƒãƒƒãƒã—ã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:138
msgid "``?``"
msgstr "``?``"

#: ../../library/re.rst:137
msgid ""
"Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. "
"``ab?`` will match either 'a' or 'ab'."
msgstr ""
"ç›´å‰ã®æ­£è¦è¡¨ç¾ã‚’ 0 å›ã‹ 1 å›ç¹°ã‚Šè¿”ã—ãŸã‚‚ã®ã«ãƒãƒƒãƒã•ã›ã‚‹çµæœã®æ­£è¦è¡¨ç¾ã«ã—ã¾ã™ã€‚ä¾‹ãˆã° ``ab?`` ã¯ 'a' ã‚ã‚‹ã„ã¯ 'ab' "
"ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:152
msgid "``*?``, ``+?``, ``??``"
msgstr "``*?``, ``+?``, ``??``"

#: ../../library/re.rst:146
msgid ""
"The ``'*'``, ``'+'``, and ``'?'`` qualifiers are all :dfn:`greedy`; they "
"match as much text as possible.  Sometimes this behaviour isn't desired; if "
"the RE ``<.*>`` is matched against ``'<a> b <c>'``, it will match the entire"
" string, and not just ``'<a>'``.  Adding ``?`` after the qualifier makes it "
"perform the match in :dfn:`non-greedy` or :dfn:`minimal` fashion; as *few* "
"characters as possible will be matched.  Using the RE ``<.*?>`` will match "
"only ``'<a>'``."
msgstr ""
"``'*'`` ã€ ``'+'`` ã€ãŠã‚ˆã³ ``'?'`` ä¿®é£¾å­ã¯å…¨ã¦ :dfn:`è²ªæ¬² (greedy)` "
"ãƒãƒƒãƒã§ã€ã§ãã‚‹ã ã‘å¤šãã®ãƒ†ã‚­ã‚¹ãƒˆã«ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã®æŒ™å‹•ãŒæœ›ã¾ã—ããªã„æ™‚ã‚‚ã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°æ­£è¦è¡¨ç¾ ``<.*>`` ãŒ ``'<a> b "
"<c>'`` ã«å¯¾ã—ã¦ãƒãƒƒãƒã•ã‚Œã‚‹ã¨ã€ ``'<a>'`` ã ã‘ã§ãªãæ–‡å­—åˆ—å…¨ä½“ã«ãƒãƒƒãƒã—ã¦ã—ã¾ã„ã¾ã™ã€‚ä¿®é£¾å­ã®å¾Œã« ``?`` ã‚’è¿½åŠ ã™ã‚‹ã¨ã€ "
":dfn:`éè²ªæ¬² (non-greedy)` ã‚ã‚‹ã„ã¯ :dfn:`æœ€å° (minimal)` ã®ãƒãƒƒãƒãŒè¡Œã‚ã‚Œã€ã§ãã‚‹ã ã‘ *å°‘ãªã„* "
"æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚æ­£è¦è¡¨ç¾ ``<.*?>`` ã‚’ä½¿ã†ã¨ ``'<a>'`` ã ã‘ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:160
msgid "``{m}``"
msgstr "``{m}``"

#: ../../library/re.rst:158
msgid ""
"Specifies that exactly *m* copies of the previous RE should be matched; "
"fewer matches cause the entire RE not to match.  For example, ``a{6}`` will "
"match exactly six ``'a'`` characters, but not five."
msgstr ""
"ç›´å‰ã®æ­£è¦è¡¨ç¾ã‚’ã¡ã‚‡ã†ã© *m* å›ç¹°ã‚Šè¿”ã—ãŸã‚‚ã®ã«ãƒãƒƒãƒã•ã›ã‚‹ã‚ˆã†æŒ‡å®šã—ã¾ã™ã€‚ãã‚Œã‚ˆã‚Šå°‘ãªã„ãƒãƒƒãƒã§ã¯æ­£è¦è¡¨ç¾å…¨ä½“ãŒãƒãƒƒãƒã—ã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€ "
"``a{6}`` ã¯ 6 å€‹ã¡ã‚‡ã†ã©ã® ``'a'`` æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ãŒã€ 5 å€‹ã§ã¯ãƒãƒƒãƒã—ã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:169
msgid "``{m,n}``"
msgstr "``{m,n}``"

#: ../../library/re.rst:163
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible.  For "
"example, ``a{3,5}`` will match from 3 to 5 ``'a'`` characters.  Omitting *m*"
" specifies a lower bound of zero,  and omitting *n* specifies an infinite "
"upper bound.  As an example, ``a{4,}b`` will match ``'aaaab'`` or a thousand"
" ``'a'`` characters followed by a ``'b'``, but not ``'aaab'``. The comma may"
" not be omitted or the modifier would be confused with the previously "
"described form."
msgstr ""
"ç›´å‰ã®æ­£è¦è¡¨ç¾ã‚’ *m* å›ã‹ã‚‰ *n* å›ã€ã§ãã‚‹ã ã‘å¤šãç¹°ã‚Šè¿”ã—ãŸã‚‚ã®ã«ãƒãƒƒãƒã•ã›ã‚‹çµæœã®æ­£è¦è¡¨ç¾ã«ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€``a{3,5}`` ã¯ã€3 "
"å€‹ã‹ã‚‰ 5 å€‹ã® ``'a'`` æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚*m* ã‚’çœç•¥ã™ã‚‹ã¨ä¸‹é™ã¯ 0 ã«æŒ‡å®šã•ã‚Œã€*n* "
"ã‚’çœç•¥ã™ã‚‹ã¨ä¸Šé™ã¯ç„¡é™ã«æŒ‡å®šã•ã‚Œã¾ã™ã€‚ä¾‹ã¨ã—ã¦ã€ ``a{4,}b`` ã¯ ``'aaaab'`` ã‚„ã€1,000 å€‹ã® ``'a'`` æ–‡å­—ã« "
"``'b'`` ãŒç¶šã„ãŸã‚‚ã®ã«ãƒãƒƒãƒã—ã¾ã™ãŒã€``'aaab'`` "
"ã«ã¯ãƒãƒƒãƒã—ã¾ã›ã‚“ã€‚ã‚³ãƒ³ãƒã¯çœç•¥ã§ãã¾ã›ã‚“ã€çœç•¥ã™ã‚‹ã¨ä¿®é£¾å­ãŒä¸Šã§è¿°ã¹ãŸå½¢å¼ã¨æ··åŒã•ã‚Œã¦ã—ã¾ã†ã‹ã‚‰ã§ã™ã€‚"

#: ../../library/re.rst:176
msgid "``{m,n}?``"
msgstr "``{m,n}?``"

#: ../../library/re.rst:172
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as *few* repetitions as possible.  This is"
" the non-greedy version of the previous qualifier.  For example, on the "
"6-character string ``'aaaaaa'``, ``a{3,5}`` will match 5 ``'a'`` characters,"
" while ``a{3,5}?`` will only match 3 characters."
msgstr ""
"çµæœã®æ­£è¦è¡¨ç¾ã¯ã€å‰ã«ã‚ã‚‹æ­£è¦è¡¨ç¾ã‚’ã€*m* å›ã‹ã‚‰ *n* å›ã¾ã§ç¹°ã‚Šè¿”ã—ãŸã‚‚ã®ã«ãƒãƒƒãƒã—ã€ã§ãã‚‹ã ã‘ *å°‘ãªã* "
"ç¹°ã‚Šè¿”ã—ãŸã‚‚ã®ã«ãƒãƒƒãƒã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã‚Œã¯ã€å‰ã®ä¿®é£¾å­ã®éè²ªæ¬²ç‰ˆã§ã™ã€‚ä¾‹ãˆã°ã€ 6 æ–‡å­—æ–‡å­—åˆ— ``'aaaaaa'`` ã§ã¯ã€ "
"``a{3,5}`` ã¯ã€5 å€‹ã® ``'a'`` æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ãŒã€ ``a{3,5}?`` ã¯ 3 å€‹ã®æ–‡å­—ã«ãƒãƒƒãƒã™ã‚‹ã ã‘ã§ã™ã€‚"

#: ../../library/re.rst:191
msgid "``\\``"
msgstr "``\\``"

#: ../../library/re.rst:181
msgid ""
"Either escapes special characters (permitting you to match characters like "
"``'*'``, ``'?'``, and so forth), or signals a special sequence; special "
"sequences are discussed below."
msgstr ""
"ç‰¹æ®Šæ–‡å­—ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ— ( ``'*'`` ã‚„ ``'?'`` ãªã©ã®æ–‡å­—ã«ãƒãƒƒãƒã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹) "
"ã—ã€ã¾ãŸã¯ç‰¹æ®Šã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’åˆå›³ã—ã¾ã™ã€‚ç‰¹æ®Šã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯å¾Œã§è­°è«–ã—ã¾ã™ã€‚"

#: ../../library/re.rst:185
msgid ""
"If you're not using a raw string to express the pattern, remember that "
"Python also uses the backslash as an escape sequence in string literals; if "
"the escape sequence isn't recognized by Python's parser, the backslash and "
"subsequent character are included in the resulting string.  However, if "
"Python would recognize the resulting sequence, the backslash should be "
"repeated twice.  This is complicated and hard to understand, so it's highly "
"recommended that you use raw strings for all but the simplest expressions."
msgstr ""
"ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è¡¨ç¾ã™ã‚‹ã®ã« raw æ–‡å­—åˆ—ã‚’ä½¿ã£ã¦ã„ãªã„ã®ã§ã‚ã‚Œã°ã€ Python "
"ã‚‚ã‚‚ã¾ãŸã€ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã§ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¨ã—ã¦ä½¿ã†ã“ã¨ã‚’æ€ã„å‡ºã—ã¦ä¸‹ã•ã„ã€‚ãã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ Python "
"ã®ãƒ‘ãƒ¼ã‚¶ãŒèªè­˜ã—ãªã„ãªã‚‰ã€ãã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã¨ãã‚Œã«ç¶šãæ–‡å­—ãŒçµæœã®æ–‡å­—åˆ—ã«å«ã¾ã‚Œã¾ã™ã€‚ã—ã‹ã—ã€Python "
"ãŒçµæœã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’èªè­˜ã™ã‚‹ãªã‚‰ã€ãã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã¯ 2 å›ç¹°ã‚Šè¿”ã•ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€‚ã“ã‚Œã¯è¤‡é›‘ã§ç†è§£ã—ã«ãã„ã®ã§ã€ã”ãå˜ç´”ãªè¡¨ç¾ä»¥å¤–ã¯ã€å…¨ã¦ "
"raw æ–‡å­—åˆ—ã‚’ä½¿ã†ã“ã¨ã‚’å¼·ãæ¨å¥¨ã—ã¾ã™ã€‚"

#: ../../library/re.rst:251
msgid "``[]``"
msgstr "``[]``"

#: ../../library/re.rst:197
msgid "Used to indicate a set of characters.  In a set:"
msgstr "æ–‡å­—ã®é›†åˆã‚’æŒ‡å®šã™ã‚‹ã®ã«ä½¿ã„ã¾ã™ã€‚é›†åˆã®ä¸­ã§ã¯:"

#: ../../library/re.rst:199
msgid ""
"Characters can be listed individually, e.g. ``[amk]`` will match ``'a'``, "
"``'m'``, or ``'k'``."
msgstr "æ–‡å­—ã‚’å€‹åˆ¥ã«æŒ‡å®šã§ãã¾ã™ã€‚ ``[amk]`` ã¯ ``'a'`` ã€ ``'m'`` ã¾ãŸã¯ ``'k'`` ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:204
msgid ""
"Ranges of characters can be indicated by giving two characters and "
"separating them by a ``'-'``, for example ``[a-z]`` will match any lowercase"
" ASCII letter, ``[0-5][0-9]`` will match all the two-digits numbers from "
"``00`` to ``59``, and ``[0-9A-Fa-f]`` will match any hexadecimal digit.  If "
"``-`` is escaped (e.g. ``[a\\-z]``) or if it's placed as the first or last "
"character (e.g. ``[-a]`` or ``[a-]``), it will match a literal ``'-'``."
msgstr ""
"é€£ç¶šã—ãŸæ–‡å­—ã®ç¯„å›²ã‚’ã€ ``'-'`` ã‚’2 ã¤ã®æ–‡å­—ã§æŒŸã‚“ã§æŒ‡å®šã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€ ``[a-z]`` ã¯ã‚ã‚‰ã‚†ã‚‹å°æ–‡å­—ã® ASCII "
"æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚``[0-5][0-9]`` ã¯ ``00`` ã‹ã‚‰ ``59`` ã¾ã§å…¨ã¦ã® 2 æ¡ã®æ•°å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚``[0-9A-"
"Fa-f]`` ã¯ä»»æ„ã® 16 é€²æ•°å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚``-`` ãŒã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚Œã¦ã„ã‚‹ã‹ (ä¾‹: "
"``[a\\-z]``)ã€å…ˆé ­ã‚„æœ«å°¾ã®æ–‡å­—ã«ã•ã‚Œã¦ã„ã‚‹ã¨ (ä¾‹: ``[-a]`` ã‚„ ``[a-]``)ã€ãƒªãƒ†ãƒ©ãƒ« ``'-'`` ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:211
msgid ""
"Special characters lose their special meaning inside sets.  For example, "
"``[(+*)]`` will match any of the literal characters ``'('``, ``'+'``, "
"``'*'``, or ``')'``."
msgstr ""
"é›†åˆã®ä¸­ã§ã¯ã€ç‰¹æ®Šæ–‡å­—ã¯ãã®ç‰¹æ®Šãªæ„å‘³ã‚’å¤±ã„ã¾ã™ã€‚ä¾‹ãˆã° ``[(+*)]`` ã¯ãƒªãƒ†ãƒ©ãƒ«æ–‡å­— ``'('`` ã€ ``'+'`` ã€ ``'*'`` "
"ã€ã¾ãŸã¯ ``')'`` ã®ã©ã‚Œã«ã§ã‚‚ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:217
msgid ""
"Character classes such as ``\\w`` or ``\\S`` (defined below) are also "
"accepted inside a set, although the characters they match depends on whether"
" :const:`ASCII` or :const:`LOCALE` mode is in force."
msgstr ""
"``\\w`` ã‚„ ``\\S`` ã®ã‚ˆã†ãªæ–‡å­—ã‚¯ãƒ©ã‚¹ (å¾Œè¿°) ã‚‚é›†åˆã®ä¸­ã§å—ç†ã•ã‚Œã¾ã™ãŒã€ãã‚Œã«ãƒãƒƒãƒã™ã‚‹æ–‡å­—ã¯ :const:`ASCII` ã‚„ "
":const:`LOCALE` ãƒ¢ãƒ¼ãƒ‰ãŒæœ‰åŠ¹ã§ã‚ã‚‹ã‹ã«ä¾å­˜ã—ã¾ã™ã€‚"

#: ../../library/re.rst:223
msgid ""
"Characters that are not within a range can be matched by "
":dfn:`complementing` the set.  If the first character of the set is ``'^'``,"
" all the characters that are *not* in the set will be matched.  For example,"
" ``[^5]`` will match any character except ``'5'``, and ``[^^]`` will match "
"any character except ``'^'``.  ``^`` has no special meaning if it's not the "
"first character in the set."
msgstr ""
":dfn:`è£œé›†åˆ` ã‚’ã¨ã£ã¦ç¯„å›²å†…ã«ãªã„æ–‡å­—ã«ãƒãƒƒãƒã§ãã¾ã™ã€‚é›†åˆã®æœ€åˆã®æ–‡å­—ãŒ ``'^'`` ãªã‚‰ã€é›†åˆã« *å«ã¾ã‚Œãªã„* "
"å…¨ã¦ã®æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ ``[^5]`` ã¯ ``'5'`` ã‚’é™¤ãã‚ã‚‰ã‚†ã‚‹æ–‡å­—ã«ãƒãƒƒãƒã—ã€ ``[^^]`` ã¯ ``'^'`` "
"ã‚’é™¤ãã‚ã‚‰ã‚†ã‚‹æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ ``^`` ã¯é›†åˆã®æœ€åˆã®æ–‡å­—ã§ãªã‘ã‚Œã°ç‰¹åˆ¥ã®æ„å‘³ã‚’æŒã¡ã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:230
msgid ""
"To match a literal ``']'`` inside a set, precede it with a backslash, or "
"place it at the beginning of the set.  For example, both ``[()[\\]{}]`` and "
"``[]()[{}]`` will both match a parenthesis."
msgstr ""
"é›†åˆã®ä¸­ã§ãƒªãƒ†ãƒ©ãƒ« ``']'`` ã«ãƒãƒƒãƒã•ã›ã‚‹ã«ã¯ã€ãã®å‰ã«ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’ã¤ã‘ã‚‹ã‹ã€é›†åˆã®å…ˆé ­ã«ç½®ãã¾ã™ã€‚ä¾‹ãˆã°ã€ ``[()[\\]{}]``"
" ã¨ ``[]()[{}]`` ã¯ã©ã¡ã‚‰ã‚‚æ‹¬å¼§ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:239
msgid ""
"Support of nested sets and set operations as in `Unicode Technical Standard "
"#18`_ might be added in the future.  This would change the syntax, so to "
"facilitate this change a :exc:`FutureWarning` will be raised in ambiguous "
"cases for the time being. That includes sets starting with a literal ``'['``"
" or containing literal character sequences ``'--'``, ``'&&'``, ``'~~'``, and"
" ``'||'``.  To avoid a warning escape them with a backslash."
msgstr ""
"`Unicode Technical Standard #18`_ "
"ã«ã‚ã‚‹ã‚ˆã†ãªé›†åˆã®å…¥ã‚Œå­ã‚„é›†åˆæ“ä½œãŒå°†æ¥è¿½åŠ ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯æ§‹æ–‡ã‚’å¤‰åŒ–ã•ã›ã‚‹ã‚‚ã®ã§ã€ã“ã®å¤‰åŒ–ã‚’å®¹æ˜“ã«ã™ã‚‹ãŸã‚ã«ã€ã•ã—ã‚ãŸã£ã¦æ›–æ˜§ãªäº‹ä¾‹ã«ã¯"
" :exc:`FutureWarning` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ãƒªãƒ†ãƒ©ãƒ« ``'['`` ã§å§‹ã¾ã‚‹é›†åˆã‚„ã€ãƒªãƒ†ãƒ©ãƒ«æ–‡å­—ã®é€£ç¶š ``'--'`` ã€ "
"``'&&'`` ã€ ``'~~'`` ãŠã‚ˆã³ ``'||'`` ã‚’å«ã‚€é›†åˆã‚’å«ã¿ã¾ã™ã€‚è­¦å‘Šã‚’é¿ã‘ã‚‹ã«ã¯ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã§ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/re.rst:249
msgid ""
":exc:`FutureWarning` is raised if a character set contains constructs that "
"will change semantically in the future."
msgstr "æ–‡å­—ã‚»ãƒƒãƒˆãŒå°†æ¥æ„å‘³è«–çš„ã«å¤‰åŒ–ã™ã‚‹æ§‹é€ ã‚’å«ã‚€ãªã‚‰ :exc:`FutureWarning` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:264
msgid "``|``"
msgstr "``|``"

#: ../../library/re.rst:256
msgid ""
"``A|B``, where *A* and *B* can be arbitrary REs, creates a regular "
"expression that will match either *A* or *B*.  An arbitrary number of REs "
"can be separated by the ``'|'`` in this way.  This can be used inside groups"
" (see below) as well.  As the target string is scanned, REs separated by "
"``'|'`` are tried from left to right. When one pattern completely matches, "
"that branch is accepted. This means that once *A* matches, *B* will not be "
"tested further, even if it would produce a longer overall match.  In other "
"words, the ``'|'`` operator is never greedy.  To match a literal ``'|'``, "
"use ``\\|``, or enclose it inside a character class, as in ``[|]``."
msgstr ""
"*A* ã¨ *B* ã‚’ä»»æ„ã®æ­£è¦è¡¨ç¾ã¨ã—ã¦ã€ ``A|B`` ã¯ *A* ã¨ *B* "
"ã®ã„ãšã‚Œã‹ã«ãƒãƒƒãƒã™ã‚‹æ­£è¦è¡¨ç¾ã‚’ä½œæˆã—ã¾ã™ã€‚ã“ã®æ–¹æ³•ã§ä»»æ„ã®æ•°ã®æ­£è¦è¡¨ç¾ã‚’ ``'|'`` ã§åˆ†é›¢ã§ãã¾ã™ã€‚ã“ã‚Œã¯ã‚°ãƒ«ãƒ¼ãƒ— (ä¸‹è¨˜å‚ç…§) "
"ä¸­ã§ã‚‚ä½¿ãˆã¾ã™ã€‚å¯¾è±¡æ–‡å­—åˆ—ã‚’èµ°æŸ»ã™ã‚‹ã¨ãã€``'|'`` "
"ã§åˆ†é›¢ã•ã‚ŒãŸæ­£è¦è¡¨ç¾ã¯å·¦ã‹ã‚‰å³ã¸é †ã«è©¦ã•ã‚Œã¾ã™ã€‚ä¸€ã¤ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒå®Œå…¨ã«ãƒãƒƒãƒã—ãŸã¨ãã€ãã®ãƒ‘ã‚¿ãƒ¼ãƒ³æãŒå—ç†ã•ã‚Œã¾ã™ã€‚ã¤ã¾ã‚Šã€ã²ã¨ãŸã³ *A* "
"ãŒãƒãƒƒãƒã—ã¦ã—ã¾ãˆã°ã€ä¾‹ãˆ *B* ã«ã‚ˆã£ã¦å…¨ä½“ã®ãƒãƒƒãƒãŒé•·ããªã‚‹ã¨ã—ã¦ã‚‚ã€ *B* ã¯ã‚‚ã¯ã‚„èµ°æŸ»ã•ã‚Œã¾ã›ã‚“ã€‚è¨€ã„ã‹ãˆã‚‹ã¨ã€ ``'|'`` "
"æ¼”ç®—å­ã¯æ±ºã—ã¦è²ªæ¬²ã«ã¯ãªã‚Šã¾ã›ã‚“ã€‚ãƒªãƒ†ãƒ©ãƒ« ``'|'`` ã«ãƒãƒƒãƒã™ã‚‹ã«ã¯ã€ ``\\|`` ã‚’ä½¿ã†ã‹ã€ ``[|]`` "
"ã®ã‚ˆã†ã«æ–‡å­—ã‚¯ãƒ©ã‚¹ä¸­ã«å›²ã¿ã¾ã™ã€‚"

#: ../../library/re.rst:274
msgid "``(...)``"
msgstr "``(...)``"

#: ../../library/re.rst:270
msgid ""
"Matches whatever regular expression is inside the parentheses, and indicates"
" the start and end of a group; the contents of a group can be retrieved "
"after a match has been performed, and can be matched later in the string "
"with the ``\\number`` special sequence, described below.  To match the "
"literals ``'('`` or ``')'``, use ``\\(`` or ``\\)``, or enclose them inside "
"a character class: ``[(]``, ``[)]``."
msgstr ""
"ä¸¸æ‹¬å¼§ã§å›²ã¾ã‚ŒãŸæ­£è¦è¡¨ç¾ã«ãƒãƒƒãƒã™ã‚‹ã¨ã¨ã‚‚ã«ã€ã‚°ãƒ«ãƒ¼ãƒ—ã®é–‹å§‹ã¨çµ‚äº†ã‚’è¡¨ã—ã¾ã™ã€‚ã‚°ãƒ«ãƒ¼ãƒ—ã®ä¸­èº«ã¯ä»¥ä¸‹ã§è¿°ã¹ã‚‹ã‚ˆã†ã«ã€ãƒãƒƒãƒãŒå®Ÿè¡Œã•ã‚ŒãŸå¾Œã§å›åã—ãŸã‚Šã€ãã®æ–‡å­—åˆ—ä¸­ã§ä»¥é™"
" ``\\number`` ç‰¹æ®Šã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ãƒãƒƒãƒã—ãŸã‚Šã§ãã¾ã™ã€‚ãƒªãƒ†ãƒ©ãƒ« ``'('`` ã‚„ ``')'`` ã«ãƒãƒƒãƒã™ã‚‹ã«ã¯ã€``\\(`` ã‚„ "
"``\\)`` ã‚’ä½¿ã†ã‹ã€æ–‡å­—ã‚¯ãƒ©ã‚¹ä¸­ã«å›²ã¿ã¾ã™:  ``[(]``ã€ ``[)]`` ã€‚"

#: ../../library/re.rst:283
msgid "``(?...)``"
msgstr "``(?...)``"

#: ../../library/re.rst:279
msgid ""
"This is an extension notation (a ``'?'`` following a ``'('`` is not "
"meaningful otherwise).  The first character after the ``'?'`` determines "
"what the meaning and further syntax of the construct is. Extensions usually "
"do not create a new group; ``(?P<name>...)`` is the only exception to this "
"rule. Following are the currently supported extensions."
msgstr ""
"ã“ã‚Œã¯æ‹¡å¼µè¨˜æ³•ã§ã™ (``'('`` ã«ç¶šã ``'?'`` ã¯ãã‚Œä»¥ä¸Šã®æ„å‘³ã‚’æŒã¡ã¾ã›ã‚“) ã€‚ ``'?'`` "
"ã«ç¶šãæœ€åˆã®æ–‡å­—ãŒã“ã®æ§‹é€ ã®æ„å‘³ã¨ç‰¹æœ‰ã®æ§‹æ–‡ã‚’æ±ºå®šã—ã¾ã™ã€‚æ‹¡å¼µã¯ä¸€èˆ¬ã«æ–°ã—ã„ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆã—ã¾ã›ã‚“ã€‚ãŸã ã— ``(?P<name>...)`` "
"ã¯ã“ã®æ³•å‰‡ã®å”¯ä¸€ã®ä¾‹å¤–ã§ã™ã€‚ç¾åœ¨ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹æ‹¡å¼µã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚"

#: ../../library/re.rst:297
msgid "``(?aiLmsux)``"
msgstr "``(?aiLmsux)``"

#: ../../library/re.rst:286
msgid ""
"(One or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``.)  The group matches the empty string; the letters"
" set the corresponding flags: :const:`re.A` (ASCII-only matching), "
":const:`re.I` (ignore case), :const:`re.L` (locale dependent), :const:`re.M`"
" (multi-line), :const:`re.S` (dot matches all), :const:`re.U` (Unicode "
"matching), and :const:`re.X` (verbose), for the entire regular expression. "
"(The flags are described in :ref:`contents-of-module-re`.) This is useful if"
" you wish to include the flags as part of the regular expression, instead of"
" passing a *flag* argument to the :func:`re.compile` function.  Flags should"
" be used first in the expression string."
msgstr ""
"(``'a'`` ã€ ``'i'`` ã€ ``'L'`` ã€ ``'m'`` ã€ ``'s'`` ã€ ``'u'`` ã€ ``'x'`` ã®é›†åˆã‹ã‚‰ 1"
" æ–‡å­—ä»¥ä¸Šã€‚) ã“ã®ã‚°ãƒ«ãƒ¼ãƒ—ã¯ç©ºæ–‡å­—åˆ—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚æ–‡å­—ã¯æ­£è¦è¡¨ç¾å…¨ä½“ã«ã€å¯¾å¿œã™ã‚‹ãƒ•ãƒ©ã‚°ã‚’è¨­å®šã—ã¾ã™ã€‚ :const:`re.A` (ASCII "
"é™å®šãƒãƒƒãƒãƒ³ã‚°)ã€ :const:`re.I` (å¤§æ–‡å­—ãƒ»å°æ–‡å­—ã‚’åŒºåˆ¥ã—ãªã„)ã€ :const:`re.L` (ãƒ­ã‚±ãƒ¼ãƒ«ä¾å­˜)ã€ "
":const:`re.M` (è¤‡æ•°è¡Œ)ã€ :const:`re.S` (ãƒ‰ãƒƒãƒˆãŒå…¨ã¦ã«ãƒãƒƒãƒ)ã€ :const:`re.U` (Unicode "
"ãƒãƒƒãƒãƒ³ã‚°)ã€ :const:`re.X` (å†—é•·)ã€‚ (å„ãƒ•ãƒ©ã‚°ã«ã¤ã„ã¦ã¯ :ref:`contents-of-module-re` ã§èª¬æ˜ã—ã¾ã™ã€‚)"
" ã“ã‚Œã¯ã€ *flag* å¼•æ•°ã‚’ :func:`re.compile` "
"é–¢æ•°ã«æ¸¡ã™ã®ã§ã¯ãªãã€ãƒ•ãƒ©ã‚°ã‚’æ­£è¦è¡¨ç¾ã®ä¸€éƒ¨ã¨ã—ã¦å«ã‚ãŸã„ã¨ãã«ä¾¿åˆ©ã§ã™ã€‚ãƒ•ãƒ©ã‚°ã¯è¡¨ç¾æ–‡å­—åˆ—ã®å…ˆé ­ã§ä½¿ã†ã¹ãã§ã™ã€‚"

#: ../../library/re.rst:305
msgid "``(?:...)``"
msgstr "``(?:...)``"

#: ../../library/re.rst:302
msgid ""
"A non-capturing version of regular parentheses.  Matches whatever regular "
"expression is inside the parentheses, but the substring matched by the group"
" *cannot* be retrieved after performing a match or referenced later in the "
"pattern."
msgstr ""
"æ™®é€šã®ä¸¸æ‹¬å¼§ã®ã€ã‚­ãƒ£ãƒ—ãƒãƒ£ã—ãªã„ç‰ˆã§ã™ã€‚ä¸¸æ‹¬å¼§ã§å›²ã¾ã‚ŒãŸæ­£è¦è¡¨ç¾ã«ãƒãƒƒãƒã—ã¾ã™ãŒã€ã“ã®ã‚°ãƒ«ãƒ¼ãƒ—ãŒãƒãƒƒãƒã—ãŸéƒ¨åˆ†æ–‡å­—åˆ—ã¯ã€ãƒãƒƒãƒã‚’å®Ÿè¡Œã—ãŸã‚ã¨ã§å›åã™ã‚‹ã“ã¨ã‚‚ã€ãã®ãƒ‘ã‚¿ãƒ¼ãƒ³ä¸­ã§ä»¥é™å‚ç…§ã™ã‚‹ã“ã¨ã‚‚"
" *ã§ãã¾ã›ã‚“* ã€‚"

#: ../../library/re.rst:331
msgid "``(?aiLmsux-imsx:...)``"
msgstr "``(?aiLmsux-imsx:...)``"

#: ../../library/re.rst:308
msgid ""
"(Zero or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``, optionally followed by ``'-'`` followed by one or"
" more letters from the ``'i'``, ``'m'``, ``'s'``, ``'x'``.) The letters set "
"or remove the corresponding flags: :const:`re.A` (ASCII-only matching), "
":const:`re.I` (ignore case), :const:`re.L` (locale dependent), :const:`re.M`"
" (multi-line), :const:`re.S` (dot matches all), :const:`re.U` (Unicode "
"matching), and :const:`re.X` (verbose), for the part of the expression. (The"
" flags are described in :ref:`contents-of-module-re`.)"
msgstr ""
"(``'a'`` ã€ ``'i'`` ã€ ``'L'`` ã€ ``'m'`` ã€ ``'s'`` ã€ ``'u'`` ã€ ``'x'`` ã®é›†åˆã‹ã‚‰ 0"
" æ–‡å­—ä»¥ä¸Šã€å¿…è¦ãªã‚‰ã•ã‚‰ã« ``'-'`` ã«ç¶šã‘ã¦ ``'i'`` ã€ ``'m'`` ã€ ``'s'`` ã€ ``'x'`` ã®é›†åˆã‹ã‚‰ 1 "
"æ–‡å­—ä»¥ä¸Šã€‚) æ–‡å­—ã¯è¡¨ç¾ã®ä¸€éƒ¨ã«ã€å¯¾å¿œã™ã‚‹ãƒ•ãƒ©ã‚°ã‚’è¨­å®šã¾ãŸã¯é™¤å»ã—ã¾ã™ã€‚ :const:`re.A` (ASCII é™å®šãƒãƒƒãƒãƒ³ã‚°)ã€ "
":const:`re.I` (å¤§æ–‡å­—ãƒ»å°æ–‡å­—ã‚’åŒºåˆ¥ã—ãªã„)ã€ :const:`re.L` (ãƒ­ã‚±ãƒ¼ãƒ«ä¾å­˜)ã€ :const:`re.M` (è¤‡æ•°è¡Œ)ã€ "
":const:`re.S` (ãƒ‰ãƒƒãƒˆãŒå…¨ã¦ã«ãƒãƒƒãƒ)ã€ :const:`re.U` (Unicode ãƒãƒƒãƒãƒ³ã‚°)ã€ :const:`re.X` "
"(å†—é•·)ã€‚ (å„ãƒ•ãƒ©ã‚°ã«ã¤ã„ã¦ã¯ :ref:`contents-of-module-re` ã§èª¬æ˜ã—ã¾ã™ã€‚)"

#: ../../library/re.rst:318
msgid ""
"The letters ``'a'``, ``'L'`` and ``'u'`` are mutually exclusive when used as"
" inline flags, so they can't be combined or follow ``'-'``.  Instead, when "
"one of them appears in an inline group, it overrides the matching mode in "
"the enclosing group.  In Unicode patterns ``(?a:...)`` switches to ASCII-"
"only matching, and ``(?u:...)`` switches to Unicode matching (default).  In "
"byte pattern ``(?L:...)`` switches to locale depending matching, and "
"``(?a:...)`` switches to ASCII-only matching (default). This override is "
"only in effect for the narrow inline group, and the original matching mode "
"is restored outside of the group."
msgstr ""
"æ–‡å­— ``'a'`` ã€ ``'L'`` ãŠã‚ˆã³ ``'u'`` ã¯ç›¸äº’ã«æ’ä»–ã§ã‚ã‚Šã€çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã‚‚ ``'-'`` "
"ã«ç¶šã‘ã‚‹ã“ã¨ã‚‚ã§ãã¾ã›ã‚“ã€‚ãã®ä»£ã‚ã‚Šã€ã“ã‚Œã‚‰ã®å†…ä¸€ã¤ãŒã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚°ãƒ«ãƒ¼ãƒ—ä¸­ã«ç¾ã‚Œã‚‹ã¨ã€å¤–å´ã®ã‚°ãƒ«ãƒ¼ãƒ—ã§ã®ãƒãƒƒãƒãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã‚’ä¸Šæ›¸ãã—ã¾ã™ã€‚ Unicode"
" ãƒ‘ã‚¿ãƒ¼ãƒ³ä¸­ã§ã¯ ``(?a:...)`` ã¯ ASCII é™å®šãƒãƒƒãƒãƒ³ã‚°ã«åˆ‡ã‚Šæ›¿ãˆã€ ``(?u:...)`` ã¯ Unicode ãƒãƒƒãƒãƒ³ã‚° "
"(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ã«åˆ‡ã‚Šæ›¿ãˆã¾ã™ã€‚ãƒã‚¤ãƒˆåˆ—ãƒ‘ã‚¿ãƒ¼ãƒ³ä¸­ã§ã¯ã€ ``(?L:...)`` ã¯ãƒ­ã‚±ãƒ¼ãƒ«ä¾å­˜ãƒãƒƒãƒãƒ³ã‚°ã«åˆ‡ã‚Šæ›¿ãˆã€ ``(?a:...)`` ã¯ "
"ASCII é™å®šãƒãƒƒãƒãƒ³ã‚° (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) "
"ã«åˆ‡ã‚Šæ›¿ãˆã¾ã™ã€‚ã“ã®ä¸Šæ›¸ãã¯ç‹­ã„ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚°ãƒ«ãƒ¼ãƒ—ã«ã®ã¿å½±éŸ¿ã—ã€å…ƒã®ãƒãƒƒãƒãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã¯ã‚°ãƒ«ãƒ¼ãƒ—å¤–ã§ã¯å¾©å…ƒã•ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:330
msgid "The letters ``'a'``, ``'L'`` and ``'u'`` also can be used in a group."
msgstr "æ–‡å­— ``'a'`` ã€ ``'L'`` ãŠã‚ˆã³ ``'u'`` ã‚‚ã‚°ãƒ«ãƒ¼ãƒ—ä¸­ã§ä½¿ãˆã¾ã™ã€‚"

#: ../../library/re.rst:358
msgid "``(?P<name>...)``"
msgstr "``(?P<name>...)``"

#: ../../library/re.rst:336
msgid ""
"Similar to regular parentheses, but the substring matched by the group is "
"accessible via the symbolic group name *name*.  Group names must be valid "
"Python identifiers, and each group name must be defined only once within a "
"regular expression.  A symbolic group is also a numbered group, just as if "
"the group were not named."
msgstr ""
"é€šå¸¸ã®ä¸¸æ‹¬å¼§ã«ä¼¼ã¦ã„ã¾ã™ãŒã€ã“ã®ã‚°ãƒ«ãƒ¼ãƒ—ãŒãƒãƒƒãƒã—ãŸéƒ¨åˆ†æ–‡å­—åˆ—ã¯ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ã‚°ãƒ«ãƒ¼ãƒ—å *name* ã§ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚ã‚°ãƒ«ãƒ¼ãƒ—åã¯æœ‰åŠ¹ãª "
"Python è­˜åˆ¥å­ã§ãªã‘ã‚Œã°ãªã‚‰ãšã€å„ã‚°ãƒ«ãƒ¼ãƒ—åã¯ 1 "
"å€‹ã®æ­£è¦è¡¨ç¾å†…ã§ä¸€åº¦ã ã‘å®šç¾©ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ã‚°ãƒ«ãƒ¼ãƒ—ã¯ã€ãã®ã‚°ãƒ«ãƒ¼ãƒ—ãŒåå‰ä»˜ã‘ã•ã‚Œã¦ã„ãªã‹ã£ãŸã‹ã®ã‚ˆã†ã«ç•ªå·ä»˜ã‘ã•ã‚ŒãŸã‚°ãƒ«ãƒ¼ãƒ—ã§ã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../library/re.rst:342
msgid ""
"Named groups can be referenced in three contexts.  If the pattern is "
"``(?P<quote>['\"]).*?(?P=quote)`` (i.e. matching a string quoted with either"
" single or double quotes):"
msgstr ""
"åå‰ä»˜ãã‚°ãƒ«ãƒ¼ãƒ—ã¯ 3 ã¤ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§å‚ç…§ã§ãã¾ã™ã€‚ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒ ``(?P<quote>['\\\"]).*?(?P=quote)`` "
"(ã‚·ãƒ³ã‚°ãƒ«ã¾ãŸã¯ãƒ€ãƒ–ãƒ«ã‚¯ã‚ªãƒ¼ãƒˆã§å›²ã¾ã‚ŒãŸæ–‡å­—åˆ—ã«ãƒãƒƒãƒ) ãªã‚‰ã°:"

#: ../../library/re.rst:347
msgid "Context of reference to group \"quote\""
msgstr "ã‚°ãƒ«ãƒ¼ãƒ— \"quote\" ã‚’å‚ç…§ã™ã‚‹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ"

#: ../../library/re.rst:347
msgid "Ways to reference it"
msgstr "å‚ç…§ã™ã‚‹æ–¹æ³•"

#: ../../library/re.rst:349
msgid "in the same pattern itself"
msgstr "ãã®åŒã˜ãƒ‘ã‚¿ãƒ¼ãƒ³ä¸­"

#: ../../library/re.rst:349
msgid "``(?P=quote)`` (as shown)"
msgstr "``(?P=quote)`` (ç¤ºã—ãŸã¨ãŠã‚Š)"

#: ../../library/re.rst:350 ../../library/re.rst:357
msgid "``\\1``"
msgstr "``\\1``"

#: ../../library/re.rst:352
msgid "when processing match object *m*"
msgstr "ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ *m* ã®å‡¦ç†æ™‚"

#: ../../library/re.rst:352
msgid "``m.group('quote')``"
msgstr "``m.group('quote')``"

#: ../../library/re.rst:353
msgid "``m.end('quote')`` (etc.)"
msgstr "``m.end('quote')`` (ãªã©)"

#: ../../library/re.rst:355
msgid "in a string passed to the *repl* argument of ``re.sub()``"
msgstr "``re.sub()`` ã® *repl* å¼•æ•°ã¸æ¸¡ã•ã‚Œã‚‹æ–‡å­—åˆ—ä¸­"

#: ../../library/re.rst:355
msgid "``\\g<quote>``"
msgstr "``\\g<quote>``"

#: ../../library/re.rst:356
msgid "``\\g<1>``"
msgstr "``\\g<1>``"

#: ../../library/re.rst:364
msgid "``(?P=name)``"
msgstr "``(?P=name)``"

#: ../../library/re.rst:363
msgid ""
"A backreference to a named group; it matches whatever text was matched by "
"the earlier group named *name*."
msgstr "åå‰ä»˜ãã‚°ãƒ«ãƒ¼ãƒ—ã¸ã®å¾Œæ–¹å‚ç…§ã§ã™ã€‚ã“ã‚Œã¯ *name* ã¨ã„ã†åå‰ã®æ—¢å‡ºã®ã‚°ãƒ«ãƒ¼ãƒ—ãŒãƒãƒƒãƒã—ãŸæ–‡å­—åˆ—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:369
msgid "``(?#...)``"
msgstr "``(?#...)``"

#: ../../library/re.rst:369
msgid "A comment; the contents of the parentheses are simply ignored."
msgstr "ã‚³ãƒ¡ãƒ³ãƒˆã§ã™ã€‚æ‹¬å¼§ã®ä¸­èº«ã¯å˜ç´”ã«ç„¡è¦–ã•ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:374
msgid "``(?=...)``"
msgstr "``(?=...)``"

#: ../../library/re.rst:372
msgid ""
"Matches if ``...`` matches next, but doesn't consume any of the string.  "
"This is called a :dfn:`lookahead assertion`.  For example, ``Isaac "
"(?=Asimov)`` will match ``'Isaac '`` only if it's followed by ``'Asimov'``."
msgstr ""
"``...`` ãŒæ¬¡ã«ç¶šãã‚‚ã®ã«ãƒãƒƒãƒã™ã‚Œã°ãƒãƒƒãƒã—ã¾ã™ãŒã€æ–‡å­—åˆ—ã‚’ã¾ã£ãŸãæ¶ˆè²»ã—ã¾ã›ã‚“ã€‚ã“ã‚Œã¯ :dfn:`å…ˆèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ (lookahead "
"assertion)` ã¨å‘¼ã°ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€``Isaac (?=Asimov)`` ã¯ ``'Isaac '`` ã«ã€ãã®å¾Œã« "
"``'Asimov'`` ãŒç¶šãå ´åˆã«ã®ã¿ã€ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:381
msgid "``(?!...)``"
msgstr "``(?!...)``"

#: ../../library/re.rst:379
msgid ""
"Matches if ``...`` doesn't match next.  This is a :dfn:`negative lookahead "
"assertion`. For example, ``Isaac (?!Asimov)`` will match ``'Isaac '`` only "
"if it's *not* followed by ``'Asimov'``."
msgstr ""
"``...`` ãŒæ¬¡ã«ç¶šãã‚‚ã®ã«ãƒãƒƒãƒã—ãªã‘ã‚Œã°ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã¯ :dfn:`å¦å®šå…ˆèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ (negative lookahead "
"assertion)` ã§ã™ã€‚ä¾‹ãˆã°ã€``Isaac (?!Asimov)`` ã¯ ``'Isaac '`` ã«ã€ãã®å¾Œã« ``'Asimov'`` "
"ãŒç¶šã‹ *ãªã„* å ´åˆã«ã®ã¿ã€ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:408
msgid "``(?<=...)``"
msgstr "``(?<=...)``"

#: ../../library/re.rst:386
msgid ""
"Matches if the current position in the string is preceded by a match for "
"``...`` that ends at the current position.  This is called a :dfn:`positive "
"lookbehind assertion`. ``(?<=abc)def`` will find a match in ``'abcdef'``, "
"since the lookbehind will back up 3 characters and check if the contained "
"pattern matches. The contained pattern must only match strings of some fixed"
" length, meaning that ``abc`` or ``a|b`` are allowed, but ``a*`` and "
"``a{3,4}`` are not.  Note that patterns which start with positive lookbehind"
" assertions will not match at the beginning of the string being searched; "
"you will most likely want to use the :func:`search` function rather than the"
" :func:`match` function:"
msgstr ""
"ãã®æ–‡å­—åˆ—ã«ãŠã‘ã‚‹ç¾åœ¨ä½ç½®ã®å‰ã«ã€ç¾åœ¨ä½ç½®ã§çµ‚ã‚ã‚‹ ``...`` ã¨ã®ãƒãƒƒãƒãŒã‚ã‚Œã°ã€ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã¯ :dfn:`å¾Œèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³` "
"ã¨å‘¼ã°ã‚Œã¾ã™ã€‚``(?<=abc)def`` ã¯ã€å¾Œèª­ã¿ã¯ 3 æ–‡å­—ã‚’ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã—ã€å«ã¾ã‚Œã¦ã„ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒãƒãƒƒãƒã™ã‚‹ã‹æ¤œæŸ»ã™ã‚‹ã®ã§ "
"``'abcdef'`` ã«ãƒãƒƒãƒã‚’è¦‹ã¤ã‘ã¾ã™ã€‚å«ã¾ã‚Œã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€å›ºå®šé•·ã®æ–‡å­—åˆ—ã«ã®ã¿ãƒãƒƒãƒã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã™ãªã‚ã¡ã€ ``abc`` ã‚„ "
"``a|b`` ã¯è¨±ã•ã‚Œã¾ã™ãŒã€``a*`` ã‚„ ``a{3,4}`` "
"ã¯è¨±ã•ã‚Œã¾ã›ã‚“ã€‚è‚¯å®šå¾Œèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã§å§‹ã¾ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€æ¤œç´¢ã•ã‚Œã‚‹æ–‡å­—åˆ—ã®å…ˆé ­ã¨ã¯æ±ºã—ã¦ãƒãƒƒãƒã—ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ä¸‹ã•ã„ã€‚:func:`match` "
"é–¢æ•°ã§ã¯ãªã :func:`search` é–¢æ•°ã‚’ä½¿ã†æ–¹ãŒæœ›ã¾ã—ã„ã§ã—ã‚‡ã†:"

#: ../../library/re.rst:401
msgid "This example looks for a word following a hyphen:"
msgstr "ã“ã®ä¾‹ã§ã¯ãƒã‚¤ãƒ•ãƒ³ã«ç¶šãå˜èªã‚’æ¢ã—ã¾ã™:"

#: ../../library/re.rst:407
msgid "Added support for group references of fixed length."
msgstr "å›ºå®šé•·ã®ã‚°ãƒ«ãƒ¼ãƒ—å‚ç…§ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/re.rst:417
msgid "``(?<!...)``"
msgstr "``(?<!...)``"

#: ../../library/re.rst:413
msgid ""
"Matches if the current position in the string is not preceded by a match for"
" ``...``.  This is called a :dfn:`negative lookbehind assertion`.  Similar "
"to positive lookbehind assertions, the contained pattern must only match "
"strings of some fixed length.  Patterns which start with negative lookbehind"
" assertions may match at the beginning of the string being searched."
msgstr ""
"ãã®æ–‡å­—åˆ—ã«ãŠã‘ã‚‹ç¾åœ¨ä½ç½®ã®å‰ã« ``...`` ã¨ã®ãƒãƒƒãƒãŒãªã‘ã‚Œã°ã€ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã¯ :dfn:`å¦å®šå¾Œèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³(negative "
"lookbehind assertion)` "
"ã¨å‘¼ã°ã‚Œã¾ã™ã€‚è‚¯å®šå¾Œèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã¨åŒæ§˜ã«ã€å«ã¾ã‚Œã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯å›ºå®šé•·ã®æ–‡å­—åˆ—ã«ã®ã¿ãƒãƒƒãƒã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å¦å®šå¾Œèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã§å§‹ã¾ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯æ¤œç´¢ã•ã‚Œã‚‹æ–‡å­—åˆ—ã®å…ˆé ­ã§ãƒãƒƒãƒã§ãã¾ã™ã€‚"

#: ../../library/re.rst:426
msgid "``(?(id/name)yes-pattern|no-pattern)``"
msgstr "``(?(id/name)yes-pattern|no-pattern)``"

#: ../../library/re.rst:420
msgid ""
"Will try to match with ``yes-pattern`` if the group with given *id* or "
"*name* exists, and with ``no-pattern`` if it doesn't. ``no-pattern`` is "
"optional and can be omitted. For example, "
"``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>|$)`` is a poor email matching pattern, "
"which will match with ``'<user@host.com>'`` as well as ``'user@host.com'``, "
"but not with ``'<user@host.com'`` nor ``'user@host.com>'``."
msgstr ""
"ä¸ãˆã‚‰ã‚ŒãŸ *id* ã‚„ *name* ã®ã‚°ãƒ«ãƒ¼ãƒ—ãŒå­˜åœ¨ã™ã‚Œã° ``yes-pattern`` ã¨ã®ã€å­˜åœ¨ã—ãªã‘ã‚Œã° ``no-pattern`` "
"ã¨ã®ãƒãƒƒãƒã‚’è©¦ã¿ã¾ã™ã€‚``no-pattern`` "
"ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã‚ã‚Šçœç•¥ã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>|$)`` ã¯è²§å¼±ãª E-mail "
"ãƒãƒƒãƒãƒ³ã‚°ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã€``'<user@host.com>'`` ã‚„ ``'user@host.com'`` "
"ã«ã¯ãƒãƒƒãƒã—ã¾ã™ãŒã€``'<user@host.com'`` ã‚„ ``'user@host.com>'`` ã«ã¯ãƒãƒƒãƒã—ã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:428
msgid ""
"The special sequences consist of ``'\\'`` and a character from the list "
"below. If the ordinary character is not an ASCII digit or an ASCII letter, "
"then the resulting RE will match the second character.  For example, ``\\$``"
" matches the character ``'$'``."
msgstr ""
"ç‰¹æ®Šã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ ``'\\'`` ã¨ä»¥ä¸‹ã®ãƒªã‚¹ãƒˆã®æ–‡å­—ã‹ã‚‰æ§‹æˆã•ã‚Œã¾ã™ã€‚é€šå¸¸æ–‡å­—ãŒ ASCII æ•°å­—ã§ã‚‚ ASCII "
"æ–‡å­—ã§ã‚‚ãªã‘ã‚Œã°ã€çµæœã®æ­£è¦è¡¨ç¾ã¯ 2 ç•ªç›®ã®æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ä¾‹ãˆã°ã€``\\$`` ã¯æ–‡å­— ``'$'`` ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:443
msgid "``\\number``"
msgstr "``\\number``"

#: ../../library/re.rst:436
msgid ""
"Matches the contents of the group of the same number.  Groups are numbered "
"starting from 1.  For example, ``(.+) \\1`` matches ``'the the'`` or ``'55 "
"55'``, but not ``'thethe'`` (note the space after the group).  This special "
"sequence can only be used to match one of the first 99 groups.  If the first"
" digit of *number* is 0, or *number* is 3 octal digits long, it will not be "
"interpreted as a group match, but as the character with octal value "
"*number*. Inside the ``'['`` and ``']'`` of a character class, all numeric "
"escapes are treated as characters."
msgstr ""
"åŒã˜ç•ªå·ã®ã‚°ãƒ«ãƒ¼ãƒ—ã®ä¸­èº«ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ã‚°ãƒ«ãƒ¼ãƒ—ã¯ 1 ã‹ã‚‰å§‹ã¾ã‚‹ç•ªå·ã‚’ã¤ã‘ã‚‰ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ ``(.+) \\1`` ã¯ã€ ``'the "
"the'`` ã‚ã‚‹ã„ã¯ ``'55 55'`` ã«ãƒãƒƒãƒã—ã¾ã™ãŒã€ ``'thethe'`` "
"ã«ã¯ãƒãƒƒãƒã—ã¾ã›ã‚“(ã‚°ãƒ«ãƒ¼ãƒ—ã®å¾Œã®ã‚¹ãƒšãƒ¼ã‚¹ã«æ³¨æ„ã—ã¦ä¸‹ã•ã„)ã€‚ã“ã®ç‰¹æ®Šã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯æœ€åˆã® 99 ã‚°ãƒ«ãƒ¼ãƒ—ã®ã†ã¡ã®ä¸€ã¤ã¨ã®ãƒãƒƒãƒã«ã®ã¿ä½¿ãˆã¾ã™ã€‚ "
"*number* ã®æœ€åˆã®æ¡ãŒ 0 ã§ã‚ã‚‹ã‹ã€ *number* ãŒ 3 æ¡ã® 8 é€²æ•°ã§ã‚ã‚Œã°ã€ãã‚Œã¯ã‚°ãƒ«ãƒ¼ãƒ—ã®ãƒãƒƒãƒã¨ã—ã¦ã§ã¯ãªãã€ 8 é€²å€¤ "
"*number* ã‚’æŒã¤æ–‡å­—ã¨ã—ã¦è§£é‡ˆã•ã‚Œã¾ã™ã€‚æ–‡å­—ã‚¯ãƒ©ã‚¹ã® ``'['`` ã¨ ``']'`` ã®é–“ã§ã¯å…¨ã¦ã®æ•°å€¤ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ãŒæ–‡å­—ã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:448
msgid "``\\A``"
msgstr "``\\A``"

#: ../../library/re.rst:448
msgid "Matches only at the start of the string."
msgstr "æ–‡å­—åˆ—ã®å…ˆé ­ã§ã®ã¿ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:464
msgid "``\\b``"
msgstr "``\\b``"

#: ../../library/re.rst:453
msgid ""
"Matches the empty string, but only at the beginning or end of a word. A word"
" is defined as a sequence of word characters.  Note that formally, ``\\b`` "
"is defined as the boundary between a ``\\w`` and a ``\\W`` character (or "
"vice versa), or between ``\\w`` and the beginning/end of the string. This "
"means that ``r'\\bfoo\\b'`` matches ``'foo'``, ``'foo.'``, ``'(foo)'``, "
"``'bar foo baz'`` but not ``'foobar'`` or ``'foo3'``."
msgstr ""
"ç©ºæ–‡å­—åˆ—ã«ãƒãƒƒãƒã—ã¾ã™ãŒã€å˜èªã®å…ˆé ­ã‹æœ«å°¾ã§ã®ã¿ã§ã™ã€‚å˜èªã¯å˜èªæ–‡å­—ã®ä¸¦ã³ã¨ã—ã¦å®šç¾©ã•ã‚Œã¾ã™ã€‚å½¢å¼çš„ã«ã¯ã€ ``\\b`` ã¯ ``\\w`` ã¨ "
"``\\W`` æ–‡å­— (ã¾ãŸã¯ãã®é€†) ã¨ã®ã€ã‚ã‚‹ã„ã¯ ``\\w`` ã¨æ–‡å­—åˆ—ã®å…ˆé ­ãƒ»æœ«å°¾ã¨ã®å¢ƒç•Œã¨ã—ã¦å®šç¾©ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ "
"``r'\\bfoo\\b'`` ã¯ ``'foo'`` ã€ ``'foo.'`` ã€ ``'(foo)'`` ã€ ``'bar foo baz'`` "
"ã«ã¯ãƒãƒƒãƒã—ã¾ã™ãŒã€ ``'foobar'`` ã‚„ ``'foo3'`` ã«ã¯ãƒãƒƒãƒã—ã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:460
msgid ""
"By default Unicode alphanumerics are the ones used in Unicode patterns, but "
"this can be changed by using the :const:`ASCII` flag.  Word boundaries are "
"determined by the current locale if the :const:`LOCALE` flag is used. Inside"
" a character range, ``\\b`` represents the backspace character, for "
"compatibility with Python's string literals."
msgstr ""
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® Unicode è‹±æ•°å­—ã¯ Unicode ãƒ‘ã‚¿ãƒ¼ãƒ³ä¸­ã§ä½¿ã‚ã‚Œã‚‹ã‚‚ã®ã¨åŒã˜ã§ã™ãŒã€ã“ã‚Œã¯ :const:`ASCII` "
"ãƒ•ãƒ©ã‚°ã‚’ä½¿ã£ã¦å¤‰æ›´ã§ãã¾ã™ã€‚ :const:`LOCALE` ãƒ•ãƒ©ã‚°ãŒä½¿ã‚ã‚Œã¦ã„ã‚‹ãªã‚‰å˜èªã®å¢ƒç•Œã¯ç¾åœ¨ã®ãƒ­ã‚±ãƒ¼ãƒ«ã«ã‚ˆã£ã¦æ±ºå®šã•ã‚Œã¾ã™ã€‚Python "
"ã®æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã¨ã®äº’æ›æ€§ã®ãŸã‚ã€æ–‡å­—åˆ—ç¯„å›²ä¸­ã§ã¯ã€ ``\\b`` ã¯å¾Œé€€ (backspace) æ–‡å­—ã‚’è¡¨ã—ã¾ã™ã€‚"

#: ../../library/re.rst:475
msgid "``\\B``"
msgstr "``\\B``"

#: ../../library/re.rst:469
msgid ""
"Matches the empty string, but only when it is *not* at the beginning or end "
"of a word.  This means that ``r'py\\B'`` matches ``'python'``, ``'py3'``, "
"``'py2'``, but not ``'py'``, ``'py.'``, or ``'py!'``. ``\\B`` is just the "
"opposite of ``\\b``, so word characters in Unicode patterns are Unicode "
"alphanumerics or the underscore, although this can be changed by using the "
":const:`ASCII` flag.  Word boundaries are determined by the current locale "
"if the :const:`LOCALE` flag is used."
msgstr ""
"ç©ºæ–‡å­—åˆ—ã«ãƒãƒƒãƒã—ã¾ã™ãŒã€ãã‚ŒãŒå˜èªã®å…ˆé ­ã‹æœ«å°¾ *ã§ãªã„* ã¨ãã®ã¿ã§ã™ã€‚ã¤ã¾ã‚Š ``r'py\\B'`` ã¯ ``'python'`` ã€ "
"``'py3'`` ã€``'py2'`` ã«ãƒãƒƒãƒã—ã¾ã™ãŒã€ ``'py'`` ã€ ``'py.'`` ã€ ã¾ãŸã¯ ``'py!'`` "
"ã«ã¯ãƒãƒƒãƒã—ã¾ã›ã‚“ã€‚ ``\\B`` ã¯ ``\\b`` ã®ã¡ã‚‡ã†ã©åå¯¾ã§ã€ Unicode ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãŠã‘ã‚‹å˜èªæ–‡å­—ã¯ Unicode "
"è‹±æ•°å­—ãŠã‚ˆã³ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã§ã™ãŒã€ ã“ã‚Œã¯ :const:`ASCII` ãƒ•ãƒ©ã‚°ã‚’ä½¿ã£ã¦å¤‰æ›´ã§ãã¾ã™ã€‚ :const:`LOCALE` "
"ãƒ•ãƒ©ã‚°ãŒä½¿ã‚ã‚Œã¦ã„ã‚‹ãªã‚‰å˜èªã®å¢ƒç•Œã¯ç¾åœ¨ã®ãƒ­ã‚±ãƒ¼ãƒ«ã«ã‚ˆã£ã¦æ±ºå®šã•ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:487
msgid "``\\d``"
msgstr "``\\d``"

#: ../../library/re.rst:484 ../../library/re.rst:504 ../../library/re.rst:524
msgid "For Unicode (str) patterns:"
msgstr "Unicode (str) ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã¯:"

#: ../../library/re.rst:481
msgid ""
"Matches any Unicode decimal digit (that is, any character in Unicode "
"character category [Nd]).  This includes ``[0-9]``, and also many other "
"digit characters.  If the :const:`ASCII` flag is used only ``[0-9]`` is "
"matched."
msgstr ""
"ä»»æ„ã® Unicode 10 é€²æ•°å­— (Unicode æ–‡å­—ã‚«ãƒ†ã‚´ãƒª [Nd]) ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã¯ ``[0-9]`` "
"ã¨ãã®ä»–å¤šæ•°ã®æ•°å­—ã‚’å«ã¿ã¾ã™ã€‚ :const:`ASCII` ãƒ•ãƒ©ã‚°ãŒä½¿ã‚ã‚Œã¦ã„ã‚‹ãªã‚‰ ``[0-9]`` ã®ã¿ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:487 ../../library/re.rst:508 ../../library/re.rst:530
msgid "For 8-bit (bytes) patterns:"
msgstr "8 ãƒ“ãƒƒãƒˆ (bytes) ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã¯:"

#: ../../library/re.rst:487
msgid "Matches any decimal digit; this is equivalent to ``[0-9]``."
msgstr "ä»»æ„ã® 10 é€²æ•°å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã¯ ``[0-9]`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/re.rst:494
msgid "``\\D``"
msgstr "``\\D``"

#: ../../library/re.rst:492
msgid ""
"Matches any character which is not a decimal digit. This is the opposite of "
"``\\d``. If the :const:`ASCII` flag is used this becomes the equivalent of "
"``[^0-9]``."
msgstr ""
"10 é€²æ•°å­—ã§ãªã„ä»»æ„ã®æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã¯ ``\\d`` ã®åå¯¾ã§ã™ã€‚:const:`ASCII` ãƒ•ãƒ©ã‚°ãŒä½¿ã‚ã‚Œã¦ã„ã‚‹ãªã‚‰ã“ã‚Œã¯ "
"``[^0-9]`` ã¨ç­‰ä¾¡ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/re.rst:508
msgid "``\\s``"
msgstr "``\\s``"

#: ../../library/re.rst:500
msgid ""
"Matches Unicode whitespace characters (which includes ``[ "
"\\t\\n\\r\\f\\v]``, and also many other characters, for example the non-"
"breaking spaces mandated by typography rules in many languages). If the "
":const:`ASCII` flag is used, only ``[ \\t\\n\\r\\f\\v]`` is matched."
msgstr ""
"Unicode ç©ºç™½æ–‡å­— (ã“ã‚Œã¯ ``[ \\t\\n\\r\\f\\v]`` "
"ãã®ä»–å¤šãã®æ–‡å­—ã€ä¾‹ãˆã°å¤šãã®è¨€èªã«ãŠã‘ã‚‹ã‚¿ã‚¤ãƒã‚°ãƒ©ãƒ•ã‚£è¦å‰‡ã§å®šç¾©ã•ã‚ŒãŸãƒãƒ¼ãƒ–ãƒ¬ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ãªã©ã‚’å«ã¿ã¾ã™) ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ "
":const:`ASCII` ãƒ•ãƒ©ã‚°ãŒä½¿ã‚ã‚Œã¦ã„ã‚‹ãªã‚‰ã€``[ \\t\\n\\r\\f\\v]`` ã®ã¿ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:507
msgid ""
"Matches characters considered whitespace in the ASCII character set; this is"
" equivalent to ``[ \\t\\n\\r\\f\\v]``."
msgstr "ASCII æ–‡å­—ã‚»ãƒƒãƒˆã§ç©ºç™½æ–‡å­—ã¨è¦‹ãªã•ã‚Œã‚‹æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã¯ ``[ \\t\\n\\r\\f\\v]`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/re.rst:515
msgid "``\\S``"
msgstr "``\\S``"

#: ../../library/re.rst:513
msgid ""
"Matches any character which is not a whitespace character. This is the "
"opposite of ``\\s``. If the :const:`ASCII` flag is used this becomes the "
"equivalent of ``[^ \\t\\n\\r\\f\\v]``."
msgstr ""
"ç©ºç™½æ–‡å­—ã§ã¯ãªã„ä»»æ„ã®æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã¯ ``\\s`` ã®åå¯¾ã§ã™ã€‚:const:`ASCII` ãƒ•ãƒ©ã‚°ãŒä½¿ã‚ã‚Œã¦ã„ã‚‹ãªã‚‰ã“ã‚Œã¯ ``[^ "
"\\t\\n\\r\\f\\v]`` ã¨ç­‰ä¾¡ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/re.rst:530
msgid "``\\w``"
msgstr "``\\w``"

#: ../../library/re.rst:521
msgid ""
"Matches Unicode word characters; this includes most characters that can be "
"part of a word in any language, as well as numbers and the underscore. If "
"the :const:`ASCII` flag is used, only ``[a-zA-Z0-9_]`` is matched."
msgstr ""
"Unicode "
"å˜èªæ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã¯ã‚ã‚‰ã‚†ã‚‹è¨€èªã§å˜èªã®ä¸€éƒ¨ã«ãªã‚Šã†ã‚‹ã»ã¨ã‚“ã©ã®æ–‡å­—ã€æ•°å­—ã€ãŠã‚ˆã³ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã‚’å«ã¿ã¾ã™ã€‚:const:`ASCII` "
"ãƒ•ãƒ©ã‚°ãŒä½¿ã‚ã‚Œã¦ã„ã‚‹ãªã‚‰ã€ ``[a-zA-Z0-9_]`` ã®ã¿ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:527
msgid ""
"Matches characters considered alphanumeric in the ASCII character set; this "
"is equivalent to ``[a-zA-Z0-9_]``.  If the :const:`LOCALE` flag is used, "
"matches characters considered alphanumeric in the current locale and the "
"underscore."
msgstr ""
"ASCII æ–‡å­—ã‚»ãƒƒãƒˆã§è‹±æ•°å­—ã¨è¦‹ãªã•ã‚Œã‚‹æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã¯ ``[a-zA-Z0-9_]`` ã¨ç­‰ä¾¡ã§ã™ã€‚:const:`LOCALE` "
"ãƒ•ãƒ©ã‚°ãŒä½¿ã‚ã‚Œã¦ã„ã‚‹ãªã‚‰ã€ç¾åœ¨ã®ãƒ­ã‚±ãƒ¼ãƒ«ã§è‹±æ•°å­—ã¨è¦‹ãªã•ã‚Œã‚‹æ–‡å­—ãŠã‚ˆã³ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:539
msgid "``\\W``"
msgstr "``\\W``"

#: ../../library/re.rst:535
msgid ""
"Matches any character which is not a word character. This is the opposite of"
" ``\\w``. If the :const:`ASCII` flag is used this becomes the equivalent of "
"``[^a-zA-Z0-9_]``.  If the :const:`LOCALE` flag is used, matches characters "
"considered alphanumeric in the current locale and the underscore."
msgstr ""
"å˜èªæ–‡å­—ã§ã¯ãªã„ä»»æ„ã®æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã‚Œã¯ ``\\w`` ã®åå¯¾ã§ã™ã€‚ :const:`ASCII` ãƒ•ãƒ©ã‚°ãŒä½¿ã‚ã‚Œã¦ã„ã‚‹ãªã‚‰ã€ã“ã‚Œã¯ "
"``[^a-zA-Z0-9_]`` ã¨ç­‰ä¾¡ã«ãªã‚Šã¾ã™ã€‚:const:`LOCALE` "
"ãƒ•ãƒ©ã‚°ãŒä½¿ã‚ã‚Œã¦ã„ã‚‹ãªã‚‰ã€ç¾åœ¨ã®ãƒ­ã‚±ãƒ¼ãƒ«ã§è‹±æ•°å­—ã¨è¦‹ãªã•ã‚Œã‚‹æ–‡å­—ã‚„ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ä»¥å¤–ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:544
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../../library/re.rst:544
msgid "Matches only at the end of the string."
msgstr "æ–‡å­—åˆ—ã®æœ«å°¾ã§ã®ã¿ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:560
msgid ""
"Most of the standard escapes supported by Python string literals are also "
"accepted by the regular expression parser::"
msgstr "Python æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹æ¨™æº–ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã®ã»ã¨ã‚“ã©ã‚‚æ­£è¦è¡¨ç¾ãƒ‘ãƒ¼ã‚¶ã§å—ç†ã•ã‚Œã¾ã™::"

#: ../../library/re.rst:567
msgid ""
"(Note that ``\\b`` is used to represent word boundaries, and means "
"\"backspace\" only inside character classes.)"
msgstr "(``\\b`` ã¯å˜èªã®å¢ƒç•Œã‚’è¡¨ã™ã®ã«ä½¿ã‚ã‚Œã€æ–‡å­—ã‚¯ãƒ©ã‚¹ä¸­ã§ã®ã¿ \"å¾Œé€€ (backspace)\" æ–‡å­—ã‚’æ„å‘³ã™ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚)"

#: ../../library/re.rst:570
msgid ""
"``'\\u'`` and ``'\\U'`` escape sequences are only recognized in Unicode "
"patterns.  In bytes patterns they are errors."
msgstr ""
"``'\\u'`` ãŠã‚ˆã³ ``'\\U'`` ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ Unicode ãƒ‘ã‚¿ãƒ¼ãƒ³ä¸­ã§ã®ã¿èªè­˜ã•ã‚Œã¾ã™ã€‚ãƒã‚¤ãƒˆåˆ—ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã¯ã‚¨ãƒ©ãƒ¼ã§ã™ã€‚"

#: ../../library/re.rst:573
msgid ""
"Octal escapes are included in a limited form.  If the first digit is a 0, or"
" if there are three octal digits, it is considered an octal escape. "
"Otherwise, it is a group reference.  As for string literals, octal escapes "
"are always at most three digits in length."
msgstr ""
"8 é€²ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã¯é™ã‚‰ã‚ŒãŸå½¢å¼ã§ã®ã¿å«ã¾ã‚Œã¾ã™ã€‚ãã®æœ€åˆã®æ¡ãŒ 0 ã§ã‚ã‚‹ã‹ã€ãã‚ŒãŒ 3 æ¡ã® 8 é€²æ•°ã§ã‚ã‚‹ãªã‚‰ã°ã€ãã‚Œã¯ 8 "
"é€²ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã¨è¦‹ãªã•ã‚Œã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã°ã€ãã‚Œã¯ã‚°ãƒ«ãƒ¼ãƒ—å‚ç…§ã§ã™ã€‚æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã§ã¯ã€8 é€²ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã¯å¸¸ã«ãŸã‹ã ã‹ 3 æ¡é•·ã§ã™ã€‚"

#: ../../library/re.rst:578
msgid "The ``'\\u'`` and ``'\\U'`` escape sequences have been added."
msgstr "``'\\u'`` ã¨ ``'\\U'`` ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/re.rst:581
msgid ""
"Unknown escapes consisting of ``'\\'`` and an ASCII letter now are errors."
msgstr "``'\\'`` ã¨ ASCII æ–‡å­—ã‹ã‚‰ãªã‚‹æœªçŸ¥ã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã¯ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/re.rst:589
msgid "Module Contents"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚³ãƒ³ãƒ†ãƒ³ãƒ„"

#: ../../library/re.rst:591
msgid ""
"The module defines several functions, constants, and an exception. Some of "
"the functions are simplified versions of the full featured methods for "
"compiled regular expressions.  Most non-trivial applications always use the "
"compiled form."
msgstr ""
"ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã„ãã¤ã‹ã®é–¢æ•°ã€å®šæ•°ã€ä¾‹å¤–ã‚’å®šç¾©ã—ã¾ã™ã€‚ã“ã®ã†ã¡ã„ãã¤ã‹ã®é–¢æ•°ã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿æ­£è¦è¡¨ç¾ãŒããªãˆã‚‹å®Œå…¨ãªæ©Ÿèƒ½ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç°¡æ˜“ã«ã—ãŸã‚‚ã®ã§ã™ã€‚äº›ç´°ãªã‚‚ã®ã‚’é™¤ãã»ã¨ã‚“ã©ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯å¸¸ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿å½¢å¼ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../library/re.rst:596
msgid ""
"Flag constants are now instances of :class:`RegexFlag`, which is a subclass "
"of :class:`enum.IntFlag`."
msgstr ""
"ãƒ•ãƒ©ã‚°å®šæ•°ã¯ã€:class:`enum.IntFlag` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚ã‚‹ :class:`RegexFlag` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/re.rst:602
msgid ""
"Compile a regular expression pattern into a :ref:`regular expression object "
"<re-objects>`, which can be used for matching using its "
":func:`~Pattern.match`, :func:`~Pattern.search` and other methods, described"
" below."
msgstr ""
"æ­£è¦è¡¨ç¾ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ :ref:`æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <re-objects>` ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã€ä»¥ä¸‹ã«è¿°ã¹ã‚‹ "
":func:`~Pattern.match` ã€ :func:`~Pattern.search` "
"ãã®ä»–ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦ãƒãƒƒãƒãƒ³ã‚°ã«ä½¿ãˆã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../library/re.rst:607
msgid ""
"The expression's behaviour can be modified by specifying a *flags* value. "
"Values can be any of the following variables, combined using bitwise OR (the"
" ``|`` operator)."
msgstr ""
"å¼ã®æŒ™å‹•ã¯ *flags* ã®å€¤ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã§åŠ æ¸›ã§ãã¾ã™ã€‚å€¤ã¯ä»¥ä¸‹ã®å¤‰æ•°ã®ã†ã¡ä»»æ„ã®ã‚‚ã®ã‚’ã€ãƒ“ãƒƒãƒˆå˜ä½ OR ( ``|`` æ¼”ç®—å­) "
"ã§çµ„ã¿åˆã‚ã›ãŸã‚‚ã®ã§ã™ã€‚"

#: ../../library/re.rst:611
msgid "The sequence ::"
msgstr "ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ ::"

#: ../../library/re.rst:616
msgid "is equivalent to ::"
msgstr "ã¯ã€ä»¥ä¸‹ã¨åŒç­‰ã§ã™ ::"

#: ../../library/re.rst:620
msgid ""
"but using :func:`re.compile` and saving the resulting regular expression "
"object for reuse is more efficient when the expression will be used several "
"times in a single program."
msgstr ""
"ãŒã€ :func:`re.compile` "
"ã‚’ä½¿ã„ã€çµæœã®æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¿å­˜ã—ã¦å†åˆ©ç”¨ã™ã‚‹ã»ã†ãŒã€ä¸€ã¤ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ãã®è¡¨ç¾ã‚’ä½•å›ã‚‚ä½¿ã†ã¨ãã«åŠ¹ç‡çš„ã§ã™ã€‚"

#: ../../library/re.rst:626
msgid ""
"The compiled versions of the most recent patterns passed to "
":func:`re.compile` and the module-level matching functions are cached, so "
"programs that use only a few regular expressions at a time needn't worry "
"about compiling regular expressions."
msgstr ""
":func:`re.compile` "
"ã‚„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«ã®ãƒãƒƒãƒãƒ³ã‚°é–¢æ•°ã«æ¸¡ã•ã‚ŒãŸæœ€æ–°ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿ã®ã‚‚ã®ãŒã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚Œã‚‹ã®ã§ã€ä¸€åº¦ã«æ­£è¦è¡¨ç¾ã‚’å°‘ã—ã—ã‹ä½¿ã‚ãªã„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã¯æ­£è¦è¡¨ç¾ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:635
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` and "
"``\\S`` perform ASCII-only matching instead of full Unicode matching.  This "
"is only meaningful for Unicode patterns, and is ignored for byte patterns. "
"Corresponds to the inline flag ``(?a)``."
msgstr ""
"``\\w`` ã€``\\W`` ã€``\\b`` ã€``\\B`` ã€``\\d`` ã€``\\D`` ã€``\\s`` ã€ãŠã‚ˆã³ ``\\S`` "
"ã«ã€å®Œå…¨ãª Unicode ãƒãƒƒãƒãƒ³ã‚°ã§ã¯ãªã ASCII é™å®šãƒãƒƒãƒãƒ³ã‚°ã‚’è¡Œã‚ã›ã¾ã™ã€‚ã“ã‚Œã¯ Unicode "
"ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã®ã¿æ„å‘³ãŒã‚ã‚Šã€ãƒã‚¤ãƒˆåˆ—ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒ•ãƒ©ã‚°ã® ``(?a)`` ã«ç›¸å½“ã—ã¾ã™ã€‚"

#: ../../library/re.rst:640
msgid ""
"Note that for backward compatibility, the :const:`re.U` flag still exists "
"(as well as its synonym :const:`re.UNICODE` and its embedded counterpart "
"``(?u)``), but these are redundant in Python 3 since matches are Unicode by "
"default for strings (and Unicode matching isn't allowed for bytes)."
msgstr ""
"å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã€:const:`re.U` ãƒ•ãƒ©ã‚° (ã¨åŒç¾©ã® :const:`re.UNICODE` ãŠã‚ˆã³åŸ‹ã‚è¾¼ã¿ã§ä½¿ç”¨ã™ã‚‹ ``(?u)``) "
"ã¯ã¾ã å­˜åœ¨ã—ã¾ã™ãŒã€Python 3 ã§ã¯æ–‡å­—åˆ—ã®ãƒãƒƒãƒãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ Unicode (ãã—ã¦ãƒã‚¤ãƒˆåˆ—ã§ã¯ Unicode ãƒãƒƒãƒãƒ³ã‚°ãŒæ‰±ãˆãªã„) "
"ãªã®ã§å†—é•·ã§ã™ã€‚"

#: ../../library/re.rst:649
msgid ""
"Display debug information about compiled expression. No corresponding inline"
" flag."
msgstr "ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿è¡¨ç¾ã«é–¢ã™ã‚‹ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚ç›¸å½“ã™ã‚‹ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒ•ãƒ©ã‚°ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:656
msgid ""
"Perform case-insensitive matching; expressions like ``[A-Z]`` will also "
"match lowercase letters.  Full Unicode matching (such as ``Ãœ`` matching "
"``Ã¼``) also works unless the :const:`re.ASCII` flag is used to disable non-"
"ASCII matches.  The current locale does not change the effect of this flag "
"unless the :const:`re.LOCALE` flag is also used. Corresponds to the inline "
"flag ``(?i)``."
msgstr ""
"å¤§æ–‡å­—ãƒ»å°æ–‡å­—ã‚’åŒºåˆ¥ã—ãªã„ãƒãƒƒãƒãƒ³ã‚°ã‚’å®Ÿè¡Œã•ã›ã¾ã™ã€‚ ``[A-Z]`` ã®ã‚ˆã†ãªè¡¨ç¾ã¯å°æ–‡å­—ã«ã‚‚ãƒãƒƒãƒã—ã¾ã™ã€‚ :const:`re.ASCII` "
"ãƒ•ãƒ©ã‚°ãŒä½¿ã‚ã‚Œã¦é ASCII ãƒãƒƒãƒãŒç„¡åŠ¹åŒ–ã•ã‚Œã¦ã„ãªã„é™ã‚Šã€å®Œå…¨ãª Unicode ãƒãƒƒãƒãƒ³ã‚° (ä¾‹ãˆã° ``Ãœ`` ãŒ ``Ã¼`` ã«ãƒãƒƒãƒã™ã‚‹)"
" ã‚‚æœ‰åŠ¹ã§ã™ã€‚ :const:`re.LOCALE` ãƒ•ãƒ©ã‚°ãŒå…±ã«ä½¿ã‚ã‚Œã¦ã„ãªã„é™ã‚Šã€ç¾åœ¨ã®ãƒ­ã‚±ãƒ¼ãƒ«ã¯å¤‰æ›´ã•ã‚Œã¾ã›ã‚“ã€‚ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒ•ãƒ©ã‚°ã® "
"``(?i)`` ã«ç›¸å½“ã—ã¾ã™ã€‚"

#: ../../library/re.rst:663
msgid ""
"Note that when the Unicode patterns ``[a-z]`` or ``[A-Z]`` are used in "
"combination with the :const:`IGNORECASE` flag, they will match the 52 ASCII "
"letters and 4 additional non-ASCII letters: 'Ä°' (U+0130, Latin capital "
"letter I with dot above), 'Ä±' (U+0131, Latin small letter dotless i), 'Å¿' "
"(U+017F, Latin small letter long s) and 'â„ª' (U+212A, Kelvin sign). If the "
":const:`ASCII` flag is used, only letters 'a' to 'z' and 'A' to 'Z' are "
"matched."
msgstr ""
"Unicode ãƒ‘ã‚¿ãƒ¼ãƒ³ ``[a-z]`` ã¾ãŸã¯ ``[A-Z]`` ãŒ :const:`IGNORECASE` ãƒ•ãƒ©ã‚°ã¨ã‚ã‚ã›ã¦ä½¿ã‚ã‚ŒãŸã¨ãã€52"
" ã® ASCII æ–‡å­—ã«åŠ ãˆã¦ 4 ã®é ASCII æ–‡å­— 'Ä°' (U+0130, Latin capital letter I with dot "
"above) ã€ 'Ä±' (U+0131, Latin small letter dotless i) ã€ 'Å¿' (U+017F, Latin "
"small letter long s) ãŠã‚ˆã³ 'â„ª' (U+212A, Kelvin sign) ã«ãƒãƒƒãƒã™ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ "
":const:`ASCII` ãƒ•ãƒ©ã‚°ãŒä½¿ã‚ã‚Œã¦ã„ã‚‹ãªã‚‰ã€æ–‡å­— 'a' ã‹ã‚‰ 'z' ãŠã‚ˆã³ 'A' ã‹ã‚‰ 'Z' ã«ã®ã¿ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/re.rst:674
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale.  This flag can be used only with bytes "
"patterns.  The use of this flag is discouraged as the locale mechanism is "
"very unreliable, it only handles one \"culture\" at a time, and it only "
"works with 8-bit locales.  Unicode matching is already enabled by default in"
" Python 3 for Unicode (str) patterns, and it is able to handle different "
"locales/languages. Corresponds to the inline flag ``(?L)``."
msgstr ""
"``\\w`` ã€ ``\\W`` ã€ ``\\b`` ã€ ``\\B`` "
"ãŠã‚ˆã³å¤§æ–‡å­—ãƒ»å°æ–‡å­—ã‚’åŒºåˆ¥ã—ãªã„ãƒãƒƒãƒãƒ³ã‚°ã‚’ã€ç¾åœ¨ã®ãƒ­ã‚±ãƒ¼ãƒ«ã«ä¾å­˜ã•ã›ã¾ã™ã€‚ãƒ­ã‚±ãƒ¼ãƒ«ã®ä»•çµ„ã¿ã¯ä¿¡é ¼ã§ããšã€ä¸€åº¦ã«ä¸€ã¤ã® \"æ–‡åŒ–\" ã—ã‹æ‰±ãˆãšã€ 8 "
"ãƒ“ãƒƒãƒˆãƒ­ã‚±ãƒ¼ãƒ«ã§ã—ã‹åƒã‹ãªã„ã®ã§ã€ã“ã®ãƒ•ãƒ©ã‚°ã‚’ä½¿ã†ã“ã¨ã¯æ¨å¥¨ã•ã‚Œã¾ã›ã‚“ã€‚Python 3 ã«ãŠã„ã¦ Unicode (str) ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã¯ "
"Unicode ãƒãƒƒãƒãƒ³ã‚°ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã™ã§ã«æœ‰åŠ¹ã«ã•ã‚Œã¦ã„ã¦ã€ç•°ãªã‚‹ãƒ­ã‚±ãƒ¼ãƒ«ã‚„è¨€èªã‚’æ‰±ãˆã¾ã™ã€‚ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒ•ãƒ©ã‚°ã® ``(?L)`` ã«ç›¸å½“ã—ã¾ã™ã€‚"

#: ../../library/re.rst:683
msgid ""
":const:`re.LOCALE` can be used only with bytes patterns and is not "
"compatible with :const:`re.ASCII`."
msgstr ":const:`re.LOCALE` ã¯ãƒã‚¤ãƒˆåˆ—ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã®ã¿ä½¿ãˆã€:const:`re.ASCII` ã¨äº’æ›ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:687
msgid ""
"Compiled regular expression objects with the :const:`re.LOCALE` flag no "
"longer depend on the locale at compile time.  Only the locale at matching "
"time affects the result of matching."
msgstr ""
":const:`re.LOCALE` "
"ãƒ•ãƒ©ã‚°ãŒã‚ã‚‹ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã®ãƒ­ã‚±ãƒ¼ãƒ«ã«ä¾å­˜ã—ãªããªã‚Šã¾ã—ãŸã€‚ãƒãƒƒãƒãƒ³ã‚°æ™‚ã®ãƒ­ã‚±ãƒ¼ãƒ«ã®ã¿ãŒãƒãƒƒãƒãƒ³ã‚°ã®çµæœã«å½±éŸ¿ã—ã¾ã™ã€‚"

#: ../../library/re.rst:696
msgid ""
"When specified, the pattern character ``'^'`` matches at the beginning of "
"the string and at the beginning of each line (immediately following each "
"newline); and the pattern character ``'$'`` matches at the end of the string"
" and at the end of each line (immediately preceding each newline).  By "
"default, ``'^'`` matches only at the beginning of the string, and ``'$'`` "
"only at the end of the string and immediately before the newline (if any) at"
" the end of the string. Corresponds to the inline flag ``(?m)``."
msgstr ""
"æŒ‡å®šã•ã‚Œã¦ã„ã‚‹ã¨ã€ãƒ‘ã‚¿ãƒ¼ãƒ³æ–‡å­— ``'^'`` ã¯æ–‡å­—åˆ—ã®å…ˆé ­ã§ã€ãŠã‚ˆã³å„è¡Œã®å…ˆé ­ (å„æ”¹è¡Œã®ç›´å¾Œ) ã§ã€ãƒãƒƒãƒã—ã¾ã™ã€‚ãã—ã¦ãƒ‘ã‚¿ãƒ¼ãƒ³æ–‡å­— "
"``'$'`` ã¯æ–‡å­—åˆ—ã®æœ«å°¾ã§ã€ãŠã‚ˆã³å„è¡Œã®æœ«å°¾ (å„æ”¹è¡Œã®ç›´å‰) ã§ã€ãƒãƒƒãƒã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ ``'^'`` "
"ã¯æ–‡å­—åˆ—ã®å…ˆé ­ã§ã®ã¿ã€``'$'`` ã¯æ–‡å­—åˆ—ã®æœ«å°¾ãŠã‚ˆã³æ–‡å­—åˆ—ã®æœ«å°¾ã®æ”¹è¡Œ (ã‚‚ã—ã‚ã‚Œã°) ã®ç›´å‰ã§ã®ã¿ãƒãƒƒãƒã—ã¾ã™ã€‚ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒ•ãƒ©ã‚°ã® "
"``(?m)`` ã«ç›¸å½“ã—ã¾ã™ã€‚"

#: ../../library/re.rst:708
msgid ""
"Make the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline. "
"Corresponds to the inline flag ``(?s)``."
msgstr ""
"``'.'`` ç‰¹æ®Šæ–‡å­—ã‚’ã€æ”¹è¡Œã‚’å«ã‚€ã‚ã‚‰ã‚†ã‚‹æ–‡å­—ã«ãƒãƒƒãƒã•ã›ã¾ã™ã€‚ã“ã®ãƒ•ãƒ©ã‚°ãŒãªã‘ã‚Œã°ã€``'.'`` ã¯ã€æ”¹è¡Œ *ä»¥å¤–ã®* "
"ã‚ã‚‰ã‚†ã‚‹æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒ•ãƒ©ã‚°ã® ``(?s)`` ã«ç›¸å½“ã—ã¾ã™ã€‚"

#: ../../library/re.rst:718
msgid ""
"This flag allows you to write regular expressions that look nicer and are "
"more readable by allowing you to visually separate logical sections of the "
"pattern and add comments. Whitespace within the pattern is ignored, except "
"when in a character class, or when preceded by an unescaped backslash, or "
"within tokens like ``*?``, ``(?:`` or ``(?P<...>``. When a line contains a "
"``#`` that is not in a character class and is not preceded by an unescaped "
"backslash, all characters from the leftmost such ``#`` through the end of "
"the line are ignored."
msgstr ""
"ã“ã®ãƒ•ãƒ©ã‚°ã¯æ­£è¦è¡¨ç¾ã‚’ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ã®è«–ç†çš„ãªç¯€ã‚’è¦–è¦šçš„ã«åˆ†å‰²ã—ã€ã‚³ãƒ¡ãƒ³ãƒˆã‚’åŠ ãˆã‚‹ã“ã¨ã§ã€è¦‹ãŸç›®ã‚ˆãèª­ã¿ã‚„ã™ãæ›¸ã‘ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ãƒ‘ã‚¿ãƒ¼ãƒ³ä¸­ã®ç©ºç™½ã¯ã€æ–‡å­—ã‚¯ãƒ©ã‚¹ä¸­ã«ã‚ã‚‹ã¨ãã¨ã€ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚Œã¦ã„ãªã„ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã®å¾Œã«ã‚ã‚‹ã¨ãã¨ã€"
" ``*?`` ã€ ``(?:`` ã‚„ ``(?P<...>`` "
"ã®ã‚ˆã†ãªãƒˆãƒ¼ã‚¯ãƒ³ä¸­ã‚’é™¤ã„ã¦ç„¡è¦–ã•ã‚Œã¾ã™ã€‚ã‚ã‚‹è¡ŒãŒæ–‡å­—ã‚¯ãƒ©ã‚¹ä¸­ã§ã‚‚ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚Œã¦ã„ãªã„ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã®å¾Œã§ã‚‚ãªã„ ``#`` "
"ã‚’å«ã‚€ãªã‚‰ã€ä¸€ç•ªå·¦ã®ãã®ã‚ˆã†ãª ``#`` ã‹ã‚‰è¡Œæœ«ã¾ã§ã®å…¨ã¦ã®æ–‡å­—ã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:727
msgid ""
"This means that the two following regular expression objects that match a "
"decimal number are functionally equal::"
msgstr "ã¤ã¾ã‚Šã€10 é€²æ•°å­—ã«ãƒãƒƒãƒã™ã‚‹ä¸‹è¨˜ã®ãµãŸã¤ã®æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€æ©Ÿèƒ½çš„ã«ç­‰ä¾¡ã§ã™::"

#: ../../library/re.rst:735
msgid "Corresponds to the inline flag ``(?x)``."
msgstr "ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒ•ãƒ©ã‚°ã® ``(?x)`` ã«ç›¸å½“ã—ã¾ã™ã€‚"

#: ../../library/re.rst:740
msgid ""
"Scan through *string* looking for the first location where the regular "
"expression *pattern* produces a match, and return a corresponding "
":ref:`match object <match-objects>`.  Return ``None`` if no position in the "
"string matches the pattern; note that this is different from finding a zero-"
"length match at some point in the string."
msgstr ""
"*string* ã‚’èµ°æŸ»ã—ã€æ­£è¦è¡¨ç¾ *pattern* ãŒãƒãƒƒãƒã‚’ç”Ÿã˜ã•ã›ã‚‹æœ€åˆã®å ´æ‰€ã‚’æ¢ã—ã¦ã€å¯¾å¿œã™ã‚‹ :ref:`ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ "
"<match-objects>` ã‚’è¿”ã—ã¾ã™ã€‚æ–‡å­—åˆ—å†…ã«ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãƒãƒƒãƒã™ã‚‹å ´æ‰€ãŒãªã‘ã‚Œã° ``None`` ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯æ–‡å­—åˆ—ã®ã©ã“ã‹ã§é•·ã• 0"
" ã®ãƒãƒƒãƒã‚’è¦‹ã¤ã‘ã‚‹ã®ã¨ã¯ç•°ãªã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/re.rst:749
msgid ""
"If zero or more characters at the beginning of *string* match the regular "
"expression *pattern*, return a corresponding :ref:`match object <match-"
"objects>`.  Return ``None`` if the string does not match the pattern; note "
"that this is different from a zero-length match."
msgstr ""
"*string* ã®å…ˆé ­ã§ 0 å€‹ä»¥ä¸Šã®æ–‡å­—ãŒæ­£è¦è¡¨ç¾ *pattern* ã«ãƒãƒƒãƒã™ã‚Œã°ã€å¯¾å¿œã™ã‚‹ :ref:`ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <match-"
"objects>` ã‚’è¿”ã—ã¾ã™ã€‚æ–‡å­—åˆ—ãŒãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãƒãƒƒãƒã—ãªã‘ã‚Œã° ``None`` ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯é•·ã• 0 "
"ã®ãƒãƒƒãƒã¨ã¯ç•°ãªã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../library/re.rst:754
msgid ""
"Note that even in :const:`MULTILINE` mode, :func:`re.match` will only match "
"at the beginning of the string and not at the beginning of each line."
msgstr ""
":const:`MULTILINE` ãƒ¢ãƒ¼ãƒ‰ã«ãŠã„ã¦ã‚‚ã€:func:`re.match` "
"ã¯å„è¡Œã®å…ˆé ­ã§ãƒãƒƒãƒã™ã‚‹ã®ã§ã¯ãªãã€æ–‡å­—åˆ—ã®å…ˆé ­ã§ã®ã¿ãƒãƒƒãƒã™ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/re.rst:757
msgid ""
"If you want to locate a match anywhere in *string*, use :func:`search` "
"instead (see also :ref:`search-vs-match`)."
msgstr ""
"*string* ä¸­ã®ã©ã“ã§ã§ã‚‚ãƒãƒƒãƒã•ã›ãŸã„ãªã‚‰ã€ä»£ã‚ã‚Šã« :func:`search` ã‚’ä½¿ã£ã¦ãã ã•ã„ (:ref:`search-vs-"
"match` ã‚‚å‚ç…§ã—ã¦ãã ã•ã„)ã€‚"

#: ../../library/re.rst:763
msgid ""
"If the whole *string* matches the regular expression *pattern*, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if the "
"string does not match the pattern; note that this is different from a zero-"
"length match."
msgstr ""
"*string* å…¨ä½“ãŒæ­£è¦è¡¨ç¾ *pattern* ã«ãƒãƒƒãƒã™ã‚‹ãªã‚‰ã€å¯¾å¿œã™ã‚‹ :ref:`ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <match-objects>` "
"ã‚’è¿”ã—ã¾ã™ã€‚æ–‡å­—åˆ—ãŒãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãƒãƒƒãƒã—ãªã„ãªã‚‰ ``None`` ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯é•·ã• 0 ã®ãƒãƒƒãƒã¨ã¯ç•°ãªã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../library/re.rst:773
msgid ""
"Split *string* by the occurrences of *pattern*.  If capturing parentheses "
"are used in *pattern*, then the text of all groups in the pattern are also "
"returned as part of the resulting list. If *maxsplit* is nonzero, at most "
"*maxsplit* splits occur, and the remainder of the string is returned as the "
"final element of the list. ::"
msgstr ""
"*string* ã‚’ã€å‡ºç¾ã—ãŸ *pattern* ã§åˆ†å‰²ã—ã¾ã™ã€‚ *pattern* "
"ä¸­ã§ã‚­ãƒ£ãƒ—ãƒãƒ£ã®ä¸¸æ‹¬å¼§ãŒä½¿ã‚ã‚Œã¦ã„ã‚Œã°ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ä¸­ã®å…¨ã¦ã®ã‚°ãƒ«ãƒ¼ãƒ—ã®ãƒ†ã‚­ã‚¹ãƒˆã‚‚çµæœã®ãƒªã‚¹ãƒˆã®ä¸€éƒ¨ã¨ã—ã¦è¿”ã•ã‚Œã¾ã™ã€‚*maxsplit* ãŒ 0 "
"ã§ãªã‘ã‚Œã°ã€åˆ†å‰²ã¯æœ€å¤§ *maxsplit* å›èµ·ã“ã‚Šã€æ®‹ã‚Šã®æ–‡å­—åˆ—ã¯ãƒªã‚¹ãƒˆã®æœ€çµ‚è¦ç´ ã¨ã—ã¦è¿”ã•ã‚Œã¾ã™ã€‚ ::"

#: ../../library/re.rst:788
msgid ""
"If there are capturing groups in the separator and it matches at the start "
"of the string, the result will start with an empty string.  The same holds "
"for the end of the string::"
msgstr ""
"ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿ä¸­ã«ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚°ãƒ«ãƒ¼ãƒ—ãŒã‚ã‚Šã€ãã‚ŒãŒæ–‡å­—åˆ—ã®å…ˆé ­ã«ãƒãƒƒãƒã™ã‚‹ãªã‚‰ã€çµæœã¯ç©ºæ–‡å­—åˆ—ã§å§‹ã¾ã‚Šã¾ã™ã€‚åŒã˜ã“ã¨ãŒæ–‡å­—åˆ—ã®æœ«å°¾ã«ã‚‚è¨€ãˆã¾ã™ã€‚"

#: ../../library/re.rst:795
msgid ""
"That way, separator components are always found at the same relative indices"
" within the result list."
msgstr "ãã†ã—ã¦ã€çµæœã®ãƒªã‚¹ãƒˆã«ãŠã„ã¦ã€ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿ã®æ§‹æˆè¦ç´ ã¯å¸¸ã«åŒã˜ç›¸å¯¾çš„ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«è¦‹ã¤ã‹ã‚Šã¾ã™ã€‚"

#: ../../library/re.rst:798
msgid ""
"Empty matches for the pattern split the string only when not adjacent to a "
"previous empty match."
msgstr "ãƒ‘ã‚¿ãƒ¼ãƒ³ã¸ã®ç©ºãƒãƒƒãƒã¯ã€ç›´å‰ã®ç©ºãƒãƒƒãƒã«éš£æ¥ã—ã¦ã„ãªã„ã¨ãã®ã¿æ–‡å­—åˆ—ã‚’åˆ†å‰²ã—ã¾ã™ã€‚"

#: ../../library/re.rst:808 ../../library/re.rst:886 ../../library/re.rst:909
msgid "Added the optional flags argument."
msgstr "ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® flags å¼•æ•°ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/re.rst:811
msgid ""
"Added support of splitting on a pattern that could match an empty string."
msgstr "ç©ºæ–‡å­—åˆ—ã«ãƒãƒƒãƒã—ã†ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã®åˆ†å‰²ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/re.rst:817
msgid ""
"Return all non-overlapping matches of *pattern* in *string*, as a list of "
"strings.  The *string* is scanned left-to-right, and matches are returned in"
" the order found.  If one or more groups are present in the pattern, return "
"a list of groups; this will be a list of tuples if the pattern has more than"
" one group.  Empty matches are included in the result."
msgstr ""
"*string* ä¸­ã® *pattern* ã«ã‚ˆã‚‹å…¨ã¦ã®é‡è¤‡ã—ãªã„ãƒãƒƒãƒã‚’ã€æ–‡å­—åˆ—ã®ãƒªã‚¹ãƒˆã¨ã—ã¦è¿”ã—ã¾ã™ã€‚ *string* "
"ã¯å·¦ã‹ã‚‰å³ã¸èµ°æŸ»ã•ã‚Œã€ãƒãƒƒãƒã¯è¦‹ã¤ã‹ã£ãŸé †ã§è¿”ã•ã‚Œã¾ã™ã€‚ãƒ‘ã‚¿ãƒ¼ãƒ³ä¸­ã« 1 "
"ã¤ä»¥ä¸Šã®ã‚°ãƒ«ãƒ¼ãƒ—ãŒã‚ã‚Œã°ã€ã‚°ãƒ«ãƒ¼ãƒ—ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ãƒ‘ã‚¿ãƒ¼ãƒ³ã«è¤‡æ•°ã®ã‚°ãƒ«ãƒ¼ãƒ—ãŒã‚ã‚Œã°ã‚¿ãƒ—ãƒ«ã®ãƒªã‚¹ãƒˆã«ãªã‚Šã¾ã™ã€‚ç©ºãƒãƒƒãƒã¯çµæœã«å«ã¾ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:823 ../../library/re.rst:834
msgid "Non-empty matches can now start just after a previous empty match."
msgstr "ç©ºã§ãªã„ãƒãƒƒãƒãŒå‰ã®ç©ºãƒãƒƒãƒã®ç›´å¾Œã‹ã‚‰å§‹ã‚ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/re.rst:829
msgid ""
"Return an :term:`iterator` yielding :ref:`match objects <match-objects>` "
"over all non-overlapping matches for the RE *pattern* in *string*.  The "
"*string* is scanned left-to-right, and matches are returned in the order "
"found.  Empty matches are included in the result."
msgstr ""
"*string* ä¸­ã®æ­£è¦è¡¨ç¾ *pattern* ã®é‡è¤‡ã—ãªã„ãƒãƒƒãƒå…¨ã¦ã«æ¸¡ã‚‹ :ref:`ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <match-objects>` ã‚’ "
"yield ã™ã‚‹ :term:`ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ <iterator>` ã‚’è¿”ã—ã¾ã™ã€‚  *string* "
"ã¯å·¦ã‹ã‚‰å³ã¸èµ°æŸ»ã•ã‚Œã€ãƒãƒƒãƒã¯è¦‹ã¤ã‹ã£ãŸé †ã§è¿”ã•ã‚Œã¾ã™ã€‚ç©ºãƒãƒƒãƒã¯çµæœã«å«ã¾ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:840
msgid ""
"Return the string obtained by replacing the leftmost non-overlapping "
"occurrences of *pattern* in *string* by the replacement *repl*.  If the "
"pattern isn't found, *string* is returned unchanged.  *repl* can be a string"
" or a function; if it is a string, any backslash escapes in it are "
"processed.  That is, ``\\n`` is converted to a single newline character, "
"``\\r`` is converted to a carriage return, and so forth.  Unknown escapes "
"such as ``\\&`` are left alone.  Backreferences, such as ``\\6``, are "
"replaced with the substring matched by group 6 in the pattern. For example::"
msgstr ""
"*string* ä¸­ã«å‡ºç¾ã™ã‚‹ä¸€ç•ªå·¦ã®é‡è¤‡ã—ãªã„ *pattern* ã‚’ç½®æ› *repl* "
"ã§ç½®æ›ã™ã‚‹ã“ã¨ã§å¾—ã‚‰ã‚Œã‚‹æ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°ã€ *string* ãŒãã®ã¾ã¾è¿”ã•ã‚Œã¾ã™ã€‚ *repl* "
"ã¯æ–‡å­—åˆ—ã¾ãŸã¯é–¢æ•°ã§ã™ã€‚ãã‚ŒãŒæ–‡å­—åˆ—ãªã‚‰ã€ãã®ä¸­ã®å…¨ã¦ã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ãŒå‡¦ç†ã•ã‚Œã¾ã™ã€‚ ``\\n`` ã¯ 1 ã¤ã®æ”¹è¡Œæ–‡å­—ã«å¤‰æ›ã•ã‚Œã€ "
"``\\r`` ã¯ã‚­ãƒ£ãƒªãƒƒã‚¸ãƒªã‚¿ãƒ¼ãƒ³ã«å¤‰æ›ã•ã‚Œã‚‹ã€ãªã©ã§ã™ã€‚ ``\\&`` ã®ã‚ˆã†ãªæœªçŸ¥ã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã¯æ®‹ã•ã‚Œã¾ã™ã€‚å¾Œæ–¹å‚ç…§ã¯ã€ä¾‹ãˆã° ``\\6`` "
"ã¯ã€ã‚°ãƒ«ãƒ¼ãƒ— 6 ãŒãƒ‘ã‚¿ãƒ¼ãƒ³ä¸­ã§ãƒãƒƒãƒã—ãŸéƒ¨åˆ†æ–‡å­—åˆ—ã§ç½®æ›ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°::"

#: ../../library/re.rst:854
msgid ""
"If *repl* is a function, it is called for every non-overlapping occurrence "
"of *pattern*.  The function takes a single :ref:`match object <match-"
"objects>` argument, and returns the replacement string.  For example::"
msgstr ""
"*repl* ãŒé–¢æ•°ã§ã‚ã‚Œã°ã€ãã‚Œã¯é‡è¤‡ã—ãªã„ *pattern* ãŒå‡ºç¾ã™ã‚‹ãŸã³ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ä¸€ã¤ã® :ref:`ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ "
"<match-objects>` å¼•æ•°ã‚’å–ã‚Šã€ç½®æ›æ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚ä¾‹ãˆã°::"

#: ../../library/re.rst:866
msgid "The pattern may be a string or a :ref:`pattern object <re-objects>`."
msgstr "ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€æ–‡å­—åˆ—ã§ã‚‚ :ref:`ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <re-objects>` ã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:868
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  If omitted or zero,"
" all occurrences will be replaced. Empty matches for the pattern are "
"replaced only when not adjacent to a previous empty match, so ``sub('x*', "
"'-', 'abxd')`` returns ``'-a-b--d-'``."
msgstr ""
"ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *count* ã¯å‡ºç¾ã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç½®æ›ã™ã‚‹æœ€å¤§ã®å›æ•°ã§ã™ã€‚ *count* ã¯éè² æ•´æ•°ã§ã™ã€‚çœç•¥ã•ã‚Œã‚‹ã‹ 0 "
"ãªã‚‰ã€å‡ºç¾ã—ãŸå…¨ã¦ãŒç½®æ›ã•ã‚Œã¾ã™ã€‚ãƒ‘ã‚¿ãƒ¼ãƒ³ã¸ã®ç©ºãƒãƒƒãƒã¯å‰ã®ç©ºãƒãƒƒãƒã«éš£æ¥ã—ã¦ã„ãªã„ã¨ãã®ã¿ç½®æ›ã•ã‚Œã‚‹ã®ã§ã€ ``sub('x*', '-', "
"'abxd')`` ã¯ ``'-a-b--d-'`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/re.rst:876
msgid ""
"In string-type *repl* arguments, in addition to the character escapes and "
"backreferences described above, ``\\g<name>`` will use the substring matched"
" by the group named ``name``, as defined by the ``(?P<name>...)`` syntax. "
"``\\g<number>`` uses the corresponding group number; ``\\g<2>`` is therefore"
" equivalent to ``\\2``, but isn't ambiguous in a replacement such as "
"``\\g<2>0``.  ``\\20`` would be interpreted as a reference to group 20, not "
"a reference to group 2 followed by the literal character ``'0'``.  The "
"backreference ``\\g<0>`` substitutes in the entire substring matched by the "
"RE."
msgstr ""
"æ–‡å­—åˆ—å‹ *repl* å¼•æ•°ã§ã¯ã€ä¸Šã§è¿°ã¹ãŸæ–‡å­—ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚„å¾Œæ–¹å‚ç…§ã«åŠ ãˆã¦ã€ ``\\g<name>`` ã¯ ``(?P<name>...)`` "
"æ§‹æ–‡ã§å®šç¾©ã•ã‚ŒãŸ ``name`` ã¨ã„ã†åå‰ã®ã‚°ãƒ«ãƒ¼ãƒ—ãŒãƒãƒƒãƒã—ãŸéƒ¨åˆ†æ–‡å­—åˆ—ã‚’ä½¿ã„ã€ ``\\g<number>`` "
"ã¯å¯¾å¿œã™ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ç•ªå·ã‚’ä½¿ã„ã¾ã™ã€‚ã‚ˆã£ã¦ ``\\g<2>`` ã¯ ``\\2`` ã¨ç­‰ä¾¡ã§ã™ãŒã€ ``\\g<2>0`` "
"ã®ã‚ˆã†ãªç½®æ›ã«ãŠã„ã¦ã‚‚æ›–æ˜§ã«ãªã‚Šã¾ã›ã‚“ã€‚ ``\\20`` ã¯ã€ã‚°ãƒ«ãƒ¼ãƒ— 20 ã¸ã®å‚ç…§ã¨ã—ã¦è§£é‡ˆã•ã‚Œã€ã‚°ãƒ«ãƒ¼ãƒ— 2 ã¸ã®å‚ç…§ã«ãƒªãƒ†ãƒ©ãƒ«æ–‡å­— "
"``'0'`` ãŒç¶šã„ãŸã‚‚ã®ã¨ã—ã¦ã¯è§£é‡ˆã•ã‚Œã¾ã›ã‚“ã€‚å¾Œæ–¹å‚ç…§ ``\\g<0>`` ã¯æ­£è¦è¡¨ç¾ã¨ãƒãƒƒãƒã—ãŸéƒ¨åˆ†æ–‡å­—åˆ—å…¨ä½“ã§ç½®ãæ›ã‚ã‚Šã¾ã™ã€‚"

#: ../../library/re.rst:889 ../../library/re.rst:912 ../../library/re.rst:1141
msgid "Unmatched groups are replaced with an empty string."
msgstr "ãƒãƒƒãƒã—ãªã‹ã£ãŸã‚°ãƒ«ãƒ¼ãƒ—ã¯ç©ºæ–‡å­—åˆ—ã«ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:892
msgid ""
"Unknown escapes in *pattern* consisting of ``'\\'`` and an ASCII letter now "
"are errors."
msgstr "*pattern* ä¸­ã« ``'\\'`` ã¨ ASCII æ–‡å­—ã‹ã‚‰ãªã‚‹æœªçŸ¥ã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ãŒã‚ã‚‹ã¨ã€ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/re.rst:896
msgid ""
"Unknown escapes in *repl* consisting of ``'\\'`` and an ASCII letter now are"
" errors."
msgstr "*repl* ä¸­ã« ``'\\'`` ã¨ ASCII æ–‡å­—ã‹ã‚‰ãªã‚‹æœªçŸ¥ã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ãŒã‚ã‚‹ã¨ã€ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/re.rst:900
msgid ""
"Empty matches for the pattern are replaced when adjacent to a previous non-"
"empty match."
msgstr "ãƒ‘ã‚¿ãƒ¼ãƒ³ã¸ã®ç©ºãƒãƒƒãƒã¯å‰ã®ç©ºã§ãªã„ãƒãƒƒãƒã«éš£æ¥ã—ã¦ã„ã‚‹ã¨ãç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:906
msgid ""
"Perform the same operation as :func:`sub`, but return a tuple ``(new_string,"
" number_of_subs_made)``."
msgstr ""
":func:`sub` ã¨åŒã˜æ“ä½œã‚’è¡Œã„ã¾ã™ãŒã€ã‚¿ãƒ—ãƒ« ``(new_stringã€ number_of_subs_made)`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/re.rst:918
msgid ""
"Escape special characters in *pattern*. This is useful if you want to match "
"an arbitrary literal string that may have regular expression metacharacters "
"in it.  For example::"
msgstr "*pattern* ä¸­ã®ç‰¹æ®Šæ–‡å­—ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã—ã¾ã™ã€‚ã“ã‚Œã¯æ­£è¦è¡¨ç¾ãƒ¡ã‚¿æ–‡å­—ã‚’å«ã¿ã†ã‚‹ä»»æ„ã®ãƒªãƒ†ãƒ©ãƒ«æ–‡å­—åˆ—ã«ãƒãƒƒãƒã—ãŸã„æ™‚ã«ä¾¿åˆ©ã§ã™ã€‚"

#: ../../library/re.rst:933
msgid ""
"This functions must not be used for the replacement string in :func:`sub` "
"and :func:`subn`, only backslashes should be escaped.  For example::"
msgstr ""
"ã“ã®é–¢æ•°ã¯ã€ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã®ã¿ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã™ã‚‹ã¹ã :func:`sub` ãŠã‚ˆã³ :func:`subn` "
"ã«ãŠã‘ã‚‹ç½®æ›æ–‡å­—åˆ—ã«ä½¿ã‚ã‚Œã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ä¾‹ãˆã°::"

#: ../../library/re.rst:941
msgid "The ``'_'`` character is no longer escaped."
msgstr "``'_'`` æ–‡å­—ãŒã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚Œãªããªã‚Šã¾ã—ãŸã€‚"

#: ../../library/re.rst:944
msgid ""
"Only characters that can have special meaning in a regular expression are "
"escaped."
msgstr "æ­£è¦è¡¨ç¾ä¸­ã§ç‰¹æ®Šãªæ„å‘³ã‚’æŒã¡ã†ã‚‹æ–‡å­—ã®ã¿ãŒã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:951
msgid "Clear the regular expression cache."
msgstr "æ­£è¦è¡¨ç¾ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã€‚"

#: ../../library/re.rst:956
msgid ""
"Exception raised when a string passed to one of the functions here is not a "
"valid regular expression (for example, it might contain unmatched "
"parentheses) or when some other error occurs during compilation or matching."
"  It is never an error if a string contains no match for a pattern.  The "
"error instance has the following additional attributes:"
msgstr ""
"ã“ã“ã®é–¢æ•°ã®ã„ãšã‚Œã‹ã«æ¸¡ã•ã‚ŒãŸæ–‡å­—åˆ—ãŒæœ‰åŠ¹ãªæ­£è¦è¡¨ç¾ã§ã¯ãªã„ (ä¾‹: æ‹¬å¼§ãŒå¯¾ã«ãªã£ã¦ã„ãªã„) "
"ã¨ãã€ã¾ãŸã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚„ãƒãƒƒãƒãƒ³ã‚°ã®éš›ã«ãã®ä»–ãªã‚“ã‚‰ã‹ã®ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã«é€å‡ºã•ã‚Œã‚‹ä¾‹å¤–ã§ã™ã€‚æ–‡å­—åˆ—ã«ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ãƒãƒƒãƒã™ã‚‹éƒ¨åˆ†ãŒãªãã¦ã‚‚ã€ãã‚Œã¯ã‚¨ãƒ©ãƒ¼ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚¨ãƒ©ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ã¯ã€æ¬¡ã®ã‚ˆã†ãªè¿½åŠ ã®å±æ€§ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/re.rst:964
msgid "The unformatted error message."
msgstr "ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã•ã‚Œã¦ã„ãªã„ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§ã™ã€‚"

#: ../../library/re.rst:968
msgid "The regular expression pattern."
msgstr "æ­£è¦è¡¨ç¾ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚"

#: ../../library/re.rst:972
msgid "The index in *pattern* where compilation failed (may be ``None``)."
msgstr "*pattern* ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã«å¤±æ•—ã—ãŸå ´æ‰€ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã™ (``None`` ã®å ´åˆã‚‚ã‚ã‚Šã¾ã™)ã€‚"

#: ../../library/re.rst:976
msgid "The line corresponding to *pos* (may be ``None``)."
msgstr "*pos* ã«å¯¾å¿œã™ã‚‹è¡Œã§ã™ (``None`` ã®å ´åˆã‚‚ã‚ã‚Šã¾ã™)ã€‚"

#: ../../library/re.rst:980
msgid "The column corresponding to *pos* (may be ``None``)."
msgstr "*pos* ã«å¯¾å¿œã™ã‚‹åˆ—ã§ã™ (``None`` ã®å ´åˆã‚‚ã‚ã‚Šã¾ã™)ã€‚"

#: ../../library/re.rst:982
msgid "Added additional attributes."
msgstr "è¿½åŠ ã®å±æ€§ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/re.rst:988
msgid "Regular Expression Objects"
msgstr "æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/re.rst:990
msgid ""
"Compiled regular expression objects support the following methods and "
"attributes:"
msgstr "ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨å±æ€§ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™:"

#: ../../library/re.rst:995
msgid ""
"Scan through *string* looking for the first location where this regular "
"expression produces a match, and return a corresponding :ref:`match object "
"<match-objects>`.  Return ``None`` if no position in the string matches the "
"pattern; note that this is different from finding a zero-length match at "
"some point in the string."
msgstr ""
"*string* ã‚’èµ°æŸ»ã—ã€ã“ã®æ­£è¦è¡¨ç¾ãŒãƒãƒƒãƒã‚’ç”Ÿã˜ã•ã›ã‚‹æœ€åˆã®å ´æ‰€ã‚’æ¢ã—ã¦ã€å¯¾å¿œã™ã‚‹ :ref:`ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <match-"
"objects>` ã‚’è¿”ã—ã¾ã™ã€‚æ–‡å­—åˆ—å†…ã«ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãƒãƒƒãƒã™ã‚‹å ´æ‰€ãŒãªã‘ã‚Œã° ``None`` ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯æ–‡å­—åˆ—å†…ã®ã‚ã‚‹å ´æ‰€ã§é•·ã•ãŒ 0 "
"ã®ãƒãƒƒãƒãŒè¦‹ã¤ã‹ã£ãŸå ´åˆã¨ã¯ç•°ãªã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/re.rst:1001
msgid ""
"The optional second parameter *pos* gives an index in the string where the "
"search is to start; it defaults to ``0``.  This is not completely equivalent"
" to slicing the string; the ``'^'`` pattern character matches at the real "
"beginning of the string and at positions just after a newline, but not "
"necessarily at the index where the search is to start."
msgstr ""
"ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ç¬¬äºŒå¼•æ•° *pos* ã¯ã€æ–‡å­—åˆ—ã®ã©ã“ã‹ã‚‰æ¢ã—å§‹ã‚ã‚‹ã‹ã‚’æŒ‡å®šã™ã‚‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ 0 "
"ã§ã™ã€‚ã“ã‚Œã¯æ–‡å­—åˆ—ã®ã‚¹ãƒ©ã‚¤ã‚¹ã¨å®Œå…¨ã«ã¯åŒã˜ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ‘ã‚¿ãƒ¼ãƒ³æ–‡å­— ``'^'`` "
"ã¯æœ¬å½“ã®æ–‡å­—åˆ—ã®å…ˆé ­ã¨æ”¹è¡Œã®ç›´å¾Œã§ãƒãƒƒãƒã—ã¾ã™ãŒã€æ¤œç´¢ã‚’é–‹å§‹ã™ã‚‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ãƒãƒƒãƒã™ã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/re.rst:1007
msgid ""
"The optional parameter *endpos* limits how far the string will be searched; "
"it will be as if the string is *endpos* characters long, so only the "
"characters from *pos* to ``endpos - 1`` will be searched for a match.  If "
"*endpos* is less than *pos*, no match will be found; otherwise, if *rx* is a"
" compiled regular expression object, ``rx.search(string, 0, 50)`` is "
"equivalent to ``rx.search(string[:50], 0)``. ::"
msgstr ""
"ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¼•æ•° *endpos* ã¯æ–‡å­—åˆ—ãŒã©ã“ã¾ã§æ¤œç´¢ã•ã‚Œã‚‹ã‹ã‚’åˆ¶é™ã—ã¾ã™ã€‚æ–‡å­—åˆ—ã®é•·ã•ãŒ *endpos* "
"æ–‡å­—ã ã£ãŸã‹ã®ã‚ˆã†ã«ãªã‚‹ã®ã§ã€*pos* ã‹ã‚‰ ``endpos - 1`` ã®æ–‡å­—ã«å¯¾ã—ã¦ã ã‘ãƒãƒƒãƒã‚’æ¢ã—ã¾ã™ã€‚*endpos* ãŒ *pos* "
"ã‚ˆã‚Šã‚‚å°ã•ã„ã¨ã€ãƒãƒƒãƒã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãã†ã§ãªã‘ã‚Œã°ã€*rx* ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦ã€``rx.search(string, "
"0, 50)`` ã¯ ``rx.search(string[:50], 0)`` ã¨ç­‰ä¾¡ã§ã™ã€‚ ::"

#: ../../library/re.rst:1022
msgid ""
"If zero or more characters at the *beginning* of *string* match this regular"
" expression, return a corresponding :ref:`match object <match-objects>`. "
"Return ``None`` if the string does not match the pattern; note that this is "
"different from a zero-length match."
msgstr ""
"*string* ã® *å…ˆé ­* ã§ 0 æ–‡å­—ä»¥ä¸ŠãŒã“ã®æ­£è¦è¡¨ç¾ã¨ãƒãƒƒãƒã™ã‚‹ãªã‚‰ã€å¯¾å¿œã™ã‚‹ :ref:`ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <match-"
"objects>` ã‚’è¿”ã—ã¾ã™ã€‚æ–‡å­—åˆ—ãŒãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãƒãƒƒãƒã—ãªã‘ã‚Œã° ``None`` ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯é•·ã• 0 "
"ã®ãƒãƒƒãƒã¨ã¯ç•°ãªã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/re.rst:1027 ../../library/re.rst:1045
msgid ""
"The optional *pos* and *endpos* parameters have the same meaning as for the "
":meth:`~Pattern.search` method. ::"
msgstr "ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *pos* ãŠã‚ˆã³ *endpos* å¼•æ•°ã¯ :meth:`~Pattern.search` ãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚‚ã®ã¨åŒã˜æ„å‘³ã§ã™ã€‚"

#: ../../library/re.rst:1035
msgid ""
"If you want to locate a match anywhere in *string*, use "
":meth:`~Pattern.search` instead (see also :ref:`search-vs-match`)."
msgstr ""
"*string* ä¸­ã®ã©ã“ã§ã§ã‚‚ãƒãƒƒãƒã•ã›ãŸã„ãªã‚‰ã€ä»£ã‚ã‚Šã« :meth:`~Pattern.search` ã‚’ä½¿ã£ã¦ãã ã•ã„ (:ref"
":`search-vs-match` ã‚‚å‚ç…§ã—ã¦ãã ã•ã„)ã€‚"

#: ../../library/re.rst:1041
msgid ""
"If the whole *string* matches this regular expression, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if the "
"string does not match the pattern; note that this is different from a zero-"
"length match."
msgstr ""
"*string* å…¨ä½“ãŒã“ã®æ­£è¦è¡¨ç¾ã«ãƒãƒƒãƒã™ã‚Œã°ã€å¯¾å¿œã™ã‚‹ :ref:`ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <match-objects>` "
"ã‚’è¿”ã—ã¾ã™ã€‚æ–‡å­—åˆ—ãŒãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãƒãƒƒãƒã—ãªã‘ã‚Œã° ``None`` ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯é•·ã• 0 ã®ãƒãƒƒãƒã¨ã¯ç•°ãªã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/re.rst:1059
msgid "Identical to the :func:`split` function, using the compiled pattern."
msgstr ":func:`split` é–¢æ•°ã«ã“ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ã†ã®ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/re.rst:1064
msgid ""
"Similar to the :func:`findall` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""
":func:`findall` é–¢æ•°ã«ã“ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ã†ã®ã¨ä¼¼ã¦ã„ã¾ã™ãŒã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *pos* ãŠã‚ˆã³ *endpos* å¼•æ•°ã§ "
":meth:`search` ã®ã‚ˆã†ã«æ¤œç´¢ç¯„å›²ã‚’åˆ¶é™ã§ãã¾ã™ã€‚"

#: ../../library/re.rst:1071
msgid ""
"Similar to the :func:`finditer` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""
":func:`finditer` é–¢æ•°ã«ã“ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ã†ã®ã¨ä¼¼ã¦ã„ã¾ã™ãŒã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *pos* ãŠã‚ˆã³ *endpos* å¼•æ•°ã§ "
":meth:`search` ã®ã‚ˆã†ã«æ¤œç´¢ç¯„å›²ã‚’åˆ¶é™ã§ãã¾ã™ã€‚"

#: ../../library/re.rst:1078
msgid "Identical to the :func:`sub` function, using the compiled pattern."
msgstr ":func:`sub` é–¢æ•°ã«ã“ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ã†ã®ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/re.rst:1083
msgid "Identical to the :func:`subn` function, using the compiled pattern."
msgstr ":func:`subn` é–¢æ•°ã«ã“ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ã†ã®ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/re.rst:1088
msgid ""
"The regex matching flags.  This is a combination of the flags given to "
":func:`.compile`, any ``(?...)`` inline flags in the pattern, and implicit "
"flags such as :data:`UNICODE` if the pattern is a Unicode string."
msgstr ""
"æ­£è¦è¡¨ç¾ã®ãƒãƒƒãƒãƒ³ã‚°ãƒ•ãƒ©ã‚°ã§ã™ã€‚ã“ã‚Œã¯ :func:`.compile` ã«ä¸ãˆã‚‰ã‚ŒãŸãƒ•ãƒ©ã‚°ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ä¸­ã® ``(?...)`` "
"ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒ•ãƒ©ã‚°ã€ãŠã‚ˆã³ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒ Unicode æ–‡å­—åˆ—ã ã£ãŸæ™‚ã® :data:`UNICODE` ã®ã‚ˆã†ãªæš—é»™ã®ãƒ•ãƒ©ã‚°ã®çµ„ã¿åˆã‚ã›ã§ã™ã€‚"

#: ../../library/re.rst:1095
msgid "The number of capturing groups in the pattern."
msgstr "ãƒ‘ã‚¿ãƒ¼ãƒ³ä¸­ã®ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚°ãƒ«ãƒ¼ãƒ—ã®æ•°ã§ã™ã€‚"

#: ../../library/re.rst:1100
msgid ""
"A dictionary mapping any symbolic group names defined by ``(?P<id>)`` to "
"group numbers.  The dictionary is empty if no symbolic groups were used in "
"the pattern."
msgstr ""
"``(?P<id>)`` "
"ã§å®šç¾©ã•ã‚ŒãŸã‚ã‚‰ã‚†ã‚‹ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ã‚°ãƒ«ãƒ¼ãƒ—åã‚’ã‚°ãƒ«ãƒ¼ãƒ—ç•ªå·ã¸å†™åƒã™ã‚‹è¾æ›¸ã§ã™ã€‚ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ã‚°ãƒ«ãƒ¼ãƒ—ãŒãƒ‘ã‚¿ãƒ¼ãƒ³ä¸­ã§å…¨ãä½¿ã‚ã‚Œã¦ã„ãªã‘ã‚Œã°ã€ã“ã®è¾æ›¸ã¯ç©ºã§ã™ã€‚"

#: ../../library/re.rst:1107
msgid "The pattern string from which the pattern object was compiled."
msgstr "ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸå…ƒã®ãƒ‘ã‚¿ãƒ¼ãƒ³æ–‡å­—åˆ—ã§ã™ã€‚"

#: ../../library/re.rst:1110
msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Compiled "
"regular expression objects are considered atomic."
msgstr ""
":func:`copy.copy` ãŠã‚ˆã³ :func:`copy.deepcopy` "
"ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚¢ãƒˆãƒŸãƒƒã‚¯ã§ã‚ã‚‹ã¨è¦‹ãªã•ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:1118
msgid "Match Objects"
msgstr "ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/re.rst:1120
msgid ""
"Match objects always have a boolean value of ``True``. Since "
":meth:`~Pattern.match` and :meth:`~Pattern.search` return ``None`` when "
"there is no match, you can test whether there was a match with a simple "
"``if`` statement::"
msgstr ""
"ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ–ãƒ¼ãƒ«å€¤ã¯å¸¸ã« ``True`` ã§ã™ã€‚ :meth:`~Pattern.match` ãŠã‚ˆã³ "
":meth:`~Pattern.search` ã¯ãƒãƒƒãƒãŒãªã„ã¨ã ``None`` ã‚’è¿”ã™ã®ã§ã€ãƒãƒƒãƒãŒã‚ã‚‹ã‹å˜ç´”ãª ``if`` æ–‡ã§åˆ¤å®šã§ãã¾ã™ã€‚"

#: ../../library/re.rst:1129
msgid "Match objects support the following methods and attributes:"
msgstr "ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŠã‚ˆã³å±æ€§ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™:"

#: ../../library/re.rst:1134
msgid ""
"Return the string obtained by doing backslash substitution on the template "
"string *template*, as done by the :meth:`~Pattern.sub` method. Escapes such "
"as ``\\n`` are converted to the appropriate characters, and numeric "
"backreferences (``\\1``, ``\\2``) and named backreferences (``\\g<1>``, "
"``\\g<name>``) are replaced by the contents of the corresponding group."
msgstr ""
"ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆæ–‡å­—åˆ— *template* ã« :meth:`~Pattern.sub` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã®è¡Œã†ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ç½®æ›ã‚’è¡Œã£ã¦å¾—ã‚‰ã‚Œã‚‹æ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚ ``\\n`` ã®ã‚ˆã†ãªã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã¯é©åˆ‡ãªæ–‡å­—ã«å¤‰æ›ã•ã‚Œã€æ•°å¾Œæ–¹å‚ç…§ "
"(``\\1``, ``\\2``) ãŠã‚ˆã³åå‰ä»˜ãå¾Œæ–¹å‚ç…§ (``\\g<1>``, ``\\g<name>``) "
"ã¯å¯¾å¿œã™ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ã®å†…å®¹ã«ç½®æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:1146
msgid ""
"Returns one or more subgroups of the match.  If there is a single argument, "
"the result is a single string; if there are multiple arguments, the result "
"is a tuple with one item per argument. Without arguments, *group1* defaults "
"to zero (the whole match is returned). If a *groupN* argument is zero, the "
"corresponding return value is the entire matching string; if it is in the "
"inclusive range [1..99], it is the string matching the corresponding "
"parenthesized group.  If a group number is negative or larger than the "
"number of groups defined in the pattern, an :exc:`IndexError` exception is "
"raised. If a group is contained in a part of the pattern that did not match,"
" the corresponding result is ``None``. If a group is contained in a part of "
"the pattern that matched multiple times, the last match is returned. ::"
msgstr ""
"ã“ã®ãƒãƒƒãƒã® 1 ã¤ä»¥ä¸Šã®ã‚µãƒ–ã‚°ãƒ«ãƒ¼ãƒ—ã‚’è¿”ã—ã¾ã™ã€‚å¼•æ•°ãŒ 1 ã¤ãªã‚‰çµæœã¯ 1 ã¤ã®æ–‡å­—åˆ—ã§ã™ã€‚è¤‡æ•°ã®å¼•æ•°ãŒã‚ã‚Œã°ã€çµæœã¯å¼•æ•°ã”ã¨ã« 1 "
"é …ç›®ã®ã‚¿ãƒ—ãƒ«ã§ã™ã€‚å¼•æ•°ãŒãªã‘ã‚Œã°ã€ *group1* ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ 0 (ãƒãƒƒãƒå…¨ä½“ãŒè¿”ã•ã‚Œã‚‹) ã§ã™ã€‚ *groupN* å¼•æ•°ãŒ 0 "
"ãªã‚‰ã€å¯¾å¿œã™ã‚‹è¿”ã‚Šå€¤ã¯ãƒãƒƒãƒã—ãŸæ–‡å­—åˆ—å…¨ä½“ã§ã™ã€‚1 ä»¥ä¸Š 99 "
"ä»¥ä¸‹ãªã‚‰ã€ä¸¸æ‹¬å¼§ã«ã‚ˆã‚‹å¯¾å¿œã™ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ã«ãƒãƒƒãƒã™ã‚‹æ–‡å­—åˆ—ã§ã™ã€‚ã‚°ãƒ«ãƒ¼ãƒ—ç•ªå·ãŒè² ã§ã‚ã‚‹ã‹ãƒ‘ã‚¿ãƒ¼ãƒ³ä¸­ã§å®šç¾©ã•ã‚ŒãŸã‚°ãƒ«ãƒ¼ãƒ—ã®æ•°ã‚ˆã‚Šå¤§ãã‘ã‚Œã°ã€ "
":exc:`IndexError` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ã‚ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ãŒãƒ‘ã‚¿ãƒ¼ãƒ³ã®ãƒãƒƒãƒã—ãªã‹ã£ãŸéƒ¨åˆ†ã«å«ã¾ã‚Œã¦ã„ã‚‹ãªã‚‰ã€å¯¾å¿œã™ã‚‹çµæœã¯ ``None``"
" ã§ã™ã€‚ã‚ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ãŒãƒ‘ã‚¿ãƒ¼ãƒ³ã®è¤‡æ•°å›ãƒãƒƒãƒã—ãŸéƒ¨åˆ†ã«å«ã¾ã‚Œã¦ã„ã‚‹ãªã‚‰ã€æœ€å¾Œã®ãƒãƒƒãƒãŒè¿”ã•ã‚Œã¾ã™ã€‚ ::"

#: ../../library/re.rst:1168
msgid ""
"If the regular expression uses the ``(?P<name>...)`` syntax, the *groupN* "
"arguments may also be strings identifying groups by their group name.  If a "
"string argument is not used as a group name in the pattern, an "
":exc:`IndexError` exception is raised."
msgstr ""
"æ­£è¦è¡¨ç¾ãŒ ``(?P<name>...)`` æ§‹æ–‡ã‚’ä½¿ã†ãªã‚‰ã€ *groupN* "
"å¼•æ•°ã¯ã‚°ãƒ«ãƒ¼ãƒ—åã§ã‚°ãƒ«ãƒ¼ãƒ—ã‚’è­˜åˆ¥ã™ã‚‹æ–‡å­—åˆ—ã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚æ–‡å­—åˆ—å¼•æ•°ãŒãƒ‘ã‚¿ãƒ¼ãƒ³ä¸­ã§ã‚°ãƒ«ãƒ¼ãƒ—åã¨ã—ã¦ä½¿ã‚ã‚Œã¦ã„ãªã‘ã‚Œã°ã€ "
":exc:`IndexError` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:1173
msgid "A moderately complicated example::"
msgstr "ã‚„ã‚„è¤‡é›‘ãªä¾‹::"

#: ../../library/re.rst:1181
msgid "Named groups can also be referred to by their index::"
msgstr "åå‰ä»˜ãã‚°ãƒ«ãƒ¼ãƒ—ã¯ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã‚‚å‚ç…§ã§ãã¾ã™::"

#: ../../library/re.rst:1188
msgid "If a group matches multiple times, only the last match is accessible::"
msgstr "ã‚ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ãŒè¤‡æ•°å›ãƒãƒƒãƒã™ã‚‹ã¨ã€ãã®æœ€å¾Œã®ãƒãƒƒãƒã«ã®ã¿ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™::"

#: ../../library/re.rst:1197
msgid ""
"This is identical to ``m.group(g)``.  This allows easier access to an "
"individual group from a match::"
msgstr "ã“ã‚Œã¯ ``m.group(g)`` ã¨åŒç­‰ã§ã™ã€‚ã“ã‚Œã§ãƒãƒƒãƒã®å€‹åˆ¥ã®ã‚°ãƒ«ãƒ¼ãƒ—ã«ç°¡å˜ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™::"

#: ../../library/re.rst:1213
msgid ""
"Return a tuple containing all the subgroups of the match, from 1 up to "
"however many groups are in the pattern.  The *default* argument is used for "
"groups that did not participate in the match; it defaults to ``None``."
msgstr ""
"ã“ã®ãƒãƒƒãƒã®ã€1 ã‹ã‚‰ãƒ‘ã‚¿ãƒ¼ãƒ³ä¸­ã®ã‚°ãƒ«ãƒ¼ãƒ—æ•°ã¾ã§ã€å…¨ã¦ã®ã‚µãƒ–ã‚°ãƒ«ãƒ¼ãƒ—ã‚’å«ã‚€ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚*default* "
"å¼•æ•°ã¯ãƒãƒƒãƒã«é–¢ä¿‚ã—ãªã‹ã£ãŸã‚°ãƒ«ãƒ¼ãƒ—ã«ä½¿ã‚ã‚Œã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ ``None`` ã§ã™ã€‚"

#: ../../library/re.rst:1217 ../../library/re.rst:1442
msgid "For example::"
msgstr "ä¾‹ãˆã°::"

#: ../../library/re.rst:1223
msgid ""
"If we make the decimal place and everything after it optional, not all "
"groups might participate in the match.  These groups will default to "
"``None`` unless the *default* argument is given::"
msgstr ""
"å°‘æ•°ä½ãŠã‚ˆã³ãã®å¾Œã®å…¨ã¦ã‚’ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã«ã™ã‚‹ã¨ã€å…¨ã¦ã®ã‚°ãƒ«ãƒ¼ãƒ—ãŒãƒãƒƒãƒã«é–¢ä¿‚ã™ã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚ãã†ã„ã£ãŸã‚°ãƒ«ãƒ¼ãƒ—ã¯ *default* "
"å¼•æ•°ãŒä¸ãˆã‚‰ã‚Œãªã„é™ã‚Šãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ ``None`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/re.rst:1236
msgid ""
"Return a dictionary containing all the *named* subgroups of the match, keyed"
" by the subgroup name.  The *default* argument is used for groups that did "
"not participate in the match; it defaults to ``None``.  For example::"
msgstr ""
"ã“ã®ãƒãƒƒãƒã®ã€å…¨ã¦ã® *åå‰ä»˜ã* ã‚µãƒ–ã‚°ãƒ«ãƒ¼ãƒ—ã‚’å«ã‚€ã€ã‚µãƒ–ã‚°ãƒ«ãƒ¼ãƒ—åã‚’ã‚­ãƒ¼ã¨ã™ã‚‹è¾æ›¸ã‚’è¿”ã—ã¾ã™ã€‚ *default* "
"å¼•æ•°ã¯ãƒãƒƒãƒã«é–¢ä¿‚ã—ãªã‹ã£ãŸã‚°ãƒ«ãƒ¼ãƒ—ã«ä½¿ã‚ã‚Œã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ ``None`` ã§ã™ã€‚ä¾‹ãˆã°::"

#: ../../library/re.rst:1248
msgid ""
"Return the indices of the start and end of the substring matched by *group*;"
" *group* defaults to zero (meaning the whole matched substring). Return "
"``-1`` if *group* exists but did not contribute to the match.  For a match "
"object *m*, and a group *g* that did contribute to the match, the substring "
"matched by group *g* (equivalent to ``m.group(g)``) is ::"
msgstr ""
"*group* ãŒãƒãƒƒãƒã—ãŸéƒ¨åˆ†æ–‡å­—åˆ—ã®å…ˆé ­ã¨æœ«å°¾ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ *group* ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ 0 (ãƒãƒƒãƒã—ãŸéƒ¨åˆ†æ–‡å­—åˆ—å…¨ä½“ã¨ã„ã†æ„å‘³)"
" ã§ã™ã€‚ *group* ãŒå­˜åœ¨ã—ã¦ã‹ã¤ãƒãƒƒãƒã«ã¯å¯„ä¸ã—ã¦ã„ãªã‹ã£ãŸãªã‚‰ ``-1`` ã‚’è¿”ã—ã¾ã™ã€‚ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ *m* "
"ã¨ã€ãƒãƒƒãƒã«å¯„ä¸ã—ãŸã‚°ãƒ«ãƒ¼ãƒ— *g* ã«å¯¾ã—ã¦ã€ã‚°ãƒ«ãƒ¼ãƒ— *g* ãŒãƒãƒƒãƒã—ãŸéƒ¨åˆ†æ–‡å­—åˆ— (``m.group(g)`` ã¨ç­‰ä¾¡ã§ã™) ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™"
" ::"

#: ../../library/re.rst:1256
msgid ""
"Note that ``m.start(group)`` will equal ``m.end(group)`` if *group* matched "
"a null string.  For example, after ``m = re.search('b(c?)', 'cba')``, "
"``m.start(0)`` is 1, ``m.end(0)`` is 2, ``m.start(1)`` and ``m.end(1)`` are "
"both 2, and ``m.start(2)`` raises an :exc:`IndexError` exception."
msgstr ""
"*group* ãŒç©ºæ–‡å­—åˆ—ã«ãƒãƒƒãƒã—ã¦ã„ãŸã‚‰ ``m.start(group)`` ã¯ ``m.end(group)`` "
"ã¨ç­‰ã—ããªã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ä¸‹ã•ã„ã€‚ä¾‹ãˆã°ã€ ``m = re.search('b(c?)', 'cba')`` ã¨ã™ã‚‹ã¨ã€ ``m.start(0)``"
" ã¯ 1 ã§ã€ ``m.end(0)`` ã¯ 2 ã§ã€ ``m.start(1)`` ã¨ ``m.end(1)`` ã¯ã¨ã‚‚ã« 2 ã§ã‚ã‚Šã€ "
"``m.start(2)`` ã¯ :exc:`IndexError` ä¾‹å¤–ã‚’ç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/re.rst:1261
msgid "An example that will remove *remove_this* from email addresses::"
msgstr "ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰ *remove_this* ã‚’å–ã‚Šé™¤ãä¾‹::"

#: ../../library/re.rst:1271
msgid ""
"For a match *m*, return the 2-tuple ``(m.start(group), m.end(group))``. Note"
" that if *group* did not contribute to the match, this is ``(-1, -1)``. "
"*group* defaults to zero, the entire match."
msgstr ""
"ãƒãƒƒãƒ *m* ã«ã¤ã„ã¦ã€2 ã‚¿ãƒ—ãƒ« ``(m.start(group), m.end(group))`` ã‚’è¿”ã—ã¾ã™ã€‚ *group* "
"ãŒãƒãƒƒãƒã«å¯„ä¸ã—ã¦ã„ãªã‘ã‚Œã°ã€ã“ã‚Œã¯ ``(-1, -1)`` ã§ã™ã€‚ *group* ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ 0 ã€ãƒãƒƒãƒå…¨ä½“ã§ã™ã€‚"

#: ../../library/re.rst:1278
msgid ""
"The value of *pos* which was passed to the :meth:`~Pattern.search` or "
":meth:`~Pattern.match` method of a :ref:`regex object <re-objects>`.  This "
"is the index into the string at which the RE engine started looking for a "
"match."
msgstr ""
":ref:`æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <re-objects>` ã® :meth:`~Pattern.search` ã‚„ "
":meth:`~Pattern.match` ã«æ¸¡ã•ã‚ŒãŸ *pos* "
"ã®å€¤ã§ã™ã€‚ã“ã‚Œã¯æ­£è¦è¡¨ç¾ã‚¨ãƒ³ã‚¸ãƒ³ãŒãƒãƒƒãƒã‚’æ¢ã—å§‹ã‚ã‚‹ä½ç½®ã®æ–‡å­—åˆ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã™ã€‚"

#: ../../library/re.rst:1285
msgid ""
"The value of *endpos* which was passed to the :meth:`~Pattern.search` or "
":meth:`~Pattern.match` method of a :ref:`regex object <re-objects>`.  This "
"is the index into the string beyond which the RE engine will not go."
msgstr ""
":ref:`æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <re-objects>` ã® :meth:`~Pattern.search` ã‚„ "
":meth:`~Pattern.match` ã«æ¸¡ã•ã‚ŒãŸ *endpos* "
"ã®å€¤ã§ã™ã€‚ã“ã‚Œã¯æ­£è¦è¡¨ç¾ã‚¨ãƒ³ã‚¸ãƒ³ãŒãã‚Œä»¥ä¸Šã¯é€²ã¾ãªã„æ–‡å­—åˆ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã™ã€‚"

#: ../../library/re.rst:1292
msgid ""
"The integer index of the last matched capturing group, or ``None`` if no "
"group was matched at all. For example, the expressions ``(a)b``, "
"``((a)(b))``, and ``((ab))`` will have ``lastindex == 1`` if applied to the "
"string ``'ab'``, while the expression ``(a)(b)`` will have ``lastindex == "
"2``, if applied to the same string."
msgstr ""
"æœ€å¾Œã«ãƒãƒƒãƒã—ãŸã‚­ãƒ£ãƒ—ãƒãƒ£ã‚°ãƒ«ãƒ¼ãƒ—ã®æ•´æ•°ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã™ã€‚ã©ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚‚å…¨ããƒãƒƒãƒã—ãªã‘ã‚Œã° ``None`` ã§ã™ã€‚ä¾‹ãˆã°ã€è¡¨ç¾ ``(a)b`` ã€"
" ``((a)(b))`` ã‚„ ``((ab))`` ãŒ ``'ab'`` ã«é©ç”¨ã•ã‚Œã‚‹ã¨ ``lastindex == 1`` ã¨ãªã‚Šã€åŒã˜æ–‡å­—åˆ—ã« "
"``(a)(b)`` ãŒé©ç”¨ã•ã‚Œã‚‹ã¨ ``lastindex == 2`` ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/re.rst:1301
msgid ""
"The name of the last matched capturing group, or ``None`` if the group "
"didn't have a name, or if no group was matched at all."
msgstr "æœ€å¾Œã«ãƒãƒƒãƒã—ãŸã‚­ãƒ£ãƒ—ãƒãƒ£ã‚°ãƒ«ãƒ¼ãƒ—ã®åå‰ã§ã™ã€‚ãã®ã‚°ãƒ«ãƒ¼ãƒ—ã«åå‰ãŒãªã„ã‹ã€ã©ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚‚å…¨ããƒãƒƒãƒã—ã¦ã„ãªã‘ã‚Œã° ``None`` ã§ã™ã€‚"

#: ../../library/re.rst:1307
msgid ""
"The :ref:`regular expression object <re-objects>` whose "
":meth:`~Pattern.match` or :meth:`~Pattern.search` method produced this match"
" instance."
msgstr ""
"ã“ã®ãƒãƒƒãƒã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿã˜ã•ã›ãŸ :meth:`~Pattern.match` ã¾ãŸã¯ :meth:`~Pattern.search` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã®å±ã™ã‚‹ :ref:`æ­£è¦è¡¨ç¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <re-objects>` ã§ã™ã€‚"

#: ../../library/re.rst:1313
msgid ""
"The string passed to :meth:`~Pattern.match` or :meth:`~Pattern.search`."
msgstr ":meth:`~Pattern.match` ã‚„ :meth:`~Pattern.search` ã¸æ¸¡ã•ã‚ŒãŸæ–‡å­—åˆ—ã§ã™ã€‚"

#: ../../library/re.rst:1316
msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Match objects"
" are considered atomic."
msgstr ""
":func:`copy.copy` ãŠã‚ˆã³ :func:`copy.deepcopy` "
"ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚¢ãƒˆãƒŸãƒƒã‚¯ã§ã‚ã‚‹ã¨è¦‹ãªã•ã‚Œã¾ã™ã€‚"

#: ../../library/re.rst:1324
msgid "Regular Expression Examples"
msgstr "æ­£è¦è¡¨ç¾ã®ä¾‹"

#: ../../library/re.rst:1328
msgid "Checking for a Pair"
msgstr "ãƒšã‚¢ã®ç¢ºèª"

#: ../../library/re.rst:1330
msgid ""
"In this example, we'll use the following helper function to display match "
"objects a little more gracefully:"
msgstr "ã“ã®ä¾‹ã§ã¯ã€ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å°‘ã—ç¾ã—ãè¡¨ç¤ºã™ã‚‹ãŸã‚ã«ã€ã“ã®è£œåŠ©é–¢æ•°ã‚’ä½¿ç”¨ã—ã¾ã™:"

#: ../../library/re.rst:1340
msgid ""
"Suppose you are writing a poker program where a player's hand is represented"
" as a 5-character string with each character representing a card, \"a\" for "
"ace, \"k\" for king, \"q\" for queen, \"j\" for jack, \"t\" for 10, and "
"\"2\" through \"9\" representing the card with that value."
msgstr ""
"ã‚ãªãŸãŒãƒãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ã„ã¦ã„ã‚‹ã¨ã—ã¾ã™ã€‚ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ‰‹æœ­ã¯ 5 æ–‡å­—ã®æ–‡å­—åˆ—ã«ã‚ˆã£ã¦è¡¨ã•ã‚Œã€ãã‚Œãã‚Œã®æ–‡å­—ãŒ 1 æšã®ã‚«ãƒ¼ãƒ‰ã‚’è¡¨ã—ã¾ã™ã€‚ "
"\"a\" ã¯ã‚¨ãƒ¼ã‚¹ã€ \"k\" ã¯ã‚­ãƒ³ã‚°ã€ \"q\" ã¯ã‚¯ã‚¤ãƒ¼ãƒ³ã€ \"j\" ã¯ã‚¸ãƒ£ãƒƒã‚¯ã€ \"t\" ã¯ 10ã€ãã—ã¦ \"2\" ã‹ã‚‰ "
"\"9\" ã¯ãã®æ•°å­—ã®ã‚«ãƒ¼ãƒ‰ã‚’è¡¨ã—ã¾ã™ã€‚"

#: ../../library/re.rst:1345
msgid "To see if a given string is a valid hand, one could do the following::"
msgstr "ä¸ãˆã‚‰ã‚ŒãŸæ–‡å­—åˆ—ãŒæœ‰åŠ¹ãªæ‰‹æœ­ã§ã‚ã‚‹ã‹è¦‹ã‚‹ã«ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã§ãã¾ã™::"

#: ../../library/re.rst:1355
msgid ""
"That last hand, ``\"727ak\"``, contained a pair, or two of the same valued "
"cards. To match this with a regular expression, one could use backreferences"
" as such::"
msgstr ""
"æœ€å¾Œã®æ‰‹æœ­ã€ ``\"727ak\"`` ã€ã¯ãƒšã‚¢ã€ã™ãªã‚ã¡åŒã˜å€¤ã® 2 "
"æšã®ã‚«ãƒ¼ãƒ‰ã‚’å«ã¿ã¾ã™ã€‚æ­£è¦è¡¨ç¾ã§ã“ã‚Œã«ãƒãƒƒãƒã™ã‚‹ã«ã¯ã€ã“ã®ã‚ˆã†ã«å¾Œæ–¹å‚ç…§ã‚’ä½¿ãˆã¾ã™::"

#: ../../library/re.rst:1365
msgid ""
"To find out what card the pair consists of, one could use the "
":meth:`~Match.group` method of the match object in the following manner:"
msgstr "ãƒšã‚¢ã«ãªã£ã¦ã„ã‚‹ã®ãŒã©ã®ã‚«ãƒ¼ãƒ‰ã‹èª¿ã¹ã‚‹ã«ã¯ã€ã“ã®ã‚ˆã†ã«ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`~Match.group` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ãˆã¾ã™:"

#: ../../library/re.rst:1385
msgid "Simulating scanf()"
msgstr "scanf() ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹"

#: ../../library/re.rst:1389
msgid ""
"Python does not currently have an equivalent to :c:func:`scanf`.  Regular "
"expressions are generally more powerful, though also more verbose, than "
":c:func:`scanf` format strings.  The table below offers some more-or-less "
"equivalent mappings between :c:func:`scanf` format tokens and regular "
"expressions."
msgstr ""
"Python ã«ã¯ç¾åœ¨ã®ã¨ã“ã‚ã€ :c:func:`scanf` ã«ç›¸å½“ã™ã‚‹ã‚‚ã®ãŒã‚ã‚Šã¾ã›ã‚“ã€‚æ­£è¦è¡¨ç¾ã¯ä¸€èˆ¬çš„ã«ã€ :c:func:`scanf` "
"ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ–‡å­—åˆ—ã‚ˆã‚Šå¼·åŠ›ã§ã™ãŒã€å†—é•·ã§ã‚‚ã‚ã‚Šã¾ã™ã€‚ä»¥ä¸‹ã®è¡¨ã«ã€ :c:func:`scanf` "
"ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒˆãƒ¼ã‚¯ãƒ³ã¨æ­£è¦è¡¨ç¾ã®ãŠãŠã‚ˆãã®å¯¾å¿œä»˜ã‘ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/re.rst:1396
msgid ":c:func:`scanf` Token"
msgstr ":c:func:`scanf` ãƒˆãƒ¼ã‚¯ãƒ³"

#: ../../library/re.rst:1396
msgid "Regular Expression"
msgstr "æ­£è¦è¡¨ç¾"

#: ../../library/re.rst:1398
msgid "``%c``"
msgstr "``%c``"

#: ../../library/re.rst:1400
msgid "``%5c``"
msgstr "``%5c``"

#: ../../library/re.rst:1400
msgid "``.{5}``"
msgstr "``.{5}``"

#: ../../library/re.rst:1402
msgid "``%d``"
msgstr "``%d``"

#: ../../library/re.rst:1402
msgid "``[-+]?\\d+``"
msgstr "``[-+]?\\d+``"

#: ../../library/re.rst:1404
msgid "``%e``, ``%E``, ``%f``, ``%g``"
msgstr "``%e``, ``%E``, ``%f``, ``%g``"

#: ../../library/re.rst:1404
msgid "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"
msgstr "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"

#: ../../library/re.rst:1406
msgid "``%i``"
msgstr "``%i``"

#: ../../library/re.rst:1406
msgid "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"
msgstr "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"

#: ../../library/re.rst:1408
msgid "``%o``"
msgstr "``%o``"

#: ../../library/re.rst:1408
msgid "``[-+]?[0-7]+``"
msgstr "``[-+]?[0-7]+``"

#: ../../library/re.rst:1410
msgid "``%s``"
msgstr "``%s``"

#: ../../library/re.rst:1410
msgid "``\\S+``"
msgstr "``\\S+``"

#: ../../library/re.rst:1412
msgid "``%u``"
msgstr "``%u``"

#: ../../library/re.rst:1412
msgid "``\\d+``"
msgstr "``\\d+``"

#: ../../library/re.rst:1414
msgid "``%x``, ``%X``"
msgstr "``%x``, ``%X``"

#: ../../library/re.rst:1414
msgid "``[-+]?(0[xX])?[\\dA-Fa-f]+``"
msgstr "``[-+]?(0[xX])?[\\dA-Fa-f]+``"

#: ../../library/re.rst:1417
msgid "To extract the filename and numbers from a string like ::"
msgstr "ä»¥ä¸‹ã®ã‚ˆã†ãªæ–‡å­—åˆ—ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«åã¨æ•°ã‚’æŠ½å‡ºã™ã‚‹ã«ã¯ ::"

#: ../../library/re.rst:1421
msgid "you would use a :c:func:`scanf` format like ::"
msgstr "ä»¥ä¸‹ã®ã‚ˆã†ã« :c:func:`scanf` ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ä½¿ãˆã¾ã™ ::"

#: ../../library/re.rst:1425
msgid "The equivalent regular expression would be ::"
msgstr "ç­‰ä¾¡ãªæ­£è¦è¡¨ç¾ã¯ã“ã†ã§ã™ ::"

#: ../../library/re.rst:1433
msgid "search() vs. match()"
msgstr "search() vs. match()"

#: ../../library/re.rst:1437
msgid ""
"Python offers two different primitive operations based on regular "
"expressions: :func:`re.match` checks for a match only at the beginning of "
"the string, while :func:`re.search` checks for a match anywhere in the "
"string (this is what Perl does by default)."
msgstr ""
"Python ã¯æ­£è¦è¡¨ç¾ãƒ™ãƒ¼ã‚¹ã® 2 ã¤ã®ç•°ãªã‚‹åŸºæœ¬çš„ãªé–¢æ•°ã€æ–‡å­—åˆ—ã®å…ˆé ­ã§ã®ã¿ã®ãƒãƒƒãƒã‚’ç¢ºèªã™ã‚‹ :func:`re.match` "
"ãŠã‚ˆã³ã€æ–‡å­—åˆ—ä¸­ã®ä½ç½®ã«ã‹ã‹ã‚ã‚‰ãšãƒãƒƒãƒã‚’ç¢ºèªã™ã‚‹ :func:`re.search` (ã“ã‚ŒãŒ Perl ã§ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æŒ™å‹•ã§ã™) "
"ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/re.rst:1448
msgid ""
"Regular expressions beginning with ``'^'`` can be used with :func:`search` "
"to restrict the match at the beginning of the string::"
msgstr "``'^'`` ã§å§‹ã¾ã‚‹æ­£è¦è¡¨ç¾ã‚’ :func:`search` ã§ä½¿ã£ã¦ã€ãƒãƒƒãƒã‚’æ–‡å­—åˆ—ã®å…ˆé ­ã§ã®ã¿ã«åˆ¶é™ã§ãã¾ã™::"

#: ../../library/re.rst:1456
msgid ""
"Note however that in :const:`MULTILINE` mode :func:`match` only matches at "
"the beginning of the string, whereas using :func:`search` with a regular "
"expression beginning with ``'^'`` will match at the beginning of each line. "
"::"
msgstr ""
"ãŸã ã—ã€ :const:`MULTILINE` ãƒ¢ãƒ¼ãƒ‰ã«ãŠã„ã¦ :func:`match` ã¯æ–‡å­—åˆ—ã®å…ˆé ­ã§ã®ã¿ãƒãƒƒãƒã—ã€ ``'^'`` "
"ã§å§‹ã¾ã‚‹æ­£è¦è¡¨ç¾ã§ :func:`search` ã‚’ä½¿ã†ã¨å„è¡Œã®å…ˆé ­ã§ãƒãƒƒãƒã™ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/re.rst:1466
msgid "Making a Phonebook"
msgstr "é›»è©±å¸³ã‚’ä½œã‚‹"

#: ../../library/re.rst:1468
msgid ""
":func:`split` splits a string into a list delimited by the passed pattern.  "
"The method is invaluable for converting textual data into data structures "
"that can be easily read and modified by Python as demonstrated in the "
"following example that creates a phonebook."
msgstr ""
":func:`split` "
"ã¯æ¸¡ã•ã‚ŒãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã§æ–‡å­—åˆ—ã‚’åˆ†å‰²ã—ã¦ãƒªã‚¹ãƒˆã«ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã«å¤‰æ›ã—ã¦ã€èª­ã¿ã‚„ã™ãã—ãŸã‚Šã€ä»¥ä¸‹ã®ä¾‹ã§å®Ÿæ¼”ã™ã‚‹é›»è©±å¸³ä½œæˆã®ã‚ˆã†ã«"
" Python ã§ç·¨é›†ã—ãŸã‚Šã—ã‚„ã™ãã™ã‚‹ã®ã«ã€éå¸¸ã«å½¹ã«ç«‹ã¡ã¾ã™ã€‚"

#: ../../library/re.rst:1473
msgid ""
"First, here is the input.  Normally it may come from a file, here we are "
"using triple-quoted string syntax::"
msgstr "ã¾ãšã€ã“ã“ã«å…¥åŠ›ãŒã‚ã‚Šã¾ã™ã€‚æ™®é€šã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰æŒã£ã¦ãã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ãŒã€ã“ã“ã§ã¯ä¸‰é‡ã‚¯ã‚ªãƒ¼ãƒˆæ–‡å­—åˆ—æ§‹æ–‡ã‚’ä½¿ã„ã¾ã™::"

#: ../../library/re.rst:1484
msgid ""
"The entries are separated by one or more newlines. Now we convert the string"
" into a list with each nonempty line having its own entry:"
msgstr "å„é …ç›®ã¯ 1 ã¤ä»¥ä¸Šã®æ”¹è¡Œã§åŒºåˆ‡ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚ã¾ãšã¯æ–‡å­—åˆ—ã‚’å¤‰æ›ã—ã¦ã€ç©ºè¡Œã§ãªã„å„è¡Œã‚’é …ç›®ã¨ã™ã‚‹ãƒªã‚¹ãƒˆã«ã—ã¾ã™:"

#: ../../library/re.rst:1497
msgid ""
"Finally, split each entry into a list with first name, last name, telephone "
"number, and address.  We use the ``maxsplit`` parameter of :func:`split` "
"because the address has spaces, our splitting pattern, in it:"
msgstr ""
"ãã—ã¦å„é …ç›®ã‚’ã€ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆãƒãƒ¼ãƒ ã€ãƒ©ã‚¹ãƒˆãƒãƒ¼ãƒ ã€é›»è©±ç•ªå·ã€ä½æ‰€ã«åˆ†å‰²ã—ã¦ãƒªã‚¹ãƒˆã«ã—ã¾ã™ã€‚åˆ†å‰²ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã‚ã‚‹ç©ºç™½æ–‡å­—ã¯ä½æ‰€ã«ã‚‚å«ã¾ã‚Œã‚‹ã®ã§ã€ "
":func:`split` ã® ``maxsplit`` å¼•æ•°ã‚’ä½¿ã„ã¾ã™:"

#: ../../library/re.rst:1510
msgid ""
"The ``:?`` pattern matches the colon after the last name, so that it does "
"not occur in the result list.  With a ``maxsplit`` of ``4``, we could "
"separate the house number from the street name:"
msgstr ""
"ã“ã® ``:?`` ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ãƒ©ã‚¹ãƒˆãƒãƒ¼ãƒ ã®æ¬¡ã®ã‚³ãƒ­ãƒ³ã«ãƒãƒƒãƒã—ã¦ã€åˆ†å‰²çµæœã®ãƒªã‚¹ãƒˆã«å‡ºã¦ã“ãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚ ``maxsplit`` ã‚’ ``4``"
" ã«ã™ã‚Œã°ã€å®¶å±‹ç•ªå·ã¨ã‚¹ãƒˆãƒªãƒ¼ãƒˆåã‚’åˆ†å‰²ã§ãã¾ã™:"

#: ../../library/re.rst:1525
msgid "Text Munging"
msgstr "ãƒ†ã‚­ã‚¹ãƒˆã®ç§˜åŒ¿"

#: ../../library/re.rst:1527
msgid ""
":func:`sub` replaces every occurrence of a pattern with a string or the "
"result of a function.  This example demonstrates using :func:`sub` with a "
"function to \"munge\" text, or randomize the order of all the characters in "
"each word of a sentence except for the first and last characters::"
msgstr ""
":func:`sub` ã¯å‡ºç¾ã™ã‚‹å„ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ–‡å­—åˆ—ã§ã€ã¾ãŸã¯é–¢æ•°ã®è¿”ã‚Šå€¤ã§ç½®ãæ›ãˆã¾ã™ã€‚ã“ã®ä¾‹ã§ã¯ãƒ†ã‚­ã‚¹ãƒˆã‚’ã€Œç§˜åŒ¿ã€ã™ã‚‹é–¢æ•°ã¨åˆã‚ã›ã¦ "
":func:`sub` ã‚’ä½¿ã†ã¨ã“ã‚ã‚’å®Ÿæ¼”ã—ã¾ã™ã€‚å…·ä½“çš„ã«ã¯ã€æ–‡ä¸­ã®å„å˜èªã«ã¤ã„ã¦ã€æœ€åˆã¨æœ€å¾Œã®æ–‡å­—ã‚’é™¤ãå…¨ã¦ã®æ–‡å­—ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«ä¸¦ã³æ›¿ãˆã¾ã™::"

#: ../../library/re.rst:1544
msgid "Finding all Adverbs"
msgstr "å…¨ã¦ã®å‰¯è©ã‚’è¦‹ã¤ã‘ã‚‹"

#: ../../library/re.rst:1546
msgid ""
":func:`findall` matches *all* occurrences of a pattern, not just the first "
"one as :func:`search` does.  For example, if a writer wanted to find all of "
"the adverbs in some text, they might use :func:`findall` in the following "
"manner::"
msgstr ""
":func:`search` ã¯æœ€åˆã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã®ã¿ãƒãƒƒãƒã—ã¾ã™ãŒã€ :func:`findall` ã¯å‡ºç¾ã™ã‚‹ *å…¨ã¦ã®* "
"ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ãƒ©ã‚¤ã‚¿ãƒ¼ãŒã‚ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã®å…¨ã¦ã®å‰¯è©ã‚’è¦‹ã¤ã‘ãŸã„ãªã‚‰ã€ä»¥ä¸‹ã®ã‚ˆã†ã« :func:`findall` ã‚’ä½¿ãˆã¾ã™::"

#: ../../library/re.rst:1557
msgid "Finding all Adverbs and their Positions"
msgstr "å…¨ã¦ã®å‰¯è©ã¨ãã®ä½ç½®ã‚’è¦‹ã¤ã‘ã‚‹"

#: ../../library/re.rst:1559
msgid ""
"If one wants more information about all matches of a pattern than the "
"matched text, :func:`finditer` is useful as it provides :ref:`match objects "
"<match-objects>` instead of strings.  Continuing with the previous example, "
"if a writer wanted to find all of the adverbs *and their positions* in some "
"text, they would use :func:`finditer` in the following manner::"
msgstr ""
"ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å…¨ã¦ã®ãƒãƒƒãƒã«ã¤ã„ã¦ã€ãƒãƒƒãƒã—ãŸãƒ†ã‚­ã‚¹ãƒˆä»¥ä¸Šã®æƒ…å ±ãŒå¿…è¦ãªã‚‰ã€æ–‡å­—åˆ—ã§ã¯ãªã :ref:`ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <match-objects>`"
" ã‚’è¿”ã™ :func:`finditer` ãŒä¾¿åˆ©ã§ã™ã€‚å…ˆã®ä¾‹ã«ç¶šã„ã¦ã€ãƒ©ã‚¤ã‚¿ãƒ¼ãŒã‚ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã®å…¨ã¦ã®å‰¯è© *ãŠã‚ˆã³ãã®ä½ç½®* "
"ã‚’è¦‹ã¤ã‘ãŸã„ãªã‚‰ã€ä»¥ä¸‹ã®ã‚ˆã†ã« :func:`finditer` ã‚’ä½¿ãˆã¾ã™::"

#: ../../library/re.rst:1573
msgid "Raw String Notation"
msgstr "Raw æ–‡å­—åˆ—è¨˜æ³•"

#: ../../library/re.rst:1575
msgid ""
"Raw string notation (``r\"text\"``) keeps regular expressions sane.  Without"
" it, every backslash (``'\\'``) in a regular expression would have to be "
"prefixed with another one to escape it.  For example, the two following "
"lines of code are functionally identical::"
msgstr ""
"Raw æ–‡å­—åˆ—è¨˜æ³• (``r\"text\"``) ã§æ­£è¦è¡¨ç¾ã‚’ã¾ã¨ã‚‚ã«ä¿ã¦ã¾ã™ã€‚ãã‚ŒãŒãªã‘ã‚Œã°ã€æ­£è¦è¡¨ç¾ä¸­ã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ (``'\\'``) "
"ã‚’å€‹ã€…ã«ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’å‰ç½®ã—ã¦ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€ä»¥ä¸‹ã® 2 è¡Œã®ã‚³ãƒ¼ãƒ‰ã¯æ©Ÿèƒ½çš„ã«ç­‰ä¾¡ã§ã™::"

#: ../../library/re.rst:1585
msgid ""
"When one wants to match a literal backslash, it must be escaped in the "
"regular expression.  With raw string notation, this means ``r\"\\\\\"``.  "
"Without raw string notation, one must use ``\"\\\\\\\\\"``, making the "
"following lines of code functionally identical::"
msgstr ""
"ãƒªãƒ†ãƒ©ãƒ«ã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã«ãƒãƒƒãƒã•ã›ãŸã„ãªã‚‰ã€æ­£è¦è¡¨ç¾ä¸­ã§ã¯ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚Raw æ–‡å­—åˆ—è¨˜æ³•ã§ã¯ã€``r\"\\\\\"``  "
"ã«ãªã‚Šã¾ã™ã€‚Raw æ–‡å­—åˆ—è¨˜æ³•ã‚’ç”¨ã„ãªã„ã¨ã€``\"\\\\\\\\\"`` ã¨ã—ãªãã¦ã¯ãªã‚‰ãšã€ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¯æ©Ÿèƒ½çš„ã«ç­‰ä¾¡ã§ã™::"

#: ../../library/re.rst:1597
msgid "Writing a Tokenizer"
msgstr "ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚¶ã‚’æ›¸ã"

#: ../../library/re.rst:1599
msgid ""
"A `tokenizer or scanner <https://en.wikipedia.org/wiki/Lexical_analysis>`_ "
"analyzes a string to categorize groups of characters.  This is a useful "
"first step in writing a compiler or interpreter."
msgstr ""
"`ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚¶ã‚„ã‚¹ã‚­ãƒ£ãƒŠ <https://en.wikipedia.org/wiki/Lexical_analysis>`_ "
"ã¯æ–‡å­—åˆ—ã‚’è§£æã—ã€æ–‡å­—ã®ã‚°ãƒ«ãƒ¼ãƒ—ã«ã‚«ãƒ†ã‚´ãƒªåˆ†ã‘ã—ã¾ã™ã€‚ã“ã‚Œã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã‚„ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’æ›¸ãã†ãˆã§å½¹ç«‹ã¤ç¬¬ä¸€æ®µéšã§ã™ã€‚"

#: ../../library/re.rst:1603
msgid ""
"The text categories are specified with regular expressions.  The technique "
"is to combine those into a single master regular expression and to loop over"
" successive matches::"
msgstr "ãƒ†ã‚­ã‚¹ãƒˆã®ã‚«ãƒ†ã‚´ãƒªã¯æ­£è¦è¡¨ç¾ã§æŒ‡å®šã•ã‚Œã¾ã™ã€‚ã“ã®æŠ€æ³•ã§ã¯ã€ãã‚Œã‚‰ã‚’ä¸€ã¤ã®ãƒã‚¹ã‚¿ãƒ¼æ­£è¦è¡¨ç¾ã«çµåˆã—ã€ãƒãƒƒãƒã®é€£ç¶šã«ã¤ã„ã¦ãƒ«ãƒ¼ãƒ—ã—ã¾ã™::"

#: ../../library/re.rst:1655
msgid "The tokenizer produces the following output::"
msgstr "ã“ã®ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚¶ã¯ä»¥ä¸‹ã®å‡ºåŠ›ã‚’ä½œæˆã—ã¾ã™::"

#: ../../library/re.rst:1678
msgid ""
"Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O'Reilly Media, "
"2009. The third edition of the book no longer covers Python at all, but the "
"first edition covered writing good regular expression patterns in great "
"detail."
msgstr ""
"Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O'Reilly Media, "
"2009. å½“æ›¸ã®ç¬¬ä¸‰ç‰ˆã§ã¯ã‚‚ã¯ã‚„ Python ã«ã¤ã„ã¦ã¾ã£ãŸãå–ã‚Šæ‰±ã£ã¦ã„ã¾ã›ã‚“ãŒã€åˆç‰ˆã§ã¯è‰¯ã„æ­£è¦è¡¨ç¾ã‚’æ›¸ãã“ã¨ã‚’ç¶¿å¯†ã«å–ã‚Šæ‰±ã£ã¦ã„ã¾ã—ãŸã€‚"
