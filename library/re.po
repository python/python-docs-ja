# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# tomo, 2017-2018
# Inada Naoki <songofacandy@gmail.com>, 2015-2016
# tomo, 2017
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 01:01+0900\n"
"PO-Revision-Date: 2019-09-01 05:22+0000\n"
"Last-Translator: Arihiro TAKASE\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/"
"language/ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/re.rst:3
msgid ":mod:`re` --- Regular expression operations"
msgstr ":mod:`re` --- 正規表現操作"

#: ../../library/re.rst:11
msgid ""
"This module provides regular expression matching operations similar to those "
"found in Perl. Both patterns and strings to be searched can be Unicode "
"strings as well as 8-bit strings."
msgstr ""
"このモジュールでは、 Perl で見られるものと同様な正規表現マッチング操作を提供"
"しています。パターンと検索対象文字列の両方について、 8 ビット文字列と "
"Unicode 文字列を同じように扱えます。"

#: ../../library/re.rst:15
msgid ""
"Regular expressions use the backslash character (``'\\'``) to indicate "
"special forms or to allow special characters to be used without invoking "
"their special meaning.  This collides with Python's usage of the same "
"character for the same purpose in string literals; for example, to match a "
"literal backslash, one might have to write ``'\\\\\\\\'`` as the pattern "
"string, because the regular expression must be ``\\\\``, and each backslash "
"must be expressed as ``\\\\`` inside a regular Python string literal."
msgstr ""
"正規表現では、特殊な形式を表したり、特殊文字の持つ特別な意味を呼び出さずにそ"
"の特殊な文字を使えるようにするために、バックスラッシュ文字 (``'\\'``) を使い"
"ます。こうしたバックスラッシュの使い方は、 Python の文字列リテラルにおける同"
"じバックスラッシュ文字と衝突を起こします。例えば、バックスラッシュ自体にマッ"
"チさせるには、パターン文字列として ``'\\\\\\\\'`` と書かなければなりません、"
"というのも、正規表現は ``\\\\`` でなければならず、さらに正規な Python 文字列"
"リテラルでは各々のバックスラッシュを ``\\\\`` と表現せねばならないからです。"

#: ../../library/re.rst:24
msgid ""
"The solution is to use Python's raw string notation for regular expression "
"patterns; backslashes are not handled in any special way in a string literal "
"prefixed with ``'r'``.  So ``r\"\\n\"`` is a two-character string containing "
"``'\\'`` and ``'n'``, while ``\"\\n\"`` is a one-character string containing "
"a newline.  Usually patterns will be expressed in Python code using this raw "
"string notation."
msgstr ""
"正規表現パターンに Python の raw string 記法を使えばこの問題を解決できます。 "
"``'r'`` を前置した文字列リテラル内ではバックスラッシュを特別扱いしません。"
"従って、 ``\"\\n\"`` が改行一文字の入った文字列になるのに対して、 "
"``r\"\\n\"`` は ``'\\'`` と ``'n'`` という二つの文字の入った文字列になりま"
"す。通常、 Python コード中では、パターンをこの raw string 記法を使って表現し"
"ます。"

#: ../../library/re.rst:31
msgid ""
"It is important to note that most regular expression operations are "
"available as module-level functions and :class:`RegexObject` methods.  The "
"functions are shortcuts that don't require you to compile a regex object "
"first, but miss some fine-tuning parameters."
msgstr ""
"大抵の正規表現操作がモジュールレベルの関数と、 :class:`RegexObject` のメソッ"
"ドとして提供されることに注意して下さい。関数は正規表現オブジェクトのコンパイ"
"ルを必要としない近道ですが、いくつかのチューニング変数を失います。"

#: ../../library/re.rst:38
msgid ""
"The third-party `regex <https://pypi.org/project/regex/>`_ module, which has "
"an API compatible with the standard library :mod:`re` module, but offers "
"additional functionality and a more thorough Unicode support."
msgstr ""
"サードパーティの `regex <https://pypi.org/project/regex/>`_ モジュールは、標"
"準ライブラリの :mod:`re` モジュールと互換な API を持ち、追加の機能とより徹底"
"した Unicode サポートを提供します。"

#: ../../library/re.rst:46
msgid "Regular Expression Syntax"
msgstr "正規表現のシンタクス"

#: ../../library/re.rst:48
msgid ""
"A regular expression (or RE) specifies a set of strings that matches it; the "
"functions in this module let you check if a particular string matches a "
"given regular expression (or if a given regular expression matches a "
"particular string, which comes down to the same thing)."
msgstr ""
"正規表現 (すなわち RE) は、表現にマッチ (match) する文字列の集合を表していま"
"す。このモジュールの関数を使えば、ある文字列が指定の正規表現にマッチするか "
"(または指定の正規表現がある文字列にマッチするか、つまりは同じことですが) を検"
"査できます。"

#: ../../library/re.rst:53
msgid ""
"Regular expressions can be concatenated to form new regular expressions; if "
"*A* and *B* are both regular expressions, then *AB* is also a regular "
"expression. In general, if a string *p* matches *A* and another string *q* "
"matches *B*, the string *pq* will match AB.  This holds unless *A* or *B* "
"contain low precedence operations; boundary conditions between *A* and *B*; "
"or have numbered group references.  Thus, complex expressions can easily be "
"constructed from simpler primitive expressions like the ones described "
"here.  For details of the theory and implementation of regular expressions, "
"consult the Friedl book referenced above, or almost any textbook about "
"compiler construction."
msgstr ""
"正規表現を連結すると新しい正規表現を作れます。 *A* と *B* がともに正規表現で"
"あれば *AB* も正規表現です。一般的に、文字列 *p* が A　とマッチし、別の文字"
"列 *q* が B とマッチすれば、文字列 *pq* は AB にマッチします。ただし、この状"
"況が成り立つのは、 *A* と *B* との間に境界条件がある場合や、番号付けされたグ"
"ループ参照のような、優先度の低い演算を *A* や *B* が含まない場合だけです。か"
"くして、ここで述べるような、より簡単でプリミティブな正規表現から、複雑な正規"
"表現を容易に構築できます。正規表現に関する理論と実装の詳細については上記の "
"Friedl 本か、コンパイラの構築に関する教科書を調べて下さい。"

#: ../../library/re.rst:63
msgid ""
"A brief explanation of the format of regular expressions follows.  For "
"further information and a gentler presentation, consult the :ref:`regex-"
"howto`."
msgstr ""
"以下で正規表現の形式に関する簡単な説明をしておきます。より詳細な情報やよりや"
"さしい説明に関しては、 :ref:`regex-howto` を参照下さい。"

#: ../../library/re.rst:66
msgid ""
"Regular expressions can contain both special and ordinary characters. Most "
"ordinary characters, like ``'A'``, ``'a'``, or ``'0'``, are the simplest "
"regular expressions; they simply match themselves.  You can concatenate "
"ordinary characters, so ``last`` matches the string ``'last'``.  (In the "
"rest of this section, we'll write RE's in ``this special style``, usually "
"without quotes, and strings to be matched ``'in single quotes'``.)"
msgstr ""
"正規表現には、特殊文字と通常文字の両方を含められます。 ``'A'`` 、 ``'a'`` 、"
"あるいは ``'0'`` のようなほとんどの通常文字は最も簡単な正規表現になります。こ"
"うした文字は、単純にその文字自体にマッチします。通常の文字は連結できるので、 "
"``last`` は文字列 ``'last'`` とマッチします。 (この節の以降の説明では、正規表"
"現を引用符を使わずに ``この表示スタイル: special style`` で書き、マッチ対象の"
"文字列は、 ``'引用符で括って'`` 書きます。)"

#: ../../library/re.rst:73
msgid ""
"Some characters, like ``'|'`` or ``'('``, are special. Special characters "
"either stand for classes of ordinary characters, or affect how the regular "
"expressions around them are interpreted. Regular expression pattern strings "
"may not contain null bytes, but can specify the null byte using the "
"``\\number`` notation, e.g., ``'\\x00'``."
msgstr ""
"``'|'`` や ``'('`` といったいくつかの文字は特殊文字です。特殊文字は通常の文字"
"の種別を表したり、あるいは特殊文字の周辺にある通常の文字に対する解釈方法に影"
"響します。正規表現パターン文字列には、 null byte を含めることができません"
"が、 ``\\number`` 記法や、 ``'\\x00'`` などとして指定することができます。"

#: ../../library/re.rst:79
msgid ""
"Repetition qualifiers (``*``, ``+``, ``?``, ``{m,n}``, etc) cannot be "
"directly nested. This avoids ambiguity with the non-greedy modifier suffix "
"``?``, and with other modifiers in other implementations. To apply a second "
"repetition to an inner repetition, parentheses may be used. For example, the "
"expression ``(?:a{6})*`` matches any multiple of six ``'a'`` characters."
msgstr ""
"繰り返しの修飾子 (``*``, ``+``, ``?``, ``{m,n}`` など) は直接入れ子にはできま"
"せん。\n"
"これによって、非貪欲な修飾子の接尾辞 ``?`` や他の実装での他の修飾子についての"
"曖昧さを回避しています。\n"
"繰り返しのある正規表現の外側にさらに繰り返しを適用するには丸括弧が使えま"
"す。\n"
"例えば、正規表現 ``(?:a{6})*`` は6つの ``'a'`` の0回以上の繰り返しに適合しま"
"す。"

#: ../../library/re.rst:86
msgid "The special characters are:"
msgstr "特殊文字を以下に示します:"

#: ../../library/re.rst:91
msgid "``'.'``"
msgstr "``'.'``"

#: ../../library/re.rst:89
msgid ""
"(Dot.)  In the default mode, this matches any character except a newline.  "
"If the :const:`DOTALL` flag has been specified, this matches any character "
"including a newline."
msgstr ""
"(ドット) デフォルトのモードでは改行以外の任意の文字にマッチします。 :const:"
"`DOTALL` フラグが指定されていれば改行も含むすべての文字にマッチします。"

#: ../../library/re.rst:95
msgid "``'^'``"
msgstr "``'^'``"

#: ../../library/re.rst:94
msgid ""
"(Caret.)  Matches the start of the string, and in :const:`MULTILINE` mode "
"also matches immediately after each newline."
msgstr ""
"(キャレット) 文字列の先頭とマッチします。 :const:`MULTILINE` モードでは各改行"
"の直後にマッチします。"

#: ../../library/re.rst:104
msgid "``'$'``"
msgstr "``'$'``"

#: ../../library/re.rst:98
msgid ""
"Matches the end of the string or just before the newline at the end of the "
"string, and in :const:`MULTILINE` mode also matches before a newline.  "
"``foo`` matches both 'foo' and 'foobar', while the regular expression "
"``foo$`` matches only 'foo'.  More interestingly, searching for ``foo.$`` in "
"``'foo1\\nfoo2\\n'`` matches 'foo2' normally, but 'foo1' in :const:"
"`MULTILINE` mode; searching for a single ``$`` in ``'foo\\n'`` will find two "
"(empty) matches: one just before the newline, and one at the end of the "
"string."
msgstr ""
"文字列の末尾、あるいは文字列の末尾の改行の直前にマッチします。例えば、 "
"``foo`` は 'foo' と 'foobar' の両方にマッチします。一方、正規表現 ``foo$`` "
"は 'foo' だけとマッチします。興味深いことに、 ``'foo1\\nfoo2\\n'`` を ``foo."
"$`` で検索した場合、通常のモードでは 'foo2' だけにマッチし、 :const:"
"`MULTILINE` モードでは 'foo1' にもマッチします。 ``$`` だけで ``'foo\\n'`` を"
"検索した場合、2箇所 (内容は空) でマッチします: 1つは、改行の直前で、もう1つ"
"は、文字列の最後です。"

#: ../../library/re.rst:109
msgid "``'*'``"
msgstr "``'*'``"

#: ../../library/re.rst:107
msgid ""
"Causes the resulting RE to match 0 or more repetitions of the preceding RE, "
"as many repetitions as are possible.  ``ab*`` will match 'a', 'ab', or 'a' "
"followed by any number of 'b's."
msgstr ""
"直前にある RE に作用して、 RE を 0 回以上できるだけ多く繰り返したものにマッチ"
"させるようにします。例えば ``ab*`` は 'a'、'ab'、あるいは 'a' に任意個数"
"の'b' を続けたものにマッチします。"

#: ../../library/re.rst:114
msgid "``'+'``"
msgstr "``'+'``"

#: ../../library/re.rst:112
msgid ""
"Causes the resulting RE to match 1 or more repetitions of the preceding RE. "
"``ab+`` will match 'a' followed by any non-zero number of 'b's; it will not "
"match just 'a'."
msgstr ""
"直前にある RE に作用して、 RE を、1 回以上繰り返したものにマッチさせるように"
"します。例えば ``ab+`` は 'a' に一つ以上の 'b' が続いたものにマッチし、 'a' "
"単体にはマッチしません。"

#: ../../library/re.rst:118
msgid "``'?'``"
msgstr "``'?'``"

#: ../../library/re.rst:117
msgid ""
"Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. "
"``ab?`` will match either 'a' or 'ab'."
msgstr ""
"直前にある RE に作用して、 RE を 0 回か 1 回繰り返したものにマッチさせるよう"
"にします。例えば ``ab?`` は 'a' あるいは 'ab' にマッチします。"

#: ../../library/re.rst:127
msgid "``*?``, ``+?``, ``??``"
msgstr "``*?``, ``+?``, ``??``"

#: ../../library/re.rst:121
msgid ""
"The ``'*'``, ``'+'``, and ``'?'`` qualifiers are all :dfn:`greedy`; they "
"match as much text as possible.  Sometimes this behaviour isn't desired; if "
"the RE ``<.*>`` is matched against ``<a> b <c>``, it will match the entire "
"string, and not just ``<a>``.  Adding ``?`` after the qualifier makes it "
"perform the match in :dfn:`non-greedy` or :dfn:`minimal` fashion; as *few* "
"characters as possible will be matched.  Using the RE ``<.*?>`` will match "
"only ``<a>``."
msgstr ""
"``'*'`` 、 ``'+'`` 、 ``'?'`` といった修飾子は、すべて :dfn:`貪欲 (greedy)` "
"マッチ、すなわちできるだけ多くのテキストにマッチするようになっています。時に"
"はこの動作が望ましくない場合もあります。例えば正規表現 ``<.*>`` を ``<a> b "
"<c>`` にマッチさせると、 ``<a>`` だけにマッチするのではなく全文字列にマッチし"
"てしまいます。 ``?`` を修飾子の後に追加すると、 :dfn:`非貪欲 (non-greedy)` あ"
"るいは :dfn:`最小一致 (minimal)` のマッチになり、できるだけ *少ない* 文字数の"
"マッチになります。例えば正規表現 ``<.*?>`` を使うと ``<a>`` だけにマッチしま"
"す。"

#: ../../library/re.rst:132
msgid "``{m}``"
msgstr "``{m}``"

#: ../../library/re.rst:130
msgid ""
"Specifies that exactly *m* copies of the previous RE should be matched; "
"fewer matches cause the entire RE not to match.  For example, ``a{6}`` will "
"match exactly six ``'a'`` characters, but not five."
msgstr ""
"前にある RE の *m* 回の正確なコピーとマッチすべきであることを指定します；マッ"
"チ回数が少なければ、RE 全体ではマッチしません。例えば、 ``a{6}`` は、正確に 6"
"個の ``'a'`` 文字とマッチしますが、 5個ではマッチしません。"

#: ../../library/re.rst:141
msgid "``{m,n}``"
msgstr "``{m,n}``"

#: ../../library/re.rst:135
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible.  For "
"example, ``a{3,5}`` will match from 3 to 5 ``'a'`` characters.  Omitting *m* "
"specifies a lower bound of zero,  and omitting *n* specifies an infinite "
"upper bound.  As an example, ``a{4,}b`` will match ``aaaab`` or a thousand "
"``'a'`` characters followed by a ``b``, but not ``aaab``. The comma may not "
"be omitted or the modifier would be confused with the previously described "
"form."
msgstr ""
"結果の RE は、前にある RE を、 *m* 回から *n* 回まで繰り返したもので、できる"
"だけ多く繰り返したものとマッチするように、マッチします。例えば、 ``a{3,5}`` "
"は、3個から 5個の ``'a'`` 文字とマッチします。 *m* を省略するとマッチ回数の下"
"限として0を指定した事になり、 *n* を省略することは、上限が無限であることを指"
"定します； ``a{4,}b`` は ``aaaab`` や、千個の ``'a'`` 文字に ``b`` が続いたも"
"のとマッチしますが、 ``aaab`` とはマッチしません。コンマは省略できません、そ"
"うでないと修飾子が上で述べた形式と混同されてしまうからです。"

#: ../../library/re.rst:148
msgid "``{m,n}?``"
msgstr "``{m,n}?``"

#: ../../library/re.rst:144
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as *few* repetitions as possible.  This is "
"the non-greedy version of the previous qualifier.  For example, on the 6-"
"character string ``'aaaaaa'``, ``a{3,5}`` will match 5 ``'a'`` characters, "
"while ``a{3,5}?`` will only match 3 characters."
msgstr ""
"結果の RE は、前にある RE の *m* 回から *n* 回まで繰り返したもので、できるだ"
"け *少なく* 繰り返したものとマッチするように、マッチします。これは、前の修飾"
"子の控え目バージョンです。例えば、 6文字文字列 ``'aaaaaa'`` では、 ``a{3,5}"
"`` は、5個の ``'a'`` 文字とマッチしますが、 ``a{3,5}?`` は3個の文字とマッチす"
"るだけです。"

#: ../../library/re.rst:161
msgid "``'\\'``"
msgstr "``'\\'``"

#: ../../library/re.rst:151
msgid ""
"Either escapes special characters (permitting you to match characters like "
"``'*'``, ``'?'``, and so forth), or signals a special sequence; special "
"sequences are discussed below."
msgstr ""
"特殊文字をエスケープする( ``'*'`` や ``'?'`` 等のような文字とのマッチをできる"
"ようにする) か、あるいは、特殊シーケンスの合図です; 特殊シーケンスは後で議論"
"します。"

#: ../../library/re.rst:155
msgid ""
"If you're not using a raw string to express the pattern, remember that "
"Python also uses the backslash as an escape sequence in string literals; if "
"the escape sequence isn't recognized by Python's parser, the backslash and "
"subsequent character are included in the resulting string.  However, if "
"Python would recognize the resulting sequence, the backslash should be "
"repeated twice.  This is complicated and hard to understand, so it's highly "
"recommended that you use raw strings for all but the simplest expressions."
msgstr ""
"もしパターンを表現するのに raw string を使用していないのであれば、 Python "
"も、バックスラッシュを文字列リテラルでのエスケープシーケンスとして使っている"
"ことを覚えていて下さい；もしエスケープシーケンスを Python の構文解析器が認識"
"して処理しなければ、そのバックスラッシュとそれに続く文字は、結果の文字列にそ"
"のまま含まれます。しかし、もし Python が結果のシーケンスを認識するのであれ"
"ば、バックスラッシュを 2回繰り返さなければいけません。このことは複雑で理解し"
"にくいので、最も簡単な表現以外は、すべて raw string を使うことをぜひ勧めま"
"す。"

#: ../../library/re.rst:193
msgid "``[]``"
msgstr "``[]``"

#: ../../library/re.rst:164
msgid "Used to indicate a set of characters.  In a set:"
msgstr "文字の集合を指定するのに使用します。集合には以下のものが指定できます:"

#: ../../library/re.rst:166
msgid ""
"Characters can be listed individually, e.g. ``[amk]`` will match ``'a'``, "
"``'m'``, or ``'k'``."
msgstr ""
"個別に指定できる文字。 ``[amk]`` は ``'a'``, ``'m'``, ``'k'`` とマッチしま"
"す。"

#: ../../library/re.rst:169
msgid ""
"Ranges of characters can be indicated by giving two characters and "
"separating them by a ``'-'``, for example ``[a-z]`` will match any lowercase "
"ASCII letter, ``[0-5][0-9]`` will match all the two-digits numbers from "
"``00`` to ``59``, and ``[0-9A-Fa-f]`` will match any hexadecimal digit.  If "
"``-`` is escaped (e.g. ``[a\\-z]``) or if it's placed as the first or last "
"character (e.g. ``[a-]``), it will match a literal ``'-'``."
msgstr ""
"連続した文字の範囲を、先頭と最後の2文字とその間に ``'-'`` を挟んだ形で指定で"
"きます。 ``[a-z]`` はすべての小文字の ASCII 文字とマッチします。 ``[0-5]"
"[0-9]`` は ``00`` から ``59`` までの、すべての 2 桁の数字とマッチします。 "
"``[0-9A-Fa-f]`` は任意の 16 進数の数字とマッチします。 ``-`` が、エスケープさ"
"れた場合 (例: ``[a\\-z]``)、あるいは先頭か末尾に置かれた場合 (例: ``[a-]``)、"
"リテラル ``'-'`` とマッチします。"

#: ../../library/re.rst:176
msgid ""
"Special characters lose their special meaning inside sets.  For example, "
"``[(+*)]`` will match any of the literal characters ``'('``, ``'+'``, "
"``'*'``, or ``')'``."
msgstr ""
"集合内では、特殊文字はその意味を失います。 ``[(+*)]`` はリテラル文字 ``'('`` "
"``'+'`` 、 ``'*'`` 、あるいは ``')'`` のいずれかとマッチします。"

#: ../../library/re.rst:180
msgid ""
"Character classes such as ``\\w`` or ``\\S`` (defined below) are also "
"accepted inside a set, although the characters they match depends on "
"whether :const:`LOCALE` or  :const:`UNICODE` mode is in force."
msgstr ""
"``\\w`` や ``\\S`` のような文字クラス (後述) も集合内に指定できますが、それら"
"にマッチする文字は :const:`LOCALE` か :const:`UNICODE` のどちらか有効にされて"
"いるモードに依存します。"

#: ../../library/re.rst:184
msgid ""
"Characters that are not within a range can be matched by :dfn:"
"`complementing` the set.  If the first character of the set is ``'^'``, all "
"the characters that are *not* in the set will be matched.  For example, "
"``[^5]`` will match any character except ``'5'``, and ``[^^]`` will match "
"any character except ``'^'``.  ``^`` has no special meaning if it's not the "
"first character in the set."
msgstr ""
"範囲内にない文字とは、その集合の :dfn:`補集合` をとることでマッチできます。集"
"合の最初の文字が ``'^'`` の時、集合に *ない* 文字すべてとマッチします。 "
"``[^5]`` は ``'5'`` を除くあらゆる文字にマッチします。 ``[^^]`` は ``'^'`` を"
"除くあらゆる文字にマッチします。 ``^`` は集合の最初の文字でない限り特別の意味"
"を持ちません。"

#: ../../library/re.rst:191
msgid ""
"To match a literal ``']'`` inside a set, precede it with a backslash, or "
"place it at the beginning of the set.  For example, both ``[()[\\]{}]`` and "
"``[]()[{}]`` will both match a parenthesis."
msgstr ""
"集合内でリテラル ``']'`` をマッチさせるには、その前にバックスラッシュをつける"
"か、集合の先頭に置きます。 ``[()[\\]{}]`` と ``[]()[{}]`` はどちらも ``']'`` "
"にマッチします。"

#: ../../library/re.rst:204
msgid "``'|'``"
msgstr "``'|'``"

#: ../../library/re.rst:196
msgid ""
"``A|B``, where A and B can be arbitrary REs, creates a regular expression "
"that will match either A or B.  An arbitrary number of REs can be separated "
"by the ``'|'`` in this way.  This can be used inside groups (see below) as "
"well.  As the target string is scanned, REs separated by ``'|'`` are tried "
"from left to right. When one pattern completely matches, that branch is "
"accepted. This means that once ``A`` matches, ``B`` will not be tested "
"further, even if it would produce a longer overall match.  In other words, "
"the ``'|'`` operator is never greedy.  To match a literal ``'|'``, use ``\\|"
"``, or enclose it inside a character class, as in ``[|]``."
msgstr ""
"``A|B`` は、ここで A と B は任意の RE ですが、 A か B のどちらかとマッチする"
"正規表現を作成します。任意個数の RE を、こういう風に ``'|'`` で分離することが"
"できます。これはグループ (以下参照) 内部でも同様に使えます。検査対象文字列を"
"スキャンする中で、 ``'|'`` で分離された RE は左から右への順に検査されます。一"
"つでも完全にマッチしたパターンがあれば、そのパターン枝が受理されます。このこ"
"とは、もし ``A`` がマッチすれば、たとえ ``B`` によるマッチが全体としてより長"
"いマッチになったとしても、 ``B`` を決して検査しないことを意味します。言いかえ"
"ると、 ``'|'`` 演算子は決して貪欲 (greedy) ではありません。文字通りの "
"``'|'`` とマッチするには、 ``\\|`` を使うか、あるいはそれを ``[|]`` のように"
"文字クラス内に入れます。"

#: ../../library/re.rst:211
msgid "``(...)``"
msgstr "``(...)``"

#: ../../library/re.rst:207
msgid ""
"Matches whatever regular expression is inside the parentheses, and indicates "
"the start and end of a group; the contents of a group can be retrieved after "
"a match has been performed, and can be matched later in the string with the "
"``\\number`` special sequence, described below.  To match the literals "
"``'('`` or ``')'``, use ``\\(`` or ``\\)``, or enclose them inside a "
"character class: ``[(] [)]``."
msgstr ""
"丸括弧の中にどのような正規表現があってもマッチし、またグループの先頭と末尾を"
"表します；グループの中身は、マッチが実行された後に検索され、後述する "
"``\\number`` 特殊シーケンス付きの文字列内で、後でマッチされます。文字通りの "
"``'('`` や ``')'`` とマッチするには、 ``\\(`` あるいは ``\\)`` を使うか、それ"
"らを文字クラス内に入れます： ``[(] [)]`` 。"

#: ../../library/re.rst:218
msgid "``(?...)``"
msgstr "``(?...)``"

#: ../../library/re.rst:214
msgid ""
"This is an extension notation (a ``'?'`` following a ``'('`` is not "
"meaningful otherwise).  The first character after the ``'?'`` determines "
"what the meaning and further syntax of the construct is. Extensions usually "
"do not create a new group; ``(?P<name>...)`` is the only exception to this "
"rule. Following are the currently supported extensions."
msgstr ""
"これは拡張記法です (``'('`` に続く ``'?'`` は他には意味がありません) 。 "
"``'?'`` の後の最初の文字が、この構造の意味とこれ以上のシンタクスがどういうも"
"のであるかを決定します。拡張記法は普通新しいグループを作成しません； ``(?"
"P<name>...)`` がこの規則の唯一の例外です。以下に現在サポートされている拡張記"
"法を示します。"

#: ../../library/re.rst:235
msgid "``(?iLmsux)``"
msgstr "``(?iLmsux)``"

#: ../../library/re.rst:221
msgid ""
"(One or more letters from the set ``'i'``, ``'L'``, ``'m'``, ``'s'``, "
"``'u'``, ``'x'``.)  The group matches the empty string; the letters set the "
"corresponding flags: :const:`re.I` (ignore case), :const:`re.L` (locale "
"dependent), :const:`re.M` (multi-line), :const:`re.S` (dot matches all), :"
"const:`re.U` (Unicode dependent), and :const:`re.X` (verbose), for the "
"entire regular expression. (The flags are described in :ref:`contents-of-"
"module-re`.) This is useful if you wish to include the flags as part of the "
"regular expression, instead of passing a *flag* argument to the :func:`re."
"compile` function."
msgstr ""
"( 集合 ``'i'``, ``'L'``, ``'m'``, ``'s'``, ``'u'``, ``'x'`` から1文字以上) 。"
"グループは空文字列ともマッチします；文字は、正規表現全体の対応するフラグ (:"
"const:`re.I` (大文字・小文字を区別しない), :const:`re.L` (ロケール依存), :"
"const:`re.M` (MULTILINEモード), :const:`re.S` (DOTALLモード), :const:`re.U` "
"(Unicode依存), :const:`re.X` (冗長) ) を設定します。 (フラグについては、 :"
"ref:`contents-of-module-re` に記述があります) これは、もし *flag* 引数を :"
"func:`re.compile` 関数に渡さずに、そのフラグを正規表現の一部として含めたいな"
"らば役に立ちます。"

#: ../../library/re.rst:232
msgid ""
"Note that the ``(?x)`` flag changes how the expression is parsed. It should "
"be used first in the expression string, or after one or more whitespace "
"characters. If there are non-whitespace characters before the flag, the "
"results are undefined."
msgstr ""
"``(?x)`` フラグは、式が構文解析される方法を変更することに注意して下さい。これ"
"は式文字列内の最初か、あるいは1つ以上の空白文字の後で使うべきです。もしこのフ"
"ラグの前に非空白文字があると、その結果は未定義です。"

#: ../../library/re.rst:241
msgid "``(?:...)``"
msgstr "``(?:...)``"

#: ../../library/re.rst:238
msgid ""
"A non-capturing version of regular parentheses.  Matches whatever regular "
"expression is inside the parentheses, but the substring matched by the group "
"*cannot* be retrieved after performing a match or referenced later in the "
"pattern."
msgstr ""
"正規表現の丸括弧の取り込まないバージョンです。どのような正規表現が丸括弧内に"
"あってもマッチしますが、グループによってマッチされたサブ文字列は、マッチを実"
"行したあと検索されることも、あるいは後でパターンで参照されることも *できませ"
"ん* 。"

#: ../../library/re.rst:266
msgid "``(?P<name>...)``"
msgstr "``(?P<name>...)``"

#: ../../library/re.rst:244
msgid ""
"Similar to regular parentheses, but the substring matched by the group is "
"accessible via the symbolic group name *name*.  Group names must be valid "
"Python identifiers, and each group name must be defined only once within a "
"regular expression.  A symbolic group is also a numbered group, just as if "
"the group were not named."
msgstr ""
"正規表現の丸括弧に似ていますが、グループによってマッチした部分文字列はシンボ"
"リック\\ グループ名 *name* によってアクセス可能になります。グループ名は有効"
"な Python 識別子でなければならず、グループ名は 1 個の正規表現内で一意でなけれ"
"ばなりません。シンボリックグループは番号付けもされており、番号によるアクセス"
"も可能です。"

#: ../../library/re.rst:250
msgid ""
"Named groups can be referenced in three contexts.  If the pattern is ``(?"
"P<quote>['\"]).*?(?P=quote)`` (i.e. matching a string quoted with either "
"single or double quotes):"
msgstr ""
"名前付きグループは 3 つのコンテキストで参照できます。パターンが ``(?"
"P<quote>['\\\"]).*?(?P=quote)`` (シングルまたはダブルクオートのどちらかにマッ"
"チ) の場合`:"

#: ../../library/re.rst:255
msgid "Context of reference to group \"quote\""
msgstr "グループ \"quote\" を参照するコンテキスト"

#: ../../library/re.rst:255
msgid "Ways to reference it"
msgstr "参照方法"

#: ../../library/re.rst:257
msgid "in the same pattern itself"
msgstr "同一パターンへの参照"

#: ../../library/re.rst:257
msgid "``(?P=quote)`` (as shown)"
msgstr "``(?P=quote)`` (そのまま)"

#: ../../library/re.rst:258 ../../library/re.rst:265
msgid "``\\1``"
msgstr "``\\1``"

#: ../../library/re.rst:260
msgid "when processing match object ``m``"
msgstr "マッチオブジェクト ``m`` の処理時"

#: ../../library/re.rst:260
msgid "``m.group('quote')``"
msgstr "``m.group('quote')``"

#: ../../library/re.rst:261
msgid "``m.end('quote')`` (etc.)"
msgstr "``m.end('quote')`` (etc.)"

#: ../../library/re.rst:263
msgid "in a string passed to the ``repl`` argument of ``re.sub()``"
msgstr "``re.sub()`` の ``repl`` 引数へ渡される文字列"

#: ../../library/re.rst:263
msgid "``\\g<quote>``"
msgstr "``\\g<quote>``"

#: ../../library/re.rst:264
msgid "``\\g<1>``"
msgstr "``\\g<1>``"

#: ../../library/re.rst:270
msgid "``(?P=name)``"
msgstr "``(?P=name)``"

#: ../../library/re.rst:269
msgid ""
"A backreference to a named group; it matches whatever text was matched by "
"the earlier group named *name*."
msgstr ""
"名前付きグループへの後方参照です; 既出のグループ名 *name* にマッチする文字列"
"は何にでもマッチします。"

#: ../../library/re.rst:273
msgid "``(?#...)``"
msgstr "``(?#...)``"

#: ../../library/re.rst:273
msgid "A comment; the contents of the parentheses are simply ignored."
msgstr "コメントです；括弧の内容は単純に無視されます。"

#: ../../library/re.rst:278
msgid "``(?=...)``"
msgstr "``(?=...)``"

#: ../../library/re.rst:276
msgid ""
"Matches if ``...`` matches next, but doesn't consume any of the string.  "
"This is called a lookahead assertion.  For example, ``Isaac (?=Asimov)`` "
"will match ``'Isaac '`` only if it's followed by ``'Asimov'``."
msgstr ""
"もし ``...`` が次に続くものとマッチすればマッチしますが、文字列をまったく消費"
"しません。これは先読みアサーション (lookahead assertion) と呼ばれます。例え"
"ば、 ``Isaac (?=Asimov)`` は、 ``'Isaac '`` に ``'Asimov'`` が続く場合だけ、 "
"``'Isaac '`` とマッチします。"

#: ../../library/re.rst:283
msgid "``(?!...)``"
msgstr "``(?!...)``"

#: ../../library/re.rst:281
msgid ""
"Matches if ``...`` doesn't match next.  This is a negative lookahead "
"assertion. For example, ``Isaac (?!Asimov)`` will match ``'Isaac '`` only if "
"it's *not* followed by ``'Asimov'``."
msgstr ""
"もし ``...`` が次に続くものとマッチしなければマッチします。これは否定先読みア"
"サーション (negative lookahead assertion) です。例えば、 ``Isaac (?!"
"Asimov)`` は、 ``'Isaac '`` に ``'Asimov'`` が続か *ない* 場合のみマッチしま"
"す。"

#: ../../library/re.rst:307
msgid "``(?<=...)``"
msgstr "``(?<=...)``"

#: ../../library/re.rst:286
msgid ""
"Matches if the current position in the string is preceded by a match for "
"``...`` that ends at the current position.  This is called a :dfn:`positive "
"lookbehind assertion`. ``(?<=abc)def`` will find a match in ``abcdef``, "
"since the lookbehind will back up 3 characters and check if the contained "
"pattern matches. The contained pattern must only match strings of some fixed "
"length, meaning that ``abc`` or ``a|b`` are allowed, but ``a*`` and ``a{3,4}"
"`` are not.  Group references are not supported even if they match strings "
"of some fixed length. Note that patterns which start with positive "
"lookbehind assertions will not match at the beginning of the string being "
"searched; you will most likely want to use the :func:`search` function "
"rather than the :func:`match` function:"
msgstr ""
"文字列内の現在位置の前に、現在位置で終わる ``...`` とのマッチがあれば、マッチ"
"します。これは :dfn:`後読みアサーション` と呼ばれます。 ``(?<=abc)def`` は "
"``abcdef`` にマッチを見つけます。後読みは 3 文字をバックアップし、含まれてい"
"るパターンとマッチするかどうか検査します。含まれるパターンは、固定長の文字列"
"にのみマッチしなければなりません。すなわち、 ``abc`` や ``a|b`` は許されます"
"が、 ``a*`` や ``a{3,4}`` は許されません。グループ参照は固定長の文字列にマッ"
"チするときでさえサポートされません。肯定後読みアサーションで始まるパターン"
"は、検索される文字列の先頭とは決してマッチしないことに注意して下さい; この表"
"現を使用するのは、おそらく :func:`match` 関数より :func:`search` 関数の方が適"
"しています:"

#: ../../library/re.rst:303
msgid "This example looks for a word following a hyphen:"
msgstr "この例ではハイフンに続く単語を探します:"

#: ../../library/re.rst:315
msgid "``(?<!...)``"
msgstr "``(?<!...)``"

#: ../../library/re.rst:310
msgid ""
"Matches if the current position in the string is not preceded by a match for "
"``...``.  This is called a :dfn:`negative lookbehind assertion`.  Similar to "
"positive lookbehind assertions, the contained pattern must only match "
"strings of some fixed length and shouldn't contain group references. "
"Patterns which start with negative lookbehind assertions may match at the "
"beginning of the string being searched."
msgstr ""
"文字列内の現在位置の前に ``...`` とのマッチがない場合に、マッチします。これ"
"は :dfn:`否定後読みアサーション(negative lookbehind assertion)` と呼ばれま"
"す。肯定後読みアサーションと同様に、含まれるパターンは固定長さの文字列だけに"
"マッチしなければならず、グループ参照を含んではなりません。否定後読みアサー"
"ションで始まるパターンは、検索される文字列の先頭とマッチできます。"

#: ../../library/re.rst:324
msgid "``(?(id/name)yes-pattern|no-pattern)``"
msgstr "``(?(id/name)yes-pattern|no-pattern)``"

#: ../../library/re.rst:318
msgid ""
"Will try to match with ``yes-pattern`` if the group with given *id* or "
"*name* exists, and with ``no-pattern`` if it doesn't. ``no-pattern`` is "
"optional and can be omitted. For example,  ``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?"
"(1)>)`` is a poor email matching pattern, which will match with "
"``'<user@host.com>'`` as well as ``'user@host.com'``, but not with "
"``'<user@host.com'``."
msgstr ""
"グループに *id* が与えられている、もしくは *name* があるとき、 ``yes-"
"pattern`` とマッチします。存在しないときには ``no-pattern`` とマッチします。 "
"``no-pattern`` はオプションで省略できます。例えば ``(<)?(\\w+@\\w+(?:\\."
"\\w+)+)(?(1)>)`` はemailアドレスとマッチする最低限のパターンです。これは "
"``'<user@host.com>'`` や ``'user@host.com'`` にはマッチしますが、 "
"``'<user@host.com'`` にはマッチしません。"

#: ../../library/re.rst:326
msgid ""
"The special sequences consist of ``'\\'`` and a character from the list "
"below. If the ordinary character is not on the list, then the resulting RE "
"will match the second character.  For example, ``\\$`` matches the character "
"``'$'``."
msgstr ""
"特殊シーケンスは ``'\\'`` と以下のリストにある文字から構成されます。もしリス"
"トにあるのが通常文字でないならば、結果の RE は2番目の文字とマッチします。例え"
"ば、 ``\\$`` は文字 ``'$'`` とマッチします。"

#: ../../library/re.rst:338
msgid "``\\number``"
msgstr "``\\number``"

#: ../../library/re.rst:331
msgid ""
"Matches the contents of the group of the same number.  Groups are numbered "
"starting from 1.  For example, ``(.+) \\1`` matches ``'the the'`` or ``'55 "
"55'``, but not ``'thethe'`` (note the space after the group).  This special "
"sequence can only be used to match one of the first 99 groups.  If the first "
"digit of *number* is 0, or *number* is 3 octal digits long, it will not be "
"interpreted as a group match, but as the character with octal value "
"*number*. Inside the ``'['`` and ``']'`` of a character class, all numeric "
"escapes are treated as characters."
msgstr ""
"同じ番号のグループの中身とマッチします。グループは1から始まる番号をつけられま"
"す。例えば、 ``(.+) \\1`` は、 ``'the the'`` あるいは ``'55 55'`` とマッチし"
"ますが、 ``'thethe'`` とはマッチしません(グループの後のスペースに注意して下さ"
"い)。この特殊シーケンスは最初の 99 グループのうちの一つとマッチするのに使うこ"
"とができるだけです。もし *number* の最初の桁が 0 である、すなわち *number* "
"が 3 桁の8進数であれば、それはグループのマッチとは解釈されず、 8進数値 "
"*number* を持つ文字として解釈されます。文字クラスの ``'['`` と ``']'`` の中の"
"数値エスケープは、文字として扱われます。"

#: ../../library/re.rst:341
msgid "``\\A``"
msgstr "``\\A``"

#: ../../library/re.rst:341
msgid "Matches only at the start of the string."
msgstr "文字列の先頭だけにマッチします。"

#: ../../library/re.rst:354
msgid "``\\b``"
msgstr "``\\b``"

#: ../../library/re.rst:344
msgid ""
"Matches the empty string, but only at the beginning or end of a word.  A "
"word is defined as a sequence of alphanumeric or underscore characters, so "
"the end of a word is indicated by whitespace or a non-alphanumeric, non-"
"underscore character. Note that formally, ``\\b`` is defined as the boundary "
"between a ``\\w`` and a ``\\W`` character (or vice versa), or between "
"``\\w`` and the beginning/end of the string, so the precise set of "
"characters deemed to be alphanumeric depends on the values of the "
"``UNICODE`` and ``LOCALE`` flags. For example, ``r'\\bfoo\\b'`` matches "
"``'foo'``, ``'foo.'``, ``'(foo)'``, ``'bar foo baz'`` but not ``'foobar'`` "
"or ``'foo3'``. Inside a character range, ``\\b`` represents the backspace "
"character, for compatibility with Python's string literals."
msgstr ""
"空文字列とマッチしますが、単語の先頭か末尾の時だけです。単語とは英数字または"
"アンダースコアからなるシーケンスで、単語の終わりは空白文字、あるいはアンダー"
"スコアを除く記号で表します。 ``\\b`` は ``\\w`` および ``\\W`` の間 (およびそ"
"の逆) あるいは ``\\w`` と文字列の開始/終了との間の境界として定義されています"
"ので、文字の正確な集合は ``UNICODE`` と ``LOCALE`` フラグの値に依存します。例"
"えば、 ``r'\\bfoo\\b'`` は ``'foo'`` , ``'foo.'`` , ``'(foo)'``, ``'bar foo "
"baz'`` にマッチしますが、 ``'foobar'``, ``'foo3'`` にはマッチしません。文字範"
"囲内では、 ``\\b`` は Python の文字列リテラルとの互換性のため、後退 "
"(backspace) 文字を表します。"

#: ../../library/re.rst:361
msgid "``\\B``"
msgstr "``\\B``"

#: ../../library/re.rst:357
msgid ""
"Matches the empty string, but only when it is *not* at the beginning or end "
"of a word.  This means that ``r'py\\B'`` matches ``'python'``, ``'py3'``, "
"``'py2'``, but not ``'py'``, ``'py.'``, or ``'py!'``. ``\\B`` is just the "
"opposite of ``\\b``, so is also subject to the settings of ``LOCALE`` and "
"``UNICODE``."
msgstr ""
"空文字列とマッチしますが、それが単語の先頭あるいは末尾に *ない* 時だけです。 "
"``r'py\\B'`` は ``'python'``, ``'py3'``, ``'py2'`` にはマッチしますが、 "
"``'py'``, ``'py.'``, ``'py!'`` にはマッチしません。これは ``\\b`` のちょうど"
"反対ですので、同じように ``LOCALE`` と ``UNICODE`` の設定に影響されます。"

#: ../../library/re.rst:367
msgid "``\\d``"
msgstr "``\\d``"

#: ../../library/re.rst:364
msgid ""
"When the :const:`UNICODE` flag is not specified, matches any decimal digit; "
"this is equivalent to the set ``[0-9]``.  With :const:`UNICODE`, it will "
"match whatever is classified as a decimal digit in the Unicode character "
"properties database."
msgstr ""
":const:`UNICODE` フラグが指定されていない場合、任意の十進数とマッチします；こ"
"れは集合 ``[0-9]`` と同じ意味です。 :const:`UNICODE` がある場合、Unicode 文字"
"特性データベースで十進数字と分類されているものにマッチします。"

#: ../../library/re.rst:373
msgid "``\\D``"
msgstr "``\\D``"

#: ../../library/re.rst:370
msgid ""
"When the :const:`UNICODE` flag is not specified, matches any non-digit "
"character; this is equivalent to the set  ``[^0-9]``.  With :const:"
"`UNICODE`, it will match  anything other than character marked as digits in "
"the Unicode character  properties database."
msgstr ""
":const:`UNICODE` フラグが指定されていない場合、任意の非数字文字とマッチしま"
"す；これは集合 ``[^0-9]`` と同じ意味です。 :const:`UNICODE` がある場合、これ"
"は Unicode 文字特性データベースで数字とマーク付けされている文字以外にマッチし"
"ます。"

#: ../../library/re.rst:381
msgid "``\\s``"
msgstr "``\\s``"

#: ../../library/re.rst:376
msgid ""
"When the :const:`UNICODE` flag is not specified, it matches any whitespace "
"character, this is equivalent to the set ``[ \\t\\n\\r\\f\\v]``. The :const:"
"`LOCALE` flag has no extra effect on matching of the space. If :const:"
"`UNICODE` is set, this will match the characters ``[ \\t\\n\\r\\f\\v]`` plus "
"whatever is classified as space in the Unicode character properties database."
msgstr ""
":const:`UNICODE` フラグが指定されていない場合、任意の空白文字とマッチし、これ"
"は集合 ``[ \\t\\n\\r\\f\\v]`` と同じ意味です。 :const:`LOCALE` フラグは空白文"
"字とのマッチについて特別な意味を持ちません。 :const:`UNICODE` が指定されてい"
"る場合、これは ``[ \\t\\n\\r\\f\\v]`` と Unicode 文字特性データベースで空白と"
"分類されている全てにマッチします。"

#: ../../library/re.rst:389
msgid "``\\S``"
msgstr "``\\S``"

#: ../../library/re.rst:384
msgid ""
"When the :const:`UNICODE` flag is not specified, matches any non-whitespace "
"character; this is equivalent to the set ``[^ \\t\\n\\r\\f\\v]`` The :const:"
"`LOCALE` flag has no extra effect on non-whitespace match.  If :const:"
"`UNICODE` is set, then any character not marked as space in the Unicode "
"character properties database is matched."
msgstr ""
":const:`UNICODE` フラグが指定されていない場合、任意の非空白文字とマッチし、こ"
"れは集合 ``[^ \\t\\n\\r\\f\\v]`` と同じ意味です。 :const:`LOCALE` フラグは非"
"空白文字とのマッチについて特別な意味を持ちません。 :const:`UNICODE` が指定さ"
"れている場合、これは Unicode 文字特性データベースで非空白と分類されている全て"
"にマッチします。"

#: ../../library/re.rst:397
msgid "``\\w``"
msgstr "``\\w``"

#: ../../library/re.rst:392
msgid ""
"When the :const:`LOCALE` and :const:`UNICODE` flags are not specified, "
"matches any alphanumeric character and the underscore; this is equivalent to "
"the set ``[a-zA-Z0-9_]``.  With :const:`LOCALE`, it will match the set "
"``[0-9_]`` plus whatever characters are defined as alphanumeric for the "
"current locale.  If :const:`UNICODE` is set, this will match the characters "
"``[0-9_]`` plus whatever is classified as alphanumeric in the Unicode "
"character properties database."
msgstr ""
":const:`LOCALE` と :const:`UNICODE` フラグが指定されていない時は、任意の英数"
"文字および下線とマッチします；これは、集合 ``[a-zA-Z0-9_]`` と同じ意味で"
"す。 :const:`LOCALE` が設定されていると、集合 ``[0-9_]`` プラス現在のロケール"
"用に英数字として定義されている任意の文字とマッチします。もし :const:"
"`UNICODE` が設定されていれば、文字 ``[0-9_]`` プラス Unicode 文字特性データ"
"ベースで英数字として分類されているものとマッチします。"

#: ../../library/re.rst:405
msgid "``\\W``"
msgstr "``\\W``"

#: ../../library/re.rst:400
msgid ""
"When the :const:`LOCALE` and :const:`UNICODE` flags are not specified, "
"matches any non-alphanumeric character; this is equivalent to the set ``[^a-"
"zA-Z0-9_]``. With :const:`LOCALE`, it will match any character not in the "
"set ``[0-9_]``, and not defined as alphanumeric for the current locale. If :"
"const:`UNICODE` is set, this will match anything other than ``[0-9_]`` plus "
"characters classified as not alphanumeric in the Unicode character "
"properties database."
msgstr ""
":const:`LOCALE` と :const:`UNICODE` フラグが指定されていない時、任意の非英数"
"文字とマッチします；これは集合 ``[^a-zA-Z0-9_]`` と同じ意味です。 :const:"
"`LOCALE` が指定されていると、集合 ``[0-9_]`` になく、現在のロケールで英数字と"
"して定義されていない任意の文字とマッチします。もし :const:`UNICODE` がセット"
"されていれば、これは ``[0-9_]`` 以外と、および Unicode 文字特性データベースで"
"非英数字と分類されている文字とマッチします。"

#: ../../library/re.rst:408
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../../library/re.rst:408
msgid "Matches only at the end of the string."
msgstr "文字列の末尾とのみマッチします。"

#: ../../library/re.rst:410
msgid ""
"If both :const:`LOCALE` and :const:`UNICODE` flags are included for a "
"particular sequence, then :const:`LOCALE` flag takes effect first followed "
"by the :const:`UNICODE`."
msgstr ""
"特定のシーケンスに対し :const:`LOCALE` と :const:`UNICODE` のどちらも影響しう"
"る場合は、 :const:`LOCALE` が指定されていれば必ず :const:`LOCALE` の効果に従"
"います。"

#: ../../library/re.rst:414
msgid ""
"Most of the standard escapes supported by Python string literals are also "
"accepted by the regular expression parser::"
msgstr ""
"Python 文字列リテラルによってサポートされている標準エスケープのほとんども、正"
"規表現パーザに認識されます::"

#: ../../library/re.rst:421
msgid ""
"(Note that ``\\b`` is used to represent word boundaries, and means "
"\"backspace\" only inside character classes.)"
msgstr ""
"(``\\b`` は単語の境界を表し、文字クラス内でのみ後退 (backspace) 文字を指すこ"
"とに注意してください)"

#: ../../library/re.rst:424
msgid ""
"Octal escapes are included in a limited form: If the first digit is a 0, or "
"if there are three octal digits, it is considered an octal escape. "
"Otherwise, it is a group reference.  As for string literals, octal escapes "
"are always at most three digits in length."
msgstr ""
"8進エスケープは制限された形式で含まれています：もし第1桁が 0 であるか、もし8"
"進3桁であれば、それは 8進エスケープとみなされます。そうでなければ、それはグ"
"ループ参照です。文字列リテラルについて、 8進エスケープはほとんどの場合3桁長に"
"なります。"

#: ../../library/re.rst:433
msgid "Mastering Regular Expressions"
msgstr "Mastering Regular Expressions 詳説正規表現"

#: ../../library/re.rst:432
msgid ""
"Book on regular expressions by Jeffrey Friedl, published by O'Reilly.  The "
"second edition of the book no longer covers Python at all, but the first "
"edition covered writing good regular expression patterns in great detail."
msgstr ""
"Jeffrey Friedl 著、O'Reilly 刊の正規表現に関する本です。この本の第2版\\ では"
"Pyhonについては触れていませんが、良い正規表現パターンの書き方を非常に\\ くわ"
"しく説明しています。"

#: ../../library/re.rst:441
msgid "Module Contents"
msgstr "モジュールコンテンツ"

#: ../../library/re.rst:443
msgid ""
"The module defines several functions, constants, and an exception. Some of "
"the functions are simplified versions of the full featured methods for "
"compiled regular expressions.  Most non-trivial applications always use the "
"compiled form."
msgstr ""
"このモジュールは幾つかの関数、定数、例外を定義します。この関数のいくつかはコ"
"ンパイル済み正規表現向けの完全版のメソッドを簡略化したバージョンです。それな"
"りのアプリケーションのほとんどで、コンパイルされた形式が用いられるのが普通で"
"す。"

#: ../../library/re.rst:451
msgid ""
"Compile a regular expression pattern into a regular expression object, which "
"can be used for matching using its :func:`~RegexObject.match` and :func:"
"`~RegexObject.search` methods, described below."
msgstr ""
"正規表現パターンを正規表現オブジェクトにコンパイルします。このオブジェクト"
"は、以下で述べる :func:`~RegexObject.match` と :func:`~RegexObject.search` メ"
"ソッドを使って、マッチングに使うことができます。"

#: ../../library/re.rst:455
msgid ""
"The expression's behaviour can be modified by specifying a *flags* value. "
"Values can be any of the following variables, combined using bitwise OR (the "
"``|`` operator)."
msgstr ""
"式の動作は、 *flags* の値を指定することで加減することができます。値は以下の変"
"数を、ビットごとの OR ( ``|`` 演算子)を使って組み合わせることができます。"

#: ../../library/re.rst:459
msgid "The sequence ::"
msgstr "シーケンス ::"

#: ../../library/re.rst:464
msgid "is equivalent to ::"
msgstr "は、 ::"

#: ../../library/re.rst:468
msgid ""
"but using :func:`re.compile` and saving the resulting regular expression "
"object for reuse is more efficient when the expression will be used several "
"times in a single program."
msgstr ""
"と同じ意味ですが、 :func:`re.compile` を使ってその結果の正規表現オブジェクト"
"を再利用した方が、その式を一つのプログラムで何回も使う時にはより効率的です。"

#: ../../library/re.rst:474
msgid ""
"The compiled versions of the most recent patterns passed to :func:`re."
"match`, :func:`re.search` or :func:`re.compile` are cached, so programs that "
"use only a few regular expressions at a time needn't worry about compiling "
"regular expressions."
msgstr ""
"最後に :func:`re.match`, :func:`re.search`, :func:`re.compile` に渡されたパ"
"ターンのコンパイルされたものがキャッシュとして残ります。そのため、正規表現を"
"ひとつだけしか使わないプログラムは正規表現のコンパイルを気にする必要はありま"
"せん。"

#: ../../library/re.rst:482
msgid "Display debug information about compiled expression."
msgstr "コンパイルした表現に関するデバッグ情報を出力します。"

#: ../../library/re.rst:488
msgid ""
"Perform case-insensitive matching; expressions like ``[A-Z]`` will match "
"lowercase letters, too.  This is not affected by the current locale.  To get "
"this effect on non-ASCII Unicode characters such as ``ü`` and ``Ü``, add "
"the :const:`UNICODE` flag."
msgstr ""

#: ../../library/re.rst:497
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s`` and ``\\S`` dependent on "
"the current locale."
msgstr ""
"``\\w`` 、 ``\\W`` 、 ``\\b`` および、 ``\\B`` 、 ``\\s`` と ``\\S`` を、現在"
"のロケールに従わさせます。"

#: ../../library/re.rst:504
msgid ""
"When specified, the pattern character ``'^'`` matches at the beginning of "
"the string and at the beginning of each line (immediately following each "
"newline); and the pattern character ``'$'`` matches at the end of the string "
"and at the end of each line (immediately preceding each newline).  By "
"default, ``'^'`` matches only at the beginning of the string, and ``'$'`` "
"only at the end of the string and immediately before the newline (if any) at "
"the end of the string."
msgstr ""
"指定されると、パターン文字 ``'^'`` は、文字列の先頭および各行の先頭(各改行の"
"直後)とマッチします；そしてパターン文字 ``'$'`` は文字列の末尾および各行の末"
"尾 (改行の直前) とマッチします。デフォルトでは、 ``'^'`` は、文字列の先頭とだ"
"けマッチし、 ``'$'`` は、文字列の末尾および文字列の末尾の改行の直前(がもしあ"
"れば)とマッチします。"

#: ../../library/re.rst:515
msgid ""
"Make the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline."
msgstr ""
"特殊文字 ``'.'`` を、改行を含む任意の文字と、とにかくマッチさせます；このフラ"
"グがなければ、 ``'.'`` は、改行 *以外の* 任意の文字とマッチします。"

#: ../../library/re.rst:522
msgid ""
"Make the ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` and "
"``\\S`` sequences dependent on the Unicode character properties database. "
"Also enables non-ASCII matching for :const:`IGNORECASE`."
msgstr ""

#: ../../library/re.rst:532
msgid ""
"This flag allows you to write regular expressions that look nicer and are "
"more readable by allowing you to visually separate logical sections of the "
"pattern and add comments. Whitespace within the pattern is ignored, except "
"when in a character class, or when preceded by an unescaped backslash, or "
"within tokens like ``*?``, ``(?:`` or ``(?P<...>``. When a line contains a "
"``#`` that is not in a character class and is not preceded by an unescaped "
"backslash, all characters from the leftmost such ``#`` through the end of "
"the line are ignored."
msgstr ""
"このフラグは正規表現を、パターンの論理的な節を視覚的に分割し、コメントを加え"
"ることで、見た目よく読みやすく書けるようにします。パターン中の空白は、文字ク"
"ラス中にあるときと、エスケープされていないバックスラッシュの後にあるときと、 "
"``*?`` 、 ``(?:`` や ``(?P<...>`` のようなトークン中を除いて無視されます。あ"
"る行が文字クラス中でもエスケープされていないバックスラッシュの後でもない "
"``#`` を含むなら、一番左のそのような ``#`` から行末までの全ての文字は無視され"
"ます。"

#: ../../library/re.rst:541
msgid ""
"This means that the two following regular expression objects that match a "
"decimal number are functionally equal::"
msgstr ""
"つまり、数字にマッチする下記のふたつの正規表現オブジェクトは、機能的に等価で"
"す。::"

#: ../../library/re.rst:552
msgid ""
"Scan through *string* looking for the first location where the regular "
"expression *pattern* produces a match, and return a corresponding :class:"
"`MatchObject` instance. Return ``None`` if no position in the string matches "
"the pattern; note that this is different from finding a zero-length match at "
"some point in the string."
msgstr ""
"*string* 全体を走査して、正規表現 *pattern* がマッチを発生する最初の位置を探"
"して、対応する :class:`MatchObject` インスタンスを返します。もし文字列内に、"
"そのパターンとマッチする位置がないならば、 ``None`` を返します；これは、文字"
"列内のある点で長さゼロのマッチを探すこととは異なることに注意して下さい。"

#: ../../library/re.rst:561
msgid ""
"If zero or more characters at the beginning of *string* match the regular "
"expression *pattern*, return a corresponding :class:`MatchObject` instance. "
"Return ``None`` if the string does not match the pattern; note that this is "
"different from a zero-length match."
msgstr ""
"もし *string* の先頭で 0 個以上の文字が正規表現 *pattern* とマッチすれば、対"
"応する :class:`MatchObject` インスタンスを返します。もし文字列がパターンと"
"マッチしなければ、 ``None`` を返します；これは長さゼロのマッチとは異なること"
"に注意して下さい。"

#: ../../library/re.rst:566
msgid ""
"Note that even in :const:`MULTILINE` mode, :func:`re.match` will only match "
"at the beginning of the string and not at the beginning of each line."
msgstr ""
":const:`MULTILINE` モードであっても、:func:`re.match` は文字列の先頭のみに"
"マッチし、各行の先頭にはマッチしないことに注意してください。"

#: ../../library/re.rst:569
msgid ""
"If you want to locate a match anywhere in *string*, use :func:`search` "
"instead (see also :ref:`search-vs-match`)."
msgstr ""
"*string* のどこにでもマッチさせたければ、 :func:`search` を使って下さい (:"
"ref:`search-vs-match` も参照してください)。"

#: ../../library/re.rst:575
msgid ""
"Split *string* by the occurrences of *pattern*.  If capturing parentheses "
"are used in *pattern*, then the text of all groups in the pattern are also "
"returned as part of the resulting list. If *maxsplit* is nonzero, at most "
"*maxsplit* splits occur, and the remainder of the string is returned as the "
"final element of the list.  (Incompatibility note: in the original Python "
"1.5 release, *maxsplit* was ignored.  This has been fixed in later releases.)"
msgstr ""
"*string* を、 *pattern* があるたびに分割します。もし括弧のキャプチャが "
"*pattern* で使われていれば、パターン内のすべてのグループのテキストも結果のリ"
"ストの一部として返されます。 *maxsplit* がゼロでなければ、高々 *maxsplit* 個"
"の分割が発生し、文字列の残りは、リストの最終要素として返されます。 (非互換性"
"ノート：オリジナルの Python 1.5 リリースでは、 *maxsplit* は無視されていまし"
"た。これはその後のリリースでは修正されました。)"

#: ../../library/re.rst:591
msgid ""
"If there are capturing groups in the separator and it matches at the start "
"of the string, the result will start with an empty string.  The same holds "
"for the end of the string:"
msgstr ""
"もし、捕捉するグループが分割パターンに含まれ、それが文字列の先頭にあるなら"
"ば、分割結果は、空文字列から始まります。文字列最後においても同様です。"

#: ../../library/re.rst:598
msgid ""
"That way, separator components are always found at the same relative indices "
"within the result list (e.g., if there's one capturing group in the "
"separator, the 0th, the 2nd and so forth)."
msgstr ""
"その場合、常に、分割要素が、分割結果のリストの相対的なインデックスに現れま"
"す。 (例えば、分割子の中に捕捉するグループが一つだけあれば、0番目、2番目、そ"
"して、4番目です)"

#: ../../library/re.rst:602
msgid ""
"Note that *split* will never split a string on an empty pattern match. For "
"example:"
msgstr ""
"*split* は空のパターンマッチでは、文字列を分割しないことに注意して下さい。例"
"えば:"

#: ../../library/re.rst:610 ../../library/re.rst:632 ../../library/re.rst:645
#: ../../library/re.rst:695 ../../library/re.rst:704
msgid "Added the optional flags argument."
msgstr "オプションの flags 引数が追加されました。"

#: ../../library/re.rst:617
msgid ""
"Return all non-overlapping matches of *pattern* in *string*, as a list of "
"strings.  The *string* is scanned left-to-right, and matches are returned in "
"the order found.  If one or more groups are present in the pattern, return a "
"list of groups; this will be a list of tuples if the pattern has more than "
"one group.  Empty matches are included in the result."
msgstr ""
"*string* 中の *pattern* による全ての重複しないマッチを、文字列のリストとして"
"返します。 *string* は左から右へ走査され、マッチは見つかった順で返されます。"
"パターン中に 1 つ以上のグループがあれば、グループのリストを返します。パターン"
"に複数のグループがあればタプルのリストになります。空マッチは結果に含まれま"
"す。"

#: ../../library/re.rst:625
msgid ""
"Due to the limitation of the current implementation the character following "
"an empty match is not included in a next match, so ``findall(r'^|\\w+', 'two "
"words')`` returns ``['', 'wo', 'words']`` (note missed \"t\").  This is "
"changed in Python 3.7."
msgstr ""

#: ../../library/re.rst:638
msgid ""
"Return an :term:`iterator` yielding :class:`MatchObject` instances over all "
"non-overlapping matches for the RE *pattern* in *string*.  The *string* is "
"scanned left-to-right, and matches are returned in the order found.  Empty "
"matches are included in the result.  See also the note about :func:`findall`."
msgstr ""

#: ../../library/re.rst:651
msgid ""
"Return the string obtained by replacing the leftmost non-overlapping "
"occurrences of *pattern* in *string* by the replacement *repl*.  If the "
"pattern isn't found, *string* is returned unchanged.  *repl* can be a string "
"or a function; if it is a string, any backslash escapes in it are "
"processed.  That is, ``\\n`` is converted to a single newline character, "
"``\\r`` is converted to a carriage return, and so forth.  Unknown escapes "
"such as ``\\j`` are left alone.  Backreferences, such as ``\\6``, are "
"replaced with the substring matched by group 6 in the pattern. For example:"
msgstr ""
"*string* 内で、 *pattern* と重複しないマッチの内、一番左にあるものを置換 "
"*repl* で置換して得られた文字列を返します。もしパターンが見つからなければ、 "
"*string* を変更せずに返します。 *repl* は文字列でも関数でも構いません；もしそ"
"れが文字列であれば、それにある任意のバックスラッシュエスケープは処理されま"
"す。すなわち、 ``\\n`` は単一の改行文字に変換され、 ``\\r`` は、キャリッジリ"
"ターンに変換されます、等々。 ``\\j`` のような未知のエスケープはそのままにされ"
"ます。 ``\\6`` のような後方参照(backreference)は、パターンのグループ 6 とマッ"
"チしたサブ文字列で置換されます。例えば:"

#: ../../library/re.rst:665
msgid ""
"If *repl* is a function, it is called for every non-overlapping occurrence "
"of *pattern*.  The function takes a single match object argument, and "
"returns the replacement string.  For example:"
msgstr ""
"もし *repl* が関数であれば、重複しない *pattern* が発生するたびにその関数が呼"
"ばれます。この関数は一つのマッチオブジェクト引数を取り、置換文字列を返しま"
"す。例えば:"

#: ../../library/re.rst:677
msgid "The pattern may be a string or an RE object."
msgstr "パターンは、文字列でも RE オブジェクトでも構いません。"

#: ../../library/re.rst:679
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  If omitted or zero, "
"all occurrences will be replaced. Empty matches for the pattern are replaced "
"only when not adjacent to a previous match, so ``sub('x*', '-', 'abc')`` "
"returns ``'-a-b-c-'``."
msgstr ""
"省略可能な引数 *count* は、置換されるパターンの出現回数の最大値です； "
"*count* は非負の整数でなければなりません。もし省略されるかゼロであれば、出現"
"したものがすべて置換されます。パターンのマッチが空であれば、以前のマッチと隣"
"合わせでない時だけ置換されますので、 ``sub('x*', '-', 'abc')`` は ``'-a-b-"
"c-'`` を返します。"

#: ../../library/re.rst:685
msgid ""
"In string-type *repl* arguments, in addition to the character escapes and "
"backreferences described above, ``\\g<name>`` will use the substring matched "
"by the group named ``name``, as defined by the ``(?P<name>...)`` syntax. "
"``\\g<number>`` uses the corresponding group number; ``\\g<2>`` is therefore "
"equivalent to ``\\2``, but isn't ambiguous in a replacement such as "
"``\\g<2>0``.  ``\\20`` would be interpreted as a reference to group 20, not "
"a reference to group 2 followed by the literal character ``'0'``.  The "
"backreference ``\\g<0>`` substitutes in the entire substring matched by the "
"RE."
msgstr ""
"文字列タイプ *repl* 引数では、上で述べた文字エスケープや後方参照の他に、 "
"``\\g<name>`` は、 ``(?P<name>...)`` シンタクスで定義された ``name`` グループ"
"によるマッチ部分文字列を使用することになりますし、 ``\\g<number>`` は対応する"
"グループ番号への参照となります; ``\\g<2>`` はつまり ``\\2`` と等価ですが、 "
"``\\g<2>0`` のような置換においても曖昧になりません。 ``\\20`` は、グループ 20"
"への参照として解釈され、グループ 2 にリテラル文字 ``'0'`` が続いたものへの参"
"照としては解釈されないかもしれません。後方参照 ``\\g<0>`` は、RE とマッチする"
"サブ文字列全体を置き換えます。"

#: ../../library/re.rst:701
msgid ""
"Perform the same operation as :func:`sub`, but return a tuple ``(new_string, "
"number_of_subs_made)``."
msgstr ""
":func:`sub` と同じ操作を行いますが、タプル ``(new_string、 "
"number_of_subs_made)`` を返します。"

#: ../../library/re.rst:710
msgid ""
"Escape all the characters in *pattern* except ASCII letters and numbers. "
"This is useful if you want to match an arbitrary literal string that may "
"have regular expression metacharacters in it.  For example::"
msgstr ""

#: ../../library/re.rst:728
msgid "Clear the regular expression cache."
msgstr "正規表現キャッシュをクリアします。"

#: ../../library/re.rst:733
msgid ""
"Exception raised when a string passed to one of the functions here is not a "
"valid regular expression (for example, it might contain unmatched "
"parentheses) or when some other error occurs during compilation or "
"matching.  It is never an error if a string contains no match for a pattern."
msgstr ""
"ここでの関数の一つに渡された文字列が、正しい正規表現ではない時 (例えば、その"
"括弧が対になっていなかった)、あるいはコンパイルやマッチングの間になんらかのエ"
"ラーが発生したとき、発生する例外です。たとえ文字列がパターンとマッチしなくて"
"も、決してエラーではありません。"

#: ../../library/re.rst:742
msgid "Regular Expression Objects"
msgstr "正規表現オブジェクト"

#: ../../library/re.rst:746
msgid ""
"The :class:`RegexObject` class supports the following methods and attributes:"
msgstr ":class:`RegexObject` クラスは以下のメソッドと属性をサポートします:"

#: ../../library/re.rst:750
msgid ""
"Scan through *string* looking for a location where this regular expression "
"produces a match, and return a corresponding :class:`MatchObject` instance. "
"Return ``None`` if no position in the string matches the pattern; note that "
"this is different from finding a zero-length match at some point in the "
"string."
msgstr ""
"*string* を走査して、この正規表現がマッチする場所を探し、対応する :class:"
"`MatchObject` インスタンスを返します。 string のどこにもマッチしない場合は "
"``None`` を返します。これは、 string 内のどこかで長さ0でマッチした場合と異な"
"ることに注意してください。"

#: ../../library/re.rst:755
msgid ""
"The optional second parameter *pos* gives an index in the string where the "
"search is to start; it defaults to ``0``.  This is not completely equivalent "
"to slicing the string; the ``'^'`` pattern character matches at the real "
"beginning of the string and at positions just after a newline, but not "
"necessarily at the index where the search is to start."
msgstr ""
"省略可能な、2つ目の引数 *pos* は、 string のどこから探し始めるかを指定する "
"index で、デフォルトでは 0 です。これは、文字列をスライスしてから検索するの"
"と、完全には同じではありません。パターン文字 ``'^'`` は本当の文字列の先頭と、"
"改行の直後にマッチしますが、検索を開始する index がマッチするとは限りません。"

#: ../../library/re.rst:761
msgid ""
"The optional parameter *endpos* limits how far the string will be searched; "
"it will be as if the string is *endpos* characters long, so only the "
"characters from *pos* to ``endpos - 1`` will be searched for a match.  If "
"*endpos* is less than *pos*, no match will be found, otherwise, if *rx* is a "
"compiled regular expression object, ``rx.search(string, 0, 50)`` is "
"equivalent to ``rx.search(string[:50], 0)``."
msgstr ""
"省略可能な引数 *endpos* は string のどこまでを検索するかを制限します。これは "
"string の長さが *endpos* 文字だった場合と同じように動作します。つまり、 "
"*pos* から ``endpos - 1`` の範囲の文字に対してパターンマッチします。 "
"*endpos* が *pos* よりも小さい場合は、マッチは見つかりません。それ以外の場合"
"は、 *rx* がコンパイルされた正規表現として、 ``rx.search(string, 0, 50)`` は "
"``rx.search(string[:50], 0)`` と同じです。"

#: ../../library/re.rst:776
msgid ""
"If zero or more characters at the *beginning* of *string* match this regular "
"expression, return a corresponding :class:`MatchObject` instance.  Return "
"``None`` if the string does not match the pattern; note that this is "
"different from a zero-length match."
msgstr ""
"もし *string* の **先頭の** 0 個以上の文字がこの正規表現とマッチすれば、対応"
"する :class:`MatchObject` インスタンスを返します。もし文字列がパターンとマッ"
"チしなければ、 ``None`` を返します。これは長さゼロのマッチとは異なることに注"
"意して下さい。"

#: ../../library/re.rst:781
msgid ""
"The optional *pos* and *endpos* parameters have the same meaning as for the :"
"meth:`~RegexObject.search` method."
msgstr ""
"省略可能な引数 *pos* と *endpos* 引数は、 :meth:`~RegexObject.search` メソッ"
"ドと同じ意味を持ちます。"

#: ../../library/re.rst:789
msgid ""
"If you want to locate a match anywhere in *string*, use :meth:`~RegexObject."
"search` instead (see also :ref:`search-vs-match`)."
msgstr ""
"*string* のどこにでもマッチさせたければ、代わりに :meth:`~RegexObject."
"search` を使って下さい( :ref:`search-vs-match`) も参照してください)。"

#: ../../library/re.rst:795
msgid "Identical to the :func:`split` function, using the compiled pattern."
msgstr ""
":func:`split` 関数と同様で、コンパイルしたパターンを使います。ただし、 :meth:"
"`match` と同じように、省略可能な *pos*, *endpos* 引数で検索範囲を指定すること"
"ができます。"

#: ../../library/re.rst:800
msgid ""
"Similar to the :func:`findall` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`match`."
msgstr ""
":func:`findall` 関数と同様で、コンパイルしたパターンを使います。ただし、 :"
"meth:`match` と同じように、省略可能な *pos*, *endpos* 引数で検索範囲を指定す"
"ることができます。"

#: ../../library/re.rst:807
msgid ""
"Similar to the :func:`finditer` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`match`."
msgstr ""
":func:`finditer` 関数と同様で、コンパイルしたパターンを使います。ただし、 :"
"meth:`match` と同じように、省略可能な *pos*, *endpos* 引数で検索範囲を指定す"
"ることができます。"

#: ../../library/re.rst:814
msgid "Identical to the :func:`sub` function, using the compiled pattern."
msgstr ":func:`sub` 関数と同様で、コンパイルしたパターンを使います。"

#: ../../library/re.rst:819
msgid "Identical to the :func:`subn` function, using the compiled pattern."
msgstr ":func:`subn` 関数と同様で、コンパイルしたパターンを使います。"

#: ../../library/re.rst:824
msgid ""
"The regex matching flags.  This is a combination of the flags given to :func:"
"`.compile` and any ``(?...)`` inline flags in the pattern."
msgstr ""
"正規表現のマッチングフラグです。これは :func:`.compile` で指定されたフラグ、"
"およびパターン内の ``(?...)`` インラインフラグとの組み合わせになりなす。"

#: ../../library/re.rst:830
msgid "The number of capturing groups in the pattern."
msgstr "パターンにあるキャプチャグループの数です。"

#: ../../library/re.rst:835
msgid ""
"A dictionary mapping any symbolic group names defined by ``(?P<id>)`` to "
"group numbers.  The dictionary is empty if no symbolic groups were used in "
"the pattern."
msgstr ""
"``(?P<id>)`` で定義された任意の記号グループ名の、グループ番号への辞書マッピン"
"グです。もし記号グループがパターン内で何も使われていなければ、辞書は空です。"

#: ../../library/re.rst:842
msgid "The pattern string from which the RE object was compiled."
msgstr "RE オブジェクトがそれからコンパイルされたパターン文字列です。"

#: ../../library/re.rst:848
msgid "Match Objects"
msgstr "MatchObject オブジェクト"

#: ../../library/re.rst:852
msgid ""
"Match objects always have a boolean value of ``True``. Since :meth:`~regex."
"match` and :meth:`~regex.search` return ``None`` when there is no match, you "
"can test whether there was a match with a simple ``if`` statement::"
msgstr ""
"マッチオブジェクトは常にブール値 ``True`` を持ちます。 :meth:`~regex.match` "
"と :meth:`~regex.search` はマッチしなかった場合に ``None`` を返すので、単純"
"な ``if`` ステートメントによってマッチしたかどうかをテストできます::"

#: ../../library/re.rst:861
msgid "Match objects support the following methods and attributes:"
msgstr "マッチオブジェクトは以下のメソッドと属性をサポートしています:"

#: ../../library/re.rst:866
msgid ""
"Return the string obtained by doing backslash substitution on the template "
"string *template*, as done by the :meth:`~RegexObject.sub` method.  Escapes "
"such as ``\\n`` are converted to the appropriate characters, and numeric "
"backreferences (``\\1``, ``\\2``) and named backreferences (``\\g<1>``, "
"``\\g<name>``) are replaced by the contents of the corresponding group."
msgstr ""
"テンプレート文字列 *template* に、 :meth:`~RegexObject.sub` メソッドがするよ"
"うなバックスラッシュ置換をして得られる文字列を返します。 ``\\n`` のようなエス"
"ケープは適当な文字に変換され、数値の後方参照 (``\\1``, ``\\2``) と名前付きの"
"後方参照 (``\\g<1>``, ``\\g<name>``) は、対応するグループの内容で置き換えられ"
"ます。"

#: ../../library/re.rst:875
msgid ""
"Returns one or more subgroups of the match.  If there is a single argument, "
"the result is a single string; if there are multiple arguments, the result "
"is a tuple with one item per argument. Without arguments, *group1* defaults "
"to zero (the whole match is returned). If a *groupN* argument is zero, the "
"corresponding return value is the entire matching string; if it is in the "
"inclusive range [1..99], it is the string matching the corresponding "
"parenthesized group.  If a group number is negative or larger than the "
"number of groups defined in the pattern, an :exc:`IndexError` exception is "
"raised. If a group is contained in a part of the pattern that did not match, "
"the corresponding result is ``None``. If a group is contained in a part of "
"the pattern that matched multiple times, the last match is returned."
msgstr ""
"マッチした1個以上のサブグループを返します。もし引数で一つであれば、その結果は"
"一つの文字列です。複数の引数があれば、その結果は、引数ごとに一項目を持つタプ"
"ルです。引数がなければ、 *group1* はデフォールトでゼロです(マッチしたものすべ"
"てが返されます)。もし *groupN* 引数がゼロであれば、対応する戻り値は、マッチす"
"る文字列全体です。もしそれが範囲 [1..99] 内であれば、それは、対応する丸括弧つ"
"きグループとマッチする文字列です。もしグループ番号が負であるか、あるいはパ"
"ターンで定義されたグループの数より大きければ、 :exc:`IndexError` 例外が発生し"
"ます。グループがマッチしなかったパターンの一部に含まれていれば、対応する結果"
"は ``None`` です。グループが、複数回マッチしたパターンの一部に含まれていれ"
"ば、最後のマッチが返されます。"

#: ../../library/re.rst:897
msgid ""
"If the regular expression uses the ``(?P<name>...)`` syntax, the *groupN* "
"arguments may also be strings identifying groups by their group name.  If a "
"string argument is not used as a group name in the pattern, an :exc:"
"`IndexError` exception is raised."
msgstr ""
"もし正規表現が ``(?P<name>...)`` シンタックスを使うならば、 *groupN* 引数は、"
"それらのグループ名によってグループを識別する文字列であっても構いません。もし"
"文字列引数がパターンのグループ名として使われていないものであれば、 :exc:"
"`IndexError` 例外が発生します。"

#: ../../library/re.rst:902
msgid "A moderately complicated example:"
msgstr "適度に複雑な例題:"

#: ../../library/re.rst:910
msgid "Named groups can also be referred to by their index:"
msgstr "名前の付けられたグループは、そのインデックスによっても参照できます。"

#: ../../library/re.rst:917
msgid "If a group matches multiple times, only the last match is accessible:"
msgstr ""
"もし、グループが複数回マッチする場合、最後のマッチだけが利用可能となります。"

#: ../../library/re.rst:926
msgid ""
"Return a tuple containing all the subgroups of the match, from 1 up to "
"however many groups are in the pattern.  The *default* argument is used for "
"groups that did not participate in the match; it defaults to ``None``.  "
"(Incompatibility note: in the original Python 1.5 release, if the tuple was "
"one element long, a string would be returned instead.  In later versions "
"(from 1.5.1 on), a singleton tuple is returned in such cases.)"
msgstr ""
"マッチの、1からパターン内にある全グループ数までのすべてのサブグループを含むタ"
"プルを返します。 *default* 引数は、マッチに加わらなかったグループ用に使われ、"
"デフォールトでは ``None`` です。 (非互換性ノート：オリジナルの Python 1.5 リ"
"リースでは、たとえタプルが一要素長であっても、その代わりに文字列を返していま"
"した。 (1.5.1 以降の)後のバージョンでは、そのような場合には、要素がひとつのタ"
"プルが返されます。)"

#: ../../library/re.rst:933
msgid "For example:"
msgstr "例えば:"

#: ../../library/re.rst:939
msgid ""
"If we make the decimal place and everything after it optional, not all "
"groups might participate in the match.  These groups will default to "
"``None`` unless the *default* argument is given:"
msgstr ""
"もし、整数部にのみ着目し、あとの部分をオプションとした場合、マッチの中に現れ"
"ないグループがあるかも知れません。それらのグループは、 *default* 引数が与えら"
"れていない場合、デフォルトでは ``None`` になります。"

#: ../../library/re.rst:952
msgid ""
"Return a dictionary containing all the *named* subgroups of the match, keyed "
"by the subgroup name.  The *default* argument is used for groups that did "
"not participate in the match; it defaults to ``None``.  For example:"
msgstr ""
"マッチの、すべての *名前つきの* サブグループを含む、サブグループ名でキー付け"
"された辞書を返します。 *default* 引数はマッチに加わらなかったグループに使わ"
"れ、デフォールトでは ``None`` です。例えば、"

#: ../../library/re.rst:964
msgid ""
"Return the indices of the start and end of the substring matched by *group*; "
"*group* defaults to zero (meaning the whole matched substring). Return "
"``-1`` if *group* exists but did not contribute to the match.  For a match "
"object *m*, and a group *g* that did contribute to the match, the substring "
"matched by group *g* (equivalent to ``m.group(g)``) is ::"
msgstr ""
"*group* とマッチした部分文字列の先頭と末尾のインデックスを返します。 *group* "
"は、デフォルトでは(マッチした部分文字列全体を意味する）ゼロです。 *group* が"
"存在してもマッチに寄与しなかった場合は、 ``-1`` を返します。マッチオブジェク"
"ト *m* および、マッチに寄与しなかったグループ *g* があって、グループ *g* と"
"マッチしたサブ文字列 ( ``m.group(g)`` と同じ意味ですが ) は::"

#: ../../library/re.rst:972
msgid ""
"Note that ``m.start(group)`` will equal ``m.end(group)`` if *group* matched "
"a null string.  For example, after ``m = re.search('b(c?)', 'cba')``, ``m."
"start(0)`` is 1, ``m.end(0)`` is 2, ``m.start(1)`` and ``m.end(1)`` are both "
"2, and ``m.start(2)`` raises an :exc:`IndexError` exception."
msgstr ""
"です。もし *group* が空文字列とマッチすれば、 ``m.start(group)`` が ``m."
"end(group)`` と等しくなることに注意して下さい。例えば、 ``m = re."
"search('b(c?)', 'cba')`` とすると、 ``m.start(0)`` は 1 で、 ``m.end(0)`` は "
"2 であり、 ``m.start(1)`` と ``m.end(1)`` はともに 2 であり、 ``m.start(2)`` "
"は :exc:`IndexError` 例外を発生します。"

#: ../../library/re.rst:977
msgid "An example that will remove *remove_this* from email addresses:"
msgstr ""
"例として、電子メールのアドレスから *remove_this* を取り除く場合を示します。"

#: ../../library/re.rst:987
msgid ""
"For :class:`MatchObject` *m*, return the 2-tuple ``(m.start(group), m."
"end(group))``. Note that if *group* did not contribute to the match, this is "
"``(-1, -1)``.  *group* defaults to zero, the entire match."
msgstr ""
":class:`MatchObject` *m* について、大きさ2のタプル ``(m.start(group), m."
"end(group))`` を返します。もし *group* がマッチに寄与しなかったら、これは "
"``(-1, -1)`` です。また *group* はデフォルトでゼロです。"

#: ../../library/re.rst:994
msgid ""
"The value of *pos* which was passed to the :meth:`~RegexObject.search` or :"
"meth:`~RegexObject.match` method of the :class:`RegexObject`.  This is the "
"index into the string at which the RE engine started looking for a match."
msgstr ""
":class:`RegexObject` の :meth:`~RegexObject.search` か :meth:`~RegexObject."
"match` に渡された *pos* の値です。これは RE エンジンがマッチを探し始める位置"
"の文字列のインデックスです。"

#: ../../library/re.rst:1001
msgid ""
"The value of *endpos* which was passed to the :meth:`~RegexObject.search` "
"or :meth:`~RegexObject.match` method of the :class:`RegexObject`.  This is "
"the index into the string beyond which the RE engine will not go."
msgstr ""
":class:`RegexObject` の :meth:`~RegexObject.search` か :meth:`~RegexObject."
"match` に渡された *endpos* の値です。これは RE エンジンがそれ以上は進まない位"
"置の文字列のインデックスです。"

#: ../../library/re.rst:1008
msgid ""
"The integer index of the last matched capturing group, or ``None`` if no "
"group was matched at all. For example, the expressions ``(a)b``, ``((a)"
"(b))``, and ``((ab))`` will have ``lastindex == 1`` if applied to the string "
"``'ab'``, while the expression ``(a)(b)`` will have ``lastindex == 2``, if "
"applied to the same string."
msgstr ""
"最後にマッチした取り込みグループの整数インデックスです。もしどのグループも全"
"くマッチしなければ ``None`` です。例えば、 ``(a)b``, ``((a)(b))`` や "
"``((ab))`` といった表現が ``'ab'`` に適用された場合、 ``lastindex == 1`` とな"
"り、同じ文字列に ``(a)(b)`` が適用された場合には ``lastindex == 2`` となるで"
"しょう。"

#: ../../library/re.rst:1017
msgid ""
"The name of the last matched capturing group, or ``None`` if the group "
"didn't have a name, or if no group was matched at all."
msgstr ""
"最後にマッチした取り込みグループの名前です。もしグループに名前がないか、ある"
"いはどのグループも全くマッチしなければ ``None`` です。"

#: ../../library/re.rst:1023
msgid ""
"The regular expression object whose :meth:`~RegexObject.match` or :meth:"
"`~RegexObject.search` method produced this :class:`MatchObject` instance."
msgstr ""
"この :class:`MatchObject` インスタンスを :meth:`~RegexObject.match` あるい"
"は :meth:`~RegexObject.search` メソッドで生成した正規表現オブジェクトです。"

#: ../../library/re.rst:1030
msgid ""
"The string passed to :meth:`~RegexObject.match` or :meth:`~RegexObject."
"search`."
msgstr ""
":meth:`~RegexObject.match` あるいは :meth:`~RegexObject.search` に渡された文"
"字列です。"

#: ../../library/re.rst:1035
msgid "Examples"
msgstr "例"

#: ../../library/re.rst:1039
msgid "Checking For a Pair"
msgstr "ペアの確認"

#: ../../library/re.rst:1041
msgid ""
"In this example, we'll use the following helper function to display match "
"objects a little more gracefully:"
msgstr ""
"この例では、マッチオブジェクトの表示を少し美しくするために、下記の補助関数を"
"使用します :"

#: ../../library/re.rst:1051
msgid ""
"Suppose you are writing a poker program where a player's hand is represented "
"as a 5-character string with each character representing a card, \"a\" for "
"ace, \"k\" for king, \"q\" for queen, \"j\" for jack, \"t\" for 10, and "
"\"2\" through \"9\" representing the card with that value."
msgstr ""
"あなたがポーカープログラムを書いているとします。プレイヤーの持ち札はそれぞれ"
"の文字が1枚のカードを意味する5文字の文字列によって表現されます。 \"a\" はエー"
"ス、 \"k\" はキング、 \"q\" はクイーン、 \"j\" はジャック \"t\" は10、そして "
"\"2\" から \"9\" はそれぞれの数字のカードを表します。"

#: ../../library/re.rst:1056
msgid "To see if a given string is a valid hand, one could do the following:"
msgstr ""
"与えられた文字列が、持ち札として有効かを確認するために、下記のようにするかも"
"知れません。 :"

#: ../../library/re.rst:1066
msgid ""
"That last hand, ``\"727ak\"``, contained a pair, or two of the same valued "
"cards. To match this with a regular expression, one could use backreferences "
"as such:"
msgstr ""
"最後の持ち札 ``\"727ak\"`` は、ペアを含んでいます。言い換えると同じ値のカード"
"が2枚あります。これを正規表現にマッチさせるために、後方参照を使う場合もありま"
"す :"

#: ../../library/re.rst:1076
msgid ""
"To find out what card the pair consists of, one could use the :meth:"
"`~MatchObject.group` method of :class:`MatchObject` in the following manner:"
msgstr ""
"どのカードのペアになっているかを調べるため、下記のように :class:"
"`MatchObject` の :meth:`~RegexObject.group` メソッドを使う場合があります。"

#: ../../library/re.rst:1097
msgid "Simulating scanf()"
msgstr "scanf() をシミュレートする"

#: ../../library/re.rst:1101
msgid ""
"Python does not currently have an equivalent to :c:func:`scanf`.  Regular "
"expressions are generally more powerful, though also more verbose, than :c:"
"func:`scanf` format strings.  The table below offers some more-or-less "
"equivalent mappings between :c:func:`scanf` format tokens and regular "
"expressions."
msgstr ""
"Python には現在のところ、 :c:func:`scanf` に相当するものがありません。正規表"
"現は、 :c:func:`scanf` のフォーマット文字列よりも、一般的により強力であり、ま"
"た冗長でもあります。以下の表に、 :c:func:`scanf` のフォーマットトークンと正規"
"表現の大体同等な対応付けを示します。"

#: ../../library/re.rst:1108
msgid ":c:func:`scanf` Token"
msgstr ":c:func:`scanf` トークン"

#: ../../library/re.rst:1108
msgid "Regular Expression"
msgstr "正規表現"

#: ../../library/re.rst:1110
msgid "``%c``"
msgstr "``%c``"

#: ../../library/re.rst:1110
msgid "``.``"
msgstr "``.``"

#: ../../library/re.rst:1112
msgid "``%5c``"
msgstr "``%5c``"

#: ../../library/re.rst:1112
msgid "``.{5}``"
msgstr "``.{5}``"

#: ../../library/re.rst:1114
msgid "``%d``"
msgstr "``%d``"

#: ../../library/re.rst:1114
msgid "``[-+]?\\d+``"
msgstr "``[-+]?\\d+``"

#: ../../library/re.rst:1116
msgid "``%e``, ``%E``, ``%f``, ``%g``"
msgstr "``%e``, ``%E``, ``%f``, ``%g``"

#: ../../library/re.rst:1116
msgid "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"
msgstr "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"

#: ../../library/re.rst:1118
msgid "``%i``"
msgstr "``%i``"

#: ../../library/re.rst:1118
msgid "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"
msgstr "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"

#: ../../library/re.rst:1120
msgid "``%o``"
msgstr "``%o``"

#: ../../library/re.rst:1120
msgid "``[-+]?[0-7]+``"
msgstr "``[-+]?[0-7]+``"

#: ../../library/re.rst:1122
msgid "``%s``"
msgstr "``%s``"

#: ../../library/re.rst:1122
msgid "``\\S+``"
msgstr "``\\S+``"

#: ../../library/re.rst:1124
msgid "``%u``"
msgstr "``%u``"

#: ../../library/re.rst:1124
msgid "``\\d+``"
msgstr "``\\d+``"

#: ../../library/re.rst:1126
msgid "``%x``, ``%X``"
msgstr "``%x``, ``%X``"

#: ../../library/re.rst:1126
msgid "``[-+]?(0[xX])?[\\dA-Fa-f]+``"
msgstr "``[-+]?(0[xX])?[\\dA-Fa-f]+``"

#: ../../library/re.rst:1129
msgid "To extract the filename and numbers from a string like ::"
msgstr "以下のような文字列からファイル名と数値を抽出することを考えます ::"

#: ../../library/re.rst:1133
msgid "you would use a :c:func:`scanf` format like ::"
msgstr "このように :c:func:`scanf` フォーマットを使うでしょう ::"

#: ../../library/re.rst:1137
msgid "The equivalent regular expression would be ::"
msgstr "同等な正規表現はこのようなものとなります ::"

#: ../../library/re.rst:1145
msgid "search() vs. match()"
msgstr "search() vs. match()"

#: ../../library/re.rst:1149
msgid ""
"Python offers two different primitive operations based on regular "
"expressions: :func:`re.match` checks for a match only at the beginning of "
"the string, while :func:`re.search` checks for a match anywhere in the "
"string (this is what Perl does by default)."
msgstr ""
"Python は正規表現ベースの 2 個の基本的な関数、文字列の先頭でのみのマッチを確"
"認する :func:`re.match` および、文字列内の位置にかかわらずマッチを確認する :"
"func:`re.search` (Perl でのデフォルトの挙動) を提供しています。"

#: ../../library/re.rst:1154
msgid "For example::"
msgstr "例えば::"

#: ../../library/re.rst:1160
msgid ""
"Regular expressions beginning with ``'^'`` can be used with :func:`search` "
"to restrict the match at the beginning of the string::"
msgstr ""
"``'^'`` で始まる正規表現は、 :func:`search` において、マッチを文字列の先頭か"
"らに制限するために使用します::"

#: ../../library/re.rst:1168
msgid ""
"Note however that in :const:`MULTILINE` mode :func:`match` only matches at "
"the beginning of the string, whereas using :func:`search` with a regular "
"expression beginning with ``'^'`` will match at the beginning of each line."
msgstr ""
"ただし、 :const:`MULTILINE` モードの :func:`match` では文字列の先頭にのみマッ"
"チするのに対し、正規表現に ``'^'`` を使った :func:`search` では各行の先頭にも"
"マッチします。"

#: ../../library/re.rst:1178
msgid "Making a Phonebook"
msgstr "電話帳の作成"

#: ../../library/re.rst:1180
msgid ""
":func:`split` splits a string into a list delimited by the passed pattern.  "
"The method is invaluable for converting textual data into data structures "
"that can be easily read and modified by Python as demonstrated in the "
"following example that creates a phonebook."
msgstr ""
":func:`split` は文字列を与えられたパターンで分割し、リストにして返します。下"
"記の、電話帳作成の例のように、このメソッドはテキストデータを読みやすくした"
"り、 Python で編集したりしやすくする際に、非常に役に立ちます。"

#: ../../library/re.rst:1185
msgid ""
"First, here is the input.  Normally it may come from a file, here we are "
"using triple-quoted string syntax:"
msgstr ""
"最初に、入力を示します。通常、これはファイルからの入力になるでしょう。ここで"
"は、3重引用符の書式とします :"

#: ../../library/re.rst:1196
msgid ""
"The entries are separated by one or more newlines. Now we convert the string "
"into a list with each nonempty line having its own entry:"
msgstr ""
"個々の記録は、1つ以上の改行で区切られています。まずは、文字列から空行を除き、"
"記録ごとのリストに変換しましょう。"

#: ../../library/re.rst:1209
msgid ""
"Finally, split each entry into a list with first name, last name, telephone "
"number, and address.  We use the ``maxsplit`` parameter of :func:`split` "
"because the address has spaces, our splitting pattern, in it:"
msgstr ""
"そして、各記録を、名、姓、電話番号、そして、住所に分割してリストにします。分"
"割のためのパターンに使っている空白文字が、住所には含まれるため、 :func:"
"`split` の ``maxsplit`` 引数を使います。 :"

#: ../../library/re.rst:1222
msgid ""
"The ``:?`` pattern matches the colon after the last name, so that it does "
"not occur in the result list.  With a ``maxsplit`` of ``4``, we could "
"separate the house number from the street name:"
msgstr ""
"パターン、 ``:?`` は姓に続くコロンにマッチします。そのため、コロンは分割結果"
"のリストには現れません。 ``maxsplit`` を ``4`` にすれば、ハウスナンバーと、ス"
"トリート名を分割することができます。 :"

#: ../../library/re.rst:1237
msgid "Text Munging"
msgstr "テキストの秘匿"

#: ../../library/re.rst:1239
msgid ""
":func:`sub` replaces every occurrence of a pattern with a string or the "
"result of a function.  This example demonstrates using :func:`sub` with a "
"function to \"munge\" text, or randomize the order of all the characters in "
"each word of a sentence except for the first and last characters::"
msgstr ""
":func:`sub` はパターンにマッチした部分を文字列や関数の返り値で置き換えます。"
"この例では、\"秘匿\" する文字列に、関数と共に :func:`sub` を適用する例を示し"
"ます。言い換えると、最初と最後の文字を除く、単語中の文字の位置をランダム化し"
"ます。 ::"

#: ../../library/re.rst:1256
msgid "Finding all Adverbs"
msgstr "全ての副詞を見つける"

#: ../../library/re.rst:1258
msgid ""
":func:`findall` matches *all* occurrences of a pattern, not just the first "
"one as :func:`search` does.  For example, if a writer wanted to find all of "
"the adverbs in some text, they might use :func:`findall` in the following "
"manner:"
msgstr ""

#: ../../library/re.rst:1269
msgid "Finding all Adverbs and their Positions"
msgstr "全ての副詞と、その位置を見つける"

#: ../../library/re.rst:1271
msgid ""
"If one wants more information about all matches of a pattern than the "
"matched text, :func:`finditer` is useful as it provides instances of :class:"
"`MatchObject` instead of strings.  Continuing with the previous example, if "
"a writer wanted to find all of the adverbs *and their positions* in some "
"text, they would use :func:`finditer` in the following manner:"
msgstr ""

#: ../../library/re.rst:1285
msgid "Raw String Notation"
msgstr "Raw String記法"

#: ../../library/re.rst:1287
msgid ""
"Raw string notation (``r\"text\"``) keeps regular expressions sane.  Without "
"it, every backslash (``'\\'``) in a regular expression would have to be "
"prefixed with another one to escape it.  For example, the two following "
"lines of code are functionally identical:"
msgstr ""
"Raw string記法 (``r\"text\"``) により、バックスラッシュ (``'\\'``) を個々に"
"バックスラッシュでエスケープすることなしに、正規表現を正常な状態に保ちます。"
"例えば、下記の2つのコードは機能的に等価です。 :"

#: ../../library/re.rst:1297
msgid ""
"When one wants to match a literal backslash, it must be escaped in the "
"regular expression.  With raw string notation, this means ``r\"\\\\\"``.  "
"Without raw string notation, one must use ``\"\\\\\\\\\"``, making the "
"following lines of code functionally identical:"
msgstr ""
"文字通りのバックスラッシュにマッチさせたいなら、正規表現中ではエスケープする"
"必要があります。 Raw string記法では、 ``r\"\\\\\"`` ということになります。 "
"Raw string記法を用いない場合、 ``\"\\\\\\\\\"`` としなくてはなりません。下記"
"のコードは機能的に等価です。 :"
