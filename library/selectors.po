# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# tomo, 2021
# TENMYO Masakazu, 2023
# 石井明久, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-11 14:17+0000\n"
"PO-Revision-Date: 2021-06-28 01:12+0000\n"
"Last-Translator: 石井明久, 2024\n"
"Language-Team: Japanese (https://app.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/selectors.rst:2
msgid ":mod:`!selectors` --- High-level I/O multiplexing"
msgstr ":mod:`!selectors` --- 高水準の I/O 多重化"

#: ../../library/selectors.rst:9
msgid "**Source code:** :source:`Lib/selectors.py`"
msgstr "**ソースコード:** :source:`Lib/selectors.py`"

#: ../../library/selectors.rst:14
msgid "Introduction"
msgstr "はじめに"

#: ../../library/selectors.rst:16
msgid ""
"This module allows high-level and efficient I/O multiplexing, built upon "
"the :mod:`select` module primitives. Users are encouraged to use this module "
"instead, unless they want precise control over the OS-level primitives used."
msgstr ""
"このモジュールにより、:mod:`select` モジュールプリミティブに基づく高水準かつ"
"効率的な I/O の多重化が行えます。OS 水準のプリミティブを使用した正確な制御を"
"求めない限り、このモジュールの使用が推奨されます。"

#: ../../library/selectors.rst:20
msgid ""
"It defines a :class:`BaseSelector` abstract base class, along with several "
"concrete implementations (:class:`KqueueSelector`, :class:"
"`EpollSelector`...), that can be used to wait for I/O readiness notification "
"on multiple file objects. In the following, \"file object\" refers to any "
"object with a :meth:`~io.IOBase.fileno` method, or a raw file descriptor. "
"See :term:`file object`."
msgstr ""
"このモジュールは :class:`BaseSelector` 抽象基底クラスと、いくつかの具象実装 "
"(:class:`KqueueSelector`, :class:`EpollSelector`...) を定義しており、これらは"
"複数のファイルオブジェクトの I/O の準備状況の通知の待機に使用できます。以下で"
"は、 \"ファイルオブジェクト\" は、:meth:`~io.IOBase.fileno` メソッドを持つあ"
"らゆるオブジェクトか、あるいは Raw ファイル記述子を意味します。:term:`ファイ"
"ルオブジェクト <file object>` を参照してください。"

#: ../../library/selectors.rst:26
msgid ""
":class:`DefaultSelector` is an alias to the most efficient implementation "
"available on the current platform: this should be the default choice for "
"most users."
msgstr ""
":class:`DefaultSelector` は、現在のプラットフォームで利用できる、もっとも効率"
"的な実装の別名になります: これはほとんどのユーザーにとってのデフォルトの選択"
"になるはずです。"

#: ../../library/selectors.rst:31
msgid ""
"The type of file objects supported depends on the platform: on Windows, "
"sockets are supported, but not pipes, whereas on Unix, both are supported "
"(some other types may be supported as well, such as fifos or special file "
"devices)."
msgstr ""
"プラットフォームごとにサポートされているファイルオブジェクトのタイプは異なり"
"ます: Windows ではソケットはサポートされますが、パイプはされません。Unix では"
"両方がサポートされます (その他の fifo やスペシャルファイルデバイスなどのタイ"
"プもサポートされます)。"

#: ../../library/selectors.rst:38
msgid ":mod:`select`"
msgstr ":mod:`select`"

#: ../../library/selectors.rst:39
msgid "Low-level I/O multiplexing module."
msgstr "低水準の I/O 多重化モジュールです。"

#: ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr ""

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See :ref:`wasm-"
"availability` for more information."
msgstr ""
"このモジュールは WebAssembly では動作しないか、利用不可です。詳しくは、:ref:"
"`wasm-availability` を見てください。"

#: ../../library/selectors.rst:44
msgid "Classes"
msgstr "クラス"

#: ../../library/selectors.rst:46
msgid "Classes hierarchy::"
msgstr "クラス階層::"

#: ../../library/selectors.rst:48
msgid ""
"BaseSelector\n"
"+-- SelectSelector\n"
"+-- PollSelector\n"
"+-- EpollSelector\n"
"+-- DevpollSelector\n"
"+-- KqueueSelector"
msgstr ""

#: ../../library/selectors.rst:56
msgid ""
"In the following, *events* is a bitwise mask indicating which I/O events "
"should be waited for on a given file object. It can be a combination of the "
"modules constants below:"
msgstr ""
"以下では、*events* は与えられたファイルオブジェクトを待機すべき I/O イベント"
"を示すビット単位のマスクになります。これには以下のモジュール定数の組み合わせ"
"を設定できます:"

#: ../../library/selectors.rst:61
msgid "Constant"
msgstr "定数"

#: ../../library/selectors.rst:61
msgid "Meaning"
msgstr "意味"

#: ../../library/selectors.rst:63
msgid "Available for read"
msgstr "読み込み可能"

#: ../../library/selectors.rst:65
msgid "Available for write"
msgstr "書き込み可能"

#: ../../library/selectors.rst:71
msgid ""
"A :class:`SelectorKey` is a :class:`~collections.namedtuple` used to "
"associate a file object to its underlying file descriptor, selected event "
"mask and attached data. It is returned by several :class:`BaseSelector` "
"methods."
msgstr ""
":class:`SelectorKey` はそれの下層のファイルディスクリプタ、選択したイベントマ"
"スク、および付属データへのファイルオブジェクトの関連付けに使用される :class:"
"`~collections.namedtuple` です。いくつかの :class:`BaseSelector` メソッドを返"
"します。"

#: ../../library/selectors.rst:78
msgid "File object registered."
msgstr "登録されたファイルオブジェクトです。"

#: ../../library/selectors.rst:82
msgid "Underlying file descriptor."
msgstr "下層のファイル記述子です。"

#: ../../library/selectors.rst:86
msgid "Events that must be waited for on this file object."
msgstr "このファイルオブジェクトで待機しなければならないイベントです。"

#: ../../library/selectors.rst:90
msgid ""
"Optional opaque data associated to this file object: for example, this could "
"be used to store a per-client session ID."
msgstr ""
"このファイルオブジェクトに関連付けられたオプションの不透明型 (Opaque) データ"
"です。例えば、これはクライアントごとのセッション ID を格納するために使用でき"
"ます。"

#: ../../library/selectors.rst:96
msgid ""
"A :class:`BaseSelector` is used to wait for I/O event readiness on multiple "
"file objects. It supports file stream registration, unregistration, and a "
"method to wait for I/O events on those streams, with an optional timeout. "
"It's an abstract base class, so cannot be instantiated. Use :class:"
"`DefaultSelector` instead, or one of :class:`SelectSelector`, :class:"
"`KqueueSelector` etc. if you want to specifically use an implementation, and "
"your platform supports it. :class:`BaseSelector` and its concrete "
"implementations support the :term:`context manager` protocol."
msgstr ""
":class:`BaseSelector` は複数のファイルオブジェクトの I/O イベントの準備状況の"
"待機に使用されます。これはファイルストリームを登録、登録解除、およびこれらの"
"ストリームでの I/O イベントを待機 (オプションでタイムアウト) するメソッドをサ"
"ポートします。これは抽象基底クラスであるため、インスタンスを作成できません。"
"使用する実装を明示的に指定したい、そしてプラットフォームがそれをサポートして"
"いる場合は、代わりに :class:`DefaultSelector` を使用するか、:class:"
"`SelectSelector` や  :class:`KqueueSelector` などの一つを使用します。:class:"
"`BaseSelector` とその具象実装は :term:`コンテキストマネージャー <context "
"manager>` プロトコルをサポートしています。"

#: ../../library/selectors.rst:108
msgid "Register a file object for selection, monitoring it for I/O events."
msgstr "I/O イベントを監視するファイルオブジェクトをセレクションに登録します。"

#: ../../library/selectors.rst:110
msgid ""
"*fileobj* is the file object to monitor.  It may either be an integer file "
"descriptor or an object with a ``fileno()`` method. *events* is a bitwise "
"mask of events to monitor. *data* is an opaque object."
msgstr ""
"*fileobj* は監視するファイルオブジェクトです。これは整数のファイル記述子か、"
"``fileno()`` メソッドを持つオブジェクトのどちらかになります。*events* は監視"
"するイベントのビット幅マスクになります。*data* は不透明型 (Opaque) オブジェク"
"トです。"

#: ../../library/selectors.rst:115
msgid ""
"This returns a new :class:`SelectorKey` instance, or raises a :exc:"
"`ValueError` in case of invalid event mask or file descriptor, or :exc:"
"`KeyError` if the file object is already registered."
msgstr ""
"これは新しい :class:`SelectorKey` インスタンスを返します。不正なイベントマス"
"ク化ファイル記述子のときは :exc:`ValueError` が、ファイルオブジェクトがすでに"
"登録済みのときは :exc:`KeyError` が送出されます。"

#: ../../library/selectors.rst:121
msgid ""
"Unregister a file object from selection, removing it from monitoring. A file "
"object shall be unregistered prior to being closed."
msgstr ""
"ファイルオブジェクトのセレクション登録を解除し、監視対象から外します。ファイ"
"ルオブジェクトの登録解除はそのクローズより前に行われます。"

#: ../../library/selectors.rst:124
msgid "*fileobj* must be a file object previously registered."
msgstr "*fileobj* は登録済みのファイルオブジェクトでなければなりません。"

#: ../../library/selectors.rst:126
msgid ""
"This returns the associated :class:`SelectorKey` instance, or raises a :exc:"
"`KeyError` if *fileobj* is not registered.  It will raise :exc:`ValueError` "
"if *fileobj* is invalid (e.g. it has no ``fileno()`` method or its "
"``fileno()`` method has an invalid return value)."
msgstr ""
"関連付けられた :class:`SelectorKey` インスタンスを返します。*fileobj* が登録"
"されていない場合 :exc:`KeyError` を送出します。*fileobj* が不正な場合 (例え"
"ば *fileobj* に ``fileno()`` メソッドが無い場合や ``fileno()`` メソッドの戻り"
"値が不正な場合) :exc:`ValueError` を送出します。"

#: ../../library/selectors.rst:133
msgid "Change a registered file object's monitored events or attached data."
msgstr ""
"登録されたファイルオブジェクトの監視されたイベントや付属データを変更します。"

#: ../../library/selectors.rst:135
msgid ""
"This is equivalent to ``BaseSelector.unregister(fileobj)`` followed by "
"``BaseSelector.register(fileobj, events, data)``, except that it can be "
"implemented more efficiently."
msgstr ""
"より効率的に実装できる点を除けば、 ``BaseSelector.unregister(fileobj)`` に続"
"けて ``BaseSelector.register(fileobj, events, data)`` を行うのと等価です。"

#: ../../library/selectors.rst:139
msgid ""
"This returns a new :class:`SelectorKey` instance, or raises a :exc:"
"`ValueError` in case of invalid event mask or file descriptor, or :exc:"
"`KeyError` if the file object is not registered."
msgstr ""
"新たな :class:`SelectorKey` インスタンスを返します。\n"
"イベントマスクやファイル記述子が不正な場合は :exc:`ValueError` を、ファイルオ"
"ブジェクトが登録されていない場合は :exc:`KeyError` を送出します。"

#: ../../library/selectors.rst:145
msgid ""
"Wait until some registered file objects become ready, or the timeout expires."
msgstr ""
"登録されたいくつかのファイルオブジェクトが準備できたか、タイムアウトするまで"
"待機します。"

#: ../../library/selectors.rst:148
msgid ""
"If ``timeout > 0``, this specifies the maximum wait time, in seconds. If "
"``timeout <= 0``, the call won't block, and will report the currently ready "
"file objects. If *timeout* is ``None``, the call will block until a "
"monitored file object becomes ready."
msgstr ""
"``timeout > 0`` の場合、最大待機時間を秒で指定します。 ``timeout <= 0`` の場"
"合、この関数の呼び出しはブロックせず、 現在準備できているファイルオブジェクト"
"を報告します。 *timeout* が ``None`` の場合、監視しているファイルオブジェクト"
"の一つが準備できるまでブロックします。"

#: ../../library/selectors.rst:154
msgid ""
"This returns a list of ``(key, events)`` tuples, one for each ready file "
"object."
msgstr ""
"この関数は ``(key, events)`` タプルのリストを返します。準備できたファイルオブ"
"ジェクトにつき1タプルです。"

#: ../../library/selectors.rst:157
msgid ""
"*key* is the :class:`SelectorKey` instance corresponding to a ready file "
"object. *events* is a bitmask of events ready on this file object."
msgstr ""
"*key* は準備状態のファイルオブジェクトに対応する :class:`SelectorKey` インス"
"タンスです。 *events* はそのファイルオブジェクトで準備が完了したイベントの"
"ビットマスクです。"

#: ../../library/selectors.rst:162
msgid ""
"This method can return before any file object becomes ready or the timeout "
"has elapsed if the current process receives a signal: in this case, an empty "
"list will be returned."
msgstr ""
"このメソッドは、現在のプロセスで信号を受信した場合、どのファイルオブジェクト"
"も準備完了にならないうちに、またはタイムアウトが経過する前に返ることがありま"
"す。その場合、空のリストが返されます。"

#: ../../library/selectors.rst:166
msgid ""
"The selector is now retried with a recomputed timeout when interrupted by a "
"signal if the signal handler did not raise an exception (see :pep:`475` for "
"the rationale), instead of returning an empty list of events before the "
"timeout."
msgstr ""
"このセレクタは、シグナルによって中断された時に、シグナルハンドラが例外を起こ"
"さなかった場合、空のイベントリストを返すのではなく、再計算されたタイムアウト"
"によってリトライするようになりました (この論拠については :pep:`475` を参照し"
"てください)。"

#: ../../library/selectors.rst:174
msgid "Close the selector."
msgstr "セレクタを閉じます。"

#: ../../library/selectors.rst:176
msgid ""
"This must be called to make sure that any underlying resource is freed. The "
"selector shall not be used once it has been closed."
msgstr ""
"下層のリソースがすべて解放されたことを確かめるために呼ばれなければなりませ"
"ん。一旦閉じられたセレクタは使ってはいけません。"

#: ../../library/selectors.rst:181
msgid "Return the key associated with a registered file object."
msgstr "登録されたファイルオブジェクトに関連付けられたキーを返します。"

#: ../../library/selectors.rst:183
msgid ""
"This returns the :class:`SelectorKey` instance associated to this file "
"object, or raises :exc:`KeyError` if the file object is not registered."
msgstr ""
"そのファイルオブジェクトに関連付けられた :class:`SelectorKey` インスタンスを"
"返します。そのファイルオブジェクトが登録されていない場合 :exc:`KeyError` を送"
"出します。"

#: ../../library/selectors.rst:188
msgid "Return a mapping of file objects to selector keys."
msgstr "ファイルオブジェクトからセレクタキーへのマッピングを返します。"

#: ../../library/selectors.rst:190
msgid ""
"This returns a :class:`~collections.abc.Mapping` instance mapping registered "
"file objects to their associated :class:`SelectorKey` instance."
msgstr ""
"これは、登録済みのファイルオブジェクトを、それらに関連づけられた :class:"
"`SelectorKey` インスタンスにマッピングする :class:`~collections.abc.Mapping` "
"のインスタンスを返します。"

#: ../../library/selectors.rst:197
msgid ""
"The default selector class, using the most efficient implementation "
"available on the current platform. This should be the default choice for "
"most users."
msgstr ""
"デフォルトの selector クラスで、現在のプラットフォームで利用できる最も効率的"
"な実装を使用しています。大半のユーザはこれをデフォルトにすべきです。"

#: ../../library/selectors.rst:204
msgid ":func:`select.select`-based selector."
msgstr ":func:`select.select` を基底とするセレクタです。"

#: ../../library/selectors.rst:209
msgid ":func:`select.poll`-based selector."
msgstr ":func:`select.poll` を基底とするセレクタです。"

#: ../../library/selectors.rst:214
msgid ":func:`select.epoll`-based selector."
msgstr ":func:`select.epoll` を基底とするセレクタです。"

#: ../../library/selectors.rst:218
msgid ""
"This returns the file descriptor used by the underlying :func:`select.epoll` "
"object."
msgstr ""
"下層の :func:`select.epoll` オブジェクトが使用しているファイル記述子を返しま"
"す。"

#: ../../library/selectors.rst:223
msgid ":func:`select.devpoll`-based selector."
msgstr ":func:`select.devpoll` を基底とするセレクタです。"

#: ../../library/selectors.rst:227
msgid ""
"This returns the file descriptor used by the underlying :func:`select."
"devpoll` object."
msgstr ""
"下層の :func:`select.devpoll` オブジェクトが使用しているファイル記述子を返し"
"ます。"

#: ../../library/selectors.rst:234
msgid ":func:`select.kqueue`-based selector."
msgstr ":func:`select.kqueue` を基底とするセレクタです。"

#: ../../library/selectors.rst:238
msgid ""
"This returns the file descriptor used by the underlying :func:`select."
"kqueue` object."
msgstr ""
"下層の :func:`select.kqueue` オブジェクトが使用しているファイル記述子を返しま"
"す。"

#: ../../library/selectors.rst:243
msgid "Examples"
msgstr "使用例"

#: ../../library/selectors.rst:245
msgid "Here is a simple echo server implementation::"
msgstr "簡単なエコーサーバの実装です::"

#: ../../library/selectors.rst:247
msgid ""
"import selectors\n"
"import socket\n"
"\n"
"sel = selectors.DefaultSelector()\n"
"\n"
"def accept(sock, mask):\n"
"    conn, addr = sock.accept()  # Should be ready\n"
"    print('accepted', conn, 'from', addr)\n"
"    conn.setblocking(False)\n"
"    sel.register(conn, selectors.EVENT_READ, read)\n"
"\n"
"def read(conn, mask):\n"
"    data = conn.recv(1000)  # Should be ready\n"
"    if data:\n"
"        print('echoing', repr(data), 'to', conn)\n"
"        conn.send(data)  # Hope it won't block\n"
"    else:\n"
"        print('closing', conn)\n"
"        sel.unregister(conn)\n"
"        conn.close()\n"
"\n"
"sock = socket.socket()\n"
"sock.bind(('localhost', 1234))\n"
"sock.listen(100)\n"
"sock.setblocking(False)\n"
"sel.register(sock, selectors.EVENT_READ, accept)\n"
"\n"
"while True:\n"
"    events = sel.select()\n"
"    for key, mask in events:\n"
"        callback = key.data\n"
"        callback(key.fileobj, mask)"
msgstr ""
