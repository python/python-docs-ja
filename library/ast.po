# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# tomo, 2020
# Yusuke Miyazaki <miyazaki.dev@gmail.com>, 2020
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 16:06+0000\n"
"PO-Revision-Date: 2020-05-30 11:56+0000\n"
"Last-Translator: Yusuke Miyazaki <miyazaki.dev@gmail.com>, 2020\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/ast.rst:2
msgid ":mod:`ast` --- Abstract Syntax Trees"
msgstr ":mod:`ast` --- 抽象構文木"

#: ../../library/ast.rst:10
msgid "**Source code:** :source:`Lib/ast.py`"
msgstr "**ソースコード:** :source:`Lib/ast.py`"

#: ../../library/ast.rst:14
msgid ""
"The :mod:`ast` module helps Python applications to process trees of the "
"Python abstract syntax grammar.  The abstract syntax itself might change "
"with each Python release; this module helps to find out programmatically "
"what the current grammar looks like."
msgstr ""
":mod:`ast` モジュールは、Python アプリケーションで Python の抽象構文木を処理"
"しやすくするものです。抽象構文そのものは、Python のリリースごとに変化する可能"
"性があります。このモジュールを使用すると、現在の文法をプログラム上で知る助け"
"になるでしょう。"

#: ../../library/ast.rst:19
msgid ""
"An abstract syntax tree can be generated by passing :data:`ast."
"PyCF_ONLY_AST` as a flag to the :func:`compile` built-in function, or using "
"the :func:`parse` helper provided in this module.  The result will be a tree "
"of objects whose classes all inherit from :class:`ast.AST`.  An abstract "
"syntax tree can be compiled into a Python code object using the built-in :"
"func:`compile` function."
msgstr ""
"抽象構文木を作成するには、 :data:`ast.PyCF_ONLY_AST` を組み込み関数 :func:"
"`compile` のフラグとして渡すか、あるいはこのモジュールで提供されているヘル"
"パー関数 :func:`parse` を使います。その結果は、 :class:`ast.AST` を継承したク"
"ラスのオブジェクトのツリーとなります。抽象構文木は組み込み関数 :func:"
"`compile` を使って Python コード・オブジェクトにコンパイルすることができま"
"す。"

#: ../../library/ast.rst:27
msgid "Node classes"
msgstr "Node クラス"

#: ../../library/ast.rst:31
msgid ""
"This is the base of all AST node classes.  The actual node classes are "
"derived from the :file:`Parser/Python.asdl` file, which is reproduced :ref:"
"`below <abstract-grammar>`.  They are defined in the :mod:`_ast` C module "
"and re-exported in :mod:`ast`."
msgstr ""
"このクラスは全ての AST ノード・クラスの基底です。実際のノード・クラスは :ref:"
"`後ほど <abstract-grammar>` 示す :file:`Parser/Python.asdl` ファイルから派生"
"したものです。これらのクラスは :mod:`_ast` C モジュールで定義され、 :mod:"
"`ast` にもエクスポートし直されています。"

#: ../../library/ast.rst:36
msgid ""
"There is one class defined for each left-hand side symbol in the abstract "
"grammar (for example, :class:`ast.stmt` or :class:`ast.expr`).  In addition, "
"there is one class defined for each constructor on the right-hand side; "
"these classes inherit from the classes for the left-hand side trees.  For "
"example, :class:`ast.BinOp` inherits from :class:`ast.expr`.  For production "
"rules with alternatives (aka \"sums\"), the left-hand side class is "
"abstract: only instances of specific constructor nodes are ever created."
msgstr ""
"抽象文法の左辺のシンボル一つずつにそれぞれ一つのクラスがあります (たとえば :"
"class:`ast.stmt` や :class:`ast.expr`)。それに加えて、右辺のコンストラクタ一"
"つずつにそれぞれ一つのクラスがあり、これらのクラスは左辺のツリーのクラスを継"
"承しています。たとえば、 :class:`ast.BinOp` は :class:`ast.expr` から継承して"
"います。代替を伴った生成規則 (production rules with alternatives) (別名 "
"\"sums\") の場合、左辺は抽象クラスとなり、特定のコンストラクタ・ノードのイン"
"スタンスのみが作成されます。"

#: ../../library/ast.rst:49
msgid ""
"Each concrete class has an attribute :attr:`_fields` which gives the names "
"of all child nodes."
msgstr ""
"各具象クラスは属性 :attr:`_fields` を持っており、すべての子ノードの名前をそこ"
"に保持しています。"

#: ../../library/ast.rst:52
msgid ""
"Each instance of a concrete class has one attribute for each child node, of "
"the type as defined in the grammar.  For example, :class:`ast.BinOp` "
"instances have an attribute :attr:`left` of type :class:`ast.expr`."
msgstr ""
"具象クラスのインスタンスは、各子ノードに対してそれぞれひとつの属性を持ってい"
"ます。この属性は、文法で定義された型となります。たとえば :class:`ast.BinOp` "
"のインスタンスは :attr:`left` という属性を持っており、その型は :class:`ast."
"expr` です。"

#: ../../library/ast.rst:56
msgid ""
"If these attributes are marked as optional in the grammar (using a question "
"mark), the value might be ``None``.  If the attributes can have zero-or-more "
"values (marked with an asterisk), the values are represented as Python "
"lists.  All possible attributes must be present and have valid values when "
"compiling an AST with :func:`compile`."
msgstr ""
"これらの属性が、文法上 (クエスチョンマークを用いて) オプションであるとマーク"
"されている場合は、その値が ``None`` となることもあります。属性が0個以上の複数"
"の値をとりうる場合 (アスタリスクでマークされている場合) は、値は Python のリ"
"ストで表されます。全ての属性は AST を :func:`compile` でコンパイルする際には"
"存在しなければならず、そして妥当な値でなければなりません。"

#: ../../library/ast.rst:67
msgid ""
"Instances of :class:`ast.expr` and :class:`ast.stmt` subclasses have :attr:"
"`lineno`, :attr:`col_offset`, :attr:`lineno`, and :attr:`col_offset` "
"attributes.  The :attr:`lineno` and :attr:`end_lineno` are the first and "
"last line numbers of source text span (1-indexed so the first line is line "
"1) and the :attr:`col_offset` and :attr:`end_col_offset` are the "
"corresponding UTF-8 byte offsets of the first and last tokens that generated "
"the node. The UTF-8 offset is recorded because the parser uses UTF-8 "
"internally."
msgstr ""

#: ../../library/ast.rst:75
msgid ""
"Note that the end positions are not required by the compiler and are "
"therefore optional. The end offset is *after* the last symbol, for example "
"one can get the source segment of a one-line expression node using "
"``source_line[node.col_offset : node.end_col_offset]``."
msgstr ""
"コンパイラは終了位置を必要としないことに注意してください。このため終了位置は"
"省略可能です。終了位置を示すオフセットは最後のシンボルの *後の位置* になりま"
"す。例えば一行で書かれた式のソースコードのセグメントは ``source_line[node."
"col_offset : node.end_col_offset]`` により取得できます。"

#: ../../library/ast.rst:80
msgid ""
"The constructor of a class :class:`ast.T` parses its arguments as follows:"
msgstr "クラス :class:`ast.T` のコンストラクタは引数を次のように解析します:"

#: ../../library/ast.rst:82
msgid ""
"If there are positional arguments, there must be as many as there are items "
"in :attr:`T._fields`; they will be assigned as attributes of these names."
msgstr ""
"位置引数があるとすれば、 :attr:`T._fields` にあるのと同じだけの個数が無ければ"
"なりません。これらの引数はそこにある名前を持った属性として割り当てられます。"

#: ../../library/ast.rst:84
msgid ""
"If there are keyword arguments, they will set the attributes of the same "
"names to the given values."
msgstr ""
"キーワード引数があるとすれば、それらはその名前の属性にその値を割り当てられま"
"す。"

#: ../../library/ast.rst:87
msgid ""
"For example, to create and populate an :class:`ast.UnaryOp` node, you could "
"use ::"
msgstr ""
"たとえば、 :class:`ast.UnaryOp` ノードを生成して属性を埋めるには、次のように"
"することができます ::"

#: ../../library/ast.rst:99
msgid "or the more compact ::"
msgstr "もしくはよりコンパクトにも書けます ::"

#: ../../library/ast.rst:106
msgid "Class :class:`ast.Constant` is now used for all constants."
msgstr ":class:`ast.Constant` が全ての定数に使われるようになりました。"

#: ../../library/ast.rst:110
msgid ""
"Old classes :class:`ast.Num`, :class:`ast.Str`, :class:`ast.Bytes`, :class:"
"`ast.NameConstant` and :class:`ast.Ellipsis` are still available, but they "
"will be removed in future Python releases.  In the meanwhile, instantiating "
"them will return an instance of a different class."
msgstr ""
":class:`ast.Num`、 :class:`ast.Str`、:class:`ast.Bytes`、:class:`ast."
"NameConstant` そして :class:`ast.Ellipsis` は現バージョンまで使用可能ですが、"
"将来のPythonリリースで削除される予定です。削除されるまでの間、これらをインス"
"タンス化すると、異なるクラスのインスタンスが返されます。"

#: ../../library/ast.rst:119
msgid "Abstract Grammar"
msgstr "抽象文法 (Abstract Grammar)"

#: ../../library/ast.rst:121
msgid "The abstract grammar is currently defined as follows:"
msgstr "抽象文法は、現在次のように定義されています:"

#: ../../library/ast.rst:128
msgid ":mod:`ast` Helpers"
msgstr ":mod:`ast` ヘルパー"

#: ../../library/ast.rst:130
msgid ""
"Apart from the node classes, the :mod:`ast` module defines these utility "
"functions and classes for traversing abstract syntax trees:"
msgstr ""
"ノード・クラスの他に、 :mod:`ast` モジュールは以下のような抽象構文木をトラ"
"バースするためのユーティリティ関数やクラスも定義しています:"

#: ../../library/ast.rst:135
msgid ""
"Parse the source into an AST node.  Equivalent to ``compile(source, "
"filename, mode, ast.PyCF_ONLY_AST)``."
msgstr ""
"*source* を解析して AST ノードにします。``compile(source, filename, mode, "
"ast.PyCF_ONLY_AST)`` と等価です。"

#: ../../library/ast.rst:138
msgid ""
"If ``type_comments=True`` is given, the parser is modified to check and "
"return type comments as specified by :pep:`484` and :pep:`526`. This is "
"equivalent to adding :data:`ast.PyCF_TYPE_COMMENTS` to the flags passed to :"
"func:`compile()`.  This will report syntax errors for misplaced type "
"comments.  Without this flag, type comments will be ignored, and the "
"``type_comment`` field on selected AST nodes will always be ``None``.  In "
"addition, the locations of ``# type: ignore`` comments will be returned as "
"the ``type_ignores`` attribute of :class:`Module` (otherwise it is always an "
"empty list)."
msgstr ""
"``type_comments=True`` が与えられると、パーサは :pep:`484` および :pep:`526` "
"で規定された型コメントをチェックし、返すように修正されます。これは :data:"
"`ast.PyCF_TYPE_COMMENTS` を追加したフラグを :func:`compile()` に渡すことと等"
"価です。パーサは不適切な場所に配置された型コメントに対してシンタックスエラー"
"をレポートします。 このフラグがない場合、型コメントは無視されて AST ノードの "
"``type_comment`` フィールドは常に ``None`` になります。さらに、 ``# type: "
"ignore`` コメントの位置は :class:`Module` の ``type_ignores`` 属性として返さ"
"れます (それ以外の場合は常に空のリストになります)。"

#: ../../library/ast.rst:148
msgid ""
"In addition, if ``mode`` is ``'func_type'``, the input syntax is modified to "
"correspond to :pep:`484` \"signature type comments\", e.g. ``(str, int) -> "
"List[str]``."
msgstr ""
"さらに ``mode`` が ``'func_type'`` の場合、入力構文は、たとえば ``(str, int) "
"-> List[str]`` のような :pep:`484` の \"シグネチャ型コメント (signature type "
"comments)\" に対応するように修正されます。"

#: ../../library/ast.rst:152
msgid ""
"Also, setting ``feature_version`` to a tuple ``(major, minor)`` will attempt "
"to parse using that Python version's grammar. Currently ``major`` must equal "
"to ``3``.  For example, setting ``feature_version=(3, 4)`` will allow the "
"use of ``async`` and ``await`` as variable names.  The lowest supported "
"version is ``(3, 4)``; the highest is ``sys.version_info[0:2]``."
msgstr ""
"また、 ``feature_version`` を ``(major, minor)`` のタプルに設定すると、パーサ"
"は指定された Python バージョンの文法で構文解析を試みます。今のところ "
"``major`` は ``3`` でなければなりません。たとえば、 ``feature_version=(3, "
"4)`` と設定すると ``async`` と ``await`` を変数名として使うことが可能になりま"
"す。 サポートされている最低のバージョンは ``(3, 4)``; 最高のバージョンは "
"``sys.version_info[0:2]`` です。"

#: ../../library/ast.rst:160 ../../library/ast.rst:181
msgid ""
"It is possible to crash the Python interpreter with a sufficiently large/"
"complex string due to stack depth limitations in Python's AST compiler."
msgstr ""
"十分に大きい文字列や複雑な文字列によって Python の抽象構文木コンパイラのス"
"タックの深さの限界を越えることで、 Python インタプリタをクラッシュさせること"
"ができます。"

#: ../../library/ast.rst:164
msgid "Added ``type_comments``, ``mode='func_type'`` and ``feature_version``."
msgstr ""
"``type_comments``、``mode='func_type'``、``feature_version``が追加されまし"
"た。"

#: ../../library/ast.rst:170
msgid ""
"Safely evaluate an expression node or a string containing a Python literal "
"or container display.  The string or node provided may only consist of the "
"following Python literal structures: strings, bytes, numbers, tuples, lists, "
"dicts, sets, booleans, and ``None``."
msgstr ""
"式ノードまたは Python のリテラルまたはコンテナのディスプレイ表現を表す文字列"
"を安全に評価します。与えられる文字列またはノードは次のリテラルのみからなるも"
"のに限られます: 文字列、バイト列、数、タプル、リスト、辞書、集合、ブール値、 "
"``None`` 。"

#: ../../library/ast.rst:175
msgid ""
"This can be used for safely evaluating strings containing Python values from "
"untrusted sources without the need to parse the values oneself.  It is not "
"capable of evaluating arbitrarily complex expressions, for example involving "
"operators or indexing."
msgstr ""
"この関数は Python の式を含んだ信頼出来ない出どころからの文字列を、値自身を解"
"析することなしに安全に評価するのに使えます。この関数は、例えば演算や添え字を"
"含んだ任意の複雑な表現を評価するのには使えません。"

#: ../../library/ast.rst:185
msgid "Now allows bytes and set literals."
msgstr "バイト列リテラルと集合リテラルが受け取れるようになりました。"

#: ../../library/ast.rst:191
msgid ""
"Return the docstring of the given *node* (which must be a :class:"
"`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef`, or :class:"
"`Module` node), or ``None`` if it has no docstring. If *clean* is true, "
"clean up the docstring's indentation with :func:`inspect.cleandoc`."
msgstr ""
"与えられた *node* (これは :class:`FunctionDef`, :class:`AsyncFunctionDef`, :"
"class:`ClassDef`, :class:`Module` のいずれかのノードでなければなりません) の"
"ドキュメント文字列を返します。もしドキュメント文字列が無ければ ``None`` を返"
"します。 *clean* が真ならば、ドキュメント文字列のインデントを :func:`inspect."
"cleandoc` を用いて一掃します。"

#: ../../library/ast.rst:197
msgid ":class:`AsyncFunctionDef` is now supported."
msgstr ":class:`AsyncFunctionDef` がサポートされました。"

#: ../../library/ast.rst:203
msgid ""
"Get source code segment of the *source* that generated *node*. If some "
"location information (:attr:`lineno`, :attr:`end_lineno`, :attr:"
"`col_offset`, or :attr:`end_col_offset`) is missing, return ``None``."
msgstr ""
"*source* のうちで *node* を生成したソースコードのセグメントを取得します。位置"
"情報  (:attr:`lineno`, :attr:`end_lineno`, :attr:`col_offset`, または :attr:"
"`end_col_offset`) が欠けている場合 ``None`` を返します。"

#: ../../library/ast.rst:207
msgid ""
"If *padded* is ``True``, the first line of a multi-line statement will be "
"padded with spaces to match its original position."
msgstr ""
"*padded* が ``True`` の場合、複数行にわたる文の最初の行が元の位置に一致するよ"
"うに空白文字でパディングされます。"

#: ../../library/ast.rst:215
msgid ""
"When you compile a node tree with :func:`compile`, the compiler expects :"
"attr:`lineno` and :attr:`col_offset` attributes for every node that supports "
"them.  This is rather tedious to fill in for generated nodes, so this helper "
"adds these attributes recursively where not already set, by setting them to "
"the values of the parent node.  It works recursively starting at *node*."
msgstr ""
":func:`compile` はノード・ツリーをコンパイルする際、 :attr:`lineno` と :attr:"
"`col_offset` 両属性をサポートする全てのノードに対しそれが存在するものと想定し"
"ます。生成されたノードに対しこれらを埋めて回るのはどちらかというと退屈な作業"
"なので、このヘルパーが再帰的に二つの属性がセットされていないものに親ノードと"
"同じ値をセットしていきます。再帰の出発点が *node* です。"

#: ../../library/ast.rst:224
msgid ""
"Increment the line number and end line number of each node in the tree "
"starting at *node* by *n*. This is useful to \"move code\" to a different "
"location in a file."
msgstr ""
"*node* で始まるツリー内の各ノードの行番号と終了行番号を *n* ずつ増やします。"
"これはファイルの中で別の場所に \"コードを移動する\" ときに便利です。"

#: ../../library/ast.rst:231
msgid ""
"Copy source location (:attr:`lineno`, :attr:`col_offset`, :attr:"
"`end_lineno`, and :attr:`end_col_offset`) from *old_node* to *new_node* if "
"possible, and return *new_node*."
msgstr ""
"ソースの場所 (:attr:`lineno`, :attr:`col_offset`, :attr:`end_lineno`, およ"
"び :attr:`end_col_offset`) を *old_node* から *new_node* に可能ならばコピー"
"し、 *new_node* を返します。"

#: ../../library/ast.rst:238
msgid ""
"Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields`` "
"that is present on *node*."
msgstr ""
"*node* にある ``node._fields`` のそれぞれのフィールドを ``(フィールド名, "
"値)`` のタプルとして yield します。"

#: ../../library/ast.rst:244
msgid ""
"Yield all direct child nodes of *node*, that is, all fields that are nodes "
"and all items of fields that are lists of nodes."
msgstr ""
"*node* の直接の子ノード全てを yield します。すなわち、yield されるのは、ノー"
"ドであるような全てのフィールドおよびノードのリストであるようなフィールドの全"
"てのアイテムです。"

#: ../../library/ast.rst:250
msgid ""
"Recursively yield all descendant nodes in the tree starting at *node* "
"(including *node* itself), in no specified order.  This is useful if you "
"only want to modify nodes in place and don't care about the context."
msgstr ""
"*node* の全ての子孫ノード(*node* 自体を含む)を再帰的に yield します。順番は決"
"められていません。この関数はノードをその場で変更するだけで文脈を気にしないよ"
"うな場合に便利です。"

#: ../../library/ast.rst:257
msgid ""
"A node visitor base class that walks the abstract syntax tree and calls a "
"visitor function for every node found.  This function may return a value "
"which is forwarded by the :meth:`visit` method."
msgstr ""
"抽象構文木を渡り歩いてビジター関数を見つけたノードごとに呼び出すノード・ビジ"
"ターの基底クラスです。この関数は :meth:`visit` メソッドに送られる値を返しても"
"かまいません。"

#: ../../library/ast.rst:261
msgid ""
"This class is meant to be subclassed, with the subclass adding visitor "
"methods."
msgstr ""
"このクラスはビジター・メソッドを付け加えたサブクラスを派生させることを意図し"
"ています。"

#: ../../library/ast.rst:266
msgid ""
"Visit a node.  The default implementation calls the method called :samp:"
"`self.visit_{classname}` where *classname* is the name of the node class, "
"or :meth:`generic_visit` if that method doesn't exist."
msgstr ""
"ノードを訪れます。デフォルトの実装では :samp:`self.visit_{classname}` という"
"メソッド (ここで *classname* はノードのクラス名です) を呼び出すか、そのメソッ"
"ドがなければ :meth:`generic_visit` を呼び出します。"

#: ../../library/ast.rst:272
msgid "This visitor calls :meth:`visit` on all children of the node."
msgstr "このビジターはノードの全ての子について :meth:`visit` を呼び出します。"

#: ../../library/ast.rst:274
msgid ""
"Note that child nodes of nodes that have a custom visitor method won't be "
"visited unless the visitor calls :meth:`generic_visit` or visits them itself."
msgstr ""
"注意して欲しいのは、専用のビジター・メソッドを具えたノードの子ノードは、この"
"ビジターが :meth:`generic_visit` を呼び出すかそれ自身で子ノードを訪れない限り"
"訪れられないということです。"

#: ../../library/ast.rst:278
msgid ""
"Don't use the :class:`NodeVisitor` if you want to apply changes to nodes "
"during traversal.  For this a special visitor exists (:class:"
"`NodeTransformer`) that allows modifications."
msgstr ""
"トラバースの途中でノードを変化させたいならば :class:`NodeVisitor` を使っては"
"いけません。そうした目的のために変更を許す特別なビジター (:class:"
"`NodeTransformer`) があります。"

#: ../../library/ast.rst:284
msgid ""
"Methods :meth:`visit_Num`, :meth:`visit_Str`, :meth:`visit_Bytes`, :meth:"
"`visit_NameConstant` and :meth:`visit_Ellipsis` are deprecated now and will "
"not be called in future Python versions.  Add the :meth:`visit_Constant` "
"method to handle all constant nodes."
msgstr ""
":meth:`visit_Num`, :meth:`visit_Str`, :meth:`visit_Bytes`, :meth:"
"`visit_NameConstant` および :meth:`visit_Ellipsis` の各メソッドは非推奨です。"
"また将来の Python バージョンでは呼び出されなくなります。全ての定数ノードを扱"
"うには :meth:`visit_Constant` を追加してください。"

#: ../../library/ast.rst:292
msgid ""
"A :class:`NodeVisitor` subclass that walks the abstract syntax tree and "
"allows modification of nodes."
msgstr ""
":class:`NodeVisitor` のサブクラスで抽象構文木を渡り歩きながらノードを変更する"
"ことを許すものです。"

#: ../../library/ast.rst:295
msgid ""
"The :class:`NodeTransformer` will walk the AST and use the return value of "
"the visitor methods to replace or remove the old node.  If the return value "
"of the visitor method is ``None``, the node will be removed from its "
"location, otherwise it is replaced with the return value.  The return value "
"may be the original node in which case no replacement takes place."
msgstr ""
":class:`NodeTransformer` は抽象構文木(AST)を渡り歩き、ビジター・メソッドの戻"
"り値を使って古いノードを置き換えたり削除したりします。ビジター・メソッドの戻"
"り値が ``None`` ならば、ノードはその場から取り去られ、そうでなければ戻り値で"
"置き換えられます。置き換えない場合は戻り値が元のノードそのものであってもかま"
"いません。"

#: ../../library/ast.rst:301
msgid ""
"Here is an example transformer that rewrites all occurrences of name lookups "
"(``foo``) to ``data['foo']``::"
msgstr ""
"それでは例を示しましょう。Name (たとえば ``foo``) を見つけるたび全て "
"``data['foo']`` に書き換える変換器 (transformer) です::"

#: ../../library/ast.rst:313
msgid ""
"Keep in mind that if the node you're operating on has child nodes you must "
"either transform the child nodes yourself or call the :meth:`generic_visit` "
"method for the node first."
msgstr ""
"操作しようとしているノードが子ノードを持つならば、その子ノードの変形も自分で"
"行うか、またはそのノードに対し最初に :meth:`generic_visit` メソッドを呼び出す"
"か、それを行うのはあなたの責任だということを肝に銘じましょう。"

#: ../../library/ast.rst:317
msgid ""
"For nodes that were part of a collection of statements (that applies to all "
"statement nodes), the visitor may also return a list of nodes rather than "
"just a single node."
msgstr ""
"文のコレクションであるようなノード (全ての文のノードが当てはまります) に対し"
"て、このビジターは単独のノードではなくノードのリストを返すかもしれません。"

#: ../../library/ast.rst:321
msgid ""
"If :class:`NodeTransformer` introduces new nodes (that weren't part of "
"original tree) without giving them location information (such as :attr:"
"`lineno`), :func:`fix_missing_locations` should be called with the new sub-"
"tree to recalculate the location information::"
msgstr ""
":class:`NodeTransformer` が(たとえば、 :attr:`lineno` のような)位置情報を与え"
"ずに(元の木の一部ではなく)新しいノードを導入する場合、 :func:"
"`fix_missing_locations` を新しいサブツリーで呼び出して、位置情報を再計算する"
"必要があります。"

#: ../../library/ast.rst:329
msgid "Usually you use the transformer like this::"
msgstr "たいてい、変換器の使い方は次のようになります::"

#: ../../library/ast.rst:336
msgid ""
"Return a formatted dump of the tree in *node*.  This is mainly useful for "
"debugging purposes.  If *annotate_fields* is true (by default), the returned "
"string will show the names and the values for fields. If *annotate_fields* "
"is false, the result string will be more compact by omitting unambiguous "
"field names.  Attributes such as line numbers and column offsets are not "
"dumped by default.  If this is wanted, *include_attributes* can be set to "
"true."
msgstr ""
"*node* 内のツリーのフォーマットされたダンプを返します。主な使い道はデバッグで"
"す。 *annotate_fields* が(デフォルトで)trueの場合、返される文字列はフィールド"
"の名前と値を示します。 *annotate_fields* がfalseの場合、あいまいさのない"
"フィールド名を省略することにより、結果文字列はよりコンパクトになります。行番"
"号や列オフセットのような属性はデフォルトではダンプされません。これがほ欲しけ"
"れば、 *include_attributes* をtrueにセットすることができます。"

#: ../../library/ast.rst:346
msgid ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, an external "
"documentation resource, has good details on working with Python ASTs."
msgstr ""
"外部ドキュメント `Green Tree Snakes <https://greentreesnakes.readthedocs.io/"
">`_ には Python AST についての詳細が書かれています。"

#: ../../library/ast.rst:349
msgid ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ "
"annotates Python ASTs with the positions of tokens and text in the source "
"code that generated them. This is helpful for tools that make source code "
"transformations."
msgstr ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ は "
"Python AST を、生成元のソースコードのトークン位置やテキストで注解します。これ"
"はソースコード変換を行うツールで有用です。 "

#: ../../library/ast.rst:354
msgid ""
"`leoAst.py <http://leoeditor.com/appendices.html#leoast-py>`_ unifies the "
"token-based and parse-tree-based views of python programs by inserting two-"
"way links between tokens and ast nodes."
msgstr ""

#: ../../library/ast.rst:358
msgid ""
"`LibCST <https://libcst.readthedocs.io/>`_ parses code as a Concrete Syntax "
"Tree that looks like an ast tree and keeps all formatting details. It's "
"useful for building automated refactoring (codemod) applications and linters."
msgstr ""
"`LibCST <https://libcst.readthedocs.io/>`_ はコードを ast ツリーに似た構文木 "
"(Concrete Syntax Tree) にパースし、かつ全ての書式設定の詳細を保持します。これ"
"は自動リファクタリングアプリケーション (codemod) やリンタを作成する際に有用で"
"す。"

#: ../../library/ast.rst:363
msgid ""
"`Parso <https://parso.readthedocs.io>`_ is a Python parser that supports "
"error recovery and round-trip parsing for different Python versions (in "
"multiple Python versions). Parso is also able to list multiple syntax errors "
"in your python file."
msgstr ""
"`Parso <https://parso.readthedocs.io>`_ はエラーリカバリや異なる Python バー"
"ジョン (複数の Python バージョン) での復元可能なパース (round-trip parsing) "
"をサポートします。また、 Parso は Python ファイル内の複数の文法エラーをリスト"
"することもできます。"
