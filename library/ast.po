# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-03-10 12:44+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/ast.rst:2
msgid ":mod:`ast` --- Abstract Syntax Trees"
msgstr ":mod:`ast` --- æŠ½è±¡æ§‹æ–‡æœ¨"

#: ../../library/ast.rst:10
msgid "**Source code:** :source:`Lib/ast.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/ast.py`"

#: ../../library/ast.rst:14
msgid ""
"The :mod:`ast` module helps Python applications to process trees of the "
"Python abstract syntax grammar.  The abstract syntax itself might change "
"with each Python release; this module helps to find out programmatically "
"what the current grammar looks like."
msgstr ""
":mod:`ast` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€Python ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ Python "
"ã®æŠ½è±¡æ§‹æ–‡æœ¨ã‚’å‡¦ç†ã—ã‚„ã™ãã™ã‚‹ã‚‚ã®ã§ã™ã€‚æŠ½è±¡æ§‹æ–‡ãã®ã‚‚ã®ã¯ã€Python "
"ã®ãƒªãƒªãƒ¼ã‚¹ã”ã¨ã«å¤‰åŒ–ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ç¾åœ¨ã®æ–‡æ³•ã‚’ãƒ—ãƒ­ã‚°ãƒ©ãƒ ä¸Šã§çŸ¥ã‚‹åŠ©ã‘ã«ãªã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../library/ast.rst:19
msgid ""
"An abstract syntax tree can be generated by passing "
":data:`ast.PyCF_ONLY_AST` as a flag to the :func:`compile` built-in "
"function, or using the :func:`parse` helper provided in this module.  The "
"result will be a tree of objects whose classes all inherit from "
":class:`ast.AST`.  An abstract syntax tree can be compiled into a Python "
"code object using the built-in :func:`compile` function."
msgstr ""
"æŠ½è±¡æ§‹æ–‡æœ¨ã‚’ä½œæˆã™ã‚‹ã«ã¯ã€ :data:`ast.PyCF_ONLY_AST` ã‚’çµ„ã¿è¾¼ã¿é–¢æ•° :func:`compile` "
"ã®ãƒ•ãƒ©ã‚°ã¨ã—ã¦æ¸¡ã™ã‹ã€ã‚ã‚‹ã„ã¯ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§æä¾›ã•ã‚Œã¦ã„ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•° :func:`parse` ã‚’ä½¿ã„ã¾ã™ã€‚ãã®çµæœã¯ã€ "
":class:`ast.AST` ã‚’ç¶™æ‰¿ã—ãŸã‚¯ãƒ©ã‚¹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ„ãƒªãƒ¼ã¨ãªã‚Šã¾ã™ã€‚æŠ½è±¡æ§‹æ–‡æœ¨ã¯çµ„ã¿è¾¼ã¿é–¢æ•° :func:`compile` ã‚’ä½¿ã£ã¦ "
"Python ã‚³ãƒ¼ãƒ‰ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/ast.rst:27
msgid "Node classes"
msgstr "Node ã‚¯ãƒ©ã‚¹"

#: ../../library/ast.rst:31
msgid ""
"This is the base of all AST node classes.  The actual node classes are "
"derived from the :file:`Parser/Python.asdl` file, which is reproduced "
":ref:`below <abstract-grammar>`.  They are defined in the :mod:`_ast` C "
"module and re-exported in :mod:`ast`."
msgstr ""
"ã“ã®ã‚¯ãƒ©ã‚¹ã¯å…¨ã¦ã® AST ãƒãƒ¼ãƒ‰ãƒ»ã‚¯ãƒ©ã‚¹ã®åŸºåº•ã§ã™ã€‚å®Ÿéš›ã®ãƒãƒ¼ãƒ‰ãƒ»ã‚¯ãƒ©ã‚¹ã¯ :ref:`å¾Œã»ã© <abstract-grammar>` ç¤ºã™ "
":file:`Parser/Python.asdl` ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰æ´¾ç”Ÿã—ãŸã‚‚ã®ã§ã™ã€‚ã“ã‚Œã‚‰ã®ã‚¯ãƒ©ã‚¹ã¯ :mod:`_ast` C ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å®šç¾©ã•ã‚Œã€"
" :mod:`ast` ã«ã‚‚ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ç›´ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/ast.rst:36
msgid ""
"There is one class defined for each left-hand side symbol in the abstract "
"grammar (for example, :class:`ast.stmt` or :class:`ast.expr`).  In addition,"
" there is one class defined for each constructor on the right-hand side; "
"these classes inherit from the classes for the left-hand side trees.  For "
"example, :class:`ast.BinOp` inherits from :class:`ast.expr`.  For production"
" rules with alternatives (aka \"sums\"), the left-hand side class is "
"abstract: only instances of specific constructor nodes are ever created."
msgstr ""
"æŠ½è±¡æ–‡æ³•ã®å·¦è¾ºã®ã‚·ãƒ³ãƒœãƒ«ä¸€ã¤ãšã¤ã«ãã‚Œãã‚Œä¸€ã¤ã®ã‚¯ãƒ©ã‚¹ãŒã‚ã‚Šã¾ã™ (ãŸã¨ãˆã° :class:`ast.stmt` ã‚„ "
":class:`ast.expr`)ã€‚ãã‚Œã«åŠ ãˆã¦ã€å³è¾ºã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ä¸€ã¤ãšã¤ã«ãã‚Œãã‚Œä¸€ã¤ã®ã‚¯ãƒ©ã‚¹ãŒã‚ã‚Šã€ã“ã‚Œã‚‰ã®ã‚¯ãƒ©ã‚¹ã¯å·¦è¾ºã®ãƒ„ãƒªãƒ¼ã®ã‚¯ãƒ©ã‚¹ã‚’ç¶™æ‰¿ã—ã¦ã„ã¾ã™ã€‚ãŸã¨ãˆã°ã€"
" :class:`ast.BinOp` ã¯ :class:`ast.expr` ã‹ã‚‰ç¶™æ‰¿ã—ã¦ã„ã¾ã™ã€‚ä»£æ›¿ã‚’ä¼´ã£ãŸç”Ÿæˆè¦å‰‡ (production "
"rules with alternatives) (åˆ¥å \"sums\") "
"ã®å ´åˆã€å·¦è¾ºã¯æŠ½è±¡ã‚¯ãƒ©ã‚¹ã¨ãªã‚Šã€ç‰¹å®šã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ãƒãƒ¼ãƒ‰ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã¿ãŒä½œæˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/ast.rst:46
msgid ""
"Each concrete class has an attribute :attr:`_fields` which gives the names "
"of all child nodes."
msgstr "å„å…·è±¡ã‚¯ãƒ©ã‚¹ã¯å±æ€§ :attr:`_fields` ã‚’æŒã£ã¦ãŠã‚Šã€ã™ã¹ã¦ã®å­ãƒãƒ¼ãƒ‰ã®åå‰ã‚’ãã“ã«ä¿æŒã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/ast.rst:49
msgid ""
"Each instance of a concrete class has one attribute for each child node, of "
"the type as defined in the grammar.  For example, :class:`ast.BinOp` "
"instances have an attribute :attr:`left` of type :class:`ast.expr`."
msgstr ""
"å…·è±¡ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã€å„å­ãƒãƒ¼ãƒ‰ã«å¯¾ã—ã¦ãã‚Œãã‚Œã²ã¨ã¤ã®å±æ€§ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ã“ã®å±æ€§ã¯ã€æ–‡æ³•ã§å®šç¾©ã•ã‚ŒãŸå‹ã¨ãªã‚Šã¾ã™ã€‚ãŸã¨ãˆã° "
":class:`ast.BinOp` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ :attr:`left` ã¨ã„ã†å±æ€§ã‚’æŒã£ã¦ãŠã‚Šã€ãã®å‹ã¯ :class:`ast.expr` "
"ã§ã™ã€‚"

#: ../../library/ast.rst:53
msgid ""
"If these attributes are marked as optional in the grammar (using a question "
"mark), the value might be ``None``.  If the attributes can have zero-or-more"
" values (marked with an asterisk), the values are represented as Python "
"lists.  All possible attributes must be present and have valid values when "
"compiling an AST with :func:`compile`."
msgstr ""
"ã“ã‚Œã‚‰ã®å±æ€§ãŒã€æ–‡æ³•ä¸Š (ã‚¯ã‚¨ã‚¹ãƒãƒ§ãƒ³ãƒãƒ¼ã‚¯ã‚’ç”¨ã„ã¦) ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã‚ã‚‹ã¨ãƒãƒ¼ã‚¯ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ãã®å€¤ãŒ ``None`` "
"ã¨ãªã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚å±æ€§ãŒ0å€‹ä»¥ä¸Šã®è¤‡æ•°ã®å€¤ã‚’ã¨ã‚Šã†ã‚‹å ´åˆ (ã‚¢ã‚¹ã‚¿ãƒªã‚¹ã‚¯ã§ãƒãƒ¼ã‚¯ã•ã‚Œã¦ã„ã‚‹å ´åˆ) ã¯ã€å€¤ã¯ Python "
"ã®ãƒªã‚¹ãƒˆã§è¡¨ã•ã‚Œã¾ã™ã€‚å…¨ã¦ã®å±æ€§ã¯ AST ã‚’ :func:`compile` "
"ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹éš›ã«ã¯å­˜åœ¨ã—ãªã‘ã‚Œã°ãªã‚‰ãšã€ãã—ã¦å¦¥å½“ãªå€¤ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ast.rst:62
msgid ""
"Instances of :class:`ast.expr` and :class:`ast.stmt` subclasses have "
":attr:`lineno` and :attr:`col_offset` attributes.  The :attr:`lineno` is the"
" line number of source text (1-indexed so the first line is line 1) and the "
":attr:`col_offset` is the UTF-8 byte offset of the first token that "
"generated the node.  The UTF-8 offset is recorded because the parser uses "
"UTF-8 internally."
msgstr ""
":class:`ast.expr` ã‚„ :class:`ast.stmt` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ã¯ã•ã‚‰ã« :attr:`lineno` ã‚„ "
":attr:`col_offset` ã¨ã„ã£ãŸå±æ€§ãŒã‚ã‚Šã¾ã™ã€‚ :attr:`lineno` ã¯ã‚½ãƒ¼ã‚¹ãƒ†ã‚­ã‚¹ãƒˆä¸Šã®è¡Œç•ªå· (1 "
"ã‹ã‚‰æ•°ãˆå§‹ã‚ã‚‹ã®ã§ã€æœ€åˆã®è¡Œã®è¡Œç•ªå·ã¯ 1 ã¨ãªã‚Šã¾ã™)ã€ãã—ã¦ :attr:`col_offset` ã¯ãƒãƒ¼ãƒ‰ãŒç”Ÿæˆã—ãŸæœ€åˆã®ãƒˆãƒ¼ã‚¯ãƒ³ã® UTF-8 "
"ãƒã‚¤ãƒˆã‚ªãƒ•ã‚»ãƒƒãƒˆã¨ãªã‚Šã¾ã™ã€‚ UTF-8 ã‚ªãƒ•ã‚»ãƒƒãƒˆãŒè¨˜éŒ²ã•ã‚Œã‚‹ç†ç”±ã¯ã€ãƒ‘ãƒ¼ã‚µãŒå†…éƒ¨ã§ UTF-8 ã‚’ä½¿ç”¨ã™ã‚‹ã‹ã‚‰ã§ã™ã€‚"

#: ../../library/ast.rst:69
msgid ""
"The constructor of a class :class:`ast.T` parses its arguments as follows:"
msgstr "ã‚¯ãƒ©ã‚¹ :class:`ast.T` ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯å¼•æ•°ã‚’æ¬¡ã®ã‚ˆã†ã«è§£æã—ã¾ã™:"

#: ../../library/ast.rst:71
msgid ""
"If there are positional arguments, there must be as many as there are items "
"in :attr:`T._fields`; they will be assigned as attributes of these names."
msgstr ""
"ä½ç½®å¼•æ•°ãŒã‚ã‚‹ã¨ã™ã‚Œã°ã€ :attr:`T._fields` "
"ã«ã‚ã‚‹ã®ã¨åŒã˜ã ã‘ã®å€‹æ•°ãŒç„¡ã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã‚‰ã®å¼•æ•°ã¯ãã“ã«ã‚ã‚‹åå‰ã‚’æŒã£ãŸå±æ€§ã¨ã—ã¦å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/ast.rst:73
msgid ""
"If there are keyword arguments, they will set the attributes of the same "
"names to the given values."
msgstr "ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ãŒã‚ã‚‹ã¨ã™ã‚Œã°ã€ãã‚Œã‚‰ã¯ãã®åå‰ã®å±æ€§ã«ãã®å€¤ã‚’å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/ast.rst:76
msgid ""
"For example, to create and populate an :class:`ast.UnaryOp` node, you could "
"use ::"
msgstr "ãŸã¨ãˆã°ã€ :class:`ast.UnaryOp` ãƒãƒ¼ãƒ‰ã‚’ç”Ÿæˆã—ã¦å±æ€§ã‚’åŸ‹ã‚ã‚‹ã«ã¯ã€æ¬¡ã®ã‚ˆã†ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ ::"

#: ../../library/ast.rst:88
msgid "or the more compact ::"
msgstr "ã‚‚ã—ãã¯ã‚ˆã‚Šã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã«ã‚‚æ›¸ã‘ã¾ã™ ::"

#: ../../library/ast.rst:97
msgid "Abstract Grammar"
msgstr "æŠ½è±¡æ–‡æ³• (Abstract Grammar)"

#: ../../library/ast.rst:99
msgid "The abstract grammar is currently defined as follows:"
msgstr "æŠ½è±¡æ–‡æ³•ã¯ã€ç¾åœ¨æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™:"

#: ../../library/ast.rst:106
msgid ":mod:`ast` Helpers"
msgstr ":mod:`ast` ãƒ˜ãƒ«ãƒ‘ãƒ¼"

#: ../../library/ast.rst:108
msgid ""
"Apart from the node classes, the :mod:`ast` module defines these utility "
"functions and classes for traversing abstract syntax trees:"
msgstr ""
"ãƒãƒ¼ãƒ‰ãƒ»ã‚¯ãƒ©ã‚¹ã®ä»–ã«ã€ :mod:`ast` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªæŠ½è±¡æ§‹æ–‡æœ¨ã‚’ãƒˆãƒ©ãƒãƒ¼ã‚¹ã™ã‚‹ãŸã‚ã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ã‚„ã‚¯ãƒ©ã‚¹ã‚‚å®šç¾©ã—ã¦ã„ã¾ã™:"

#: ../../library/ast.rst:113
msgid ""
"Parse the source into an AST node.  Equivalent to ``compile(source, "
"filename, mode, ast.PyCF_ONLY_AST)``."
msgstr ""
"*source* ã‚’è§£æã—ã¦ AST ãƒãƒ¼ãƒ‰ã«ã—ã¾ã™ã€‚``compile(source, filename, mode, "
"ast.PyCF_ONLY_AST)`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/ast.rst:117 ../../library/ast.rst:135
msgid ""
"It is possible to crash the Python interpreter with a sufficiently "
"large/complex string due to stack depth limitations in Python's AST "
"compiler."
msgstr ""
"ååˆ†ã«å¤§ãã„æ–‡å­—åˆ—ã‚„è¤‡é›‘ãªæ–‡å­—åˆ—ã«ã‚ˆã£ã¦ Python ã®æŠ½è±¡æ§‹æ–‡æœ¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®ã‚¹ã‚¿ãƒƒã‚¯ã®æ·±ã•ã®é™ç•Œã‚’è¶Šãˆã‚‹ã“ã¨ã§ã€ Python "
"ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/ast.rst:124
msgid ""
"Safely evaluate an expression node or a string containing a Python literal "
"or container display.  The string or node provided may only consist of the "
"following Python literal structures: strings, bytes, numbers, tuples, lists,"
" dicts, sets, booleans, and ``None``."
msgstr ""
"å¼ãƒãƒ¼ãƒ‰ã¾ãŸã¯ Python "
"ã®ãƒªãƒ†ãƒ©ãƒ«ã¾ãŸã¯ã‚³ãƒ³ãƒ†ãƒŠã®ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤è¡¨ç¾ã‚’è¡¨ã™æ–‡å­—åˆ—ã‚’å®‰å…¨ã«è©•ä¾¡ã—ã¾ã™ã€‚ä¸ãˆã‚‰ã‚Œã‚‹æ–‡å­—åˆ—ã¾ãŸã¯ãƒãƒ¼ãƒ‰ã¯æ¬¡ã®ãƒªãƒ†ãƒ©ãƒ«ã®ã¿ã‹ã‚‰ãªã‚‹ã‚‚ã®ã«é™ã‚‰ã‚Œã¾ã™: "
"æ–‡å­—åˆ—ã€ãƒã‚¤ãƒˆåˆ—ã€æ•°ã€ã‚¿ãƒ—ãƒ«ã€ãƒªã‚¹ãƒˆã€è¾æ›¸ã€é›†åˆã€ãƒ–ãƒ¼ãƒ«å€¤ã€ ``None`` ã€‚"

#: ../../library/ast.rst:129
msgid ""
"This can be used for safely evaluating strings containing Python values from"
" untrusted sources without the need to parse the values oneself.  It is not "
"capable of evaluating arbitrarily complex expressions, for example involving"
" operators or indexing."
msgstr ""
"ã“ã®é–¢æ•°ã¯ Python "
"ã®å¼ã‚’å«ã‚“ã ä¿¡é ¼å‡ºæ¥ãªã„å‡ºã©ã“ã‚ã‹ã‚‰ã®æ–‡å­—åˆ—ã‚’ã€å€¤è‡ªèº«ã‚’è§£æã™ã‚‹ã“ã¨ãªã—ã«å®‰å…¨ã«è©•ä¾¡ã™ã‚‹ã®ã«ä½¿ãˆã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ã€ä¾‹ãˆã°æ¼”ç®—ã‚„æ·»ãˆå­—ã‚’å«ã‚“ã ä»»æ„ã®è¤‡é›‘ãªè¡¨ç¾ã‚’è©•ä¾¡ã™ã‚‹ã®ã«ã¯ä½¿ãˆã¾ã›ã‚“ã€‚"

#: ../../library/ast.rst:139
msgid "Now allows bytes and set literals."
msgstr "ãƒã‚¤ãƒˆåˆ—ãƒªãƒ†ãƒ©ãƒ«ã¨é›†åˆãƒªãƒ†ãƒ©ãƒ«ãŒå—ã‘å–ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/ast.rst:145
msgid ""
"Return the docstring of the given *node* (which must be a "
":class:`FunctionDef`, :class:`ClassDef` or :class:`Module` node), or "
"``None`` if it has no docstring.  If *clean* is true, clean up the "
"docstring's indentation with :func:`inspect.cleandoc`."
msgstr ""
"ä¸ãˆã‚‰ã‚ŒãŸ *node* (ã“ã‚Œã¯ :class:`FunctionDef`, :class:`ClassDef`, :class:`Module` "
"ã®ã„ãšã‚Œã‹ã®ãƒãƒ¼ãƒ‰ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“) ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚ã‚‚ã—ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ–‡å­—åˆ—ãŒç„¡ã‘ã‚Œã° ``None`` ã‚’è¿”ã—ã¾ã™ã€‚ "
"*clean* ãŒçœŸãªã‚‰ã°ã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ–‡å­—åˆ—ã®ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’ :func:`inspect.cleandoc` ã‚’ç”¨ã„ã¦ä¸€æƒã—ã¾ã™ã€‚"

#: ../../library/ast.rst:153
msgid ""
"When you compile a node tree with :func:`compile`, the compiler expects "
":attr:`lineno` and :attr:`col_offset` attributes for every node that "
"supports them.  This is rather tedious to fill in for generated nodes, so "
"this helper adds these attributes recursively where not already set, by "
"setting them to the values of the parent node.  It works recursively "
"starting at *node*."
msgstr ""
":func:`compile` ã¯ãƒãƒ¼ãƒ‰ãƒ»ãƒ„ãƒªãƒ¼ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹éš›ã€ :attr:`lineno` ã¨ :attr:`col_offset` "
"ä¸¡å±æ€§ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å…¨ã¦ã®ãƒãƒ¼ãƒ‰ã«å¯¾ã—ãã‚ŒãŒå­˜åœ¨ã™ã‚‹ã‚‚ã®ã¨æƒ³å®šã—ã¾ã™ã€‚ç”Ÿæˆã•ã‚ŒãŸãƒãƒ¼ãƒ‰ã«å¯¾ã—ã“ã‚Œã‚‰ã‚’åŸ‹ã‚ã¦å›ã‚‹ã®ã¯ã©ã¡ã‚‰ã‹ã¨ã„ã†ã¨é€€å±ˆãªä½œæ¥­ãªã®ã§ã€ã“ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼ãŒå†å¸°çš„ã«äºŒã¤ã®å±æ€§ãŒã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ãªã„ã‚‚ã®ã«è¦ªãƒãƒ¼ãƒ‰ã¨åŒã˜å€¤ã‚’ã‚»ãƒƒãƒˆã—ã¦ã„ãã¾ã™ã€‚å†å¸°ã®å‡ºç™ºç‚¹ãŒ"
" *node* ã§ã™ã€‚"

#: ../../library/ast.rst:162
msgid ""
"Increment the line number of each node in the tree starting at *node* by "
"*n*. This is useful to \"move code\" to a different location in a file."
msgstr ""
"*node* ã‹ã‚‰å§‹ã¾ã‚‹ãƒ„ãƒªãƒ¼ã®å…¨ã¦ã®ãƒãƒ¼ãƒ‰ã®è¡Œç•ªå·ã‚’ *n* ãšã¤å¢—ã‚„ã—ã¾ã™ã€‚ã“ã‚Œã¯ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¸­ã§åˆ¥ã®å ´æ‰€ã«ã€Œã‚³ãƒ¼ãƒ‰ã‚’å‹•ã‹ã™ã€ã¨ãã«ä¾¿åˆ©ã§ã™ã€‚"

#: ../../library/ast.rst:168
msgid ""
"Copy source location (:attr:`lineno` and :attr:`col_offset`) from *old_node*"
" to *new_node* if possible, and return *new_node*."
msgstr ""
"ã‚½ãƒ¼ã‚¹ã®å ´æ‰€ (:attr:`lineno` ã¨ :attr:`col_offset`) ã‚’ *old_node* ã‹ã‚‰ *new_node* "
"ã«å¯èƒ½ãªã‚‰ã°ã‚³ãƒ”ãƒ¼ã—ã€ *new_node* ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ast.rst:174
msgid ""
"Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields`` "
"that is present on *node*."
msgstr ""
"*node* ã«ã‚ã‚‹ ``node._fields`` ã®ãã‚Œãã‚Œã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ ``(ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å, å€¤)`` ã®ã‚¿ãƒ—ãƒ«ã¨ã—ã¦ yield ã—ã¾ã™ã€‚"

#: ../../library/ast.rst:180
msgid ""
"Yield all direct child nodes of *node*, that is, all fields that are nodes "
"and all items of fields that are lists of nodes."
msgstr ""
"*node* ã®ç›´æ¥ã®å­ãƒãƒ¼ãƒ‰å…¨ã¦ã‚’ yield ã—ã¾ã™ã€‚ã™ãªã‚ã¡ã€yield "
"ã•ã‚Œã‚‹ã®ã¯ã€ãƒãƒ¼ãƒ‰ã§ã‚ã‚‹ã‚ˆã†ãªå…¨ã¦ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŠã‚ˆã³ãƒãƒ¼ãƒ‰ã®ãƒªã‚¹ãƒˆã§ã‚ã‚‹ã‚ˆã†ãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å…¨ã¦ã®ã‚¢ã‚¤ãƒ†ãƒ ã§ã™ã€‚"

#: ../../library/ast.rst:186
msgid ""
"Recursively yield all descendant nodes in the tree starting at *node* "
"(including *node* itself), in no specified order.  This is useful if you "
"only want to modify nodes in place and don't care about the context."
msgstr ""
"*node* ã®å…¨ã¦ã®å­å­«ãƒãƒ¼ãƒ‰(*node* è‡ªä½“ã‚’å«ã‚€)ã‚’å†å¸°çš„ã« yield "
"ã—ã¾ã™ã€‚é †ç•ªã¯æ±ºã‚ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ã“ã®é–¢æ•°ã¯ãƒãƒ¼ãƒ‰ã‚’ãã®å ´ã§å¤‰æ›´ã™ã‚‹ã ã‘ã§æ–‡è„ˆã‚’æ°—ã«ã—ãªã„ã‚ˆã†ãªå ´åˆã«ä¾¿åˆ©ã§ã™ã€‚"

#: ../../library/ast.rst:193
msgid ""
"A node visitor base class that walks the abstract syntax tree and calls a "
"visitor function for every node found.  This function may return a value "
"which is forwarded by the :meth:`visit` method."
msgstr ""
"æŠ½è±¡æ§‹æ–‡æœ¨ã‚’æ¸¡ã‚Šæ­©ã„ã¦ãƒ“ã‚¸ã‚¿ãƒ¼é–¢æ•°ã‚’è¦‹ã¤ã‘ãŸãƒãƒ¼ãƒ‰ã”ã¨ã«å‘¼ã³å‡ºã™ãƒãƒ¼ãƒ‰ãƒ»ãƒ“ã‚¸ã‚¿ãƒ¼ã®åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚ã“ã®é–¢æ•°ã¯ :meth:`visit` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã«é€ã‚‰ã‚Œã‚‹å€¤ã‚’è¿”ã—ã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚"

#: ../../library/ast.rst:197
msgid ""
"This class is meant to be subclassed, with the subclass adding visitor "
"methods."
msgstr "ã“ã®ã‚¯ãƒ©ã‚¹ã¯ãƒ“ã‚¸ã‚¿ãƒ¼ãƒ»ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä»˜ã‘åŠ ãˆãŸã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’æ´¾ç”Ÿã•ã›ã‚‹ã“ã¨ã‚’æ„å›³ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/ast.rst:202
msgid ""
"Visit a node.  The default implementation calls the method called "
":samp:`self.visit_{classname}` where *classname* is the name of the node "
"class, or :meth:`generic_visit` if that method doesn't exist."
msgstr ""
"ãƒãƒ¼ãƒ‰ã‚’è¨ªã‚Œã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å®Ÿè£…ã§ã¯ :samp:`self.visit_{classname}` ã¨ã„ã†ãƒ¡ã‚½ãƒƒãƒ‰ (ã“ã“ã§ *classname* "
"ã¯ãƒãƒ¼ãƒ‰ã®ã‚¯ãƒ©ã‚¹åã§ã™) ã‚’å‘¼ã³å‡ºã™ã‹ã€ãã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒãªã‘ã‚Œã° :meth:`generic_visit` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../library/ast.rst:208
msgid "This visitor calls :meth:`visit` on all children of the node."
msgstr "ã“ã®ãƒ“ã‚¸ã‚¿ãƒ¼ã¯ãƒãƒ¼ãƒ‰ã®å…¨ã¦ã®å­ã«ã¤ã„ã¦ :meth:`visit` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../library/ast.rst:210
msgid ""
"Note that child nodes of nodes that have a custom visitor method won't be "
"visited unless the visitor calls :meth:`generic_visit` or visits them "
"itself."
msgstr ""
"æ³¨æ„ã—ã¦æ¬²ã—ã„ã®ã¯ã€å°‚ç”¨ã®ãƒ“ã‚¸ã‚¿ãƒ¼ãƒ»ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å…·ãˆãŸãƒãƒ¼ãƒ‰ã®å­ãƒãƒ¼ãƒ‰ã¯ã€ã“ã®ãƒ“ã‚¸ã‚¿ãƒ¼ãŒ :meth:`generic_visit` "
"ã‚’å‘¼ã³å‡ºã™ã‹ãã‚Œè‡ªèº«ã§å­ãƒãƒ¼ãƒ‰ã‚’è¨ªã‚Œãªã„é™ã‚Šè¨ªã‚Œã‚‰ã‚Œãªã„ã¨ã„ã†ã“ã¨ã§ã™ã€‚"

#: ../../library/ast.rst:214
msgid ""
"Don't use the :class:`NodeVisitor` if you want to apply changes to nodes "
"during traversal.  For this a special visitor exists "
"(:class:`NodeTransformer`) that allows modifications."
msgstr ""
"ãƒˆãƒ©ãƒãƒ¼ã‚¹ã®é€”ä¸­ã§ãƒãƒ¼ãƒ‰ã‚’å¤‰åŒ–ã•ã›ãŸã„ãªã‚‰ã° :class:`NodeVisitor` "
"ã‚’ä½¿ã£ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚ãã†ã—ãŸç›®çš„ã®ãŸã‚ã«å¤‰æ›´ã‚’è¨±ã™ç‰¹åˆ¥ãªãƒ“ã‚¸ã‚¿ãƒ¼ (:class:`NodeTransformer`) ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/ast.rst:221
msgid ""
"A :class:`NodeVisitor` subclass that walks the abstract syntax tree and "
"allows modification of nodes."
msgstr ":class:`NodeVisitor` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§æŠ½è±¡æ§‹æ–‡æœ¨ã‚’æ¸¡ã‚Šæ­©ããªãŒã‚‰ãƒãƒ¼ãƒ‰ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã‚’è¨±ã™ã‚‚ã®ã§ã™ã€‚"

#: ../../library/ast.rst:224
msgid ""
"The :class:`NodeTransformer` will walk the AST and use the return value of "
"the visitor methods to replace or remove the old node.  If the return value "
"of the visitor method is ``None``, the node will be removed from its "
"location, otherwise it is replaced with the return value.  The return value "
"may be the original node in which case no replacement takes place."
msgstr ""
":class:`NodeTransformer` "
"ã¯æŠ½è±¡æ§‹æ–‡æœ¨(AST)ã‚’æ¸¡ã‚Šæ­©ãã€ãƒ“ã‚¸ã‚¿ãƒ¼ãƒ»ãƒ¡ã‚½ãƒƒãƒ‰ã®æˆ»ã‚Šå€¤ã‚’ä½¿ã£ã¦å¤ã„ãƒãƒ¼ãƒ‰ã‚’ç½®ãæ›ãˆãŸã‚Šå‰Šé™¤ã—ãŸã‚Šã—ã¾ã™ã€‚ãƒ“ã‚¸ã‚¿ãƒ¼ãƒ»ãƒ¡ã‚½ãƒƒãƒ‰ã®æˆ»ã‚Šå€¤ãŒ "
"``None`` "
"ãªã‚‰ã°ã€ãƒãƒ¼ãƒ‰ã¯ãã®å ´ã‹ã‚‰å–ã‚Šå»ã‚‰ã‚Œã€ãã†ã§ãªã‘ã‚Œã°æˆ»ã‚Šå€¤ã§ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚ç½®ãæ›ãˆãªã„å ´åˆã¯æˆ»ã‚Šå€¤ãŒå…ƒã®ãƒãƒ¼ãƒ‰ãã®ã‚‚ã®ã§ã‚ã£ã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚"

#: ../../library/ast.rst:230
msgid ""
"Here is an example transformer that rewrites all occurrences of name lookups"
" (``foo``) to ``data['foo']``::"
msgstr ""
"ãã‚Œã§ã¯ä¾‹ã‚’ç¤ºã—ã¾ã—ã‚‡ã†ã€‚Name (ãŸã¨ãˆã° ``foo``) ã‚’è¦‹ã¤ã‘ã‚‹ãŸã³å…¨ã¦ ``data['foo']`` ã«æ›¸ãæ›ãˆã‚‹å¤‰æ›å™¨ "
"(transformer) ã§ã™::"

#: ../../library/ast.rst:242
msgid ""
"Keep in mind that if the node you're operating on has child nodes you must "
"either transform the child nodes yourself or call the :meth:`generic_visit` "
"method for the node first."
msgstr ""
"æ“ä½œã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ãƒãƒ¼ãƒ‰ãŒå­ãƒãƒ¼ãƒ‰ã‚’æŒã¤ãªã‚‰ã°ã€ãã®å­ãƒãƒ¼ãƒ‰ã®å¤‰å½¢ã‚‚è‡ªåˆ†ã§è¡Œã†ã‹ã€ã¾ãŸã¯ãã®ãƒãƒ¼ãƒ‰ã«å¯¾ã—æœ€åˆã« "
":meth:`generic_visit` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã‹ã€ãã‚Œã‚’è¡Œã†ã®ã¯ã‚ãªãŸã®è²¬ä»»ã ã¨ã„ã†ã“ã¨ã‚’è‚ã«éŠ˜ã˜ã¾ã—ã‚‡ã†ã€‚"

#: ../../library/ast.rst:246
msgid ""
"For nodes that were part of a collection of statements (that applies to all "
"statement nodes), the visitor may also return a list of nodes rather than "
"just a single node."
msgstr ""
"æ–‡ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã§ã‚ã‚‹ã‚ˆã†ãªãƒãƒ¼ãƒ‰ (å…¨ã¦ã®æ–‡ã®ãƒãƒ¼ãƒ‰ãŒå½“ã¦ã¯ã¾ã‚Šã¾ã™) "
"ã«å¯¾ã—ã¦ã€ã“ã®ãƒ“ã‚¸ã‚¿ãƒ¼ã¯å˜ç‹¬ã®ãƒãƒ¼ãƒ‰ã§ã¯ãªããƒãƒ¼ãƒ‰ã®ãƒªã‚¹ãƒˆã‚’è¿”ã™ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ast.rst:250
msgid "Usually you use the transformer like this::"
msgstr "ãŸã„ã¦ã„ã€å¤‰æ›å™¨ã®ä½¿ã„æ–¹ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../library/ast.rst:257
msgid ""
"Return a formatted dump of the tree in *node*.  This is mainly useful for "
"debugging purposes.  The returned string will show the names and the values "
"for fields.  This makes the code impossible to evaluate, so if evaluation is"
" wanted *annotate_fields* must be set to ``False``.  Attributes such as line"
" numbers and column offsets are not dumped by default.  If this is wanted, "
"*include_attributes* can be set to ``True``."
msgstr ""
"*node* "
"ä¸­ã®ãƒ„ãƒªãƒ¼ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã•ã‚ŒãŸãƒ€ãƒ³ãƒ—ã‚’è¿”ã—ã¾ã™ã€‚ä¸»ãªä½¿ã„é“ã¯ãƒ‡ãƒãƒƒã‚°ã§ã™ã€‚è¿”ã•ã‚Œã‚‹æ–‡å­—åˆ—ã¯åå‰ã¨ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å€¤ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚ã“ã‚Œã‚’ä½¿ã†ã¨ã‚³ãƒ¼ãƒ‰ã¯è©•ä¾¡ã§ããªããªã‚Šã¾ã™ã®ã§ã€è©•ä¾¡ãŒå¿…è¦ãªã‚‰ã°"
" *annotate_fields* ã« ``False`` "
"ã‚’ã‚»ãƒƒãƒˆã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚è¡Œç•ªå·ã‚„åˆ—ã‚ªãƒ•ã‚»ãƒƒãƒˆã®ã‚ˆã†ãªå±æ€§ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ãƒ€ãƒ³ãƒ—ã•ã‚Œã¾ã›ã‚“ã€‚ã“ã‚ŒãŒæ¬²ã—ã‘ã‚Œã°ã€*include_attributes*"
" ã‚’ ``True`` ã«ã‚»ãƒƒãƒˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/ast.rst:266
msgid ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.org/>`_, an external"
" documentation resource, has good details on working with Python ASTs."
msgstr ""
"å¤–éƒ¨ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ `Green Tree Snakes <https://greentreesnakes.readthedocs.org/>`_ ã«ã¯ "
"Python AST ã«ã¤ã„ã¦ã®è©³ç´°ãŒæ›¸ã‹ã‚Œã¦ã„ã¾ã™ã€‚"
