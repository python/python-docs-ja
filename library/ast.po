# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# tomo, 2021
# Yusuke Miyazaki <miyazaki.dev@gmail.com>, 2022
# Takeshi Nakazato, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-24 14:15+0000\n"
"PO-Revision-Date: 2021-06-28 00:54+0000\n"
"Last-Translator: Takeshi Nakazato, 2022\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/ast.rst:2
msgid ":mod:`ast` --- Abstract Syntax Trees"
msgstr ":mod:`ast` --- 抽象構文木"

#: ../../library/ast.rst:14
msgid "**Source code:** :source:`Lib/ast.py`"
msgstr "**ソースコード:** :source:`Lib/ast.py`"

#: ../../library/ast.rst:18
msgid ""
"The :mod:`ast` module helps Python applications to process trees of the "
"Python abstract syntax grammar.  The abstract syntax itself might change "
"with each Python release; this module helps to find out programmatically "
"what the current grammar looks like."
msgstr ""
":mod:`ast` モジュールは、Python アプリケーションで Python の抽象構文木を処理"
"しやすくするものです。抽象構文そのものは、Python のリリースごとに変化する可能"
"性があります。このモジュールを使用すると、現在の文法をプログラム上で知る助け"
"になるでしょう。"

#: ../../library/ast.rst:23
msgid ""
"An abstract syntax tree can be generated by passing :data:`ast."
"PyCF_ONLY_AST` as a flag to the :func:`compile` built-in function, or using "
"the :func:`parse` helper provided in this module.  The result will be a tree "
"of objects whose classes all inherit from :class:`ast.AST`.  An abstract "
"syntax tree can be compiled into a Python code object using the built-in :"
"func:`compile` function."
msgstr ""
"抽象構文木を作成するには、 :data:`ast.PyCF_ONLY_AST` を組み込み関数 :func:"
"`compile` のフラグとして渡すか、あるいはこのモジュールで提供されているヘル"
"パー関数 :func:`parse` を使います。その結果は、 :class:`ast.AST` を継承したク"
"ラスのオブジェクトのツリーとなります。抽象構文木は組み込み関数 :func:"
"`compile` を使って Python コード・オブジェクトにコンパイルすることができま"
"す。"

#: ../../library/ast.rst:33
msgid "Abstract Grammar"
msgstr "抽象文法 (Abstract Grammar)"

#: ../../library/ast.rst:35
msgid "The abstract grammar is currently defined as follows:"
msgstr "抽象文法は、現在次のように定義されています:"

#: ../../library/ast.rst:42
msgid "Node classes"
msgstr "Node クラス"

#: ../../library/ast.rst:46
msgid ""
"This is the base of all AST node classes.  The actual node classes are "
"derived from the :file:`Parser/Python.asdl` file, which is reproduced :ref:"
"`above <abstract-grammar>`.  They are defined in the :mod:`_ast` C module "
"and re-exported in :mod:`ast`."
msgstr ""

#: ../../library/ast.rst:51
msgid ""
"There is one class defined for each left-hand side symbol in the abstract "
"grammar (for example, :class:`ast.stmt` or :class:`ast.expr`).  In addition, "
"there is one class defined for each constructor on the right-hand side; "
"these classes inherit from the classes for the left-hand side trees.  For "
"example, :class:`ast.BinOp` inherits from :class:`ast.expr`.  For production "
"rules with alternatives (aka \"sums\"), the left-hand side class is "
"abstract: only instances of specific constructor nodes are ever created."
msgstr ""
"抽象文法の左辺のシンボル一つずつにそれぞれ一つのクラスがあります (たとえば :"
"class:`ast.stmt` や :class:`ast.expr`)。それに加えて、右辺のコンストラクタ一"
"つずつにそれぞれ一つのクラスがあり、これらのクラスは左辺のツリーのクラスを継"
"承しています。たとえば、 :class:`ast.BinOp` は :class:`ast.expr` から継承して"
"います。代替を伴った生成規則 (production rules with alternatives) (別名 "
"\"sums\") の場合、左辺は抽象クラスとなり、特定のコンストラクタ・ノードのイン"
"スタンスのみが作成されます。"

#: ../../library/ast.rst:64
msgid ""
"Each concrete class has an attribute :attr:`_fields` which gives the names "
"of all child nodes."
msgstr ""
"各具象クラスは属性 :attr:`_fields` を持っており、すべての子ノードの名前をそこ"
"に保持しています。"

#: ../../library/ast.rst:67
msgid ""
"Each instance of a concrete class has one attribute for each child node, of "
"the type as defined in the grammar.  For example, :class:`ast.BinOp` "
"instances have an attribute :attr:`left` of type :class:`ast.expr`."
msgstr ""
"具象クラスのインスタンスは、各子ノードに対してそれぞれひとつの属性を持ってい"
"ます。この属性は、文法で定義された型となります。たとえば :class:`ast.BinOp` "
"のインスタンスは :attr:`left` という属性を持っており、その型は :class:`ast."
"expr` です。"

#: ../../library/ast.rst:71
msgid ""
"If these attributes are marked as optional in the grammar (using a question "
"mark), the value might be ``None``.  If the attributes can have zero-or-more "
"values (marked with an asterisk), the values are represented as Python "
"lists.  All possible attributes must be present and have valid values when "
"compiling an AST with :func:`compile`."
msgstr ""
"これらの属性が、文法上 (クエスチョンマークを用いて) オプションであるとマーク"
"されている場合は、その値が ``None`` となることもあります。属性が0個以上の複数"
"の値をとりうる場合 (アスタリスクでマークされている場合) は、値は Python のリ"
"ストで表されます。全ての属性は AST を :func:`compile` でコンパイルする際には"
"存在しなければならず、そして妥当な値でなければなりません。"

#: ../../library/ast.rst:82
msgid ""
"Instances of :class:`ast.expr` and :class:`ast.stmt` subclasses have :attr:"
"`lineno`, :attr:`col_offset`, :attr:`end_lineno`, and :attr:`end_col_offset` "
"attributes.  The :attr:`lineno` and :attr:`end_lineno` are the first and "
"last line numbers of source text span (1-indexed so the first line is line "
"1) and the :attr:`col_offset` and :attr:`end_col_offset` are the "
"corresponding UTF-8 byte offsets of the first and last tokens that generated "
"the node. The UTF-8 offset is recorded because the parser uses UTF-8 "
"internally."
msgstr ""

#: ../../library/ast.rst:91
msgid ""
"Note that the end positions are not required by the compiler and are "
"therefore optional. The end offset is *after* the last symbol, for example "
"one can get the source segment of a one-line expression node using "
"``source_line[node.col_offset : node.end_col_offset]``."
msgstr ""
"コンパイラは終了位置を必要としないことに注意してください。このため終了位置は"
"省略可能です。終了位置を示すオフセットは最後のシンボルの *後の位置* になりま"
"す。例えば一行で書かれた式のソースコードのセグメントは ``source_line[node."
"col_offset : node.end_col_offset]`` により取得できます。"

#: ../../library/ast.rst:96
msgid ""
"The constructor of a class :class:`ast.T` parses its arguments as follows:"
msgstr "クラス :class:`ast.T` のコンストラクタは引数を次のように解析します:"

#: ../../library/ast.rst:98
msgid ""
"If there are positional arguments, there must be as many as there are items "
"in :attr:`T._fields`; they will be assigned as attributes of these names."
msgstr ""
"位置引数があるとすれば、 :attr:`T._fields` にあるのと同じだけの個数が無ければ"
"なりません。これらの引数はそこにある名前を持った属性として割り当てられます。"

#: ../../library/ast.rst:100
msgid ""
"If there are keyword arguments, they will set the attributes of the same "
"names to the given values."
msgstr ""
"キーワード引数があるとすれば、それらはその名前の属性にその値を割り当てられま"
"す。"

#: ../../library/ast.rst:103
msgid ""
"For example, to create and populate an :class:`ast.UnaryOp` node, you could "
"use ::"
msgstr ""
"たとえば、 :class:`ast.UnaryOp` ノードを生成して属性を埋めるには、次のように"
"することができます ::"

#: ../../library/ast.rst:115
msgid "or the more compact ::"
msgstr "もしくはよりコンパクトにも書けます ::"

#: ../../library/ast.rst:122
msgid "Class :class:`ast.Constant` is now used for all constants."
msgstr ":class:`ast.Constant` が全ての定数に使われるようになりました。"

#: ../../library/ast.rst:126
msgid ""
"Simple indices are represented by their value, extended slices are "
"represented as tuples."
msgstr ""
"単純なインデックスはその値で表現され、幅を持つスライスはタプルで表現されま"
"す。"

#: ../../library/ast.rst:131
msgid ""
"Old classes :class:`ast.Num`, :class:`ast.Str`, :class:`ast.Bytes`, :class:"
"`ast.NameConstant` and :class:`ast.Ellipsis` are still available, but they "
"will be removed in future Python releases.  In the meantime, instantiating "
"them will return an instance of a different class."
msgstr ""
"古いクラスである :class:`ast.Num`, :class:`ast.Str`, :class:`ast.Bytes`, :"
"class:`ast.NameConstant` および :class:`ast.Ellipsis` は現バージョンでは利用"
"可能ですが、将来の Python リリースで削除される予定です。それまでは、これらの"
"クラスをインスタンス化すると異なるクラスのインスタンスが返されます。"

#: ../../library/ast.rst:138
msgid ""
"Old classes :class:`ast.Index` and :class:`ast.ExtSlice` are still "
"available, but they will be removed in future Python releases. In the "
"meantime, instantiating them will return an instance of a different class."
msgstr ""
"古いクラスである :class:`ast.Index` と :class:`ast.ExtSlice` は現バージョンで"
"は利用可能ですが、将来の Python リリースで削除される予定です。それまでは、こ"
"れらのクラスをインスタンス化すると異なるクラスのインスタンスが返されます。"

#: ../../library/ast.rst:144
msgid ""
"The descriptions of the specific node classes displayed here were initially "
"adapted from the fantastic `Green Tree Snakes <https://greentreesnakes."
"readthedocs.io/en/latest/>`__ project and all its contributors."
msgstr ""
"ここに示されている特定のノードクラスについての記述は、素晴らしい `Green Tree "
"Snakes <https://greentreesnakes.readthedocs.io/en/latest/>`__ プロジェクトと"
"そのすべての貢献者の成果物をもとにしています。"

#: ../../library/ast.rst:150
msgid "Literals"
msgstr "リテラル"

#: ../../library/ast.rst:154
msgid ""
"A constant value. The ``value`` attribute of the ``Constant`` literal "
"contains the Python object it represents. The values represented can be "
"simple types such as a number, string or ``None``, but also immutable "
"container types (tuples and frozensets) if all of their elements are "
"constant."
msgstr ""
"定数です。 ``Constant`` リテラルの ``value`` 属性は定数値を表す Python オブ"
"ジェクトを保持します。定数として表現される値は数値、文字列、または ``None`` "
"のような単純な型のほかに、全ての要素が定数であるイミュータブルなコンテナ型 "
"(tuples および frozensets) も設定可能です。"

#: ../../library/ast.rst:168
msgid ""
"Node representing a single formatting field in an f-string. If the string "
"contains a single formatting field and nothing else the node can be isolated "
"otherwise it appears in :class:`JoinedStr`."
msgstr ""
"このノードは f-string における単一の書式指定置換フィールドを表現します。文字"
"列が単一の置換フィールドしか持たず、他に何も含まない場合は、ノードは単独で存"
"在できます。そうでない場合は  :class:`JoinedStr` の一部としてあらわれます。"

#: ../../library/ast.rst:172
msgid ""
"``value`` is any expression node (such as a literal, a variable, or a "
"function call)."
msgstr ""
"``value`` は式ツリーのノードのいずれか (リテラル、変数、関数呼び出しなど) で"
"す。"

#: ../../library/ast.rst:174
msgid "``conversion`` is an integer:"
msgstr "``conversion`` は整数です:"

#: ../../library/ast.rst:176
msgid "-1: no formatting"
msgstr "-1: 書式指定なし"

#: ../../library/ast.rst:177
msgid "115: ``!s`` string formatting"
msgstr "115: ``!s`` 文字列書式指定"

#: ../../library/ast.rst:178
msgid "114: ``!r`` repr formatting"
msgstr "114: ``!r`` repr 書式指定"

#: ../../library/ast.rst:179
msgid "97: ``!a`` ascii formatting"
msgstr "97: ``!a`` ascii 書式指定"

#: ../../library/ast.rst:181
msgid ""
"``format_spec`` is a :class:`JoinedStr` node representing the formatting of "
"the value, or ``None`` if no format was specified. Both ``conversion`` and "
"``format_spec`` can be set at the same time."
msgstr ""
"``format_spec`` は値の書式指定を表現する :class:`JoinedStr` ノード、もしくは"
"書式指定がない場合は ``None`` です。 ``conversion`` と ``format_spec`` を同時"
"に設定することができます。"

#: ../../library/ast.rst:188
msgid ""
"An f-string, comprising a series of :class:`FormattedValue` and :class:"
"`Constant` nodes."
msgstr ""
":class:`FormattedValue` ノードと :class:`Constant` ノードの集まりからなる f-"
"string です。"

#: ../../library/ast.rst:217
msgid ""
"A list or tuple. ``elts`` holds a list of nodes representing the elements. "
"``ctx`` is :class:`Store` if the container is an assignment target (i.e. "
"``(x,y)=something``), and :class:`Load` otherwise."
msgstr ""
"リストまたはタプルをあらわします。 ``elts`` は内包する要素を表現するノードの"
"リストを保持します。 ``ctx`` はコンテナが代入のターゲットである場合 (たとえ"
"ば ``(x,y)=something`` のような場合) は :class:`Store` であり、そうでない場合"
"は :class:`Load` です。"

#: ../../library/ast.rst:243
msgid "A set. ``elts`` holds a list of nodes representing the set's elements."
msgstr ""
"集合 (set) をあらわします。 ``elts`` は集合の各要素を表現するノードのリストを"
"保持します。"

#: ../../library/ast.rst:258
msgid ""
"A dictionary. ``keys`` and ``values`` hold lists of nodes representing the "
"keys and the values respectively, in matching order (what would be returned "
"when calling :code:`dictionary.keys()` and :code:`dictionary.values()`)."
msgstr ""
"辞書をあらわします。 ``keys`` と ``values`` はそれぞれキーと値のノードのリス"
"ト を順序が一致した形で (それぞれ :code:`dictionary.keys()` と :code:"
"`dictionary.values()` を呼び出したときに返される順序で) 保持します。"

#: ../../library/ast.rst:262
msgid ""
"When doing dictionary unpacking using dictionary literals the expression to "
"be expanded goes in the ``values`` list, with a ``None`` at the "
"corresponding position in ``keys``."
msgstr ""
"辞書リテラルを使って辞書を展開した場合、展開された式ツリーにおいて辞書は "
"``values`` リストに入り、 ``keys`` の対応する位置には ``None`` が入ります。"

#: ../../library/ast.rst:280
msgid "Variables"
msgstr "変数"

#: ../../library/ast.rst:284
msgid ""
"A variable name. ``id`` holds the name as a string, and ``ctx`` is one of "
"the following types."
msgstr ""
"変数名をあらわします。 ``id`` は変数名を文字列で保持し、 ``ctx`` は以下に示す"
"型のいずれかです。"

#: ../../library/ast.rst:292
msgid ""
"Variable references can be used to load the value of a variable, to assign a "
"new value to it, or to delete it. Variable references are given a context to "
"distinguish these cases."
msgstr ""
"変数の参照は変数の値をロードするか、新しい値を割り当てるか、または値を削除す"
"るために使うことができます。変数の参照はこれら3つの場合を区別するためのコンテ"
"キストによって与えられます。"

#: ../../library/ast.rst:325
msgid ""
"A ``*var`` variable reference. ``value`` holds the variable, typically a :"
"class:`Name` node. This type must be used when building a :class:`Call` node "
"with ``*args``."
msgstr ""
"``*var`` 形式の変数の参照をあらわします。 ``value`` は変数、典型的には :"
"class:`Name` ノード、を保持します。この型は ``*args`` を伴う関数呼び出しノー"
"ド :class:`Call` を構築する際に使用します。 "

#: ../../library/ast.rst:348
msgid "Expressions"
msgstr "式 (expression)"

#: ../../library/ast.rst:352
msgid ""
"When an expression, such as a function call, appears as a statement by "
"itself with its return value not used or stored, it is wrapped in this "
"container. ``value`` holds one of the other nodes in this section, a :class:"
"`Constant`, a :class:`Name`, a :class:`Lambda`, a :class:`Yield` or :class:"
"`YieldFrom` node."
msgstr ""
"関数呼び出しのような式がそれ自身で文となり、戻り値が使われないかまたは保存さ"
"れないとき、その式はこのコンテナでラップされます。 ``value`` はこの節で説明す"
"る他のノード、 :class:`Constant` ノード、 :class:`Name` ノード、 :class:"
"`Lambda` ノード :class:`Yield` ノードまたは :class:`YieldFrom` ノードのいずれ"
"かを保持します。"

#: ../../library/ast.rst:371
msgid ""
"A unary operation. ``op`` is the operator, and ``operand`` any expression "
"node."
msgstr ""
"単項演算をあらわします。 ``op`` は演算子で、 ``operand`` は任意の式ツリーの"
"ノードです。"

#: ../../library/ast.rst:380
msgid ""
"Unary operator tokens. :class:`Not` is the ``not`` keyword, :class:`Invert` "
"is the ``~`` operator."
msgstr ""
"単項演算の演算子をあらわします。 :class:`Not` は論理否定キーワード ``not`` で"
"あり、 :class:`Invert` はビット反転演算子 ``~`` です。"

#: ../../library/ast.rst:394
msgid ""
"A binary operation (like addition or division). ``op`` is the operator, and "
"``left`` and ``right`` are any expression nodes."
msgstr ""
"(加算や減算のような) 二項演算をあらわします。 ``op`` は演算子、 ``left`` と "
"``right`` は任意の式ツリーのノードです。"

#: ../../library/ast.rst:421
msgid "Binary operator tokens."
msgstr "二項演算の演算子をあらわします。"

#: ../../library/ast.rst:426
msgid ""
"A boolean operation, 'or' or 'and'. ``op`` is :class:`Or` or :class:`And`. "
"``values`` are the values involved. Consecutive operations with the same "
"operator, such as ``a or b or c``, are collapsed into one node with several "
"values."
msgstr ""
"'or' や 'and' のような論理演算をあらわします。 ``op`` は :class:`Or` または :"
"class:`And` です。 ``values`` は必要な値のリストです。 ``a or b or c`` のよう"
"に同じ演算子を使う連続した演算は、複数の値を持った単一のノードとして表現され"
"ます。"

#: ../../library/ast.rst:431
msgid "This doesn't include ``not``, which is a :class:`UnaryOp`."
msgstr "``not`` は単項演算 :class:`UnaryOp` のため、ここには含まれません。"

#: ../../library/ast.rst:447
msgid "Boolean operator tokens."
msgstr "論理演算の演算子をあらわします。"

#: ../../library/ast.rst:452
msgid ""
"A comparison of two or more values. ``left`` is the first value in the "
"comparison, ``ops`` the list of operators, and ``comparators`` the list of "
"values after the first element in the comparison."
msgstr ""
"2つ以上の値の比較をあらわします。 ``left`` 比較の中の最初の値、``ops`` は演算"
"子のリスト、 ``comparators`` は2つ目以降の値のリストです。"

#: ../../library/ast.rst:481
msgid "Comparison operator tokens."
msgstr "比較演算の演算子をあらわします。"

#: ../../library/ast.rst:486
msgid ""
"A function call. ``func`` is the function, which will often be a :class:"
"`Name` or :class:`Attribute` object. Of the arguments:"
msgstr ""
"関数呼び出しをあらわします。 ``func`` は関数で、多くの場合 :class:`Name` また"
"は :class:`Attribute` のオブジェクトです。 関数呼び出しの引数:"

#: ../../library/ast.rst:489
msgid "``args`` holds a list of the arguments passed by position."
msgstr "``args`` は位置引数のリストを保持します。 "

#: ../../library/ast.rst:490
msgid ""
"``keywords`` holds a list of :class:`keyword` objects representing arguments "
"passed by keyword."
msgstr ""
"``keywords`` は :class:`keyword` クラスのオブジェクトのリスト保持し、キーワー"
"ド引数をあらわします。"

#: ../../library/ast.rst:493
msgid ""
"When creating a ``Call`` node, ``args`` and ``keywords`` are required, but "
"they can be empty lists. ``starargs`` and ``kwargs`` are optional."
msgstr ""
"``Call`` ノードを生成するときに ``args`` と ``keywords`` は必須ですが、空のリ"
"ストであってもかまいません。 ``starargs`` と ``kwargs`` はオプション引数で"
"す。"

#: ../../library/ast.rst:517
msgid ""
"A keyword argument to a function call or class definition. ``arg`` is a raw "
"string of the parameter name, ``value`` is a node to pass in."
msgstr ""
"関数呼び出しまたはクラス定義のキーワード引数をあらわします。 ``arg`` はパラ"
"メータ名をあらわす文字列、 ``value`` は引数に渡す値をあらわすノードです。"

#: ../../library/ast.rst:523
msgid ""
"An expression such as ``a if b else c``. Each field holds a single node, so "
"in the following example, all three are :class:`Name` nodes."
msgstr ""
"``a if b else c`` のような式をあらわします。各フィールドは単一のノードを保持"
"します。以下の例では、3つの式ノードはすべて :class:`Name` ノードです。"

#: ../../library/ast.rst:538
msgid ""
"Attribute access, e.g. ``d.keys``. ``value`` is a node, typically a :class:"
"`Name`. ``attr`` is a bare string giving the name of the attribute, and "
"``ctx`` is :class:`Load`, :class:`Store` or :class:`Del` according to how "
"the attribute is acted on."
msgstr ""
"たとえば ``d.keys`` のような属性へのアクセスです。 ``value`` はノードで、典型"
"的には :class:`Name` です。 ``attr`` は属性名を与える生の文字列で、 ``ctx`` "
"はその属性がどのように振る舞うかに応じて :class:`Load`、 :class:`Store` また"
"は :class:`Del` のいずれかです。"

#: ../../library/ast.rst:555
msgid ""
"A named expression. This AST node is produced by the assignment expressions "
"operator (also known as the walrus operator). As opposed to the :class:"
"`Assign` node in which the first argument can be multiple nodes, in this "
"case both ``target`` and ``value`` must be single nodes."
msgstr ""
"代入式です。この AST ノードは代入式演算子（ウォルラス演算子、または「セイウチ"
"演算子」としても知られています）によって生成されます。第一引数が複数のノード"
"であってもよい :class:`Assign` ノードと異なり、このノードの場合は ``target`` "
"と ``value`` の両方が単一のノードでなければなりません。"

#: ../../library/ast.rst:570
msgid "Subscripting"
msgstr "配列要素の参照 (Subscripting)"

#: ../../library/ast.rst:574
msgid ""
"A subscript, such as ``l[1]``. ``value`` is the subscripted object (usually "
"sequence or mapping). ``slice`` is an index, slice or key. It can be a :"
"class:`Tuple` and contain a :class:`Slice`. ``ctx`` is :class:`Load`, :class:"
"`Store` or :class:`Del` according to the action performed with the subscript."
msgstr ""
"``l[1]`` のような配列要素の参照をあらわします。 ``value`` は参照元のオブジェ"
"クトです (通常シーケンス型またはマッピング型)。 ``slice`` はインデックス、ス"
"ライス、またはキーです。 :class:`Slice` を含む :class:`Tuple` でもかまいませ"
"ん。 ``ctx`` は要素の参照により実行されるアクションに応じて :class:`Load`、 :"
"class:`Store` または :class:`Del` のいずれかです。"

#: ../../library/ast.rst:598
msgid ""
"Regular slicing (on the form ``lower:upper`` or ``lower:upper:step``). Can "
"occur only inside the *slice* field of :class:`Subscript`, either directly "
"or as an element of :class:`Tuple`."
msgstr ""
"基本的なスライス操作 (``lower:upper`` や ``lower:upper:step`` の形式) をあら"
"わします。 :class:`Subscript` の *slice* フィールドでの直接指定か、または :"
"class:`Tuple` の要素として指定する場合のみ利用可能です。"

#: ../../library/ast.rst:615
msgid "Comprehensions"
msgstr "内包表記 (Comprehension)"

#: ../../library/ast.rst:622
msgid ""
"List and set comprehensions, generator expressions, and dictionary "
"comprehensions. ``elt`` (or ``key`` and ``value``) is a single node "
"representing the part that will be evaluated for each item."
msgstr ""
"リストや集合の内包表記、ジェネレータ、および辞書の内包表記です。 ``elt`` (ま"
"たは ``key`` と ``value``) は各要素として評価される部品をあらわす単一のノード"
"です。"

#: ../../library/ast.rst:626
msgid "``generators`` is a list of :class:`comprehension` nodes."
msgstr "``generators`` は :class:`comprehension` ノードのリストです。"

#: ../../library/ast.rst:668
msgid ""
"One ``for`` clause in a comprehension. ``target`` is the reference to use "
"for each element - typically a :class:`Name` or :class:`Tuple` node. "
"``iter`` is the object to iterate over. ``ifs`` is a list of test "
"expressions: each ``for`` clause can have multiple ``ifs``."
msgstr ""
"内包表記におけるひとつの ``for`` 節をあらわします。 ``target`` は各要素への参"
"照です - 典型的には :class:`Name` または :class:`Tuple` ノードです。 "
"``iter`` はイテレートする対象のオブジェクトです。 ``ifs`` は条件節のリストで"
"す: 各 ``for`` 節は複数の ``ifs`` を持つことができます。"

#: ../../library/ast.rst:673
msgid ""
"``is_async`` indicates a comprehension is asynchronous (using an ``async "
"for`` instead of ``for``). The value is an integer (0 or 1)."
msgstr ""
"``is_async`` は内包表記が非同期であることを示します (``async for`` を "
"``for`` の代わりに使います)。値は整数です (0 または 1)。"

#: ../../library/ast.rst:739
msgid "Statements"
msgstr "文 (Statements)"

#: ../../library/ast.rst:743
msgid ""
"An assignment. ``targets`` is a list of nodes, and ``value`` is a single "
"node."
msgstr ""
"代入です。 ``targets`` はノードのリスト、 ``value`` は単一のノードです。"

#: ../../library/ast.rst:745
msgid ""
"Multiple nodes in ``targets`` represents assigning the same value to each. "
"Unpacking is represented by putting a :class:`Tuple` or :class:`List` within "
"``targets``."
msgstr ""
"``targets`` の複数のノードは、それぞれに対して同じ値を代入することをあらわし"
"ます。分割代入は ``targets`` 内に :class:`Tuple` または :class:`List` を置く"
"ことで表現されます。"

#: ../../library/ast.rst:751 ../../library/ast.rst:1038
#: ../../library/ast.rst:1242 ../../library/ast.rst:1663
msgid ""
"``type_comment`` is an optional string with the type annotation as a comment."
msgstr ""
"``type_comment`` はコメントとして型アノテーションをあらわすオプション文字列で"
"す。"

#: ../../library/ast.rst:781
msgid ""
"An assignment with a type annotation. ``target`` is a single node and can be "
"a :class:`Name`, a :class:`Attribute` or a :class:`Subscript`. "
"``annotation`` is the annotation, such as a :class:`Constant` or :class:"
"`Name` node. ``value`` is a single optional node. ``simple`` is a boolean "
"integer set to True for a :class:`Name` node in ``target`` that do not "
"appear in between parenthesis and are hence pure names and not expressions."
msgstr ""
"型アノテーションを伴う代入です。 ``target`` は単一のノードで、 :class:"
"`Name`,  :class:`Attribute` または :class:`Subscript` のいずれかです。 "
"``annotation`` は :class:`Constant` や :class:`Name` node のようなアノテー"
"ションです。 ``value`` はオプションで、代入する値を単一のノードであらわしたも"
"のです。 ``simple`` 真偽値と解釈される整数で、 ``target`` の :class:`Name` "
"ノードが丸かっこに囲まれておらず、したがって式ではなく純粋な名前である場合に "
"True を設定します。"

#: ../../library/ast.rst:836
msgid ""
"Augmented assignment, such as ``a += 1``. In the following example, "
"``target`` is a :class:`Name` node for ``x`` (with the :class:`Store` "
"context), ``op`` is :class:`Add`, and ``value`` is a :class:`Constant` with "
"value for 1."
msgstr ""
"``a += 1`` のような累積代入をあらわします。下記の例では、 ``target`` は (:"
"class:`Store` コンテキストを伴う) ``x`` のための :class:`Name` ノード、 "
"``op`` は :class:`Add` 演算子、そして ``value`` は定数1をあらわす :class:"
"`Constant` ノードです。"

#: ../../library/ast.rst:841
msgid ""
"The ``target`` attribute cannot be of class :class:`Tuple` or :class:`List`, "
"unlike the targets of :class:`Assign`."
msgstr ""

#: ../../library/ast.rst:858
msgid ""
"A ``raise`` statement. ``exc`` is the exception object to be raised, "
"normally a :class:`Call` or :class:`Name`, or ``None`` for a standalone "
"``raise``. ``cause`` is the optional part for ``y`` in ``raise x from y``."
msgstr ""
"``raise`` 文をあらわします。 ``exc`` は送出される例外オブジェクトで、通常は :"
"class:`Call` または :class:`Name`、 もしくは単独の ``raise`` では ``None`` を"
"指定します。 ``cause`` はオプションで、 ``raise x from y`` の ``y`` にあたり"
"ます。"

#: ../../library/ast.rst:875
msgid ""
"An assertion. ``test`` holds the condition, such as a :class:`Compare` node. "
"``msg`` holds the failure message."
msgstr ""
"アサーションです。 ``test`` は :class:`Compare` ノードなどのような条件を保持"
"します。 ``msg`` は失敗した時のメッセージを保持します。"

#: ../../library/ast.rst:891
msgid ""
"Represents a ``del`` statement. ``targets`` is a list of nodes, such as :"
"class:`Name`, :class:`Attribute` or :class:`Subscript` nodes."
msgstr ""
"``del`` 文をあらわします。 ``targets`` は :class:`Name`, :class:"
"`Attribute`,  :class:`Subscript` などのノードのリストです。"

#: ../../library/ast.rst:909
msgid "A ``pass`` statement."
msgstr "``pass`` 文をあらわします。"

#: ../../library/ast.rst:920
msgid ""
"Other statements which are only applicable inside functions or loops are "
"described in other sections."
msgstr ""
"関数またはループの内部でのみ適用可能な他の文は、別のセクションで説明します。"

#: ../../library/ast.rst:924
msgid "Imports"
msgstr "インポート"

#: ../../library/ast.rst:928
msgid "An import statement. ``names`` is a list of :class:`alias` nodes."
msgstr "インポート文です。 ``names`` は :class:`alias` ノードのリストです。"

#: ../../library/ast.rst:945
msgid ""
"Represents ``from x import y``. ``module`` is a raw string of the 'from' "
"name, without any leading dots, or ``None`` for statements such as ``from . "
"import foo``. ``level`` is an integer holding the level of the relative "
"import (0 means absolute import)."
msgstr ""
"``from x import y`` をあらわします。 ``module`` は 'from' でインポートする先"
"頭がドットでないモジュール名をあらわす文字列か、または ``from . import foo`` "
"のような構文の場合は ``None`` を指定します。 ``level`` は相対インポートのレベ"
"ルを表す整数を保持します (0 は絶対インポートを意味します)。"

#: ../../library/ast.rst:967
msgid ""
"Both parameters are raw strings of the names. ``asname`` can be ``None`` if "
"the regular name is to be used."
msgstr ""
"いずれのパラメータも名前をあらわす生の文字列です。 ``asname`` は標準の名前を"
"使う場合は ``None`` を指定できます。"

#: ../../library/ast.rst:984
msgid "Control flow"
msgstr "制御フロー"

#: ../../library/ast.rst:987
msgid ""
"Optional clauses such as ``else`` are stored as an empty list if they're not "
"present."
msgstr ""
"``else`` 節のようなオプションの節が存在しない場合は、空のリストとして保存され"
"ます。"

#: ../../library/ast.rst:992
msgid ""
"An ``if`` statement. ``test`` holds a single node, such as a :class:"
"`Compare` node. ``body`` and ``orelse`` each hold a list of nodes."
msgstr ""
"``if`` 文です。 ``test`` は :class:`Compare` ノードなどの単一のノードを保持し"
"ます。 ``body`` と ``orelse`` はそれぞれノードのリストを保持します。"

#: ../../library/ast.rst:995
msgid ""
"``elif`` clauses don't have a special representation in the AST, but rather "
"appear as extra :class:`If` nodes within the ``orelse`` section of the "
"previous one."
msgstr ""
"``elif`` 節は AST において固有の表現を持たず、先行する節をあらわすノードの "
"``orelse`` セクションに追加の :class:`If` ノードとして現れます。"

#: ../../library/ast.rst:1030
msgid ""
"A ``for`` loop. ``target`` holds the variable(s) the loop assigns to, as a "
"single :class:`Name`, :class:`Tuple` or :class:`List` node. ``iter`` holds "
"the item to be looped over, again as a single node. ``body`` and ``orelse`` "
"contain lists of nodes to execute. Those in ``orelse`` are executed if the "
"loop finishes normally, rather than via a ``break`` statement."
msgstr ""
"``for`` ループです。 ``target`` はループが割り当てる単一または複数の変数を :"
"class:`Name`, :class:`Tuple` または :class:`List` のいずれかを単一のノードで"
"保持します。 ``iter`` はループ対象の変数を、同じく単一のノードで保持します。 "
"``body`` と ``orelse`` は実行するノードのリストを含んでいます。 ``orelse`` に"
"含まれるノードは、ループが ``break`` 文によって中断せず、正常終了した場合に実"
"行されます。"

#: ../../library/ast.rst:1064
msgid ""
"A ``while`` loop. ``test`` holds the condition, such as a :class:`Compare` "
"node."
msgstr ""
"``while`` ループです。 ``test`` は :class:`Compare` のような条件をあらわす"
"ノードを保持します。"

#: ../../library/ast.rst:1091
msgid "The ``break`` and ``continue`` statements."
msgstr "``break`` 文および ``continue`` 文です。"

#: ../../library/ast.rst:1126
msgid ""
"``try`` blocks. All attributes are list of nodes to execute, except for "
"``handlers``, which is a list of :class:`ExceptHandler` nodes."
msgstr ""
"``try`` ブロックです。 :class:`ExceptHandler` ノードのリストである "
"``handlers`` を除き、全ての属性はそれぞれの節で実行するノードのリストです。"

#: ../../library/ast.rst:1172
msgid ""
"``try`` blocks which are followed by ``except*`` clauses. The attributes are "
"the same as for :class:`Try` but the :class:`ExceptHandler` nodes in "
"``handlers`` are interpreted as ``except*`` blocks rather then ``except``."
msgstr ""

#: ../../library/ast.rst:1203
msgid ""
"A single ``except`` clause. ``type`` is the exception type it will match, "
"typically a :class:`Name` node (or ``None`` for a catch-all ``except:`` "
"clause). ``name`` is a raw string for the name to hold the exception, or "
"``None`` if the clause doesn't have ``as foo``. ``body`` is a list of nodes."
msgstr ""
"単一の ``except`` 節をあらわします。 ``type`` はこの節にマッチする例外のタイ"
"プで、典型的には :class:`Name` ノードです (``None`` を指定すると全ての例外を"
"キャッチする ``except:`` 節をあらわします)。 ``name`` は例外オブジェクトを保"
"持する変数の名前をあらわす生の文字列で、 ``as foo`` を持たない節の場合は "
"``None`` を指定します。 ``body`` はノードのリストです。"

#: ../../library/ast.rst:1237
msgid ""
"A ``with`` block. ``items`` is a list of :class:`withitem` nodes "
"representing the context managers, and ``body`` is the indented block inside "
"the context."
msgstr ""
"``with`` ブロックです。 ``items`` は :class:`withitem` ノードのリストで、コン"
"テキストマネージャのリストをあらわします。また ``body`` はコンテキスト内にイ"
"ンデントされたブロックです。"

#: ../../library/ast.rst:1247
msgid ""
"A single context manager in a ``with`` block. ``context_expr`` is the "
"context manager, often a :class:`Call` node. ``optional_vars`` is a :class:"
"`Name`, :class:`Tuple` or :class:`List` for the ``as foo`` part, or ``None`` "
"if that isn't used."
msgstr ""
"``with`` ブロックにおける単一のコンテキストマネージャをあらわします。 "
"``context_expr`` はコンテキストマネージャで、しばしば :class:`Call` ノードが"
"設定されます。 ``optional_vars`` は ``as foo`` に相当する :class:`Name`, :"
"class:`Tuple` または :class:`List` のいずれかのノードか、または、この部分が不"
"要な場合は ``None`` を設定します。"

#: ../../library/ast.rst:1280
msgid "Pattern matching"
msgstr ""

#: ../../library/ast.rst:1285
msgid ""
"A ``match`` statement. ``subject`` holds the subject of the match (the "
"object that is being matched against the cases) and ``cases`` contains an "
"iterable of :class:`match_case` nodes with the different cases."
msgstr ""

#: ../../library/ast.rst:1291
msgid ""
"A single case pattern in a ``match`` statement. ``pattern`` contains the "
"match pattern that the subject will be matched against. Note that the :class:"
"`AST` nodes produced for patterns differ from those produced for "
"expressions, even when they share the same syntax."
msgstr ""

#: ../../library/ast.rst:1296
msgid ""
"The ``guard`` attribute contains an expression that will be evaluated if the "
"pattern matches the subject."
msgstr ""

#: ../../library/ast.rst:1299
msgid ""
"``body`` contains a list of nodes to execute if the pattern matches and the "
"result of evaluating the guard expression is true."
msgstr ""

#: ../../library/ast.rst:1342
msgid ""
"A match literal or value pattern that compares by equality. ``value`` is an "
"expression node. Permitted value nodes are restricted as described in the "
"match statement documentation. This pattern succeeds if the match subject is "
"equal to the evaluated value."
msgstr ""

#: ../../library/ast.rst:1369
msgid ""
"A match literal pattern that compares by identity. ``value`` is the "
"singleton to be compared against: ``None``, ``True``, or ``False``. This "
"pattern succeeds if the match subject is the given constant."
msgstr ""

#: ../../library/ast.rst:1394
msgid ""
"A match sequence pattern. ``patterns`` contains the patterns to be matched "
"against the subject elements if the subject is a sequence. Matches a "
"variable length sequence if one of the subpatterns is a ``MatchStar`` node, "
"otherwise matches a fixed length sequence."
msgstr ""

#: ../../library/ast.rst:1425
msgid ""
"Matches the rest of the sequence in a variable length match sequence "
"pattern. If ``name`` is not ``None``, a list containing the remaining "
"sequence elements is bound to that name if the overall sequence pattern is "
"successful."
msgstr ""

#: ../../library/ast.rst:1465
msgid ""
"A match mapping pattern. ``keys`` is a sequence of expression nodes. "
"``patterns`` is a corresponding sequence of pattern nodes. ``rest`` is an "
"optional name that can be specified to capture the remaining mapping "
"elements. Permitted key expressions are restricted as described in the match "
"statement documentation."
msgstr ""

#: ../../library/ast.rst:1471
msgid ""
"This pattern succeeds if the subject is a mapping, all evaluated key "
"expressions are present in the mapping, and the value corresponding to each "
"key matches the corresponding subpattern. If ``rest`` is not ``None``, a "
"dict containing the remaining mapping elements is bound to that name if the "
"overall mapping pattern is successful."
msgstr ""

#: ../../library/ast.rst:1511
msgid ""
"A match class pattern. ``cls`` is an expression giving the nominal class to "
"be matched. ``patterns`` is a sequence of pattern nodes to be matched "
"against the class defined sequence of pattern matching attributes. "
"``kwd_attrs`` is a sequence of additional attributes to be matched "
"(specified as keyword arguments in the class pattern), ``kwd_patterns`` are "
"the corresponding patterns (specified as keyword values in the class "
"pattern)."
msgstr ""

#: ../../library/ast.rst:1518
msgid ""
"This pattern succeeds if the subject is an instance of the nominated class, "
"all positional patterns match the corresponding class-defined attributes, "
"and any specified keyword attributes match their corresponding pattern."
msgstr ""

#: ../../library/ast.rst:1522
msgid ""
"Note: classes may define a property that returns self in order to match a "
"pattern node against the instance being matched. Several builtin types are "
"also matched that way, as described in the match statement documentation."
msgstr ""

#: ../../library/ast.rst:1575
msgid ""
"A match \"as-pattern\", capture pattern or wildcard pattern. ``pattern`` "
"contains the match pattern that the subject will be matched against. If the "
"pattern is ``None``, the node represents a capture pattern (i.e a bare name) "
"and will always succeed."
msgstr ""

#: ../../library/ast.rst:1580
msgid ""
"The ``name`` attribute contains the name that will be bound if the pattern "
"is successful. If ``name`` is ``None``, ``pattern`` must also be ``None`` "
"and the node represents the wildcard pattern."
msgstr ""

#: ../../library/ast.rst:1616
msgid ""
"A match \"or-pattern\". An or-pattern matches each of its subpatterns in "
"turn to the subject, until one succeeds. The or-pattern is then deemed to "
"succeed. If none of the subpatterns succeed the or-pattern fails. The "
"``patterns`` attribute contains a list of match pattern nodes that will be "
"matched against the subject."
msgstr ""

#: ../../library/ast.rst:1648
msgid "Function and class definitions"
msgstr "関数およびクラス定義"

#: ../../library/ast.rst:1652
msgid "A function definition."
msgstr "関数定義です。"

#: ../../library/ast.rst:1654
msgid "``name`` is a raw string of the function name."
msgstr "``name`` は関数名をあらわす生の文字列です。"

#: ../../library/ast.rst:1655
msgid "``args`` is an :class:`arguments` node."
msgstr "``args`` は引数をあらわす :class:`arguments` ノードです。"

#: ../../library/ast.rst:1656
msgid "``body`` is the list of nodes inside the function."
msgstr "``body`` は関数の本体をあらわすノードのリストです。"

#: ../../library/ast.rst:1657
msgid ""
"``decorator_list`` is the list of decorators to be applied, stored outermost "
"first (i.e. the first in the list will be applied last)."
msgstr ""
"``decorator_list`` は関数に適用されるデコレータのリストで、外側のデコレータが"
"リストの先頭に保存されます (すなわち、リストの先頭にあるデコレータが最後に適"
"用されます)。"

#: ../../library/ast.rst:1659
msgid "``returns`` is the return annotation."
msgstr "``returns`` は戻り値に対する注釈です。"

#: ../../library/ast.rst:1668
msgid ""
"``lambda`` is a minimal function definition that can be used inside an "
"expression. Unlike :class:`FunctionDef`, ``body`` holds a single node."
msgstr ""
"``lambda`` は式の中で使うことができる最小限の関数定義です。 :class:"
"`FunctionDef` ノードと異なり、 ``body`` は単一のノードとなります。"

#: ../../library/ast.rst:1692
msgid "The arguments for a function."
msgstr "関数の引数"

#: ../../library/ast.rst:1694
msgid ""
"``posonlyargs``, ``args`` and ``kwonlyargs`` are lists of :class:`arg` nodes."
msgstr ""
"``posonlyargs``, ``args`` および ``kwonlyargs`` はそれぞれ :class:`arg` ノー"
"ドのリストです。"

#: ../../library/ast.rst:1695
msgid ""
"``vararg`` and ``kwarg`` are single :class:`arg` nodes, referring to the "
"``*args, **kwargs`` parameters."
msgstr ""
"``vararg`` と ``kwarg`` はそれぞれ単一の :class:`arg` ノードで、 ``*args, "
"**kwargs`` パラメータに相当します。"

#: ../../library/ast.rst:1697
msgid ""
"``kw_defaults`` is a list of default values for keyword-only arguments. If "
"one is ``None``, the corresponding argument is required."
msgstr ""
"``kw_defaults`` はキーワード専用引数に対するデフォルト値のリストです。値が "
"``None`` の場合、対応する引数は必須となります。"

#: ../../library/ast.rst:1699
msgid ""
"``defaults`` is a list of default values for arguments that can be passed "
"positionally. If there are fewer defaults, they correspond to the last n "
"arguments."
msgstr ""
"``defaults`` は位置引数として渡すことのできる引数に対するデフォルト値のリスト"
"です。デフォルト値の数nが位置引数の数より少ない場合、それらは最後のn個の引数"
"に割り当てられます。"

#: ../../library/ast.rst:1706
msgid ""
"A single argument in a list. ``arg`` is a raw string of the argument name, "
"``annotation`` is its annotation, such as a :class:`Str` or :class:`Name` "
"node."
msgstr ""
"単一の引数をあらわします。 ``arg`` は引数名をあらわす生の文字列、 "
"``annotation`` は、 :class:`Str` や :class:`Name` ノードのような引数に対する"
"注釈です。"

#: ../../library/ast.rst:1712
msgid ""
"``type_comment`` is an optional string with the type annotation as a comment"
msgstr ""
"``type_comment`` はコメントとして型アノテーションをあらわすオプション文字列で"
"す。"

#: ../../library/ast.rst:1756
msgid "A ``return`` statement."
msgstr "``return`` 文です。"

#: ../../library/ast.rst:1771
msgid ""
"A ``yield`` or ``yield from`` expression. Because these are expressions, "
"they must be wrapped in a :class:`Expr` node if the value sent back is not "
"used."
msgstr ""
"``yield`` または ``yield from`` 式をあらわします。これらは式なので、送り返さ"
"れる値が使われない場合は :class:`Expr` ノードでラップされなければなりません。"

#: ../../library/ast.rst:1796
msgid ""
"``global`` and ``nonlocal`` statements. ``names`` is a list of raw strings."
msgstr ""
"``global`` および ``nonlocal`` 文です。 ``names`` は生の文字列のリストです。"

#: ../../library/ast.rst:1823
msgid "A class definition."
msgstr "クラス定義です。"

#: ../../library/ast.rst:1825
msgid "``name`` is a raw string for the class name"
msgstr "``name`` はクラス名をあらわす生の文字列です。"

#: ../../library/ast.rst:1826
msgid "``bases`` is a list of nodes for explicitly specified base classes."
msgstr "``bases`` は明示的に指定された基底クラスをあらわすノードのリストです。"

#: ../../library/ast.rst:1827
msgid ""
"``keywords`` is a list of :class:`keyword` nodes, principally for "
"'metaclass'. Other keywords will be passed to the metaclass, as per "
"`PEP-3115 <https://peps.python.org/pep-3115/>`_."
msgstr ""

#: ../../library/ast.rst:1830
msgid ""
"``starargs`` and ``kwargs`` are each a single node, as in a function call. "
"starargs will be expanded to join the list of base classes, and kwargs will "
"be passed to the metaclass."
msgstr ""
"``starargs`` と ``kwargs`` は、関数呼び出しの場合と同様にそれぞれ単一のノード"
"です。 starargs はベースクラスのリストと結合するために展開され、 kwargs はメ"
"タクラスに渡されます。"

#: ../../library/ast.rst:1833
msgid ""
"``body`` is a list of nodes representing the code within the class "
"definition."
msgstr "``body`` はクラス定義に含まれるコードをあらわすノードのリストです。"

#: ../../library/ast.rst:1835
msgid "``decorator_list`` is a list of nodes, as in :class:`FunctionDef`."
msgstr ""
"``decorator_list`` はノードのリストで、関数定義 :class:`FunctionDef` の場合と"
"同様に解釈されます。"

#: ../../library/ast.rst:1864
msgid "Async and await"
msgstr "async と await"

#: ../../library/ast.rst:1868
msgid ""
"An ``async def`` function definition. Has the same fields as :class:"
"`FunctionDef`."
msgstr ""
"``async def`` 形式の関数定義です。通常の関数定義 :class:`FunctionDef` と同じ"
"フィールドを持ちます。"

#: ../../library/ast.rst:1874
msgid ""
"An ``await`` expression. ``value`` is what it waits for. Only valid in the "
"body of an :class:`AsyncFunctionDef`."
msgstr ""
"``await`` 式をあらわします。 ``value`` は待ち受ける値です。 :class:"
"`AsyncFunctionDef` の本体 (body) の中でのみ有効です。"

#: ../../library/ast.rst:1907
msgid ""
"``async for`` loops and ``async with`` context managers. They have the same "
"fields as :class:`For` and :class:`With`, respectively. Only valid in the "
"body of an :class:`AsyncFunctionDef`."
msgstr ""
"``async for`` ループと ``async with`` コンテキストマネージャです。それぞれ :"
"class:`For` および :class:`With` と同じフィールドを持ちます。 :class:"
"`AsyncFunctionDef` の本体 (body) の中でのみ有効です。"

#: ../../library/ast.rst:1912
msgid ""
"When a string is parsed by :func:`ast.parse`, operator nodes (subclasses of :"
"class:`ast.operator`, :class:`ast.unaryop`, :class:`ast.cmpop`, :class:`ast."
"boolop` and :class:`ast.expr_context`) on the returned tree will be "
"singletons. Changes to one will be reflected in all other occurrences of the "
"same value (e.g. :class:`ast.Add`)."
msgstr ""
"文字列が :func:`ast.parse` によってパースされたとき、戻り値のツリーに含まれる"
"演算子ノード (:class:`ast.operator`, :class:`ast.unaryop`, :class:`ast."
"cmpop`, :class:`ast.boolop` および :class:`ast.expr_context` のサブクラス) は"
"シングルトンです。したがっていずれかの演算子ノードを変更すると、その変更は他"
"の全ての同じ値 (たとえば :class:`ast.Add` ノードを変更した場合はその他全て"
"の :class:`ast.Add` ノード) に反映されます。"

#: ../../library/ast.rst:1920
msgid ":mod:`ast` Helpers"
msgstr ":mod:`ast` ヘルパー"

#: ../../library/ast.rst:1922
msgid ""
"Apart from the node classes, the :mod:`ast` module defines these utility "
"functions and classes for traversing abstract syntax trees:"
msgstr ""
"ノード・クラスの他に、 :mod:`ast` モジュールは以下のような抽象構文木をトラ"
"バースするためのユーティリティ関数やクラスも定義しています:"

#: ../../library/ast.rst:1927
msgid ""
"Parse the source into an AST node.  Equivalent to ``compile(source, "
"filename, mode, ast.PyCF_ONLY_AST)``."
msgstr ""
"*source* を解析して AST ノードにします。``compile(source, filename, mode, "
"ast.PyCF_ONLY_AST)`` と等価です。"

#: ../../library/ast.rst:1930
msgid ""
"If ``type_comments=True`` is given, the parser is modified to check and "
"return type comments as specified by :pep:`484` and :pep:`526`. This is "
"equivalent to adding :data:`ast.PyCF_TYPE_COMMENTS` to the flags passed to :"
"func:`compile()`.  This will report syntax errors for misplaced type "
"comments.  Without this flag, type comments will be ignored, and the "
"``type_comment`` field on selected AST nodes will always be ``None``.  In "
"addition, the locations of ``# type: ignore`` comments will be returned as "
"the ``type_ignores`` attribute of :class:`Module` (otherwise it is always an "
"empty list)."
msgstr ""
"``type_comments=True`` が与えられると、パーサは :pep:`484` および :pep:`526` "
"で規定された型コメントをチェックし、返すように修正されます。これは :data:"
"`ast.PyCF_TYPE_COMMENTS` を追加したフラグを :func:`compile()` に渡すことと等"
"価です。パーサは不適切な場所に配置された型コメントに対してシンタックスエラー"
"をレポートします。 このフラグがない場合、型コメントは無視されて AST ノードの "
"``type_comment`` フィールドは常に ``None`` になります。さらに、 ``# type: "
"ignore`` コメントの位置は :class:`Module` の ``type_ignores`` 属性として返さ"
"れます (それ以外の場合は常に空のリストになります)。"

#: ../../library/ast.rst:1940
msgid ""
"In addition, if ``mode`` is ``'func_type'``, the input syntax is modified to "
"correspond to :pep:`484` \"signature type comments\", e.g. ``(str, int) -> "
"List[str]``."
msgstr ""
"さらに ``mode`` が ``'func_type'`` の場合、入力構文は、たとえば ``(str, int) "
"-> List[str]`` のような :pep:`484` の \"シグネチャ型コメント (signature type "
"comments)\" に対応するように修正されます。"

#: ../../library/ast.rst:1944
msgid ""
"Also, setting ``feature_version`` to a tuple ``(major, minor)`` will attempt "
"to parse using that Python version's grammar. Currently ``major`` must equal "
"to ``3``.  For example, setting ``feature_version=(3, 4)`` will allow the "
"use of ``async`` and ``await`` as variable names.  The lowest supported "
"version is ``(3, 4)``; the highest is ``sys.version_info[0:2]``."
msgstr ""
"また、 ``feature_version`` を ``(major, minor)`` のタプルに設定すると、パーサ"
"は指定された Python バージョンの文法で構文解析を試みます。今のところ "
"``major`` は ``3`` でなければなりません。たとえば、 ``feature_version=(3, "
"4)`` と設定すると ``async`` と ``await`` を変数名として使うことが可能になりま"
"す。 サポートされている最低のバージョンは ``(3, 4)``; 最高のバージョンは "
"``sys.version_info[0:2]`` です。"

#: ../../library/ast.rst:1951
msgid ""
"If source contains a null character ('\\0'), :exc:`ValueError` is raised."
msgstr ""

#: ../../library/ast.rst:1954
msgid ""
"Note that successfully parsing source code into an AST object doesn't "
"guarantee that the source code provided is valid Python code that can be "
"executed as the compilation step can raise further :exc:`SyntaxError` "
"exceptions. For instance, the source ``return 42`` generates a valid AST "
"node for a return statement, but it cannot be compiled alone (it needs to be "
"inside a function node)."
msgstr ""

#: ../../library/ast.rst:1961
msgid ""
"In particular, :func:`ast.parse` won't do any scoping checks, which the "
"compilation step does."
msgstr ""

#: ../../library/ast.rst:1965
msgid ""
"It is possible to crash the Python interpreter with a sufficiently large/"
"complex string due to stack depth limitations in Python's AST compiler."
msgstr ""
"十分に大きい文字列や複雑な文字列によって Python の抽象構文木コンパイラのス"
"タックの深さの限界を越えることで、 Python インタプリタをクラッシュさせること"
"ができます。"

#: ../../library/ast.rst:1969
msgid "Added ``type_comments``, ``mode='func_type'`` and ``feature_version``."
msgstr ""
"``type_comments``、``mode='func_type'``、``feature_version``が追加されまし"
"た。"

#: ../../library/ast.rst:1975
msgid ""
"Unparse an :class:`ast.AST` object and generate a string with code that "
"would produce an equivalent :class:`ast.AST` object if parsed back with :"
"func:`ast.parse`."
msgstr ""
":class:`ast.AST` オブジェクトを逆に構文解析して、 :func:`ast.parse` が元の :"
"class:`ast.AST` と等価なオブジェクトを生成できるような文字列を生成します。"

#: ../../library/ast.rst:1980
msgid ""
"The produced code string will not necessarily be equal to the original code "
"that generated the :class:`ast.AST` object (without any compiler "
"optimizations, such as constant tuples/frozensets)."
msgstr ""
"生成されたコード文字列は、生成元のコードである :class:`ast.AST` オブジェクト"
"と必ずしも等価であるとは限りません (定数タプルや frozenset などに対するコンパ"
"イラ最適化なしのコードです)。"

#: ../../library/ast.rst:1985
msgid ""
"Trying to unparse a highly complex expression would result with :exc:"
"`RecursionError`."
msgstr ""
"非常に複雑な式を逆構文解析すると :exc:`RecursionError` となることがあります。"

#: ../../library/ast.rst:1993
msgid ""
"Evaluate an expression node or a string containing only a Python literal or "
"container display.  The string or node provided may only consist of the "
"following Python literal structures: strings, bytes, numbers, tuples, lists, "
"dicts, sets, booleans, ``None`` and ``Ellipsis``."
msgstr ""

#: ../../library/ast.rst:1998
msgid ""
"This can be used for evaluating strings containing Python values without the "
"need to parse the values oneself.  It is not capable of evaluating "
"arbitrarily complex expressions, for example involving operators or indexing."
msgstr ""

#: ../../library/ast.rst:2003
msgid ""
"This function had been documented as \"safe\" in the past without defining "
"what that meant. That was misleading. This is specifically designed not to "
"execute Python code, unlike the more general :func:`eval`. There is no "
"namespace, no name lookups, or ability to call out. But it is not free from "
"attack: A relatively small input can lead to memory exhaustion or to C stack "
"exhaustion, crashing the process. There is also the possibility for "
"excessive CPU consumption denial of service on some inputs. Calling it on "
"untrusted data is thus not recommended."
msgstr ""

#: ../../library/ast.rst:2013
msgid ""
"It is possible to crash the Python interpreter due to stack depth "
"limitations in Python's AST compiler."
msgstr ""

#: ../../library/ast.rst:2016
msgid ""
"It can raise :exc:`ValueError`, :exc:`TypeError`, :exc:`SyntaxError`, :exc:"
"`MemoryError` and :exc:`RecursionError` depending on the malformed input."
msgstr ""

#: ../../library/ast.rst:2020
msgid "Now allows bytes and set literals."
msgstr "バイト列リテラルと集合リテラルが受け取れるようになりました。"

#: ../../library/ast.rst:2023
msgid "Now supports creating empty sets with ``'set()'``."
msgstr "``'set()'`` による空の集合の生成をサポートするようになりました。"

#: ../../library/ast.rst:2026
msgid "For string inputs, leading spaces and tabs are now stripped."
msgstr ""

#: ../../library/ast.rst:2032
msgid ""
"Return the docstring of the given *node* (which must be a :class:"
"`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef`, or :class:"
"`Module` node), or ``None`` if it has no docstring. If *clean* is true, "
"clean up the docstring's indentation with :func:`inspect.cleandoc`."
msgstr ""
"与えられた *node* (これは :class:`FunctionDef`, :class:`AsyncFunctionDef`, :"
"class:`ClassDef`, :class:`Module` のいずれかのノードでなければなりません) の"
"ドキュメント文字列を返します。もしドキュメント文字列が無ければ ``None`` を返"
"します。 *clean* が真ならば、ドキュメント文字列のインデントを :func:`inspect."
"cleandoc` を用いて一掃します。"

#: ../../library/ast.rst:2038
msgid ":class:`AsyncFunctionDef` is now supported."
msgstr ":class:`AsyncFunctionDef` がサポートされました。"

#: ../../library/ast.rst:2044
msgid ""
"Get source code segment of the *source* that generated *node*. If some "
"location information (:attr:`lineno`, :attr:`end_lineno`, :attr:"
"`col_offset`, or :attr:`end_col_offset`) is missing, return ``None``."
msgstr ""
"*source* のうちで *node* を生成したソースコードのセグメントを取得します。位置"
"情報  (:attr:`lineno`, :attr:`end_lineno`, :attr:`col_offset`, または :attr:"
"`end_col_offset`) が欠けている場合 ``None`` を返します。"

#: ../../library/ast.rst:2048
msgid ""
"If *padded* is ``True``, the first line of a multi-line statement will be "
"padded with spaces to match its original position."
msgstr ""
"*padded* が ``True`` の場合、複数行にわたる文の最初の行が元の位置に一致するよ"
"うに空白文字でパディングされます。"

#: ../../library/ast.rst:2056
msgid ""
"When you compile a node tree with :func:`compile`, the compiler expects :"
"attr:`lineno` and :attr:`col_offset` attributes for every node that supports "
"them.  This is rather tedious to fill in for generated nodes, so this helper "
"adds these attributes recursively where not already set, by setting them to "
"the values of the parent node.  It works recursively starting at *node*."
msgstr ""
":func:`compile` はノード・ツリーをコンパイルする際、 :attr:`lineno` と :attr:"
"`col_offset` 両属性をサポートする全てのノードに対しそれが存在するものと想定し"
"ます。生成されたノードに対しこれらを埋めて回るのはどちらかというと退屈な作業"
"なので、このヘルパーが再帰的に二つの属性がセットされていないものに親ノードと"
"同じ値をセットしていきます。再帰の出発点が *node* です。"

#: ../../library/ast.rst:2065
msgid ""
"Increment the line number and end line number of each node in the tree "
"starting at *node* by *n*. This is useful to \"move code\" to a different "
"location in a file."
msgstr ""
"*node* で始まるツリー内の各ノードの行番号と終了行番号を *n* ずつ増やします。"
"これはファイルの中で別の場所に \"コードを移動する\" ときに便利です。"

#: ../../library/ast.rst:2072
msgid ""
"Copy source location (:attr:`lineno`, :attr:`col_offset`, :attr:"
"`end_lineno`, and :attr:`end_col_offset`) from *old_node* to *new_node* if "
"possible, and return *new_node*."
msgstr ""
"ソースの場所 (:attr:`lineno`, :attr:`col_offset`, :attr:`end_lineno`, およ"
"び :attr:`end_col_offset`) を *old_node* から *new_node* に可能ならばコピー"
"し、 *new_node* を返します。"

#: ../../library/ast.rst:2079
msgid ""
"Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields`` "
"that is present on *node*."
msgstr ""
"*node* にある ``node._fields`` のそれぞれのフィールドを ``(フィールド名, "
"値)`` のタプルとして yield します。"

#: ../../library/ast.rst:2085
msgid ""
"Yield all direct child nodes of *node*, that is, all fields that are nodes "
"and all items of fields that are lists of nodes."
msgstr ""
"*node* の直接の子ノード全てを yield します。すなわち、yield されるのは、ノー"
"ドであるような全てのフィールドおよびノードのリストであるようなフィールドの全"
"てのアイテムです。"

#: ../../library/ast.rst:2091
msgid ""
"Recursively yield all descendant nodes in the tree starting at *node* "
"(including *node* itself), in no specified order.  This is useful if you "
"only want to modify nodes in place and don't care about the context."
msgstr ""
"*node* の全ての子孫ノード(*node* 自体を含む)を再帰的に yield します。順番は決"
"められていません。この関数はノードをその場で変更するだけで文脈を気にしないよ"
"うな場合に便利です。"

#: ../../library/ast.rst:2098
msgid ""
"A node visitor base class that walks the abstract syntax tree and calls a "
"visitor function for every node found.  This function may return a value "
"which is forwarded by the :meth:`visit` method."
msgstr ""
"抽象構文木を渡り歩いてビジター関数を見つけたノードごとに呼び出すノード・ビジ"
"ターの基底クラスです。この関数は :meth:`visit` メソッドに送られる値を返しても"
"かまいません。"

#: ../../library/ast.rst:2102
msgid ""
"This class is meant to be subclassed, with the subclass adding visitor "
"methods."
msgstr ""
"このクラスはビジター・メソッドを付け加えたサブクラスを派生させることを意図し"
"ています。"

#: ../../library/ast.rst:2107
msgid ""
"Visit a node.  The default implementation calls the method called :samp:"
"`self.visit_{classname}` where *classname* is the name of the node class, "
"or :meth:`generic_visit` if that method doesn't exist."
msgstr ""
"ノードを訪れます。デフォルトの実装では :samp:`self.visit_{classname}` という"
"メソッド (ここで *classname* はノードのクラス名です) を呼び出すか、そのメソッ"
"ドがなければ :meth:`generic_visit` を呼び出します。"

#: ../../library/ast.rst:2113
msgid "This visitor calls :meth:`visit` on all children of the node."
msgstr "このビジターはノードの全ての子について :meth:`visit` を呼び出します。"

#: ../../library/ast.rst:2115
msgid ""
"Note that child nodes of nodes that have a custom visitor method won't be "
"visited unless the visitor calls :meth:`generic_visit` or visits them itself."
msgstr ""
"注意して欲しいのは、専用のビジター・メソッドを具えたノードの子ノードは、この"
"ビジターが :meth:`generic_visit` を呼び出すかそれ自身で子ノードを訪れない限り"
"訪れられないということです。"

#: ../../library/ast.rst:2119
msgid ""
"Don't use the :class:`NodeVisitor` if you want to apply changes to nodes "
"during traversal.  For this a special visitor exists (:class:"
"`NodeTransformer`) that allows modifications."
msgstr ""
"トラバースの途中でノードを変化させたいならば :class:`NodeVisitor` を使っては"
"いけません。そうした目的のために変更を許す特別なビジター (:class:"
"`NodeTransformer`) があります。"

#: ../../library/ast.rst:2125
msgid ""
"Methods :meth:`visit_Num`, :meth:`visit_Str`, :meth:`visit_Bytes`, :meth:"
"`visit_NameConstant` and :meth:`visit_Ellipsis` are deprecated now and will "
"not be called in future Python versions.  Add the :meth:`visit_Constant` "
"method to handle all constant nodes."
msgstr ""
":meth:`visit_Num`, :meth:`visit_Str`, :meth:`visit_Bytes`, :meth:"
"`visit_NameConstant` および :meth:`visit_Ellipsis` の各メソッドは非推奨です。"
"また将来の Python バージョンでは呼び出されなくなります。全ての定数ノードを扱"
"うには :meth:`visit_Constant` を追加してください。"

#: ../../library/ast.rst:2133
msgid ""
"A :class:`NodeVisitor` subclass that walks the abstract syntax tree and "
"allows modification of nodes."
msgstr ""
":class:`NodeVisitor` のサブクラスで抽象構文木を渡り歩きながらノードを変更する"
"ことを許すものです。"

#: ../../library/ast.rst:2136
msgid ""
"The :class:`NodeTransformer` will walk the AST and use the return value of "
"the visitor methods to replace or remove the old node.  If the return value "
"of the visitor method is ``None``, the node will be removed from its "
"location, otherwise it is replaced with the return value.  The return value "
"may be the original node in which case no replacement takes place."
msgstr ""
":class:`NodeTransformer` は抽象構文木(AST)を渡り歩き、ビジター・メソッドの戻"
"り値を使って古いノードを置き換えたり削除したりします。ビジター・メソッドの戻"
"り値が ``None`` ならば、ノードはその場から取り去られ、そうでなければ戻り値で"
"置き換えられます。置き換えない場合は戻り値が元のノードそのものであってもかま"
"いません。"

#: ../../library/ast.rst:2142
msgid ""
"Here is an example transformer that rewrites all occurrences of name lookups "
"(``foo``) to ``data['foo']``::"
msgstr ""
"それでは例を示しましょう。Name (たとえば ``foo``) を見つけるたび全て "
"``data['foo']`` に書き換える変換器 (transformer) です::"

#: ../../library/ast.rst:2154
msgid ""
"Keep in mind that if the node you're operating on has child nodes you must "
"either transform the child nodes yourself or call the :meth:`generic_visit` "
"method for the node first."
msgstr ""
"操作しようとしているノードが子ノードを持つならば、その子ノードの変形も自分で"
"行うか、またはそのノードに対し最初に :meth:`generic_visit` メソッドを呼び出す"
"か、それを行うのはあなたの責任だということを肝に銘じましょう。"

#: ../../library/ast.rst:2158
msgid ""
"For nodes that were part of a collection of statements (that applies to all "
"statement nodes), the visitor may also return a list of nodes rather than "
"just a single node."
msgstr ""
"文のコレクションであるようなノード (全ての文のノードが当てはまります) に対し"
"て、このビジターは単独のノードではなくノードのリストを返すかもしれません。"

#: ../../library/ast.rst:2162
msgid ""
"If :class:`NodeTransformer` introduces new nodes (that weren't part of "
"original tree) without giving them location information (such as :attr:"
"`lineno`), :func:`fix_missing_locations` should be called with the new sub-"
"tree to recalculate the location information::"
msgstr ""
":class:`NodeTransformer` が(たとえば、 :attr:`lineno` のような)位置情報を与え"
"ずに(元の木の一部ではなく)新しいノードを導入する場合、 :func:"
"`fix_missing_locations` を新しいサブツリーで呼び出して、位置情報を再計算する"
"必要があります。"

#: ../../library/ast.rst:2170
msgid "Usually you use the transformer like this::"
msgstr "たいてい、変換器の使い方は次のようになります::"

#: ../../library/ast.rst:2177
msgid ""
"Return a formatted dump of the tree in *node*.  This is mainly useful for "
"debugging purposes.  If *annotate_fields* is true (by default), the returned "
"string will show the names and the values for fields. If *annotate_fields* "
"is false, the result string will be more compact by omitting unambiguous "
"field names.  Attributes such as line numbers and column offsets are not "
"dumped by default.  If this is wanted, *include_attributes* can be set to "
"true."
msgstr ""
"*node* 内のツリーのフォーマットされたダンプを返します。主な使い道はデバッグで"
"す。 *annotate_fields* が true の場合 (デフォルト)、返される文字列はフィール"
"ドの名前と値を示します。 *annotate_fields* が false の場合、あいまいさのない"
"フィールド名を省略することにより、結果文字列はよりコンパクトになります。行番"
"号や列オフセットのような属性はデフォルトではダンプされません。これが必要であ"
"れば、 *include_attributes* を true にすると表示できます。"

#: ../../library/ast.rst:2185
msgid ""
"If *indent* is a non-negative integer or string, then the tree will be "
"pretty-printed with that indent level.  An indent level of 0, negative, or "
"``\"\"`` will only insert newlines.  ``None`` (the default) selects the "
"single line representation. Using a positive integer indent indents that "
"many spaces per level.  If *indent* is a string (such as ``\"\\t\"``), that "
"string is used to indent each level."
msgstr ""
"*indent* が非負の整数または文字列の場合、ツリーは指定されたインデントレベルで"
"整形されて出力されます (pretty-printed)。インデントレベルがゼロ、負の数、また"
"は ``\"\"`` の場合は改行だけを挿入します。 ``None`` (デフォルト値) は単一行で"
"の表記になります。正の整数を指定すると各インデントレベルでその数だけの空白で"
"インデントされます。 *indent* が文字列 (``\"\\t\"`` など) の場合、その文字列"
"が各レベルのインデントに使われます。"

#: ../../library/ast.rst:2192
msgid "Added the *indent* option."
msgstr "*indent* オプションを追加しました。"

#: ../../library/ast.rst:2199
msgid "Compiler Flags"
msgstr "コンパイラフラグ"

#: ../../library/ast.rst:2201
msgid ""
"The following flags may be passed to :func:`compile` in order to change "
"effects on the compilation of a program:"
msgstr ""
"以下のフラグはプログラムのコンパイルにおける効果を変更するために :func:"
"`compile` に渡すことができます:"

#: ../../library/ast.rst:2206
msgid ""
"Enables support for top-level ``await``, ``async for``, ``async with`` and "
"async comprehensions."
msgstr ""
"トップレベルの ``await``, ``async for``, ``async with`` および async 内包表記"
"のサポートを有効化します。"

#: ../../library/ast.rst:2213
msgid ""
"Generates and returns an abstract syntax tree instead of returning a "
"compiled code object."
msgstr ""
"コンパイルされたコードオブジェクトの代わりに抽象構文木を生成して返します。"

#: ../../library/ast.rst:2218
msgid ""
"Enables support for :pep:`484` and :pep:`526` style type comments (``# type: "
"<type>``, ``# type: ignore <stuff>``)."
msgstr ""
":pep:`484` および :pep:`526` 形式の型コメント (``# type: <type>``, ``# type: "
"ignore <stuff>``) のサポートを有効化します。"

#: ../../library/ast.rst:2227
msgid "Command-Line Usage"
msgstr "コマンドラインからの使用"

#: ../../library/ast.rst:2231
msgid ""
"The :mod:`ast` module can be executed as a script from the command line. It "
"is as simple as:"
msgstr ""
":mod:`ast` モジュールはコマンドラインからスクリプトとして実行することができま"
"す。実行方法は単純です:"

#: ../../library/ast.rst:2238
msgid "The following options are accepted:"
msgstr "以下のオプションが使用できます:"

#: ../../library/ast.rst:2244
msgid "Show the help message and exit."
msgstr "ヘルプメッセージを表示して終了します。"

#: ../../library/ast.rst:2249
msgid ""
"Specify what kind of code must be compiled, like the *mode* argument in :"
"func:`parse`."
msgstr ""
":func:`parse` 関数の *mode* 引数と同様、コンパイルするコードの種類を指定しま"
"す。"

#: ../../library/ast.rst:2254
msgid "Don't parse type comments."
msgstr "型コメントをパースしません。"

#: ../../library/ast.rst:2258
msgid "Include attributes such as line numbers and column offsets."
msgstr "行番号や列オフセットなどの属性を含めます。"

#: ../../library/ast.rst:2263
msgid "Indentation of nodes in AST (number of spaces)."
msgstr "AST におけるノードのインデント (空白の数) です。"

#: ../../library/ast.rst:2265
msgid ""
"If :file:`infile` is specified its contents are parsed to AST and dumped to "
"stdout.  Otherwise, the content is read from stdin."
msgstr ""
":file:`infile` を指定するとその内容が AST にパースされて標準出力に出力されま"
"す。そうでない場合は標準入力から入力を読み込みます。"

#: ../../library/ast.rst:2271
msgid ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, an external "
"documentation resource, has good details on working with Python ASTs."
msgstr ""
"外部ドキュメント `Green Tree Snakes <https://greentreesnakes.readthedocs.io/"
">`_ には Python AST についての詳細が書かれています。"

#: ../../library/ast.rst:2274
msgid ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ "
"annotates Python ASTs with the positions of tokens and text in the source "
"code that generated them. This is helpful for tools that make source code "
"transformations."
msgstr ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ は "
"Python AST を、生成元のソースコードのトークン位置やテキストで注解します。これ"
"はソースコード変換を行うツールで有用です。 "

#: ../../library/ast.rst:2279
msgid ""
"`leoAst.py <https://leoeditor.com/appendices.html#leoast-py>`_ unifies the "
"token-based and parse-tree-based views of python programs by inserting two-"
"way links between tokens and ast nodes."
msgstr ""

#: ../../library/ast.rst:2283
msgid ""
"`LibCST <https://libcst.readthedocs.io/>`_ parses code as a Concrete Syntax "
"Tree that looks like an ast tree and keeps all formatting details. It's "
"useful for building automated refactoring (codemod) applications and linters."
msgstr ""
"`LibCST <https://libcst.readthedocs.io/>`_ はコードを ast ツリーに似た構文木 "
"(Concrete Syntax Tree) にパースし、かつ全ての書式設定の詳細を保持します。これ"
"は自動リファクタリングアプリケーション (codemod) やリンタを作成する際に有用で"
"す。"

#: ../../library/ast.rst:2288
msgid ""
"`Parso <https://parso.readthedocs.io>`_ is a Python parser that supports "
"error recovery and round-trip parsing for different Python versions (in "
"multiple Python versions). Parso is also able to list multiple syntax errors "
"in your python file."
msgstr ""
"`Parso <https://parso.readthedocs.io>`_ はエラーリカバリや異なる Python バー"
"ジョン (複数の Python バージョン) での復元可能なパース (round-trip parsing) "
"をサポートします。また、 Parso は Python ファイル内の複数の文法エラーをリスト"
"することもできます。"
