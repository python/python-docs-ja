# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-21 01:52+0900\n"
"PO-Revision-Date: 2017-09-22 17:56+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/math.rst:3
msgid ":mod:`math` --- Mathematical functions"
msgstr ":mod:`math` --- æ•°å­¦é–¢æ•°"

#: ../../library/math.rst:12
msgid ""
"This module is always available.  It provides access to the mathematical "
"functions defined by the C standard."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã„ã¤ã§ã‚‚åˆ©ç”¨ã§ãã¾ã™ã€‚æ¨™æº– C ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹æ•°å­¦é–¢æ•°ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/math.rst:15
msgid ""
"These functions cannot be used with complex numbers; use the functions of "
"the same name from the :mod:`cmath` module if you require support for "
"complex numbers.  The distinction between functions which support complex "
"numbers and those which don't is made since most users do not want to learn "
"quite as much mathematics as required to understand complex numbers.  "
"Receiving an exception instead of a complex result allows earlier detection "
"of the unexpected complex number used as a parameter, so that the programmer"
" can determine how and why it was generated in the first place."
msgstr "ã“ã‚Œã‚‰ã®é–¢æ•°ã§è¤‡ç´ æ•°ã‚’ä½¿ã†ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚è¤‡ç´ æ•°ã«å¯¾å¿œã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãªã‚‰ã°ã€ :mod:`cmath` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚ã‚‹åŒã˜åå‰ã®é–¢æ•°ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚ã»ã¨ã‚“ã©ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯è¤‡ç´ æ•°ã‚’ç†è§£ã™ã‚‹ã®ã«å¿…è¦ãªã ã‘ã®æ•°å­¦ã‚’å‹‰å¼·ã—ãŸããªã„ã®ã§ã€è¤‡ç´ æ•°ã«å¯¾å¿œã—ãŸé–¢æ•°ã¨å¯¾å¿œã—ã¦ã„ãªã„é–¢æ•°ã®åŒºåˆ¥ãŒã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®é–¢æ•°ã§ã¯è¤‡ç´ æ•°ãŒåˆ©ç”¨ã§ããªã„ãŸã‚ã€å¼•æ•°ã«è¤‡ç´ æ•°ã‚’æ¸¡ã•ã‚Œã‚‹ã¨ã€è¤‡ç´ æ•°ã®çµæœãŒè¿”ã‚‹ã®ã§ã¯ãªãä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã™ã€‚ãã®çµæœã€ã©ã†ã„ã£ãŸç†ç”±ã§ä¾‹å¤–ãŒé€å‡ºã•ã‚ŒãŸã‹ã«æ—©ã„æ®µéšã§æ°—ã¥ãäº‹ãŒã§ãã¾ã™ã€‚"

#: ../../library/math.rst:24
msgid ""
"The following functions are provided by this module.  Except when explicitly"
" noted otherwise, all return values are floats."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯æ¬¡ã®é–¢æ•°ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚æ˜ç¤ºçš„ãªæ³¨è¨˜ã®ãªã„é™ã‚Šã€æˆ»ã‚Šå€¤ã¯å…¨ã¦æµ®å‹•å°æ•°ç‚¹æ•°ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/math.rst:29
msgid "Number-theoretic and representation functions"
msgstr "æ•°è«–ãŠã‚ˆã³æ•°è¡¨ç¾ã«ã¾ã¤ã‚ã‚‹é–¢æ•°ã§ã™"

#: ../../library/math.rst:33
msgid ""
"Return the ceiling of *x* as a float, the smallest integer value greater "
"than or equal to *x*."
msgstr "*x* ã®å¤©äº•å€¤ (ceil)ã€ã™ãªã‚ã¡ *x* ä»¥ä¸Šã®æœ€ã‚‚å°ã•ã„æ•´æ•°ã‚’ float å‹ã§è¿”ã—ã¾ã™ã€‚"

#: ../../library/math.rst:39
msgid ""
"Return *x* with the sign of *y*.  On a platform that supports signed zeros, "
"``copysign(1.0, -0.0)`` returns *-1.0*."
msgstr "*x* ã« *y* ã®ç¬¦å·ã‚’ä»˜ã‘ã¦è¿”ã—ã¾ã™ã€‚ç¬¦å·ä»˜ãã®ã‚¼ãƒ­ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ã€ ``copysign(1.0, -0.0)`` ã¯ *-1.0* ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/math.rst:47
msgid "Return the absolute value of *x*."
msgstr "*x* ã®çµ¶å¯¾å€¤ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/math.rst:52
msgid ""
"Return *x* factorial.  Raises :exc:`ValueError` if *x* is not integral or is"
" negative."
msgstr "*x* ã®éšä¹—ã‚’è¿”ã—ã¾ã™ã€‚ *x* ãŒæ•´æ•°å€¤ã§ãªã‹ã£ãŸã‚Šè² ã§ã‚ã£ãŸã‚Šã™ã‚‹ã¨ãã¯ã€ :exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/math.rst:60
msgid ""
"Return the floor of *x* as a float, the largest integer value less than or "
"equal to *x*."
msgstr "*x* ã®åºŠå€¤ (floor)ã€ã™ãªã‚ã¡ *x* ä»¥ä¸‹ã®æœ€ã‚‚å¤§ãã„æ•´æ•°ã‚’ floatå‹ã§è¿”ã—ã¾ã™ã€‚"

#: ../../library/math.rst:66
msgid ""
"Return ``fmod(x, y)``, as defined by the platform C library. Note that the "
"Python expression ``x % y`` may not return the same result.  The intent of "
"the C standard is that ``fmod(x, y)`` be exactly (mathematically; to "
"infinite precision) equal to ``x - n*y`` for some integer *n* such that the "
"result has the same sign as *x* and magnitude less than ``abs(y)``.  "
"Python's ``x % y`` returns a result with the sign of *y* instead, and may "
"not be exactly computable for float arguments. For example, ``fmod(-1e-100, "
"1e100)`` is ``-1e-100``, but the result of Python's ``-1e-100 % 1e100`` is "
"``1e100-1e-100``, which cannot be represented exactly as a float, and rounds"
" to the surprising ``1e100``.  For this reason, function :func:`fmod` is "
"generally preferred when working with floats, while Python's ``x % y`` is "
"preferred when working with integers."
msgstr "ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã® C ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ ``fmod(x, y)`` ã‚’è¿”ã—ã¾ã™ã€‚ Python ã® ``x % y`` ã¨ã„ã†å¼ã¯å¿…ãšã—ã‚‚åŒã˜çµæœã‚’è¿”ã•ãªã„ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ C æ¨™æº–ã®è¦æ±‚ã§ã¯ã€ :c:func:`fmod` ã¯é™¤ç®—ã®çµæœãŒ *x* ã¨åŒã˜ç¬¦å·ã«ãªã‚Šã€å¤§ãã•ãŒ ``abs(y)`` ã‚ˆã‚Šå°ã•ããªã‚‹ã‚ˆã†ãªæ•´æ•° *n* ã«ã¤ã„ã¦ã¯ ``fmod(x, y)`` ãŒå³å¯†ã« (æ•°å­¦çš„ã«ã€ã¤ã¾ã‚Šé™ã‚Šãªãé«˜ã„ç²¾åº¦ã§) ``x - n*y``  ã¨ç­‰ä¾¡ã§ã‚ã‚‹ã‚ˆã†æ±‚ã‚ã¦ã„ã¾ã™ã€‚ Python ã® ``x % y`` ã¯ã€ *y* ã¨åŒã˜ç¬¦å·ã®çµæœã‚’è¿”ã—ã€æµ®å‹•å°æ•°ç‚¹ã®å¼•æ•°ã«å¯¾ã—ã¦å³å¯†ãªè§£ã‚’å‡ºã›ãªã„ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€ ``fmod(-1e-100, 1e100)`` ã¯ ``-1e-100`` ã§ã™ãŒã€ Python ã® ``-1e-100 % 1e100`` ã¯ ``1e100-1e-100`` ã«ãªã‚Šã€æµ®å‹•å°æ•°ç‚¹å‹ã§å³å¯†ã«è¡¨ç¾ã§ããšã€ã‚„ã‚„ã“ã—ã„ã“ã¨ã« ``1e100`` ã«ä¸¸ã‚ã‚‰ã‚Œã¾ã™ã€‚ã“ã®ãŸã‚ã€ä¸€èˆ¬ã«ã¯æµ®å‹•å°æ•°ç‚¹ã®å ´åˆã«ã¯é–¢æ•° :func:`fmod` ã€æ•´æ•°ã®å ´åˆã«ã¯ ``x % y`` ã‚’ä½¿ã†æ–¹ãŒã‚ˆã„ã§ã—ã‚‡ã†ã€‚"

#: ../../library/math.rst:81
msgid ""
"Return the mantissa and exponent of *x* as the pair ``(m, e)``.  *m* is a "
"float and *e* is an integer such that ``x == m * 2**e`` exactly. If *x* is "
"zero, returns ``(0.0, 0)``, otherwise ``0.5 <= abs(m) < 1``.  This is used "
"to \"pick apart\" the internal representation of a float in a portable way."
msgstr "*x* ã®ä»®æ•°ã¨æŒ‡æ•°ã‚’ ``(m, e)`` ã®ãƒšã‚¢ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚*m* ã¯floatå‹ã§ã€*e* ã¯å³å¯†ã« ``x == m * 2**e`` ã§ã‚ã‚‹ã‚ˆã†ãªæ•´æ•°å‹ã§ã™ã€‚*x* ãŒã‚¼ãƒ­ã®å ´åˆã¯ã€``(0.0, 0)`` ã‚’è¿”ã—ã€ãã‚Œä»¥å¤–ã®å ´åˆã¯ã€``0.5 <= abs(m) < 1`` ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯æµ®å‹•å°æ•°ç‚¹å‹ã®å†…éƒ¨è¡¨ç¾ã‚’å¯æ¬æ€§ã‚’ä¿ã£ãŸã¾ã¾ \"åˆ†è§£ (pick apart)\" ã™ã‚‹ãŸã‚ã§ã™ã€‚"

#: ../../library/math.rst:89
msgid ""
"Return an accurate floating point sum of values in the iterable.  Avoids "
"loss of precision by tracking multiple intermediate partial sums::"
msgstr "iterable ä¸­ã®å€¤ã®æµ®å‹•å°æ•°ç‚¹æ•°ã®æ­£ç¢ºãªå’Œã‚’è¿”ã—ã¾ã™ã€‚è¤‡æ•°ã®éƒ¨åˆ†å’Œã‚’è¿½è·¡ã™ã‚‹ã“ã¨ã§æ¡è½ã¡ã‚’é˜²ãã¾ã™::"

#: ../../library/math.rst:97
msgid ""
"The algorithm's accuracy depends on IEEE-754 arithmetic guarantees and the "
"typical case where the rounding mode is half-even.  On some non-Windows "
"builds, the underlying C library uses extended precision addition and may "
"occasionally double-round an intermediate sum causing it to be off in its "
"least significant bit."
msgstr "ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®æ­£ç¢ºæ€§ã¯ IEEE-754 æ¼”ç®—ã®ä¿è¨¼ã¨ä¸¸ã‚ãƒ¢ãƒ¼ãƒ‰ãŒå¶æ•°ä¸¸ã‚ (half-even) ã§ã‚ã‚‹å…¸å‹çš„ãªå ´åˆã«ä¾å­˜ã—ã¾ã™ã€‚Windowsä»¥å¤–ã®å¹¾ã¤ã‹ã®ãƒ“ãƒ«ãƒ‰ã§ã¯ã€ä¾å­˜ã™ã‚‹Cãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã€æ‹¡å¼µç²¾åº¦ã®åŠ ç®—ã¨æ™‚ã€…æ™‚ã€…åˆè¨ˆã®ä¸­é–“å€¤ã‚’ double å‹ã¸ä¸¸ã‚ã‚’è¡Œã£ã¦ã—ã¾ã„ã€æœ€ä¸‹ä½ãƒ“ãƒƒãƒˆã®æ¶ˆå¤±ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/math.rst:103
msgid ""
"For further discussion and two alternative approaches, see the `ASPN "
"cookbook recipes for accurate floating point summation "
"<https://code.activestate.com/recipes/393090/>`_\\."
msgstr "ã‚ˆã‚Šè©³ç´°ãªè­°è«–ã¨ä»£æ›¿ã¨ãªã‚‹äºŒã¤ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã«ã¤ã„ã¦ã¯ã€`ASPN cookbook recipes for accurate floating point summation <https://code.activestate.com/recipes/393090/>`_ ã‚’ã”è¦§ä¸‹ã•ã„ã€‚"

#: ../../library/math.rst:112
msgid "Check if the float *x* is positive or negative infinity."
msgstr "æµ®å‹•å°æ•°ç‚¹æ•° *x* ãŒæ­£ã¾ãŸã¯è² ã®ç„¡é™å¤§ã§ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚"

#: ../../library/math.rst:119
msgid ""
"Check if the float *x* is a NaN (not a number).  For more information on "
"NaNs, see the IEEE 754 standards."
msgstr "æµ®å‹•å°æ•°ç‚¹æ•° *x* ãŒ NaN (not a number) ã§ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚ NaN ã«ã¤ã„ã¦ã®è©³ã—ã„æƒ…å ±ã¯ã€ IEEE 754 æ¨™æº–ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/math.rst:127
msgid ""
"Return ``x * (2**i)``.  This is essentially the inverse of function "
":func:`frexp`."
msgstr "``x * (2**i)`` ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯æœ¬è³ªçš„ã« :func:`frexp` ã®é€†é–¢æ•°ã§ã™ã€‚"

#: ../../library/math.rst:133
msgid ""
"Return the fractional and integer parts of *x*.  Both results carry the sign"
" of *x* and are floats."
msgstr "*x* ã®å°æ•°éƒ¨åˆ†ã¨æ•´æ•°éƒ¨åˆ†ã‚’è¿”ã—ã¾ã™ã€‚ä¸¡æ–¹ã®çµæœã¯ *x* ã®ç¬¦å·ã‚’å—ã‘ç¶™ãã¾ã™ã€‚æ•´æ•°éƒ¨ã¯floatå‹ã§è¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/math.rst:139
msgid ""
"Return the :class:`~numbers.Real` value *x* truncated to an "
":class:`~numbers.Integral` (usually a long integer).  Uses the ``__trunc__``"
" method."
msgstr "*x* ã® :class:`~numbers.Integral` å€¤ (ãŸã„ã¦ã„é•·æ•´æ•°) ã¸åˆ‡ã‚Šæ¨ã¦ã‚‰ã‚ŒãŸ :class:`~numbers.Real` å€¤ã‚’è¿”ã—ã¾ã™ã€‚ ``x.__trunc__()`` ãƒ¡ã‚½ãƒƒãƒ‰ã«å‡¦ç†ã‚’å§”è­²ã—ã¾ã™ã€‚"

#: ../../library/math.rst:146
msgid ""
"Note that :func:`frexp` and :func:`modf` have a different call/return "
"pattern than their C equivalents: they take a single argument and return a "
"pair of values, rather than returning their second return value through an "
"'output parameter' (there is no such thing in Python)."
msgstr ":func:`frexp` ã¨ :func:`modf` ã¯ C ã®ã‚‚ã®ã¨ã¯ç•°ãªã£ãŸå‘¼ã³å‡ºã—/è¿”ã—ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æŒã£ã¦ã„ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚å¼•æ•°ã‚’1ã¤ã ã‘å—ã‘å–ã‚Šã€1çµ„ã®ãƒšã‚¢ã«ãªã£ãŸå€¤ã‚’è¿”ã™ã®ã§ã€2ã¤ç›®ã®æˆ»ã‚Šå€¤ã‚’ 'å‡ºåŠ›ç”¨ã®å¼•æ•°' çµŒç”±ã§è¿”ã—ãŸã‚Šã¯ã—ã¾ã›ã‚“ (Python ã«ã¯å‡ºåŠ›ç”¨ã®å¼•æ•°ã¯ã‚ã‚Šã¾ã›ã‚“)ã€‚"

#: ../../library/math.rst:151
msgid ""
"For the :func:`ceil`, :func:`floor`, and :func:`modf` functions, note that "
"*all* floating-point numbers of sufficiently large magnitude are exact "
"integers. Python floats typically carry no more than 53 bits of precision "
"(the same as the platform C double type), in which case any float *x* with "
"``abs(x) >= 2**52`` necessarily has no fractional bits."
msgstr ":func:`ceil` ã€ :func:`floor` ã€ãŠã‚ˆã³ :func:`modf` é–¢æ•°ã«ã¤ã„ã¦ã¯ã€éå¸¸ã«å¤§ããªæµ®å‹•å°æ•°ç‚¹æ•°ãŒ *å…¨ã¦* æ•´æ•°ãã®ã‚‚ã®ã«ãªã‚‹ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚é€šå¸¸ã€Python ã®æµ®å‹•å°æ•°ç‚¹å‹ã¯ 53 ãƒ“ãƒƒãƒˆä»¥ä¸Šã®ç²¾åº¦ã‚’ã‚‚ãŸãªã„ (ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«ãŠã‘ã‚‹ C double å‹ã¨åŒã˜) ã®ã§ã€çµæœçš„ã« ``abs(x) >= 2**52`` ã§ã‚ã‚‹ã‚ˆã†ãªæµ®å‹•å°æ•°ç‚¹å‹ *x* ã¯å°æ•°éƒ¨åˆ†ã‚’æŒãŸãªããªã‚‹ã®ã§ã™ã€‚"

#: ../../library/math.rst:159
msgid "Power and logarithmic functions"
msgstr "æŒ‡æ•°é–¢æ•°ã¨å¯¾æ•°é–¢æ•°"

#: ../../library/math.rst:163
msgid "Return ``e**x``."
msgstr "``e**x`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/math.rst:168
msgid ""
"Return ``e**x - 1``.  For small floats *x*, the subtraction in ``exp(x) - "
"1`` can result in a significant loss of precision; the :func:`expm1` "
"function provides a way to compute this quantity to full precision::"
msgstr "``e**x - 1`` ã‚’è¿”ã—ã¾ã™ã€‚å°ã•ãªæµ®å‹•å°æ•°ç‚¹æ•° *x* ã«ã¤ã„ã¦ ``exp(x) - 1`` ã‚’è¨ˆç®—ã™ã‚‹ã¨ã€å¼•ãç®—ã«ã‚ˆã‚Š `æ¡è½ã¡ <http://ja.wikipedia.org/wiki/%E8%AA%A4%E5%B7%AE#.E6.A1.81.E8.90.BD.E3.81.A1>`_ ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ãŒã€ã“ã® :func:`expm1` é–¢æ•°ã¯ã€å®Œå…¨ãªç²¾åº¦ã§ã“ã®å€¤ã‚’è¨ˆç®—ã—ã¾ã™::"

#: ../../library/math.rst:184
msgid "With one argument, return the natural logarithm of *x* (to base *e*)."
msgstr "å¼•æ•°ãŒ1ã¤ã®å ´åˆã€*x* ã® (*e* ã‚’åº•ã¨ã™ã‚‹)è‡ªç„¶å¯¾æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/math.rst:186
msgid ""
"With two arguments, return the logarithm of *x* to the given *base*, "
"calculated as ``log(x)/log(base)``."
msgstr "å¼•æ•°ãŒ2ã¤ã®å ´åˆã€``log(x)/log(base)`` ã¨ã—ã¦æ±‚ã‚ã‚‰ã‚Œã‚‹ *base* ã‚’åº•ã¨ã—ãŸ *x* ã®å¯¾æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/math.rst:189
msgid "*base* argument added."
msgstr "å¼•æ•° *base* ã‚’è¿½åŠ "

#: ../../library/math.rst:195
msgid ""
"Return the natural logarithm of *1+x* (base *e*). The result is calculated "
"in a way which is accurate for *x* near zero."
msgstr "*1+x* ã®è‡ªç„¶å¯¾æ•°(ã¤ã¾ã‚Šåº• *e* ã®å¯¾æ•°)ã‚’è¿”ã—ã¾ã™ã€‚çµæœã¯ã‚¼ãƒ­ã«è¿‘ã„ *x* ã«å¯¾ã—ã¦æ­£ç¢ºã«ãªã‚‹ã‚ˆã†ãªæ–¹æ³•ã§è¨ˆç®—ã•ã‚Œã¾ã™ã€‚"

#: ../../library/math.rst:203
msgid ""
"Return the base-10 logarithm of *x*.  This is usually more accurate than "
"``log(x, 10)``."
msgstr "*x* ã®10ã‚’åº•ã¨ã—ãŸå¯¾æ•°(å¸¸ç”¨å¯¾æ•°)ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯é€šå¸¸ã€``log(x, 10)`` ã‚ˆã‚Šã‚‚é«˜ç²¾åº¦ã§ã™ã€‚"

#: ../../library/math.rst:209
msgid ""
"Return ``x`` raised to the power ``y``.  Exceptional cases follow Annex 'F' "
"of the C99 standard as far as possible.  In particular, ``pow(1.0, x)`` and "
"``pow(x, 0.0)`` always return ``1.0``, even when ``x`` is a zero or a NaN.  "
"If both ``x`` and ``y`` are finite, ``x`` is negative, and ``y`` is not an "
"integer then ``pow(x, y)`` is undefined, and raises :exc:`ValueError`."
msgstr "``x`` ã® ``y`` ä¹—ã‚’è¿”ã—ã¾ã™ã€‚ä¾‹å¤–çš„ãªå ´åˆã«ã¤ã„ã¦ã¯ã€ C99 æ¨™æº–ã®ä»˜éŒ² 'F' ã«å¯èƒ½ãªé™ã‚Šå¾“ã„ã¾ã™ã€‚ç‰¹ã«ã€ ``pow(1.0, x)`` ã¨ ``pow(x, 0.0)`` ã¯ã€ãŸã¨ãˆ ``x`` ãŒé›¶ã‚„ NaN ã§ã‚‚ã€å¸¸ã« ``1.0`` ã‚’è¿”ã—ã¾ã™ã€‚ã‚‚ã— ``x`` ã¨ ``y`` ã®ä¸¡æ–¹ãŒæœ‰é™ã®å€¤ã§ã€ ``x`` ãŒè² ã€ ``y`` ãŒæ•´æ•°ã§ãªã„å ´åˆã€ ``pow(x, y)`` ã¯æœªå®šç¾©ã§ã€ :exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/math.rst:216
msgid ""
"Unlike the built-in ``**`` operator, :func:`math.pow` converts both its "
"arguments to type :class:`float`.  Use ``**`` or the built-in :func:`pow` "
"function for computing exact integer powers."
msgstr "çµ„ã¿è¾¼ã¿ã® ``**`` æ¼”ç®—å­ã¨é•ã£ã¦ã€ :func:`math.pow` ã¯ä¸¡æ–¹ã®å¼•æ•°ã‚’ :class:`float` å‹ã«å¤‰æ›ã—ã¾ã™ã€‚æ­£ç¢ºãªæ•´æ•°ã®å†ªä¹—ã‚’è¨ˆç®—ã™ã‚‹ã«ã¯ ``**`` ã‚‚ã—ãã¯çµ„ã¿è¾¼ã¿ã® :func:`pow` é–¢æ•°ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚"

#: ../../library/math.rst:220
msgid "The outcome of ``1**nan`` and ``nan**0`` was undefined."
msgstr "ä»¥å‰ã¯ ``1**nan`` ã‚„ ``nan**0`` ã®çµæœã¯æœªå®šç¾©ã§ã—ãŸã€‚"

#: ../../library/math.rst:226
msgid "Return the square root of *x*."
msgstr "*x* ã®å¹³æ–¹æ ¹ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/math.rst:230
msgid "Trigonometric functions"
msgstr "ä¸‰è§’é–¢æ•°"

#: ../../library/math.rst:234
msgid "Return the arc cosine of *x*, in radians."
msgstr "*x* ã®é€†ä½™å¼¦ã‚’ã€ãƒ©ã‚¸ã‚¢ãƒ³ã§è¿”ã—ã¾ã™ã€‚"

#: ../../library/math.rst:239
msgid "Return the arc sine of *x*, in radians."
msgstr "*x* ã®é€†æ­£å¼¦ã‚’ã€ãƒ©ã‚¸ã‚¢ãƒ³ã§è¿”ã—ã¾ã™ã€‚"

#: ../../library/math.rst:244
msgid "Return the arc tangent of *x*, in radians."
msgstr "*x* ã®é€†æ­£æ¥ã‚’ã€ãƒ©ã‚¸ã‚¢ãƒ³ã§è¿”ã—ã¾ã™ã€‚"

#: ../../library/math.rst:249
msgid ""
"Return ``atan(y / x)``, in radians. The result is between ``-pi`` and "
"``pi``. The vector in the plane from the origin to point ``(x, y)`` makes "
"this angle with the positive X axis. The point of :func:`atan2` is that the "
"signs of both inputs are known to it, so it can compute the correct quadrant"
" for the angle. For example, ``atan(1)`` and ``atan2(1, 1)`` are both "
"``pi/4``, but ``atan2(-1, -1)`` is ``-3*pi/4``."
msgstr "``atan(y / x)`` ã‚’ã€ãƒ©ã‚¸ã‚¢ãƒ³ã§è¿”ã—ã¾ã™ã€‚æˆ»ã‚Šå€¤ã¯ ``-pi`` ã‹ã‚‰ ``pi`` ã®é–“ã«ãªã‚Šã¾ã™ã€‚ã“ã®è§’åº¦ã¯ã€æ¥µåº§æ¨™å¹³é¢ã«ãŠã„ã¦åŸç‚¹ã‹ã‚‰ ``(x, y)`` ã¸ã®ãƒ™ã‚¯ãƒˆãƒ«ãŒ X è»¸ã®æ­£ã®æ–¹å‘ã¨ãªã™è§’ã§ã™ã€‚ :func:`atan2` ã®ãƒã‚¤ãƒ³ãƒˆã¯ã€ä¸¡æ–¹ã®å…¥åŠ›ã®ç¬¦å·ãŒæ—¢çŸ¥ã§ã‚ã‚‹ãŸã‚ã«ã€ä½ç›¸è§’ã®æ­£ã—ã„è±¡é™ã‚’è¨ˆç®—ã§ãã‚‹ã“ã¨ã«ã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€ ``atan(1)`` ã¨ ``atan2(1, 1)`` ã¯ã„ãšã‚Œã‚‚ ``pi/4`` ã§ã™ãŒã€ ``atan2(-1, -1)`` ã¯ ``-3*pi/4`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/math.rst:259
msgid "Return the cosine of *x* radians."
msgstr "*x* ãƒ©ã‚¸ã‚¢ãƒ³ã®ä½™å¼¦ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/math.rst:264
msgid ""
"Return the Euclidean norm, ``sqrt(x*x + y*y)``. This is the length of the "
"vector from the origin to point ``(x, y)``."
msgstr "ãƒ¦ãƒ¼ã‚¯ãƒªãƒƒãƒ‰ãƒãƒ«ãƒ (``sqrt(x*x + y*y)``)ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯åŸç‚¹ã‹ã‚‰ç‚¹ ``(x, y)`` ã®ãƒ™ã‚¯ãƒˆãƒ«ã®é•·ã•ã§ã™ã€‚"

#: ../../library/math.rst:270
msgid "Return the sine of *x* radians."
msgstr "*x* ãƒ©ã‚¸ã‚¢ãƒ³ã®æ­£å¼¦ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/math.rst:275
msgid "Return the tangent of *x* radians."
msgstr "*x* ãƒ©ã‚¸ã‚¢ãƒ³ã®æ­£æ¥ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/math.rst:279
msgid "Angular conversion"
msgstr "è§’åº¦å¤‰æ›"

#: ../../library/math.rst:283
msgid "Convert angle *x* from radians to degrees."
msgstr "è§’ *x* ã‚’ãƒ©ã‚¸ã‚¢ãƒ³ã‹ã‚‰åº¦ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../library/math.rst:288
msgid "Convert angle *x* from degrees to radians."
msgstr "è§’ *x* ã‚’åº¦ã‹ã‚‰ãƒ©ã‚¸ã‚¢ãƒ³ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../library/math.rst:292
msgid "Hyperbolic functions"
msgstr "åŒæ›²ç·šé–¢æ•°"

#: ../../library/math.rst:296
msgid "Return the inverse hyperbolic cosine of *x*."
msgstr "*x* ã®é€†åŒæ›²ç·šä½™å¼¦ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/math.rst:303
msgid "Return the inverse hyperbolic sine of *x*."
msgstr "*x* ã®é€†åŒæ›²ç·šæ­£å¼¦ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/math.rst:310
msgid "Return the inverse hyperbolic tangent of *x*."
msgstr "*x* ã®é€†åŒæ›²ç·šæ­£æ¥ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/math.rst:317
msgid "Return the hyperbolic cosine of *x*."
msgstr "*x* ã®åŒæ›²ç·šä½™å¼¦ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/math.rst:322
msgid "Return the hyperbolic sine of *x*."
msgstr "*x* ã®åŒæ›²ç·šæ­£å¼¦ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/math.rst:327
msgid "Return the hyperbolic tangent of *x*."
msgstr "*x* ã®åŒæ›²ç·šæ­£æ¥ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/math.rst:331
msgid "Special functions"
msgstr "ç‰¹æ®Šãªé–¢æ•°"

#: ../../library/math.rst:335
msgid "Return the error function at *x*."
msgstr "*x* ã®èª¤å·®é–¢æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/math.rst:342
msgid "Return the complementary error function at *x*."
msgstr "*x* ã®ç›¸è£œèª¤å·®é–¢æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/math.rst:349
msgid "Return the Gamma function at *x*."
msgstr "*x* ã®ã‚¬ãƒ³ãƒé–¢æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/math.rst:356
msgid ""
"Return the natural logarithm of the absolute value of the Gamma function at "
"*x*."
msgstr "*x* ã®ã‚¬ãƒ³ãƒé–¢æ•°ã®çµ¶å¯¾å€¤ã®è‡ªç„¶å¯¾æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/math.rst:363
msgid "Constants"
msgstr "å®šæ•°"

#: ../../library/math.rst:367
msgid "The mathematical constant Ï€ = 3.141592..., to available precision."
msgstr "åˆ©ç”¨å¯èƒ½ãªç²¾åº¦ã®ã€æ•°å­¦å®šæ•°Ï€ = 3.141592... (å††å‘¨ç‡)ã€‚"

#: ../../library/math.rst:372
msgid "The mathematical constant e = 2.718281..., to available precision."
msgstr "åˆ©ç”¨å¯èƒ½ãªç²¾åº¦ã®ã€æ•°å­¦å®šæ•° *e* = 2.718281... (è‡ªç„¶å¯¾æ•°ã®åº•)ã€‚"

#: ../../library/math.rst:377
msgid ""
"The :mod:`math` module consists mostly of thin wrappers around the platform "
"C math library functions.  Behavior in exceptional cases follows Annex F of "
"the C99 standard where appropriate.  The current implementation will raise "
":exc:`ValueError` for invalid operations like ``sqrt(-1.0)`` or ``log(0.0)``"
" (where C99 Annex F recommends signaling invalid operation or divide-by-"
"zero), and :exc:`OverflowError` for results that overflow (for example, "
"``exp(1000.0)``).  A NaN will not be returned from any of the functions "
"above unless one or more of the input arguments was a NaN; in that case, "
"most functions will return a NaN, but (again following C99 Annex F) there "
"are some exceptions to this rule, for example ``pow(float('nan'), 0.0)`` or "
"``hypot(float('nan'), float('inf'))``."
msgstr ":mod:`math` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€ã»ã¨ã‚“ã©ãŒå®Ÿè¡Œãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«ãŠã‘ã‚‹ C è¨€èªã®æ•°å­¦ãƒ©ã‚¤ãƒ–ãƒ©ãƒªé–¢æ•°ã«å¯¾ã™ã‚‹è–„ã„ãƒ©ãƒƒãƒ‘ã§ã§ãã¦ã„ã¾ã™ã€‚ä¾‹å¤–çš„ãªå ´åˆã§ã®æŒ™å‹•ã¯ã€é©åˆ‡ã§ã‚ã‚‹é™ã‚Š C99 æ¨™æº–ã® Annex F ã«å¾“ã„ã¾ã™ã€‚ç¾åœ¨ã®å®Ÿè£…ã§ã¯ã€(C99 Annex F ã§ä¸æ­£ãªæ¼”ç®—ã‚„ã‚¼ãƒ­é™¤ç®—ã‚’é€šçŸ¥ã™ã‚‹ã“ã¨ãŒæ¨å¥¨ã•ã‚Œã¦ã„ã‚‹) ``sqrt(-1.0)`` ã‚„ ``log(0.0)`` ã¨ã„ã£ãŸä¸æ­£ãªæ“ä½œã«å¯¾ã—ã¦ :exc:`ValueError` ã‚’ç™ºç”Ÿã•ã›ã€(ä¾‹ãˆã° ``exp(1000.0)`` ã®ã‚ˆã†ãª) æ¼”ç®—çµæœãŒã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã™ã‚‹å ´åˆã«ã¯ :exc:`OverflowError` ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚ä¸Šè¨˜ã®é–¢æ•°ç¾¤ã¯ã€1ã¤ä»¥ä¸Šã®å¼•æ•°ãŒ NaN ã§ã‚ã£ãŸå ´åˆã‚’é™¤ã„ã¦ã€ NaN ã‚’è¿”ã—ã¾ã›ã‚“ã€‚å¼•æ•°ã« NaN ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã¯ã€æ®†ã©ã®é–¢æ•°ã¯ NaN ã‚’è¿”ã—ã¾ã™ãŒã€ (C99 Annex F ã«å¾“ã£ã¦) åˆ¥ã®å‹•ä½œã‚’ã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€ ``pow(float('nan'), 0.0)`` ã‚„ ``hypot(float('nan'), float('inf'))`` ã¨ã„ã£ãŸå ´åˆã§ã™ã€‚è¨³æ³¨: ä¾‹å¤–ãŒç™ºç”Ÿã›ãšã«çµæœãŒè¿”ã‚‹ã¨ã€è¨ˆç®—çµæœãŒãŠã‹ã—ããªã£ãŸåŸå› ãŒè¤‡ç´ æ•°ã‚’æ¸¡ã—ãŸãŸã‚ã ã¨ã„ã†ã“ã¨ã«æ°—ã¥ãã®ãŒé…ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/math.rst:389
msgid ""
"Note that Python makes no effort to distinguish signaling NaNs from quiet "
"NaNs, and behavior for signaling NaNs remains unspecified. Typical behavior "
"is to treat all NaNs as though they were quiet."
msgstr "Python ã¯ signaling NaN ã¨ quiet NaN ã‚’åŒºåˆ¥ã›ãšã€signaling NaN ã«å¯¾ã™ã‚‹æŒ™å‹•ã¯æœªå®šç¾©ã¨ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚å…¸å‹çš„ãªæŒ™å‹•ã¯ã€å…¨ã¦ã® NaN ã‚’ quiet NaN ã¨ã—ã¦æ‰±ã†ã“ã¨ã§ã™ã€‚"

#: ../../library/math.rst:393
msgid ""
"Behavior in special cases now aims to follow C99 Annex F.  In earlier "
"versions of Python the behavior in special cases was loosely specified."
msgstr "ç‰¹åˆ¥ãªã‚±ãƒ¼ã‚¹ã«ãŠã‘ã‚‹æŒ™å‹•ã¯ã€ C99 Annex F ã«å¾“ãŠã†ã¨ã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® Python ã§ã¯ã€ç‰¹åˆ¥ãªã‚±ãƒ¼ã‚¹ã§ã®æŒ™å‹•ã¯æ›–æ˜§ã«ã—ã‹å®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“ã§ã—ãŸã€‚"

#: ../../library/math.rst:400
msgid "Module :mod:`cmath`"
msgstr ":mod:`cmath` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"

#: ../../library/math.rst:401
msgid "Complex number versions of many of these functions."
msgstr "ã“ã‚Œã‚‰ã®å¤šãã®é–¢æ•°ã®è¤‡ç´ æ•°ç‰ˆã€‚"
