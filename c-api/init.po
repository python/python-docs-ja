# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# mollinaca, 2021
# Akira inamori <akira.inamori@tf-ebina.com>, 2021
# Arihiro TAKASE, 2023
# Nozomu Kaneko <nozom.kaneko@gmail.com>, 2023
# Masato HASHIMOTO <cabezon.hashimoto@gmail.com>, 2023
# Osamu NAKAMURA, 2023
# Takeshi Nakazato, 2024
# tomo, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-08-03 20:15+0000\n"
"PO-Revision-Date: 2021-06-28 00:49+0000\n"
"Last-Translator: tomo, 2024\n"
"Language-Team: Japanese (https://app.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/init.rst:8
msgid "Initialization, Finalization, and Threads"
msgstr "初期化 (initialization)、終了処理 (finalization)、スレッド"

#: ../../c-api/init.rst:10
msgid "See also :ref:`Python Initialization Configuration <init-config>`."
msgstr ":ref:`Python 初期化設定 <init-config>` も参照してください。"

#: ../../c-api/init.rst:15
msgid "Before Python Initialization"
msgstr "Python 初期化以前"

#: ../../c-api/init.rst:17
msgid ""
"In an application embedding  Python, the :c:func:`Py_Initialize` function "
"must be called before using any other Python/C API functions; with the "
"exception of a few functions and the :ref:`global configuration variables "
"<global-conf-vars>`."
msgstr ""
"Python が埋め込まれているアプリケーションでは、他の Python/C API 関数を使う前"
"に :c:func:`Py_Initialize` 関数を呼ばなければなりません。これには例外として、"
"いくつかの関数と :ref:`グローバルな設定変数 <global-conf-vars>` があります。"

#: ../../c-api/init.rst:22
msgid ""
"The following functions can be safely called before Python is initialized:"
msgstr "次の関数は Python の初期化の前でも安全に呼び出せます:"

#: ../../c-api/init.rst:24
msgid "Configuration functions:"
msgstr "設定関数:"

#: ../../c-api/init.rst:26
msgid ":c:func:`PyImport_AppendInittab`"
msgstr ":c:func:`PyImport_AppendInittab`"

#: ../../c-api/init.rst:27
msgid ":c:func:`PyImport_ExtendInittab`"
msgstr ":c:func:`PyImport_ExtendInittab`"

#: ../../c-api/init.rst:28
msgid ":c:func:`!PyInitFrozenExtensions`"
msgstr ""

#: ../../c-api/init.rst:29
msgid ":c:func:`PyMem_SetAllocator`"
msgstr ":c:func:`PyMem_SetAllocator`"

#: ../../c-api/init.rst:30
msgid ":c:func:`PyMem_SetupDebugHooks`"
msgstr ":c:func:`PyMem_SetupDebugHooks`"

#: ../../c-api/init.rst:31
msgid ":c:func:`PyObject_SetArenaAllocator`"
msgstr ":c:func:`PyObject_SetArenaAllocator`"

#: ../../c-api/init.rst:32
msgid ":c:func:`Py_SetProgramName`"
msgstr ":c:func:`Py_SetProgramName`"

#: ../../c-api/init.rst:33
msgid ":c:func:`Py_SetPythonHome`"
msgstr ":c:func:`Py_SetPythonHome`"

#: ../../c-api/init.rst:34
msgid ":c:func:`PySys_ResetWarnOptions`"
msgstr ":c:func:`PySys_ResetWarnOptions`"

#: ../../c-api/init.rst:36
msgid "Informative functions:"
msgstr "情報取得の関数:"

#: ../../c-api/init.rst:38
msgid ":c:func:`Py_IsInitialized`"
msgstr ":c:func:`Py_IsInitialized`"

#: ../../c-api/init.rst:39
msgid ":c:func:`PyMem_GetAllocator`"
msgstr ":c:func:`PyMem_GetAllocator`"

#: ../../c-api/init.rst:40
msgid ":c:func:`PyObject_GetArenaAllocator`"
msgstr ":c:func:`PyObject_GetArenaAllocator`"

#: ../../c-api/init.rst:41
msgid ":c:func:`Py_GetBuildInfo`"
msgstr ":c:func:`Py_GetBuildInfo`"

#: ../../c-api/init.rst:42
msgid ":c:func:`Py_GetCompiler`"
msgstr ":c:func:`Py_GetCompiler`"

#: ../../c-api/init.rst:43
msgid ":c:func:`Py_GetCopyright`"
msgstr ":c:func:`Py_GetCopyright`"

#: ../../c-api/init.rst:44
msgid ":c:func:`Py_GetPlatform`"
msgstr ":c:func:`Py_GetPlatform`"

#: ../../c-api/init.rst:45
msgid ":c:func:`Py_GetVersion`"
msgstr ":c:func:`Py_GetVersion`"

#: ../../c-api/init.rst:47
msgid "Utilities:"
msgstr "ユーティリティ:"

#: ../../c-api/init.rst:49
msgid ":c:func:`Py_DecodeLocale`"
msgstr ":c:func:`Py_DecodeLocale`"

#: ../../c-api/init.rst:51
msgid "Memory allocators:"
msgstr "メモリアロケータ:"

#: ../../c-api/init.rst:53
msgid ":c:func:`PyMem_RawMalloc`"
msgstr ":c:func:`PyMem_RawMalloc`"

#: ../../c-api/init.rst:54
msgid ":c:func:`PyMem_RawRealloc`"
msgstr ":c:func:`PyMem_RawRealloc`"

#: ../../c-api/init.rst:55
msgid ":c:func:`PyMem_RawCalloc`"
msgstr ":c:func:`PyMem_RawCalloc`"

#: ../../c-api/init.rst:56
msgid ":c:func:`PyMem_RawFree`"
msgstr ":c:func:`PyMem_RawFree`"

#: ../../c-api/init.rst:58
msgid "Synchronization:"
msgstr ""

#: ../../c-api/init.rst:60
msgid ":c:func:`PyMutex_Lock`"
msgstr ""

#: ../../c-api/init.rst:61
msgid ":c:func:`PyMutex_Unlock`"
msgstr ""

#: ../../c-api/init.rst:65
msgid ""
"The following functions **should not be called** before :c:func:"
"`Py_Initialize`: :c:func:`Py_EncodeLocale`, :c:func:`Py_GetPath`, :c:func:"
"`Py_GetPrefix`, :c:func:`Py_GetExecPrefix`, :c:func:"
"`Py_GetProgramFullPath`, :c:func:`Py_GetPythonHome`, :c:func:"
"`Py_GetProgramName` and :c:func:`PyEval_InitThreads`."
msgstr ""
"次の関数は :c:func:`Py_Initialize` より前に **呼び出すべき ではありません"
"** : :c:func:`Py_EncodeLocale`, :c:func:`Py_GetPath`, :c:func:"
"`Py_GetPrefix`, :c:func:`Py_GetExecPrefix`, :c:func:"
"`Py_GetProgramFullPath`, :c:func:`Py_GetPythonHome`, :c:func:"
"`Py_GetProgramName`, :c:func:`PyEval_InitThreads` 。"

#: ../../c-api/init.rst:75
msgid "Global configuration variables"
msgstr "グローバルな設定変数"

#: ../../c-api/init.rst:77
msgid ""
"Python has variables for the global configuration to control different "
"features and options. By default, these flags are controlled by :ref:"
"`command line options <using-on-interface-options>`."
msgstr ""
"Python には、様々な機能やオプションを制御するグローバルな設定のための変数があ"
"ります。\n"
"デフォルトでは、これらのフラグは :ref:`コマンドラインオプション <using-on-"
"interface-options>` で制御されます。"

#: ../../c-api/init.rst:81
msgid ""
"When a flag is set by an option, the value of the flag is the number of "
"times that the option was set. For example, ``-b`` sets :c:data:"
"`Py_BytesWarningFlag` to 1 and ``-bb`` sets :c:data:`Py_BytesWarningFlag` to "
"2."
msgstr ""
"オプションでフラグがセットされると、フラグの値はそのオプションがセットされた"
"回数になります。\n"
"例えば、 ``-b`` では :c:data:`Py_BytesWarningFlag` が 1 に設定され、 ``-bb`` "
"では :c:data:`Py_BytesWarningFlag` が 2 に設定されます。"

#: ../../c-api/init.rst:87
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"bytes_warning` should be used instead, see :ref:`Python Initialization "
"Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:91
msgid ""
"Issue a warning when comparing :class:`bytes` or :class:`bytearray` with :"
"class:`str` or :class:`bytes` with :class:`int`.  Issue an error if greater "
"or equal to ``2``."
msgstr ""
":class:`bytes` または :class:`bytearray` を :class:`str` と比較した場合、また"
"は、 :class:`bytes` を :class:`int` と比較した場合に警告を発生させます。\n"
"``2`` 以上の値を設定している場合は、エラーを発生させます。"

#: ../../c-api/init.rst:95
msgid "Set by the :option:`-b` option."
msgstr ":option:`-b` オプションで設定します。"

#: ../../c-api/init.rst:101
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"parser_debug` should be used instead, see :ref:`Python Initialization "
"Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:105
msgid ""
"Turn on parser debugging output (for expert only, depending on compilation "
"options)."
msgstr ""
"パーサーのデバッグ出力を有効にします。(専門家専用です。コンパイルオプションに"
"依存します)。"

#: ../../c-api/init.rst:108
msgid ""
"Set by the :option:`-d` option and the :envvar:`PYTHONDEBUG` environment "
"variable."
msgstr ":option:`-d` オプションと :envvar:`PYTHONDEBUG` 環境変数で設定します。"

#: ../../c-api/init.rst:115
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"write_bytecode` should be used instead, see :ref:`Python Initialization "
"Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:119
msgid ""
"If set to non-zero, Python won't try to write ``.pyc`` files on the import "
"of source modules."
msgstr ""
"非ゼロに設定した場合、Python はソースモジュールのインポート時に ``.pyc`` ファ"
"イルの作成を試みません。"

#: ../../c-api/init.rst:122
msgid ""
"Set by the :option:`-B` option and the :envvar:`PYTHONDONTWRITEBYTECODE` "
"environment variable."
msgstr ""
":option:`-B` オプションと :envvar:`PYTHONDONTWRITEBYTECODE` 環境変数で設定し"
"ます。"

#: ../../c-api/init.rst:129
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"pathconfig_warnings` should be used instead, see :ref:`Python Initialization "
"Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:133
msgid ""
"Suppress error messages when calculating the module search path in :c:func:"
"`Py_GetPath`."
msgstr ""
":c:func:`Py_GetPath` の中でモジュール検索パスを割り出しているときのエラーメッ"
"セージを抑制します。"

#: ../../c-api/init.rst:136
msgid "Private flag used by ``_freeze_module`` and ``frozenmain`` programs."
msgstr ""
"``_freeze_module`` プログラムと ``frozenmain`` プログラムが使用する非公開フラ"
"グです。"

#: ../../c-api/init.rst:142
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"hash_seed` and :c:member:`PyConfig.use_hash_seed` should be used instead, "
"see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:147
msgid ""
"Set to ``1`` if the :envvar:`PYTHONHASHSEED` environment variable is set to "
"a non-empty string."
msgstr ""
":envvar:`PYTHONHASHSEED` 環境変数が空でない文字列に設定された場合に、 ``1`` "
"が設定されます。"

#: ../../c-api/init.rst:150
msgid ""
"If the flag is non-zero, read the :envvar:`PYTHONHASHSEED` environment "
"variable to initialize the secret hash seed."
msgstr ""
"フラグがゼロでない場合、 :envvar:`PYTHONHASHSEED` 環境変数を読みシークレット"
"ハッシュシードを初期化します。"

#: ../../c-api/init.rst:157
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"use_environment` should be used instead, see :ref:`Python Initialization "
"Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:161
msgid ""
"Ignore all :envvar:`!PYTHON*` environment variables, e.g. :envvar:"
"`PYTHONPATH` and :envvar:`PYTHONHOME`, that might be set."
msgstr ""

#: ../../c-api/init.rst:164
msgid "Set by the :option:`-E` and :option:`-I` options."
msgstr ":option:`-E` オプションと :option:`-I` オプションで設定します。"

#: ../../c-api/init.rst:170
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"inspect` should be used instead, see :ref:`Python Initialization "
"Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:174
msgid ""
"When a script is passed as first argument or the :option:`-c` option is "
"used, enter interactive mode after executing the script or the command, even "
"when :data:`sys.stdin` does not appear to be a terminal."
msgstr ""
"最初の引数にスクリプトが指定されたときや :option:`-c` オプションが利用された"
"際に、 :data:`sys.stdin` がターミナルに出力されないときであっても、スクリプト"
"かコマンドを実行した後にインタラクティブモードに入ります。"

#: ../../c-api/init.rst:178
msgid ""
"Set by the :option:`-i` option and the :envvar:`PYTHONINSPECT` environment "
"variable."
msgstr ""
":option:`-i` オプションと :envvar:`PYTHONINSPECT` 環境変数で設定します。"

#: ../../c-api/init.rst:185
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"interactive` should be used instead, see :ref:`Python Initialization "
"Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:189
msgid "Set by the :option:`-i` option."
msgstr ":option:`-i` オプションで設定します。"

#: ../../c-api/init.rst:195
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"isolated` should be used instead, see :ref:`Python Initialization "
"Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:199
msgid ""
"Run Python in isolated mode. In isolated mode :data:`sys.path` contains "
"neither the script's directory nor the user's site-packages directory."
msgstr ""
"Python を隔離モードで実行します。\n"
"隔離モードでは :data:`sys.path` はスクリプトのディレクトリやユーザのサイト"
"パッケージのディレクトリを含みません。"

#: ../../c-api/init.rst:202
msgid "Set by the :option:`-I` option."
msgstr ":option:`-I` オプションで設定します。"

#: ../../c-api/init.rst:210
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyPreConfig."
"legacy_windows_fs_encoding` should be used instead, see :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:214
msgid ""
"If the flag is non-zero, use the ``mbcs`` encoding with ``replace`` error "
"handler, instead of the UTF-8 encoding with ``surrogatepass`` error handler, "
"for the :term:`filesystem encoding and error handler`."
msgstr ""

#: ../../c-api/init.rst:218
msgid ""
"Set to ``1`` if the :envvar:`PYTHONLEGACYWINDOWSFSENCODING` environment "
"variable is set to a non-empty string."
msgstr ""
":envvar:`PYTHONLEGACYWINDOWSFSENCODING` 環境変数が空でない文字列に設定された"
"場合に、 ``1`` に設定されます。"

#: ../../c-api/init.rst:221
msgid "See :pep:`529` for more details."
msgstr "より詳しくは :pep:`529` を参照してください。"

#: ../../c-api/init.rst:223 ../../c-api/init.rst:241
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`利用可能な環境 <availability>`: Windows 。"

#: ../../c-api/init.rst:229
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"legacy_windows_stdio` should be used instead, see :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:233
msgid ""
"If the flag is non-zero, use :class:`io.FileIO` instead of :class:`!io."
"_WindowsConsoleIO` for :mod:`sys` standard streams."
msgstr ""

#: ../../c-api/init.rst:236
msgid ""
"Set to ``1`` if the :envvar:`PYTHONLEGACYWINDOWSSTDIO` environment variable "
"is set to a non-empty string."
msgstr ""
":envvar:`PYTHONLEGACYWINDOWSSTDIO` 環境変数が空でない文字列に設定された場合"
"に、 ``1`` に設定されます。"

#: ../../c-api/init.rst:239
msgid "See :pep:`528` for more details."
msgstr "より詳しくは :pep:`528` を参照してください。"

#: ../../c-api/init.rst:247
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"site_import` should be used instead, see :ref:`Python Initialization "
"Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:251
msgid ""
"Disable the import of the module :mod:`site` and the site-dependent "
"manipulations of :data:`sys.path` that it entails.  Also disable these "
"manipulations if :mod:`site` is explicitly imported later (call :func:`site."
"main` if you want them to be triggered)."
msgstr ""
":mod:`site` モジュールの import と、そのモジュールが行なっていた site ごと"
"の :data:`sys.path` への操作を無効にします。後で :mod:`site` を明示的に "
"import しても、これらの操作は実行されません (実行したい場合は、 :func:`site."
"main` を呼び出してください)。"

#: ../../c-api/init.rst:256
msgid "Set by the :option:`-S` option."
msgstr ":option:`-S` オプションで設定します。"

#: ../../c-api/init.rst:262
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"user_site_directory` should be used instead, see :ref:`Python Initialization "
"Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:266
msgid ""
"Don't add the :data:`user site-packages directory <site.USER_SITE>` to :data:"
"`sys.path`."
msgstr ""
":data:`ユーザのサイトパッケージのディレクトリ <site.USER_SITE>` を :data:"
"`sys.path` に追加しません。"

#: ../../c-api/init.rst:269
msgid ""
"Set by the :option:`-s` and :option:`-I` options, and the :envvar:"
"`PYTHONNOUSERSITE` environment variable."
msgstr ""
":option:`-s` オプション、 :option:`-I` 、 :envvar:`PYTHONNOUSERSITE` 環境変数"
"で設定します。"

#: ../../c-api/init.rst:276
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"optimization_level` should be used instead, see :ref:`Python Initialization "
"Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:280
msgid ""
"Set by the :option:`-O` option and the :envvar:`PYTHONOPTIMIZE` environment "
"variable."
msgstr ""
":option:`-O` オプションと :envvar:`PYTHONOPTIMIZE` 環境変数で設定します。"

#: ../../c-api/init.rst:287
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"quiet` should be used instead, see :ref:`Python Initialization Configuration "
"<init-config>`."
msgstr ""

#: ../../c-api/init.rst:291
msgid ""
"Don't display the copyright and version messages even in interactive mode."
msgstr ""
"インタラクティブモードでも copyright とバージョンのメッセージを表示しません。"

#: ../../c-api/init.rst:293
msgid "Set by the :option:`-q` option."
msgstr ":option:`-q` オプションで設定します。"

#: ../../c-api/init.rst:301
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"buffered_stdio` should be used instead, see :ref:`Python Initialization "
"Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:305
msgid "Force the stdout and stderr streams to be unbuffered."
msgstr "標準出力と標準エラーをバッファリングしないように強制します。"

#: ../../c-api/init.rst:307
msgid ""
"Set by the :option:`-u` option and the :envvar:`PYTHONUNBUFFERED` "
"environment variable."
msgstr ""
":option:`-u` オプションと :envvar:`PYTHONUNBUFFERED` 環境変数で設定します。"

#: ../../c-api/init.rst:314
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"verbose` should be used instead, see :ref:`Python Initialization "
"Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:318
msgid ""
"Print a message each time a module is initialized, showing the place "
"(filename or built-in module) from which it is loaded.  If greater or equal "
"to ``2``, print a message for each file that is checked for when searching "
"for a module. Also provides information on module cleanup at exit."
msgstr ""
"モジュールが初期化されるたびにメッセージを出力し、それがどこ (ファイル名やビ"
"ルトインモジュール) からロードされたのかを表示します。\n"
"値が 2 以上の場合は、モジュールを検索するときにチェックしたファイルごとにメッ"
"セージを出力します。また、終了時のモジュールクリーンアップに関する情報も提供"
"します。"

#: ../../c-api/init.rst:323
msgid ""
"Set by the :option:`-v` option and the :envvar:`PYTHONVERBOSE` environment "
"variable."
msgstr ""
":option:`-v` オプションと :envvar:`PYTHONVERBOSE` 環境変数で設定します。"

#: ../../c-api/init.rst:330
msgid "Initializing and finalizing the interpreter"
msgstr "インタープリタの初期化と終了処理"

#: ../../c-api/init.rst:345
msgid ""
"Initialize the Python interpreter.  In an application embedding  Python, "
"this should be called before using any other Python/C API functions; see :"
"ref:`Before Python Initialization <pre-init-safe>` for the few exceptions."
msgstr ""
"Python インタープリタを初期化します。\n"
"Python の埋め込みを行うアプリケーションでは、他のあらゆる Python/C API を使用"
"するよりも前にこの関数を呼び出さなければなりません。いくつかの例外について"
"は :ref:`Python 初期化以前 <pre-init-safe>` を参照してください。"

#: ../../c-api/init.rst:349
msgid ""
"This initializes the table of loaded modules (``sys.modules``), and creates "
"the fundamental modules :mod:`builtins`, :mod:`__main__` and :mod:`sys`.  It "
"also initializes the module search path (``sys.path``). It does not set "
"``sys.argv``; use the new :c:type:`PyConfig` API of the :ref:`Python "
"Initialization Configuration <init-config>` for that.  This is a no-op when "
"called for a second time (without calling :c:func:`Py_FinalizeEx` first).  "
"There is no return value; it is a fatal error if the initialization fails."
msgstr ""

#: ../../c-api/init.rst:359 ../../c-api/init.rst:373
msgid ""
"Use the :c:func:`Py_InitializeFromConfig` function to customize the :ref:"
"`Python Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:363
msgid ""
"On Windows, changes the console mode from ``O_TEXT`` to ``O_BINARY``, which "
"will also affect non-Python uses of the console using the C Runtime."
msgstr ""
"Windows では ``O_TEXT`` から ``O_BINARY`` へコンソールモードが変更されます"
"が、これはその C ランタイムを使っているコンソールでの Python 以外の使い勝手に"
"も影響を及ぼします。"

#: ../../c-api/init.rst:369
msgid ""
"This function works like :c:func:`Py_Initialize` if *initsigs* is ``1``. If "
"*initsigs* is ``0``, it skips initialization registration of signal "
"handlers, which might be useful when Python is embedded."
msgstr ""
"*initsigs* に ``1`` を指定した場合、この関数は :c:func:`Py_Initialize` と同じ"
"ように動作します。\n"
"*initsigs* に ``0`` を指定した場合、初期化時のシグナルハンドラの登録をスキッ"
"プすることができ、これは Python の埋め込みで便利でしょう。"

#: ../../c-api/init.rst:379
msgid ""
"Return true (nonzero) when the Python interpreter has been initialized, "
"false (zero) if not.  After :c:func:`Py_FinalizeEx` is called, this returns "
"false until :c:func:`Py_Initialize` is called again."
msgstr ""
"Python インタプリタが初期化済みであれば真(非ゼロ)を、さもなければ偽(ゼロ)を返"
"します。:c:func:`Py_FinalizeEx` を呼び出した後は、:c:func:`Py_Initialize` を"
"再び呼び出すまで、この関数は偽を返します。"

#: ../../c-api/init.rst:386
msgid ""
"Return true (non-zero) if the main Python interpreter is :term:`shutting "
"down <interpreter shutdown>`. Return false (zero) otherwise."
msgstr ""

#: ../../c-api/init.rst:394
msgid ""
"Undo all initializations made by :c:func:`Py_Initialize` and subsequent use "
"of Python/C API functions, and destroy all sub-interpreters (see :c:func:"
"`Py_NewInterpreter` below) that were created and not yet destroyed since the "
"last call to :c:func:`Py_Initialize`.  Ideally, this frees all memory "
"allocated by the Python interpreter.  This is a no-op when called for a "
"second time (without calling :c:func:`Py_Initialize` again first)."
msgstr ""

#: ../../c-api/init.rst:401
msgid ""
"Since this is the reverse of :c:func:`Py_Initialize`, it should be called in "
"the same thread with the same interpreter active.  That means the main "
"thread and the main interpreter. This should never be called while :c:func:"
"`Py_RunMain` is running."
msgstr ""

#: ../../c-api/init.rst:406
msgid ""
"Normally the return value is ``0``. If there were errors during finalization "
"(flushing buffered data), ``-1`` is returned."
msgstr ""

#: ../../c-api/init.rst:410
msgid ""
"This function is provided for a number of reasons.  An embedding application "
"might want to restart Python without having to restart the application "
"itself. An application that has loaded the Python interpreter from a "
"dynamically loadable library (or DLL) might want to free all memory "
"allocated by Python before unloading the DLL. During a hunt for memory leaks "
"in an application a developer might want to free all memory allocated by "
"Python before exiting from the application."
msgstr ""
"この関数が提供されている理由はいくつかあります。Python の埋め込みを行っている"
"アプリケーションでは、アプリケーションを再起動することなく Python を再起動し"
"たいことがあります。また、動的ロード可能イブラリ (あるいは DLL) から Python "
"インタプリタをロードするアプリケーションでは、DLL をアンロードする前に "
"Python が確保したメモリを全て解放したいと考えるかもしれません。アプリケーショ"
"ン内で起きているメモリリークを追跡する際に、開発者は Python が確保したメモリ"
"をアプリケーションの終了前に解放させたいと思う場合もあります。"

#: ../../c-api/init.rst:418
msgid ""
"**Bugs and caveats:** The destruction of modules and objects in modules is "
"done in random order; this may cause destructors (:meth:`~object.__del__` "
"methods) to fail when they depend on other objects (even functions) or "
"modules.  Dynamically loaded extension modules loaded by Python are not "
"unloaded.  Small amounts of memory allocated by the Python interpreter may "
"not be freed (if you find a leak, please report it).  Memory tied up in "
"circular references between objects is not freed.  Some memory allocated by "
"extension modules may not be freed.  Some extensions may not work properly "
"if their initialization routine is called more than once; this can happen if "
"an application calls :c:func:`Py_Initialize` and :c:func:`Py_FinalizeEx` "
"more than once."
msgstr ""

#: ../../c-api/init.rst:429
msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython."
"_PySys_ClearAuditHooks`` with no arguments."
msgstr ""

#: ../../c-api/init.rst:435
msgid ""
"This is a backwards-compatible version of :c:func:`Py_FinalizeEx` that "
"disregards the return value."
msgstr ""
"この関数は :c:func:`Py_FinalizeEx` の後方互換性バージョンで、戻り値がありませ"
"ん。"

#: ../../c-api/init.rst:440
msgid "Process-wide parameters"
msgstr "プロセスワイドのパラメータ"

#: ../../c-api/init.rst:450
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"program_name` should be used instead, see :ref:`Python Initialization "
"Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:454
msgid ""
"This function should be called before :c:func:`Py_Initialize` is called for "
"the first time, if it is called at all.  It tells the interpreter the value "
"of the ``argv[0]`` argument to the :c:func:`main` function of the program "
"(converted to wide characters). This is used by :c:func:`Py_GetPath` and "
"some other functions below to find the Python run-time libraries relative to "
"the interpreter executable.  The default value is ``'python'``.  The "
"argument should point to a zero-terminated wide character string in static "
"storage whose contents will not change for the duration of the program's "
"execution.  No code in the Python interpreter will change the contents of "
"this storage."
msgstr ""
"この関数を呼び出すなら、最初に :c:func:`Py_Initialize` を呼び出すよりも前に呼"
"び出さなければなりません。この関数はインタプリタにプログラムの :c:func:"
"`main` 関数に指定した ``argv[0]`` 引数の値を教えます (ワイドキャラクタに変換"
"されます)。この引数値は、 :c:func:`Py_GetPath` や、以下に示すその他の関数が、"
"インタプリタの実行可能形式から Python ランタイムライブラリへの相対パスを取得"
"するために使われます。デフォルトの値は ``'python'`` です。引数はゼロ終端され"
"たワイドキャラクタ文字列で、静的な記憶領域に入っていなければならず、その内容"
"はプログラムの実行中に変更してはなりません。 Python インタプリタ内のコード"
"で、この記憶領域の内容を変更するものは一切ありません。"

#: ../../c-api/init.rst:465 ../../c-api/init.rst:704 ../../c-api/init.rst:740
#: ../../c-api/init.rst:766
msgid ""
"Use :c:func:`Py_DecodeLocale` to decode a bytes string to get a :c:expr:"
"`wchar_*` string."
msgstr ""
"バイト文字列を :c:expr:`wchar_*` 文字列にデコードするには :c:func:"
"`Py_DecodeLocale` を使ってください。"

#: ../../c-api/init.rst:473
msgid ""
"Return the program name set with :c:member:`PyConfig.program_name`, or the "
"default. The returned string points into static storage; the caller should "
"not modify its value."
msgstr ""

#: ../../c-api/init.rst:477 ../../c-api/init.rst:499 ../../c-api/init.rst:543
#: ../../c-api/init.rst:564 ../../c-api/init.rst:590 ../../c-api/init.rst:778
msgid ""
"This function should not be called before :c:func:`Py_Initialize`, otherwise "
"it returns ``NULL``."
msgstr ""

#: ../../c-api/init.rst:480 ../../c-api/init.rst:502 ../../c-api/init.rst:546
#: ../../c-api/init.rst:567 ../../c-api/init.rst:595 ../../c-api/init.rst:781
msgid "It now returns ``NULL`` if called before :c:func:`Py_Initialize`."
msgstr ""

#: ../../c-api/init.rst:483 ../../c-api/init.rst:570
msgid "Get :data:`sys.executable` instead."
msgstr ""

#: ../../c-api/init.rst:489
msgid ""
"Return the *prefix* for installed platform-independent files. This is "
"derived through a number of complicated rules from the program name set "
"with :c:member:`PyConfig.program_name` and some environment variables; for "
"example, if the program name is ``'/usr/local/bin/python'``, the prefix is "
"``'/usr/local'``. The returned string points into static storage; the caller "
"should not modify its value.  This corresponds to the :makevar:`prefix` "
"variable in the top-level :file:`Makefile` and the :option:`--prefix` "
"argument to the :program:`configure` script at build time.  The value is "
"available to Python code as ``sys.prefix``. It is only useful on Unix.  See "
"also the next function."
msgstr ""

#: ../../c-api/init.rst:505
msgid "Get :data:`sys.prefix` instead."
msgstr ""

#: ../../c-api/init.rst:511
msgid ""
"Return the *exec-prefix* for installed platform-*dependent* files.  This is "
"derived through a number of complicated rules from the program name set "
"with :c:member:`PyConfig.program_name` and some environment variables; for "
"example, if the program name is ``'/usr/local/bin/python'``, the exec-prefix "
"is ``'/usr/local'``.  The returned string points into static storage; the "
"caller should not modify its value.  This corresponds to the :makevar:"
"`exec_prefix` variable in the top-level :file:`Makefile` and the ``--exec-"
"prefix`` argument to the :program:`configure` script at build  time.  The "
"value is available to Python code as ``sys.exec_prefix``.  It is only useful "
"on Unix."
msgstr ""

#: ../../c-api/init.rst:521
msgid ""
"Background: The exec-prefix differs from the prefix when platform dependent "
"files (such as executables and shared libraries) are installed in a "
"different directory tree.  In a typical installation, platform dependent "
"files may be installed in the :file:`/usr/local/plat` subtree while platform "
"independent may be installed in :file:`/usr/local`."
msgstr ""
"背景: プラットフォーム依存のファイル (実行形式や共有ライブラリ) が別のディレ"
"クトリツリー内にインストールされている場合、 exec-prefix は prefix と異なりま"
"す。典型的なインストール形態では、プラットフォーム非依存のファイルが :file:`/"
"usr/local` に収められる一方、プラットフォーム依存のファイルは :file:`/usr/"
"local/plat` サブツリーに収められます。"

#: ../../c-api/init.rst:527
msgid ""
"Generally speaking, a platform is a combination of hardware and software "
"families, e.g.  Sparc machines running the Solaris 2.x operating system are "
"considered the same platform, but Intel machines running Solaris 2.x are "
"another platform, and Intel machines running Linux are yet another "
"platform.  Different major revisions of the same operating system generally "
"also form different platforms.  Non-Unix operating systems are a different "
"story; the installation strategies on those systems are so different that "
"the prefix and exec-prefix are meaningless, and set to the empty string. "
"Note that compiled Python bytecode files are platform independent (but not "
"independent from the Python version by which they were compiled!)."
msgstr ""
"一般的に、プラットフォームとは、ハードウェアとソフトウェアファミリの組み合わ"
"せを指します。例えば、Solaris 2.x を動作させている Sparc マシンは全て同じプ"
"ラットフォームであるとみなしますが、Solaris 2.x を動作させている Intel マシン"
"は違うプラットフォームになりますし、同じ Intel マシンでも Linux を動作させて"
"いるならまた別のプラットフォームです。一般的には、同じオペレーティングシステ"
"ムでも、メジャーリビジョンの違うものは異なるプラットフォームです。非 Unix の"
"オペレーティングシステムの場合は話はまた別です; 非 Unix のシステムでは、イン"
"ストール方法はとても異なっていて、prefix や exec-prefix には意味がなく、空文"
"字列が設定されています。コンパイル済みの Python バイトコードはプラットフォー"
"ムに依存しないので注意してください (ただし、どのバージョンの Python でコンパ"
"イルされたかには依存します!)。"

#: ../../c-api/init.rst:538
msgid ""
"System administrators will know how to configure the :program:`mount` or :"
"program:`automount` programs to share :file:`/usr/local` between platforms "
"while having :file:`/usr/local/plat` be a different filesystem for each "
"platform."
msgstr ""
"システム管理者は、 :program:`mount` や :program:`automount` プログラムを使っ"
"て、各プラットフォーム用の :file:`/usr/local/plat` を異なったファイルシステム"
"に置き、プラットフォーム間で :file:`/usr/local` を共有するための設定方法を"
"知っているでしょう。"

#: ../../c-api/init.rst:549
msgid "Get :data:`sys.exec_prefix` instead."
msgstr ""

#: ../../c-api/init.rst:558
msgid ""
"Return the full program name of the Python executable; this is  computed as "
"a side-effect of deriving the default module search path  from the program "
"name (set by :c:member:`PyConfig.program_name`). The returned string points "
"into static storage; the caller should not modify its value.  The value is "
"available to Python code as ``sys.executable``."
msgstr ""

#: ../../c-api/init.rst:580
msgid ""
"Return the default module search path; this is computed from the program "
"name (set by :c:member:`PyConfig.program_name`) and some environment "
"variables. The returned string consists of a series of directory names "
"separated by a platform dependent delimiter character.  The delimiter "
"character is ``':'`` on Unix and macOS, ``';'`` on Windows.  The returned "
"string points into static storage; the caller should not modify its value.  "
"The list :data:`sys.path` is initialized with this value on interpreter "
"startup; it can be (and usually is) modified later to change the search path "
"for loading modules."
msgstr ""

#: ../../c-api/init.rst:598
msgid "Get :data:`sys.path` instead."
msgstr ""

#: ../../c-api/init.rst:604
msgid ""
"Return the version of this Python interpreter.  This is a string that looks "
"something like ::"
msgstr ""
"Python インタプリタのバージョンを返します。バージョンは、次のような形式の文字"
"列です ::"

#: ../../c-api/init.rst:611
msgid ""
"The first word (up to the first space character) is the current Python "
"version; the first characters are the major and minor version separated by a "
"period.  The returned string points into static storage; the caller should "
"not modify its value.  The value is available to Python code as :data:`sys."
"version`."
msgstr ""
"第一ワード (最初のスペース文字まで) は、現在の Python のバージョンです; 最初"
"の文字は、ピリオドで区切られたメジャーバージョンとマイナーバージョンです。関"
"数が返す文字列ポインタは静的な記憶領域を返します; 関数の呼び出し側はこの値を"
"変更できません。この値は Python コードからは :data:`sys.version` として利用で"
"きます。"

#: ../../c-api/init.rst:616
msgid "See also the :c:var:`Py_Version` constant."
msgstr ""

#: ../../c-api/init.rst:623
msgid ""
"Return the platform identifier for the current platform.  On Unix, this is "
"formed from the \"official\" name of the operating system, converted to "
"lower case, followed by the major revision number; e.g., for Solaris 2.x, "
"which is also known as SunOS 5.x, the value is ``'sunos5'``.  On macOS, it "
"is ``'darwin'``.  On Windows, it is ``'win'``.  The returned string points "
"into static storage; the caller should not modify its value.  The value is "
"available to Python code as ``sys.platform``."
msgstr ""
"現在のプラットフォームのプラットフォーム識別文字列を返します。Unixでは、オペ"
"レーティングシステムの \"公式の\" 名前を小文字に変換し、後ろにメジャーリビ"
"ジョン番号を付けた構成になっています。例えば Solaris 2.x は、SunOS 5.x, とし"
"ても知られていますが、``'sunos5'`` になります。macOS では ``'darwin'`` です。"
"Windows では ``'win'`` です。関数が返す文字列ポインタは静的な記憶領域を返しま"
"す; 関数の呼び出し側はこの値を変更できません。この値は Python コードからは "
"``sys.platform`` として利用できます。"

#: ../../c-api/init.rst:634
msgid ""
"Return the official copyright string for the current Python version, for "
"example"
msgstr ""
"現在の Python バージョンに対する公式の著作権表示文字列を返します。例えば"

#: ../../c-api/init.rst:636
msgid "``'Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam'``"
msgstr "``'Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam'``"

#: ../../c-api/init.rst:640
msgid ""
"The returned string points into static storage; the caller should not modify "
"its value.  The value is available to Python code as ``sys.copyright``."
msgstr ""
"関数が返す文字列ポインタは静的な記憶領域を返します; 関数の呼び出し側はこの値"
"を変更できません。この値は Python コードからは ``sys.copyright`` として利用で"
"きます。"

#: ../../c-api/init.rst:646
msgid ""
"Return an indication of the compiler used to build the current Python "
"version, in square brackets, for example::"
msgstr ""
"現在使っているバージョンの Python をビルドする際に用いたコンパイラを示す文字"
"列を、角括弧で囲った文字列を返します。例えば::"

#: ../../c-api/init.rst:653 ../../c-api/init.rst:667
msgid ""
"The returned string points into static storage; the caller should not modify "
"its value.  The value is available to Python code as part of the variable "
"``sys.version``."
msgstr ""
"関数が返す文字列ポインタは静的な記憶領域を返します; 関数の呼び出し側はこの値"
"を変更できません。この値は Python コードからは ``sys.version`` の一部として取"
"り出せます。"

#: ../../c-api/init.rst:660
msgid ""
"Return information about the sequence number and build date and time  of the "
"current Python interpreter instance, for example ::"
msgstr ""
"現在使っている Python インタプリタインスタンスの、シーケンス番号とビルド日時"
"に関する情報を返します。例えば ::"

#: ../../c-api/init.rst:679
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"argv`, :c:member:`PyConfig.parse_argv` and :c:member:`PyConfig.safe_path` "
"should be used instead, see :ref:`Python Initialization Configuration <init-"
"config>`."
msgstr ""

#: ../../c-api/init.rst:684
msgid ""
"Set :data:`sys.argv` based on *argc* and *argv*.  These parameters are "
"similar to those passed to the program's :c:func:`main` function with the "
"difference that the first entry should refer to the script file to be "
"executed rather than the executable hosting the Python interpreter.  If "
"there isn't a script that will be run, the first entry in *argv* can be an "
"empty string.  If this function fails to initialize :data:`sys.argv`, a "
"fatal condition is signalled using :c:func:`Py_FatalError`."
msgstr ""
"*argc* および *argv* に基づいて :data:`sys.argv` を設定します。これらの引数は"
"プログラムの :c:func:`main` に渡した引数に似ていますが、最初の要素が Python "
"インタプリタの宿主となっている実行形式の名前ではなく、実行されるスクリプト名"
"を参照しなければならない点が違います。実行するスクリプトがない場合、 *argv* "
"の最初の要素は空文字列にしてもかまいません。この関数が :data:`sys.argv` の初"
"期化に失敗した場合、致命的エラーを :c:func:`Py_FatalError` で知らせます。"

#: ../../c-api/init.rst:692
msgid ""
"If *updatepath* is zero, this is all the function does.  If *updatepath* is "
"non-zero, the function also modifies :data:`sys.path` according to the "
"following algorithm:"
msgstr ""
"*updatepath* が 0 の場合、ここまでの動作がこの関数がすることの全てです。 "
"*updatepath* が 0 でない場合、この関数は :data:`sys.path` を以下のアルゴリズ"
"ムに基づいて修正します:"

#: ../../c-api/init.rst:696
msgid ""
"If the name of an existing script is passed in ``argv[0]``, the absolute "
"path of the directory where the script is located is prepended to :data:`sys."
"path`."
msgstr ""
"存在するスクリプトの名前が ``argv[0]`` に渡された場合、そのスクリプトがある場"
"所の絶対パスを :data:`sys.path` の先頭に追加します。"

#: ../../c-api/init.rst:699
msgid ""
"Otherwise (that is, if *argc* is ``0`` or ``argv[0]`` doesn't point to an "
"existing file name), an empty string is prepended to :data:`sys.path`, which "
"is the same as prepending the current working directory (``\".\"``)."
msgstr ""
"それ以外の場合 (*argc* が ``0`` だったり、 ``argv[0]`` が存在するファイル名を"
"指していない場合)、 :data:`sys.path` の先頭に空の文字列を追加します。\n"
"これは現在の作業ディレクトリ (``\".\"``) を先頭に追加するのと同じです。"

#: ../../c-api/init.rst:707 ../../c-api/init.rst:743
msgid ""
"See also :c:member:`PyConfig.orig_argv` and :c:member:`PyConfig.argv` "
"members of the :ref:`Python Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:711
msgid ""
"It is recommended that applications embedding the Python interpreter for "
"purposes other than executing a single script pass ``0`` as *updatepath*, "
"and update :data:`sys.path` themselves if desired. See :cve:`2008-5983`."
msgstr ""

#: ../../c-api/init.rst:716
msgid ""
"On versions before 3.1.3, you can achieve the same effect by manually "
"popping the first :data:`sys.path` element after having called :c:func:"
"`PySys_SetArgv`, for example using::"
msgstr ""
"3.1.3 より前のバージョンでは、 :c:func:`PySys_SetArgv` の呼び出しが完了した後"
"に :data:`sys.path` の先頭の要素を取り出すことで、同じ効果が得られます。例え"
"ばこのように使います::"

#: ../../c-api/init.rst:732
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"argv` and :c:member:`PyConfig.parse_argv` should be used instead, see :ref:"
"`Python Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:736
msgid ""
"This function works like :c:func:`PySys_SetArgvEx` with *updatepath* set to "
"``1`` unless the :program:`python` interpreter was started with the :option:"
"`-I`."
msgstr ""
"この関数は、 :program:`python` インタプリタが :option:`-I` オプション付きで実"
"行されている場合を除き :c:func:`PySys_SetArgvEx` の *updatepath* に ``1`` を"
"設定したのと同じように動作します。"

#: ../../c-api/init.rst:746
msgid "The *updatepath* value depends on :option:`-I`."
msgstr "*updatepath* の値は :option:`-I` オプションに依存します。"

#: ../../c-api/init.rst:753
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"home` should be used instead, see :ref:`Python Initialization Configuration "
"<init-config>`."
msgstr ""

#: ../../c-api/init.rst:757
msgid ""
"Set the default \"home\" directory, that is, the location of the standard "
"Python libraries.  See :envvar:`PYTHONHOME` for the meaning of the argument "
"string."
msgstr ""
"Python の標準ライブラリがある、デフォルトの \"home\" ディレクトリを設定しま"
"す。引数の文字列の意味については :envvar:`PYTHONHOME` を参照してください。"

#: ../../c-api/init.rst:761
msgid ""
"The argument should point to a zero-terminated character string in static "
"storage whose contents will not change for the duration of the program's "
"execution.  No code in the Python interpreter will change the contents of "
"this storage."
msgstr ""
"引数は静的なストレージに置かれてプログラム実行中に書き換えられないようなゼロ"
"終端の文字列であるべきです。Python インタプリタはこのストレージの内容を変更し"
"ません。"

#: ../../c-api/init.rst:774
msgid ""
"Return the default \"home\", that is, the value set by :c:member:`PyConfig."
"home`, or the value of the :envvar:`PYTHONHOME` environment variable if it "
"is set."
msgstr ""

#: ../../c-api/init.rst:784
msgid ""
"Get :c:member:`PyConfig.home` or :envvar:`PYTHONHOME` environment variable "
"instead."
msgstr ""

#: ../../c-api/init.rst:792
msgid "Thread State and the Global Interpreter Lock"
msgstr ""
"スレッド状態 (thread state) とグローバルインタプリタロック (global "
"interpreter lock)"

#: ../../c-api/init.rst:799
msgid ""
"The Python interpreter is not fully thread-safe.  In order to support multi-"
"threaded Python programs, there's a global lock, called the :term:`global "
"interpreter lock` or :term:`GIL`, that must be held by the current thread "
"before it can safely access Python objects. Without the lock, even the "
"simplest operations could cause problems in a multi-threaded program: for "
"example, when two threads simultaneously increment the reference count of "
"the same object, the reference count could end up being incremented only "
"once instead of twice."
msgstr ""
"Python インタプリタは完全にはスレッドセーフではありません。マルチスレッドの "
"Python プログラムをサポートするために、 :term:`グローバルインタプリタロック "
"<global interpreter lock>` あるいは :term:`GIL` と呼ばれるグローバルなロック"
"が存在していて、現在のスレッドが Python オブジェクトに安全にアクセスする前に"
"必ずロックを獲得しなければならなくなっています。ロック機構がなければ、単純な"
"操作でさえ、マルチスレッドプログラムの実行に問題を引き起こす可能性がありま"
"す。たとえば、二つのスレッドが同じオブジェクトの参照カウントを同時にインクリ"
"メントすると、結果的に参照カウントは二回でなく一回だけしかインクリメントされ"
"ないかもしれません。"

#: ../../c-api/init.rst:809
msgid ""
"Therefore, the rule exists that only the thread that has acquired the :term:"
"`GIL` may operate on Python objects or call Python/C API functions. In order "
"to emulate concurrency of execution, the interpreter regularly tries to "
"switch threads (see :func:`sys.setswitchinterval`).  The lock is also "
"released around potentially blocking I/O operations like reading or writing "
"a file, so that other Python threads can run in the meantime."
msgstr ""
"このため、 :term:`GIL` を獲得したスレッドだけが Python オブジェクトを操作した"
"り、 Python/C API 関数を呼び出したりできるというルールがあります。並行処理を"
"エミュレートするために、インタプリタは定期的にロックを解放したり獲得したりし"
"ます。 (:func:`sys.setswitchinterval` を参照) このロックはブロックが起こりう"
"る I/O 操作の付近でも解放・獲得され、 I/O を要求するスレッドが I/O 操作の完了"
"を待つ間、他のスレッドが動作できるようにしています。"

#: ../../c-api/init.rst:819
msgid ""
"The Python interpreter keeps some thread-specific bookkeeping information "
"inside a data structure called :c:type:`PyThreadState`.  There's also one "
"global variable pointing to the current :c:type:`PyThreadState`: it can be "
"retrieved using :c:func:`PyThreadState_Get`."
msgstr ""
"Python インタプリタはスレッドごとに必要な情報を :c:type:`PyThreadState` と呼"
"ばれるデータ構造の中に保存します。そしてグローバル変数として現在の :c:type:"
"`PyThreadState` を指すポインタを1つ持ちます。このグローバル変数は :c:func:"
"`PyThreadState_Get` を使って取得できます。"

#: ../../c-api/init.rst:825
msgid "Releasing the GIL from extension code"
msgstr "拡張コード内で GIL を解放する"

#: ../../c-api/init.rst:827
msgid ""
"Most extension code manipulating the :term:`GIL` has the following simple "
"structure::"
msgstr ""
":term:`GIL` を操作するほとんどのコードは、次のような単純な構造になります::"

#: ../../c-api/init.rst:836
msgid "This is so common that a pair of macros exists to simplify it::"
msgstr ""
"この構造は非常に一般的なので、作業を単純にするために2つのマクロが用意されてい"
"ます::"

#: ../../c-api/init.rst:846
msgid ""
"The :c:macro:`Py_BEGIN_ALLOW_THREADS` macro opens a new block and declares a "
"hidden local variable; the :c:macro:`Py_END_ALLOW_THREADS` macro closes the "
"block."
msgstr ""
":c:macro:`Py_BEGIN_ALLOW_THREADS` マクロは新たなブロックを開始し、隠しローカ"
"ル変数を宣言します; :c:macro:`Py_END_ALLOW_THREADS` はブロックを閉じます。"

#: ../../c-api/init.rst:850
msgid "The block above expands to the following code::"
msgstr "上のブロックは次のコードに展開されます::"

#: ../../c-api/init.rst:862
msgid ""
"Here is how these functions work: the global interpreter lock is used to "
"protect the pointer to the current thread state.  When releasing the lock "
"and saving the thread state, the current thread state pointer must be "
"retrieved before the lock is released (since another thread could "
"immediately acquire the lock and store its own thread state in the global "
"variable). Conversely, when acquiring the lock and restoring the thread "
"state, the lock must be acquired before storing the thread state pointer."
msgstr ""
"これらの関数の動作を説明します。GIL は現在のスレッド状態を指すポインタを保護"
"するために使われます。ロックを解放してスレッド状態を退避する際、ロックを解放"
"する前に現在のスレッド状態ポインタを取得しておかなければなりません (他のス"
"レッドがすぐさまロックを獲得して、自らのスレッド状態をグローバル変数に保存し"
"てしまうかもしれないからです)。逆に、ロックを獲得してスレッド状態を復帰する際"
"には、グローバル変数にスレッド状態ポインタを保存する前にロックを獲得しておか"
"なければなりません。"

#: ../../c-api/init.rst:871
msgid ""
"Calling system I/O functions is the most common use case for releasing the "
"GIL, but it can also be useful before calling long-running computations "
"which don't need access to Python objects, such as compression or "
"cryptographic functions operating over memory buffers.  For example, the "
"standard :mod:`zlib` and :mod:`hashlib` modules release the GIL when "
"compressing or hashing data."
msgstr ""
"GIL を解放するのはほとんどがシステムのI/O関数を呼び出す時ですが、メモリバッ"
"ファに対する圧縮や暗号化のように、 Python のオブジェクトにアクセスしない長時"
"間かかる計算処理を呼び出すときも GIL を解放することは有益です。例えば、 :mod:"
"`zlib` や :mod:`hashlib` モジュールは圧縮やハッシュ計算の前に GIL を解放しま"
"す。"

#: ../../c-api/init.rst:882
msgid "Non-Python created threads"
msgstr "Python 以外で作られたスレッド"

#: ../../c-api/init.rst:884
msgid ""
"When threads are created using the dedicated Python APIs (such as the :mod:"
"`threading` module), a thread state is automatically associated to them and "
"the code showed above is therefore correct.  However, when threads are "
"created from C (for example by a third-party library with its own thread "
"management), they don't hold the GIL, nor is there a thread state structure "
"for them."
msgstr ""
"Python API を通して作られたスレッド (:mod:`threading` モジュールなど) では自"
"動的にスレッド状態が割り当てられて、上記のコードは正しく動きます。しかし、(自"
"前でスレッド管理を行う外部のライブラリなどにより)C言語でスレッドを生成した場"
"合、そのスレッドには GIL がなく、スレッド状態データ構造体もないことに注意する"
"必要があります。"

#: ../../c-api/init.rst:891
msgid ""
"If you need to call Python code from these threads (often this will be part "
"of a callback API provided by the aforementioned third-party library), you "
"must first register these threads with the interpreter by creating a thread "
"state data structure, then acquiring the GIL, and finally storing their "
"thread state pointer, before you can start using the Python/C API.  When you "
"are done, you should reset the thread state pointer, release the GIL, and "
"finally free the thread state data structure."
msgstr ""
"このようなスレッドから Python コードを呼び出す必要がある場合 (外部のライブラ"
"リからコールバックするAPIなどがよくある例です)、Python/C API を呼び出す前に、"
"スレッド状態データ構造体を生成し、GIL を獲得し、スレッド状態ポインタを保存す"
"ることで、スレッドをインタプリタに登録しなければなりません。スレッドが作業を"
"終えたら、スレッド状態ポインタをリセットして、ロックを解放し、最後にスレッド"
"状態データ構造体のメモリを解放しなければなりません。"

#: ../../c-api/init.rst:899
msgid ""
"The :c:func:`PyGILState_Ensure` and :c:func:`PyGILState_Release` functions "
"do all of the above automatically.  The typical idiom for calling into "
"Python from a C thread is::"
msgstr ""
":c:func:`PyGILState_Ensure` と :c:func:`PyGILState_Release` はこの処理を自動"
"的に行います。 Cのスレッドから Python を呼び出す典型的な方法は以下のとおりで"
"す::"

#: ../../c-api/init.rst:913
msgid ""
"Note that the ``PyGILState_*`` functions assume there is only one global "
"interpreter (created automatically by :c:func:`Py_Initialize`).  Python "
"supports the creation of additional interpreters (using :c:func:"
"`Py_NewInterpreter`), but mixing multiple interpreters and the "
"``PyGILState_*`` API is unsupported."
msgstr ""
"``PyGILState_*`` 関数は、(:c:func:`Py_Initialize` によって自動的に作られる) "
"グローバルインタプリタ1つだけが存在すると仮定する事に気をつけて下さい。 "
"Python は (:c:func:`Py_NewInterpreter` を使って) 追加のインタプリタを作成でき"
"ることに変わりはありませんが、複数インタプリタと ``PyGILState_*`` API を混ぜ"
"て使うことはサポートされていません。"

#: ../../c-api/init.rst:923
msgid "Cautions about fork()"
msgstr ""

#: ../../c-api/init.rst:925
msgid ""
"Another important thing to note about threads is their behaviour in the face "
"of the C :c:func:`fork` call. On most systems with :c:func:`fork`, after a "
"process forks only the thread that issued the fork will exist.  This has a "
"concrete impact both on how locks must be handled and on all stored state in "
"CPython's runtime."
msgstr ""

#: ../../c-api/init.rst:931
msgid ""
"The fact that only the \"current\" thread remains means any locks held by "
"other threads will never be released. Python solves this for :func:`os.fork` "
"by acquiring the locks it uses internally before the fork, and releasing "
"them afterwards. In addition, it resets any :ref:`lock-objects` in the "
"child. When extending or embedding Python, there is no way to inform Python "
"of additional (non-Python) locks that need to be acquired before or reset "
"after a fork. OS facilities such as :c:func:`!pthread_atfork` would need to "
"be used to accomplish the same thing. Additionally, when extending or "
"embedding Python, calling :c:func:`fork` directly rather than through :func:"
"`os.fork` (and returning to or calling into Python) may result in a deadlock "
"by one of Python's internal locks being held by a thread that is defunct "
"after the fork. :c:func:`PyOS_AfterFork_Child` tries to reset the necessary "
"locks, but is not always able to."
msgstr ""

#: ../../c-api/init.rst:946
msgid ""
"The fact that all other threads go away also means that CPython's runtime "
"state there must be cleaned up properly, which :func:`os.fork` does.  This "
"means finalizing all other :c:type:`PyThreadState` objects belonging to the "
"current interpreter and all other :c:type:`PyInterpreterState` objects.  Due "
"to this and the special nature of the :ref:`\"main\" interpreter <sub-"
"interpreter-support>`, :c:func:`fork` should only be called in that "
"interpreter's \"main\" thread, where the CPython global runtime was "
"originally initialized. The only exception is if :c:func:`exec` will be "
"called immediately after."
msgstr ""

#: ../../c-api/init.rst:959
msgid "High-level API"
msgstr "高レベルAPI"

#: ../../c-api/init.rst:961
msgid ""
"These are the most commonly used types and functions when writing C "
"extension code, or when embedding the Python interpreter:"
msgstr ""
"C拡張を書いたりPythonインタプリタを埋め込むときに最も一般的に使われる型や関数"
"は次のとおりです:"

#: ../../c-api/init.rst:966
msgid ""
"This data structure represents the state shared by a number of cooperating "
"threads.  Threads belonging to the same interpreter share their module "
"administration and a few other internal items. There are no public members "
"in this structure."
msgstr ""
"このデータ構造体は、協調動作する多数のスレッド間で共有されている状態を表現し"
"ます。同じインタプリタに属するスレッドはモジュール管理情報やその他いくつかの"
"内部的な情報を共有しています。この構造体には公開 (public) のメンバはありませ"
"ん。"

#: ../../c-api/init.rst:971
msgid ""
"Threads belonging to different interpreters initially share nothing, except "
"process state like available memory, open file descriptors and such.  The "
"global interpreter lock is also shared by all threads, regardless of to "
"which interpreter they belong."
msgstr ""
"異なるインタプリタに属するスレッド間では、利用可能なメモリ、開かれているファ"
"イルデスクリプタなどといったプロセス状態を除いて、初期状態では何も共有されて"
"いません。GILもまた、スレッドがどのインタプリタに属しているかに関わらずすべて"
"のスレッドで共有されています。"

#: ../../c-api/init.rst:979
msgid ""
"This data structure represents the state of a single thread.  The only "
"public data member is:"
msgstr ""

#: ../../c-api/init.rst:984
msgid "This thread's interpreter state."
msgstr ""

#: ../../c-api/init.rst:995
msgid "Deprecated function which does nothing."
msgstr ""

#: ../../c-api/init.rst:997
msgid ""
"In Python 3.6 and older, this function created the GIL if it didn't exist."
msgstr ""

#: ../../c-api/init.rst:999
msgid "The function now does nothing."
msgstr ""

#: ../../c-api/init.rst:1002
msgid ""
"This function is now called by :c:func:`Py_Initialize()`, so you don't have "
"to call it yourself anymore."
msgstr ""
"この関数は :c:func:`Py_Initialize()` から呼び出されるようになり、わざわざ呼び"
"出す必要はもう無くなりました。"

#: ../../c-api/init.rst:1006
msgid ""
"This function cannot be called before :c:func:`Py_Initialize()` anymore."
msgstr ""
"この関数は :c:func:`Py_Initialize()` より前に呼び出すことができなくなりまし"
"た。"

#: ../../c-api/init.rst:1016
msgid ""
"Release the global interpreter lock (if it has been created) and reset the "
"thread state to ``NULL``, returning the previous thread state (which is not "
"``NULL``).  If the lock has been created, the current thread must have "
"acquired it."
msgstr ""
"(GIL が生成されている場合) GILを解放して、スレッドの状態を ``NULL`` にし、以"
"前のスレッド状態 (``NULL`` にはなりません) を返します。\n"
"ロックがすでに生成されている場合、現在のスレッドがロックを獲得していなければ"
"なりません。"

#: ../../c-api/init.rst:1024
msgid ""
"Acquire the global interpreter lock (if it has been created) and set the "
"thread state to *tstate*, which must not be ``NULL``.  If the lock has been "
"created, the current thread must not have acquired it, otherwise deadlock "
"ensues."
msgstr ""
"(GIL が生成されている場合) GIL を獲得して、現在のスレッド状態を *tstate* に設"
"定します。 *tstate* は ``NULL`` であってはなりません。 GIL が生成されていて、"
"この関数を呼び出したスレッドがすでにロックを獲得している場合、デッドロックに"
"陥ります。"

#: ../../c-api/init.rst:1030 ../../c-api/init.rst:1089
#: ../../c-api/init.rst:1371
msgid ""
"Calling this function from a thread when the runtime is finalizing will "
"terminate the thread, even if the thread was not created by Python. You can "
"use :c:func:`Py_IsFinalizing` or :func:`sys.is_finalizing` to check if the "
"interpreter is in process of being finalized before calling this function to "
"avoid unwanted termination."
msgstr ""

#: ../../c-api/init.rst:1038
msgid ""
"Return the current thread state.  The global interpreter lock must be held. "
"When the current thread state is ``NULL``, this issues a fatal error (so "
"that the caller needn't check for ``NULL``)."
msgstr ""
"現在のスレッド状態を返します。GIL を保持していなければなりません。現在のス"
"レッド状態が ``NULL`` なら、(呼び出し側が ``NULL`` チェックをしなくてすむよう"
"に) この関数は致命的エラーを起こすようになっています。"

#: ../../c-api/init.rst:1042
msgid "See also :c:func:`PyThreadState_GetUnchecked`."
msgstr ""

#: ../../c-api/init.rst:1047
msgid ""
"Similar to :c:func:`PyThreadState_Get`, but don't kill the process with a "
"fatal error if it is NULL. The caller is responsible to check if the result "
"is NULL."
msgstr ""

#: ../../c-api/init.rst:1051
msgid ""
"In Python 3.5 to 3.12, the function was private and known as "
"``_PyThreadState_UncheckedGet()``."
msgstr ""

#: ../../c-api/init.rst:1058
msgid ""
"Swap the current thread state with the thread state given by the argument "
"*tstate*, which may be ``NULL``.  The global interpreter lock must be held "
"and is not released."
msgstr ""
"現在のスレッド状態を *tstate* に指定したスレッド状態と入れ変えます。*tstate* "
"は ``NULL`` の場合があります。GIL を保持していなければならず、解放しません。"

#: ../../c-api/init.rst:1063
msgid ""
"The following functions use thread-local storage, and are not compatible "
"with sub-interpreters:"
msgstr ""
"以下の関数はスレッドローカルストレージを利用していて、サブインタプリタとの互"
"換性がありません:"

#: ../../c-api/init.rst:1068
msgid ""
"Ensure that the current thread is ready to call the Python C API regardless "
"of the current state of Python, or of the global interpreter lock. This may "
"be called as many times as desired by a thread as long as each call is "
"matched with a call to :c:func:`PyGILState_Release`. In general, other "
"thread-related APIs may be used between :c:func:`PyGILState_Ensure` and :c:"
"func:`PyGILState_Release` calls as long as the thread state is restored to "
"its previous state before the Release().  For example, normal usage of the :"
"c:macro:`Py_BEGIN_ALLOW_THREADS` and :c:macro:`Py_END_ALLOW_THREADS` macros "
"is acceptable."
msgstr ""
"Pythonの状態やGILに関わらず、実行中スレッドでPython C APIの呼び出しが可能とな"
"るようにします。この関数はスレッド内で何度でも呼び出すことができますが、必ず"
"全ての呼び出しに対応して :c:func:`PyGILState_Release` を呼び出す必要がありま"
"す。通常、 :c:func:`PyGILState_Ensure` 呼び出しと :c:func:"
"`PyGILState_Release` 呼び出しの間でこれ以外のスレッド関連API を使用することが"
"できますが、Release()の前にスレッド状態は復元されていなければなりません。例え"
"ば、通常の :c:macro:`Py_BEGIN_ALLOW_THREADS` マクロと :c:macro:"
"`Py_END_ALLOW_THREADS` は使用することができます。"

#: ../../c-api/init.rst:1078
msgid ""
"The return value is an opaque \"handle\" to the thread state when :c:func:"
"`PyGILState_Ensure` was called, and must be passed to :c:func:"
"`PyGILState_Release` to ensure Python is left in the same state. Even though "
"recursive calls are allowed, these handles *cannot* be shared - each unique "
"call to :c:func:`PyGILState_Ensure` must save the handle for its call to :c:"
"func:`PyGILState_Release`."
msgstr ""
"戻り値は :c:func:`PyGILState_Ensure` 呼び出し時のスレッド状態を隠蔽した\"ハン"
"ドル\"で、 :c:func:`PyGILState_Release` に渡してPythonを同じ状態に保たなけれ"
"ばなりません。再起呼び出しも可能ですが、ハンドルを共有することは *できません"
"* - それぞれの :c:func:`PyGILState_Ensure` 呼び出しでハンドルを保存し、対応す"
"る :c:func:`PyGILState_Release` 呼び出しで渡してください。"

#: ../../c-api/init.rst:1085
msgid ""
"When the function returns, the current thread will hold the GIL and be able "
"to call arbitrary Python code.  Failure is a fatal error."
msgstr ""
"関数から復帰したとき、実行中のスレッドはGILを所有していて、任意の Python コー"
"ドを実行できます。処理の失敗は致命的なエラーです。"

#: ../../c-api/init.rst:1097
msgid ""
"Release any resources previously acquired.  After this call, Python's state "
"will be the same as it was prior to the corresponding :c:func:"
"`PyGILState_Ensure` call (but generally this state will be unknown to the "
"caller, hence the use of the GILState API)."
msgstr ""
"獲得したすべてのリソースを解放します。この関数を呼び出すと、Pythonの状態は対"
"応する :c:func:`PyGILState_Ensure` を呼び出す前と同じとなります (通常、この状"
"態は呼び出し元でははわかりませんので、GILState APIを利用するようにしてくださ"
"い)。"

#: ../../c-api/init.rst:1102
msgid ""
"Every call to :c:func:`PyGILState_Ensure` must be matched by a call to :c:"
"func:`PyGILState_Release` on the same thread."
msgstr ""
":c:func:`PyGILState_Ensure` を呼び出す場合は、必ず同一スレッド内で対応する :"
"c:func:`PyGILState_Release` を呼び出してください。"

#: ../../c-api/init.rst:1108
msgid ""
"Get the current thread state for this thread.  May return ``NULL`` if no "
"GILState API has been used on the current thread.  Note that the main thread "
"always has such a thread-state, even if no auto-thread-state call has been "
"made on the main thread.  This is mainly a helper/diagnostic function."
msgstr ""
"このスレッドの現在のスレッドの状態を取得します。これまで現在のスレッドで "
"GILState API を使ったことが無い場合は、``NULL`` が返ります。メインスレッドで"
"自身のスレッド状態に関する呼び出しを全くしないとしても、メインスレッドは常に"
"スレッド状態の情報を持っていることに注意してください。こうなっている目的は主"
"にヘルパ機能もしくは診断機能のためです。"

#: ../../c-api/init.rst:1116
msgid ""
"Return ``1`` if the current thread is holding the GIL and ``0`` otherwise. "
"This function can be called from any thread at any time. Only if it has had "
"its Python thread state initialized and currently is holding the GIL will it "
"return ``1``. This is mainly a helper/diagnostic function.  It can be useful "
"for example in callback contexts or memory allocation functions when knowing "
"that the GIL is locked can allow the caller to perform sensitive actions or "
"otherwise behave differently."
msgstr ""
"現在のスレッドが GILを保持しているならば ``1`` を、そうでなければ ``0`` を返"
"します。この関数はいつでもどのスレッドからでも呼び出すことができます。 "
"Python スレッドの状態が初期化されており、現在 GIL を保持している場合にのみ "
"``1`` を返します。これは主にヘルパー/診断用の関数です。この関数は、例えばコー"
"ルバックのコンテキストやメモリ割り当て機能で有益でしょう。なぜなら、 GIL が"
"ロックされていると知っていれば、呼び出し元は sensitive な行動を実行することが"
"でき、そうでなければ異なるやりかたで振る舞うことができるからです。"

#: ../../c-api/init.rst:1128
msgid ""
"The following macros are normally used without a trailing semicolon; look "
"for example usage in the Python source distribution."
msgstr ""
"以下のマクロは、通常末尾にセミコロンを付けずに使います; Python ソース配布物内"
"の使用例を見てください。"

#: ../../c-api/init.rst:1134
msgid ""
"This macro expands to ``{ PyThreadState *_save; _save = PyEval_SaveThread();"
"``. Note that it contains an opening brace; it must be matched with a "
"following :c:macro:`Py_END_ALLOW_THREADS` macro.  See above for further "
"discussion of this macro."
msgstr ""
"このマクロを展開すると ``{ PyThreadState *_save; _save = PyEval_SaveThread();"
"`` になります。マクロに開き波括弧が入っていることに注意してください; この波括"
"弧は後で :c:macro:`Py_END_ALLOW_THREADS` マクロと対応させなければなりません。"
"マクロについての詳しい議論は上記を参照してください。"

#: ../../c-api/init.rst:1142
msgid ""
"This macro expands to ``PyEval_RestoreThread(_save); }``. Note that it "
"contains a closing brace; it must be matched with an earlier :c:macro:"
"`Py_BEGIN_ALLOW_THREADS` macro.  See above for further discussion of this "
"macro."
msgstr ""
"このマクロを展開すると ``PyEval_RestoreThread(_save); }`` になります。マクロ"
"に開き波括弧が入っていることに注意してください; この波括弧は事前の :c:macro:"
"`Py_BEGIN_ALLOW_THREADS` マクロと対応していなければなりません。マクロについて"
"の詳しい議論は上記を参照してください。"

#: ../../c-api/init.rst:1150
msgid ""
"This macro expands to ``PyEval_RestoreThread(_save);``: it is equivalent to :"
"c:macro:`Py_END_ALLOW_THREADS` without the closing brace."
msgstr ""
"このマクロを展開すると ``PyEval_RestoreThread(_save);`` になります: 閉じ波括"
"弧のない :c:macro:`Py_END_ALLOW_THREADS` と同じです。"

#: ../../c-api/init.rst:1156
msgid ""
"This macro expands to ``_save = PyEval_SaveThread();``: it is equivalent to :"
"c:macro:`Py_BEGIN_ALLOW_THREADS` without the opening brace and variable "
"declaration."
msgstr ""
"このマクロを展開すると ``_save = PyEval_SaveThread();`` になります: 開き波括"
"弧のない :c:macro:`Py_BEGIN_ALLOW_THREADS` と同じです。"

#: ../../c-api/init.rst:1162
msgid "Low-level API"
msgstr "低レベルAPI"

#: ../../c-api/init.rst:1164
msgid ""
"All of the following functions must be called after :c:func:`Py_Initialize`."
msgstr ""
"次の全ての関数は :c:func:`Py_Initialize` の後に呼び出さなければなりません。"

#: ../../c-api/init.rst:1166
msgid ":c:func:`Py_Initialize()` now initializes the :term:`GIL`."
msgstr ""
":c:func:`Py_Initialize()` は :term:`GIL` を初期化するようになりました。"

#: ../../c-api/init.rst:1172
msgid ""
"Create a new interpreter state object.  The global interpreter lock need not "
"be held, but may be held if it is necessary to serialize calls to this "
"function."
msgstr ""
"新しいインタプリタ状態オブジェクトを生成します。GIL を保持しておく必要はあり"
"ませんが、この関数を次々に呼び出す必要がある場合には保持しておいたほうがよい"
"でしょう。"

#: ../../c-api/init.rst:1176
msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython."
"PyInterpreterState_New`` with no arguments."
msgstr ""

#: ../../c-api/init.rst:1181
msgid ""
"Reset all information in an interpreter state object.  The global "
"interpreter lock must be held."
msgstr ""
"インタプリタ状態オブジェクト内の全ての情報をリセットします。GIL を保持してい"
"なければなりません。"

#: ../../c-api/init.rst:1184
msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython."
"PyInterpreterState_Clear`` with no arguments."
msgstr ""

#: ../../c-api/init.rst:1189
msgid ""
"Destroy an interpreter state object.  The global interpreter lock need not "
"be held.  The interpreter state must have been reset with a previous call "
"to :c:func:`PyInterpreterState_Clear`."
msgstr ""
"インタプリタ状態オブジェクトを破壊します。GIL を保持しておく必要はありませ"
"ん。インタプリタ状態は :c:func:`PyInterpreterState_Clear` であらかじめリセッ"
"トしておかなければなりません。"

#: ../../c-api/init.rst:1196
msgid ""
"Create a new thread state object belonging to the given interpreter object. "
"The global interpreter lock need not be held, but may be held if it is "
"necessary to serialize calls to this function."
msgstr ""
"指定したインタプリタオブジェクトに属する新たなスレッド状態オブジェクトを生成"
"します。GIL を保持しておく必要はありませんが、この関数を次々に呼び出す必要が"
"ある場合には保持しておいたほうがよいでしょう。"

#: ../../c-api/init.rst:1203
msgid ""
"Reset all information in a thread state object.  The global interpreter lock "
"must be held."
msgstr ""
"スレッド状態オブジェクト内の全ての情報をリセットします。GIL を保持していなけ"
"ればなりません。"

#: ../../c-api/init.rst:1206
msgid ""
"This function now calls the :c:member:`PyThreadState.on_delete` callback. "
"Previously, that happened in :c:func:`PyThreadState_Delete`."
msgstr ""

#: ../../c-api/init.rst:1213
msgid ""
"Destroy a thread state object.  The global interpreter lock need not be "
"held. The thread state must have been reset with a previous call to :c:func:"
"`PyThreadState_Clear`."
msgstr ""
"スレッド状態オブジェクトを破壊します。GIL を保持する必要はありません。スレッ"
"ド状態は :c:func:`PyThreadState_Clear` であらかじめリセットしておかなければな"
"りません。"

#: ../../c-api/init.rst:1220
msgid ""
"Destroy the current thread state and release the global interpreter lock. "
"Like :c:func:`PyThreadState_Delete`, the global interpreter lock need not be "
"held. The thread state must have been reset with a previous call to :c:func:"
"`PyThreadState_Clear`."
msgstr ""

#: ../../c-api/init.rst:1228
msgid "Get the current frame of the Python thread state *tstate*."
msgstr ""

#: ../../c-api/init.rst:1230
msgid ""
"Return a :term:`strong reference`. Return ``NULL`` if no frame is currently "
"executing."
msgstr ""

#: ../../c-api/init.rst:1233
msgid "See also :c:func:`PyEval_GetFrame`."
msgstr ""

#: ../../c-api/init.rst:1235 ../../c-api/init.rst:1244
#: ../../c-api/init.rst:1253
msgid "*tstate* must not be ``NULL``."
msgstr ""

#: ../../c-api/init.rst:1242
msgid ""
"Get the unique thread state identifier of the Python thread state *tstate*."
msgstr ""

#: ../../c-api/init.rst:1251
msgid "Get the interpreter of the Python thread state *tstate*."
msgstr ""

#: ../../c-api/init.rst:1260
msgid "Suspend tracing and profiling in the Python thread state *tstate*."
msgstr ""

#: ../../c-api/init.rst:1262
msgid "Resume them using the :c:func:`PyThreadState_LeaveTracing` function."
msgstr ""

#: ../../c-api/init.rst:1269
msgid ""
"Resume tracing and profiling in the Python thread state *tstate* suspended "
"by the :c:func:`PyThreadState_EnterTracing` function."
msgstr ""

#: ../../c-api/init.rst:1272
msgid ""
"See also :c:func:`PyEval_SetTrace` and :c:func:`PyEval_SetProfile` functions."
msgstr ""

#: ../../c-api/init.rst:1280
msgid "Get the current interpreter."
msgstr ""

#: ../../c-api/init.rst:1282
msgid ""
"Issue a fatal error if there no current Python thread state or no current "
"interpreter. It cannot return NULL."
msgstr ""

#: ../../c-api/init.rst:1285 ../../c-api/init.rst:1295
msgid "The caller must hold the GIL."
msgstr "呼び出し側はGILを獲得する必要があります"

#: ../../c-api/init.rst:1292
msgid ""
"Return the interpreter's unique ID.  If there was any error in doing so then "
"``-1`` is returned and an error is set."
msgstr ""
"インタプリタの一意な ID を返します。\n"
"処理中に何かエラーが起きたら、 ``-1`` が返され、エラーがセットされます。"

#: ../../c-api/init.rst:1302
msgid ""
"Return a dictionary in which interpreter-specific data may be stored. If "
"this function returns ``NULL`` then no exception has been raised and the "
"caller should assume no interpreter-specific dict is available."
msgstr ""
"インタプリタ固有のデータを保持している辞書を返します。\n"
"この関数が ``NULL`` を返した場合は、ここまでで例外は送出されておらず、呼び出"
"し側はインタプリタ固有の辞書は利用できないと考えなければなりません。"

#: ../../c-api/init.rst:1306
msgid ""
"This is not a replacement for :c:func:`PyModule_GetState()`, which "
"extensions should use to store interpreter-specific state information."
msgstr ""
"この関数は :c:func:`PyModule_GetState()` を置き換えるものではなく、拡張モ"
"ジュールがインタプリタ固有の状態情報を格納するのに使うべきものです。"

#: ../../c-api/init.rst:1313
msgid "Type of a frame evaluation function."
msgstr ""

#: ../../c-api/init.rst:1315
msgid ""
"The *throwflag* parameter is used by the ``throw()`` method of generators: "
"if non-zero, handle the current exception."
msgstr ""

#: ../../c-api/init.rst:1318
msgid "The function now takes a *tstate* parameter."
msgstr ""

#: ../../c-api/init.rst:1321
msgid ""
"The *frame* parameter changed from ``PyFrameObject*`` to "
"``_PyInterpreterFrame*``."
msgstr ""

#: ../../c-api/init.rst:1326
msgid "Get the frame evaluation function."
msgstr ""

#: ../../c-api/init.rst:1328 ../../c-api/init.rst:1336
msgid "See the :pep:`523` \"Adding a frame evaluation API to CPython\"."
msgstr ""

#: ../../c-api/init.rst:1334
msgid "Set the frame evaluation function."
msgstr ""

#: ../../c-api/init.rst:1343
msgid ""
"Return a dictionary in which extensions can store thread-specific state "
"information.  Each extension should use a unique key to use to store state "
"in the dictionary.  It is okay to call this function when no current thread "
"state is available. If this function returns ``NULL``, no exception has been "
"raised and the caller should assume no current thread state is available."
msgstr ""
"拡張モジュールがスレッド固有の状態情報を保存できるような辞書を返します。各々"
"の拡張モジュールが辞書に状態情報を保存するためには唯一のキーを使わなければな"
"りません。現在のスレッド状態がない時にこの関数を呼び出してもかまいません。こ"
"の関数が ``NULL`` を返す場合、例外はまったく送出されず、呼び出し側は現在のス"
"レッド状態が利用できないと考えなければなりません。"

#: ../../c-api/init.rst:1352
msgid ""
"Asynchronously raise an exception in a thread. The *id* argument is the "
"thread id of the target thread; *exc* is the exception object to be raised. "
"This function does not steal any references to *exc*. To prevent naive "
"misuse, you must write your own C extension to call this.  Must be called "
"with the GIL held. Returns the number of thread states modified; this is "
"normally one, but will be zero if the thread id isn't found.  If *exc* is "
"``NULL``, the pending exception (if any) for the thread is cleared. This "
"raises no exceptions."
msgstr ""

#: ../../c-api/init.rst:1360
msgid ""
"The type of the *id* parameter changed from :c:expr:`long` to :c:expr:"
"`unsigned long`."
msgstr ""
"*id* 引数の型が :c:expr:`long` から :c:expr:`unsigned long` へ変更されまし"
"た。"

#: ../../c-api/init.rst:1366
msgid ""
"Acquire the global interpreter lock and set the current thread state to "
"*tstate*, which must not be ``NULL``.  The lock must have been created "
"earlier. If this thread already has the lock, deadlock ensues."
msgstr ""
"GIL を獲得し、現在のスレッド状態を *tstate* に設定します。 *tstate* は "
"``NULL`` であってはなりません。ロックはあらかじめ作成されていなければなりませ"
"ん。この関数を呼び出したスレッドがすでにロックを獲得している場合、デッドロッ"
"クに陥ります。"

#: ../../c-api/init.rst:1377
msgid ""
"Updated to be consistent with :c:func:`PyEval_RestoreThread`, :c:func:"
"`Py_END_ALLOW_THREADS`, and :c:func:`PyGILState_Ensure`, and terminate the "
"current thread if called while the interpreter is finalizing."
msgstr ""

#: ../../c-api/init.rst:1382
msgid ""
":c:func:`PyEval_RestoreThread` is a higher-level function which is always "
"available (even when threads have not been initialized)."
msgstr ""
":c:func:`PyEval_RestoreThread` はいつでも (スレッドが初期化されたいないときで"
"も) 利用可能な高レベル関数です。"

#: ../../c-api/init.rst:1388
msgid ""
"Reset the current thread state to ``NULL`` and release the global "
"interpreter lock.  The lock must have been created earlier and must be held "
"by the current thread.  The *tstate* argument, which must not be ``NULL``, "
"is only used to check that it represents the current thread state --- if it "
"isn't, a fatal error is reported."
msgstr ""
"現在のスレッド状態をリセットして ``NULL`` にし、GIL を解放します。ロックはあ"
"らかじめ作成されていなければならず、かつ現在のスレッドが保持していなければな"
"りません。*tstate* は ``NULL`` であってはなりませんが、その値が現在のスレッド"
"状態を表現しているかどうかを調べるためにだけ使われます --- もしそうでなけれ"
"ば、致命的エラーが報告されます。"

#: ../../c-api/init.rst:1394
msgid ""
":c:func:`PyEval_SaveThread` is a higher-level function which is always "
"available (even when threads have not been initialized)."
msgstr ""
":c:func:`PyEval_SaveThread` はより高レベルな関数で常に (スレッドが初期化され"
"ていないときでも) 利用できます。"

#: ../../c-api/init.rst:1401
msgid "Sub-interpreter support"
msgstr "サブインタプリタサポート"

#: ../../c-api/init.rst:1403
msgid ""
"While in most uses, you will only embed a single Python interpreter, there "
"are cases where you need to create several independent interpreters in the "
"same process and perhaps even in the same thread. Sub-interpreters allow you "
"to do that."
msgstr ""
"ほとんどの場合は埋め込む Python インタプリタは1つだけですが、いくつかの場合に"
"同一プロセス内、あるいは同一スレッド内で、複数の独立したインタプリタを作成す"
"る必要があります。\n"
"これを可能にするのがサブインタプリタです。"

#: ../../c-api/init.rst:1408
msgid ""
"The \"main\" interpreter is the first one created when the runtime "
"initializes. It is usually the only Python interpreter in a process.  Unlike "
"sub-interpreters, the main interpreter has unique process-global "
"responsibilities like signal handling.  It is also responsible for execution "
"during runtime initialization and is usually the active interpreter during "
"runtime finalization.  The :c:func:`PyInterpreterState_Main` function "
"returns a pointer to its state."
msgstr ""
"\"メイン\" インタプリタとは、ランタイムが初期化を行ったときに最初に作成された"
"インタプリタのことです。\n"
"サブインタプリタと違い、メインインタプリタにはシグナルハンドリングのような、"
"プロセス全域で唯一な責務があります。\n"
"メインインタプリタにはランタイムの初期化中の処理実行という責務もあり、通常は"
"ランタイムの終了処理中に動いているランタイムでもあります。\n"
":c:func:`PyInterpreterState_Main` 関数は、メインインタプリタの状態へのポイン"
"タを返します。"

#: ../../c-api/init.rst:1415
msgid ""
"You can switch between sub-interpreters using the :c:func:"
"`PyThreadState_Swap` function. You can create and destroy them using the "
"following functions:"
msgstr ""
"サブインタプリタを切り替えが :c:func:`PyThreadState_Swap` 関数でできます。\n"
"次の関数を使ってサブインタプリタの作成と削除が行えます:"

#: ../../c-api/init.rst:1421
msgid ""
"Structure containing most parameters to configure a sub-interpreter. Its "
"values are used only in :c:func:`Py_NewInterpreterFromConfig` and never "
"modified by the runtime."
msgstr ""

#: ../../c-api/init.rst:1427
msgid "Structure fields:"
msgstr "構造体フィールド:"

#: ../../c-api/init.rst:1431
msgid ""
"If this is ``0`` then the sub-interpreter will use its own \"object\" "
"allocator state. Otherwise it will use (share) the main interpreter's."
msgstr ""

#: ../../c-api/init.rst:1435
msgid ""
"If this is ``0`` then :c:member:`~PyInterpreterConfig."
"check_multi_interp_extensions` must be ``1`` (non-zero). If this is ``1`` "
"then :c:member:`~PyInterpreterConfig.gil` must not be :c:macro:"
"`PyInterpreterConfig_OWN_GIL`."
msgstr ""

#: ../../c-api/init.rst:1443
msgid ""
"If this is ``0`` then the runtime will not support forking the process in "
"any thread where the sub-interpreter is currently active. Otherwise fork is "
"unrestricted."
msgstr ""

#: ../../c-api/init.rst:1447
msgid ""
"Note that the :mod:`subprocess` module still works when fork is disallowed."
msgstr ""

#: ../../c-api/init.rst:1452
msgid ""
"If this is ``0`` then the runtime will not support replacing the current "
"process via exec (e.g. :func:`os.execv`) in any thread where the sub-"
"interpreter is currently active. Otherwise exec is unrestricted."
msgstr ""

#: ../../c-api/init.rst:1457
msgid ""
"Note that the :mod:`subprocess` module still works when exec is disallowed."
msgstr ""

#: ../../c-api/init.rst:1462
msgid ""
"If this is ``0`` then the sub-interpreter's :mod:`threading` module won't "
"create threads. Otherwise threads are allowed."
msgstr ""

#: ../../c-api/init.rst:1468
msgid ""
"If this is ``0`` then the sub-interpreter's :mod:`threading` module won't "
"create daemon threads. Otherwise daemon threads are allowed (as long as :c:"
"member:`~PyInterpreterConfig.allow_threads` is non-zero)."
msgstr ""

#: ../../c-api/init.rst:1475
msgid ""
"If this is ``0`` then all extension modules may be imported, including "
"legacy (single-phase init) modules, in any thread where the sub-interpreter "
"is currently active. Otherwise only multi-phase init extension modules (see :"
"pep:`489`) may be imported. (Also see :c:macro:"
"`Py_mod_multiple_interpreters`.)"
msgstr ""

#: ../../c-api/init.rst:1482
msgid ""
"This must be ``1`` (non-zero) if :c:member:`~PyInterpreterConfig."
"use_main_obmalloc` is ``0``."
msgstr ""

#: ../../c-api/init.rst:1487
msgid ""
"This determines the operation of the GIL for the sub-interpreter. It may be "
"one of the following:"
msgstr ""

#: ../../c-api/init.rst:1494
msgid "Use the default selection (:c:macro:`PyInterpreterConfig_SHARED_GIL`)."
msgstr ""

#: ../../c-api/init.rst:1498
msgid "Use (share) the main interpreter's GIL."
msgstr ""

#: ../../c-api/init.rst:1502
msgid "Use the sub-interpreter's own GIL."
msgstr ""

#: ../../c-api/init.rst:1504
msgid ""
"If this is :c:macro:`PyInterpreterConfig_OWN_GIL` then :c:member:"
"`PyInterpreterConfig.use_main_obmalloc` must be ``0``."
msgstr ""

#: ../../c-api/init.rst:1518
msgid ""
"Create a new sub-interpreter.  This is an (almost) totally separate "
"environment for the execution of Python code.  In particular, the new "
"interpreter has separate, independent versions of all imported modules, "
"including the fundamental modules :mod:`builtins`, :mod:`__main__` and :mod:"
"`sys`.  The table of loaded modules (``sys.modules``) and the module search "
"path (``sys.path``) are also separate.  The new environment has no ``sys."
"argv`` variable.  It has new standard I/O stream file objects ``sys.stdin``, "
"``sys.stdout`` and ``sys.stderr`` (however these refer to the same "
"underlying file descriptors)."
msgstr ""
"新しいサブインタプリタ (sub-interpreter) を生成します。サブインタプリタとは、"
"(ほぼ完全に) 個別に分割された Python コードの実行環境です。特に、新しいサブイ"
"ンタプリタは、 import されるモジュール全てについて個別のバージョンを持ち、こ"
"れには基盤となるモジュール :mod:`builtins`, :mod:`__main__` および :mod:"
"`sys` も含まれます。ロード済みのモジュールからなるテーブル (``sys."
"modules``)  およびモジュール検索パス (``sys.path``) もサブインタプリタ毎に別"
"個のものになります。新たなサブインタプリタ環境には ``sys.argv`` 変数がありま"
"せん。また、サブインタプリタは新たな標準 I/O ストリーム ``sys.stdin``, ``sys."
"stdout``, ``sys.stderr`` を持ちます (とはいえ、これらのストリームは根底にある"
"同じファイル記述子を参照しています)。"

#: ../../c-api/init.rst:1528
msgid ""
"The given *config* controls the options with which the interpreter is "
"initialized."
msgstr ""

#: ../../c-api/init.rst:1531
msgid ""
"Upon success, *tstate_p* will be set to the first thread state created in "
"the new sub-interpreter.  This thread state is made in the current thread "
"state. Note that no actual thread is created; see the discussion of thread "
"states below.  If creation of the new interpreter is unsuccessful, "
"*tstate_p* is set to ``NULL``; no exception is set since the exception state "
"is stored in the current thread state and there may not be a current thread "
"state."
msgstr ""

#: ../../c-api/init.rst:1540
msgid ""
"Like all other Python/C API functions, the global interpreter lock must be "
"held before calling this function and is still held when it returns.  "
"Likewise a current thread state must be set on entry.  On success, the "
"returned thread state will be set as current.  If the sub-interpreter is "
"created with its own GIL then the GIL of the calling interpreter will be "
"released.  When the function returns, the new interpreter's GIL will be held "
"by the current thread and the previously interpreter's GIL will remain "
"released here."
msgstr ""

#: ../../c-api/init.rst:1551
msgid ""
"Sub-interpreters are most effective when isolated from each other, with "
"certain functionality restricted::"
msgstr ""

#: ../../c-api/init.rst:1565
msgid ""
"Note that the config is used only briefly and does not get modified. During "
"initialization the config's values are converted into various :c:type:"
"`PyInterpreterState` values.  A read-only copy of the config may be stored "
"internally on the :c:type:`PyInterpreterState`."
msgstr ""

#: ../../c-api/init.rst:1574
msgid "Extension modules are shared between (sub-)interpreters as follows:"
msgstr ""

#: ../../c-api/init.rst:1576
msgid ""
"For modules using multi-phase initialization, e.g. :c:func:"
"`PyModule_FromDefAndSpec`, a separate module object is created and "
"initialized for each interpreter. Only C-level static and global variables "
"are shared between these module objects."
msgstr ""

#: ../../c-api/init.rst:1582
msgid ""
"For modules using single-phase initialization, e.g. :c:func:"
"`PyModule_Create`, the first time a particular extension is imported, it is "
"initialized normally, and a (shallow) copy of its module's dictionary is "
"squirreled away. When the same extension is imported by another "
"(sub-)interpreter, a new module is initialized and filled with the contents "
"of this copy; the extension's ``init`` function is not called. Objects in "
"the module's dictionary thus end up shared across (sub-)interpreters, which "
"might cause unwanted behavior (see `Bugs and caveats`_ below)."
msgstr ""

#: ../../c-api/init.rst:1593
msgid ""
"Note that this is different from what happens when an extension is imported "
"after the interpreter has been completely re-initialized by calling :c:func:"
"`Py_FinalizeEx` and :c:func:`Py_Initialize`; in that case, the extension's "
"``initmodule`` function *is* called again. As with multi-phase "
"initialization, this means that only C-level static and global variables are "
"shared between these modules."
msgstr ""

#: ../../c-api/init.rst:1613
msgid ""
"Create a new sub-interpreter.  This is essentially just a wrapper around :c:"
"func:`Py_NewInterpreterFromConfig` with a config that preserves the existing "
"behavior.  The result is an unisolated sub-interpreter that shares the main "
"interpreter's GIL, allows fork/exec, allows daemon threads, and allows "
"single-phase init modules."
msgstr ""

#: ../../c-api/init.rst:1625
msgid ""
"Destroy the (sub-)interpreter represented by the given thread state. The "
"given thread state must be the current thread state.  See the discussion of "
"thread states below.  When the call returns, the current thread state is "
"``NULL``.  All thread states associated with this interpreter are "
"destroyed.  The global interpreter lock used by the target interpreter must "
"be held before calling this function.  No GIL is held when it returns."
msgstr ""

#: ../../c-api/init.rst:1633
msgid ""
":c:func:`Py_FinalizeEx` will destroy all sub-interpreters that haven't been "
"explicitly destroyed at that point."
msgstr ""

#: ../../c-api/init.rst:1638
msgid "A Per-Interpreter GIL"
msgstr ""

#: ../../c-api/init.rst:1640
msgid ""
"Using :c:func:`Py_NewInterpreterFromConfig` you can create a sub-interpreter "
"that is completely isolated from other interpreters, including having its "
"own GIL.  The most important benefit of this isolation is that such an "
"interpreter can execute Python code without being blocked by other "
"interpreters or blocking any others.  Thus a single Python process can truly "
"take advantage of multiple CPU cores when running Python code.  The "
"isolation also encourages a different approach to concurrency than that of "
"just using threads. (See :pep:`554`.)"
msgstr ""

#: ../../c-api/init.rst:1650
msgid ""
"Using an isolated interpreter requires vigilance in preserving that "
"isolation.  That especially means not sharing any objects or mutable state "
"without guarantees about thread-safety.  Even objects that are otherwise "
"immutable (e.g. ``None``, ``(1, 5)``) can't normally be shared because of "
"the refcount.  One simple but less-efficient approach around this is to use "
"a global lock around all use of some state (or object). Alternately, "
"effectively immutable objects (like integers or strings) can be made safe in "
"spite of their refcounts by making them :term:`immortal`. In fact, this has "
"been done for the builtin singletons, small integers, and a number of other "
"builtin objects."
msgstr ""

#: ../../c-api/init.rst:1661
msgid ""
"If you preserve isolation then you will have access to proper multi-core "
"computing without the complications that come with free-threading. Failure "
"to preserve isolation will expose you to the full consequences of free-"
"threading, including races and hard-to-debug crashes."
msgstr ""

#: ../../c-api/init.rst:1666
msgid ""
"Aside from that, one of the main challenges of using multiple isolated "
"interpreters is how to communicate between them safely (not break isolation) "
"and efficiently.  The runtime and stdlib do not provide any standard "
"approach to this yet.  A future stdlib module would help mitigate the effort "
"of preserving isolation and expose effective tools for communicating (and "
"sharing) data between interpreters."
msgstr ""

#: ../../c-api/init.rst:1677
msgid "Bugs and caveats"
msgstr "バグと注意事項"

#: ../../c-api/init.rst:1679
msgid ""
"Because sub-interpreters (and the main interpreter) are part of the same "
"process, the insulation between them isn't perfect --- for example, using "
"low-level file operations like  :func:`os.close` they can (accidentally or "
"maliciously) affect each other's open files.  Because of the way extensions "
"are shared between (sub-)interpreters, some extensions may not work "
"properly; this is especially likely when using single-phase initialization "
"or (static) global variables. It is possible to insert objects created in "
"one sub-interpreter into a namespace of another (sub-)interpreter; this "
"should be avoided if possible."
msgstr ""

#: ../../c-api/init.rst:1689
msgid ""
"Special care should be taken to avoid sharing user-defined functions, "
"methods, instances or classes between sub-interpreters, since import "
"operations executed by such objects may affect the wrong (sub-)interpreter's "
"dictionary of loaded modules. It is equally important to avoid sharing "
"objects from which the above are reachable."
msgstr ""

#: ../../c-api/init.rst:1695
msgid ""
"Also note that combining this functionality with ``PyGILState_*`` APIs is "
"delicate, because these APIs assume a bijection between Python thread states "
"and OS-level threads, an assumption broken by the presence of sub-"
"interpreters. It is highly recommended that you don't switch sub-"
"interpreters between a pair of matching :c:func:`PyGILState_Ensure` and :c:"
"func:`PyGILState_Release` calls. Furthermore, extensions (such as :mod:"
"`ctypes`) using these APIs to allow calling of Python code from non-Python "
"created threads will probably be broken when using sub-interpreters."
msgstr ""
"サブインタプリタを ``PyGILState_*`` API と組み合わせるのが難しいことにも注意"
"してください。これらのAPIはPythonのスレッド状態とOSレベルスレッドが1対1で対応"
"していることを前提にしていて、サブインタプリタが存在するとその前提が崩れるか"
"らです。対応する :c:func:`PyGILState_Ensure` と :c:func:`PyGILState_Release` "
"の呼び出しのペアの間では、サブインタプリタの切り替えを行わないことを強く推奨"
"します。さらに、(:mod:`ctypes` のような)これらのAPIを使ってPythonの外で作られ"
"たスレッドから Pythonコードを実行している拡張モジュールはサブインタプリタを使"
"うと壊れる可能性があります。"

#: ../../c-api/init.rst:1706
msgid "Asynchronous Notifications"
msgstr "非同期通知"

#: ../../c-api/init.rst:1708
msgid ""
"A mechanism is provided to make asynchronous notifications to the main "
"interpreter thread.  These notifications take the form of a function pointer "
"and a void pointer argument."
msgstr ""
"インタプリタのメインスレッドに非同期な通知を行うために提供されている仕組みで"
"す。これらの通知は関数ポインタと void ポインタ引数という形態を取ります。"

#: ../../c-api/init.rst:1715
msgid ""
"Schedule a function to be called from the main interpreter thread.  On "
"success, ``0`` is returned and *func* is queued for being called in the main "
"thread.  On failure, ``-1`` is returned without setting any exception."
msgstr ""
"インタプリタのメインスレッドから関数が呼び出される予定を組みます。成功すると "
"``0`` が返り、*func* はメインスレッドの呼び出しキューに詰められます。失敗する"
"と、例外をセットせずに ``-1`` が返ります。"

#: ../../c-api/init.rst:1719
msgid ""
"When successfully queued, *func* will be *eventually* called from the main "
"interpreter thread with the argument *arg*.  It will be called "
"asynchronously with respect to normally running Python code, but with both "
"these conditions met:"
msgstr ""
"無事にキューに詰められると、*func* は *いつかは必ず* インタプリタのメインス"
"レッドから、*arg* を引数として呼び出されます。この関数は、通常の実行中の "
"Python コードに対して非同期に呼び出されますが、次の両方の条件に合致したときに"
"呼び出されます:"

#: ../../c-api/init.rst:1724
msgid "on a :term:`bytecode` boundary;"
msgstr ":term:`bytecode` 境界上にいるとき、"

#: ../../c-api/init.rst:1725
msgid ""
"with the main thread holding the :term:`global interpreter lock` (*func* can "
"therefore use the full C API)."
msgstr ""
"メインスレッドが :term:`global interpreter lock` を保持している (すなわち "
"*func* が全ての C API を呼び出せる) とき。"

#: ../../c-api/init.rst:1728
msgid ""
"*func* must return ``0`` on success, or ``-1`` on failure with an exception "
"set.  *func* won't be interrupted to perform another asynchronous "
"notification recursively, but it can still be interrupted to switch threads "
"if the global interpreter lock is released."
msgstr ""
"成功したら *func* は ``0`` を返さねばならず、失敗したら ``-1`` を返し例外を"
"セットしなければいけません。*func* は、他の非同期通知を行うために、さらに割り"
"込まれることはありませんが、グローバルインタプリタロックが解放された場合は、"
"スレッドの切り替えによって割り込まれる可能性が残っています。"

#: ../../c-api/init.rst:1733
msgid ""
"This function doesn't need a current thread state to run, and it doesn't "
"need the global interpreter lock."
msgstr ""
"この関数は実行するのに現在のスレッド状態を必要とせず、グローバルインタプリタ"
"ロックも必要としません。"

#: ../../c-api/init.rst:1736
msgid ""
"To call this function in a subinterpreter, the caller must hold the GIL. "
"Otherwise, the function *func* can be scheduled to be called from the wrong "
"interpreter."
msgstr ""

#: ../../c-api/init.rst:1741
msgid ""
"This is a low-level function, only useful for very special cases. There is "
"no guarantee that *func* will be called as quick as possible.  If the main "
"thread is busy executing a system call, *func* won't be called before the "
"system call returns.  This function is generally **not** suitable for "
"calling Python code from arbitrary C threads.  Instead, use the :ref:"
"`PyGILState API<gilstate>`."
msgstr ""
"これは、非常に特別な場合にのみ役立つ、低レベルな関数です。 *func* が可能な限"
"り早く呼び出される保証はありません。メインスレッドがシステムコールを実行する"
"のに忙しい場合は、 *func* はシステムコールが返ってくるまで呼び出されないで"
"しょう。この関数は一般的には、任意の C スレッドから Python コードを呼び出すの"
"には **向きません** 。これの代わりに、 :ref:`PyGILState API<gilstate>` を使用"
"してください。"

#: ../../c-api/init.rst:1750
msgid ""
"If this function is called in a subinterpreter, the function *func* is now "
"scheduled to be called from the subinterpreter, rather than being called "
"from the main interpreter. Each subinterpreter now has its own list of "
"scheduled calls."
msgstr ""

#: ../../c-api/init.rst:1759
msgid "Profiling and Tracing"
msgstr "プロファイルとトレース (profiling and tracing)"

#: ../../c-api/init.rst:1764
msgid ""
"The Python interpreter provides some low-level support for attaching "
"profiling and execution tracing facilities.  These are used for profiling, "
"debugging, and coverage analysis tools."
msgstr ""
"Python インタプリタは、プロファイル: 分析 (profile) や実行のトレース: 追跡 "
"(trace) といった機能を組み込むために低水準のサポートを提供しています。このサ"
"ポートは、プロファイルやデバッグ、適用範囲分析 (coverage analysis) ツールなど"
"に使われます。"

#: ../../c-api/init.rst:1768
msgid ""
"This C interface allows the profiling or tracing code to avoid the overhead "
"of calling through Python-level callable objects, making a direct C function "
"call instead.  The essential attributes of the facility have not changed; "
"the interface allows trace functions to be installed per-thread, and the "
"basic events reported to the trace function are the same as had been "
"reported to the Python-level trace functions in previous versions."
msgstr ""
"この C インターフェースは、プロファイルやトレース作業時に、Python レベルの呼"
"び出し可能オブジェクトが呼び出されることによるオーバヘッドを避け、直接 C 関数"
"呼び出しが行えるようにしています。プロファイルやトレース機能の本質的な特性は"
"変わっていません; インターフェースではトレース関数をスレッドごとにインストー"
"ルでき、トレース関数に報告される基本イベント (basic event) は以前のバージョン"
"において Python レベルのトレース関数で報告されていたものと同じです。"

#: ../../c-api/init.rst:1778
msgid ""
"The type of the trace function registered using :c:func:`PyEval_SetProfile` "
"and :c:func:`PyEval_SetTrace`. The first parameter is the object passed to "
"the registration function as *obj*, *frame* is the frame object to which the "
"event pertains, *what* is one of the constants :c:data:`PyTrace_CALL`, :c:"
"data:`PyTrace_EXCEPTION`, :c:data:`PyTrace_LINE`, :c:data:`PyTrace_RETURN`, :"
"c:data:`PyTrace_C_CALL`, :c:data:`PyTrace_C_EXCEPTION`, :c:data:"
"`PyTrace_C_RETURN`, or :c:data:`PyTrace_OPCODE`, and *arg* depends on the "
"value of *what*:"
msgstr ""

#: ../../c-api/init.rst:1787
msgid "Value of *what*"
msgstr "*what* の値"

#: ../../c-api/init.rst:1787
msgid "Meaning of *arg*"
msgstr "*arg* の意味"

#: ../../c-api/init.rst:1789
msgid ":c:data:`PyTrace_CALL`"
msgstr ""

#: ../../c-api/init.rst:1789 ../../c-api/init.rst:1794
#: ../../c-api/init.rst:1805
msgid "Always :c:data:`Py_None`."
msgstr "常に :c:data:`Py_None` 。"

#: ../../c-api/init.rst:1791
msgid ":c:data:`PyTrace_EXCEPTION`"
msgstr ""

#: ../../c-api/init.rst:1791
msgid "Exception information as returned by :func:`sys.exc_info`."
msgstr ":func:`sys.exc_info` の返す例外情報です。"

#: ../../c-api/init.rst:1794
msgid ":c:data:`PyTrace_LINE`"
msgstr ""

#: ../../c-api/init.rst:1796
msgid ":c:data:`PyTrace_RETURN`"
msgstr ""

#: ../../c-api/init.rst:1796
msgid ""
"Value being returned to the caller, or ``NULL`` if caused by an exception."
msgstr ""
"呼び出し側に返される予定の値か、例外によって関数を抜ける場合は ``NULL`` で"
"す。"

#: ../../c-api/init.rst:1799
msgid ":c:data:`PyTrace_C_CALL`"
msgstr ""

#: ../../c-api/init.rst:1799 ../../c-api/init.rst:1801
#: ../../c-api/init.rst:1803
msgid "Function object being called."
msgstr "呼び出される関数オブジェクト。"

#: ../../c-api/init.rst:1801
msgid ":c:data:`PyTrace_C_EXCEPTION`"
msgstr ""

#: ../../c-api/init.rst:1803
msgid ":c:data:`PyTrace_C_RETURN`"
msgstr ""

#: ../../c-api/init.rst:1805
msgid ":c:data:`PyTrace_OPCODE`"
msgstr ""

#: ../../c-api/init.rst:1810
msgid ""
"The value of the *what* parameter to a :c:type:`Py_tracefunc` function when "
"a new call to a function or method is being reported, or a new entry into a "
"generator. Note that the creation of the iterator for a generator function "
"is not reported as there is no control transfer to the Python bytecode in "
"the corresponding frame."
msgstr ""
"関数やメソッドが新たに呼び出されたり、ジェネレータが新たなエントリの処理に"
"入ったことを報告する際の、 :c:type:`Py_tracefunc` の *what* の値です。イテ"
"レータやジェネレータ関数の生成は、対応するフレーム内の Python バイトコードに"
"制御の委譲 (control transfer) が起こらないため報告されないので注意してくださ"
"い。"

#: ../../c-api/init.rst:1819
msgid ""
"The value of the *what* parameter to a :c:type:`Py_tracefunc` function when "
"an exception has been raised.  The callback function is called with this "
"value for *what* when after any bytecode is processed after which the "
"exception becomes set within the frame being executed.  The effect of this "
"is that as exception propagation causes the Python stack to unwind, the "
"callback is called upon return to each frame as the exception propagates.  "
"Only trace functions receives these events; they are not needed by the "
"profiler."
msgstr ""
"例外が送出された際の :c:type:`Py_tracefunc` の *what* の値です。現在実行され"
"ているフレームで例外がセットされ、何らかのバイトコードが処理された後に、 "
"*what* にこの値がセットされた状態でコールバック関数が呼び出されます。この結"
"果、例外の伝播によって Python が呼び出しスタックを逆戻りする際に、各フレーム"
"から処理が戻るごとにコールバック関数が呼び出されます。トレース関数だけがこれ"
"らのイベントを受け取ります; プロファイラはこの種のイベントを必要としません。"

#: ../../c-api/init.rst:1830
msgid ""
"The value passed as the *what* parameter to a :c:type:`Py_tracefunc` "
"function (but not a profiling function) when a line-number event is being "
"reported. It may be disabled for a frame by setting :attr:`~frame."
"f_trace_lines` to *0* on that frame."
msgstr ""

#: ../../c-api/init.rst:1838
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a call is about to return."
msgstr ""
"呼び出しが返るときに :c:type:`Py_tracefunc` 関数に *what* 引数として渡す値で"
"す。"

#: ../../c-api/init.rst:1844
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a C function is about to be called."
msgstr ""
"C関数を呼び出す直前に :c:type:`Py_tracefunc` 関数の *what* 引数として渡す値で"
"す。"

#: ../../c-api/init.rst:1850
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a C function has raised an exception."
msgstr ""
"C関数が例外を送出したときに :c:type:`Py_tracefunc` 関数の *what* 引数として渡"
"す値です。"

#: ../../c-api/init.rst:1856
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a C function has returned."
msgstr ""
"C関数から戻るときに :c:type:`Py_tracefunc` 関数の *what* 引数として渡す値で"
"す。"

#: ../../c-api/init.rst:1862
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions (but "
"not profiling functions) when a new opcode is about to be executed.  This "
"event is not emitted by default: it must be explicitly requested by setting :"
"attr:`~frame.f_trace_opcodes` to *1* on the frame."
msgstr ""

#: ../../c-api/init.rst:1870
msgid ""
"Set the profiler function to *func*.  The *obj* parameter is passed to the "
"function as its first parameter, and may be any Python object, or ``NULL``.  "
"If the profile function needs to maintain state, using a different value for "
"*obj* for each thread provides a convenient and thread-safe place to store "
"it.  The profile function is called for all monitored events except :c:data:"
"`PyTrace_LINE` :c:data:`PyTrace_OPCODE` and :c:data:`PyTrace_EXCEPTION`."
msgstr ""

#: ../../c-api/init.rst:1877
msgid "See also the :func:`sys.setprofile` function."
msgstr ":func:`sys.setprofile` 関数も参照してください。"

#: ../../c-api/init.rst:1879 ../../c-api/init.rst:1886
#: ../../c-api/init.rst:1905 ../../c-api/init.rst:1912
msgid "The caller must hold the :term:`GIL`."
msgstr "呼び出し側は :term:`GIL` を獲得しなければなりません。"

#: ../../c-api/init.rst:1883
msgid ""
"Like :c:func:`PyEval_SetProfile` but sets the profile function in all "
"running threads belonging to the current interpreter instead of the setting "
"it only on the current thread."
msgstr ""

#: ../../c-api/init.rst:1888
msgid ""
"As :c:func:`PyEval_SetProfile`, this function ignores any exceptions raised "
"while setting the profile functions in all threads."
msgstr ""

#: ../../c-api/init.rst:1896
msgid ""
"Set the tracing function to *func*.  This is similar to :c:func:"
"`PyEval_SetProfile`, except the tracing function does receive line-number "
"events and per-opcode events, but does not receive any event related to C "
"function objects being called.  Any trace function registered using :c:func:"
"`PyEval_SetTrace` will not receive :c:data:`PyTrace_C_CALL`, :c:data:"
"`PyTrace_C_EXCEPTION` or :c:data:`PyTrace_C_RETURN` as a value for the "
"*what* parameter."
msgstr ""

#: ../../c-api/init.rst:1903
msgid "See also the :func:`sys.settrace` function."
msgstr ":func:`sys.settrace` 関数も参照してください。"

#: ../../c-api/init.rst:1909
msgid ""
"Like :c:func:`PyEval_SetTrace` but sets the tracing function in all running "
"threads belonging to the current interpreter instead of the setting it only "
"on the current thread."
msgstr ""

#: ../../c-api/init.rst:1914
msgid ""
"As :c:func:`PyEval_SetTrace`, this function ignores any exceptions raised "
"while setting the trace functions in all threads."
msgstr ""

#: ../../c-api/init.rst:1920
msgid "Reference tracing"
msgstr ""

#: ../../c-api/init.rst:1926
msgid ""
"The type of the trace function registered using :c:func:"
"`PyRefTracer_SetTracer`. The first parameter is a Python object that has "
"been just created (when **event** is set to :c:data:`PyRefTracer_CREATE`) or "
"about to be destroyed (when **event** is set to :c:data:"
"`PyRefTracer_DESTROY`). The **data** argument is the opaque pointer that was "
"provided when :c:func:`PyRefTracer_SetTracer` was called."
msgstr ""

#: ../../c-api/init.rst:1936
msgid ""
"The value for the *event* parameter to :c:type:`PyRefTracer` functions when "
"a Python object has been created."
msgstr ""

#: ../../c-api/init.rst:1941
msgid ""
"The value for the *event* parameter to :c:type:`PyRefTracer` functions when "
"a Python object has been destroyed."
msgstr ""

#: ../../c-api/init.rst:1946
msgid ""
"Register a reference tracer function. The function will be called when a new "
"Python has been created or when an object is going to be destroyed. If "
"**data** is provided it must be an opaque pointer that will be provided when "
"the tracer function is called. Return ``0`` on success. Set an exception and "
"return ``-1`` on error."
msgstr ""

#: ../../c-api/init.rst:1952
msgid ""
"Not that tracer functions **must not** create Python objects inside or "
"otherwise the call will be re-entrant. The tracer also **must not** clear "
"any existing exception or set an exception.  The GIL will be held every time "
"the tracer function is called."
msgstr ""

#: ../../c-api/init.rst:1957 ../../c-api/init.rst:1968
msgid "The GIL must be held when calling this function."
msgstr ""

#: ../../c-api/init.rst:1963
msgid ""
"Get the registered reference tracer function and the value of the opaque "
"data pointer that was registered when :c:func:`PyRefTracer_SetTracer` was "
"called. If no tracer was registered this function will return NULL and will "
"set the **data** pointer to NULL."
msgstr ""

#: ../../c-api/init.rst:1975
msgid "Advanced Debugger Support"
msgstr "高度なデバッガサポート (advanced debugger support)"

#: ../../c-api/init.rst:1980
msgid ""
"These functions are only intended to be used by advanced debugging tools."
msgstr "以下の関数は高度なデバッグツールでの使用のためだけのものです。"

#: ../../c-api/init.rst:1985
msgid ""
"Return the interpreter state object at the head of the list of all such "
"objects."
msgstr ""
"インタプリタ状態オブジェクトからなるリストのうち、先頭にあるものを返します。"

#: ../../c-api/init.rst:1990
msgid "Return the main interpreter state object."
msgstr "メインインタプリタの状態オブジェクトを返します。"

#: ../../c-api/init.rst:1995
msgid ""
"Return the next interpreter state object after *interp* from the list of all "
"such objects."
msgstr ""
"インタプリタ状態オブジェクトからなるリストのうち、*interp* の次にあるものを返"
"します。"

#: ../../c-api/init.rst:2001
msgid ""
"Return the pointer to the first :c:type:`PyThreadState` object in the list "
"of threads associated with the interpreter *interp*."
msgstr ""
"インタプリタ *interp* に関連付けられているスレッドからなるリストのうち、先頭"
"にある :c:type:`PyThreadState` オブジェクトを返します。"

#: ../../c-api/init.rst:2007
msgid ""
"Return the next thread state object after *tstate* from the list of all such "
"objects belonging to the same :c:type:`PyInterpreterState` object."
msgstr ""
"*tstate* と同じ :c:type:`PyInterpreterState` オブジェクトに属しているスレッド"
"状態オブジェクトのうち、 *tstate* の次にあるものを返します。"

#: ../../c-api/init.rst:2014
msgid "Thread Local Storage Support"
msgstr "スレッドローカルストレージのサポート"

#: ../../c-api/init.rst:2018
msgid ""
"The Python interpreter provides low-level support for thread-local storage "
"(TLS) which wraps the underlying native TLS implementation to support the "
"Python-level thread local storage API (:class:`threading.local`).  The "
"CPython C level APIs are similar to those offered by pthreads and Windows: "
"use a thread key and functions to associate a :c:expr:`void*` value per "
"thread."
msgstr ""
"Python インタプリタは、スレッドローカルストレージ (thread-local storage, "
"TLS) の低レベルサポートを提供していて、ネイティブの TLS 実装を内部にラップし"
"て Python レベルのスレッドローカルストレージ API (:class:`threading.local`) "
"をサポートしています。\n"
"CPython の C レベル API は pthreads や Windows で与えられる TLS と同様です: "
"スレッドキーとスレッドごとに :c:expr:`void*` 値を関係付ける関数を使います。"

#: ../../c-api/init.rst:2025
msgid ""
"The GIL does *not* need to be held when calling these functions; they supply "
"their own locking."
msgstr ""
"API で使われる関数を呼ぶときは、 GIL を取得する必要は *ありません* 。関数自身"
"のロックがサポートされています。"

#: ../../c-api/init.rst:2028
msgid ""
"Note that :file:`Python.h` does not include the declaration of the TLS APIs, "
"you need to include :file:`pythread.h` to use thread-local storage."
msgstr ""
":file:`Python.h` は TLS API の宣言を include せず、スレッドローカルストレージ"
"を使うには :file:`pythread.h` を include する必要があることに注意してくださ"
"い。"

#: ../../c-api/init.rst:2032
msgid ""
"None of these API functions handle memory management on behalf of the :c:"
"expr:`void*` values.  You need to allocate and deallocate them yourself. If "
"the :c:expr:`void*` values happen to be :c:expr:`PyObject*`, these functions "
"don't do refcount operations on them either."
msgstr ""
"この API 関数はどれも :c:expr:`void*` 値の代わりにメモリ管理を行うことはしま"
"せん。\n"
"メモリの確保と解放は自前で行う必要があります。\n"
":c:expr:`void*` 値がたまたま :c:expr:`PyObject*` だった場合は、 API 関数はそ"
"れぞれの値の参照カウントの操作は行いません。"

#: ../../c-api/init.rst:2040
msgid "Thread Specific Storage (TSS) API"
msgstr "スレッド固有ストレージ (Thread Specific Storage, TSS) API"

#: ../../c-api/init.rst:2042
msgid ""
"TSS API is introduced to supersede the use of the existing TLS API within "
"the CPython interpreter.  This API uses a new type :c:type:`Py_tss_t` "
"instead of :c:expr:`int` to represent thread keys."
msgstr ""
"TSS API は、 CPython インタプリタに含まれている既存の TLS API を置き換えるた"
"めに導入されました。\n"
"この API は、スレッドキーの表現に :c:expr:`int` の代わりに新しい型 :c:type:"
"`Py_tss_t` を使います。"

#: ../../c-api/init.rst:2048
msgid "\"A New C-API for Thread-Local Storage in CPython\" (:pep:`539`)"
msgstr ""
"\"CPython のスレッドローカルストレージのための新しい C API\" (:pep:`539`)"

#: ../../c-api/init.rst:2053
msgid ""
"This data structure represents the state of a thread key, the definition of "
"which may depend on the underlying TLS implementation, and it has an "
"internal field representing the key's initialization state.  There are no "
"public members in this structure."
msgstr ""
"このデータ構造体はスレッドキーの状態を表現しています。この構造体の定義は、根"
"底の TLS 実装に依存し、キーの初期化状態を表現する内部フィールドを持ちます。\n"
"この構造体には公開 (public) のメンバはありません。"

#: ../../c-api/init.rst:2058
msgid ""
"When :ref:`Py_LIMITED_API <stable>` is not defined, static allocation of "
"this type by :c:macro:`Py_tss_NEEDS_INIT` is allowed."
msgstr ""
":ref:`Py_LIMITED_API <stable>` が定義されていないときは、この型の :c:macro:"
"`Py_tss_NEEDS_INIT` による静的メモリ確保ができます。"

#: ../../c-api/init.rst:2064
msgid ""
"This macro expands to the initializer for :c:type:`Py_tss_t` variables. Note "
"that this macro won't be defined with :ref:`Py_LIMITED_API <stable>`."
msgstr ""
"このマクロは :c:type:`Py_tss_t` 変数の初期化子に展開されます。\n"
"このマクロは :ref:`Py_LIMITED_API <stable>` があるときは定義されません。"

#: ../../c-api/init.rst:2069
msgid "Dynamic Allocation"
msgstr "動的メモリ確保"

#: ../../c-api/init.rst:2071
msgid ""
"Dynamic allocation of the :c:type:`Py_tss_t`, required in extension modules "
"built with :ref:`Py_LIMITED_API <stable>`, where static allocation of this "
"type is not possible due to its implementation being opaque at build time."
msgstr ""
"動的な :c:type:`Py_tss_t` のメモリ確保は :ref:`Py_LIMITED_API <stable>` でビ"
"ルドされた拡張モジュールで必要になりますが、その実装がビルド時に不透明なため"
"に、この型の静的なメモリ確保は不可能です。"

#: ../../c-api/init.rst:2078
msgid ""
"Return a value which is the same state as a value initialized with :c:macro:"
"`Py_tss_NEEDS_INIT`, or ``NULL`` in the case of dynamic allocation failure."
msgstr ""

#: ../../c-api/init.rst:2085
msgid ""
"Free the given *key* allocated by :c:func:`PyThread_tss_alloc`, after first "
"calling :c:func:`PyThread_tss_delete` to ensure any associated thread locals "
"have been unassigned. This is a no-op if the *key* argument is ``NULL``."
msgstr ""

#: ../../c-api/init.rst:2091
msgid ""
"A freed key becomes a dangling pointer. You should reset the key to ``NULL``."
msgstr ""

#: ../../c-api/init.rst:2096
msgid "Methods"
msgstr "メソッド"

#: ../../c-api/init.rst:2098
msgid ""
"The parameter *key* of these functions must not be ``NULL``.  Moreover, the "
"behaviors of :c:func:`PyThread_tss_set` and :c:func:`PyThread_tss_get` are "
"undefined if the given :c:type:`Py_tss_t` has not been initialized by :c:"
"func:`PyThread_tss_create`."
msgstr ""

#: ../../c-api/init.rst:2106
msgid ""
"Return a non-zero value if the given :c:type:`Py_tss_t` has been initialized "
"by :c:func:`PyThread_tss_create`."
msgstr ""

#: ../../c-api/init.rst:2112
msgid ""
"Return a zero value on successful initialization of a TSS key.  The behavior "
"is undefined if the value pointed to by the *key* argument is not "
"initialized by :c:macro:`Py_tss_NEEDS_INIT`.  This function can be called "
"repeatedly on the same key -- calling it on an already initialized key is a "
"no-op and immediately returns success."
msgstr ""

#: ../../c-api/init.rst:2121
msgid ""
"Destroy a TSS key to forget the values associated with the key across all "
"threads, and change the key's initialization state to uninitialized.  A "
"destroyed key is able to be initialized again by :c:func:"
"`PyThread_tss_create`. This function can be called repeatedly on the same "
"key -- calling it on an already destroyed key is a no-op."
msgstr ""

#: ../../c-api/init.rst:2130
msgid ""
"Return a zero value to indicate successfully associating a :c:expr:`void*` "
"value with a TSS key in the current thread.  Each thread has a distinct "
"mapping of the key to a :c:expr:`void*` value."
msgstr ""

#: ../../c-api/init.rst:2137
msgid ""
"Return the :c:expr:`void*` value associated with a TSS key in the current "
"thread.  This returns ``NULL`` if no value is associated with the key in the "
"current thread."
msgstr ""

#: ../../c-api/init.rst:2145
msgid "Thread Local Storage (TLS) API"
msgstr "スレッドローカルストレージ (TLS) API"

#: ../../c-api/init.rst:2147
msgid ""
"This API is superseded by :ref:`Thread Specific Storage (TSS) API <thread-"
"specific-storage-api>`."
msgstr ""

#: ../../c-api/init.rst:2152
msgid ""
"This version of the API does not support platforms where the native TLS key "
"is defined in a way that cannot be safely cast to ``int``.  On such "
"platforms, :c:func:`PyThread_create_key` will return immediately with a "
"failure status, and the other TLS functions will all be no-ops on such "
"platforms."
msgstr ""

#: ../../c-api/init.rst:2157
msgid ""
"Due to the compatibility problem noted above, this version of the API should "
"not be used in new code."
msgstr ""
"前述の互換性の問題により、このバージョンのAPIは新規のコードで利用すべきではあ"
"りません。"

#: ../../c-api/init.rst:2168
msgid "Synchronization Primitives"
msgstr "同期プリミティブ"

#: ../../c-api/init.rst:2170
msgid "The C-API provides a basic mutual exclusion lock."
msgstr ""

#: ../../c-api/init.rst:2174
msgid ""
"A mutual exclusion lock.  The :c:type:`!PyMutex` should be initialized to "
"zero to represent the unlocked state.  For example::"
msgstr ""

#: ../../c-api/init.rst:2179
msgid ""
"Instances of :c:type:`!PyMutex` should not be copied or moved.  Both the "
"contents and address of a :c:type:`!PyMutex` are meaningful, and it must "
"remain at a fixed, writable location in memory."
msgstr ""

#: ../../c-api/init.rst:2185
msgid ""
"A :c:type:`!PyMutex` currently occupies one byte, but the size should be "
"considered unstable.  The size may change in future Python releases without "
"a deprecation period."
msgstr ""

#: ../../c-api/init.rst:2193
msgid ""
"Lock mutex *m*.  If another thread has already locked it, the calling thread "
"will block until the mutex is unlocked.  While blocked, the thread will "
"temporarily release the :term:`GIL` if it is held."
msgstr ""

#: ../../c-api/init.rst:2201
msgid ""
"Unlock mutex *m*. The mutex must be locked --- otherwise, the function will "
"issue a fatal error."
msgstr ""

#: ../../c-api/init.rst:2209
msgid "Python Critical Section API"
msgstr ""

#: ../../c-api/init.rst:2211
msgid ""
"The critical section API provides a deadlock avoidance layer on top of per-"
"object locks for :term:`free-threaded <free threading>` CPython.  They are "
"intended to replace reliance on the :term:`global interpreter lock`, and are "
"no-ops in versions of Python with the global interpreter lock."
msgstr ""

#: ../../c-api/init.rst:2216
msgid ""
"Critical sections avoid deadlocks by implicitly suspending active critical "
"sections and releasing the locks during calls to :c:func:"
"`PyEval_SaveThread`. When :c:func:`PyEval_RestoreThread` is called, the most "
"recent critical section is resumed, and its locks reacquired.  This means "
"the critical section API provides weaker guarantees than traditional locks "
"-- they are useful because their behavior is similar to the :term:`GIL`."
msgstr ""

#: ../../c-api/init.rst:2223
msgid ""
"The functions and structs used by the macros are exposed for cases where C "
"macros are not available. They should only be used as in the given macro "
"expansions. Note that the sizes and contents of the structures may change in "
"future Python versions."
msgstr ""

#: ../../c-api/init.rst:2230
msgid ""
"Operations that need to lock two objects at once must use :c:macro:"
"`Py_BEGIN_CRITICAL_SECTION2`.  You *cannot* use nested critical sections to "
"lock more than one object at once, because the inner critical section may "
"suspend the outer critical sections.  This API does not provide a way to "
"lock more than two objects at once."
msgstr ""

#: ../../c-api/init.rst:2236
msgid "Example usage::"
msgstr "使用例::"

#: ../../c-api/init.rst:2247
msgid ""
"In the above example, :c:macro:`Py_SETREF` calls :c:macro:`Py_DECREF`, which "
"can call arbitrary code through an object's deallocation function.  The "
"critical section API avoids potentital deadlocks due to reentrancy and lock "
"ordering by allowing the runtime to temporarily suspend the critical section "
"if the code triggered by the finalizer blocks and calls :c:func:"
"`PyEval_SaveThread`."
msgstr ""

#: ../../c-api/init.rst:2255
msgid ""
"Acquires the per-object lock for the object *op* and begins a critical "
"section."
msgstr ""

#: ../../c-api/init.rst:2258 ../../c-api/init.rst:2272
#: ../../c-api/init.rst:2287 ../../c-api/init.rst:2301
msgid "In the free-threaded build, this macro expands to::"
msgstr ""

#: ../../c-api/init.rst:2264 ../../c-api/init.rst:2293
msgid "In the default build, this macro expands to ``{``."
msgstr ""

#: ../../c-api/init.rst:2270
msgid "Ends the critical section and releases the per-object lock."
msgstr ""

#: ../../c-api/init.rst:2277 ../../c-api/init.rst:2306
msgid "In the default build, this macro expands to ``}``."
msgstr ""

#: ../../c-api/init.rst:2283
msgid ""
"Acquires the per-objects locks for the objects *a* and *b* and begins a "
"critical section.  The locks are acquired in a consistent order (lowest "
"address first) to avoid lock ordering deadlocks."
msgstr ""

#: ../../c-api/init.rst:2299
msgid "Ends the critical section and releases the per-object locks."
msgstr ""

#: ../../c-api/init.rst:335
msgid "PyEval_InitThreads()"
msgstr "PyEval_InitThreads()"

#: ../../c-api/init.rst:335
msgid "modules (in module sys)"
msgstr "modules (in module sys)"

#: ../../c-api/init.rst:335 ../../c-api/init.rst:576
msgid "path (in module sys)"
msgstr "path (sys モジュール)"

#: ../../c-api/init.rst:335 ../../c-api/init.rst:576 ../../c-api/init.rst:1011
#: ../../c-api/init.rst:1510 ../../c-api/init.rst:1605
msgid "module"
msgstr "module"

#: ../../c-api/init.rst:335 ../../c-api/init.rst:1510 ../../c-api/init.rst:1605
msgid "builtins"
msgstr "builtins"

#: ../../c-api/init.rst:335 ../../c-api/init.rst:1510 ../../c-api/init.rst:1605
msgid "__main__"
msgstr "__main__"

#: ../../c-api/init.rst:335 ../../c-api/init.rst:1510 ../../c-api/init.rst:1605
msgid "sys"
msgstr "sys"

#: ../../c-api/init.rst:335 ../../c-api/init.rst:576
msgid "search"
msgstr "検索"

#: ../../c-api/init.rst:335 ../../c-api/init.rst:576
msgid "path"
msgstr "パス"

#: ../../c-api/init.rst:335 ../../c-api/init.rst:1570 ../../c-api/init.rst:1623
msgid "Py_FinalizeEx (C function)"
msgstr ""

#: ../../c-api/init.rst:445
msgid "Py_Initialize()"
msgstr "Py_Initialize()"

#: ../../c-api/init.rst:445 ../../c-api/init.rst:674
msgid "main()"
msgstr "main()"

#: ../../c-api/init.rst:445
msgid "Py_GetPath()"
msgstr "Py_GetPath()"

#: ../../c-api/init.rst:555
msgid "executable (in module sys)"
msgstr "executable (in module sys)"

#: ../../c-api/init.rst:609 ../../c-api/init.rst:651 ../../c-api/init.rst:665
msgid "version (in module sys)"
msgstr "version (in module sys)"

#: ../../c-api/init.rst:621
msgid "platform (in module sys)"
msgstr "platform (in module sys)"

#: ../../c-api/init.rst:638
msgid "copyright (in module sys)"
msgstr "copyright (in module sys)"

#: ../../c-api/init.rst:674
msgid "Py_FatalError()"
msgstr "Py_FatalError()"

#: ../../c-api/init.rst:674
msgid "argv (in module sys)"
msgstr "argv (in module sys)"

#: ../../c-api/init.rst:794
msgid "global interpreter lock"
msgstr "global interpreter lock"

#: ../../c-api/init.rst:794
msgid "interpreter lock"
msgstr "interpreter lock"

#: ../../c-api/init.rst:794
msgid "lock, interpreter"
msgstr "lock, interpreter"

#: ../../c-api/init.rst:807
msgid "setswitchinterval (in module sys)"
msgstr ""

#: ../../c-api/init.rst:816
msgid "PyThreadState (C type)"
msgstr ""

#: ../../c-api/init.rst:842
msgid "Py_BEGIN_ALLOW_THREADS (C macro)"
msgstr ""

#: ../../c-api/init.rst:842
msgid "Py_END_ALLOW_THREADS (C macro)"
msgstr ""

#: ../../c-api/init.rst:858
msgid "PyEval_RestoreThread (C function)"
msgstr ""

#: ../../c-api/init.rst:858
msgid "PyEval_SaveThread (C function)"
msgstr ""

#: ../../c-api/init.rst:989
msgid "PyEval_AcquireThread()"
msgstr "PyEval_AcquireThread()"

#: ../../c-api/init.rst:989
msgid "PyEval_ReleaseThread()"
msgstr "PyEval_ReleaseThread()"

#: ../../c-api/init.rst:989
msgid "PyEval_SaveThread()"
msgstr "PyEval_SaveThread()"

#: ../../c-api/init.rst:989
msgid "PyEval_RestoreThread()"
msgstr "PyEval_RestoreThread()"

#: ../../c-api/init.rst:1011
msgid "_thread"
msgstr "_thread"

#: ../../c-api/init.rst:1510 ../../c-api/init.rst:1605
msgid "stdout (in module sys)"
msgstr "stdout (sys モジュール)"

#: ../../c-api/init.rst:1510 ../../c-api/init.rst:1605
msgid "stderr (in module sys)"
msgstr "stderr (sys モジュール)"

#: ../../c-api/init.rst:1510 ../../c-api/init.rst:1605
msgid "stdin (in module sys)"
msgstr "stdin (sys モジュール)"

#: ../../c-api/init.rst:1570
msgid "Py_Initialize (C function)"
msgstr ""

#: ../../c-api/init.rst:1600
msgid "close (in module os)"
msgstr ""
