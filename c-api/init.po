# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# tomo, 2019
# Tetsuo Koyama <tkoyama010@gmail.com>, 2020
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-09 18:48+0900\n"
"PO-Revision-Date: 2018-06-29 17:51+0000\n"
"Last-Translator: Tetsuo Koyama <tkoyama010@gmail.com>, 2020\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/init.rst:8
msgid "Initialization, Finalization, and Threads"
msgstr "初期化 (initialization)、終了処理 (finalization)、スレッド"

#: ../../c-api/init.rst:12
msgid "Initializing and finalizing the interpreter"
msgstr "インタプリタの初期化と終了処理"

#: ../../c-api/init.rst:30
msgid ""
"Initialize the Python interpreter.  In an application embedding  Python, "
"this should be called before using any other Python/C API functions; with "
"the exception of :c:func:`Py_SetProgramName`, :c:func:`Py_SetPythonHome` "
"and :c:func:`Py_SetPath`.  This initializes the table of loaded modules "
"(``sys.modules``), and creates the fundamental modules :mod:`builtins`, :mod:"
"`__main__` and :mod:`sys`.  It also initializes the module search path "
"(``sys.path``). It does not set ``sys.argv``; use :c:func:`PySys_SetArgvEx` "
"for that.  This is a no-op when called for a second time (without calling :c:"
"func:`Py_FinalizeEx` first).  There is no return value; it is a fatal error "
"if the initialization fails."
msgstr ""
"Python インタプリタを初期化します。 Python の埋め込みを行うアプリケーションで"
"は、他のあらゆる Python/C API を使用するよりも前にこの関数を呼び出さなければ"
"なりません。ただし、 :c:func:`Py_SetProgramName`, :c:func:"
"`Py_SetPythonHome`, および :c:func:`Py_SetPath` は例外です。この関数はロード"
"済みモジュールのテーブル (``sys.modules``) を初期化し、基盤となるモジュール"
"群、 :mod:`builtins`, :mod:`__main__`, :mod:`sys` を生成します。また、モ"
"ジュール検索パス   (``sys.path``) も初期化します。 ``sys.argv`` の設定は行い"
"ません。設定するには、 :c:func:`PySys_SetArgvEx` を使ってください。この関数"
"を (:c:func:`Py_FinalizeEx` を呼ばずに) 再度呼び出しても何も行いません。戻り"
"値はありません。初期化が失敗すれば、それは致命的なエラーです。"

#: ../../c-api/init.rst:41
msgid ""
"On Windows, changes the console mode from ``O_TEXT`` to ``O_BINARY``, which "
"will also affect non-Python uses of the console using the C Runtime."
msgstr ""
"Windows では ``O_TEXT`` から ``O_BINARY`` へコンソールモードが変更されます"
"が、これはその C ランタイムを使っているコンソールでの Python 以外の使い勝手に"
"も影響を及ぼします。"

#: ../../c-api/init.rst:47
msgid ""
"This function works like :c:func:`Py_Initialize` if *initsigs* is ``1``. If "
"*initsigs* is ``0``, it skips initialization registration of signal "
"handlers, which might be useful when Python is embedded."
msgstr ""
"*initsigs* に ``1`` を指定した場合、この関数は :c:func:`Py_Initialize` と同じ"
"ように動作します。\n"
"*initsigs* に ``0`` を指定した場合、初期化時のシグナルハンドラの登録をスキッ"
"プすることができ、これは Python の埋め込みで便利でしょう。"

#: ../../c-api/init.rst:54
msgid ""
"Return true (nonzero) when the Python interpreter has been initialized, "
"false (zero) if not.  After :c:func:`Py_FinalizeEx` is called, this returns "
"false until :c:func:`Py_Initialize` is called again."
msgstr ""
"Python インタプリタが初期化済みであれば真(非ゼロ)を、さもなければ偽(ゼロ)を返"
"します。:c:func:`Py_FinalizeEx` を呼び出した後は、:c:func:`Py_Initialize` を"
"再び呼び出すまで、この関数は偽を返します。"

#: ../../c-api/init.rst:61
msgid ""
"Undo all initializations made by :c:func:`Py_Initialize` and subsequent use "
"of Python/C API functions, and destroy all sub-interpreters (see :c:func:"
"`Py_NewInterpreter` below) that were created and not yet destroyed since the "
"last call to :c:func:`Py_Initialize`.  Ideally, this frees all memory "
"allocated by the Python interpreter.  This is a no-op when called for a "
"second time (without calling :c:func:`Py_Initialize` again first).  Normally "
"the return value is ``0``.  If there were errors during finalization "
"(flushing buffered data), ``-1`` is returned."
msgstr ""
":c:func:`Py_Initialize` とそれ以後の Python/C API 関数で行った全ての初期化処"
"理を取り消し、最後の :c:func:`Py_Initialize`  呼び出し以後に Python インタプ"
"リタが生成した全てのサブインタプリタ  (sub-interpreter, 下記の :c:func:"
"`Py_NewInterpreter` を参照) を消去します。\n"
"理想的な状況では、この関数によって Python インタプリタが確保したメモリは全て"
"解放されます。\n"
"この関数を (:c:func:`Py_Initialize` を呼ばずに) 再度呼び出しても何も行いませ"
"ん。\n"
"通常は返り値は ``0`` です。終了処理中 (バッファリングされたデータの書き出し) "
"のエラーがあった場合は ``-1`` が返されます。"

#: ../../c-api/init.rst:70
msgid ""
"This function is provided for a number of reasons.  An embedding application "
"might want to restart Python without having to restart the application "
"itself. An application that has loaded the Python interpreter from a "
"dynamically loadable library (or DLL) might want to free all memory "
"allocated by Python before unloading the DLL. During a hunt for memory leaks "
"in an application a developer might want to free all memory allocated by "
"Python before exiting from the application."
msgstr ""
"この関数が提供されている理由はいくつかあります。Python の埋め込みを行っている"
"アプリケーションでは、アプリケーションを再起動することなく Python を再起動し"
"たいことがあります。また、動的ロード可能イブラリ (あるいは DLL) から Python "
"インタプリタをロードするアプリケーションでは、DLL をアンロードする前に "
"Python が確保したメモリを全て解放したいと考えるかもしれません。アプリケーショ"
"ン内で起きているメモリリークを追跡する際に、開発者は Python が確保したメモリ"
"をアプリケーションの終了前に解放させたいと思う場合もあります。"

#: ../../c-api/init.rst:78
msgid ""
"**Bugs and caveats:** The destruction of modules and objects in modules is "
"done in random order; this may cause destructors (:meth:`__del__` methods) "
"to fail when they depend on other objects (even functions) or modules.  "
"Dynamically loaded extension modules loaded by Python are not unloaded.  "
"Small amounts of memory allocated by the Python interpreter may not be freed "
"(if you find a leak, please report it).  Memory tied up in circular "
"references between objects is not freed.  Some memory allocated by extension "
"modules may not be freed.  Some extensions may not work properly if their "
"initialization routine is called more than once; this can happen if an "
"application calls :c:func:`Py_Initialize` and :c:func:`Py_FinalizeEx` more "
"than once."
msgstr ""
"**バグおよび注意事項:** モジュールやモジュール内のオブジェクトはランダムな順"
"番で削除されます。このため、他のオブジェクト(関数オブジェクトも含みます) やモ"
"ジュールに依存するデストラクタ  (:meth:`__del__` メソッド) が失敗してしまうこ"
"とがあります。動的にロードされるようになっている拡張モジュールが Python に"
"よってロードされていた場合、アンロードされません。 Python が確保したメモリが"
"わずかながら解放されないかもしれません (メモリリークを発見したら、どうか報告"
"してください)。オブジェクト間の循環参照に捕捉されているメモリは解放されないこ"
"とがあります。拡張モジュールが確保したメモリは解放されないことがあります。拡"
"張モジュールによっては、初期化ルーチンを 2 度以上呼び出すと正しく動作しないこ"
"とがあります。こうした状況は、 :c:func:`Py_Initialize`  や :c:func:"
"`Py_FinalizeEx` を 2 度以上呼び出すと起こり得ます。"

#: ../../c-api/init.rst:94
msgid ""
"This is a backwards-compatible version of :c:func:`Py_FinalizeEx` that "
"disregards the return value."
msgstr ""
"この関数は :c:func:`Py_FinalizeEx` の後方互換性バージョンで、戻り値がありませ"
"ん。"

#: ../../c-api/init.rst:99
msgid "Process-wide parameters"
msgstr "プロセスワイドのパラメータ"

#: ../../c-api/init.rst:109
msgid ""
"This function should be called before :c:func:`Py_Initialize`, if it is "
"called at all. It specifies which encoding and error handling to use with "
"standard IO, with the same meanings as in :func:`str.encode`."
msgstr ""
"もし :c:func:`Py_Initialize` が呼ばれるなら、この関数はその前に呼ばなければな"
"りません。標準の IO において、どのエンコーディングおよびどんなエラー処理を使"
"うかを、 :func:`str.encode` と同様の意味で指定します。"

#: ../../c-api/init.rst:113
msgid ""
"It overrides :envvar:`PYTHONIOENCODING` values, and allows embedding code to "
"control IO encoding when the environment variable does not work."
msgstr ""
"これは、環境変数が働かない時に :envvar:`PYTHONIOENCODING` の値を上書きし、埋"
"め込みコードが IO エンコーディングをコントロールできるようにします。"

#: ../../c-api/init.rst:116
msgid ""
"``encoding`` and/or ``errors`` may be NULL to use :envvar:`PYTHONIOENCODING` "
"and/or default values (depending on other settings)."
msgstr ""
"``encoding`` と ``errors`` のどちらかまたは両方を NULL にすることで、 :"
"envvar:`PYTHONIOENCODING` とデフォルト値のどちらかまたは両方を使うことができ"
"ます (他の設定に依存します)。"

#: ../../c-api/init.rst:120
msgid ""
"Note that :data:`sys.stderr` always uses the \"backslashreplace\" error "
"handler, regardless of this (or any other) setting."
msgstr ""
"この設定 (あるいは他の設定) に関わらず、 :data:`sys.stderr` は常に "
"\"backslashreplace\" エラーハンドラを使うことに注意してください。"

#: ../../c-api/init.rst:123
msgid ""
"If :c:func:`Py_FinalizeEx` is called, this function will need to be called "
"again in order to affect subsequent calls to :c:func:`Py_Initialize`."
msgstr ""
":c:func:`Py_FinalizeEx` を呼び出した場合は、:c:func:`Py_Initialize` を呼び出"
"す前に、この関数を再度呼び出す必要があるでしょう。"

#: ../../c-api/init.rst:126
msgid ""
"Returns ``0`` if successful, a nonzero value on error (e.g. calling after "
"the interpreter has already been initialized)."
msgstr ""
"成功したら ``0`` を、エラーの場合は ``0`` でない値を返します (例えば、インタ"
"プリタが初期化された後に、この関数が呼び出された場合)。"

#: ../../c-api/init.rst:139
msgid ""
"This function should be called before :c:func:`Py_Initialize` is called for "
"the first time, if it is called at all.  It tells the interpreter the value "
"of the ``argv[0]`` argument to the :c:func:`main` function of the program "
"(converted to wide characters). This is used by :c:func:`Py_GetPath` and "
"some other functions below to find the Python run-time libraries relative to "
"the interpreter executable.  The default value is ``'python'``.  The "
"argument should point to a zero-terminated wide character string in static "
"storage whose contents will not change for the duration of the program's "
"execution.  No code in the Python interpreter will change the contents of "
"this storage."
msgstr ""
"この関数を呼び出すなら、最初に :c:func:`Py_Initialize` を呼び出すよりも前に呼"
"び出さなければなりません。この関数はインタプリタにプログラムの :c:func:"
"`main` 関数に指定した ``argv[0]`` 引数の値を教えます (ワイドキャラクタに変換"
"されます)。この引数値は、 :c:func:`Py_GetPath` や、以下に示すその他の関数が、"
"インタプリタの実行可能形式から Python ランタイムライブラリへの相対パスを取得"
"するために使われます。デフォルトの値は ``'python'`` です。引数はゼロ終端され"
"たワイドキャラクタ文字列で、静的な記憶領域に入っていなければならず、その内容"
"はプログラムの実行中に変更してはなりません。 Python インタプリタ内のコード"
"で、この記憶領域の内容を変更するものは一切ありません。"

#: ../../c-api/init.rst:150 ../../c-api/init.rst:264 ../../c-api/init.rst:366
#: ../../c-api/init.rst:393 ../../c-api/init.rst:410
msgid ""
"Use :c:func:`Py_DecodeLocale` to decode a bytes string to get a :c:type:"
"`wchar_*` string."
msgstr ""
"バイト文字列を :c:type:`wchar_*` 文字列にデコードするには :c:func:"
"`Py_DecodeLocale` を使ってください。"

#: ../../c-api/init.rst:158
msgid ""
"Return the program name set with :c:func:`Py_SetProgramName`, or the "
"default. The returned string points into static storage; the caller should "
"not modify its value."
msgstr ""
":c:func:`Py_SetProgramName` で設定されたプログラム名か、デフォルトのプログラ"
"ム名を返します。関数が返す文字列ポインタは静的な記憶領域を返します。関数の呼"
"び出し側はこの値を変更できません。"

#: ../../c-api/init.rst:165
msgid ""
"Return the *prefix* for installed platform-independent files. This is "
"derived through a number of complicated rules from the program name set "
"with :c:func:`Py_SetProgramName` and some environment variables; for "
"example, if the program name is ``'/usr/local/bin/python'``, the prefix is "
"``'/usr/local'``. The returned string points into static storage; the caller "
"should not modify its value.  This corresponds to the :makevar:`prefix` "
"variable in the top-level :file:`Makefile` and the ``--prefix`` argument to "
"the :program:`configure` script at build time.  The value is available to "
"Python code as ``sys.prefix``. It is only useful on Unix.  See also the next "
"function."
msgstr ""
"プラットフォーム非依存のファイル群がインストールされている場所である "
"*prefix* を返します。この値は :c:func:`Py_SetProgramName` でセットされたプロ"
"グラム名やいくつかの環境変数をもとに、数々の複雑な規則から導出されます。例え"
"ば、プログラム名が ``'/usr/local/bin/python'`` の場合、prefix は ``'/usr/"
"local'`` になります。関数が返す文字列ポインタは静的な記憶領域を返します; 関数"
"の呼び出し側はこの値を変更できません。この値はトップレベルの :file:"
"`Makefile` に指定されている変数 :makevar:`prefix` や、ビルド値に :program:"
"`configure` スクリプトに指定した ``--prefix`` 引数に対応しています。この値は "
"Python コードからは ``sys.prefix`` として利用できます。これはUnixでのみ有用で"
"す。次に説明する関数も参照してください。"

#: ../../c-api/init.rst:178
msgid ""
"Return the *exec-prefix* for installed platform-*dependent* files.  This is "
"derived through a number of complicated rules from the program name set "
"with :c:func:`Py_SetProgramName` and some environment variables; for "
"example, if the program name is ``'/usr/local/bin/python'``, the exec-prefix "
"is ``'/usr/local'``.  The returned string points into static storage; the "
"caller should not modify its value.  This corresponds to the :makevar:"
"`exec_prefix` variable in the top-level :file:`Makefile` and the ``--exec-"
"prefix`` argument to the :program:`configure` script at build  time.  The "
"value is available to Python code as ``sys.exec_prefix``.  It is only useful "
"on Unix."
msgstr ""
"プラットフォーム *依存* のファイルがインストールされている場所である *exec-"
"prefix* を返します。この値は :c:func:`Py_SetProgramName` でセットされたプログ"
"ラム名やいくつかの環境変数をもとに、数々の複雑な規則から導出されます。例え"
"ば、プログラム名が ``'/usr/local/bin/python'`` の場合、exec-prefix は ``'/"
"usr/local'`` になります。関数が返す文字列ポインタは静的な記憶領域を返します; "
"関数の呼び出し側はこの値を変更できません。この値はトップレベルの :file:"
"`Makefile` に指定されている変数 :makevar:`exec_prefix` や、ビルド値に :"
"program:`configure` スクリプトに指定した ``--exec-prefix`` 引数に対応していま"
"す。この値は Python コードからは ``sys.exec_prefix`` として利用できます。 "
"Unixのみで有用です。"

#: ../../c-api/init.rst:188
msgid ""
"Background: The exec-prefix differs from the prefix when platform dependent "
"files (such as executables and shared libraries) are installed in a "
"different directory tree.  In a typical installation, platform dependent "
"files may be installed in the :file:`/usr/local/plat` subtree while platform "
"independent may be installed in :file:`/usr/local`."
msgstr ""
"背景: プラットフォーム依存のファイル (実行形式や共有ライブラリ) が別のディレ"
"クトリツリー内にインストールされている場合、 exec-prefix は prefix と異なりま"
"す。典型的なインストール形態では、プラットフォーム非依存のファイルが :file:`/"
"usr/local` に収められる一方、プラットフォーム依存のファイルは :file:`/usr/"
"local/plat` サブツリーに収められます。"

#: ../../c-api/init.rst:194
msgid ""
"Generally speaking, a platform is a combination of hardware and software "
"families, e.g.  Sparc machines running the Solaris 2.x operating system are "
"considered the same platform, but Intel machines running Solaris 2.x are "
"another platform, and Intel machines running Linux are yet another "
"platform.  Different major revisions of the same operating system generally "
"also form different platforms.  Non-Unix operating systems are a different "
"story; the installation strategies on those systems are so different that "
"the prefix and exec-prefix are meaningless, and set to the empty string. "
"Note that compiled Python bytecode files are platform independent (but not "
"independent from the Python version by which they were compiled!)."
msgstr ""
"一般的に、プラットフォームとは、ハードウェアとソフトウェアファミリの組み合わ"
"せを指します。例えば、Solaris 2.x を動作させている Sparc マシンは全て同じプ"
"ラットフォームであるとみなしますが、Solaris 2.x を動作させている Intel マシン"
"は違うプラットフォームになりますし、同じ Intel マシンでも Linux を動作させて"
"いるならまた別のプラットフォームです。一般的には、同じオペレーティングシステ"
"ムでも、メジャーリビジョンの違うものは異なるプラットフォームです。非 Unix の"
"オペレーティングシステムの場合は話はまた別です; 非 Unix のシステムでは、イン"
"ストール方法はとても異なっていて、prefix や exec-prefix には意味がなく、空文"
"字列が設定されています。コンパイル済みの Python バイトコードはプラットフォー"
"ムに依存しないので注意してください (ただし、どのバージョンの Python でコンパ"
"イルされたかには依存します!)。"

#: ../../c-api/init.rst:205
msgid ""
"System administrators will know how to configure the :program:`mount` or :"
"program:`automount` programs to share :file:`/usr/local` between platforms "
"while having :file:`/usr/local/plat` be a different filesystem for each "
"platform."
msgstr ""
"システム管理者は、 :program:`mount` や :program:`automount` プログラムを使っ"
"て、各プラットフォーム用の :file:`/usr/local/plat` を異なったファイルシステム"
"に置き、プラットフォーム間で :file:`/usr/local` を共有するための設定方法を"
"知っているでしょう。"

#: ../../c-api/init.rst:217
msgid ""
"Return the full program name of the Python executable; this is  computed as "
"a side-effect of deriving the default module search path  from the program "
"name (set by :c:func:`Py_SetProgramName` above). The returned string points "
"into static storage; the caller should not modify its value.  The value is "
"available to Python code as ``sys.executable``."
msgstr ""
"Python 実行可能形式の完全なプログラム名を返します; この値はデフォルトのモ"
"ジュール検索パスを (前述の :c:func:`Py_SetProgramName`  で設定された) プログ"
"ラム名から導出する際に副作用的に計算されます。関数が返す文字列ポインタは静的"
"な記憶領域を返します; 関数の呼び出し側はこの値を変更できません。この値は "
"Python コードからは ``sys.executable`` として利用できます。"

#: ../../c-api/init.rst:231
msgid ""
"Return the default module search path; this is computed from the program "
"name (set by :c:func:`Py_SetProgramName` above) and some environment "
"variables. The returned string consists of a series of directory names "
"separated by a platform dependent delimiter character.  The delimiter "
"character is ``':'`` on Unix and Mac OS X, ``';'`` on Windows.  The returned "
"string points into static storage; the caller should not modify its value.  "
"The list :data:`sys.path` is initialized with this value on interpreter "
"startup; it can be (and usually is) modified later to change the search path "
"for loading modules."
msgstr ""
"デフォルトのモジュール検索パスを返します; パスは (上の :c:func:"
"`Py_SetProgramName` で設定された) プログラム名と、いくつかの環境変数から計算"
"されます。戻り値となる文字列は、プラットフォーム依存のパス区切り文字で分割さ"
"れた一連のディレクトリ名からなります。区切り文字は Unix と Mac OS X では "
"``':'``, Windows では ``';'`` です。関数が返す文字列ポインタは静的な記憶領域"
"を返します; 関数の呼び出し側はこの値を変更できません。 :data:`sys.path` はイ"
"ンタプリタによってこの値で初期化され、その後にモジュールをロードする際の検索"
"パスを変更するために修正することが可能で、たいていそうされます。"

#: ../../c-api/init.rst:251
msgid ""
"Set the default module search path.  If this function is called before :c:"
"func:`Py_Initialize`, then :c:func:`Py_GetPath` won't attempt to compute a "
"default search path but uses the one provided instead.  This is useful if "
"Python is embedded by an application that has full knowledge of the location "
"of all modules.  The path components should be separated by the platform "
"dependent delimiter character, which is ``':'`` on Unix and Mac OS X, "
"``';'`` on Windows."
msgstr ""
"デフォルトのモジュール検索パスを設定します。この関数が :c:func:"
"`Py_Initialize` より前に呼び出された場合、 :c:func:`Py_GetPath` はデフォルト"
"の検索パスを計算しようとせず、代わりにこの関数が与えた検索パスを返します。こ"
"れは、 Python がアプリケーションに組み込まれていて、そのアプリケーションが全"
"てのモジュールの場所を完全に把握しているときに便利です。パスはプラットフォー"
"ム依存の区切り文字で分割されている必要があります。区切り文字は Unix と Mac "
"OS X では ``':'`` 、Windows では ``';'`` です。"

#: ../../c-api/init.rst:259
msgid ""
"This also causes :data:`sys.executable` to be set only to the raw program "
"name (see :c:func:`Py_SetProgramName`) and for :data:`sys.prefix` and :data:"
"`sys.exec_prefix` to be empty.  It is up to the caller to modify these if "
"required after calling :c:func:`Py_Initialize`."
msgstr ""
"また、この関数は :data:`sys.executable` に特に加工されていないプログラム名 (:"
"c:func:`Py_SetProgramName` を参照) をセットし、 :data:`sys.prefix` と :data:"
"`sys.exec_prefix` に空文字列をセットします。 :c:func:`Py_Initialize` が呼び出"
"された後で、これらの値を変更する必要がある場合は、呼び出し側の責任で行いま"
"す。"

#: ../../c-api/init.rst:267
msgid ""
"The path argument is copied internally, so the caller may free it after the "
"call completes."
msgstr ""
"パス引数は内部でコピーされます。したがって、呼び出し完了後に呼び出し元は引数"
"を解放できます。"

#: ../../c-api/init.rst:273
msgid ""
"Return the version of this Python interpreter.  This is a string that looks "
"something like ::"
msgstr ""
"Python インタプリタのバージョンを返します。バージョンは、次のような形式の文字"
"列です ::"

#: ../../c-api/init.rst:280
msgid ""
"The first word (up to the first space character) is the current Python "
"version; the first three characters are the major and minor version "
"separated by a period.  The returned string points into static storage; the "
"caller should not modify its value.  The value is available to Python code "
"as :data:`sys.version`."
msgstr ""
"第一ワード (最初のスペース文字まで) は、現在の Python のバージョンです; 最初"
"の三文字は、ピリオドで区切られたメジャーバージョンとマイナーバージョンです。"
"関数が返す文字列ポインタは静的な記憶領域を返します; 関数の呼び出し側はこの値"
"を変更できません。この値は Python コードからは :data:`sys.version` として利用"
"できます。"

#: ../../c-api/init.rst:290
msgid ""
"Return the platform identifier for the current platform.  On Unix, this is "
"formed from the \"official\" name of the operating system, converted to "
"lower case, followed by the major revision number; e.g., for Solaris 2.x, "
"which is also known as SunOS 5.x, the value is ``'sunos5'``.  On Mac OS X, "
"it is ``'darwin'``.  On Windows, it is ``'win'``.  The returned string "
"points into static storage; the caller should not modify its value.  The "
"value is available to Python code as ``sys.platform``."
msgstr ""
"現在のプラットフォームのプラットフォーム識別文字列を返します。Unixでは、オペ"
"レーティングシステムの \"公式の\" 名前を小文字に変換し、後ろにメジャーリビ"
"ジョン番号を付けた構成になっています。例えば Solaris 2.x は、SunOS 5.x, とし"
"ても知られていますが、``'sunos5'`` になります。Mac OS X では ``'darwin'`` で"
"す。Windows では ``'win'`` です。関数が返す文字列ポインタは静的な記憶領域を返"
"します; 関数の呼び出し側はこの値を変更できません。この値は Python コードから"
"は ``sys.platform`` として利用できます。"

#: ../../c-api/init.rst:301
msgid ""
"Return the official copyright string for the current Python version, for "
"example"
msgstr ""
"現在の Python バージョンに対する公式の著作権表示文字列を返します。例えば"

#: ../../c-api/init.rst:303
msgid "``'Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam'``"
msgstr "``'Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam'``"

#: ../../c-api/init.rst:307
msgid ""
"The returned string points into static storage; the caller should not modify "
"its value.  The value is available to Python code as ``sys.copyright``."
msgstr ""
"関数が返す文字列ポインタは静的な記憶領域を返します; 関数の呼び出し側はこの値"
"を変更できません。この値は Python コードからは ``sys.copyright`` として利用で"
"きます。"

#: ../../c-api/init.rst:313
msgid ""
"Return an indication of the compiler used to build the current Python "
"version, in square brackets, for example::"
msgstr ""
"現在使っているバージョンの Python をビルドする際に用いたコンパイラを示す文字"
"列を、角括弧で囲った文字列を返します。例えば::"

#: ../../c-api/init.rst:320 ../../c-api/init.rst:334
msgid ""
"The returned string points into static storage; the caller should not modify "
"its value.  The value is available to Python code as part of the variable "
"``sys.version``."
msgstr ""
"関数が返す文字列ポインタは静的な記憶領域を返します; 関数の呼び出し側はこの値"
"を変更できません。この値は Python コードからは ``sys.version`` の一部として取"
"り出せます。"

#: ../../c-api/init.rst:327
msgid ""
"Return information about the sequence number and build date and time  of the "
"current Python interpreter instance, for example ::"
msgstr ""
"現在使っている Python インタプリタインスタンスの、シーケンス番号とビルド日時"
"に関する情報を返します。例えば ::"

#: ../../c-api/init.rst:346
msgid ""
"Set :data:`sys.argv` based on *argc* and *argv*.  These parameters are "
"similar to those passed to the program's :c:func:`main` function with the "
"difference that the first entry should refer to the script file to be "
"executed rather than the executable hosting the Python interpreter.  If "
"there isn't a script that will be run, the first entry in *argv* can be an "
"empty string.  If this function fails to initialize :data:`sys.argv`, a "
"fatal condition is signalled using :c:func:`Py_FatalError`."
msgstr ""
"*argc* および *argv* に基づいて :data:`sys.argv` を設定します。これらの引数は"
"プログラムの :c:func:`main` に渡した引数に似ていますが、最初の要素が Python "
"インタプリタの宿主となっている実行形式の名前ではなく、実行されるスクリプト名"
"を参照しなければならない点が違います。実行するスクリプトがない場合、 *argv* "
"の最初の要素は空文字列にしてもかまいません。この関数が :data:`sys.argv` の初"
"期化に失敗した場合、致命的エラーを :c:func:`Py_FatalError` で知らせます。"

#: ../../c-api/init.rst:354
msgid ""
"If *updatepath* is zero, this is all the function does.  If *updatepath* is "
"non-zero, the function also modifies :data:`sys.path` according to the "
"following algorithm:"
msgstr ""
"*updatepath* が 0 の場合、ここまでの動作がこの関数がすることの全てです。 "
"*updatepath* が 0 でない場合、この関数は :data:`sys.path` を以下のアルゴリズ"
"ムに基づいて修正します:"

#: ../../c-api/init.rst:358
msgid ""
"If the name of an existing script is passed in ``argv[0]``, the absolute "
"path of the directory where the script is located is prepended to :data:`sys."
"path`."
msgstr ""
"存在するスクリプトの名前が ``argv[0]`` に渡された場合、そのスクリプトがある場"
"所の絶対パスを :data:`sys.path` の先頭に追加します。"

#: ../../c-api/init.rst:361
msgid ""
"Otherwise (that is, if *argc* is ``0`` or ``argv[0]`` doesn't point to an "
"existing file name), an empty string is prepended to :data:`sys.path`, which "
"is the same as prepending the current working directory (``\".\"``)."
msgstr ""
"それ以外の場合 (*argc* が ``0`` だったり、 ``argv[0]`` が存在するファイル名を"
"指していない場合)、 :data:`sys.path` の先頭に空の文字列を追加します。\n"
"これは現在の作業ディレクトリ (``\".\"``) を先頭に追加するのと同じです。"

#: ../../c-api/init.rst:370
msgid ""
"It is recommended that applications embedding the Python interpreter for "
"purposes other than executing a single script pass ``0`` as *updatepath*, "
"and update :data:`sys.path` themselves if desired. See `CVE-2008-5983 "
"<https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5983>`_."
msgstr ""
"単一のスクリプトを実行する以外の目的でPython インタプリタを埋め込んでいるアプ"
"リケーションでは、 *updatepath* に ``0`` を渡して、必要な場合は自分で :data:"
"`sys.path` を更新することをおすすめします。\n"
"`CVE-2008-5983 <https://cve.mitre.org/cgi-bin/cvename.cgi?"
"name=CVE-2008-5983>`_ を参照してください。"

#: ../../c-api/init.rst:375
msgid ""
"On versions before 3.1.3, you can achieve the same effect by manually "
"popping the first :data:`sys.path` element after having called :c:func:"
"`PySys_SetArgv`, for example using::"
msgstr ""
"3.1.3 より前のバージョンでは、 :c:func:`PySys_SetArgv` の呼び出しが完了した後"
"に :data:`sys.path` の先頭の要素を取り出すことで、同じ効果が得られます。例え"
"ばこのように使います::"

#: ../../c-api/init.rst:389
msgid ""
"This function works like :c:func:`PySys_SetArgvEx` with *updatepath* set to "
"``1`` unless the :program:`python` interpreter was started with the :option:"
"`-I`."
msgstr ""
"この関数は、 :program:`python` インタプリタが :option:`-I` オプション付きで実"
"行されている場合を除き :c:func:`PySys_SetArgvEx` の *updatepath* に ``1`` を"
"設定したのと同じように動作します。"

#: ../../c-api/init.rst:396
msgid "The *updatepath* value depends on :option:`-I`."
msgstr "*updatepath* の値は :option:`-I` オプションに依存します。"

#: ../../c-api/init.rst:401
msgid ""
"Set the default \"home\" directory, that is, the location of the standard "
"Python libraries.  See :envvar:`PYTHONHOME` for the meaning of the argument "
"string."
msgstr ""
"Python の標準ライブラリがある、デフォルトの \"home\" ディレクトリを設定しま"
"す。引数の文字列の意味については :envvar:`PYTHONHOME` を参照してください。"

#: ../../c-api/init.rst:405
msgid ""
"The argument should point to a zero-terminated character string in static "
"storage whose contents will not change for the duration of the program's "
"execution.  No code in the Python interpreter will change the contents of "
"this storage."
msgstr ""
"引数は静的なストレージに置かれてプログラム実行中に書き換えられないようなゼロ"
"終端の文字列であるべきです。Python インタプリタはこのストレージの内容を変更し"
"ません。"

#: ../../c-api/init.rst:416
msgid ""
"Return the default \"home\", that is, the value set by a previous call to :c:"
"func:`Py_SetPythonHome`, or the value of the :envvar:`PYTHONHOME` "
"environment variable if it is set."
msgstr ""
"前回の :c:func:`Py_SetPythonHome` 呼び出しで設定されたデフォルトの \"home\" "
"か、 :envvar:`PYTHONHOME` 環境変数が設定されていればその値を返します。"

#: ../../c-api/init.rst:424
msgid "Thread State and the Global Interpreter Lock"
msgstr ""
"スレッド状態 (thread state) とグローバルインタプリタロック (global "
"interpreter lock)"

#: ../../c-api/init.rst:431
msgid ""
"The Python interpreter is not fully thread-safe.  In order to support multi-"
"threaded Python programs, there's a global lock, called the :term:`global "
"interpreter lock` or :term:`GIL`, that must be held by the current thread "
"before it can safely access Python objects. Without the lock, even the "
"simplest operations could cause problems in a multi-threaded program: for "
"example, when two threads simultaneously increment the reference count of "
"the same object, the reference count could end up being incremented only "
"once instead of twice."
msgstr ""
"Python インタプリタは完全にはスレッドセーフではありません。マルチスレッドの "
"Python プログラムをサポートするために、グローバルインタプリタロック(:term:"
"`global interpreter lock`, :term:`GIL`) と呼ばれるグローバルなロックが存在し"
"ていて、現在のスレッドが Python オブジェクトに安全にアクセスする前に必ずロッ"
"クを獲得しなければならなくなっています。ロック機構がなければ、単純な操作でさ"
"え、マルチスレッドプログラムの実行に問題を引き起こす可能性があります。たとえ"
"ば、二つのスレッドが同じオブジェクトの参照カウントを同時にインクリメントする"
"と、結果的に参照カウントは二回でなく一回だけしかインクリメントされないかもし"
"れません。"

#: ../../c-api/init.rst:441
msgid ""
"Therefore, the rule exists that only the thread that has acquired the :term:"
"`GIL` may operate on Python objects or call Python/C API functions. In order "
"to emulate concurrency of execution, the interpreter regularly tries to "
"switch threads (see :func:`sys.setswitchinterval`).  The lock is also "
"released around potentially blocking I/O operations like reading or writing "
"a file, so that other Python threads can run in the meantime."
msgstr ""
"このため、 :term:`GIL` を獲得したスレッドだけが Python オブジェクトを操作した"
"り、 Python/C API 関数を呼び出したりできるというルールがあります。並行処理を"
"エミュレートするために、インタプリタは定期的にロックを解放したり獲得したりし"
"ます。 (:func:`sys.setswitchinterval` を参照) このロックはブロックが起こりう"
"る I/O 操作の付近でも解放・獲得され、 I/O を要求するスレッドが I/O 操作の完了"
"を待つ間、他のスレッドが動作できるようにしています。"

#: ../../c-api/init.rst:452
msgid ""
"The Python interpreter keeps some thread-specific bookkeeping information "
"inside a data structure called :c:type:`PyThreadState`.  There's also one "
"global variable pointing to the current :c:type:`PyThreadState`: it can be "
"retrieved using :c:func:`PyThreadState_Get`."
msgstr ""
"Python インタプリタはスレッドごとに必要な情報を :c:type:`PyThreadState` と呼"
"ばれるデータ構造の中に保存します。そしてグローバル変数として現在の :c:type:"
"`PyThreadState` を指すポインタを1つ持ちます。このグローバル変数は :c:func:"
"`PyThreadState_Get` を使って取得できます。"

#: ../../c-api/init.rst:458
msgid "Releasing the GIL from extension code"
msgstr "拡張コード内で GIL を解放する"

#: ../../c-api/init.rst:460
msgid ""
"Most extension code manipulating the :term:`GIL` has the following simple "
"structure::"
msgstr ""
":term:`GIL` を操作するほとんどのコードは、次のような単純な構造になります::"

#: ../../c-api/init.rst:469
msgid "This is so common that a pair of macros exists to simplify it::"
msgstr ""
"この構造は非常に一般的なので、作業を単純にするために2つのマクロが用意されてい"
"ます::"

#: ../../c-api/init.rst:479
msgid ""
"The :c:macro:`Py_BEGIN_ALLOW_THREADS` macro opens a new block and declares a "
"hidden local variable; the :c:macro:`Py_END_ALLOW_THREADS` macro closes the "
"block.  These two macros are still available when Python is compiled without "
"thread support (they simply have an empty expansion)."
msgstr ""
":c:macro:`Py_BEGIN_ALLOW_THREADS` マクロは新たなブロックを開始し、隠しローカ"
"ル変数を宣言します; :c:macro:`Py_END_ALLOW_THREADS` はブロックを閉じます。 "
"Python をスレッドサポートなしでコンパイルしたときでもこの2つのマクロは利用可"
"能です (単に、空行に展開されます)。"

#: ../../c-api/init.rst:484
msgid ""
"When thread support is enabled, the block above expands to the following "
"code::"
msgstr ""
"スレッドサポートが有効になっている場合、上記のブロックは以下のようなコードに"
"展開されます::"

#: ../../c-api/init.rst:496
msgid ""
"Here is how these functions work: the global interpreter lock is used to "
"protect the pointer to the current thread state.  When releasing the lock "
"and saving the thread state, the current thread state pointer must be "
"retrieved before the lock is released (since another thread could "
"immediately acquire the lock and store its own thread state in the global "
"variable). Conversely, when acquiring the lock and restoring the thread "
"state, the lock must be acquired before storing the thread state pointer."
msgstr ""
"これらの関数の動作を説明します。GIL は現在のスレッド状態を指すポインタを保護"
"するために使われます。ロックを解放してスレッド状態を退避する際、ロックを解放"
"する前に現在のスレッド状態ポインタを取得しておかなければなりません (他のス"
"レッドがすぐさまロックを獲得して、自らのスレッド状態をグローバル変数に保存し"
"てしまうかもしれないからです)。逆に、ロックを獲得してスレッド状態を復帰する際"
"には、グローバル変数にスレッド状態ポインタを保存する前にロックを獲得しておか"
"なければなりません。"

#: ../../c-api/init.rst:505
msgid ""
"Calling system I/O functions is the most common use case for releasing the "
"GIL, but it can also be useful before calling long-running computations "
"which don't need access to Python objects, such as compression or "
"cryptographic functions operating over memory buffers.  For example, the "
"standard :mod:`zlib` and :mod:`hashlib` modules release the GIL when "
"compressing or hashing data."
msgstr ""
"GIL を解放するのはほとんどがシステムのI/O関数を呼び出す時ですが、メモリバッ"
"ファに対する圧縮や暗号化のように、 Python のオブジェクトにアクセスしない長時"
"間かかる計算処理を呼び出すときも GIL を解放することは有益です。例えば、 :mod:"
"`zlib` や :mod:`hashlib` モジュールは圧縮やハッシュ計算の前に GIL を解放しま"
"す。"

#: ../../c-api/init.rst:516
msgid "Non-Python created threads"
msgstr "Python 以外で作られたスレッド"

#: ../../c-api/init.rst:518
msgid ""
"When threads are created using the dedicated Python APIs (such as the :mod:"
"`threading` module), a thread state is automatically associated to them and "
"the code showed above is therefore correct.  However, when threads are "
"created from C (for example by a third-party library with its own thread "
"management), they don't hold the GIL, nor is there a thread state structure "
"for them."
msgstr ""
"Python API を通して作られたスレッド (:mod:`threading` モジュールなど) では自"
"動的にスレッド状態が割り当てられて、上記のコードは正しく動きます。しかし、(自"
"前でスレッド管理を行う外部のライブラリなどにより)C言語でスレッドを生成した場"
"合、そのスレッドには GIL がなく、スレッド状態データ構造体もないことに注意する"
"必要があります。"

#: ../../c-api/init.rst:525
msgid ""
"If you need to call Python code from these threads (often this will be part "
"of a callback API provided by the aforementioned third-party library), you "
"must first register these threads with the interpreter by creating a thread "
"state data structure, then acquiring the GIL, and finally storing their "
"thread state pointer, before you can start using the Python/C API.  When you "
"are done, you should reset the thread state pointer, release the GIL, and "
"finally free the thread state data structure."
msgstr ""
"このようなスレッドから Python コードを呼び出す必要がある場合 (外部のライブラ"
"リからコールバックするAPIなどがよくある例です)、Python/C API を呼び出す前に、"
"スレッド状態データ構造体を生成し、GIL を獲得し、スレッド状態ポインタを保存す"
"ることで、スレッドをインタプリタに登録しなければなりません。スレッドが作業を"
"終えたら、スレッド状態ポインタをリセットして、ロックを解放し、最後にスレッド"
"状態データ構造体のメモリを解放しなければなりません。"

#: ../../c-api/init.rst:533
msgid ""
"The :c:func:`PyGILState_Ensure` and :c:func:`PyGILState_Release` functions "
"do all of the above automatically.  The typical idiom for calling into "
"Python from a C thread is::"
msgstr ""
":c:func:`PyGILState_Ensure` と :c:func:`PyGILState_Release` はこの処理を自動"
"的に行います。 Cのスレッドから Python を呼び出す典型的な方法は以下のとおりで"
"す::"

#: ../../c-api/init.rst:547
msgid ""
"Note that the :c:func:`PyGILState_\\*` functions assume there is only one "
"global interpreter (created automatically by :c:func:`Py_Initialize`).  "
"Python supports the creation of additional interpreters (using :c:func:"
"`Py_NewInterpreter`), but mixing multiple interpreters and the :c:func:"
"`PyGILState_\\*` API is unsupported."
msgstr ""
":c:func:`PyGILState_\\*` 関数は、(:c:func:`Py_Initialize` によって自動的に作"
"られる) グローバルインタプリタ1つだけが存在すると仮定する事に気をつけて下さ"
"い。 Python は (:c:func:`Py_NewInterpreter` を使って) 追加のインタプリタを作"
"成できることに変わりはありませんが、複数インタプリタと :c:func:"
"`PyGILState_\\*` API を混ぜて使うことはサポートされていません。"

#: ../../c-api/init.rst:553
msgid ""
"Another important thing to note about threads is their behaviour in the face "
"of the C :c:func:`fork` call. On most systems with :c:func:`fork`, after a "
"process forks only the thread that issued the fork will exist. That also "
"means any locks held by other threads will never be released. Python solves "
"this for :func:`os.fork` by acquiring the locks it uses internally before "
"the fork, and releasing them afterwards. In addition, it resets any :ref:"
"`lock-objects` in the child. When extending or embedding Python, there is no "
"way to inform Python of additional (non-Python) locks that need to be "
"acquired before or reset after a fork. OS facilities such as :c:func:"
"`pthread_atfork` would need to be used to accomplish the same thing. "
"Additionally, when extending or embedding Python, calling :c:func:`fork` "
"directly rather than through :func:`os.fork` (and returning to or calling "
"into Python) may result in a deadlock by one of Python's internal locks "
"being held by a thread that is defunct after the fork. :c:func:"
"`PyOS_AfterFork` tries to reset the necessary locks, but is not always able "
"to."
msgstr ""
"注意しないといけないもう一つの重要な点は、 C の :c:func:`fork` を呼び出した時"
"の動作です。ほとんどの :c:func:`fork` を持っているシステムでは、fork されたプ"
"ロセスには fork を実行したスレッドしか存在しません。これは、別のスレッドに取"
"得されたロックがずっと解放されないことを意味します。 Python は fork する前に"
"ロックを取得し、その後に fork を解放することでこの :func:`os.fork` の問題を解"
"決しています。加えて、子プロセスではすべての :ref:`lock-objects` をリセットし"
"ます。 Python を拡張したり埋め込んだりしている場合、 Python に fork 前に取得"
"したり fork 後に解放しなければならない追加の (Python 以外の) ロックを Python "
"に教える手段がありません。 Python と同じことを実現するには、 :c:func:"
"`pthread_atfork` のようなOSの機能を使う必要があります。加えて、Python を拡張"
"したり埋め込んだりしているときに、 :func:`os.fork` を通してではなく直接 :c:"
"func:`fork` を呼び出すと、fork後に失われるスレッドに取得されていた Python の"
"内部ロックのためにデッドロックが発生するかもしれません。 :c:func:"
"`PyOS_AfterFork` は必要なロックのリセットを試みますが、いつでもそれが可能とは"
"限りません。"

#: ../../c-api/init.rst:572
msgid "High-level API"
msgstr "高レベルAPI"

#: ../../c-api/init.rst:574
msgid ""
"These are the most commonly used types and functions when writing C "
"extension code, or when embedding the Python interpreter:"
msgstr ""
"C拡張を書いたりPythonインタプリタを埋め込むときに最も一般的に使われる型や関数"
"は次のとおりです:"

#: ../../c-api/init.rst:579
msgid ""
"This data structure represents the state shared by a number of cooperating "
"threads.  Threads belonging to the same interpreter share their module "
"administration and a few other internal items. There are no public members "
"in this structure."
msgstr ""
"このデータ構造体は、協調動作する多数のスレッド間で共有されている状態を表現し"
"ます。同じインタプリタに属するスレッドはモジュール管理情報やその他いくつかの"
"内部的な情報を共有しています。この構造体には公開 (public) のメンバはありませ"
"ん。"

#: ../../c-api/init.rst:584
msgid ""
"Threads belonging to different interpreters initially share nothing, except "
"process state like available memory, open file descriptors and such.  The "
"global interpreter lock is also shared by all threads, regardless of to "
"which interpreter they belong."
msgstr ""
"異なるインタプリタに属するスレッド間では、利用可能なメモリ、開かれているファ"
"イルデスクリプタなどといったプロセス状態を除いて、初期状態では何も共有されて"
"いません。GILもまた、スレッドがどのインタプリタに属しているかに関わらずすべて"
"のスレッドで共有されています。"

#: ../../c-api/init.rst:592
msgid ""
"This data structure represents the state of a single thread.  The only "
"public data member is :c:type:`PyInterpreterState \\*`:attr:`interp`, which "
"points to this thread's interpreter state."
msgstr ""
"単一のスレッドの状態を表現する表現するデータ構造体です。スレッドのインタプリ"
"タ状態を指すポインタ :c:type:`PyInterpreterState \\*` :attr:`interp` だけが公"
"開されているデータメンバです。"

#: ../../c-api/init.rst:605
msgid ""
"Initialize and acquire the global interpreter lock.  It should be called in "
"the main thread before creating a second thread or engaging in any other "
"thread operations such as ``PyEval_ReleaseThread(tstate)``. It is not needed "
"before calling :c:func:`PyEval_SaveThread` or :c:func:`PyEval_RestoreThread`."
msgstr ""
"GIL を初期化し、獲得します。この関数は、主スレッドが第二のスレッドを生成する"
"以前や、 ``PyEval_ReleaseThread(tstate)`` といった他のスレッド操作に入るより"
"も前に呼び出されるようにしておかなければなりません。 :c:func:"
"`PyEval_SaveThread`, :c:func:`PyEval_RestoreThread` の前に呼び出す必要はあり"
"ません。"

#: ../../c-api/init.rst:610
msgid "This is a no-op when called for a second time."
msgstr "二度目に呼び出すと何も行いません。"

#: ../../c-api/init.rst:612
msgid ""
"This function cannot be called before :c:func:`Py_Initialize()` anymore."
msgstr ""
"この関数は :c:func:`Py_Initialize()` より前に呼び出すことができなくなりまし"
"た。"

#: ../../c-api/init.rst:619
msgid ""
"When only the main thread exists, no GIL operations are needed. This is a "
"common situation (most Python programs do not use threads), and the lock "
"operations slow the interpreter down a bit. Therefore, the lock is not "
"created initially.  This situation is equivalent to having acquired the "
"lock: when there is only a single thread, all object accesses are safe.  "
"Therefore, when this function initializes the global interpreter lock, it "
"also acquires it.  Before the Python :mod:`_thread` module creates a new "
"thread, knowing that either it has the lock or the lock hasn't been created "
"yet, it calls :c:func:`PyEval_InitThreads`.  When this call returns, it is "
"guaranteed that the lock has been created and that the calling thread has "
"acquired it."
msgstr ""
"メインスレッドだけが存在しているとき、 GIL 操作は必要ありません。 (ほとんど"
"の Python プログラムはスレッドを使わないので) これはよくある状況であり、ロッ"
"ク操作はインタプリタの動作を少しだけ遅くします。なので、ロックは最初には作成"
"されません。これはロックを獲得しているのと同じ状態になります: スレッドが 1 つ"
"しかないとき、オブジェクトへの全てのアクセスは安全です。またこれらのことか"
"ら、この関数がグローバルインタプリタロックを初期化するときは、その取得も行い"
"ます。 Python の :mod:`_thread` モジュールは新しいスレッドを作成する前に、"
"ロックが既にあるのかロックはまだ作成されていないのか知るために、  :c:func:"
"`PyEval_InitThreads` を呼び出します。呼び出しが返ってきたとき、ロックが作成さ"
"れており、呼び出したスレッドがそれを獲得したことが保証されます。"

#: ../../c-api/init.rst:630
msgid ""
"It is **not** safe to call this function when it is unknown which thread (if "
"any) currently has the global interpreter lock."
msgstr ""
"(どんなスレッドであれ) どのスレッドが現在グローバルインタプリタロックを持って"
"いるか分からないときに、この関数を呼び出すのは安全では **ありません**。"

#: ../../c-api/init.rst:633
msgid ""
"This function is not available when thread support is disabled at compile "
"time."
msgstr ""
"この関数は、コンパイル時にスレッドサポートが無効にされているときは利用できま"
"せん。"

#: ../../c-api/init.rst:638
msgid ""
"Returns a non-zero value if :c:func:`PyEval_InitThreads` has been called.  "
"This function can be called without holding the GIL, and therefore can be "
"used to avoid calls to the locking API when running single-threaded.  This "
"function is not available when thread support is disabled at compile time."
msgstr ""
":c:func:`PyEval_InitThreads` をすでに呼び出している場合は真 (非ゼロ) を返しま"
"す。この関数は、GILを獲得せずに呼び出すことができますので、シングルスレッドで"
"実行している場合にはロック関連のAPI呼び出しを避けるために使うことができます。"
"この関数はコンパイル時にスレッドサポートを無効化すると利用できません。"

#: ../../c-api/init.rst:646
msgid ""
"Release the global interpreter lock (if it has been created and thread "
"support is enabled) and reset the thread state to *NULL*, returning the "
"previous thread state (which is not *NULL*).  If the lock has been created, "
"the current thread must have acquired it.  (This function is available even "
"when thread support is disabled at compile time.)"
msgstr ""
"(GIL が生成されていて、スレッドサポートが有効の場合) GILを解放して、スレッド"
"状態を *NULL* にし、以前のスレッド状態 (*NULL* にはなりません) を返します。"
"ロックがすでに生成されている場合、現在のスレッドがロックを獲得していなければ"
"なりません。(この関数はコンパイル時にスレッドサポートが無効にされていても利用"
"できます。)"

#: ../../c-api/init.rst:655
msgid ""
"Acquire the global interpreter lock (if it has been created and thread "
"support is enabled) and set the thread state to *tstate*, which must not be "
"*NULL*.  If the lock has been created, the current thread must not have "
"acquired it, otherwise deadlock ensues.  (This function is available even "
"when thread support is disabled at compile time.)"
msgstr ""
"(GIL が生成されていて、スレッドサポートが有効の場合) GIL を獲得して、現在のス"
"レッド状態を *tstate* に設定します。*tstate* は *NULL* であってはなりません。"
"GIL が生成されていて、この関数を呼び出したスレッドがすでにロックを獲得してい"
"る場合、デッドロックに陥ります。(この関数はコンパイル時にスレッドサポートが無"
"効にされていても利用できます。)"

#: ../../c-api/init.rst:664
msgid ""
"Return the current thread state.  The global interpreter lock must be held. "
"When the current thread state is *NULL*, this issues a fatal error (so that "
"the caller needn't check for *NULL*)."
msgstr ""
"現在のスレッド状態を返します。GIL を保持していなければなりません。現在のス"
"レッド状態が *NULL* なら、(呼び出し側が *NULL* チェックをしなくてすむように) "
"この関数は致命的エラーを起こすようになっています。"

#: ../../c-api/init.rst:671
msgid ""
"Swap the current thread state with the thread state given by the argument "
"*tstate*, which may be *NULL*.  The global interpreter lock must be held and "
"is not released."
msgstr ""
"現在のスレッド状態を *tstate* に指定したスレッド状態と入れ変えます。*tstate* "
"は *NULL* の場合があります。GIL を保持していなければならず、解放しません。"

#: ../../c-api/init.rst:678
msgid ""
"This function is called from :c:func:`PyOS_AfterFork` to ensure that newly "
"created child processes don't hold locks referring to threads which are not "
"running in the child process."
msgstr ""
"この関数は :c:func:`PyOS_AfterFork` から呼び出され、新しい子プロセスが、子プ"
"ロセス内で実行していないスレッドが持っているロックを持たないようにします。"

#: ../../c-api/init.rst:683
msgid ""
"The following functions use thread-local storage, and are not compatible "
"with sub-interpreters:"
msgstr ""
"以下の関数はスレッドローカルストレージを利用していて、サブインタプリタとの互"
"換性がありません:"

#: ../../c-api/init.rst:688
msgid ""
"Ensure that the current thread is ready to call the Python C API regardless "
"of the current state of Python, or of the global interpreter lock. This may "
"be called as many times as desired by a thread as long as each call is "
"matched with a call to :c:func:`PyGILState_Release`. In general, other "
"thread-related APIs may be used between :c:func:`PyGILState_Ensure` and :c:"
"func:`PyGILState_Release` calls as long as the thread state is restored to "
"its previous state before the Release().  For example, normal usage of the :"
"c:macro:`Py_BEGIN_ALLOW_THREADS` and :c:macro:`Py_END_ALLOW_THREADS` macros "
"is acceptable."
msgstr ""
"Pythonの状態やGILに関わらず、実行中スレッドでPython C APIの呼び出しが可能とな"
"るようにします。この関数はスレッド内で何度でも呼び出すことができますが、必ず"
"全ての呼び出しに対応して :c:func:`PyGILState_Release` を呼び出す必要がありま"
"す。通常、 :c:func:`PyGILState_Ensure` 呼び出しと :c:func:"
"`PyGILState_Release` 呼び出しの間でこれ以外のスレッド関連API を使用することが"
"できますが、Release()の前にスレッド状態は復元されていなければなりません。例え"
"ば、通常の :c:macro:`Py_BEGIN_ALLOW_THREADS` マクロと :c:macro:"
"`Py_END_ALLOW_THREADS` は使用することができます。"

#: ../../c-api/init.rst:698
msgid ""
"The return value is an opaque \"handle\" to the thread state when :c:func:"
"`PyGILState_Ensure` was called, and must be passed to :c:func:"
"`PyGILState_Release` to ensure Python is left in the same state. Even though "
"recursive calls are allowed, these handles *cannot* be shared - each unique "
"call to :c:func:`PyGILState_Ensure` must save the handle for its call to :c:"
"func:`PyGILState_Release`."
msgstr ""
"戻り値は :c:func:`PyGILState_Ensure` 呼び出し時のスレッド状態を隠蔽した\"ハン"
"ドル\"で、 :c:func:`PyGILState_Release` に渡してPythonを同じ状態に保たなけれ"
"ばなりません。再起呼び出しも可能ですが、ハンドルを共有することは *できません"
"* - それぞれの :c:func:`PyGILState_Ensure` 呼び出しでハンドルを保存し、対応す"
"る :c:func:`PyGILState_Release` 呼び出しで渡してください。"

#: ../../c-api/init.rst:705
msgid ""
"When the function returns, the current thread will hold the GIL and be able "
"to call arbitrary Python code.  Failure is a fatal error."
msgstr ""
"関数から復帰したとき、実行中のスレッドはGILを所有していて、任意の Python コー"
"ドを実行できます。処理の失敗は致命的なエラーです。"

#: ../../c-api/init.rst:711
msgid ""
"Release any resources previously acquired.  After this call, Python's state "
"will be the same as it was prior to the corresponding :c:func:"
"`PyGILState_Ensure` call (but generally this state will be unknown to the "
"caller, hence the use of the GILState API)."
msgstr ""
"獲得したすべてのリソースを解放します。この関数を呼び出すと、Pythonの状態は対"
"応する :c:func:`PyGILState_Ensure` を呼び出す前と同じとなります (通常、この状"
"態は呼び出し元でははわかりませんので、GILState APIを利用するようにしてくださ"
"い)。"

#: ../../c-api/init.rst:716
msgid ""
"Every call to :c:func:`PyGILState_Ensure` must be matched by a call to :c:"
"func:`PyGILState_Release` on the same thread."
msgstr ""
":c:func:`PyGILState_Ensure` を呼び出す場合は、必ず同一スレッド内で対応する :"
"c:func:`PyGILState_Release` を呼び出してください。"

#: ../../c-api/init.rst:722
msgid ""
"Get the current thread state for this thread.  May return ``NULL`` if no "
"GILState API has been used on the current thread.  Note that the main thread "
"always has such a thread-state, even if no auto-thread-state call has been "
"made on the main thread.  This is mainly a helper/diagnostic function."
msgstr ""
"このスレッドの現在のスレッドの状態を取得します。これまで現在のスレッドで "
"GILState API を使ったことが無い場合は、``NULL`` が返ります。メインスレッドで"
"自身のスレッド状態に関する呼び出しを全くしないとしても、メインスレッドは常に"
"スレッド状態の情報を持っていることに注意してください。こうなっている目的は主"
"にヘルパ機能もしくは診断機能のためです。"

#: ../../c-api/init.rst:730
msgid ""
"Return ``1`` if the current thread is holding the GIL and ``0`` otherwise. "
"This function can be called from any thread at any time. Only if it has had "
"its Python thread state initialized and currently is holding the GIL will it "
"return ``1``. This is mainly a helper/diagnostic function.  It can be useful "
"for example in callback contexts or memory allocation functions when knowing "
"that the GIL is locked can allow the caller to perform sensitive actions or "
"otherwise behave differently."
msgstr ""
"現在のスレッドが GILを保持しているならば ``1`` を、そうでなければ ``0`` を返"
"します。この関数はいつでもどのスレッドからでも呼び出すことができます。 "
"Python スレッドの状態が初期化されており、現在 GIL を保持している場合にのみ "
"``1`` を返します。これは主にヘルパー/診断用の関数です。この関数は、例えばコー"
"ルバックのコンテキストやメモリ割り当て機能で有益でしょう。なぜなら、 GIL が"
"ロックされていると知っていれば、呼び出し元は sensitive な行動を実行することが"
"でき、そうでなければ異なるやりかたで振る舞うことができるからです。"

#: ../../c-api/init.rst:742
msgid ""
"The following macros are normally used without a trailing semicolon; look "
"for example usage in the Python source distribution."
msgstr ""
"以下のマクロは、通常末尾にセミコロンを付けずに使います; Python ソース配布物内"
"の使用例を見てください。"

#: ../../c-api/init.rst:748
msgid ""
"This macro expands to ``{ PyThreadState *_save; _save = PyEval_SaveThread();"
"``. Note that it contains an opening brace; it must be matched with a "
"following :c:macro:`Py_END_ALLOW_THREADS` macro.  See above for further "
"discussion of this macro.  It is a no-op when thread support is disabled at "
"compile time."
msgstr ""
"このマクロを展開すると ``{ PyThreadState *_save; _save = PyEval_SaveThread();"
"`` になります。マクロに開き波括弧が入っていることに注意してください; この波括"
"弧は後で :c:macro:`Py_END_ALLOW_THREADS` マクロと対応させなければなりません。"
"マクロについての詳しい議論は上記を参照してください。コンパイル時にスレッドサ"
"ポートが無効化されていると何も行いません。"

#: ../../c-api/init.rst:756
msgid ""
"This macro expands to ``PyEval_RestoreThread(_save); }``. Note that it "
"contains a closing brace; it must be matched with an earlier :c:macro:"
"`Py_BEGIN_ALLOW_THREADS` macro.  See above for further discussion of this "
"macro.  It is a no-op when thread support is disabled at compile time."
msgstr ""
"このマクロを展開すると ``PyEval_RestoreThread(_save); }`` になります。マクロ"
"に開き波括弧が入っていることに注意してください; この波括弧は事前の :c:macro:"
"`Py_BEGIN_ALLOW_THREADS` マクロと対応していなければなりません。マクロについて"
"の詳しい議論は上記を参照してください。コンパイル時にスレッドサポートが無効化"
"されていると何も行いません。"

#: ../../c-api/init.rst:764
msgid ""
"This macro expands to ``PyEval_RestoreThread(_save);``: it is equivalent to :"
"c:macro:`Py_END_ALLOW_THREADS` without the closing brace.  It is a no-op "
"when thread support is disabled at compile time."
msgstr ""
"このマクロを展開すると ``PyEval_RestoreThread(_save);`` になります: 閉じ波括"
"弧のない :c:macro:`Py_END_ALLOW_THREADS` と同じです。コンパイル時にスレッドサ"
"ポートが無効化されていると何も行いません。"

#: ../../c-api/init.rst:771
msgid ""
"This macro expands to ``_save = PyEval_SaveThread();``: it is equivalent to :"
"c:macro:`Py_BEGIN_ALLOW_THREADS` without the opening brace and variable "
"declaration.  It is a no-op when thread support is disabled at compile time."
msgstr ""
"このマクロを展開すると ``_save = PyEval_SaveThread();`` になります: 開き波括"
"弧のない :c:macro:`Py_BEGIN_ALLOW_THREADS` と同じです。コンパイル時にスレッド"
"サポートが無効化されていると何も行いません。"

#: ../../c-api/init.rst:777
msgid "Low-level API"
msgstr "低レベルAPI"

#: ../../c-api/init.rst:779
msgid ""
"All of the following functions are only available when thread support is "
"enabled at compile time, and must be called only when the global interpreter "
"lock has been created."
msgstr ""
"以下の全ての関数はコンパイル時にスレッドサポートが有効になっている時だけ利用"
"でき、呼び出すのはGILがすでに作成されている場合だけにしなくてはなりません。"

#: ../../c-api/init.rst:786
msgid ""
"Create a new interpreter state object.  The global interpreter lock need not "
"be held, but may be held if it is necessary to serialize calls to this "
"function."
msgstr ""
"新しいインタプリタ状態オブジェクトを生成します。GIL を保持しておく必要はあり"
"ませんが、この関数を次々に呼び出す必要がある場合には保持しておいたほうがよい"
"でしょう。"

#: ../../c-api/init.rst:793
msgid ""
"Reset all information in an interpreter state object.  The global "
"interpreter lock must be held."
msgstr ""
"インタプリタ状態オブジェクト内の全ての情報をリセットします。GIL を保持してい"
"なければなりません。"

#: ../../c-api/init.rst:799
msgid ""
"Destroy an interpreter state object.  The global interpreter lock need not "
"be held.  The interpreter state must have been reset with a previous call "
"to :c:func:`PyInterpreterState_Clear`."
msgstr ""
"インタプリタ状態オブジェクトを破壊します。GIL を保持しておく必要はありませ"
"ん。インタプリタ状態は :c:func:`PyInterpreterState_Clear` であらかじめリセッ"
"トしておかなければなりません。"

#: ../../c-api/init.rst:806
msgid ""
"Create a new thread state object belonging to the given interpreter object. "
"The global interpreter lock need not be held, but may be held if it is "
"necessary to serialize calls to this function."
msgstr ""
"指定したインタプリタオブジェクトに属する新たなスレッド状態オブジェクトを生成"
"します。GIL を保持しておく必要はありませんが、この関数を次々に呼び出す必要が"
"ある場合には保持しておいたほうがよいでしょう。"

#: ../../c-api/init.rst:813
msgid ""
"Reset all information in a thread state object.  The global interpreter lock "
"must be held."
msgstr ""
"スレッド状態オブジェクト内の全ての情報をリセットします。GIL を保持していなけ"
"ればなりません。"

#: ../../c-api/init.rst:819
msgid ""
"Destroy a thread state object.  The global interpreter lock need not be "
"held. The thread state must have been reset with a previous call to :c:func:"
"`PyThreadState_Clear`."
msgstr ""
"スレッド状態オブジェクトを破壊します。GIL を保持する必要はありません。スレッ"
"ド状態は :c:func:`PyThreadState_Clear` であらかじめリセットしておかなければな"
"りません。"

#: ../../c-api/init.rst:826
msgid ""
"Return a dictionary in which extensions can store thread-specific state "
"information.  Each extension should use a unique key to use to store state "
"in the dictionary.  It is okay to call this function when no current thread "
"state is available. If this function returns *NULL*, no exception has been "
"raised and the caller should assume no current thread state is available."
msgstr ""
"拡張モジュールがスレッド固有の状態情報を保存できるような辞書を返します。各々"
"の拡張モジュールが辞書に状態情報を保存するためには唯一のキーを使わなければな"
"りません。現在のスレッド状態がない時にこの関数を呼び出してもかまいません。こ"
"の関数が *NULL* を返す場合、例外はまったく送出されず、呼び出し側は現在のス"
"レッド状態が利用できないと考えなければなりません。"

#: ../../c-api/init.rst:835
msgid ""
"Asynchronously raise an exception in a thread. The *id* argument is the "
"thread id of the target thread; *exc* is the exception object to be raised. "
"This function does not steal any references to *exc*. To prevent naive "
"misuse, you must write your own C extension to call this.  Must be called "
"with the GIL held. Returns the number of thread states modified; this is "
"normally one, but will be zero if the thread id isn't found.  If *exc* is :"
"const:`NULL`, the pending exception (if any) for the thread is cleared. This "
"raises no exceptions."
msgstr ""
"スレッド内で非同期的に例外を送出します。 *id* 引数はターゲットとなるスレッド"
"のスレッド id です; *exc* は送出する例外オブジェクトです。この関数は *exc* に"
"対する参照を一切盗み取りません。安直な間違いを防ぐため、この関数を呼び出すに"
"は独自に C 拡張モジュールを書かなければなりません。 GIL を保持した状態で呼び"
"出さなければなりません。状態が変更されたスレッドの数を返します; 通常は 1 です"
"が、スレッドが見付からなかった場合は 0 になることもあります。 *exc* が :"
"const:`NULL` の場合は、このスレッドのまだ送出されていない例外は (何であれ) 消"
"去されます。この場合は例外を送出しません。"

#: ../../c-api/init.rst:846
msgid ""
"Acquire the global interpreter lock and set the current thread state to "
"*tstate*, which should not be *NULL*.  The lock must have been created "
"earlier. If this thread already has the lock, deadlock ensues."
msgstr ""
"GIL を獲得し、現在のスレッド状態を *tstate* に設定します。 *tstate* は "
"*NULL* であってはなりません。ロックはあらかじめ作成されていなければなりませ"
"ん。この関数を呼び出したスレッドがすでにロックを獲得している場合、デッドロッ"
"クに陥ります。"

#: ../../c-api/init.rst:850
msgid ""
":c:func:`PyEval_RestoreThread` is a higher-level function which is always "
"available (even when thread support isn't enabled or when threads have not "
"been initialized)."
msgstr ""
":c:func:`PyEval_RestoreThread` はいつでも (スレッドサポートが有効でないときや"
"スレッドが初期化されたいないときでさえ) 利用可能な高レベル関数です。"

#: ../../c-api/init.rst:857
msgid ""
"Reset the current thread state to *NULL* and release the global interpreter "
"lock.  The lock must have been created earlier and must be held by the "
"current thread.  The *tstate* argument, which must not be *NULL*, is only "
"used to check that it represents the current thread state --- if it isn't, a "
"fatal error is reported."
msgstr ""
"現在のスレッド状態をリセットして *NULL* にし、GIL を解放します。ロックはあら"
"かじめ作成されていなければならず、かつ現在のスレッドが保持していなければなり"
"ません。*tstate* は *NULL* であってはなりませんが、その値が現在のスレッド状態"
"を表現しているかどうかを調べるためにだけ使われます --- もしそうでなければ、致"
"命的エラーが報告されます。"

#: ../../c-api/init.rst:863
msgid ""
":c:func:`PyEval_SaveThread` is a higher-level function which is always "
"available (even when thread support isn't enabled or when threads have not "
"been initialized)."
msgstr ""
":c:func:`PyEval_SaveThread` はより高レベルな関数で常に(スレッドサポートが無効"
"な場合やスレッドが初期化されていない場合でも)利用できます。"

#: ../../c-api/init.rst:870
msgid ""
"Acquire the global interpreter lock.  The lock must have been created "
"earlier. If this thread already has the lock, a deadlock ensues."
msgstr ""
"GILを獲得します。ロックは前もって作成されていなければなりません。この関数を呼"
"び出したスレッドがすでにロックを獲得している場合、デッドロックに陥ります。"

#: ../../c-api/init.rst:873
msgid ""
"This function does not update the current thread state.  Please use :c:func:"
"`PyEval_RestoreThread` or :c:func:`PyEval_AcquireThread` instead."
msgstr ""
"この関数は現在のスレッドの状態を更新しません。代わりに :c:func:"
"`PyEval_RestoreThread` もしくは :c:func:`PyEval_AcquireThread` を使用してくだ"
"さい。"

#: ../../c-api/init.rst:881
msgid ""
"Release the global interpreter lock.  The lock must have been created "
"earlier."
msgstr "GILを解放します。ロックは前もって作成されていなければなりません。"

#: ../../c-api/init.rst:883
msgid ""
"This function does not update the current thread state.  Please use :c:func:"
"`PyEval_SaveThread` or :c:func:`PyEval_ReleaseThread` instead."
msgstr ""
"この関数は現在のスレッドの状態を更新しません。代わりに :c:func:"
"`PyEval_SaveThread` もしくは :c:func:`PyEval_ReleaseThread` を使用してくださ"
"い。"

#: ../../c-api/init.rst:892
msgid "Sub-interpreter support"
msgstr "サブインタプリタサポート"

#: ../../c-api/init.rst:894
msgid ""
"While in most uses, you will only embed a single Python interpreter, there "
"are cases where you need to create several independent interpreters in the "
"same process and perhaps even in the same thread.  Sub-interpreters allow "
"you to do that.  You can switch between sub-interpreters using the :c:func:"
"`PyThreadState_Swap` function.  You can create and destroy them using the "
"following functions:"
msgstr ""
"ほとんどの場合は埋め込む Python インタプリタは1つだけですが、いくつかの場合に"
"同一プロセス内、あるいは同一スレッド内で、複数の独立したインタプリタを作成す"
"る必要があります。サブインタプリタはこれを可能にします。 :c:func:"
"`PyThreadState_Swap` 関数を使ってサブインタプリタを切り替えることができます。"
"以下の関数を使ってサブインタプリタの作成と削除を行えます:"

#: ../../c-api/init.rst:912
msgid ""
"Create a new sub-interpreter.  This is an (almost) totally separate "
"environment for the execution of Python code.  In particular, the new "
"interpreter has separate, independent versions of all imported modules, "
"including the fundamental modules :mod:`builtins`, :mod:`__main__` and :mod:"
"`sys`.  The table of loaded modules (``sys.modules``) and the module search "
"path (``sys.path``) are also separate.  The new environment has no ``sys."
"argv`` variable.  It has new standard I/O stream file objects ``sys.stdin``, "
"``sys.stdout`` and ``sys.stderr`` (however these refer to the same "
"underlying file descriptors)."
msgstr ""
"新しいサブインタプリタ (sub-interpreter) を生成します。サブインタプリタとは、"
"(ほぼ完全に) 個別に分割された Python コードの実行環境です。特に、新しいサブイ"
"ンタプリタは、 import されるモジュール全てについて個別のバージョンを持ち、こ"
"れには基盤となるモジュール :mod:`builtins`, :mod:`__main__` および :mod:"
"`sys` も含まれます。ロード済みのモジュールからなるテーブル (``sys."
"modules``)  およびモジュール検索パス (``sys.path``) もサブインタプリタ毎に別"
"個のものになります。新たなサブインタプリタ環境には ``sys.argv`` 変数がありま"
"せん。また、サブインタプリタは新たな標準 I/O ストリーム ``sys.stdin``, ``sys."
"stdout``, ``sys.stderr`` を持ちます (とはいえ、これらのストリームは根底にある"
"同じファイル記述子を参照しています)。"

#: ../../c-api/init.rst:922
msgid ""
"The return value points to the first thread state created in the new sub-"
"interpreter.  This thread state is made in the current thread state. Note "
"that no actual thread is created; see the discussion of thread states "
"below.  If creation of the new interpreter is unsuccessful, *NULL* is "
"returned; no exception is set since the exception state is stored in the "
"current thread state and there may not be a current thread state.  (Like all "
"other Python/C API functions, the global interpreter lock must be held "
"before calling this function and is still held when it returns; however, "
"unlike most other Python/C API functions, there needn't be a current thread "
"state on entry.)"
msgstr ""
"戻り値は、新たなサブインタプリタが生成したスレッド状態 (thread state) オブ"
"ジェクトのうち、最初のものを指しています。このスレッド状態が現在のスレッド状"
"態 (current thread state) になります。実際のスレッドが生成されるわけではない"
"ので注意してください; 下記のスレッド状態に関する議論を参照してください。新た"
"なインタプリタの生成に失敗すると、*NULL* を返します; 例外状態はセットされませ"
"んが、これは例外状態が現在のスレッド状態に保存されることになっていて、現在の"
"スレッド状態なるものが存在しないことがあるからです。(他の Python/C API 関数の"
"ように、この関数を呼び出す前にはGILが保持されていなければならず、関数が処理を"
"戻した際にも保持されたままになります; しかし、他の Python/C API 関数とは違"
"い、関数から戻ったときの現在のスレッド状態が関数に入るときと同じとは限らない"
"ので注意してください。)"

#: ../../c-api/init.rst:937
msgid ""
"Extension modules are shared between (sub-)interpreters as follows: the "
"first time a particular extension is imported, it is initialized normally, "
"and a (shallow) copy of its module's dictionary is squirreled away.  When "
"the same extension is imported by another (sub-)interpreter, a new module is "
"initialized and filled with the contents of this copy; the extension's "
"``init`` function is not called.  Note that this is different from what "
"happens when an extension is imported after the interpreter has been "
"completely re-initialized by calling :c:func:`Py_FinalizeEx` and :c:func:"
"`Py_Initialize`; in that case, the extension's ``initmodule`` function *is* "
"called again."
msgstr ""
"拡張モジュールは以下のような形で (サブ) インタプリタ間で共有されます: ある特"
"定の拡張モジュールを最初に import すると、モジュールを通常通りに初期化し、そ"
"のモジュールの辞書の (浅い) コピーをしまい込んでおきます。他の (サブ) インタ"
"プリタが同じ拡張モジュールを import すると、新たなモジュールを初期化し、先ほ"
"どのコピーの内容で辞書の値を埋めます; 拡張モジュールの ``init`` 関数は呼び出"
"されません。この挙動は、 :c:func:`Py_FinalizeEx` および :c:func:"
"`Py_Initialize` を呼び出してインタプリタを完全に再初期化した後に拡張モジュー"
"ルを import した際の挙動とは異なるので注意してください; 再初期化後に import "
"を行うと、拡張モジュールの ``initmodule`` は再度 *呼び出されます* 。"

#: ../../c-api/init.rst:954
msgid ""
"Destroy the (sub-)interpreter represented by the given thread state. The "
"given thread state must be the current thread state.  See the discussion of "
"thread states below.  When the call returns, the current thread state is "
"*NULL*.  All thread states associated with this interpreter are destroyed.  "
"(The global interpreter lock must be held before calling this function and "
"is still held when it returns.)  :c:func:`Py_FinalizeEx` will destroy all "
"sub-interpreters that haven't been explicitly destroyed at that point."
msgstr ""
"指定されたスレッド状態 *tstate* で表現される (サブ) インタプリタを抹消しま"
"す。 *tstate* は現在のスレッド状態でなければなりません。下記のスレッド状態に"
"関する議論を参照してください。関数呼び出しが戻ったとき、現在のスレッド状態は "
"*NULL* になっています。このインタプリタに関連付けられた全てのスレッド状態は抹"
"消されます。 (この関数を呼び出す前にはGILを保持しておかなければならず、ロック"
"は関数が戻ったときも保持されています。) :c:func:`Py_FinalizeEx` は、その時点"
"で明示的に抹消されていない全てのサブインタプリタを抹消します。"

#: ../../c-api/init.rst:964
msgid "Bugs and caveats"
msgstr "バグと注意事項"

#: ../../c-api/init.rst:966
msgid ""
"Because sub-interpreters (and the main interpreter) are part of the same "
"process, the insulation between them isn't perfect --- for example, using "
"low-level file operations like  :func:`os.close` they can (accidentally or "
"maliciously) affect each other's open files.  Because of the way extensions "
"are shared between (sub-)interpreters, some extensions may not work "
"properly; this is especially likely when the extension makes use of (static) "
"global variables, or when the extension manipulates its module's dictionary "
"after its initialization.  It is possible to insert objects created in one "
"sub-interpreter into a namespace of another sub-interpreter; this should be "
"done with great care to avoid sharing user-defined functions, methods, "
"instances or classes between sub-interpreters, since import operations "
"executed by such objects may affect the wrong (sub-)interpreter's dictionary "
"of loaded modules."
msgstr ""
"サブインタプリタ (とメインインタプリタ) は同じプロセスの一部分なので、インタ"
"プリタ間の隔離は完璧ではありません --- 例えば、 :func:`os.close` のような低レ"
"ベルのファイル操作を使うと、 (偶然なり故意なりに) 互いのインタプリタ下にある"
"開かれたファイルに影響を及ぼせてしまいます。拡張モジュールを (サブ) インタプ"
"リタ間で共有する方法のせいで、拡張モジュールによっては正しく動作しないかもし"
"れません; 拡張モジュールが (静的な) グローバル変数を利用している場合や、拡張"
"モジュールが初期化後に自身のモジュール辞書を操作する場合には特にそうです。一"
"つのサブインタプリタで生成されたオブジェクトは他のサブインタプリタの名前空間"
"への挿入が可能です; ユーザ定義関数、メソッド、インスタンスおよびクラスをサブ"
"インタプリタをサブインタプリタ間で共有しないように十分注意してください。とい"
"うのは、これらの共有オブジェクトが実行した import 文は間違った (サブ) インタ"
"プリタのロード済みモジュール辞書に影響を及ぼす場合があるからです。"

#: ../../c-api/init.rst:980
msgid ""
"Also note that combining this functionality with :c:func:`PyGILState_\\*` "
"APIs is delicate, because these APIs assume a bijection between Python "
"thread states and OS-level threads, an assumption broken by the presence of "
"sub-interpreters. It is highly recommended that you don't switch sub-"
"interpreters between a pair of matching :c:func:`PyGILState_Ensure` and :c:"
"func:`PyGILState_Release` calls. Furthermore, extensions (such as :mod:"
"`ctypes`) using these APIs to allow calling of Python code from non-Python "
"created threads will probably be broken when using sub-interpreters."
msgstr ""
"サブインタプリタを :c:func:`PyGILState_\\*` API と組み合わせるのが難しいこと"
"にも注意してください。これらのAPIはPythonのスレッド状態とOSレベルスレッドが1"
"対1で対応していることを前提にしていて、サブインタプリタが存在するとその前提が"
"崩れるからです。対応する :c:func:`PyGILState_Ensure` と :c:func:"
"`PyGILState_Release` の呼び出しのペアの間では、サブインタプリタの切り替えを行"
"わないことを強く推奨します。さらに、(:mod:`ctypes` のような)これらのAPIを使っ"
"てPythonの外で作られたスレッドから Pythonコードを実行している拡張モジュールは"
"サブインタプリタを使うと壊れる可能性があります。"

#: ../../c-api/init.rst:991
msgid "Asynchronous Notifications"
msgstr "非同期通知"

#: ../../c-api/init.rst:993
msgid ""
"A mechanism is provided to make asynchronous notifications to the main "
"interpreter thread.  These notifications take the form of a function pointer "
"and a void pointer argument."
msgstr ""
"インタプリタのメインスレッドに非同期な通知を行うために提供されている仕組みで"
"す。これらの通知は関数ポインタと void ポインタ引数という形態を取ります。"

#: ../../c-api/init.rst:1002
msgid ""
"Schedule a function to be called from the main interpreter thread.  On "
"success, ``0`` is returned and *func* is queued for being called in the main "
"thread.  On failure, ``-1`` is returned without setting any exception."
msgstr ""
"インタプリタのメインスレッドから関数が呼び出される予定を組みます。成功すると "
"``0`` が返り、*func* はメインスレッドの呼び出しキューに詰められます。失敗する"
"と、例外をセットせずに ``-1`` が返ります。"

#: ../../c-api/init.rst:1006
msgid ""
"When successfully queued, *func* will be *eventually* called from the main "
"interpreter thread with the argument *arg*.  It will be called "
"asynchronously with respect to normally running Python code, but with both "
"these conditions met:"
msgstr ""
"無事にキューに詰められると、*func* は *いつかは必ず* インタプリタのメインス"
"レッドから、*arg* を引数として呼び出されます。この関数は、通常の実行中の "
"Python コードに対して非同期に呼び出されますが、次の両方の条件に合致したときに"
"呼び出されます:"

#: ../../c-api/init.rst:1011
msgid "on a :term:`bytecode` boundary;"
msgstr ":term:`bytecode` 境界上にいるとき、"

#: ../../c-api/init.rst:1012
msgid ""
"with the main thread holding the :term:`global interpreter lock` (*func* can "
"therefore use the full C API)."
msgstr ""
"メインスレッドが :term:`global interpreter lock` を保持している (すなわち "
"*func* が全ての C API を呼び出せる) とき。"

#: ../../c-api/init.rst:1015
msgid ""
"*func* must return ``0`` on success, or ``-1`` on failure with an exception "
"set.  *func* won't be interrupted to perform another asynchronous "
"notification recursively, but it can still be interrupted to switch threads "
"if the global interpreter lock is released."
msgstr ""
"成功したら *func* は ``0`` を返さねばならず、失敗したら ``-1`` を返し例外を"
"セットしなければいけません。*func* は、他の非同期通知を行うために、さらに割り"
"込まれることはありませんが、グローバルインタプリタロックが解放された場合は、"
"スレッドの切り替えによって割り込まれる可能性が残っています。"

#: ../../c-api/init.rst:1020
msgid ""
"This function doesn't need a current thread state to run, and it doesn't "
"need the global interpreter lock."
msgstr ""
"この関数は実行するのに現在のスレッド状態を必要とせず、グローバルインタプリタ"
"ロックも必要としません。"

#: ../../c-api/init.rst:1024
msgid ""
"This is a low-level function, only useful for very special cases. There is "
"no guarantee that *func* will be called as quick as possible.  If the main "
"thread is busy executing a system call, *func* won't be called before the "
"system call returns.  This function is generally **not** suitable for "
"calling Python code from arbitrary C threads.  Instead, use the :ref:"
"`PyGILState API<gilstate>`."
msgstr ""
"これは、非常に特別な場合にのみ役立つ、低レベルな関数です。 *func* が可能な限"
"り早く呼び出される保証はありません。メインスレッドがシステムコールを実行する"
"のに忙しい場合は、 *func* はシステムコールが返ってくるまで呼び出されないで"
"しょう。この関数は一般的には、任意の C スレッドから Python コードを呼び出すの"
"には **向きません** 。これの代わりに、 :ref:`PyGILState API<gilstate>` を使用"
"してください。"

#: ../../c-api/init.rst:1036
msgid "Profiling and Tracing"
msgstr "プロファイルとトレース (profiling and tracing)"

#: ../../c-api/init.rst:1041
msgid ""
"The Python interpreter provides some low-level support for attaching "
"profiling and execution tracing facilities.  These are used for profiling, "
"debugging, and coverage analysis tools."
msgstr ""
"Python インタプリタは、プロファイル: 分析 (profile) や実行のトレース: 追跡 "
"(trace) といった機能を組み込むために低水準のサポートを提供しています。このサ"
"ポートは、プロファイルやデバッグ、適用範囲分析 (coverage analysis) ツールなど"
"に使われます。"

#: ../../c-api/init.rst:1045
msgid ""
"This C interface allows the profiling or tracing code to avoid the overhead "
"of calling through Python-level callable objects, making a direct C function "
"call instead.  The essential attributes of the facility have not changed; "
"the interface allows trace functions to be installed per-thread, and the "
"basic events reported to the trace function are the same as had been "
"reported to the Python-level trace functions in previous versions."
msgstr ""
"この C インタフェースは、プロファイルやトレース作業時に、Python レベルの呼び"
"出し可能オブジェクトが呼び出されることによるオーバヘッドを避け、直接 C 関数呼"
"び出しが行えるようにしています。プロファイルやトレース機能の本質的な特性は変"
"わっていません; インタフェースではトレース関数をスレッドごとにインストールで"
"き、トレース関数に報告される基本イベント (basic event) は以前のバージョンにお"
"いて Python レベルのトレース関数で報告されていたものと同じです。"

#: ../../c-api/init.rst:1055
msgid ""
"The type of the trace function registered using :c:func:`PyEval_SetProfile` "
"and :c:func:`PyEval_SetTrace`. The first parameter is the object passed to "
"the registration function as *obj*, *frame* is the frame object to which the "
"event pertains, *what* is one of the constants :const:`PyTrace_CALL`, :const:"
"`PyTrace_EXCEPTION`, :const:`PyTrace_LINE`, :const:`PyTrace_RETURN`, :const:"
"`PyTrace_C_CALL`, :const:`PyTrace_C_EXCEPTION`, or :const:"
"`PyTrace_C_RETURN`, and *arg* depends on the value of *what*:"
msgstr ""
":c:func:`PyEval_SetProfile` および :c:func:`PyEval_SetTrace` を使って登録でき"
"るトレース関数の形式です。最初のパラメタはオブジェクトで、登録関数に *obj* と"
"して渡されます。 *frame* はイベントが属している実行フレームオブジェクトで、 "
"*what* は定数 :const:`PyTrace_CALL`, :const:`PyTrace_EXCEPTION`, :const:"
"`PyTrace_LINE`, :const:`PyTrace_RETURN`, :const:`PyTrace_C_CALL`, :const:"
"`PyTrace_C_EXCEPTION`, あるいは :const:`PyTrace_C_RETURN` のいずれかで、 "
"*arg* は *what* の値によって以下のように異なります:"

#: ../../c-api/init.rst:1064
msgid "Value of *what*"
msgstr "*what* の値"

#: ../../c-api/init.rst:1064
msgid "Meaning of *arg*"
msgstr "*arg* の意味"

#: ../../c-api/init.rst:1066
msgid ":const:`PyTrace_CALL`"
msgstr ":const:`PyTrace_CALL`"

#: ../../c-api/init.rst:1066 ../../c-api/init.rst:1071
msgid "Always :c:data:`Py_None`."
msgstr "常に :c:data:`Py_None` 。"

#: ../../c-api/init.rst:1068
msgid ":const:`PyTrace_EXCEPTION`"
msgstr ":const:`PyTrace_EXCEPTION`"

#: ../../c-api/init.rst:1068
msgid "Exception information as returned by :func:`sys.exc_info`."
msgstr ":func:`sys.exc_info` の返す例外情報です。"

#: ../../c-api/init.rst:1071
msgid ":const:`PyTrace_LINE`"
msgstr ":const:`PyTrace_LINE`"

#: ../../c-api/init.rst:1073
msgid ":const:`PyTrace_RETURN`"
msgstr ":const:`PyTrace_RETURN`"

#: ../../c-api/init.rst:1073
msgid ""
"Value being returned to the caller, or *NULL* if caused by an exception."
msgstr ""
"呼び出し側に返される予定の値か、例外によって関数を抜ける場合は *NULL* です。"

#: ../../c-api/init.rst:1076
msgid ":const:`PyTrace_C_CALL`"
msgstr ":const:`PyTrace_C_CALL`"

#: ../../c-api/init.rst:1076 ../../c-api/init.rst:1078
#: ../../c-api/init.rst:1080
msgid "Function object being called."
msgstr "呼び出される関数オブジェクト。"

#: ../../c-api/init.rst:1078
msgid ":const:`PyTrace_C_EXCEPTION`"
msgstr ":const:`PyTrace_C_EXCEPTION`"

#: ../../c-api/init.rst:1080
msgid ":const:`PyTrace_C_RETURN`"
msgstr ":const:`PyTrace_C_RETURN`"

#: ../../c-api/init.rst:1086
msgid ""
"The value of the *what* parameter to a :c:type:`Py_tracefunc` function when "
"a new call to a function or method is being reported, or a new entry into a "
"generator. Note that the creation of the iterator for a generator function "
"is not reported as there is no control transfer to the Python bytecode in "
"the corresponding frame."
msgstr ""
"関数やメソッドが新たに呼び出されたり、ジェネレータが新たなエントリの処理に"
"入ったことを報告する際の、 :c:type:`Py_tracefunc` の *what* の値です。イテ"
"レータやジェネレータ関数の生成は、対応するフレーム内の Python バイトコードに"
"制御の委譲 (control transfer) が起こらないため報告されないので注意してくださ"
"い。"

#: ../../c-api/init.rst:1095
msgid ""
"The value of the *what* parameter to a :c:type:`Py_tracefunc` function when "
"an exception has been raised.  The callback function is called with this "
"value for *what* when after any bytecode is processed after which the "
"exception becomes set within the frame being executed.  The effect of this "
"is that as exception propagation causes the Python stack to unwind, the "
"callback is called upon return to each frame as the exception propagates.  "
"Only trace functions receives these events; they are not needed by the "
"profiler."
msgstr ""
"例外が送出された際の :c:type:`Py_tracefunc` の *what* の値です。現在実行され"
"ているフレームで例外がセットされ、何らかのバイトコードが処理された後に、 "
"*what* にこの値がセットされた状態でコールバック関数が呼び出されます。この結"
"果、例外の伝播によって Python が呼び出しスタックを逆戻りする際に、各フレーム"
"から処理が戻るごとにコールバック関数が呼び出されます。トレース関数だけがこれ"
"らのイベントを受け取ります; プロファイラはこの種のイベントを必要としません。"

#: ../../c-api/init.rst:1106
msgid ""
"The value passed as the *what* parameter to a trace function (but not a "
"profiling function) when a line-number event is being reported."
msgstr ""
"行番号イベントを報告するときに (プロファイル関数ではなく) トレース関数の "
"*what* パラメタとして渡す値です。"

#: ../../c-api/init.rst:1112
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a call is about to return."
msgstr ""
"呼び出しが返るときに :c:type:`Py_tracefunc` 関数に *what* パラメタとして渡す"
"値です。"

#: ../../c-api/init.rst:1118
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a C function is about to be called."
msgstr ""
"C関数を呼び出す直前に :c:type:`Py_tracefunc` 関数の *what* パラメタとして渡す"
"値です。"

#: ../../c-api/init.rst:1124
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a C function has raised an exception."
msgstr ""
"C関数が例外を送出したときに :c:type:`Py_tracefunc` 関数の *what* パラメタとし"
"て渡す値です。"

#: ../../c-api/init.rst:1130
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a C function has returned."
msgstr ""
"C関数から戻るときに :c:type:`Py_tracefunc` 関数の *what* パラメタとして渡す値"
"です。"

#: ../../c-api/init.rst:1136
msgid ""
"Set the profiler function to *func*.  The *obj* parameter is passed to the "
"function as its first parameter, and may be any Python object, or *NULL*.  "
"If the profile function needs to maintain state, using a different value for "
"*obj* for each thread provides a convenient and thread-safe place to store "
"it.  The profile function is called for all monitored events except :const:"
"`PyTrace_LINE` and :const:`PyTrace_EXCEPTION`."
msgstr ""
"プロファイル関数を *func* に設定します。\n"
"*obj* パラメータは関数の第一パラメータとして渡されるもので、何らかの Python "
"オブジェクトあるいは *NULL* です。\n"
"プロファイル関数がスレッド状態を維持する必要があるなら、各々のスレッドに異な"
"る *obj* を使うことで、状態を記憶しておく便利でスレッドセーフな場所を提供でき"
"ます。\n"
"プロファイル関数は、モニタされているイベントのうち、 :const:`PyTrace_LINE`, :"
"const:`PyTrace_EXCEPTION` を除く全てのイベントに対して呼び出されます。"

#: ../../c-api/init.rst:1146
msgid ""
"Set the tracing function to *func*.  This is similar to :c:func:"
"`PyEval_SetProfile`, except the tracing function does receive line-number "
"events and does not receive any event related to C function objects being "
"called. Any trace function registered using :c:func:`PyEval_SetTrace` will "
"not receive :const:`PyTrace_C_CALL`, :const:`PyTrace_C_EXCEPTION` or :const:"
"`PyTrace_C_RETURN` as a value for the *what* parameter."
msgstr ""

#: ../../c-api/init.rst:1156
msgid ""
"Return a tuple of function call counts.  There are constants defined for the "
"positions within the tuple:"
msgstr ""
"Return a tuple of function call counts.  There are constants defined for the "
"positions within the tuple:"

#: ../../c-api/init.rst:1160
msgid "Name"
msgstr "名前"

#: ../../c-api/init.rst:1160
msgid "Value"
msgstr "値"

#: ../../c-api/init.rst:1162
msgid ":const:`PCALL_ALL`"
msgstr ":const:`PCALL_ALL`"

#: ../../c-api/init.rst:1162
msgid "0"
msgstr "0"

#: ../../c-api/init.rst:1164
msgid ":const:`PCALL_FUNCTION`"
msgstr ":const:`PCALL_FUNCTION`"

#: ../../c-api/init.rst:1164
msgid "1"
msgstr "1"

#: ../../c-api/init.rst:1166
msgid ":const:`PCALL_FAST_FUNCTION`"
msgstr ":const:`PCALL_FAST_FUNCTION`"

#: ../../c-api/init.rst:1166
msgid "2"
msgstr "2"

#: ../../c-api/init.rst:1168
msgid ":const:`PCALL_FASTER_FUNCTION`"
msgstr ":const:`PCALL_FASTER_FUNCTION`"

#: ../../c-api/init.rst:1168
msgid "3"
msgstr "3"

#: ../../c-api/init.rst:1170
msgid ":const:`PCALL_METHOD`"
msgstr ":const:`PCALL_METHOD`"

#: ../../c-api/init.rst:1170
msgid "4"
msgstr "4"

#: ../../c-api/init.rst:1172
msgid ":const:`PCALL_BOUND_METHOD`"
msgstr ":const:`PCALL_BOUND_METHOD`"

#: ../../c-api/init.rst:1172
msgid "5"
msgstr "5"

#: ../../c-api/init.rst:1174
msgid ":const:`PCALL_CFUNCTION`"
msgstr ":const:`PCALL_CFUNCTION`"

#: ../../c-api/init.rst:1174
msgid "6"
msgstr "6"

#: ../../c-api/init.rst:1176
msgid ":const:`PCALL_TYPE`"
msgstr ":const:`PCALL_TYPE`"

#: ../../c-api/init.rst:1176
msgid "7"
msgstr "7"

#: ../../c-api/init.rst:1178
msgid ":const:`PCALL_GENERATOR`"
msgstr ":const:`PCALL_GENERATOR`"

#: ../../c-api/init.rst:1178
msgid "8"
msgstr "8"

#: ../../c-api/init.rst:1180
msgid ":const:`PCALL_OTHER`"
msgstr ":const:`PCALL_OTHER`"

#: ../../c-api/init.rst:1180
msgid "9"
msgstr "9"

#: ../../c-api/init.rst:1182
msgid ":const:`PCALL_POP`"
msgstr ":const:`PCALL_POP`"

#: ../../c-api/init.rst:1182
msgid "10"
msgstr "10"

#: ../../c-api/init.rst:1185
msgid ""
":const:`PCALL_FAST_FUNCTION` means no argument tuple needs to be created. :"
"const:`PCALL_FASTER_FUNCTION` means that the fast-path frame setup code is "
"used."
msgstr ""
":const:`PCALL_FAST_FUNCTION` means no argument tuple needs to be created. :"
"const:`PCALL_FASTER_FUNCTION` means that the fast-path frame setup code is "
"used."

#: ../../c-api/init.rst:1188
msgid ""
"If there is a method call where the call can be optimized by changing the "
"argument tuple and calling the function directly, it gets recorded twice."
msgstr ""
"If there is a method call where the call can be optimized by changing the "
"argument tuple and calling the function directly, it gets recorded twice."

#: ../../c-api/init.rst:1192
msgid ""
"This function is only present if Python is compiled with :const:"
"`CALL_PROFILE` defined."
msgstr ""
"This function is only present if Python is compiled with :const:"
"`CALL_PROFILE` defined."

#: ../../c-api/init.rst:1198
msgid "Advanced Debugger Support"
msgstr "高度なデバッガサポート (advanced debugger support)"

#: ../../c-api/init.rst:1203
msgid ""
"These functions are only intended to be used by advanced debugging tools."
msgstr "以下の関数は高度なデバッグツールでの使用のためだけのものです。"

#: ../../c-api/init.rst:1208
msgid ""
"Return the interpreter state object at the head of the list of all such "
"objects."
msgstr ""
"インタプリタ状態オブジェクトからなるリストのうち、先頭にあるものを返します。"

#: ../../c-api/init.rst:1213
msgid ""
"Return the next interpreter state object after *interp* from the list of all "
"such objects."
msgstr ""
"インタプリタ状態オブジェクトからなるリストのうち、*interp* の次にあるものを返"
"します。"

#: ../../c-api/init.rst:1219
msgid ""
"Return the pointer to the first :c:type:`PyThreadState` object in the list "
"of threads associated with the interpreter *interp*."
msgstr ""
"インタプリタ *interp* に関連付けられているスレッドからなるリストのうち、先頭"
"にある :c:type:`PyThreadState` オブジェクトを返します。"

#: ../../c-api/init.rst:1225
msgid ""
"Return the next thread state object after *tstate* from the list of all such "
"objects belonging to the same :c:type:`PyInterpreterState` object."
msgstr ""
"*tstate* と同じ :c:type:`PyInterpreterState` オブジェクトに属しているスレッド"
"状態オブジェクトのうち、 *tstate* の次にあるものを返します。"
