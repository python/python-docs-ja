# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2015
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-21 01:52+0900\n"
"PO-Revision-Date: 2018-01-20 20:54+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/intro.rst:8
msgid "Introduction"
msgstr "ã¯ã˜ã‚ã«"

#: ../../c-api/intro.rst:10
msgid ""
"The Application Programmer's Interface to Python gives C and C++ programmers"
" access to the Python interpreter at a variety of levels.  The API is "
"equally usable from C++, but for brevity it is generally referred to as the "
"Python/C API.  There are two fundamentally different reasons for using the "
"Python/C API. The first reason is to write *extension modules* for specific "
"purposes; these are C modules that extend the Python interpreter.  This is "
"probably the most common use.  The second reason is to use Python as a "
"component in a larger application; this technique is generally referred to "
"as :dfn:`embedding` Python in an application."
msgstr "Python ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ—ãƒ­ã‚°ãƒ©ãƒç”¨ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ (Application Programmer's Interface, API) ã¯ã€ Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«å¯¾ã™ã‚‹æ§˜ã€…ãªãƒ¬ãƒ™ãƒ«ã§ã®ã‚¢ã‚¯ã‚»ã‚¹æ‰‹æ®µã‚’ C ã‚„ C++ ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒã«æä¾›ã—ã¦ã„ã¾ã™ã€‚ã“ã® API ã¯é€šå¸¸ C++ ã‹ã‚‰ã‚‚å…¨ãåŒã˜ã‚ˆã†ã«åˆ©ç”¨ã§ãã‚‹ã®ã§ã™ãŒã€ç°¡æ½”ãªå‘¼ã³åã«ã™ã‚‹ãŸã‚ã« Python/C API ã¨åã¥ã‘ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚æ ¹æœ¬çš„ã«ç•°ãªã‚‹äºŒã¤ã®ç›®çš„ã‹ã‚‰ã€ Python/C API ãŒç”¨ã„ã‚‰ã‚Œã¾ã™ã€‚ç¬¬ä¸€ã¯ã€ç‰¹å®šç”¨é€”ã® *æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« (extention module)* ã€ã™ãªã‚ã¡ Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’æ‹¡å¼µã™ã‚‹ C ã§æ›¸ã‹ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¨˜è¿°ã™ã‚‹ã€ã¨ã„ã†ç›®çš„ã§ã™ã€‚ç¬¬äºŒã¯ã€ã‚ˆã‚Šå¤§è¦æ¨¡ãªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å†…ã§ Python ã‚’æ§‹æˆè¦ç´  (component) ã¨ã—ã¦åˆ©ç”¨ã™ã‚‹ã¨ã„ã†ç›®çš„ã§ã™; ã“ã®ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã¯ã€ä¸€èˆ¬çš„ã«ã¯ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¸ã® Python ã®åŸ‹ã‚è¾¼ã¿ (:dfn:`embedding`) ã¨å‘¼ã³ã¾ã™ã€‚"

#: ../../c-api/intro.rst:20
msgid ""
"Writing an extension module is a relatively well-understood process,  where "
"a \"cookbook\" approach works well.  There are several tools  that automate "
"the process to some extent.  While people have embedded  Python in other "
"applications since its early existence, the process of  embedding Python is "
"less straightforward than writing an extension."
msgstr "æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä½œæˆã¯æ¯”è¼ƒçš„ã‚ã‹ã‚Šã‚„ã™ã„ãƒ—ãƒ­ã‚»ã‚¹ã§ã€\"æ‰‹å¼•æ›¸ (cookbook)\" çš„ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§ã†ã¾ãå®Ÿç¾ã§ãã¾ã™ã€‚ä½œæ¥­ã‚’ã‚ã‚‹ç¨‹åº¦ã¾ã§è‡ªå‹•åŒ–ã—ã¦ãã‚Œã‚‹ãƒ„ãƒ¼ãƒ«ã‚‚ã„ãã¤ã‹ã‚ã‚Šã¾ã™ã€‚ä¸€æ–¹ã€ä»–ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¸ã® Python ã®åŸ‹ã‚è¾¼ã¿ã¯ã€Python ãŒã§ãã¦ã‹ã‚‰æ—©ã„æ™‚æœŸã‹ã‚‰è¡Œã‚ã‚Œã¦ãã¾ã—ãŸãŒã€æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä½œæˆã«æ¯”ã¹ã‚‹ã¨ã‚„ã‚„é›£è§£ã§ã™ã€‚"

#: ../../c-api/intro.rst:26
msgid ""
"Many API functions are useful independent of whether you're embedding  or "
"extending Python; moreover, most applications that embed Python  will need "
"to provide a custom extension as well, so it's probably a  good idea to "
"become familiar with writing an extension before  attempting to embed Python"
" in a real application."
msgstr "å¤šãã® API é–¢æ•°ã¯ã€Python ã®åŸ‹ã‚è¾¼ã¿ã§ã‚ã‚‹ã‹æ‹¡å¼µã§ã‚ã‚‹ã‹ã«é–¢ã‚ã‚‰ãšå½¹ç«‹ã¡ã¾ã™; ã¨ã¯ã„ãˆã€Python ã‚’åŸ‹ã‚è¾¼ã‚“ã§ã„ã‚‹ã»ã¨ã‚“ã©ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€åŒæ™‚ã«è‡ªä½œã®æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚‚æä¾›ã™ã‚‹å¿…è¦ãŒç”Ÿã˜ã‚‹ã“ã¨ã«ãªã‚‹ã§ã—ã‚‡ã†ã‹ã‚‰ã€Python ã‚’å®Ÿéš›ã«ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«åŸ‹ã‚è¾¼ã‚“ã§ã¿ã‚‹å‰ã«æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æ›¸ãæ–¹ã«è©³ã—ããªã£ã¦ãŠãã®ã¯ã‚ˆã„è€ƒãˆã ã¨æ€ã„ã¾ã™ã€‚"

#: ../../c-api/intro.rst:36
msgid "Include Files"
msgstr "ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«"

#: ../../c-api/intro.rst:38
msgid ""
"All function, type and macro definitions needed to use the Python/C API are "
"included in your code by the following line::"
msgstr "Python/C API ã‚’ä½¿ã†ãŸã‚ã«å¿…è¦ãªã€é–¢æ•°ã€å‹ãŠã‚ˆã³ãƒã‚¯ãƒ­ã®å…¨ã¦ã®å®šç¾©ã‚’ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ã™ã‚‹ã«ã¯ã€ä»¥ä¸‹ã®è¡Œ::"

#: ../../c-api/intro.rst:43
msgid ""
"This implies inclusion of the following standard headers: ``<stdio.h>``, "
"``<string.h>``, ``<errno.h>``, ``<limits.h>``, ``<assert.h>`` and "
"``<stdlib.h>`` (if available)."
msgstr "ã‚’ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã«è¨˜è¿°ã—ã¾ã™ã€‚ã“ã®è¡Œã‚’è¨˜è¿°ã™ã‚‹ã¨ã€æ¨™æº–ãƒ˜ãƒƒãƒ€: ``<stdio.h>``, ``<string.h>``, ``<errno.h>``, ``<limits.h>``, ``<assert.h>``, ``<stdlib.h>`` ã‚’ (åˆ©ç”¨ã§ãã‚Œã°) ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ã—ã¾ã™ã€‚"

#: ../../c-api/intro.rst:49
msgid ""
"Since Python may define some pre-processor definitions which affect the "
"standard headers on some systems, you *must* include :file:`Python.h` before"
" any standard headers are included."
msgstr "ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã£ã¦ã¯ã€Python ã®å®šç¾©ã—ã¦ã„ã‚‹ãƒ—ãƒªãƒ—ãƒ­ã‚»ãƒƒã‚µå®šç¾©ãŒæ¨™æº–ãƒ˜ãƒƒãƒ€ã«å½±éŸ¿ã‚’ãŠã‚ˆã¼ã™å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§ã€ :file:`Python.h` ã¯ *å¿…ãš* ä»–ã®æ¨™æº–ãƒ˜ãƒƒãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã‚ˆã‚Šã‚‚å‰ã«ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚"

#: ../../c-api/intro.rst:53
msgid ""
"All user visible names defined by Python.h (except those defined by the "
"included standard headers) have one of the prefixes ``Py`` or ``_Py``.  "
"Names beginning with ``_Py`` are for internal use by the Python "
"implementation and should not be used by extension writers. Structure member"
" names do not have a reserved prefix."
msgstr "Python.h ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€ãƒ¦ãƒ¼ã‚¶ã‹ã‚‰è¦‹ãˆã‚‹åå‰å…¨ã¦ (Python.h ãŒã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ã—ã¦ã„ã‚‹æ¨™æº–ãƒ˜ãƒƒãƒ€ã®åå‰ã¯é™¤ãã¾ã™) ã«ã¯ã€æ¥é ­æ–‡å­—åˆ— ``Py`` ã¾ãŸã¯ ``_Py`` ãŒä»˜ãã¾ã™ã€‚``_Py`` ã§å§‹ã¾ã‚‹åå‰ã¯ Python å®Ÿè£…ã§å†…éƒ¨ä½¿ç”¨ã™ã‚‹ãŸã‚ã®åå‰ã§ã€æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä½œè€…ã¯ä½¿ã£ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚æ§‹é€ ä½“ã®ãƒ¡ãƒ³ãƒã«ã¯äºˆç´„æ¸ˆã¿ã®æ¥é ­æ–‡å­—åˆ—ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/intro.rst:58
msgid ""
"**Important:** user code should never define names that begin with ``Py`` or"
" ``_Py``.  This confuses the reader, and jeopardizes the portability of the "
"user code to future Python versions, which may define additional names "
"beginning with one of these prefixes."
msgstr "**é‡è¦:** API ã®ãƒ¦ãƒ¼ã‚¶ã¯ã€``Py`` ã‚„ ``_Py`` ã§å§‹ã¾ã‚‹åå‰ã‚’å®šç¾©ã™ã‚‹ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚’çµ¶å¯¾ã«æ›¸ã„ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚å¾Œã‹ã‚‰ã‚³ãƒ¼ãƒ‰ã‚’èª­ã‚€äººã‚’æ··ä¹±ã•ã›ãŸã‚Šã€å°†æ¥ã® Python ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§åŒã˜åå‰ãŒå®šç¾©ã•ã‚Œã¦ã€ãƒ¦ãƒ¼ã‚¶ã®æ›¸ã„ãŸã‚³ãƒ¼ãƒ‰ã®å¯æ¬æ€§ã‚’å±ã†ãã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../c-api/intro.rst:63
msgid ""
"The header files are typically installed with Python.  On Unix, these  are "
"located in the directories :file:`{prefix}/include/pythonversion/` and "
":file:`{exec_prefix}/include/pythonversion/`, where :envvar:`prefix` and "
":envvar:`exec_prefix` are defined by the corresponding parameters to "
"Python's :program:`configure` script and *version* is ``sys.version[:3]``.  "
"On Windows, the headers are installed in :file:`{prefix}/include`, where "
":envvar:`prefix` is the installation directory specified to the installer."
msgstr "ãƒ˜ãƒƒãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ç¾¤ã¯é€šå¸¸ Python ã¨å…±ã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¾ã™ã€‚ Unixã§ã¯ :file:`{prefix}/include/pythonversion/` ãŠã‚ˆã³ :file:`{exec_prefix}/include/pythonversion/` ã«ç½®ã‹ã‚Œã¾ã™ã€‚ :envvar:`prefix` ã¨ :envvar:`exec_prefix` ã¯ Python ã‚’ãƒ“ãƒ«ãƒ‰ã™ã‚‹éš›ã® :program:`configure` ã‚¹ã‚¯ãƒªãƒ—ãƒˆã«ä¸ãˆãŸãƒ‘ãƒ©ãƒ¡ã‚¿ã«å¯¾å¿œã—ã€ *version* ã¯ ``sys.version[:3]`` ã«å¯¾å¿œã—ã¾ã™ã€‚ Windows ã§ã¯ã€ãƒ˜ãƒƒãƒ€ã¯ :file:`{prefix}/include` ã«ç½®ã‹ã‚Œã¾ã™ã€‚ :envvar:`prefix` ã¯ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ©ã«æŒ‡å®šã—ãŸã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ã™ã€‚"

#: ../../c-api/intro.rst:71
msgid ""
"To include the headers, place both directories (if different) on your "
"compiler's search path for includes.  Do *not* place the parent directories "
"on the search path and then use ``#include <pythonX.Y/Python.h>``; this will"
" break on multi-platform builds since the platform independent headers under"
" :envvar:`prefix` include the platform specific headers from "
":envvar:`exec_prefix`."
msgstr "ãƒ˜ãƒƒãƒ€ã‚’ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ã™ã‚‹ã«ã¯ã€å„ãƒ˜ãƒƒãƒ€ã®å…¥ã£ãŸãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª (åˆ¥ã€…ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å ´åˆã¯ä¸¡æ–¹) ã‚’ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œç´¢ã™ã‚‹ãŸã‚ã®ãƒ‘ã‚¹ã«å…¥ã‚Œã¾ã™ã€‚è¦ªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ã‚µãƒ¼ãƒãƒ‘ã‚¹ã«å…¥ã‚Œã¦ã€ ``#include <pythonX.Y/Python.h>`` ã®ã‚ˆã†ã«ã—ã¦ã¯ *ãªã‚Šã¾ã›ã‚“* ; :envvar:`prefix` å†…ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«ä¾å­˜ã—ãªã„ãƒ˜ãƒƒãƒ€ã¯ã€ :envvar:`exec_prefix` ã‹ã‚‰ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ä¾å­˜ã®ãƒ˜ãƒƒãƒ€ã‚’ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ã—ã¦ã„ã‚‹ã®ã§ã€ã“ã®ã‚ˆã†ãªæ“ä½œã‚’è¡Œã†ã¨è¤‡æ•°ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã®ãƒ“ãƒ«ãƒ‰ãŒã§ããªããªã‚Šã¾ã™ã€‚"

#: ../../c-api/intro.rst:78
msgid ""
"C++ users should note that though the API is defined entirely using C, the "
"header files do properly declare the entry points to be ``extern \"C\"``, so"
" there is no need to do anything special to use the API from C++."
msgstr "API ã¯ã™ã¹ã¦ C è¨€èªã‚’ä½¿ã£ã¦å®šç¾©ã—ã¦ã„ã¾ã™ãŒã€ãƒ˜ãƒƒãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆã‚’ ``extern \"C\"`` ã§é©åˆ‡ã«å®£è¨€ã—ã¦ã„ã‚‹ã®ã§ã€C++ ãƒ¦ãƒ¼ã‚¶ã¯ã€ãªã‚“ã®å•é¡Œã‚‚ãªã C++ã‹ã‚‰ API ã‚’åˆ©ç”¨ã§ãã‚‹ã“ã¨ã«æ°—ã¥ãã¯ãšã§ã™ã€‚"

#: ../../c-api/intro.rst:86
msgid "Objects, Types and Reference Counts"
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€å‹ãŠã‚ˆã³å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ"

#: ../../c-api/intro.rst:90
msgid ""
"Most Python/C API functions have one or more arguments as well as a return "
"value of type :c:type:`PyObject\\*`.  This type is a pointer to an opaque "
"data type representing an arbitrary Python object.  Since all Python object "
"types are treated the same way by the Python language in most situations "
"(e.g., assignments, scope rules, and argument passing), it is only fitting "
"that they should be represented by a single C type.  Almost all Python "
"objects live on the heap: you never declare an automatic or static variable "
"of type :c:type:`PyObject`, only pointer variables of type "
":c:type:`PyObject\\*` can  be declared.  The sole exception are the type "
"objects; since these must never be deallocated, they are typically static "
":c:type:`PyTypeObject` objects."
msgstr "Python/C API é–¢æ•°ã¯ã€ :c:type:`PyObject\\*` å‹ã®ä¸€ã¤ä»¥ä¸Šã®å¼•æ•°ã¨æˆ»ã‚Šå€¤ã‚’æŒã¡ã¾ã™ã€‚ã“ã®å‹ã¯ã€ä»»æ„ã® Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¡¨ç¾ã™ã‚‹ä¸é€æ˜ (opaque) ãªãƒ‡ãƒ¼ã‚¿å‹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã§ã™ã€‚ Python è¨€èªã¯ã€å…¨ã¦ã® Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã‚’ã»ã¨ã‚“ã©ã®çŠ¶æ³ (ä¾‹ãˆã°ä»£å…¥ã€ã‚¹ã‚³ãƒ¼ãƒ—è¦å‰‡ (scope rule)ã€å¼•æ•°æ¸¡ã—) ã§åŒæ§˜ã«æ‰±ã„ã¾ã™ã€‚ã»ã¨ã‚“ã©å…¨ã¦ã® Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ’ãƒ¼ãƒ— (heap) ä¸Šã«ç½®ã‹ã‚Œã¾ã™: ã“ã®ãŸã‚ã€ :c:type:`PyObject` å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€è‡ªå‹•è¨˜æ†¶ (automatic) ã¨ã—ã¦ã‚‚é™çš„è¨˜æ†¶ (static) ã¨ã—ã¦ã‚‚å®£è¨€ã§ãã¾ã›ã‚“ã€‚ :c:type:`PyObject\\*` å‹ã®ãƒã‚¤ãƒ³ã‚¿å¤‰æ•°ã®ã¿å®£è¨€ã§ãã¾ã™ã€‚å”¯ä¸€ã®ä¾‹å¤–ã¯ã€å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™; å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ¡ãƒ¢ãƒªè§£æ”¾ (deallocate) ã—ã¦ã¯ãªã‚‰ãªã„ã®ã§ã€é€šå¸¸ã¯é™çš„è¨˜æ†¶ã® :c:type:`PyTypeObject` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã—ã¾ã™ã€‚"

#: ../../c-api/intro.rst:101
msgid ""
"All Python objects (even Python integers) have a :dfn:`type` and a "
":dfn:`reference count`.  An object's type determines what kind of object it "
"is (e.g., an integer, a list, or a user-defined function; there are many "
"more as explained in :ref:`types`).  For each of the well-known types there "
"is a macro to check whether an object is of that type; for instance, "
"``PyList_Check(a)`` is true if (and only if) the object pointed to by *a* is"
" a Python list."
msgstr "å…¨ã¦ã® Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ (Python æ•´æ•°å‹ã§ã™ã‚‰) å‹ (:dfn:`type`)  ã¨å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ (:dfn:`reference count`) ãŒã‚ã‚Šã¾ã™ã€‚ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã¯ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã©ã®ç¨®é¡ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ (ä¾‹ãˆã°æ•´æ•°ã€ãƒªã‚¹ãƒˆã€ãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•°ã€ãªã©; ãã®ä»–å¤šæ•°ã«ã¤ã„ã¦ã¯ :ref:`types` ã§èª¬æ˜ã—ã¦ã„ã¾ã™) ã‚’æ±ºå®šã—ã¾ã™ã€‚ã‚ˆãçŸ¥ã‚‰ã‚Œã¦ã„ã‚‹å‹ã«ã¤ã„ã¦ã¯ã€å„ã€…ãƒã‚¯ãƒ­ãŒå­˜åœ¨ã—ã¦ã€ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãã®å‹ã‹ã©ã†ã‹èª¿ã¹ã‚‰ã‚Œã¾ã™; ä¾‹ãˆã°ã€ ``PyList_Check(a)`` ã¯ã€ *a* ã§ç¤ºã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ Python ãƒªã‚¹ãƒˆå‹ã®ã¨ã (ã‹ã¤ãã®ã¨ãã«é™ã‚Š) çœŸå€¤ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/intro.rst:112
msgid "Reference Counts"
msgstr "å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ"

#: ../../c-api/intro.rst:114
msgid ""
"The reference count is important because today's computers have a  finite "
"(and often severely limited) memory size; it counts how many  different "
"places there are that have a reference to an object.  Such a  place could be"
" another object, or a global (or static) C variable, or  a local variable in"
" some C function. When an object's reference count  becomes zero, the object"
" is deallocated.  If it contains references to  other objects, their "
"reference count is decremented. Those other  objects may be deallocated in "
"turn, if this decrement makes their reference count become zero, and so on."
"  (There's an obvious problem  with objects that reference each other here; "
"for now, the solution is  \"don't do that.\")"
msgstr "ä»Šæ—¥ã®è¨ˆç®—æ©Ÿã¯æœ‰é™ã® (ã—ã°ã—ã°éå¸¸ã«é™ã‚‰ã‚ŒãŸ) ãƒ¡ãƒ¢ãƒªã‚µã‚¤ã‚ºã—ã‹æŒãŸãªã„ã®ã§ã€å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã¯é‡è¦ãªæ¦‚å¿µã§ã™; å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã¯ã€ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦å‚ç…§ã‚’è¡Œã£ã¦ã„ã‚‹å ´æ‰€ãŒä½•ç®‡æ‰€ã‚ã‚‹ã‹ã‚’æ•°ãˆã‚‹å€¤ã§ã™ã€‚å‚ç…§ã‚’è¡Œã£ã¦ã„ã‚‹å ´æ‰€ã¨ã¯ã€åˆ¥ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã£ãŸã‚Šã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ãª (ã‚ã‚‹ã„ã¯é™çš„ãª) C å¤‰æ•°ã§ã‚ã£ãŸã‚Šã€ä½•ã‚‰ã‹ã® C é–¢æ•°å†…ã«ã‚ã‚‹ãƒ­ãƒ¼ã‚«ãƒ«ãªå¤‰æ•°ã ã£ãŸã‚Šã—ã¾ã™ã€‚ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒã‚¼ãƒ­ã«ãªã‚‹ã¨ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯è§£æ”¾ã•ã‚Œã¾ã™ã€‚ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ãŒå…¥ã£ã¦ã„ã‚Œã°ã€ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã¯ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã•ã‚Œã¾ã™ã€‚ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã®çµæœã€ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒã‚¼ãƒ­ã«ãªã‚‹ã¨ã€ä»Šåº¦ã¯ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè§£æ”¾ã•ã‚Œã‚‹ã€ã¨ã„ã£ãŸå…·åˆã«ä»¥å¾Œç¶šãã¾ã™ã€‚(è¨€ã†ã¾ã§ã‚‚ãªãã€äº’ã„ã‚’å‚ç…§ã—ã‚ã†ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦å•é¡ŒãŒã‚ã‚Šã¾ã™; ç¾çŠ¶ã§ã¯ã€è§£æ±ºç­–ã¯ \"ä½•ã‚‚ã—ãªã„\" ã§ã™ã€‚)"

#: ../../c-api/intro.rst:129
msgid ""
"Reference counts are always manipulated explicitly.  The normal way is  to "
"use the macro :c:func:`Py_INCREF` to increment an object's reference count "
"by one, and :c:func:`Py_DECREF` to decrement it by   one.  The "
":c:func:`Py_DECREF` macro is considerably more complex than the incref one, "
"since it must check whether the reference count becomes zero and then cause "
"the object's deallocator to be called. The deallocator is a function pointer"
" contained in the object's type structure.  The type-specific deallocator "
"takes care of decrementing the reference counts for other objects contained "
"in the object if this is a compound object type, such as a list, as well as "
"performing any additional finalization that's needed.  There's no chance "
"that the reference count can overflow; at least as many bits are used to "
"hold the reference count as there are distinct memory locations in virtual "
"memory (assuming ``sizeof(Py_ssize_t) >= sizeof(void*)``). Thus, the "
"reference count increment is a simple operation."
msgstr "å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã¯ã€å¸¸ã«æ˜ç¤ºçš„ãªã‚„ã‚Šæ–¹ã§æ“ä½œã•ã‚Œã¾ã™ã€‚é€šå¸¸ã®æ–¹æ³•ã§ã¯ã€ :c:func:`Py_INCREF`  ã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‚ç…§ã‚’ 1 ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã€ :c:func:`Py_DECREF` ã§ 1 ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã¾ã™ã€‚ :c:func:`Py_DECREF` ãƒã‚¯ãƒ­ã¯ã€incref ã‚ˆã‚Šã‚‚ã‹ãªã‚Šè¤‡é›‘ã§ã™ã€‚ã¨ã„ã†ã®ã¯ã€ :c:func:`Py_DECREF` ãƒã‚¯ãƒ­ã¯å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒã‚¼ãƒ­ã«ãªã£ãŸã‹ã©ã†ã‹ã‚’èª¿ã¹ã¦ã€ãªã£ãŸå ´åˆã«ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ (deallocator) ã‚’å‘¼ã³å‡ºã•ãªã‘ã‚Œã°ãªã‚‰ãªã„ã‹ã‚‰ã§ã™ã€‚ãƒ‡ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã¨ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã‚’å®šç¾©ã—ã¦ã„ã‚‹æ§‹é€ ä½“å†…ã«ã‚ã‚‹é–¢æ•°ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã§ã™ã€‚å‹å›ºæœ‰ã®ãƒ‡ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã¯ã€ãã®å‹ãŒè¤‡åˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (compound object) å‹ã§ã‚ã‚‹å ´åˆã«ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå†…ã®ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã™ã‚‹ã‚ˆã†æ°—ã‚’é…ã‚‹ã¨ã¨ã‚‚ã«ã€ãã®ä»–ã®å¿…è¦ãªãƒ•ã‚¡ã‚¤ãƒŠãƒ©ã‚¤ã‚º (finalize) å‡¦ç†ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒã‚ªãƒ¼ãƒãƒ•ãƒ­ãƒ¼ã™ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“; ã¨ã„ã†ã®ã‚‚ã€ä»®æƒ³ãƒ¡ãƒ¢ãƒªç©ºé–“ã«ã¯ã€(``sizeof(Py_ssize_t) >= sizeof(void*)`` ã¨ä»®å®šã—ãŸå ´åˆ) å°‘ãªãã¨ã‚‚å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã®è¨˜æ†¶ã«ä½¿ã‚ã‚Œã‚‹ãƒ“ãƒƒãƒˆæ•°ã¨åŒã˜ã ã‘ã®ãƒ¡ãƒ¢ãƒªä¸Šã®ä½ç½®ãŒã‚ã‚‹ã‹ã‚‰ã§ã™ã€‚å¾“ã£ã¦ã€å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã®ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã¯å˜ç´”ãªæ“ä½œã«ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/intro.rst:143
msgid ""
"It is not necessary to increment an object's reference count for every  "
"local variable that contains a pointer to an object.  In theory, the  "
"object's reference count goes up by one when the variable is made to  point "
"to it and it goes down by one when the variable goes out of  scope.  "
"However, these two cancel each other out, so at the end the  reference count"
" hasn't changed.  The only real reason to use the  reference count is to "
"prevent the object from being deallocated as  long as our variable is "
"pointing to it.  If we know that there is at  least one other reference to "
"the object that lives at least as long as our variable, there is no need to "
"increment the reference count  temporarily. An important situation where "
"this arises is in objects  that are passed as arguments to C functions in an"
" extension module  that are called from Python; the call mechanism "
"guarantees to hold a  reference to every argument for the duration of the "
"call."
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ãŒå…¥ã£ã¦ã„ã‚‹ãƒ­ãƒ¼ã‚«ãƒ«ãªå¤‰æ•°å…¨ã¦ã«ã¤ã„ã¦ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’å¿…ãšã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ç†è«–ä¸Šã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡ã—ç¤ºã™å¤‰æ•°ãŒç”Ÿæˆã•ã‚ŒãŸã¨ãã« 1 å¢—ã‚„ã•ã‚Œã€ãã®å¤‰æ•°ãŒã‚¹ã‚³ãƒ¼ãƒ—ã‹ã‚‰å‡ºã¦è¡Œã£ãŸéš›ã« 1 æ¸›ã‚‰ã•ã‚Œã¾ã™ã€‚ã—ã‹ã—ã“ã®å ´åˆã€äºŒã¤ã®æ“ä½œã¯äº’ã„ã«ç›¸æ®ºã™ã‚‹ã®ã§ã€çµæœçš„ã«å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã¯å¤‰åŒ–ã—ã¾ã›ã‚“ã€‚å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½¿ã†çœŸã®æ„ç¾©ã¨ã¯ã€æ‰‹æŒã¡ã®ä½•ã‚‰ã‹ã®å¤‰æ•°ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡ã—ã¦ã„ã‚‹é–“ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãƒ‡ã‚¢ãƒ­ã‚±ãƒ¼ãƒˆã•ã‚Œãªã„ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã«ã‚ã‚Šã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ã€ä¸€ã¤ã§ã‚‚åˆ¥ã®å‚ç…§ãŒè¡Œã‚ã‚Œã¦ã„ã¦ã€ãã®å‚ç…§ãŒæ‰‹æŒã¡ã®å¤‰æ•°ã¨åŒã˜é–“ç¶­æŒã•ã‚Œã‚‹ã®ãªã‚‰ã€å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’ä¸€æ™‚çš„ã«å¢—ã‚„ã™å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆæ“ä½œã®å¿…è¦æ€§ãŒæµ®ãå½«ã‚Šã«ãªã‚‹é‡è¦ãªå±€é¢ã¨ã¯ã€Python ã‹ã‚‰å‘¼ã³å‡ºã•ã‚ŒãŸæ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã® C é–¢æ•°ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¼•æ•°ã¨ã—ã¦æ¸¡ã™ã¨ãã§ã™; å‘¼ã³å‡ºã—ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã¯ã€å‘¼ã³å‡ºã—ã®é–“å…¨ã¦ã®å¼•æ•°ã«å¯¾ã™ã‚‹å‚ç…§ã‚’ä¿è¨¼ã—ã¾ã™ã€‚"

#: ../../c-api/intro.rst:157
msgid ""
"However, a common pitfall is to extract an object from a list and hold on to"
" it for a while without incrementing its reference count. Some other "
"operation might conceivably remove the object from the list, decrementing "
"its reference count and possible deallocating it. The real danger is that "
"innocent-looking operations may invoke arbitrary Python code which could do "
"this; there is a code path which allows control to flow back to the user "
"from a :c:func:`Py_DECREF`, so almost any operation is potentially "
"dangerous."
msgstr "ã—ã‹ã—ãªãŒã‚‰ã€ã‚ˆãé™¥ã‚‹éã¡ã¨ã—ã¦ã€ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒªã‚¹ãƒˆã‹ã‚‰å¾—ãŸã¨ãã«ã€å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã›ãšã«ã—ã°ã‚‰ãæ”¾ã£ã¦ãŠãã¨ã„ã†ã®ãŒã‚ã‚Šã¾ã™ã€‚ä»–ã®æ“ä½œãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒªã‚¹ãƒˆã‹ã‚‰é™¤å»ã—ã¦ã—ã¾ã„ã€å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã•ã‚Œã¦ãƒ‡ã‚¢ãƒ­ã‚±ãƒ¼ãƒˆã•ã‚Œã¦ã—ã¾ã†ã“ã¨ãŒè€ƒãˆã‚‰ã‚Œã¾ã™ã€‚æœ¬å½“ã«å±é™ºãªã®ã¯ã€ã¾ã£ãŸãç„¡å®³ãã†ã«ã¿ãˆã‚‹æ“ä½œãŒã€ä¸Šè¨˜ã®å‹•ä½œã‚’å¼•ãèµ·ã“ã™ä½•ã‚‰ã‹ã® Python ã‚³ãƒ¼ãƒ‰ã‚’å‘¼ã³å‡ºã—ã‹ã­ãªã„ã¨ã„ã†ã“ã¨ã§ã™; :c:func:`Py_DECREF` ã‹ã‚‰ãƒ¦ãƒ¼ã‚¶ã¸åˆ¶å¾¡ã‚’æˆ»ã›ã‚‹ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ãƒ‘ã‚¹ãŒå­˜åœ¨ã™ã‚‹ãŸã‚ã€ã»ã¨ã‚“ã©å…¨ã¦ã®æ“ä½œãŒæ½œåœ¨çš„ã«å±é™ºã‚’ã¯ã‚‰ã‚€ã“ã¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/intro.rst:165
msgid ""
"A safe approach is to always use the generic operations (functions  whose "
"name begins with ``PyObject_``, ``PyNumber_``, ``PySequence_`` or "
"``PyMapping_``). These operations always increment the reference count of "
"the object they return. This leaves the caller with the responsibility to "
"call :c:func:`Py_DECREF` when they are done with the result; this soon "
"becomes second nature."
msgstr "å®‰å…¨ã«å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’æ“ä½œã™ã‚‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯ã€æ±ç”¨ã®æ“ä½œ (é–¢æ•°åãŒ  ``PyObject_``, ``PyNumber_``, ``PySequence_``, ãŠã‚ˆã³  ``PyMapping_`` ã§å§‹ã¾ã‚‹é–¢æ•°) ã®åˆ©ç”¨ã§ã™ã€‚ã“ã‚Œã‚‰ã®æ“ä½œã¯å¸¸ã«æˆ»ã‚Šå€¤ã¨ãªã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã¾ã™ã€‚ãƒ¦ãƒ¼ã‚¶ã«ã¯æˆ»ã‚Šå€¤ãŒä¸è¦ã«ãªã£ãŸã‚‰ :c:func:`Py_DECREF` ã‚’å‘¼ã¶è²¬ä»»ãŒæ®‹ã•ã‚Œã¦ã„ã¾ã™; ã¨ã¯ã„ãˆã€ã™ãã«ãã®ç¿’æ…£ã¯èº«ã«ä»˜ãã§ã—ã‚‡ã†ã€‚"

#: ../../c-api/intro.rst:175
msgid "Reference Count Details"
msgstr "å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã®è©³ç´°"

#: ../../c-api/intro.rst:177
msgid ""
"The reference count behavior of functions in the Python/C API is best  "
"explained in terms of *ownership of references*.  Ownership pertains to "
"references, never to objects (objects are not owned: they are always "
"shared).  \"Owning a reference\" means being responsible for calling "
"Py_DECREF on it when the reference is no longer needed.  Ownership can also "
"be transferred, meaning that the code that receives ownership of the "
"reference then becomes responsible for eventually decref'ing it by calling "
":c:func:`Py_DECREF` or :c:func:`Py_XDECREF` when it's no longer needed---or "
"passing on this responsibility (usually to its caller). When a function "
"passes ownership of a reference on to its caller, the caller is said to "
"receive a *new* reference.  When no ownership is transferred, the caller is "
"said to *borrow* the reference. Nothing needs to be done for a borrowed "
"reference."
msgstr "Python/C API ã®å„é–¢æ•°ã«ãŠã‘ã‚‹å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã®æŒ¯ã‚‹èˆã„ã¯ã€èª¬æ˜ã™ã‚‹ã«ã¯ã€ *å‚ç…§ã®æ‰€æœ‰æ¨© (ownership of references)* ã¨ã„ã†è¨€è‘‰ã§ã†ã¾ãèª¬æ˜ã§ãã¾ã™ã€‚æ‰€æœ‰æ¨©ã¯å‚ç…§ã«å¯¾ã™ã‚‹ã‚‚ã®ã§ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ (ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯èª°ã«ã‚‚æ‰€æœ‰ã•ã‚Œãšã€å¸¸ã«å…±æœ‰ã•ã‚Œã¦ã„ã¾ã™)ã€‚ã‚ã‚‹å‚ç…§ã® \"æ‰€æœ‰\" ã¯ã€ãã®å‚ç…§ãŒå¿…è¦ãªããªã£ãŸæ™‚ç‚¹ã§ :c:func:`Py_DECREF` ã‚’å‘¼ã³å‡ºã™å½¹å‰²ã‚’æ‹…ã†ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚æ‰€æœ‰æ¨©ã¯å§”è­²ã§ãã€ã‚ã‚‹ã‚³ãƒ¼ãƒ‰ãŒå§”è­²ã«ã‚ˆã£ã¦æ‰€æœ‰æ¨©ã‚’å¾—ã‚‹ã¨ã€ä»Šåº¦ã¯ãã®ã‚³ãƒ¼ãƒ‰ãŒå‚ç…§ãŒå¿…è¦ãªããªã£ãŸéš›ã«æœ€çµ‚çš„ã« :c:func:`Py_DECREF` ã‚„ :c:func:`Py_XDECREF` ã‚’å‘¼ã³å‡ºã—ã¦ decref ã™ã‚‹å½¹å‰²ã‚’æ‹…ã„ã¾ã™ --- ã‚ã‚‹ã„ã¯ã€ãã®å½¹å‰²ã‚’ (é€šå¸¸ã¯ã‚³ãƒ¼ãƒ‰ã‚’å‘¼ã³å‡ºã—ãŸå…ƒã«) å—ã‘æ¸¡ã—ã¾ã™ã€‚ã‚ã‚‹é–¢æ•°ãŒã€é–¢æ•°ã®å‘¼ã³å‡ºã—å´ã«å¯¾ã—ã¦å‚ç…§ã®æ‰€æœ‰æ¨©ã‚’æ¸¡ã™ã¨ã€å‘¼ã³å‡ºã—å´ã¯ *æ–°ãŸãª* å‚ç…§ (new reference) ã‚’å¾—ã‚‹ã€ã¨è¨€ã„ã¾ã™ã€‚æ‰€æœ‰æ¨©ãŒæ¸¡ã•ã‚Œãªã„å ´åˆã€å‘¼ã³å‡ºã—å´ã¯å‚ç…§ã‚’ *å€Ÿã‚Šã‚‹* (borrow) ã¨ã„ã„ã¾ã™ã€‚å€Ÿã‚ŠãŸå‚ç…§ã«å¯¾ã—ã¦ã¯ã€ä½•ã‚‚ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/intro.rst:190
msgid ""
"Conversely, when a calling function passes in a reference to an  object, "
"there are two possibilities: the function *steals* a  reference to the "
"object, or it does not.  *Stealing a reference* means that when you pass a "
"reference to a function, that function assumes that it now owns that "
"reference, and you are not responsible for it any longer."
msgstr "é€†ã«ã€ã‚ã‚‹é–¢æ•°å‘¼ã³å‡ºã—ã§ã€ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’å‘¼ã³å‡ºã•ã‚Œã‚‹é–¢æ•°ã«æ¸¡ã™éš›ã«ã¯ã€äºŒã¤ã®å¯èƒ½æ€§: é–¢æ•°ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’ *ç›—ã¿å–ã‚‹* (steal) å ´åˆã¨ã€ãã†ã§ãªã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚*å‚ç…§ã‚’ç›—ã‚€* ã¨ã¯ã€é–¢æ•°ã«å‚ç…§ã‚’æ¸¡ã—ãŸã¨ãã«ã€å‚ç…§ã®æ‰€æœ‰è€…ãŒãã®é–¢æ•°ã«ãªã£ãŸã¨ä»®å®šã—ã€é–¢æ•°ã®å‘¼ã³å‡ºã—å…ƒã«ã¯æ‰€æœ‰æ¨©ãŒãªããªã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚"

#: ../../c-api/intro.rst:200
msgid ""
"Few functions steal references; the two notable exceptions are "
":c:func:`PyList_SetItem` and :c:func:`PyTuple_SetItem`, which  steal a "
"reference to the item (but not to the tuple or list into which the item is "
"put!).  These functions were designed to steal a reference because of a "
"common idiom for populating a tuple or list with newly created objects; for "
"example, the code to create the tuple ``(1, 2, \"three\")`` could look like "
"this (forgetting about error handling for the moment; a better way to code "
"this is shown below)::"
msgstr "å‚ç…§ã‚’ç›—ã¿å–ã‚‹é–¢æ•°ã¯ã»ã¨ã‚“ã©ã‚ã‚Šã¾ã›ã‚“; ä¾‹å¤–ã¨ã—ã¦ã‚ˆãçŸ¥ã‚‰ã‚Œã¦ã„ã‚‹ã®ã¯ã€ :c:func:`PyList_SetItem` ã¨ :c:func:`PyTuple_SetItem` ã§ã€ã“ã‚Œã‚‰ã¯ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«å…¥ã‚Œã‚‹è¦ç´ ã«å¯¾ã™ã‚‹å‚ç…§ã‚’ç›—ã¿å–ã‚Šã¾ã™ (ã—ã‹ã—ã€è¦ç´ ã®å…¥ã‚‹å…ˆã®ã‚¿ãƒ—ãƒ«ã‚„ãƒªã‚¹ãƒˆã®å‚ç…§ã¯ç›—ã¿å–ã‚Šã¾ã›ã‚“!)ã€‚ã“ã‚Œã‚‰ã®é–¢æ•°ã¯ã€ãƒªã‚¹ãƒˆã‚„ã‚¿ãƒ—ãƒ«ã®ä¸­ã«æ–°ãŸã«ä½œæˆã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å…¥ã‚Œã¦ã„ãéš›ã®å¸¸å¥—çš„ãªæ›¸ãæ–¹ã‚’ã—ã‚„ã™ãã™ã‚‹ãŸã‚ã«ã€å‚ç…§ã‚’ç›—ã¿å–ã‚‹ã‚ˆã†ã«è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™; ä¾‹ãˆã°ã€ ``(1, 2, \"three\")`` ã¨ã„ã†ã‚¿ãƒ—ãƒ«ã‚’ç”Ÿæˆã™ã‚‹ã‚³ãƒ¼ãƒ‰ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ (ã¨ã‚Šã‚ãˆãšä¾‹å¤–å‡¦ç†ã®ã“ã¨ã¯å¿˜ã‚Œã¦ãŠãã¾ã™; ã‚‚ã£ã¨ã‚ˆã„æ›¸ãæ–¹ã‚’å¾Œã§ç¤ºã—ã¾ã™)::"

#: ../../c-api/intro.rst:215
msgid ""
"Here, :c:func:`PyInt_FromLong` returns a new reference which is immediately "
"stolen by :c:func:`PyTuple_SetItem`.  When you want to keep using an object "
"although the reference to it will be stolen, use :c:func:`Py_INCREF` to grab"
" another reference before calling the reference-stealing function."
msgstr "ã“ã“ã§ã€ :c:func:`PyInt_FromLong` ã¯æ–°ã—ã„å‚ç…§ã‚’è¿”ã—ã€ã™ãã« :c:func:`PyTuple_SetItem` ã«ç›—ã¾ã‚Œã¾ã™ã€‚å‚ç…§ãŒç›—ã¾ã‚ŒãŸå¾Œã‚‚ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’åˆ©ç”¨ã—ãŸã„å ´åˆã¯ã€å‚ç…§ç›—ã‚€é–¢æ•°ã‚’å‘¼ã³å‡ºã™å‰ã«ã€ :c:func:`Py_INCREF` ã‚’åˆ©ç”¨ã—ã¦ã‚‚ã†ä¸€ã¤ã®å‚ç…§ã‚’å–å¾—ã—ã¦ãã ã•ã„ã€‚"

#: ../../c-api/intro.rst:220
msgid ""
"Incidentally, :c:func:`PyTuple_SetItem` is the *only* way to set tuple "
"items; :c:func:`PySequence_SetItem` and :c:func:`PyObject_SetItem` refuse to"
" do this since tuples are an immutable data type.  You should only use "
":c:func:`PyTuple_SetItem` for tuples that you are creating yourself."
msgstr "ã¡ãªã¿ã«ã€ :c:func:`PyTuple_SetItem` ã¯ã‚¿ãƒ—ãƒ«ã«å€¤ã‚’ã‚»ãƒƒãƒˆã™ã‚‹ãŸã‚ã® *å”¯ä¸€ã®* æ–¹æ³•ã§ã™; ã‚¿ãƒ—ãƒ«ã¯å¤‰æ›´ä¸èƒ½ãªãƒ‡ãƒ¼ã‚¿å‹ãªã®ã§ã€ :c:func:`PySequence_SetItem` ã‚„ :c:func:`PyObject_SetItem` ã‚’ä½¿ã†ã¨ä¸Šã®æ“ä½œã¯æ‹’å¦ã•ã‚Œã¦ã—ã¾ã„ã¾ã™ã€‚è‡ªåˆ†ã§ã‚¿ãƒ—ãƒ«ã®å€¤ã‚’å…¥ã‚Œã¦ã„ãã¤ã‚‚ã‚Šãªã‚‰ã€ :c:func:`PyTuple_SetItem` ã ã‘ã—ã‹ä½¿ãˆã¾ã›ã‚“ã€‚"

#: ../../c-api/intro.rst:225
msgid ""
"Equivalent code for populating a list can be written using "
":c:func:`PyList_New` and :c:func:`PyList_SetItem`."
msgstr "åŒã˜ãã€ãƒªã‚¹ãƒˆã«å€¤ã‚’å…¥ã‚Œã¦ã„ãã‚³ãƒ¼ãƒ‰ã¯ :c:func:`PyList_New` ã¨ :c:func:`PyList_SetItem` ã§æ›¸ã‘ã¾ã™ã€‚"

#: ../../c-api/intro.rst:228
msgid ""
"However, in practice, you will rarely use these ways of creating and "
"populating a tuple or list.  There's a generic function, "
":c:func:`Py_BuildValue`, that can create most common objects from C values, "
"directed by a :dfn:`format string`. For example, the above two blocks of "
"code could be replaced by the following (which also takes care of the error "
"checking)::"
msgstr "ã—ã‹ã—å®Ÿéš›ã«ã¯ã€ã‚¿ãƒ—ãƒ«ã‚„ãƒªã‚¹ãƒˆã‚’ç”Ÿæˆã—ã¦å€¤ã‚’å…¥ã‚Œã‚‹éš›ã«ã¯ã€ä¸Šè¨˜ã®ã‚ˆã†ãªæ–¹æ³•ã¯ã»ã¨ã‚“ã©ä½¿ã„ã¾ã›ã‚“ã€‚ã‚ˆã‚Šæ±ç”¨æ€§ã®ã‚ã‚‹é–¢æ•°ã€ :c:func:`Py_BuildValue` ãŒã‚ã‚Šã€ã»ã¨ã‚“ã©ã®ä¸»è¦ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ–‡å­—åˆ— :dfn:`format string` ã®æŒ‡å®šã«åŸºã¥ã„ã¦ C ã®å€¤ã‹ã‚‰ç”Ÿæˆã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€ä¸Šã®äºŒç¨®é¡ã®ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ (ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯ã«ã‚‚é…æ…®ã—ã¦ã„ã¾ã™)::"

#: ../../c-api/intro.rst:239
msgid ""
"It is much more common to use :c:func:`PyObject_SetItem` and friends with "
"items whose references you are only borrowing, like arguments that were "
"passed in to the function you are writing.  In that case, their behaviour "
"regarding reference counts is much saner, since you don't have to increment "
"a reference count so you can give a reference away (\"have it be stolen\")."
"  For example, this function sets all items of a list (actually, any mutable"
" sequence) to a given item::"
msgstr "è‡ªä½œã®é–¢æ•°ã«æ¸¡ã™å¼•æ•°ã®ã‚ˆã†ã«ã€å˜ã«å‚ç…§ã‚’å€Ÿã‚Šã‚‹ã ã‘ã®è¦ç´ ã«å¯¾ã—ã¦ã¯ã€ :c:func:`PyObject_SetItem` ã¨ãã®ä»²é–“ã‚’ä½¿ã†ã®ãŒã¯ã‚‹ã‹ã«ä¸€èˆ¬çš„ã§ã™ã€‚ãã®å ´åˆã€å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã™ã‚‹å¿…è¦ãŒãªãã€å‚ç…§ã‚’å¼•ãæ¸¡ã›ã‚‹ (\"å‚ç…§ã‚’ç›—ã¿å–ã‚‰ã›ã‚‰ã‚Œã‚‹\") ã®ã§ã€å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã«é–¢ã™ã‚‹å‹•ä½œã¯ã‚ˆã‚Šå¥å…¨ã«ãªã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€ä»¥ä¸‹ã®é–¢æ•°ã¯ä¸ãˆã‚‰ã‚ŒãŸè¦ç´ ã‚’ãƒªã‚¹ãƒˆä¸­ã®å…¨ã¦ã®è¦ç´ ã®å€¤ã«ã‚»ãƒƒãƒˆã—ã¾ã™::"

#: ../../c-api/intro.rst:269
msgid ""
"The situation is slightly different for function return values.   While "
"passing a reference to most functions does not change your  ownership "
"responsibilities for that reference, many functions that  return a reference"
" to an object give you ownership of the reference. The reason is simple: in "
"many cases, the returned object is created  on the fly, and the reference "
"you get is the only reference to the  object.  Therefore, the generic "
"functions that return object references, like :c:func:`PyObject_GetItem` and"
"  :c:func:`PySequence_GetItem`, always return a new reference (the caller "
"becomes the owner of the reference)."
msgstr "é–¢æ•°ã®æˆ»ã‚Šå€¤ã®å ´åˆã«ã¯ã€çŠ¶æ³ã¯å°‘ã—ç•°ãªã‚Šã¾ã™ã€‚ã»ã¨ã‚“ã©ã®é–¢æ•°ã«ã¤ã„ã¦ã¯ã€å‚ç…§ã‚’æ¸¡ã—ã¦ã‚‚ãã®å‚ç…§ã«å¯¾ã™ã‚‹æ‰€æœ‰æ¨©ãŒå¤‰ã‚ã‚‹ã“ã¨ãŒãªã„ä¸€æ–¹ã§ã€ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹å‚ç…§ã‚’è¿”ã™ã‚ˆã†ãªå¤šãã®é–¢æ•°ã¯ã€å‚ç…§ã«å¯¾ã™ã‚‹æ‰€æœ‰æ¨©ã‚’å‘¼ã³å‡ºã—å´ã«ä¸ãˆã¾ã™ã€‚ç†ç”±ã¯ç°¡å˜ã§ã™: å¤šãã®å ´åˆã€é–¢æ•°ãŒè¿”ã™ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãã®å ´ã§ (on the fly) ç”Ÿæˆã•ã‚Œã‚‹ãŸã‚ã€å‘¼ã³å‡ºã—å´ãŒå¾—ã‚‹å‚ç…§ã¯ç”Ÿæˆã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹å”¯ä¸€ã®å‚ç…§ã«ãªã‚‹ã‹ã‚‰ã§ã™ã€‚å¾“ã£ã¦ã€ :c:func:`PyObject_GetItem` ã‚„ :c:func:`PySequence_GetItem` ã®ã‚ˆã†ã«ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹å‚ç…§ã‚’è¿”ã™æ±ç”¨ã®é–¢æ•°ã¯ã€å¸¸ã«æ–°ãŸãªå‚ç…§ã‚’è¿”ã—ã¾ã™ (å‘¼ã³å‡ºã—å´ãŒå‚ç…§ã®æ‰€æœ‰è€…ã«ãªã‚Šã¾ã™)ã€‚"

#: ../../c-api/intro.rst:278
msgid ""
"It is important to realize that whether you own a reference returned  by a "
"function depends on which function you call only --- *the plumage* (the type"
" of the object passed as an argument to the function) *doesn't enter into "
"it!* Thus, if you  extract an item from a list using "
":c:func:`PyList_GetItem`, you don't own the reference --- but if you obtain "
"the same item from the same list using :c:func:`PySequence_GetItem` (which "
"happens to take exactly the same arguments), you do own a reference to the "
"returned object."
msgstr "é‡è¦ãªã®ã¯ã€é–¢æ•°ãŒè¿”ã™å‚ç…§ã®æ‰€æœ‰æ¨©ã‚’æŒã¦ã‚‹ã‹ã©ã†ã‹ã¯ã€ã©ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã‹ã ã‘ã«ã‚ˆã‚‹ã€ã¨ç†è§£ã™ã‚‹ã“ã¨ã§ã™ --- é–¢æ•°å‘¼ã³å‡ºã—æ™‚ã® *ãŠé£¾ã‚Š* (é–¢æ•°ã«å¼•æ•°ã¨ã—ã¦æ¸¡ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹) ã¯ *ã“ã®å•é¡Œã«ã¯é–¢ä¿‚ã‚ã‚Šã¾ã›ã‚“!* å¾“ã£ã¦ã€ :c:func:`PyList_GetItem` ã‚’ä½¿ã£ã¦ãƒªã‚¹ãƒˆå†…ã®è¦ç´ ã‚’å¾—ãŸå ´åˆã«ã¯ã€å‚ç…§ã®æ‰€æœ‰è€…ã«ã¯ãªã‚Šã¾ã›ã‚“ --- ãŒã€åŒã˜è¦ç´ ã‚’åŒã˜ãƒªã‚¹ãƒˆã‹ã‚‰ :c:func:`PySequence_GetItem` (å›³ã‚‰ãšã‚‚ã“ã®é–¢æ•°ã¯å…¨ãåŒã˜å¼•æ•°ã‚’ã¨ã‚Šã¾ã™) ã‚’ä½¿ã£ã¦å–ã‚Šå‡ºã™ã¨ã€è¿”ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹å‚ç…§ã‚’å¾—ã¾ã™ã€‚"

#: ../../c-api/intro.rst:290
msgid ""
"Here is an example of how you could write a function that computes the sum "
"of the items in a list of integers; once using  :c:func:`PyList_GetItem`, "
"and once using :c:func:`PySequence_GetItem`. ::"
msgstr "ä»¥ä¸‹ã¯ã€æ•´æ•°ã‹ã‚‰ãªã‚‹ãƒªã‚¹ãƒˆã«å¯¾ã—ã¦å„è¦ç´ ã®åˆè¨ˆã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°ã‚’ã©ã®ã‚ˆã†ã«ã—ã¦æ›¸ã‘ã‚‹ã‹ã‚’ç¤ºã—ãŸä¾‹ã§ã™; ä¸€ã¤ã¯ :c:func:`PyList_GetItem` ã‚’ä½¿ã£ã¦ã„ã¦ã€ã‚‚ã†ä¸€ã¤ã¯ :c:func:`PySequence_GetItem` ã‚’ä½¿ã£ã¦ã„ã¾ã™ã€‚ ::"

#: ../../c-api/intro.rst:342
msgid "Types"
msgstr "å‹"

#: ../../c-api/intro.rst:344
msgid ""
"There are few other data types that play a significant role in  the Python/C"
" API; most are simple C types such as :c:type:`int`,  :c:type:`long`, "
":c:type:`double` and :c:type:`char\\*`.  A few structure types  are used to "
"describe static tables used to list the functions exported  by a module or "
"the data attributes of a new object type, and another is used to describe "
"the value of a complex number.  These will  be discussed together with the "
"functions that use them."
msgstr "Python/C API ã«ãŠã„ã¦é‡è¦ãªå½¹å‰²ã‚’æŒã¤ãƒ‡ãƒ¼ã‚¿å‹ã¯ã€ :c:type:`PyObject` å‹ã®ä»–ã«ã‚‚ã„ãã¤ã‹ã‚ã‚Šã¾ã™; ã»ã¨ã‚“ã©ã¯ :c:type:`int`, :c:type:`long`,  :c:type:`double`, ãŠã‚ˆã³ :c:type:`char\\*` ã¨ã„ã£ãŸã€å˜ãªã‚‹ C ã®ãƒ‡ãƒ¼ã‚¿å‹ã§ã™ã€‚ã¾ãŸã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å…¬é–‹ã—ã¦ã„ã‚‹é–¢æ•°ã‚’åˆ—æŒ™ã™ã‚‹éš›ã«ç”¨ã„ã‚‰ã‚Œã‚‹é™çš„ãªãƒ†ãƒ¼ãƒ–ãƒ«ã‚„ã€æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã«ãŠã‘ã‚‹ãƒ‡ãƒ¼ã‚¿å±æ€§ã‚’è¨˜è¿°ã—ãŸã‚Šã€è¤‡ç´ æ•°ã®å€¤ã‚’è¨˜è¿°ã—ãŸã‚Šã™ã‚‹ãŸã‚ã«æ§‹é€ ä½“ã‚’ã„ãã¤ã‹ä½¿ã£ã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®å‹ã«ã¤ã„ã¦ã¯ã€ãã®å‹ã‚’ä½¿ã†é–¢æ•°ã¨ã¨ã‚‚ã«èª¬æ˜ã—ã¦ã‚†ãã¾ã™ã€‚"

#: ../../c-api/intro.rst:356
msgid "Exceptions"
msgstr "ä¾‹å¤–"

#: ../../c-api/intro.rst:358
msgid ""
"The Python programmer only needs to deal with exceptions if specific  error "
"handling is required; unhandled exceptions are automatically  propagated to "
"the caller, then to the caller's caller, and so on, until they reach the "
"top-level interpreter, where they are reported to the  user accompanied by a"
" stack traceback."
msgstr "Python ãƒ—ãƒ­ã‚°ãƒ©ãƒã¯ã€ç‰¹å®šã®ã‚¨ãƒ©ãƒ¼å‡¦ç†ãŒå¿…è¦ãªã¨ãã ã‘ã—ã‹ä¾‹å¤–ã‚’æ‰±ã†å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“; å‡¦ç†ã—ãªã‹ã£ãŸä¾‹å¤–ã¯ã€å‡¦ç†ã®å‘¼ã³å‡ºã—å´ã€ãã®ã¾ãŸå‘¼ã³å‡ºã—å´ã€ã¨ã„ã£ãŸå…·åˆã«ã€ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿å±¤ã¾ã§è‡ªå‹•çš„ã«ä¼æ’­ã—ã¾ã™ã€‚ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿å±¤ã¯ã€ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã¨åˆã‚ã›ã¦ä¾‹å¤–ã‚’ãƒ¦ãƒ¼ã‚¶ã«å ±å‘Šã—ã¾ã™ã€‚"

#: ../../c-api/intro.rst:366
msgid ""
"For C programmers, however, error checking always has to be explicit.  All "
"functions in the Python/C API can raise exceptions, unless an explicit claim"
" is made otherwise in a function's documentation.  In general, when a "
"function encounters an error, it sets an exception, discards any object "
"references that it owns, and returns an error indicator.  If not documented "
"otherwise, this indicator is either *NULL* or ``-1``, depending on the "
"function's return type. A few functions return a Boolean true/false result, "
"with false indicating an error.  Very few functions return no explicit error"
" indicator or have an ambiguous return value, and require explicit testing "
"for errors with :c:func:`PyErr_Occurred`.  These exceptions are always "
"explicitly documented."
msgstr "ã¨ã“ã‚ãŒã€ C ãƒ—ãƒ­ã‚°ãƒ©ãƒã®å ´åˆã€ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯ã¯å¸¸ã«æ˜ç¤ºçš„ã«è¡Œã‚ã­ã°ãªã‚Šã¾ã›ã‚“ã€‚ Python/C API ã®å…¨ã¦ã®é–¢æ•°ã¯ã€é–¢æ•°ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§æ˜ç¢ºã«èª¬æ˜ãŒãªã„é™ã‚Šä¾‹å¤–ã‚’ç™ºè¡Œã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ä¸€èˆ¬çš„ãªè©±ã¨ã—ã¦ã€ã‚ã‚‹é–¢æ•°ãŒä½•ã‚‰ã‹ã®ã‚¨ãƒ©ãƒ¼ã«é­é‡ã™ã‚‹ã¨ã€é–¢æ•°ã¯ä¾‹å¤–ã‚’è¨­å®šã—ã¦ã€é–¢æ•°å†…ã«ãŠã‘ã‚‹å‚ç…§ã®æ‰€æœ‰æ¨©ã‚’å…¨ã¦æ”¾æ£„ã—ã€ã‚¨ãƒ©ãƒ¼å€¤(error indicator)ã‚’è¿”ã—ã¾ã™ã€‚ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«æ›¸ã‹ã‚Œã¦ãªã„å ´åˆã€ã“ã®ã‚¨ãƒ©ãƒ¼å€¤ã¯é–¢æ•°ã®æˆ»ã‚Šå€¤ã®å‹ã«ã‚ˆã£ã¦ã€ *NULL* ã‹ ``-1`` ã®ã©ã¡ã‚‰ã‹ã«ãªã‚Šã¾ã™ã€‚ã„ãã¤ã‹ã®é–¢æ•°ã§ã¯ãƒ–ãƒ¼ãƒ«å‹ã§çœŸ/å½ã‚’è¿”ã—ã€å½ã¯ã‚¨ãƒ©ãƒ¼ã‚’ç¤ºã—ã¾ã™ã€‚ãã‚ã‚ã¦å°‘æ•°ã®é–¢æ•°ã§ã¯æ˜ç¢ºãªã‚¨ãƒ©ãƒ¼æŒ‡æ¨™ã‚’è¿”ã•ãªã‹ã£ãŸã‚Šã€ã‚ã„ã¾ã„ãªæˆ»ã‚Šå€¤ã‚’è¿”ã—ãŸã‚Šã™ã‚‹ã®ã§ã€ :c:func:`PyErr_Occurred` ã§æ˜ç¤ºçš„ã«ã‚¨ãƒ©ãƒ¼ãƒ†ã‚¹ãƒˆã‚’è¡Œã†å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã®ä¾‹å¤–ã¯å¸¸ã«æ˜ç¤ºçš„ã«ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆåŒ–ã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/intro.rst:381
msgid ""
"Exception state is maintained in per-thread storage (this is  equivalent to "
"using global storage in an unthreaded application).  A  thread can be in one"
" of two states: an exception has occurred, or not. The function "
":c:func:`PyErr_Occurred` can be used to check for this: it returns a "
"borrowed reference to the exception type object when an exception has "
"occurred, and *NULL* otherwise.  There are a number of functions to set the "
"exception state: :c:func:`PyErr_SetString` is the most common (though not "
"the most general) function to set the exception state, and "
":c:func:`PyErr_Clear` clears the exception state."
msgstr "ä¾‹å¤–æ™‚ã®çŠ¶æ…‹æƒ…å ± (exception state)ã¯ã€ã‚¹ãƒ¬ãƒƒãƒ‰å˜ä½ã«ç”¨æ„ã•ã‚ŒãŸè¨˜æ†¶é ˜åŸŸ (per-thread storage) å†…ã§ç®¡ç†ã•ã‚Œã¾ã™ (ã“ã®è¨˜æ†¶é ˜åŸŸã¯ã€ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ä½¿ã‚ãªã„ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªè¨˜æ†¶é ˜åŸŸã¨åŒã˜ã§ã™)ã€‚ä¸€ã¤ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¯äºŒã¤ã®çŠ¶æ…‹ã®ã©ã¡ã‚‰ã‹: ä¾‹å¤–ãŒç™ºç”Ÿã—ãŸã‹ã€ã¾ã ç™ºç”Ÿã—ã¦ã„ãªã„ã‹ã€ã‚’ã¨ã‚Šã¾ã™ã€‚é–¢æ•° :c:func:`PyErr_Occurred` ã‚’ä½¿ã†ã¨ã€ã“ã®çŠ¶æ…‹ã‚’èª¿ã¹ã‚‰ã‚Œã¾ã™: ã“ã®é–¢æ•°ã¯ä¾‹å¤–ãŒç™ºç”Ÿã—ãŸéš›ã«ã¯ãã®ä¾‹å¤–å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹å€Ÿç”¨å‚ç…§ (borrowed reference) ã‚’è¿”ã—ã€ãã†ã§ãªã„ã¨ãã«ã¯ *NULL* ã‚’è¿”ã—ã¾ã™ã€‚ä¾‹å¤–çŠ¶æ…‹ã‚’è¨­å®šã™ã‚‹é–¢æ•°ã¯æ•°å¤šãã‚ã‚Šã¾ã™: :c:func:`PyErr_SetString` ã¯ã‚‚ã£ã¨ã‚‚ã‚ˆãçŸ¥ã‚‰ã‚Œã¦ã„ã‚‹ (ãŒã€ã‚‚ã£ã¨ã‚‚æ±ç”¨æ€§ã®ãªã„) ä¾‹å¤–ã‚’è¨­å®šã™ã‚‹ãŸã‚ã®é–¢æ•°ã§ã€ :c:func:`PyErr_Clear` ã¯ä¾‹å¤–çŠ¶æ…‹æƒ…å ±ã‚’æ¶ˆã—å»ã‚‹é–¢æ•°ã§ã™ã€‚"

#: ../../c-api/intro.rst:396
msgid ""
"The full exception state consists of three objects (all of which can  be "
"*NULL*): the exception type, the corresponding exception  value, and the "
"traceback.  These have the same meanings as the Python   objects "
"``sys.exc_type``, ``sys.exc_value``, and ``sys.exc_traceback``; however, "
"they are not the same: the Python objects represent the last exception being"
" handled by a Python  :keyword:`try` ... :keyword:`except` statement, while "
"the C level exception state only exists while an exception is being passed "
"on between C functions until it reaches the Python bytecode interpreter's  "
"main loop, which takes care of transferring it to ``sys.exc_type`` and "
"friends."
msgstr "å®Œå…¨ãªä¾‹å¤–çŠ¶æ…‹æƒ…å ±ã¯ã€3 ã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ: ä¾‹å¤–ã®å‹ã€ä¾‹å¤–ã®å€¤ã€ãã—ã¦ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã€ã‹ã‚‰ãªã‚Šã¾ã™  (ã©ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚ *NULL* ã‚’å–ã‚Šå¾—ã¾ã™)ã€‚ã“ã‚Œã‚‰ã®æƒ…å ±ã¯ã€ Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®   ``sys.exc_type``, ``sys.exc_value``, ãŠã‚ˆã³ ``sys.exc_traceback`` ã¨åŒã˜æ„å‘³ã‚’æŒã¡ã¾ã™; ã¨ã¯ã„ãˆã€ C ã¨ Python ã®ä¾‹å¤–çŠ¶æ…‹æƒ…å ±ã¯å…¨ãåŒã˜ã§ã¯ã‚ã‚Šã¾ã›ã‚“: Python ã«ãŠã‘ã‚‹ä¾‹å¤–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€Python ã® :keyword:`try` ...  :keyword:`except` æ–‡ã§æœ€è¿‘å‡¦ç†ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¡¨ã™ä¸€æ–¹ã€ C ãƒ¬ãƒ™ãƒ«ã®ä¾‹å¤–çŠ¶æ…‹æƒ…å ±ãŒå­˜ç¶šã™ã‚‹ã®ã¯ã€æ¸¡ã•ã‚ŒãŸä¾‹å¤–æƒ…å ±ã‚’ ``sys.exc_type`` ãã®ä»–ã«è»¢é€ã™ã‚‹ã‚ˆã†å–ã‚Šè¨ˆã‚‰ã† Python ã®ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—ã«åˆ°é”ã™ã‚‹ã¾ã§ã€ä¾‹å¤–ãŒé–¢æ•°ã®é–“ã§å—ã‘æ¸¡ã—ã•ã‚Œã¦ã„ã‚‹é–“ã ã‘ã§ã™ã€‚"

#: ../../c-api/intro.rst:408
msgid ""
"Note that starting with Python 1.5, the preferred, thread-safe way to access"
" the exception state from Python code is to call the function "
":func:`sys.exc_info`, which returns the per-thread exception state for "
"Python code.  Also, the semantics of both ways to access the exception state"
" have changed so that a function which catches an exception will save and "
"restore its thread's exception state so as to preserve the exception state "
"of its caller.  This prevents common bugs in exception handling code caused "
"by an innocent-looking function overwriting the exception being handled; it "
"also reduces the often unwanted lifetime extension for objects that are "
"referenced by the stack frames in the traceback."
msgstr "Python 1.5 ã‹ã‚‰ã¯ã€Python ã§æ›¸ã‹ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã‹ã‚‰ä¾‹å¤–çŠ¶æ…‹æƒ…å ±ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹æ–¹æ³•ã¨ã—ã¦ã€æ¨å¥¨ã•ã‚Œã¦ã„ã¦ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ãªæ–¹æ³•ã¯ :func:`sys.exc_info` ã«ãªã£ã¦ã„ã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã“ã®é–¢æ•°ã¯ Python ã‚³ãƒ¼ãƒ‰ã®å®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã«ãŠã‘ã‚‹ä¾‹å¤–çŠ¶æ…‹æƒ…å ±ã‚’è¿”ã—ã¾ã™ã€‚ã¾ãŸã€ã“ã‚Œã‚‰ã®ä¾‹å¤–çŠ¶æ…‹æƒ…å ±ã«å¯¾ã™ã‚‹ã‚¢ã‚¯ã‚»ã‚¹æ‰‹æ®µã¯ã€ä¸¡æ–¹ã¨ã‚‚æ„å‘³ã¥ã‘ (semantics) ãŒå¤‰æ›´ã•ã‚Œã€ã‚ã‚‹é–¢æ•°ãŒä¾‹å¤–ã‚’æ•æ‰ã™ã‚‹ã¨ã€ãã®é–¢æ•°ã‚’å®Ÿè¡Œã—ã¦ã„ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã®ä¾‹å¤–çŠ¶æ…‹æƒ…å ±ã‚’ä¿å­˜ã—ã¦ã€å‘¼ã³å‡ºã—å´ã®ä¾‹å¤–çŠ¶æ…‹æƒ…å ±ã‚’ç¶­æŒã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ã“ã®å¤‰æ›´ã«ã‚ˆã£ã¦ã€ç„¡å®³ãã†ã«è¦‹ãˆã‚‹é–¢æ•°ãŒç¾åœ¨æ‰±ã£ã¦ã„ã‚‹ä¾‹å¤–ã‚’ä¸Šæ›¸ãã™ã‚‹ã“ã¨ã§å¼•ãèµ·ã“ã•ã‚Œã‚‹ã€ä¾‹å¤–å‡¦ç†ã‚³ãƒ¼ãƒ‰ã§ã‚ˆããŠãã¦ã„ãŸãƒã‚°ã‚’æŠ‘æ­¢ã—ã¦ã„ã¾ã™; ã¾ãŸã€ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯å†…ã®ã‚¹ã‚¿ãƒƒã‚¯ãƒ•ãƒ¬ãƒ¼ãƒ ã§å‚ç…§ã•ã‚Œã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã—ã°ã—ã°ä¸å¿…è¦ã«å¯¿å‘½ã‚’æ°¸ã‚‰ãˆã¦ã„ãŸã®ã‚’ãªãã—ã¦ã„ã¾ã™ã€‚"

#: ../../c-api/intro.rst:419
msgid ""
"As a general principle, a function that calls another function to  perform "
"some task should check whether the called function raised an  exception, and"
" if so, pass the exception state on to its caller.  It  should discard any "
"object references that it owns, and return an  error indicator, but it "
"should *not* set another exception --- that would overwrite the exception "
"that was just raised, and lose important information about the exact cause "
"of the error."
msgstr "ä¸€èˆ¬çš„ãªåŸç†ã¨ã—ã¦ã€ã‚ã‚‹é–¢æ•°ãŒåˆ¥ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ä½•ã‚‰ã‹ã®ä½œæ¥­ã‚’ã•ã›ã‚‹ã¨ãã€å‘¼ã³å‡ºã—å…ˆã®é–¢æ•°ãŒä¾‹å¤–ã‚’é€å‡ºã—ã¦ã„ãªã„ã‹èª¿ã¹ãªãã¦ã¯ãªã‚‰ãšã€ã‚‚ã—é€å‡ºã—ã¦ã„ã‚Œã°ã€ãã®ä¾‹å¤–çŠ¶æ…‹æƒ…å ±ã¯å‘¼ã³å‡ºã—å´ã«æ¸¡ã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å‘¼ã³å‡ºã—å…ƒã®é–¢æ•°ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‚ç…§ã®æ‰€æœ‰æ¨©ã‚’ã™ã¹ã¦æ”¾æ£„ã—ã€ã‚¨ãƒ©ãƒ¼æŒ‡æ¨™ã‚’è¿”ã•ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ãŒã€ä½™è¨ˆã«ä¾‹å¤–ã‚’è¨­å®šã™ã‚‹å¿…è¦ã¯ *ã‚ã‚Šã¾ã›ã‚“* --- ãã‚“ãªã“ã¨ã‚’ã™ã‚Œã°ã€ãŸã£ãŸä»Šé€å‡ºã•ã‚ŒãŸã°ã‹ã‚Šã®ä¾‹å¤–ã‚’ä¸Šæ›¸ãã—ã¦ã—ã¾ã„ã€ã‚¨ãƒ©ãƒ¼ã®åŸå› ãã®ã‚‚ã®ã«é–¢ã™ã‚‹é‡è¦ãªæƒ…å ±ã‚’å¤±ã†ã“ã¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/intro.rst:428
msgid ""
"A simple example of detecting exceptions and passing them on is shown in the"
" :c:func:`sum_sequence` example above.  It so happens that this example "
"doesn't need to clean up any owned references when it detects an error.  The"
" following example function shows some error cleanup.  First, to remind you "
"why you like Python, we show the equivalent Python code::"
msgstr "ä¾‹å¤–ã‚’æ¤œå‡ºã—ã¦æ¸¡ã™ä¾‹ã¯ã€ä¸Šã® :c:func:`sum_sequence` ã§ç¤ºã—ã¦ã„ã¾ã™ã€‚å¶ç„¶ã«ã‚‚ã€ã“ã®ä¾‹ã§ã¯ã‚¨ãƒ©ãƒ¼ã‚’æ¤œå‡ºã—ãŸéš›ã«ä½•ã‚‰å‚ç…§ã‚’æ”¾æ£„ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ä»¥ä¸‹ã®é–¢æ•°ã®ä¾‹ã§ã¯ã€ã‚¨ãƒ©ãƒ¼ã«å¯¾ã™ã‚‹å¾Œå§‹æœ«ã«ã¤ã„ã¦ç¤ºã—ã¦ã„ã¾ã™ã€‚ã¾ãšã€ã©ã†ã—ã¦ Python ã§æ›¸ãã®ãŒå¥½ãã‹æ€ã„å‡ºã—ã¦ã‚‚ã‚‰ã†ãŸã‚ã«ã€ç­‰ä¾¡ãª Python ã‚³ãƒ¼ãƒ‰ã‚’ç¤ºã—ã¾ã™::"

#: ../../c-api/intro.rst:443
msgid "Here is the corresponding C code, in all its glory::"
msgstr "ä»¥ä¸‹ã¯å¯¾å¿œã™ã‚‹ã‚³ãƒ¼ãƒ‰ã‚’ C ã§å®Œç’§ã«æ›¸ã„ãŸã‚‚ã®ã§ã™::"

#: ../../c-api/intro.rst:495
msgid ""
"This example represents an endorsed use of the ``goto`` statement  in C! It "
"illustrates the use of :c:func:`PyErr_ExceptionMatches` and "
":c:func:`PyErr_Clear` to handle specific exceptions, and the use of "
":c:func:`Py_XDECREF` to dispose of owned references that may be *NULL* (note"
" the ``'X'`` in the name; :c:func:`Py_DECREF` would crash when confronted "
"with a *NULL* reference).  It is important that the variables used to hold "
"owned references are initialized to *NULL* for this to work; likewise, the "
"proposed return value is initialized to ``-1`` (failure) and only set to "
"success after the final call made is successful."
msgstr "ãªã‚“ã¨ã“ã®ä¾‹ã¯ C ã§ ``goto`` æ–‡ã‚’ä½¿ã†ãŠå‹§ã‚ã®æ–¹æ³•ã¾ã§ç¤ºã—ã¦ã„ã¾ã™ã­! ã“ã®ä¾‹ã§ã¯ã€ç‰¹å®šã®ä¾‹å¤–ã‚’å‡¦ç†ã™ã‚‹ãŸã‚ã« :c:func:`PyErr_ExceptionMatches`  ãŠã‚ˆã³ :c:func:`PyErr_Clear` ã‚’ã©ã†ä½¿ã†ã‹ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚ã¾ãŸã€æ‰€æœ‰æ¨©ã‚’æŒã£ã¦ã„ã‚‹å‚ç…§ã§ã€å€¤ãŒ *NULL* ã«ãªã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã‚‚ã®ã‚’æ¨ã¦ã‚‹ãŸã‚ã«  :c:func:`Py_XDECREF` ã‚’ã©ã†ä½¿ã†ã‹ã‚‚ç¤ºã—ã¦ã„ã¾ã™ (é–¢æ•°åã« ``'X'`` ãŒä»˜ã„ã¦ã„ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„; :c:func:`Py_DECREF` ã¯ *NULL* å‚ç…§ã«å‡ºãã‚ã™ã¨ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã—ã¾ã™)ã€‚æ­£ã—ãå‹•ä½œã•ã›ã‚‹ãŸã‚ã«ã¯ã€æ‰€æœ‰æ¨©ã‚’æŒã¤å‚ç…§ã‚’ä¿æŒã™ã‚‹ãŸã‚ã®å¤‰æ•°ã‚’ *NULL* ã§åˆæœŸåŒ–ã™ã‚‹ã“ã¨ãŒé‡è¦ã§ã™; åŒæ§˜ã«ã€ã‚ã‚‰ã‹ã˜ã‚æˆ»ã‚Šå€¤ã‚’å®šç¾©ã™ã‚‹éš›ã«ã¯å€¤ã‚’ ``-1`` (å¤±æ•—) ã§åˆæœŸåŒ–ã—ã¦ãŠã„ã¦ã€æœ€å¾Œã®é–¢æ•°å‘¼ã³å‡ºã—ã¾ã§ã†ã¾ãã„ã£ãŸå ´åˆã«ã®ã¿ ``0`` (æˆåŠŸ) ã«è¨­å®šã—ã¾ã™ã€‚"

#: ../../c-api/intro.rst:509
msgid "Embedding Python"
msgstr "Python ã®åŸ‹ã‚è¾¼ã¿"

#: ../../c-api/intro.rst:511
msgid ""
"The one important task that only embedders (as opposed to extension writers)"
" of the Python interpreter have to worry about is the initialization, and "
"possibly the finalization, of the Python interpreter.  Most functionality of"
" the interpreter can only be used after the interpreter has been "
"initialized."
msgstr "Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®åŸ‹ã‚è¾¼ã¿ã‚’è¡Œã†äºº (ã„ã‚ã°æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æ›¸ãæ‰‹ã®å¯¾æ¥µ) ãŒæ°—ã«ã‹ã‘ãªã‘ã‚Œã°ãªã‚‰ãªã„é‡è¦ãªã‚¿ã‚¹ã‚¯ã¯ã€Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®åˆæœŸåŒ–å‡¦ç† (initialization)ã€ãã—ã¦ãŠãã‚‰ãã¯çµ‚äº†å‡¦ç† (finalization) ã§ã™ã€‚ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®ã»ã¨ã‚“ã©ã®æ©Ÿèƒ½ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®èµ·å‹•å¾Œã—ã‹ä½¿ãˆã¾ã›ã‚“ã€‚"

#: ../../c-api/intro.rst:525
msgid ""
"The basic initialization function is :c:func:`Py_Initialize`. This "
"initializes the table of loaded modules, and creates the fundamental modules"
" :mod:`__builtin__`, :mod:`__main__`, :mod:`sys`, and :mod:`exceptions`.  It"
" also initializes the module search path (``sys.path``)."
msgstr "åŸºæœ¬çš„ãªåˆæœŸåŒ–å‡¦ç†ã‚’è¡Œã†é–¢æ•°ã¯ :c:func:`Py_Initialize` ã§ã™ã€‚ã“ã®é–¢æ•°ã¯ãƒ­ãƒ¼ãƒ‰æ¸ˆã¿ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰ãªã‚‹ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ä½œæˆã—ã€åœŸå°ã¨ãªã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« :mod:`__builtin__`, :mod:`__main__`,  :mod:`sys` , :mod:`exceptions` ã‚’ä½œæˆã—ã¾ã™ã€‚ã¾ãŸã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ¤œç´¢ãƒ‘ã‚¹ (``sys.path``)    ã®åˆæœŸåŒ–ã‚‚è¡Œã„ã¾ã™ã€‚"

#: ../../c-api/intro.rst:532
msgid ""
":c:func:`Py_Initialize` does not set the \"script argument list\"  "
"(``sys.argv``). If this variable is needed by Python code that will be "
"executed later, it must be set explicitly with a call to  "
"``PySys_SetArgvEx(argc, argv, updatepath)`` after the call to "
":c:func:`Py_Initialize`."
msgstr ":c:func:`Py_Initialize` ã®ä¸­ã§ã¯ã€ \"ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¸ã®å¼•æ•°ãƒªã‚¹ãƒˆ\" (script argument list, ``sys.argv`` ã®ã“ã¨) ã‚’è¨­å®šã—ã¾ã›ã‚“ã€‚ã“ã®å¤‰æ•°ãŒå¾Œã«å®Ÿè¡Œã•ã‚Œã‚‹ Python ã‚³ãƒ¼ãƒ‰ä¸­ã§å¿…è¦ãªã‚‰ã€ :c:func:`Py_Initialize` ã®å¾Œã§ ``PySys_SetArgvEx(argc, argv, updatepath)`` ã‚’å‘¼ã³å‡ºã—ã¦æ˜ç¤ºçš„ã«è¨­å®šã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/intro.rst:537
msgid ""
"On most systems (in particular, on Unix and Windows, although the details "
"are slightly different), :c:func:`Py_Initialize` calculates the module "
"search path based upon its best guess for the location of the standard "
"Python interpreter executable, assuming that the Python library is found in "
"a fixed location relative to the Python interpreter executable.  In "
"particular, it looks for a directory named :file:`lib/python{X.Y}` relative "
"to the parent directory where the executable named :file:`python` is found "
"on the shell command search path (the environment variable :envvar:`PATH`)."
msgstr "ã»ã¨ã‚“ã©ã®ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ (ç‰¹ã« Unix ã¨ Windows ã¯ã€è©³ç´°ãŒã‚ãšã‹ã«ç•°ãªã‚Šã¯ã—ã¾ã™ãŒ)ã€ :c:func:`Py_Initialize` ã¯æ¨™æº–ã® Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿å®Ÿè¡Œå½¢å¼ã®å ´æ‰€ã«å¯¾ã™ã‚‹æ¨å®šçµæœã«åŸºã¥ã„ã¦ã€ Python ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒ Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿å®Ÿè¡Œå½¢å¼ã‹ã‚‰ã®ç›¸å¯¾ãƒ‘ã‚¹ã§è¦‹ã¤ã‹ã‚‹ã¨ã„ã†ä»®å®šã®ä¸‹ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ¤œç´¢ãƒ‘ã‚¹ã‚’è¨ˆç®—ã—ã¾ã™ã€‚ã¨ã‚Šã‚ã‘ã“ã®æ¤œç´¢ã§ã¯ã€ã‚·ã‚§ãƒ«ã‚³ãƒãƒ³ãƒ‰æ¤œç´¢ãƒ‘ã‚¹ (ç’°å¢ƒå¤‰æ•° :envvar:`PATH`) ä¸Šã«è¦‹ã¤ã‹ã£ãŸ :file:`python` ã¨ã„ã†åå‰ã®å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«ã®ç½®ã‹ã‚Œã¦ã„ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®è¦ªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰ã®ç›¸å¯¾ã§ã€ :file:`lib/python{X.Y}` ã¨ã„ã†åå‰ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’æ¢ã—ã¾ã™ã€‚"

#: ../../c-api/intro.rst:546
msgid ""
"For instance, if the Python executable is found in "
":file:`/usr/local/bin/python`, it will assume that the libraries are in "
":file:`/usr/local/lib/python{X.Y}`.  (In fact, this particular path is also "
"the \"fallback\" location, used when no executable file named :file:`python`"
" is found along :envvar:`PATH`.)  The user can override this behavior by "
"setting the environment variable :envvar:`PYTHONHOME`, or insert additional "
"directories in front of the standard path by setting :envvar:`PYTHONPATH`."
msgstr "ä¾‹ãˆã°ã€ Python å®Ÿè¡Œå½¢å¼ãŒ :file:`/usr/local/bin/python` ã§è¦‹ã¤ã‹ã£ãŸã¨ã™ã‚‹ã¨ã€ :c:func:`Py_Initialize` ã¯ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒ :file:`/usr/local/lib/python{X.Y}` ã«ã‚ã‚‹ã‚‚ã®ã¨ä»®å®šã—ã¾ã™ã€‚ (å®Ÿéš›ã«ã¯ã€ã“ã®ãƒ‘ã‚¹ã¯ \"ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ (fallback)\" ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªä½ç½®ã§ã‚‚ã‚ã‚Šã€ :file:`python` ãŒ :envvar:`PATH` ä¸Šã«ãªã„å ´åˆã«ä½¿ã‚ã‚Œã¾ã™ã€‚) ãƒ¦ãƒ¼ã‚¶ã¯ :envvar:`PYTHONHOME` ã‚’è¨­å®šã™ã‚‹ã“ã¨ã§ã“ã®å‹•ä½œã‚’ã‚ªãƒ¼ãƒãƒ©ã‚¤ãƒ‰ã—ãŸã‚Šã€ :envvar:`PYTHONPATH` ã‚’è¨­å®šã—ã¦è¿½åŠ ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’æ¨™æº–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ¤œç´¢ãƒ‘ã‚¹ã®å‰ã«æŒ¿å…¥ã—ãŸã‚Šã§ãã¾ã™ã€‚"

#: ../../c-api/intro.rst:561
msgid ""
"The embedding application can steer the search by calling "
"``Py_SetProgramName(file)`` *before* calling  :c:func:`Py_Initialize`.  Note"
" that :envvar:`PYTHONHOME` still overrides this and :envvar:`PYTHONPATH` is "
"still inserted in front of the standard path.  An application that requires "
"total control has to provide its own implementation of :c:func:`Py_GetPath`,"
" :c:func:`Py_GetPrefix`, :c:func:`Py_GetExecPrefix`, and "
":c:func:`Py_GetProgramFullPath` (all defined in :file:`Modules/getpath.c`)."
msgstr "åŸ‹ã‚è¾¼ã¿ã‚’è¡Œã†ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ã€ :c:func:`Py_Initialize` ã‚’å‘¼ã³å‡ºã™ *å‰ã«* ``Py_SetProgramName(file)``  ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã€ä¸Šè¨˜ã®æ¤œç´¢ã‚’æ“ä½œã§ãã¾ã™ã€‚ã“ã®åŸ‹ã‚è¾¼ã¿ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã®è¨­å®šã¯ä¾ç„¶ã¨ã—ã¦ :envvar:`PYTHONHOME`  ã§ã‚ªãƒ¼ãƒãƒ©ã‚¤ãƒ‰ã§ãã€æ¨™æº–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ¤œç´¢ãƒ‘ã‚¹ã®å‰ã«ã¯ä»¥å‰ã¨ã—ã¦ :envvar:`PYTHONPATH` ãŒæŒ¿å…¥ã•ã‚Œã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ¤œç´¢ãƒ‘ã‚¹ã‚’å®Œå…¨ã«åˆ¶å¾¡ã—ãŸã„ã®ãªã‚‰ã€ç‹¬è‡ªã« :c:func:`Py_GetPath`, :c:func:`Py_GetPrefix`, :c:func:`Py_GetExecPrefix`,  ãŠã‚ˆã³ :c:func:`Py_GetProgramFullPath`  ã®å®Ÿè£…ã‚’æä¾›ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ (ã“ã‚Œã‚‰ã¯å…¨ã¦ :file:`Modules/getpath.c` ã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã™)ã€‚"

#: ../../c-api/intro.rst:571
msgid ""
"Sometimes, it is desirable to \"uninitialize\" Python.  For instance,  the "
"application may want to start over (make another call to "
":c:func:`Py_Initialize`) or the application is simply done with its  use of "
"Python and wants to free memory allocated by Python.  This can be "
"accomplished by calling :c:func:`Py_Finalize`.  The function "
":c:func:`Py_IsInitialized` returns true if Python is currently in the "
"initialized state.  More information about these functions is given in a "
"later chapter. Notice that :c:func:`Py_Finalize` does *not* free all memory "
"allocated by the Python interpreter, e.g. memory allocated by extension "
"modules currently cannot be released."
msgstr "ãŸã¾ã«ã€ Python ã‚’ \"åˆæœŸåŒ–ã—ãªã„\" ã‚ˆã†ã«ã—ãŸã„ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€ã‚ã‚‹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯å®Ÿè¡Œã‚’æœ€åˆã‹ã‚‰ã‚„ã‚ŠãªãŠã— (start over) ã•ã›ã‚‹ (:c:func:`Py_Initialize` ã‚’ã‚‚ã†ä¸€åº¦å‘¼ã³å‡ºã•ã›ã‚‹) ã‚ˆã†ã«ã—ãŸã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã‚ã‚‹ã„ã¯ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒ Python ã‚’ä¸€æ—¦ä½¿ã„çµ‚ãˆã¦ã€Python ãŒç¢ºä¿ã—ãŸãƒ¡ãƒ¢ãƒªã‚’è§£æ”¾ã§ãã‚‹ã‚ˆã†ã«ã—ãŸã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ :c:func:`Py_Finalize` ã‚’ä½¿ã†ã¨ã€ã“ã†ã—ãŸå‡¦ç†ã‚’å®Ÿç¾ã§ãã¾ã™ã€‚ã¾ãŸã€é–¢æ•° :c:func:`Py_IsInitialized`  ã¯ã€Python ãŒç¾åœ¨åˆæœŸåŒ–æ¸ˆã¿ã®çŠ¶æ…‹ã«ã‚ã‚‹å ´åˆã«çœŸã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã®é–¢æ•°ã«ã¤ã„ã¦ã®ã•ã‚‰ãªã‚‹æƒ…å ±ã¯ã€å¾Œã®ç« ã§èª¬æ˜ã—ã¾ã™ã€‚ :c:func:`Py_Finalize` ãŒPythonã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ç¢ºä¿ã•ã‚ŒãŸå…¨ã¦ã®ãƒ¡ãƒ¢ãƒªã‚’ *è§£æ”¾ã™ã‚‹ã‚ã‘ã§ã¯ãªã„* ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ä¾‹ãˆã°ã€æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚ˆã£ã¦ç¢ºä¿ã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªã¯ã€ç¾åœ¨ã®ã¨ã“ã‚è§£æ”¾ã™ã‚‹äº‹ãŒã§ãã¾ã›ã‚“ã€‚"

#: ../../c-api/intro.rst:585
msgid "Debugging Builds"
msgstr "ãƒ‡ãƒãƒƒã‚°ç‰ˆãƒ“ãƒ«ãƒ‰ (Debugging Builds)"

#: ../../c-api/intro.rst:587
msgid ""
"Python can be built with several macros to enable extra checks of the "
"interpreter and extension modules.  These checks tend to add a large amount "
"of overhead to the runtime so they are not enabled by default."
msgstr "ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¨æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å¯¾ã—ã¦ã®è¿½åŠ ãƒã‚§ãƒƒã‚¯ã‚’ã™ã‚‹ãŸã‚ã®ã„ãã¤ã‹ã®ãƒã‚¯ãƒ­ã‚’æœ‰åŠ¹ã«ã—ã¦Pythonã‚’ãƒ“ãƒ«ãƒ‰ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒã‚§ãƒƒã‚¯ã¯ã€å®Ÿè¡Œæ™‚ã«å¤§ããªã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã‚’ç”Ÿã˜ã‚‹å‚¾å‘ãŒã‚ã‚Šã¾ã™ã€‚ãªã®ã§ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯æœ‰åŠ¹ã«ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"

#: ../../c-api/intro.rst:591
msgid ""
"A full list of the various types of debugging builds is in the file "
":file:`Misc/SpecialBuilds.txt` in the Python source distribution. Builds are"
" available that support tracing of reference counts, debugging the memory "
"allocator, or low-level profiling of the main interpreter loop.  Only the "
"most frequently-used builds will be described in the remainder of this "
"section."
msgstr "Pythonãƒ‡ãƒãƒƒã‚°ç‰ˆãƒ“ãƒ«ãƒ‰ã®å…¨ã¦ã®ç¨®é¡ã®ãƒªã‚¹ãƒˆãŒã€Pythonã‚½ãƒ¼ã‚¹é…å¸ƒ(source distribution)ã®ä¸­ã® :file:`Misc/SpecialBuilds.txt` ã«ã‚ã‚Šã¾ã™ã€‚å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã®ãƒˆãƒ¬ãƒ¼ã‚¹ã€ãƒ¡ãƒ¢ãƒªã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã®ãƒ‡ãƒãƒƒã‚°ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—ã®ä½ãƒ¬ãƒ™ãƒ«ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°ãŒåˆ©ç”¨å¯èƒ½ã§ã™ã€‚ã‚ˆãä½¿ã‚ã‚Œã‚‹ãƒ“ãƒ«ãƒ‰ã«ã¤ã„ã¦ã®ã¿ã€ã“ã®ç¯€ã®æ®‹ã‚Šã®éƒ¨åˆ†ã§èª¬æ˜ã—ã¾ã™ã€‚"

#: ../../c-api/intro.rst:597
msgid ""
"Compiling the interpreter with the :c:macro:`Py_DEBUG` macro defined "
"produces what is generally meant by \"a debug build\" of Python. "
":c:macro:`Py_DEBUG` is enabled in the Unix build by adding ``--with-"
"pydebug`` to the :file:`./configure` command.  It is also implied by the "
"presence of the not-Python-specific :c:macro:`_DEBUG` macro.  When "
":c:macro:`Py_DEBUG` is enabled in the Unix build, compiler optimization is "
"disabled."
msgstr "ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’ :c:macro:`Py_DEBUG` ãƒã‚¯ãƒ­ã‚’æœ‰åŠ¹ã«ã—ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ã¨ã€ä¸€èˆ¬çš„ã«ã€Œãƒ‡ãƒãƒƒã‚°ãƒ“ãƒ«ãƒ‰ã€ã¨ã„ã‚ã‚Œã‚‹PythonãŒã§ãã¾ã™ã€‚ Unix ã§ã¯ã€ :file:`./configure` ã‚³ãƒãƒ³ãƒ‰ã« ``--with-pydebug`` ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã§ã€ :c:macro:`Py_DEBUG` ãŒæœ‰åŠ¹ã«ãªã‚Šã¾ã™ã€‚ãã®å ´åˆã€æš—é»™çš„ã«Pythonå°‚ç”¨ã§ã¯ãªã„ :c:macro:`_DEBUG` ã‚‚æœ‰åŠ¹ã«ãªã‚Šã¾ã™ã€‚ Unix ãƒ“ãƒ«ãƒ‰ã§ã¯ã€ :c:macro:`Py_DEBUG` ãŒæœ‰åŠ¹ãªå ´åˆã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®æœ€é©åŒ–ãŒç„¡åŠ¹ã«ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/intro.rst:604
msgid ""
"In addition to the reference count debugging described below, the following "
"extra checks are performed:"
msgstr "ã‚ã¨ã§èª¬æ˜ã™ã‚‹å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãƒ‡ãƒãƒƒã‚°ã®ä»–ã«ã€ä»¥ä¸‹ã®è¿½åŠ ãƒã‚§ãƒƒã‚¯ã‚‚æœ‰åŠ¹ã«ãªã‚Šã¾ã™:"

#: ../../c-api/intro.rst:607
msgid "Extra checks are added to the object allocator."
msgstr "object allocator ã«å¯¾ã™ã‚‹è¿½åŠ ãƒã‚§ãƒƒã‚¯ã€‚"

#: ../../c-api/intro.rst:609
msgid "Extra checks are added to the parser and compiler."
msgstr "ãƒ‘ãƒ¼ã‚µãƒ¼ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«å¯¾ã™ã‚‹è¿½åŠ ãƒã‚§ãƒƒã‚¯ã€‚"

#: ../../c-api/intro.rst:611
msgid ""
"Downcasts from wide types to narrow types are checked for loss of "
"information."
msgstr "æƒ…å ±æå¤±ã®ãŸã‚ã«ã€å¤§ãã„å‹ã‹ã‚‰å°ã•ã„å‹ã¸ã®ãƒ€ã‚¦ãƒ³ã‚­ãƒ£ã‚¹ãƒˆã«å¯¾ã™ã‚‹ãƒã‚§ãƒƒã‚¯ã€‚"

#: ../../c-api/intro.rst:613
msgid ""
"A number of assertions are added to the dictionary and set implementations. "
"In addition, the set object acquires a :meth:`test_c_api` method."
msgstr "è¾æ›¸(dict)ã¨é›†åˆ(set)ã®å®Ÿè£…ã«å¯¾ã™ã‚‹ã€ã„ãã¤ã‚‚ã® assertion ã®è¿½åŠ ã€‚åŠ ãˆã¦ã€é›†åˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã« :meth:`test_c_api` ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¿½åŠ ã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/intro.rst:616
msgid "Sanity checks of the input arguments are added to frame creation."
msgstr "ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ä½œæˆã™ã‚‹æ™‚ã®ã€å¼•æ•°ã®å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯ã€‚"

#: ../../c-api/intro.rst:618
msgid ""
"The storage for long ints is initialized with a known invalid pattern to "
"catch reference to uninitialized digits."
msgstr "åˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„æ•°ã«å¯¾ã™ã‚‹å‚ç…§ã‚’æ¤œå‡ºã™ã‚‹ãŸã‚ã«ã€é•·æ•´æ•°ã®ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãŒç‰¹å®šã®å¦¥å½“ã§ãªã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã§åˆæœŸåŒ–ã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/intro.rst:621
msgid ""
"Low-level tracing and extra exception checking are added to the runtime "
"virtual machine."
msgstr "ä½ãƒ¬ãƒ™ãƒ«ãƒˆãƒ¬ãƒ¼ã‚¹ã¨è¿½åŠ ä¾‹å¤–ãƒã‚§ãƒƒã‚¯ãŒVM runtimeã«è¿½åŠ ã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/intro.rst:624
msgid "Extra checks are added to the memory arena implementation."
msgstr "ãƒ¡ãƒ¢ãƒªã‚¢ãƒªãƒ¼ãƒŠ(memory arena)ã®å®Ÿè£…ã«å¯¾ã™ã‚‹è¿½åŠ ãƒã‚§ãƒƒã‚¯ã€‚"

#: ../../c-api/intro.rst:626
msgid "Extra debugging is added to the thread module."
msgstr "threadãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å¯¾ã™ã‚‹è¿½åŠ ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½."

#: ../../c-api/intro.rst:628
msgid "There may be additional checks not mentioned here."
msgstr "ã“ã“ã§è¨€åŠã•ã‚Œã¦ã„ãªã„è¿½åŠ ãƒã‚§ãƒƒã‚¯ã‚‚ã‚ã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../c-api/intro.rst:630
msgid ""
"Defining :c:macro:`Py_TRACE_REFS` enables reference tracing.  When defined, "
"a circular doubly linked list of active objects is maintained by adding two "
"extra fields to every :c:type:`PyObject`.  Total allocations are tracked as "
"well.  Upon exit, all existing references are printed.  (In interactive mode"
" this happens after every statement run by the interpreter.)  Implied by "
":c:macro:`Py_DEBUG`."
msgstr ":c:macro:`Py_TRACE_REFS` ã‚’å®£è¨€ã™ã‚‹ã¨ã€å‚ç…§ãƒˆãƒ¬ãƒ¼ã‚¹ãŒæœ‰åŠ¹ã«ãªã‚Šã¾ã™ã€‚å…¨ã¦ã® :c:type:`PyObject` ã«äºŒã¤ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã§ã€ä½¿ç”¨ä¸­ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å¾ªç’°äºŒé‡é€£çµãƒªã‚¹ãƒˆãŒç®¡ç†ã•ã‚Œã¾ã™ã€‚å…¨ã¦ã®å‰²ã‚Šå½“ã¦(allocation)ãŒãƒˆãƒ¬ãƒ¼ã‚¹ã•ã‚Œã¾ã™ã€‚çµ‚äº†æ™‚ã«ã€å…¨ã¦ã®æ®‹ã£ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚ (ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ã‚ˆã‚‹æ–‡ã®å®Ÿè¡Œã®ãŸã³ã«è¡¨ç¤ºã•ã‚Œã¾ã™) :c:macro:`Py_TRACE_REFS` ã¯ :c:macro:`Py_DEBUG` ã«ã‚ˆã£ã¦æš—é»™çš„ã«æœ‰åŠ¹ã«ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/intro.rst:636
msgid ""
"Please refer to :file:`Misc/SpecialBuilds.txt` in the Python source "
"distribution for more detailed information."
msgstr "ã‚ˆã‚Šè©³ã—ã„æƒ…å ±ã«ã¤ã„ã¦ã¯ã€Pythonã®ã‚½ãƒ¼ã‚¹é…å¸ƒ(source distribution)ã®ä¸­ã® :file:`Misc/SpecialBuilds.txt` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"
