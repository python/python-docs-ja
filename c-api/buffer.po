# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# tomoğŸ§, 2017
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-21 01:52+0900\n"
"PO-Revision-Date: 2018-01-20 20:53+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/buffer.rst:6
msgid "Buffers and Memoryview Objects"
msgstr "buffer ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ memoryview ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../c-api/buffer.rst:16
msgid ""
"Python objects implemented in C can export a group of functions called the "
"\"buffer interface.\"  These functions can be used by an object to expose "
"its data in a raw, byte-oriented format. Clients of the object can use the "
"buffer interface to access the object data directly, without needing to copy"
" it first."
msgstr "C ã§å®Ÿè£…ã•ã‚ŒãŸ Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€\"ãƒãƒƒãƒ•ã‚¡ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ (buffer interface)\" ã¨å‘¼ã°ã‚Œã‚‹ä¸€é€£ã®é–¢æ•°ã‚’å…¬é–‹ã—ã¦ã„ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã®é–¢æ•°ã¯ã€ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿ (raw) ã®ãƒã‚¤ãƒˆåˆ—å½¢å¼ã§å…¬é–‹ã™ã‚‹ãŸã‚ã«ä½¿ã„ã¾ã™ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½¿ã„æ‰‹ã¯ã€ãƒãƒƒãƒ•ã‚¡ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ä½¿ã†ã“ã¨ã§ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚ã‚‰ã‹ã˜ã‚ã‚³ãƒ”ãƒ¼ã—ã¦ãŠãå¿…è¦ãªã—ã«ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ãƒ¼ã‚¿ã«ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚"

#: ../../c-api/buffer.rst:22
msgid ""
"Two examples of objects that support the buffer interface are strings and "
"arrays. The string object exposes the character contents in the buffer "
"interface's byte-oriented form. An array can only expose its contents via "
"the old-style buffer interface. This limitation does not apply to Python 3, "
"where :class:`memoryview` objects can be constructed from arrays, too. Array"
" elements may be multi-byte values."
msgstr "ãƒãƒƒãƒ•ã‚¡ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¾‹ã¨ã—ã¦ã€æ–‡å­—åˆ—å‹ã¨ã‚¢ãƒ¬ã‚¤ (array) å‹ã®äºŒã¤ãŒã‚ã‚Šã¾ã™ã€‚æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ãã®å†…å®¹ã‚’ãƒãƒƒãƒ•ã‚¡ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã®ãƒã‚¤ãƒˆæŒ‡å‘ã®å½¢å¼ã§å…¬é–‹ã—ã¦ã„ã¾ã™ã€‚ã‚¢ãƒ¬ã‚¤ã¯ãã®å†…å®¹ã‚’æ—§ã‚¹ã‚¿ã‚¤ãƒ«ãƒãƒƒãƒ•ã‚¡ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹çµŒç”±ã§ã—ã‹å…¬é–‹ã§ãã¾ã›ã‚“ã€‚ã“ã®åˆ¶é™ã¯ :class:`memoryview` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¢ãƒ¬ã‚¤ã‹ã‚‰æ§‹ç¯‰å‡ºæ¥ã‚‹ Python 3 ã«ã¯é©ç”¨ã•ã‚Œã¾ã›ã‚“ã€‚ã‚¢ãƒ¬ã‚¤ã®è¦ç´ ã¯è¤‡æ•°ãƒã‚¤ãƒˆã®å€¤ã«ãªã‚Šãˆã¾ã™ã€‚"

#: ../../c-api/buffer.rst:29
msgid ""
"An example user of the buffer interface is the file object's :meth:`write` "
"method. Any object that can export a series of bytes through the buffer "
"interface can be written to a file. There are a number of format codes to "
":c:func:`PyArg_ParseTuple` that operate against an object's buffer "
"interface, returning data from the target object."
msgstr "ãƒãƒƒãƒ•ã‚¡ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã®ä½¿ã„æ‰‹ã®ä¸€ä¾‹ã¨ã—ã¦ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`write` ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚ãƒãƒƒãƒ•ã‚¡ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ä»‹ã—ã¦ãƒã‚¤ãƒˆåˆ—ã‚’å…¬é–‹ã—ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å…¨ã¦ã€ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®æ›¸ãå‡ºã—ãŒã§ãã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒãƒƒãƒ•ã‚¡ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æ“ä½œã—ã€å¯¾è±¡ã¨ãªã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã•ã›ã‚‹ :c:func:`PyArg_ParseTuple` ã«ã¯æ•°å¤šãã®ãƒ‡ãƒ¼ã‚¿æ›¸å¼åŒ–ã‚³ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../c-api/buffer.rst:35
msgid ""
"Starting from version 1.6, Python has been providing Python-level buffer "
"objects and a C-level buffer API so that any built-in or used-defined type "
"can expose its characteristics. Both, however, have been deprecated because "
"of various shortcomings, and have been officially removed in Python 3 in "
"favour of a new C-level buffer API and a new Python-level object named "
":class:`memoryview`."
msgstr "ãƒãƒ¼ã‚¸ãƒ§ãƒ³ 1.6 ã‹ã‚‰ã€Python ã¯ Python ãƒ¬ãƒ™ãƒ«ã®ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã€ C è¨€èªãƒ¬ãƒ™ãƒ«ã®ãƒãƒƒãƒ•ã‚¡ API ã‚’æä¾›ã—ã¦ãŠã‚Šã€ä»»æ„ã®ãƒ“ãƒ«ãƒˆã‚¤ãƒ³å‹ã‚„ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©å‹ã¯ãã®æ–‡å­—åˆ—è¡¨ç¾ã‚’å…¬é–‹ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã—ã‹ã—ã€ä¸¡æ–¹å…±ã€å¹¾ã¤ã‹ã®æ¬ ç‚¹ã®ãŸã‚ã«å»ƒæ­¢äºˆå®šæ‰±ã„ã•ã‚Œã¦ã„ã¦ã€ Python 3 ã§ã¯å…¬å¼ã«å‰Šé™¤ã•ã‚Œã€æ–°ã—ã„ C è¨€èªãƒ¬ãƒ™ãƒ«ã®ãƒãƒƒãƒ•ã‚¡ API ã¨æ–°ã—ã„ Python ãƒ¬ãƒ™ãƒ«ã® :class:`memoryview` ã¨ã„ã†åå‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ç½®ãæ›ãˆã‚‰ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../c-api/buffer.rst:42
msgid ""
"The new buffer API has been backported to Python 2.6, and the "
":class:`memoryview` object has been backported to Python 2.7. It is strongly"
" advised to use them rather than the old APIs, unless you are blocked from "
"doing so for compatibility reasons."
msgstr "æ–°ã—ã„ãƒãƒƒãƒ•ã‚¡ API ã¯ Python 2.6 ã«é€†ç§»æ¤ã•ã‚Œã¦ãŠã‚Šã€ :class:`memoryviews` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ Python 2.7 ã«é€†ç§»æ¤ã•ã‚Œã¦ã„ã¾ã™ã€‚å¤ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ã®äº’æ›æ€§ãŒå¿…è¦ãªã‘ã‚Œã°ã€å¤ã„APIã®ä»£ã‚ã‚Šã«ã“ã‚Œã‚‰ã‚’ä½¿ã†ã“ã¨ã‚’ãŠã™ã™ã‚ã—ã¾ã™ã€‚"

#: ../../c-api/buffer.rst:49
msgid "The new-style Py_buffer struct"
msgstr "æ–°ã‚¹ã‚¿ã‚¤ãƒ« Py_buffer æ§‹é€ ä½“"

#: ../../c-api/buffer.rst:56
msgid "A pointer to the start of the memory for the object."
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ãƒ¢ãƒªã®é–‹å§‹ä½ç½®ã¸ã®ãƒã‚¤ãƒ³ã‚¿"

#: ../../c-api/buffer.rst:61
msgid "The total length of the memory in bytes."
msgstr "ãƒ¡ãƒ¢ãƒªã®ãƒˆãƒ¼ã‚¿ãƒ«ã‚µã‚¤ã‚º [byte]"

#: ../../c-api/buffer.rst:65
msgid "An indicator of whether the buffer is read only."
msgstr "ãƒãƒƒãƒ•ã‚¡ãŒèª­ã¿è¾¼ã¿å°‚ç”¨ã‹ã©ã†ã‹ã‚’ç¤ºã™"

#: ../../c-api/buffer.rst:70
msgid ""
"A *NULL* terminated string in :mod:`struct` module style syntax giving the "
"contents of the elements available through the buffer.  If this is *NULL*, "
"``\"B\"`` (unsigned bytes) is assumed."
msgstr "ãƒãƒƒãƒ•ã‚¡ã‚’é€šã—ã¦ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹è¦ç´ ã®å½¢å¼ã‚’æŒ‡å®šã™ã‚‹ã€ :mod:`struct` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¹ã‚¿ã‚¤ãƒ«æ–‡æ³•ã®ã€ *NULL* çµ‚ç«¯æ–‡å­—åˆ—ã€‚ã“ã®ãƒã‚¤ãƒ³ã‚¿ã®å€¤ãŒ *NULL* ãªã‚‰ã€ ``\"B\"`` (ç¬¦å·ç„¡ã—ãƒã‚¤ãƒˆ) ã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™ã€‚"

#: ../../c-api/buffer.rst:76
msgid ""
"The number of dimensions the memory represents as a multi-dimensional array."
"  If it is ``0``, :c:data:`strides` and :c:data:`suboffsets` must be *NULL*."
msgstr "ãƒ¡ãƒ¢ãƒªãŒå¤šæ¬¡å…ƒé…åˆ—ã‚’è¡¨ã—ã¦ã„ã‚‹æ™‚ã®æ¬¡å…ƒæ•°ã€‚ ``0`` ã®å ´åˆã€ :c:data:`strides` ã¨ :c:data:`suboffsets` ã¯ *NULL* ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/buffer.rst:82
msgid ""
"An array of :c:type:`Py_ssize_t`\\s the length of :c:data:`ndim` giving the "
"shape of the memory as a multi-dimensional array.  Note that ``((*shape)[0] "
"* ... * (*shape)[ndims-1])*itemsize`` should be equal to :c:data:`len`."
msgstr "ãƒ¡ãƒ¢ãƒªãŒå¤šæ¬¡å…ƒé…åˆ—ã‚’è¡¨ã—ã¦ã„ã‚‹ã¨ãã€ãã®å½¢ã‚’ç¤ºã™é•·ã• :c:data:`ndim` ã® :c:type:`Py_ssize_t` ã®é…åˆ—ã€‚ ``((*shape)[0] * ... * (*shape)[ndims-1])*itemsize`` ã¯ :c:data:`len` ã¨ç­‰ã—ããªã‘ã‚Œã°ãªã‚‰ãªã„ã“ã¨ã«æ°—ã‚’ã¤ã‘ã¦ãã ã•ã„ã€‚"

#: ../../c-api/buffer.rst:89
msgid ""
"An array of :c:type:`Py_ssize_t`\\s the length of :c:data:`ndim` giving the "
"number of bytes to skip to get to a new element in each dimension."
msgstr "å„æ¬¡å…ƒã§æ¬¡ã®è¦ç´ ã‚’å¾—ã‚‹ãŸã‚ã«ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹ãƒã‚¤ãƒˆæ•°ã‚’ç¤ºã™ã€é•·ã• :c:data:`ndim` ã® :c:type:`Py_ssize_t` ã®é…åˆ—ã€‚"

#: ../../c-api/buffer.rst:94
msgid ""
"An array of :c:type:`Py_ssize_t`\\s the length of :c:data:`ndim`.  If these "
"suboffset numbers are greater than or equal to 0, then the value stored "
"along the indicated dimension is a pointer and the suboffset value dictates "
"how many bytes to add to the pointer after de-referencing. A suboffset value"
" that it negative indicates that no de-referencing should occur (striding in"
" a contiguous memory block)."
msgstr "é•·ã• :c:data:`ndim` ã® :c:type:`Py_ssize_t` ã®é…åˆ—ã€‚ suboffset ã®å„æ•°å€¤ãŒ 0 ä»¥ä¸Šã§ã‚ã‚‹ã¨ãã€ãã®æ¬¡å…ƒã«æ ¼ç´ã•ã‚Œã¦ã„ã‚‹ã®ã¯ãƒã‚¤ãƒ³ã‚¿ã§ã€ suboffset ã®å€¤ã¯ãã®ãƒã‚¤ãƒ³ã‚¿ã®å‚ç…§ã‚’è§£æ±ºã™ã‚‹ã¨ãã«ä½•ãƒã‚¤ãƒˆã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¶³ã™ã‹ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚ suboffset ã«è² ã®æ•°ãŒæ ¼ç´ã•ã‚Œã¦ã„ã‚‹ã¨ãã¯ã€å‚ç…§è§£æ±ºãŒä¸è¦ã§ã‚ã‚‹ã“ã¨ (é€£ç¶šã—ãŸãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯å†…ã«ç›´æ¥é…ç½®ã•ã‚Œã¦ã„ã‚‹ã“ã¨)ã‚’æ„å‘³ã—ã¦ã„ã¾ã™ã€‚"

#: ../../c-api/buffer.rst:101
msgid ""
"If all suboffsets are negative (i.e. no de-referencing is needed, then this "
"field must be NULL (the default value)."
msgstr "å…¨ã¦ã® suboffset ãŒè² æ•°ã®å ´åˆ (ã¤ã¾ã‚Šå‚ç…§è§£æ±ºãŒä¸è¦) ãªå ´åˆã€ã“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ NULL ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ (ã“ã‚ŒãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã™)ã€‚"

#: ../../c-api/buffer.rst:104
msgid ""
"Here is a function that returns a pointer to the element in an N-D array "
"pointed to by an N-dimensional index when there are both non-NULL strides "
"and suboffsets::"
msgstr "æ¬¡ã®ä¾‹ã¯ã€ strides ã‚‚ suboffsets ã‚‚ NULL ã§ãªã„å ´åˆã®ã€N æ¬¡å…ƒã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«ã‚ˆã£ã¦æŒ‡ã•ã‚Œã¦ã„ã‚‹ N æ¬¡å…ƒé…åˆ—å†…ã®è¦ç´ ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã™é–¢æ•°ã§ã™ã€‚ ::"

#: ../../c-api/buffer.rst:124
msgid ""
"This is a storage for the itemsize (in bytes) of each element of the shared "
"memory. It is technically un-necessary as it can be obtained using "
":c:func:`PyBuffer_SizeFromFormat`, however an exporter may know this "
"information without parsing the format string and it is necessary to know "
"the itemsize for proper interpretation of striding. Therefore, storing it is"
" more convenient and faster."
msgstr "ã“ã‚Œã¯å…±æœ‰ãƒ¡ãƒ¢ãƒªä¸Šã®å„è¦ç´ ã®byteå˜ä½ã®ã‚µã‚¤ã‚ºã‚’æ ¼ç´ã™ã‚‹å¤‰æ•°ã§ã™ã€‚ã“ã‚Œã¯ :c:func:`PyBuffer_SizeFromFormat` ã‚’ä½¿ã£ã¦è¨ˆç®—ã§ãã‚‹å€¤ãªã®ã§æŠ€è¡“çš„ã«ã¯ä¸è¦ãªã®ã§ã™ãŒã€ãƒãƒƒãƒ•ã‚¡ã‚’æä¾›ã™ã‚‹å´ã¯ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ–‡å­—åˆ—ã‚’è§£æã—ãªãã¦ã‚‚ã“ã®æƒ…å ±ã‚’çŸ¥ã£ã¦ã„ã‚‹ã§ã—ã‚‡ã†ã—ã€ãƒãƒƒãƒ•ã‚¡ã‚’å—ã‘å–ã‚‹å´ã«ã¨ã£ã¦ã¯æ­£ã—ãè§£é‡ˆã™ã‚‹ã®ã«å¿…è¦ãªæƒ…å ±ã§ã™ã€‚ãªã®ã§ã€è¦ç´ ã‚µã‚¤ã‚ºã‚’æ ¼ç´ã™ã‚‹ã»ã†ãŒä¾¿åˆ©ã§ã™ã—é«˜é€Ÿã§ã™ã€‚"

#: ../../c-api/buffer.rst:133
msgid ""
"This is for use internally by the exporting object. For example, this might "
"be re-cast as an integer by the exporter and used to store flags about "
"whether or not the shape, strides, and suboffsets arrays must be freed when "
"the buffer is released. The consumer should never alter this value."
msgstr "ãƒãƒƒãƒ•ã‚¡ã‚’æä¾›ã™ã‚‹å´ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå†…éƒ¨çš„ã«åˆ©ç”¨ã™ã‚‹ãŸã‚ã®å¤‰æ•°ã§ã™ã€‚ä¾‹ãˆã°ã€æä¾›å´ã¯ã“ã®å¤‰æ•°ã«æ•´æ•°å‹ã‚’ã‚­ãƒ£ã‚¹ãƒˆã—ã¦ã€ shape, strides, suboffsets ã¨ã„ã£ãŸé…åˆ—ã‚’ãƒãƒƒãƒ•ã‚¡ã‚’è§£æ”¾ã™ã‚‹ã¨ãã«åŒæ™‚ã«è§£æ”¾ã™ã‚‹ã¹ãã‹ã©ã†ã‹ã‚’ç®¡ç†ã™ã‚‹ãƒ•ãƒ©ã‚°ã«ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã§ã—ã‚‡ã†ã€‚ãƒãƒƒãƒ•ã‚¡ã‚’å—ã‘å–ã‚‹å´ã¯ã€ã“ã®å€¤ã‚’å¤‰æ›´ã—ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/buffer.rst:141
msgid "Buffer related functions"
msgstr "ãƒãƒƒãƒ•ã‚¡é–¢é€£é–¢æ•°"

#: ../../c-api/buffer.rst:146
msgid "Return ``1`` if *obj* supports the buffer interface otherwise ``0``."
msgstr "*obj* ãŒãƒãƒƒãƒ•ã‚¡ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹å ´åˆã« ``1`` ã‚’ã€ãã‚Œä»¥å¤–ã®å ´åˆã« ``0`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/buffer.rst:151
msgid ""
"Export *obj* into a :c:type:`Py_buffer`, *view*.  These arguments must never"
" be *NULL*.  The *flags* argument is a bit field indicating what kind of "
"buffer the caller is prepared to deal with and therefore what kind of buffer"
" the exporter is allowed to return.  The buffer interface allows for "
"complicated memory sharing possibilities, but some caller may not be able to"
" handle all the complexity but may want to see if the exporter will let them"
" take a simpler view to its memory."
msgstr "*obj* ã‚’ :c:type:`Py_buffer` *view* ã¸ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã®å¼•æ•°ã¯ *NULL* ã§ã‚ã£ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ *flag* å¼•æ•°ã¯å‘¼ã³å‡ºã—å´ãŒã©ã‚“ãªãƒãƒƒãƒ•ã‚¡ã‚’æ‰±ãŠã†ã¨ã—ã¦ã„ã‚‹ã®ã‹ã€ãƒãƒƒãƒ•ã‚¡æä¾›å´ãŒã©ã‚“ãªãƒãƒƒãƒ•ã‚¡ã‚’è¿”ã™ã“ã¨ãŒè¨±ã•ã‚Œã¦ã„ã‚‹ã®ã‹ã‚’ç¤ºã™ã€ãƒ“ãƒƒãƒˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§ã™ã€‚ãƒãƒƒãƒ•ã‚¡ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã¯è¤‡é›‘ãªãƒ¡ãƒ¢ãƒªå…±æœ‰ã‚’å¯èƒ½ã«ã—ã¦ã„ã¾ã™ãŒã€å‘¼ã³å‡ºã—å…ƒã¯ã™ã¹ã¦ã®è¤‡é›‘ãªãƒãƒƒãƒ•ã‚¡ã‚’æ‰±ãˆã‚‹ã¨ã¯é™ã‚‰ãšã€ãƒãƒƒãƒ•ã‚¡æä¾›å´ãŒã‚·ãƒ³ãƒ—ãƒ«ãªãƒ“ãƒ¥ãƒ¼ã‚’æä¾›ã§ãã‚‹ãªã‚‰ãã‚Œã‚’åˆ©ç”¨ã—ãŸã„ã¨ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../c-api/buffer.rst:159
msgid ""
"Some exporters may not be able to share memory in every possible way and may"
" need to raise errors to signal to some consumers that something is just not"
" possible. These errors should be a :exc:`BufferError` unless there is "
"another error that is actually causing the problem. The exporter can use "
"flags information to simplify how much of the :c:data:`Py_buffer` structure "
"is filled in with non-default values and/or raise an error if the object "
"can't support a simpler view of its memory."
msgstr "ãƒãƒƒãƒ•ã‚¡æä¾›å´ã¯ã™ã¹ã¦ã®æ–¹æ³•ã§ãƒ¡ãƒ¢ãƒªã‚’å…±æœ‰ã§ãã‚‹ã¨ã¯é™ã‚‰ãšã€å‘¼ã³å‡ºã—å´ã«ä½•ã‹ãŒä¸å¯èƒ½ã§ã‚ã‚‹ã“ã¨ã‚’ä¼ãˆã‚‹ãŸã‚ã«ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿã•ã›ã‚‹å¿…è¦ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ãã®å ´åˆã®ã‚¨ãƒ©ãƒ¼ã¯ã€ã‚‚ã—ãã®å•é¡Œã‚’å®Ÿéš›ã«å¼•ãèµ·ã“ã—ã¦ã„ã‚‹ã®ãŒåˆ¥ã®ã‚¨ãƒ©ãƒ¼ã ã£ãŸã¨ã—ã¦ã‚‚ã€ :exc:`BufferError` ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãƒãƒƒãƒ•ã‚¡æä¾›å´ã¯ flag ã®æƒ…å ±ã‚’ä½¿ã£ã¦ :c:data:`Py_buffer` æ§‹é€ ä½“ã®ã©ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¸ã®éãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã®è¨­å®šã‚’çœç•¥ã—ãŸã‚Šã€è¦æ±‚ã•ã‚ŒãŸã‚·ãƒ³ãƒ—ãƒ«ãª view ã‚’æä¾›ã§ããªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿã•ã›ãŸã‚Šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../c-api/buffer.rst:167
msgid "``0`` is returned on success and ``-1`` on error."
msgstr "æˆåŠŸã—ãŸã‚‰ ``0`` ãŒã€ã‚¨ãƒ©ãƒ¼æ™‚ã«ã¯ ``-1`` ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/buffer.rst:169
msgid "The following table gives possible values to the *flags* arguments."
msgstr "æ¬¡ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ã€ *flags* å¼•æ•°ãŒå–ã‚Šã†ã‚‹å€¤ã§ã™ã€‚"

#: ../../c-api/buffer.rst:172
msgid "Flag"
msgstr "Flag"

#: ../../c-api/buffer.rst:172
msgid "Description"
msgstr "èª¬æ˜"

#: ../../c-api/buffer.rst:174
msgid ":c:macro:`PyBUF_SIMPLE`"
msgstr ":c:macro:`PyBUF_SIMPLE`"

#: ../../c-api/buffer.rst:174
msgid ""
"This is the default flag state.  The returned buffer may or may not have "
"writable memory.  The format of the data will be assumed to be unsigned "
"bytes.  This is a \"stand-alone\" flag constant. It never needs to be '|'d "
"to the others. The exporter will raise an error if it cannot provide such a "
"contiguous buffer of bytes."
msgstr "ã“ã‚Œã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® flag ã®çŠ¶æ…‹ã§ã™ã€‚çµæœã®ãƒãƒƒãƒ•ã‚¡ã¯æ›¸ãè¾¼ã¿å¯èƒ½ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã—ã€ä¸å¯èƒ½ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ãƒ‡ãƒ¼ã‚¿ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ unsigned byte ã¨ã—ã¾ã™ã€‚ã“ã‚Œã¯ \"ã‚¹ã‚¿ãƒ³ãƒ‰ã‚¢ãƒ­ãƒ³\" ã®ãƒ•ãƒ©ã‚°å®šæ•°ã§ã™ã€‚ä»–ã®å®šæ•°ã¨ '|' ã‚’å–ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚æä¾›å´ã¯ã“ã®ã‚ˆã†ãªé€£ç¶šã—ãŸãƒã‚¤ãƒˆåˆ—ã®ãƒãƒƒãƒ•ã‚¡ã‚’æä¾›ã§ããªã„å ´åˆã«ã€ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿã•ã›ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../c-api/buffer.rst:183
msgid ":c:macro:`PyBUF_WRITABLE`"
msgstr ":c:macro:`PyBUF_WRITABLE`"

#: ../../c-api/buffer.rst:183
msgid ""
"The returned buffer must be writable.  If it is not writable, then raise an "
"error."
msgstr "çµæœã®ãƒãƒƒãƒ•ã‚¡ã¯æ›¸è¾¼ã¿å¯èƒ½ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚æ›¸ãè¾¼ã¿ä¸å¯èƒ½ãªå ´åˆã¯ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚"

#: ../../c-api/buffer.rst:186
msgid ":c:macro:`PyBUF_STRIDES`"
msgstr ":c:macro:`PyBUF_STRIDES`"

#: ../../c-api/buffer.rst:186
msgid ""
"This implies :c:macro:`PyBUF_ND`. The returned buffer must provide strides "
"information (i.e. the strides cannot be NULL). This would be used when the "
"consumer can handle strided, discontiguous arrays.  Handling strides "
"automatically assumes you can handle shape.  The exporter can raise an error"
" if a strided representation of the data is not possible (i.e. without the "
"suboffsets)."
msgstr "ã“ã®å€¤ã¯ :c:macro:`PyBUF_ND` ã‚’å«ã¿ã¾ã™ã€‚ãƒãƒƒãƒ•ã‚¡ã¯ strides æƒ…å ±ã‚’æä¾›ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ (è¨€ã„æ›ãˆã‚‹ã¨ã€ strides ã¯ NULL ã§ã‚ã£ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚) ã“ã®ãƒ•ãƒ©ã‚°ã¯ã€å‘¼ã³å‡ºã—å…ƒãŒã€è¦ç´ é–“ã«éš™é–“ã®ã‚ã‚‹ä¸é€£ç¶šãªé…åˆ—ã‚’æ‰±ãˆã‚‹ã¨ãã«ä½¿ã‚ã‚Œã¾ã™ã€‚ strides ã‚’æ‰±ã†ã“ã¨ã¯ã€è‡ªå‹•çš„ã« shape ã‚‚æ‰±ãˆã‚‹ã“ã¨ã‚’è¦æ±‚ã•ã‚Œã¾ã™ã€‚æä¾›å´ã¯ stride å½¢å¼ã®ãƒãƒƒãƒ•ã‚¡ã‚’æä¾›ã§ããªã„ã¨ã(ä¾‹ãˆã°ã€ suboffset ãŒå¿…è¦ãªå ´åˆ)ã¯ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚"

#: ../../c-api/buffer.rst:196
msgid ":c:macro:`PyBUF_ND`"
msgstr ":c:macro:`PyBUF_ND`"

#: ../../c-api/buffer.rst:196
msgid ""
"The returned buffer must provide shape information. The memory will be "
"assumed C-style contiguous (last dimension varies the fastest). The exporter"
" may raise an error if it cannot provide this kind of contiguous buffer. If "
"this is not given then shape will be *NULL*."
msgstr "ãƒãƒƒãƒ•ã‚¡ã¯ shape æƒ…å ±ã‚’æä¾›ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãƒ¡ãƒ¢ãƒªã¯ C ã‚¹ã‚¿ã‚¤ãƒ«ã®ä¸¦ã³ (æœ€å¾Œã®æ¬¡å…ƒãŒä¸€ç•ªé«˜é€Ÿ) ã ã¨ä»®å®šã•ã‚Œã¾ã™ã€‚æä¾›å´ã¯ã“ã®ç¨®é¡ã®é€£ç¶šãƒãƒƒãƒ•ã‚¡ã‚’æä¾›ã§ããªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚ã“ã®ãƒ•ãƒ©ã‚°ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªå ´åˆã¯ shape ã¯ *NULL* ã«ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/buffer.rst:206
msgid ""
":c:macro:`PyBUF_C_CONTIGUOUS` :c:macro:`PyBUF_F_CONTIGUOUS` "
":c:macro:`PyBUF_ANY_CONTIGUOUS`"
msgstr ":c:macro:`PyBUF_C_CONTIGUOUS` :c:macro:`PyBUF_F_CONTIGUOUS` :c:macro:`PyBUF_ANY_CONTIGUOUS`"

#: ../../c-api/buffer.rst:206
msgid ""
"These flags indicate that the contiguity returned buffer must be "
"respectively, C-contiguous (last dimension varies the fastest), Fortran "
"contiguous (first dimension varies the fastest) or either one.  All of these"
" flags imply :c:macro:`PyBUF_STRIDES` and guarantee that the strides buffer "
"info structure will be filled in correctly."
msgstr "ã“ã‚Œã‚‰ã®ãƒ•ãƒ©ã‚°ã¯ã€è¿”ã•ã‚Œã‚‹ãƒãƒƒãƒ•ã‚¡ã®ä¸¦ã³ã‚’æŒ‡å®šã—ã¾ã™ã€‚ãã‚Œãã‚Œã€Cä¸¦ã³(æœ€å¾Œã®æ¬¡å…ƒãŒä¸€ç•ªé«˜é€Ÿ)ã€Fortranä¸¦ã³(æœ€åˆã®æ¬¡å…ƒãŒä¸€ç•ªé«˜é€Ÿ), ãã®ã©ã¡ã‚‰ã§ã‚‚ã€ã‚’æ„å‘³ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ•ãƒ©ã‚°ã¯ :c:macro:`PyBUF_STRIDES` ã‚’å«ã‚“ã§ãŠã‚Šã€ strides æƒ…å ±ãŒæ­£ã—ãæ ¼ç´ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ä¿è¨¼ã—ã¾ã™ã€‚"

#: ../../c-api/buffer.rst:216
msgid ":c:macro:`PyBUF_INDIRECT`"
msgstr ":c:macro:`PyBUF_INDIRECT`"

#: ../../c-api/buffer.rst:216
msgid ""
"This flag indicates the returned buffer must have suboffsets information "
"(which can be NULL if no suboffsets are needed).  This can be used when the "
"consumer can handle indirect array referencing implied by these suboffsets. "
"This implies :c:macro:`PyBUF_STRIDES`."
msgstr "ã“ã®ãƒ•ãƒ©ã‚°ã¯ã€è¿”ã•ã‚Œã‚‹ãƒãƒƒãƒ•ã‚¡ãŒ suboffsets æƒ…å ±ã‚’å«ã‚“ã§ã„ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚(suboffsets ãŒå¿…è¦ç„¡ã„ã¨ãã¯ NULL ã§ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚) ã“ã®ãƒ•ãƒ©ã‚°ã¯ã€ãƒãƒƒãƒ•ã‚¡åˆ©ç”¨å´ãŒ suboffsets ã‚’ä½¿ã£ã¦å‚ç…§ã•ã‚Œã¦ã„ã‚‹é–“æ¥é…åˆ—ã‚’æ‰±ãˆã‚‹ã¨ãã«åˆ©ç”¨ã•ã‚Œã¾ã™ã€‚ã“ã®ãƒ•ãƒ©ã‚°ã¯ :c:macro:`PyBUF_STRIDES` ã‚’å«ã¿ã¾ã™ã€‚"

#: ../../c-api/buffer.rst:226
msgid ":c:macro:`PyBUF_FORMAT`"
msgstr ":c:macro:`PyBUF_FORMAT`"

#: ../../c-api/buffer.rst:226
msgid ""
"The returned buffer must have true format information if this flag is "
"provided. This would be used when the consumer is going to be checking for "
"what 'kind' of data is actually stored. An exporter should always be able to"
" provide this information if requested. If format is not explicitly "
"requested then the format must be returned as *NULL* (which means ``'B'``, "
"or unsigned bytes)"
msgstr "è¿”ã•ã‚Œã‚‹ãƒãƒƒãƒ•ã‚¡ã¯æ­£ã—ã„ format æƒ…å ±ã‚’æŒã£ã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®ãƒ•ãƒ©ã‚°ã¯ã€ãƒãƒƒãƒ•ã‚¡åˆ©ç”¨å´ãŒå®Ÿéš›ã«æ ¼ç´ã•ã‚Œã¦ã„ã‚‹ãƒ‡ãƒ¼ã‚¿ã® 'ç¨®é¡' ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã¨ãã«åˆ©ç”¨ã—ã¾ã™ã€‚ãƒãƒƒãƒ•ã‚¡æä¾›å´ã¯ã€è¦æ±‚ã•ã‚ŒãŸå ´åˆã¯å¸¸ã«ã“ã®æƒ…å ±ã‚’æä¾›ã§ãã‚‹ã¹ãã§ã™ã€‚ format ãŒæ˜ç¤ºçš„ã«è¦æ±‚ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ format ã¯ *NULL* (``'B'``, unsigned byte ã‚’æ„å‘³ã™ã‚‹)ã§ã‚ã‚‹ã¹ãã§ã™ã€‚"

#: ../../c-api/buffer.rst:236
msgid ":c:macro:`PyBUF_STRIDED`"
msgstr ":c:macro:`PyBUF_STRIDED`"

#: ../../c-api/buffer.rst:236
msgid "This is equivalent to ``(PyBUF_STRIDES | PyBUF_WRITABLE)``."
msgstr "``(PyBUF_STRIDES | PyBUF_WRITABLE)`` ã¨åŒã˜"

#: ../../c-api/buffer.rst:239
msgid ":c:macro:`PyBUF_STRIDED_RO`"
msgstr ":c:macro:`PyBUF_STRIDED_RO`"

#: ../../c-api/buffer.rst:239
msgid "This is equivalent to ``(PyBUF_STRIDES)``."
msgstr "``(PyBUF_STRIDES)`` ã¨åŒã˜"

#: ../../c-api/buffer.rst:242
msgid ":c:macro:`PyBUF_RECORDS`"
msgstr ":c:macro:`PyBUF_RECORDS`"

#: ../../c-api/buffer.rst:242
msgid ""
"This is equivalent to ``(PyBUF_STRIDES | PyBUF_FORMAT | PyBUF_WRITABLE)``."
msgstr "``(PyBUF_STRIDES | PyBUF_FORMAT | PyBUF_WRITABLE)`` ã¨åŒã˜"

#: ../../c-api/buffer.rst:245
msgid ":c:macro:`PyBUF_RECORDS_RO`"
msgstr ":c:macro:`PyBUF_RECORDS_RO`"

#: ../../c-api/buffer.rst:245
msgid "This is equivalent to ``(PyBUF_STRIDES | PyBUF_FORMAT)``."
msgstr "``(PyBUF_STRIDES | PyBUF_FORMAT)`` ã¨åŒã˜"

#: ../../c-api/buffer.rst:248
msgid ":c:macro:`PyBUF_FULL`"
msgstr ":c:macro:`PyBUF_FULL`"

#: ../../c-api/buffer.rst:248
msgid ""
"This is equivalent to ``(PyBUF_INDIRECT | PyBUF_FORMAT | PyBUF_WRITABLE)``."
msgstr "``(PyBUF_INDIRECT | PyBUF_FORMAT | PyBUF_WRITABLE)`` ã¨åŒã˜"

#: ../../c-api/buffer.rst:251
msgid ":c:macro:`PyBUF_FULL_RO`"
msgstr ":c:macro:`PyBUF_FULL_RO`"

#: ../../c-api/buffer.rst:251
msgid "This is equivalent to ``(PyBUF_INDIRECT | PyBUF_FORMAT)``."
msgstr "``(PyBUF_INDIRECT | PyBUF_FORMAT)`` ã¨åŒã˜"

#: ../../c-api/buffer.rst:254
msgid ":c:macro:`PyBUF_CONTIG`"
msgstr ":c:macro:`PyBUF_CONTIG`"

#: ../../c-api/buffer.rst:254
msgid "This is equivalent to ``(PyBUF_ND | PyBUF_WRITABLE)``."
msgstr "``(PyBUF_ND | PyBUF_WRITABLE)`` ã¨åŒã˜"

#: ../../c-api/buffer.rst:257
msgid ":c:macro:`PyBUF_CONTIG_RO`"
msgstr ":c:macro:`PyBUF_CONTIG_RO`"

#: ../../c-api/buffer.rst:257
msgid "This is equivalent to ``(PyBUF_ND)``."
msgstr "``(PyBUF_ND)`` ã¨åŒã˜"

#: ../../c-api/buffer.rst:264
msgid ""
"Release the buffer *view*.  This should be called when the buffer is no "
"longer being used as it may free memory from it."
msgstr "*view* ãƒãƒƒãƒ•ã‚¡ã‚’è§£æ”¾ã—ã¾ã™ã€‚ãƒãƒƒãƒ•ã‚¡ãŒåˆ©ç”¨ã•ã‚Œãªããªã£ãŸã¨ãã«ã€ãã®ãƒ¡ãƒ¢ãƒªã‚’è§£æ”¾ã§ãã‚‹ã‚ˆã†ã«ã“ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã¹ãã§ã™ã€‚"

#: ../../c-api/buffer.rst:270
msgid ""
"Return the implied :c:data:`~Py_buffer.itemsize` from the struct-stype "
":c:data:`~Py_buffer.format`."
msgstr ":c:data:`~Py_buffer.itemsize` ã®å€¤ã‚’ :c:data:`~PyBuffer.format` ã‹ã‚‰è¨ˆç®—ã—ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/buffer.rst:276
msgid ""
"Return ``1`` if the memory defined by the *view* is C-style (*fortran* is "
"``'C'``) or Fortran-style (*fortran* is ``'F'``) contiguous or either one "
"(*fortran* is ``'A'``).  Return ``0`` otherwise."
msgstr "*view* ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ãƒ¡ãƒ¢ãƒªãŒã€ C ã‚¹ã‚¿ã‚¤ãƒ« (*fortran* == ``'C'``) ã®ã¨ãã‹ã€ Fortran ã‚¹ã‚¿ã‚¤ãƒ« (*fortran* == ``'F'``) ã®ã¨ãã‹ã€ãã®ã„ãšã‚Œã‹ (*fortran* == ``'A'``) ã§ã‚ã‚Œã° ``1`` ã‚’è¿”ã—ã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ ``0`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/buffer.rst:283
msgid ""
"Fill the *strides* array with byte-strides of a contiguous (C-style if "
"*fortran* is ``'C'`` or Fortran-style if *fortran* is ``'F'``) array of the "
"given shape with the given number of bytes per element."
msgstr "*strides* é…åˆ—ã‚’ã€ *itemsize* ã®å¤§ãã•ã®è¦ç´ ãŒãƒã‚¤ãƒˆå˜ä½ã§é€£ç¶šã—ãŸã€ *shape* ã®å½¢ã‚’ã—ãŸ (*fortran* ãŒ ``'C'`` ãªã‚‰ C-style, ``'F'`` ãªã‚‰ Fortran-style ã®) å¤šæ¬¡å…ƒé…åˆ—ã¨ã—ã¦åŸ‹ã‚ã‚‹ã€‚"

#: ../../c-api/buffer.rst:290
msgid ""
"Fill in a buffer-info structure, *view*, correctly for an exporter that can "
"only share a contiguous chunk of memory of \"unsigned bytes\" of the given "
"length.  Return ``0`` on success and ``-1`` (with raising an error) on "
"error."
msgstr "ãƒãƒƒãƒ•ã‚¡æä¾›å´ãŒä¸ãˆã‚‰ã‚ŒãŸé•·ã•ã® \"unsigned bytes\" ã®é€£ç¶šã—ãŸ1ã¤ã®ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã—ã‹æä¾›ã§ããªã„ã‚‚ã®ã¨ã—ã¦ã€ *view* ãƒãƒƒãƒ•ã‚¡æƒ…å ±æ§‹é€ ä½“ã‚’æ­£ã—ãåŸ‹ã‚ã‚‹ã€‚æˆåŠŸã—ãŸã‚‰ ``0`` ã‚’ã€ã‚¨ãƒ©ãƒ¼æ™‚ã«ã¯ (ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã¤ã¤) ``-1`` ã‚’è¿”ã™ã€‚"

#: ../../c-api/buffer.rst:296
msgid "MemoryView objects"
msgstr "memoryview ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../c-api/buffer.rst:300
msgid ""
"A :class:`memoryview` object exposes the new C level buffer interface as a "
"Python object which can then be passed around like any other object."
msgstr ":class:`memoryview` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€æ–°ã—ã„ã€ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨åŒã˜ã‚ˆã†ã«æ‰±ãˆã‚‹ Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å½¢ã‚’ã—ãŸ Cè¨€èªãƒ¬ãƒ™ãƒ«ã®ãƒãƒƒãƒ•ã‚¡ã¸ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã§ã™ã€‚"

#: ../../c-api/buffer.rst:305
msgid ""
"Create a memoryview object from an object that defines the new buffer "
"interface."
msgstr "æ–°ã—ã„ãƒãƒƒãƒ•ã‚¡ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®šç¾©ã—ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ memoryview ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã‚Šã¾ã™ã€‚"

#: ../../c-api/buffer.rst:311
msgid ""
"Create a memoryview object wrapping the given buffer-info structure *view*. "
"The memoryview object then owns the buffer, which means you shouldn't try to"
" release it yourself: it will be released on deallocation of the memoryview "
"object."
msgstr "buffer-info æ§‹é€ ä½“ *view* ã‚’ãƒ©ãƒƒãƒ—ã™ã‚‹ memoryview ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã‚Šã¾ã™ã€‚ä½œã‚‰ã‚ŒãŸ memoryview ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒãƒƒãƒ•ã‚¡ã‚’æ‰€æœ‰ã™ã‚‹ã“ã¨ã«ãªã‚‹ã®ã§ã€ *view* ã‚’è§£æ”¾ã—ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚ã“ã®ãƒãƒƒãƒ•ã‚¡ã¯ memoryview ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå‰Šé™¤ã•ã‚Œã‚‹ã¨ãã«è§£æ”¾ã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/buffer.rst:319
msgid ""
"Create a memoryview object to a contiguous chunk of memory (in either 'C' or"
" 'F'ortran *order*) from an object that defines the buffer interface. If "
"memory is contiguous, the memoryview object points to the original memory. "
"Otherwise copy is made and the memoryview points to a new bytes object."
msgstr "buffer ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®šç¾©ã—ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ ('C' ã‹ 'F'ortran ã® *order* ã§) é€£ç¶šã—ãŸãƒ¡ãƒ¢ãƒªãƒãƒ£ãƒ³ã‚¯ã¸ã® memoryview ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã‚Šã¾ã™ã€‚ãƒ¡ãƒ¢ãƒªãŒé€£ç¶šã—ã¦ã„ã‚‹å ´åˆã€ memoryview ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å…ƒã®ãƒ¡ãƒ¢ãƒªã‚’å‚ç…§ã—ã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã€ãƒ¡ãƒ¢ãƒªã¯ã‚³ãƒ”ãƒ¼ã•ã‚Œã¦ã€ memoryview ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ–°ã—ã„ bytes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‚ç…§ã—ã¾ã™ã€‚"

#: ../../c-api/buffer.rst:328
msgid ""
"Return true if the object *obj* is a memoryview object.  It is not currently"
" allowed to create subclasses of :class:`memoryview`."
msgstr "*obj* ãŒ memoryview ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã«çœŸã‚’è¿”ã—ã¾ã™ã€‚ç¾åœ¨ã®ã¨ã“ã‚ã€ :class:`memoryview` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã®ä½œæˆã¯è¨±å¯ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"

#: ../../c-api/buffer.rst:334
msgid ""
"Return a pointer to the buffer-info structure wrapped by the given object.  "
"The object **must** be a memoryview instance; this macro doesn't check its "
"type, you must do it yourself or you will risk crashes."
msgstr "ä¸ãˆã‚‰ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãƒ©ãƒƒãƒ—ã•ã‚ŒãŸ buffer-info æ§‹é€ ä½“ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ memoryview ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ **ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“** ã€‚ã“ã®ãƒã‚¯ãƒ­ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ãªã„ã®ã§ã€å‘¼ã³å‡ºã—å´ã§ä¿è¨¼ã—ãªã‘ã‚Œã°ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../c-api/buffer.rst:340
msgid "Old-style buffer objects"
msgstr "æ—§ã‚¹ã‚¿ã‚¤ãƒ«ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../c-api/buffer.rst:344
msgid ""
"More information on the old buffer interface is provided in the section :ref"
":`buffer-structs`, under the description for :c:type:`PyBufferProcs`."
msgstr "å¤ã„ãƒãƒƒãƒ•ã‚¡ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã«é–¢ã™ã‚‹ã‚ˆã‚Šè©³ã—ã„æƒ…å ±ã¯ã€ \"ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ ä½“\" ç¯€ ( :ref:`buffer-structs` ç¯€) ã®ã€ :c:type:`PyBufferProcs` ã®èª¬æ˜ã®ã¨ã“ã‚ã«ã‚ã‚Šã¾ã™ã€‚"

#: ../../c-api/buffer.rst:347
msgid ""
"A \"buffer object\" is defined in the :file:`bufferobject.h` header "
"(included by :file:`Python.h`). These objects look very similar to string "
"objects at the Python programming level: they support slicing, indexing, "
"concatenation, and some other standard string operations. However, their "
"data can come from one of two sources: from a block of memory, or from "
"another object which exports the buffer interface."
msgstr "\"ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ\" ã¯ãƒ˜ãƒƒãƒ€ãƒ•ã‚¡ã‚¤ãƒ« :file:`bufferobject.h` ã®ä¸­ã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ (ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ :file:`Python.h` ãŒã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ã—ã¦ã„ã¾ã™)ã€‚ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ Python ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®ãƒ¬ãƒ™ãƒ«ã‹ã‚‰ã¯æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨éå¸¸ã«ã‚ˆãä¼¼ã¦ã„ã‚‹ã‚ˆã†ã«è¦‹ãˆã¾ã™: ã‚¹ãƒ©ã‚¤ã‚¹ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æŒ‡å®šã€çµåˆã€ãã®ä»–æ¨™æº–ã®æ–‡å­—åˆ—æ“ä½œã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ã—ã‹ã—ã€ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ãƒ¼ã‚¿ã¯äºŒã¤ã®ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹: ä½•ã‚‰ã‹ã®ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‹ã€ãƒãƒƒãƒ•ã‚¡ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å…¬é–‹ã—ã¦ã„ã‚‹åˆ¥ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ã®ã„ãšã‚Œã‹ã«ç”±æ¥ã—ã¦ã„ã¾ã™ã€‚"

#: ../../c-api/buffer.rst:354
msgid ""
"Buffer objects are useful as a way to expose the data from another object's "
"buffer interface to the Python programmer. They can also be used as a zero-"
"copy slicing mechanism. Using their ability to reference a block of memory, "
"it is possible to expose any data to the Python programmer quite easily. The"
" memory could be a large, constant array in a C extension, it could be a raw"
" block of memory for manipulation before passing to an operating system "
"library, or it could be used to pass around structured data in its native, "
"in-memory format."
msgstr "ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒãƒƒãƒ•ã‚¡ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‹ã‚‰ Python ãƒ—ãƒ­ã‚°ãƒ©ãƒã«ãƒ‡ãƒ¼ã‚¿ã‚’å…¬é–‹ã™ã‚‹æ–¹æ³•ã¨ã—ã¦ä¾¿åˆ©ã§ã™ã€‚ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚¼ãƒ­ã‚³ãƒ”ãƒ¼ãªã‚¹ãƒ©ã‚¤ã‚¹æ©Ÿæ§‹ (zero-copy slicing mechanism) ã¨ã—ã¦ã‚‚ä½¿ã‚ã‚Œã¾ã™ã€‚ãƒ–ãƒ­ãƒƒã‚¯ãƒ¡ãƒ¢ãƒªã‚’å‚ç…§ã™ã‚‹ã¨ã„ã†ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ©Ÿèƒ½ã‚’ä½¿ã†ã“ã¨ã§ã€ä»»æ„ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãã‚ã‚ã¦ç°¡å˜ã« Python ãƒ—ãƒ­ã‚°ãƒ©ãƒã«å…¬é–‹ã§ãã¾ã™ã€‚ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã¯å·¨å¤§ã§ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã—ã€C æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã®å®šæ•°é…åˆ—ã§ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚ã¾ãŸã€ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå´ã«æ¸¡ã™å‰ã®ã€æ“ä½œç”¨ã®ç”Ÿã®ãƒ–ãƒ­ãƒƒã‚¯ãƒ¡ãƒ¢ãƒªã§ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã—ã€æ§‹é€ åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’ãƒã‚¤ãƒ†ã‚£ãƒ–ã®ãƒ¡ãƒ¢ãƒªé…ç½®å½¢å¼ã§ã‚„ã‚Šã¨ã‚Šã™ã‚‹ãŸã‚ã«ã‚‚ä½¿ãˆã¾ã™ã€‚"

#: ../../c-api/buffer.rst:366
msgid "This subtype of :c:type:`PyObject` represents a buffer object."
msgstr "ã“ã® :c:type:`PyObject` ã®ã‚µãƒ–ã‚¿ã‚¤ãƒ—ã¯ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¡¨ç¾ã—ã¾ã™ã€‚"

#: ../../c-api/buffer.rst:373
msgid ""
"The instance of :c:type:`PyTypeObject` which represents the Python buffer "
"type; it is the same object as ``buffer`` and  ``types.BufferType`` in the "
"Python layer. ."
msgstr "Python ãƒãƒƒãƒ•ã‚¡å‹ (buffer type) ã‚’è¡¨ç¾ã™ã‚‹ :c:type:`PyTypeObject` ã§ã™; Python ãƒ¬ã‚¤ãƒ¤ã«ãŠã‘ã‚‹ ``buffer`` ã‚„ ``types.BufferType`` ã¨åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚"

#: ../../c-api/buffer.rst:380
msgid ""
"This constant may be passed as the *size* parameter to "
":c:func:`PyBuffer_FromObject` or :c:func:`PyBuffer_FromReadWriteObject`.  It"
" indicates that the new :c:type:`PyBufferObject` should refer to *base* "
"object from the specified *offset* to the end of its exported buffer. Using "
"this enables the caller to avoid querying the *base* object for its length."
msgstr "ã“ã®å®šæ•°ã¯ã€ :c:func:`PyBuffer_FromObject` ã‚„ :c:func:`PyBuffer_FromReadWriteObject` ã« *size* ãƒ‘ãƒ©ãƒ¡ã‚¿ã¨ã—ã¦æ¸¡ã—ã¾ã™ã€‚ã“ã®ãƒ‘ãƒ©ãƒ¡ã‚¿ã‚’æ¸¡ã™ã¨ã€ :c:type:`PyBufferObject` ã¯æŒ‡å®šã•ã‚ŒãŸ *offset* ã‹ã‚‰ãƒãƒƒãƒ•ã‚¡ã®çµ‚ã‚ã‚Šã¾ã§ã‚’ *base* ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦å‚ç…§ã—ã¾ã™ã€‚ã“ã®ãƒ‘ãƒ©ãƒ¡ã‚¿ã‚’ä½¿ã†ã“ã¨ã§ã€é–¢æ•°ã®å‘¼ã³å‡ºã—å´ãŒ *base* ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚µã‚¤ã‚ºã‚’èª¿ã¹ã‚‹å¿…è¦ãŒãªããªã‚Šã¾ã™ã€‚"

#: ../../c-api/buffer.rst:390
msgid "Return true if the argument has type :c:data:`PyBuffer_Type`."
msgstr "å¼•æ•°ãŒ :c:data:`PyBuffer_Type` å‹ã®ã¨ãã«çœŸã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/buffer.rst:395
msgid ""
"Return a new read-only buffer object.  This raises :exc:`TypeError` if "
"*base* doesn't support the read-only buffer protocol or doesn't provide "
"exactly one buffer segment, or it raises :exc:`ValueError` if *offset* is "
"less than zero.  The buffer will hold a reference to the *base* object, and "
"the buffer's contents will refer to the *base* object's buffer interface, "
"starting as position *offset* and extending for *size* bytes. If *size* is "
":const:`Py_END_OF_BUFFER`, then the new buffer's contents extend to the "
"length of the *base* object's exported buffer data."
msgstr "æ–°ãŸãªèª­ã¿å‡ºã—å°‚ç”¨ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ *base* ãŒèª­ã¿å‡ºã—å°‚ç”¨ãƒãƒƒãƒ•ã‚¡ã«å¿…è¦ãªãƒãƒƒãƒ•ã‚¡ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„å ´åˆã‚„ã€å³å¯†ã«ä¸€ã¤ã®ãƒãƒƒãƒ•ã‚¡ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’æä¾›ã—ã¦ã„ãªã„å ´åˆã«ã¯ :exc:`TypeError` ã‚’é€å‡ºã—ã€ *offset* ãŒã‚¼ãƒ­ä»¥ä¸‹ã®å ´åˆã«ã¯ :exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ *base* ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹å‚ç…§ã‚’ä¿æŒã—ã€ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å†…å®¹ã¯ *base* ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® *offset* ã‹ã‚‰ *size* ãƒã‚¤ãƒˆã®ãƒãƒƒãƒ•ã‚¡ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã¸ã®å‚ç…§ã«ãªã‚Šã¾ã™ã€‚ *size* ãŒ :const:`Py_END_OF_BUFFER` ã®å ´åˆã€æ–°ãŸã«ä½œæˆã™ã‚‹ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å†…å®¹ã¯ *base* ã‹ã‚‰å…¬é–‹ã•ã‚Œã¦ã„ã‚‹ãƒãƒƒãƒ•ã‚¡ã®æœ«å°¾ã¾ã§ã«ã‚ãŸã‚Šã¾ã™ã€‚"

#: ../../c-api/buffer.rst:404 ../../c-api/buffer.rst:416
msgid ""
"This function used an :c:type:`int` type for *offset* and *size*. This might"
" require changes in your code for properly supporting 64-bit systems."
msgstr "ã“ã®é–¢æ•°ã¯ä»¥å‰ã¯ *offset*, *size* ã®å‹ã« :c:type:`int` ã‚’åˆ©ç”¨ã—ã¦ã„ã¾ã—ãŸã€‚ã“ã®å¤‰æ›´ã«ã‚ˆã‚Šã€ 64bit ã‚·ã‚¹ãƒ†ãƒ ã‚’æ­£ã—ãã‚µãƒãƒ¼ãƒˆã™ã‚‹ã«ã¯ä¿®æ­£ãŒå¿…è¦ã«ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/buffer.rst:412
msgid ""
"Return a new writable buffer object.  Parameters and exceptions are similar "
"to those for :c:func:`PyBuffer_FromObject`.  If the *base* object does not "
"export the writeable buffer protocol, then :exc:`TypeError` is raised."
msgstr "æ–°ãŸãªæ›¸ãè¾¼ã¿å¯èƒ½ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ãƒ‘ãƒ©ãƒ¡ã‚¿ãŠã‚ˆã³ä¾‹å¤–ã¯ :c:func:`PyBuffer_FromObject` ã¨åŒã˜ã§ã™ã€‚ *base* ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ›¸ãè¾¼ã¿å¯èƒ½ãƒãƒƒãƒ•ã‚¡ã«å¿…è¦ãªãƒãƒƒãƒ•ã‚¡ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’å…¬é–‹ã—ã¦ã„ãªã„å ´åˆã€ :exc:`TypeError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../c-api/buffer.rst:424
msgid ""
"Return a new read-only buffer object that reads from a specified location in"
" memory, with a specified size.  The caller is responsible for ensuring that"
" the memory buffer, passed in as *ptr*, is not deallocated while the "
"returned buffer object exists.  Raises :exc:`ValueError` if *size* is less "
"than zero.  Note that :const:`Py_END_OF_BUFFER` may *not* be passed for the "
"*size* parameter; :exc:`ValueError` will be raised in that case."
msgstr "ãƒ¡ãƒ¢ãƒªä¸Šã®æŒ‡å®šã•ã‚ŒãŸå ´æ‰€ã‹ã‚‰æŒ‡å®šã•ã‚ŒãŸã‚µã‚¤ã‚ºã®ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿å‡ºã›ã‚‹ã€æ–°ãŸãªèª­ã¿å‡ºã—å°‚ç”¨ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ãŒè¿”ã™ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå­˜ç¶šã™ã‚‹é–“ã€ *ptr* ã§ä¸ãˆã‚‰ã‚ŒãŸãƒ¡ãƒ¢ãƒªãƒãƒƒãƒ•ã‚¡ãŒãƒ‡ã‚¢ãƒ­ã‚±ãƒ¼ãƒˆã•ã‚Œãªã„ã‚ˆã†ã«ã™ã‚‹ã®ã¯å‘¼ã³å‡ºã—å´ã®è²¬ä»»ã§ã™ã€‚ *size* ãŒã‚¼ãƒ­ä»¥ä¸‹ã®å ´åˆã«ã¯ :exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚ *size* ã«ã¯ :const:`Py_END_OF_BUFFER` ã‚’æŒ‡å®šã—ã¦ã¯ *ã„ã‘ã¾ã›ã‚“* ; æŒ‡å®šã™ã‚‹ã¨ã€ :exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../c-api/buffer.rst:431 ../../c-api/buffer.rst:441
#: ../../c-api/buffer.rst:453
msgid ""
"This function used an :c:type:`int` type for *size*. This might require "
"changes in your code for properly supporting 64-bit systems."
msgstr "ã“ã®é–¢æ•°ã¯ä»¥å‰ã¯ *size* ã®å‹ã« :c:type:`int` ã‚’åˆ©ç”¨ã—ã¦ã„ã¾ã—ãŸã€‚ã“ã®å¤‰æ›´ã«ã‚ˆã‚Šã€ 64bit ã‚·ã‚¹ãƒ†ãƒ ã‚’æ­£ã—ãã‚µãƒãƒ¼ãƒˆã™ã‚‹ã«ã¯ä¿®æ­£ãŒå¿…è¦ã«ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/buffer.rst:438
msgid ""
"Similar to :c:func:`PyBuffer_FromMemory`, but the returned buffer is "
"writable."
msgstr ":c:func:`PyBuffer_FromMemory` ã«ä¼¼ã¦ã„ã¾ã™ãŒã€æ›¸ãè¾¼ã¿å¯èƒ½ãªãƒãƒƒãƒ•ã‚¡ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/buffer.rst:448
msgid ""
"Return a new writable buffer object that maintains its own memory buffer of "
"*size* bytes.  :exc:`ValueError` is returned if *size* is not zero or "
"positive.  Note that the memory buffer (as returned by "
":c:func:`PyObject_AsWriteBuffer`) is not specifically aligned."
msgstr "*size* ãƒã‚¤ãƒˆã®ãƒ¡ãƒ¢ãƒªãƒãƒƒãƒ•ã‚¡ã‚’ç‹¬è‡ªã«ç¶­æŒã™ã‚‹æ–°ãŸãªæ›¸ãè¾¼ã¿å¯èƒ½ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ *size* ãŒã‚¼ãƒ­ã¾ãŸã¯æ­£ã®å€¤ã§ãªã„å ´åˆã€ :exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚( :c:func:`PyObject_AsWriteBuffer` ãŒè¿”ã™ã‚ˆã†ãª) ãƒ¡ãƒ¢ãƒªãƒãƒƒãƒ•ã‚¡ã¯ç‰¹ã«æ•´åˆ—ã•ã‚Œã¦ã„ãªã„ã®ã§æ³¨æ„ã—ã¦ä¸‹ã•ã„ã€‚"
