# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2017
# E. Kawashima, 2017
# Arihiro TAKASE, 2017
# Naoki INADA <songofacandy@gmail.com>, 2017
# tomoğŸ§, 2017
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-30 05:56+0900\n"
"PO-Revision-Date: 2017-02-16 17:37+0000\n"
"Last-Translator: tomoğŸ§, 2017\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/module.rst:6
msgid "Module Objects"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (module object)"

#: ../../c-api/module.rst:15
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python module type.  "
"This is exposed to Python programs as ``types.ModuleType``."
msgstr ""
"ã“ã® :c:type:`PyTypeObject` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ Python "
"ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã‚’è¡¨ç¾ã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€Python ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã¯ ``types.ModuleType``  "
"ã¨ã—ã¦å…¬é–‹ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../c-api/module.rst:21
msgid ""
"Return true if *p* is a module object, or a subtype of a module object."
msgstr "*p* ãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚µãƒ–ã‚¿ã‚¤ãƒ—ã§ã‚ã‚‹ã¨ãã«çœŸã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/module.rst:26
msgid ""
"Return true if *p* is a module object, but not a subtype of "
":c:data:`PyModule_Type`."
msgstr ""
"*p* ãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã€ã‹ã¤ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚µãƒ–ã‚¿ã‚¤ãƒ—ã§ãªã„ã¨ãã«çœŸã‚’è¿”ã—ã¾ã™ã€‚ :c:data:`PyModule_Type`."

#: ../../c-api/module.rst:39
msgid ""
"Return a new module object with the :attr:`__name__` attribute set to "
"*name*. The module's :attr:`__name__`, :attr:`__doc__`, :attr:`__package__`,"
" and :attr:`__loader__` attributes are filled in (all but :attr:`__name__` "
"are set to ``None``); the caller is responsible for providing a "
":attr:`__file__` attribute."
msgstr ""
":attr:`__name__` å±æ€§ã« *name* ãŒè¨­å®šã•ã‚ŒãŸæ–°ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚\n"
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® :attr:`__name__`, :attr:`__doc__`, :attr:`__package__`, :attr:`__loader__` å±æ€§ã«å€¤ãŒå…¥ã£ã¦ã„ã¾ã™ (:attr:`__name__` ä»¥å¤–ã¯å…¨ã¦ ``None`` ã§ã™);\n"
":attr:`__file__` å±æ€§ã«å€¤ã‚’å…¥ã‚Œã‚‹ã®ã¯å‘¼ã³å‡ºã—å´ã®è²¬ä»»ã§ã™ã€‚"

#: ../../c-api/module.rst:47
msgid ":attr:`__package__` and :attr:`__loader__` are set to ``None``."
msgstr ":attr:`__package__` ã¨ :attr:`__loader__` ã¯ ``None`` ã«è¨­å®šã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/module.rst:53
msgid ""
"Similar to :c:func:`PyModule_NewObject`, but the name is a UTF-8 encoded "
"string instead of a Unicode object."
msgstr ""

#: ../../c-api/module.rst:61
msgid ""
"Return the dictionary object that implements *module*'s namespace; this "
"object is the same as the :attr:`~object.__dict__` attribute of the module "
"object. If *module* is not a module object (or a subtype of a module "
"object), :exc:`SystemError` is raised and *NULL* is returned."
msgstr ""
"*module* ã®åå‰ç©ºé–“ã‚’å®Ÿè£…ã™ã‚‹è¾æ›¸ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™;\n"
"ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :attr:`~object.__dict__` å±æ€§ã¨åŒã˜ã‚‚ã®ã§ã™ã€‚\n"
"*module* ãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (ã‚‚ã—ãã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚µãƒ–ã‚¿ã‚¤ãƒ—) ã§ãªã„å ´åˆã¯ã€ :exc:`SystemError` ãŒé€å‡ºã•ã‚Œ *NULL* ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/module.rst:66
msgid ""
"It is recommended extensions use other :c:func:`PyModule_\\*` and "
":c:func:`PyObject_\\*` functions rather than directly manipulate a module's "
":attr:`~object.__dict__`."
msgstr ""
"æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® :attr:`~object.__dict__` ã‚’ç›´æ¥æ“ä½œã™ã‚‹ã‚ˆã‚Šã‚‚ã€ :c:func:`PyModule_\\*`"
" ãŠã‚ˆã³ :c:func:`PyObject_\\*` é–¢æ•°ã‚’ä½¿ã†æ–¹ãŒæ¨å¥¨ã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/module.rst:77
msgid ""
"Return *module*'s :attr:`__name__` value.  If the module does not provide "
"one, or if it is not a string, :exc:`SystemError` is raised and *NULL* is "
"returned."
msgstr ""
"*module* ã® :attr:`__name__` ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã“ã®å±æ€§ã‚’æä¾›ã—ã¦ã„ãªã„å ´åˆã‚„æ–‡å­—åˆ—å‹ã§ãªã„å ´åˆã€ "
":exc:`SystemError` ã‚’é€å‡ºã—ã¦ *NULL* ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/module.rst:85
msgid ""
"Similar to :c:func:`PyModule_GetNameObject` but return the name encoded to "
"``'utf-8'``."
msgstr ""
":c:func:`PyModule_GetNameObject` ã«ä¼¼ã¦ã„ã¾ã™ãŒã€ ``'utf-8'`` ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸ name ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/module.rst:90
msgid ""
"Return the \"state\" of the module, that is, a pointer to the block of "
"memory allocated at module creation time, or *NULL*.  See "
":c:member:`PyModuleDef.m_size`."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® \"state\"(ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç”Ÿæˆã—ãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ç¢ºä¿ã•ã‚Œã‚‹ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼) ã‹ã€ãªã‘ã‚Œã° *NULL* ã‚’è¿”ã—ã¾ã™ã€‚ "
":c:member:`PyModuleDef.m_size` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../c-api/module.rst:97
msgid ""
"Return a pointer to the :c:type:`PyModuleDef` struct from which the module "
"was created, or *NULL* if the module wasn't created from a definition."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒä½œã‚‰ã‚Œã‚‹å…ƒã¨ãªã£ãŸ :c:type:`PyModuleDef` æ§‹é€ ä½“ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚\n"
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå®šç¾©ã«ã‚ˆã£ã¦ä½œã‚‰ã‚Œã¦ã„ãªã‹ã£ãŸå ´åˆã¯ *NULL* ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/module.rst:107
msgid ""
"Return the name of the file from which *module* was loaded using *module*'s "
":attr:`__file__` attribute.  If this is not defined, or if it is not a "
"unicode string, raise :exc:`SystemError` and return *NULL*; otherwise return"
" a reference to a Unicode object."
msgstr ""
"*module* ã® :attr:`__file__` å±æ€§ã‚’ã‚‚ã¨ã« *module* "
"ãŒãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸã‚‚ã¨ã®ãƒ•ã‚¡ã‚¤ãƒ«åã‚’è¿”ã—ã¾ã™ã€‚ã‚‚ã—ãƒ•ã‚¡ã‚¤ãƒ«åãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã‚„ã€ Unicode æ–‡å­—åˆ—ã§ã¯ãªã„å ´åˆã€ "
":exc:`SystemError` ã‚’ç™ºç”Ÿã•ã›ã¦ *NULL* ã‚’è¿”ã—ã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/module.rst:117
msgid ""
"Similar to :c:func:`PyModule_GetFilenameObject` but return the filename "
"encoded to 'utf-8'."
msgstr ""
":c:func:`PyModule_GetFilenameObject` ã¨ä¼¼ã¦ã„ã¾ã™ãŒã€ 'utf-8' ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«åã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/module.rst:120
msgid ""
":c:func:`PyModule_GetFilename` raises :c:type:`UnicodeEncodeError` on "
"unencodable filenames, use :c:func:`PyModule_GetFilenameObject` instead."
msgstr ""
":c:func:`PyModule_GetFilename` ã¯ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã§ããªã„ãƒ•ã‚¡ã‚¤ãƒ«åã«å¯¾ã—ã¦ã¯ "
":c:type:`UnicodeEncodeError` ã‚’é€å‡ºã—ã¾ã™ã€‚ã“ã‚Œã®ä»£ã‚ã‚Šã« "
":c:func:`PyModule_GetFilenameObject` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../c-api/module.rst:128
msgid "Initializing C modules"
msgstr "Cãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åˆæœŸåŒ–"

#: ../../c-api/module.rst:130
msgid ""
"Modules objects are usually created from extension modules (shared libraries"
" which export an initialization function), or compiled-in modules (where the"
" initialization function is added using :c:func:`PyImport_AppendInittab`). "
"See :ref:`building` or :ref:`extending-with-embedding` for details."
msgstr ""
"é€šå¸¸ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« (åˆæœŸåŒ–é–¢æ•°ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒª) ã¾ãŸã¯çµ„ã¿è¾¼ã¾ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« (:c:func:`PyImport_AppendInittab` ã‚’ä½¿ã£ã¦åˆæœŸåŒ–é–¢æ•°ãŒè¿½åŠ ã•ã‚Œã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«) ã‹ã‚‰ä½œã‚‰ã‚Œã¾ã™ã€‚\n"
"è©³ç´°ã«ã¤ã„ã¦ã¯ :ref:`building` ã¾ãŸã¯ :ref:`extending-with-embedding` ã‚’è¦‹ã¦ãã ã•ã„ã€‚"

#: ../../c-api/module.rst:135
msgid ""
"The initialization function can either pass a module definition instance to "
":c:func:`PyModule_Create`, and return the resulting module object, or "
"request \"multi-phase initialization\" by returning the definition struct "
"itself."
msgstr ""
"åˆæœŸåŒ–é–¢æ•°ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®šç¾©ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ :c:func:`PyModule_Create` "
"ã«æ¸¡ã—ã¦å‡ºæ¥ä¸ŠãŒã£ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¦ã‚‚ã‚ˆã„ã§ã™ã—ã€ã‚‚ã—ãã¯å®šç¾©æ§‹é€ ä½“ãã®ã‚‚ã®ã‚’è¿”ã—\"å¤šæ®µéšåˆæœŸåŒ–\"ã‚’è¦æ±‚ã—ã¦ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚"

#: ../../c-api/module.rst:141
msgid ""
"The module definition struct, which holds all information needed to create a"
" module object. There is usually only one statically initialized variable of"
" this type for each module."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®šç¾©æ§‹é€ ä½“ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã™ã‚‹ã®ã«å¿…è¦ãªã™ã¹ã¦ã®æƒ…å ±ã‚’ä¿æŒã—ã¾ã™ã€‚\n"
"é€šå¸¸ã¯ã€ãã‚Œãã‚Œã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã”ã¨ã«é™çš„ã«åˆæœŸåŒ–ã•ã‚ŒãŸã“ã®å‹ã®å¤‰æ•°ãŒ1ã¤ã ã‘å­˜åœ¨ã—ã¾ã™ã€‚"

#: ../../c-api/module.rst:147
msgid "Always initialize this member to :const:`PyModuleDef_HEAD_INIT`."
msgstr "ã“ã®ãƒ¡ãƒ³ãƒãƒ¼ã¯å¸¸ã« :const:`PyModuleDef_HEAD_INIT` ã§åˆæœŸåŒ–ã—ã¦ãã ã•ã„ã€‚"

#: ../../c-api/module.rst:151
msgid "Name for the new module."
msgstr "æ–°ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ã€‚"

#: ../../c-api/module.rst:155
msgid ""
"Docstring for the module; usually a docstring variable created with "
":c:func:`PyDoc_STRVAR` is used."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® docstringã€‚ãŸã„ã¦ã„ docstring ã¯ :c:func:`PyDoc_STRVAR` ã‚’åˆ©ç”¨ã—ã¦ç”Ÿæˆã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/module.rst:160
msgid ""
"Module state may be kept in a per-module memory area that can be retrieved "
"with :c:func:`PyModule_GetState`, rather than in static globals. This makes "
"modules safe for use in multiple sub-interpreters."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®çŠ¶æ…‹ã¯ã€é™çš„ãªã‚°ãƒ­ãƒ¼ãƒãƒ«ãªé ˜åŸŸã§ã¯ãªã :c:func:`PyModule_GetState` ã§å–å¾—ã§ãã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã”ã¨ã®ãƒ¡ãƒ¢ãƒªé ˜åŸŸã«ä¿æŒã•ã‚Œã¦ã„ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚\n"
"ã“ã‚Œã«ã‚ˆã£ã¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯è¤‡æ•°ã®ã‚µãƒ–ãƒ»ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãƒ¼ã§å®‰å…¨ã«ä½¿ãˆã¾ã™ã€‚"

#: ../../c-api/module.rst:164
msgid ""
"This memory area is allocated based on *m_size* on module creation, and "
"freed when the module object is deallocated, after the :c:member:`m_free` "
"function has been called, if present."
msgstr ""
"ã“ã®ãƒ¡ãƒ¢ãƒªé ˜åŸŸã¯ *m_size* ã«åŸºã¥ã„ã¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä½œæˆæ™‚ã«ç¢ºä¿ã•ã‚Œã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç ´æ£„ã•ã‚Œã‚‹ã¨ãã«ã€ "
":c:member:`m_free` é–¢æ•°ãŒã‚ã‚Œã°ãã‚ŒãŒå‘¼ã°ã‚ŒãŸå¾Œã§è§£æ”¾ã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/module.rst:168
msgid ""
"Setting ``m_size`` to ``-1`` means that the module does not support sub-"
"interpreters, because it has global state."
msgstr ""
"``m_size`` ã« ``-1`` "
"ã‚’è¨­å®šã™ã‚‹ã¨ã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªçŠ¶æ…‹ã‚’æŒã¤ãŸã‚ã«ã‚µãƒ–ãƒ»ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„ã¨ã„ã†ã“ã¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/module.rst:171
msgid ""
"Setting it to a non-negative value means that the module can be re-"
"initialized and specifies the additional amount of memory it requires for "
"its state. Non-negative ``m_size`` is required for multi-phase "
"initialization."
msgstr ""
"``m_size`` ã‚’éè² ã®å€¤ã«è¨­å®šã™ã‚‹ã¨ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯å†åˆæœŸåŒ–ã§ãã€ãã®çŠ¶æ…‹ã®ãŸã‚ã«å¿…è¦ã¨ãªã‚‹è¿½åŠ ã®ãƒ¡ãƒ¢ãƒªé‡ã‚’æŒ‡å®šã§ãã‚‹ã¨ã„ã†ã“ã¨ã«ãªã‚Šã¾ã™ã€‚\n"
"éè² ã® ``m_size`` ã¯å¤šæ®µéšåˆæœŸåŒ–ã§å¿…è¦ã«ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/module.rst:176
msgid "See :PEP:`3121` for more details."
msgstr "è©³ç´°ã¯ :PEP:`3121` ã‚’å‚ç…§ã€‚"

#: ../../c-api/module.rst:180
msgid ""
"A pointer to a table of module-level functions, described by "
":c:type:`PyMethodDef` values.  Can be *NULL* if no functions are present."
msgstr ""
":c:type:`PyMethodDef` ã§å®šç¾©ã•ã‚Œã‚‹ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«é–¢æ•°ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚é–¢æ•°ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ *NULL* "
"ã‚’è¨­å®šã™ã‚‹ã“ã¨ãŒå¯èƒ½ã€‚"

#: ../../c-api/module.rst:185
msgid ""
"An array of slot definitions for multi-phase initialization, terminated by a"
" ``{0, NULL}`` entry. When using single-phase initialization, *m_slots* must"
" be *NULL*."
msgstr ""
"å¤šæ®µéšåˆæœŸåŒ–ã®ãŸã‚ã®ã‚¹ãƒ­ãƒƒãƒˆå®šç¾©ã®é…åˆ—ã§ã€ ``{0, NULL}`` è¦ç´ ãŒçµ‚ç«¯ã¨ãªã‚Šã¾ã™ã€‚\n"
"ä¸€æ®µéšåˆæœŸåŒ–ã‚’ä½¿ã†ã¨ãã¯ã€ *m_slots* ã¯ *NULL* ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/module.rst:191
msgid ""
"Prior to version 3.5, this member was always set to *NULL*, and was defined "
"as:"
msgstr "ãƒãƒ¼ã‚¸ãƒ§ãƒ³ 3.5 ã‚ˆã‚Šå‰ã¯ã€ã“ã®ãƒ¡ãƒ³ãƒã¯å¸¸ã« *NULL* ã«è¨­å®šã•ã‚Œã¦ã„ã¦ã€æ¬¡ã®ã‚‚ã®ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã¾ã—ãŸ:"

#: ../../c-api/module.rst:198
msgid ""
"A traversal function to call during GC traversal of the module object, or "
"*NULL* if not needed. This function may be called before module state is "
"allocated (:c:func:`PyModule_GetState()` may return `NULL`), and before the "
":c:member:`Py_mod_exec` function is executed."
msgstr ""

#: ../../c-api/module.rst:205
msgid ""
"A clear function to call during GC clearing of the module object, or *NULL* "
"if not needed. This function may be called before module state is allocated "
"(:c:func:`PyModule_GetState()` may return `NULL`), and before the "
":c:member:`Py_mod_exec` function is executed."
msgstr ""

#: ../../c-api/module.rst:212
msgid ""
"A function to call during deallocation of the module object, or *NULL* if "
"not needed. This function may be called before module state is allocated "
"(:c:func:`PyModule_GetState()` may return `NULL`), and before the "
":c:member:`Py_mod_exec` function is executed."
msgstr ""

#: ../../c-api/module.rst:218
msgid "Single-phase initialization"
msgstr "ä¸€æ®µéšåˆæœŸåŒ–"

#: ../../c-api/module.rst:220
msgid ""
"The module initialization function may create and return the module object "
"directly. This is referred to as \"single-phase initialization\", and uses "
"one of the following two module creation functions:"
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åˆæœŸåŒ–é–¢æ•°ãŒç›´æ¥ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã—ã¦è¿”ã™å ´åˆãŒã‚ã‚Šã¾ã™ã€‚\n"
"ã“ã‚Œã¯\"ä¸€æ®µéšåˆæœŸåŒ–\"ã¨å‘¼ã°ã‚Œã€æ¬¡ã®2ã¤ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ç”Ÿæˆé–¢æ•°ã®ã©ã¡ã‚‰ã‹1ã¤ã‚’ä½¿ã„ã¾ã™:"

#: ../../c-api/module.rst:226
msgid ""
"Create a new module object, given the definition in *def*.  This behaves "
"like :c:func:`PyModule_Create2` with *module_api_version* set to "
":const:`PYTHON_API_VERSION`."
msgstr ""
"*def* ã§ã®å®šç¾©ã«å¾“ã£ã¦æ–°ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã—ã¾ã™ã€‚\n"
"ã“ã‚Œã¯ :c:func:`PyModule_Create2` ã® *module_api_version* ã« :const:`PYTHON_API_VERSION` ã‚’è¨­å®šã—ãŸã¨ãã®ã‚ˆã†ã«æŒ¯ã‚‹èˆã„ã¾ã™ã€‚"

#: ../../c-api/module.rst:233
msgid ""
"Create a new module object, given the definition in *def*, assuming the API "
"version *module_api_version*.  If that version does not match the version of"
" the running interpreter, a :exc:`RuntimeWarning` is emitted."
msgstr ""
"APIãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ *module_api_version* ã¨ã—ã¦ *def* ã§ã®å®šç¾©ã«å¾“ã£ã¦æ–°ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã—ã¾ã™ã€‚\n"
"ã‚‚ã—æŒ‡å®šã•ã‚ŒãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒå®Ÿè¡Œã—ã¦ã„ã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ç•°ãªã‚‹å ´åˆã¯ã€ :exc:`RuntimeWarning` ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚"

#: ../../c-api/module.rst:239
msgid ""
"Most uses of this function should be using :c:func:`PyModule_Create` "
"instead; only use this if you are sure you need it."
msgstr ""
"ã»ã¨ã‚“ã©ã®å ´åˆã€ã“ã®é–¢æ•°ã§ã¯ãªã :c:func:`PyModule_Create` "
"ã‚’åˆ©ç”¨ã™ã‚‹ã¹ãã§ã™ã€‚ã“ã®é–¢æ•°ã¯ã€ã“ã®é–¢æ•°ã®å¿…è¦æ€§ã‚’ç†è§£ã—ã¦ã„ã‚‹ã¨ãã«ã ã‘åˆ©ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../c-api/module.rst:242
msgid ""
"Before it is returned from in the initialization function, the resulting "
"module object is typically populated using functions like "
":c:func:`PyModule_AddObject`."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒåˆæœŸåŒ–é–¢æ•°ã‹ã‚‰è¿”ã•ã‚Œã‚‹å‰ã«ã€ãŸã„ã¦ã„ã¯ :c:func:`PyModule_AddObject` "
"ãªã©ã®é–¢æ•°ã‚’ä½¿ã£ã¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãƒ¡ãƒ³ãƒã‚’æ‰€å±ã•ã›ã¾ã™ã€‚"

#: ../../c-api/module.rst:248
msgid "Multi-phase initialization"
msgstr "å¤šæ®µéšåˆæœŸåŒ–"

#: ../../c-api/module.rst:250
msgid ""
"An alternate way to specify extensions is to request \"multi-phase "
"initialization\". Extension modules created this way behave more like Python"
" modules: the initialization is split between the *creation phase*, when the"
" module object is created, and the *execution phase*, when it is populated. "
"The distinction is similar to the :py:meth:`__new__` and :py:meth:`__init__`"
" methods of classes."
msgstr ""
"æ‹¡å¼µã‚’ç›´æ¥ç”Ÿæˆã™ã‚‹ã‚‚ã†1ã¤ã®ã‚„ã‚Šæ–¹ã¯ã€\"å¤šæ®µéšåˆæœŸåŒ–\"ã‚’è¦æ±‚ã™ã‚‹æ–¹æ³•ã§ã™ã€‚\n"
"ã“ã®æ–¹æ³•ã§ä½œã‚‰ã‚Œã‚‹æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€ã‚ˆã‚ŠPythonãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«è¿‘ã„æŒ¯ã‚‹èˆã„ã‚’ã—ã¾ã™:\n"
"åˆæœŸåŒ–å‡¦ç†ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã™ã‚‹ *ç”Ÿæˆæ®µéš* ã¨ãƒ¡ãƒ³ãƒã‚’æ‰€å±ã•ã›ã‚‹ *å®Ÿè¡Œæ®µéš* ã«åˆ†å‰²ã•ã‚Œã¾ã™ã€‚\n"
"ã“ã®åŒºåˆ¥ã¯ã‚¯ãƒ©ã‚¹ã® :py:meth:`__new__` ãƒ¡ã‚½ãƒƒãƒ‰ã¨ :py:meth:`__init__` ãƒ¡ã‚½ãƒƒãƒ‰ã«ä¼¼ã¦ã„ã¾ã™ã€‚"

#: ../../c-api/module.rst:257
msgid ""
"Unlike modules created using single-phase initialization, these modules are "
"not singletons: if the *sys.modules* entry is removed and the module is re-"
"imported, a new module object is created, and the old module is subject to "
"normal garbage collection -- as with Python modules. By default, multiple "
"modules created from the same definition should be independent: changes to "
"one should not affect the others. This means that all state should be "
"specific to the module object (using e.g. using "
":c:func:`PyModule_GetState`), or its contents (such as the module's "
":attr:`__dict__` or individual classes created with "
":c:func:`PyType_FromSpec`)."
msgstr ""
"ä¸€æ®µéšåˆæœŸåŒ–ã§ç”Ÿæˆã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨é•ã„ã€å¤šæ®µéšåˆæœŸåŒ–ã§ç”Ÿæˆã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã§ã¯ã‚ã‚Šã¾ã›ã‚“:\n"
"*sys.modules* ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãŒå‰Šé™¤ã•ã‚Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå†ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸå ´åˆã€æ–°ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç”Ÿæˆã•ã‚Œã€å¤ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯Pythonãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨åŒã˜ã‚ˆã†ã«é€šå¸¸ã®ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã§å‡¦ç†ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚\n"
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€åŒã˜å®šç¾©ã‹ã‚‰ä½œã‚‰ã‚ŒãŸè¤‡æ•°ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ç‹¬ç«‹ã§ã‚ã‚‹ã¹ãã§ã™: ã‚ã‚‹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«åŠ ãˆãŸå¤‰æ›´ã¯åˆ¥ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å½±éŸ¿ã—ã¾ã›ã‚“ã€‚\n"
"ã“ã‚Œã¯ã€(ä¾‹ãˆã° :c:func:`PyModule_GetState` ã‚’ä½¿ã£ã¦å–å¾—ã§ãã‚‹) å…¨ã¦ã®çŠ¶æ…‹ã‚„ã€(ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® :attr:`__dict__` ã‚„ :c:func:`PyType_FromSpec` ã§ç”Ÿæˆã•ã‚ŒãŸå€‹ã€…ã®ã‚¯ãƒ©ã‚¹ã®ã‚ˆã†ãª) ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«æ‰€å±ã™ã‚‹ã‚‚ã®ã¯ã€ç‰¹å®šã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç‰¹æœ‰ã®ã‚‚ã®ã§ã‚ã‚‹ã¹ãã¨ã„ã†ã“ã¨ã§ã™ã€‚"

#: ../../c-api/module.rst:267
msgid ""
"All modules created using multi-phase initialization are expected to support"
" :ref:`sub-interpreters <sub-interpreter-support>`. Making sure multiple "
"modules are independent is typically enough to achieve this."
msgstr ""
"å¤šæ®µéšåˆæœŸåŒ–ã‚’ä½¿ã£ã¦ç”Ÿæˆã•ã‚Œã‚‹å…¨ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ :ref:`ã‚µãƒ–ãƒ»ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãƒ¼ <sub-interpreter-support>` ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ãŒæ±‚ã‚ã‚‰ã‚Œã¾ã™ã€‚\n"
"è¤‡æ•°ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒç‹¬ç«‹ã—ã¦ã„ã‚‹ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ã®ã«ã¯ã€ãŸã„ã¦ã„ã¯ã“ã®ã‚µãƒãƒ¼ãƒˆã‚’ã™ã‚‹ã ã‘ã§ååˆ†ã§ã™ã€‚"

#: ../../c-api/module.rst:271
msgid ""
"To request multi-phase initialization, the initialization function "
"(PyInit_modulename) returns a :c:type:`PyModuleDef` instance with non-empty "
":c:member:`~PyModuleDef.m_slots`. Before it is returned, the ``PyModuleDef``"
" instance must be initialized with the following function:"
msgstr ""
"å¤šæ®µéšåˆæœŸåŒ–ã‚’è¦æ±‚ã™ã‚‹ãŸã‚ã«ã€åˆæœŸåŒ–é–¢æ•° (PyInit_modulename) ã¯ç©ºã§ãªã„ :c:member:`~PyModuleDef.m_slots` ã‚’æŒã¤ :c:type:`PyModuleDef` ã‚’è¿”ã—ã¾ã™ã€‚\n"
"ã“ã‚Œã‚’è¿”ã™å‰ã«ã€ ``PyModuleDef`` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯æ¬¡ã®é–¢æ•°ã§åˆæœŸåŒ–ã•ã‚Œãªãã¦ã¯ã„ã‘ã¾ã›ã‚“:"

#: ../../c-api/module.rst:278
msgid ""
"Ensures a module definition is a properly initialized Python object that "
"correctly reports its type and reference count."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®šç¾©ãŒå‹ã¨å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’æ­£ã—ãå ±å‘Šã™ã‚‹ã€é©åˆ‡ã«åˆæœŸåŒ–ã•ã‚ŒãŸ Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹ã“ã¨ä¿è¨¼ã—ã¾ã™ã€‚"

#: ../../c-api/module.rst:281
msgid "Returns *def* cast to ``PyObject*``, or *NULL* if an error occurred."
msgstr "``PyObject*`` ã«ã‚­ãƒ£ã‚¹ãƒˆã•ã‚ŒãŸ *def* ã‚’è¿”ã—ã¾ã™ã€‚ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆ *NULL* ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/module.rst:285
msgid ""
"The *m_slots* member of the module definition must point to an array of "
"``PyModuleDef_Slot`` structures:"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®šç¾©ã® *m_slots* ãƒ¡ãƒ³ãƒã¯ ``PyModuleDef_Slot`` æ§‹é€ ä½“ã®é…åˆ—ã‚’æŒ‡ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“:"

#: ../../c-api/module.rst:292
msgid "A slot ID, chosen from the available values explained below."
msgstr "ã‚¹ãƒ­ãƒƒãƒˆ ID ã§ã€ä»¥ä¸‹ã§èª¬æ˜ã•ã‚Œã¦ã„ã‚‹åˆ©ç”¨å¯èƒ½ãªå€¤ã‹ã‚‰é¸ã°ã‚Œã¾ã™ã€‚"

#: ../../c-api/module.rst:296
msgid "Value of the slot, whose meaning depends on the slot ID."
msgstr "ã‚¹ãƒ­ãƒƒãƒˆã®å€¤ã§ã€æ„å‘³ã¯ã‚¹ãƒ­ãƒƒãƒˆ ID ã«ä¾å­˜ã—ã¾ã™ã€‚"

#: ../../c-api/module.rst:300
msgid "The *m_slots* array must be terminated by a slot with id 0."
msgstr "*m_slots* é…åˆ—ã¯ID 0 ã®ã‚¹ãƒ­ãƒƒãƒˆã§çµ‚ç«¯ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/module.rst:302
msgid "The available slot types are:"
msgstr "åˆ©ç”¨å¯èƒ½ãªã‚¹ãƒ­ãƒƒãƒˆã®å‹ã¯ä»¥ä¸‹ã§ã™:"

#: ../../c-api/module.rst:306
msgid ""
"Specifies a function that is called to create the module object itself. The "
"*value* pointer of this slot must point to a function of the signature:"
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªèº«ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã«å‘¼ã°ã‚Œã‚‹é–¢æ•°ã‚’æŒ‡å®šã—ã¾ã™ã€‚\n"
"ã“ã®ã‚¹ãƒ­ãƒƒãƒˆã® *value* ãƒã‚¤ãƒ³ã‚¿ã¯æ¬¡ã®ã‚·ã‚°ãƒãƒãƒ£ã‚’æŒã¤é–¢æ•°ã‚’æŒ‡ã—ã¦ã„ãªãã¦ã¯ã„ã‘ã¾ã›ã‚“:"

#: ../../c-api/module.rst:311
msgid ""
"The function receives a :py:class:`~importlib.machinery.ModuleSpec` "
"instance, as defined in :PEP:`451`, and the module definition. It should "
"return a new module object, or set an error and return *NULL*."
msgstr ""
":PEP:`451` ã§å®šç¾©ã•ã‚ŒãŸ :py:class:`~importlib.machinery.ModuleSpec` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®šç¾©ã‚’å—ã‘å–ã‚‹é–¢æ•°ã§ã™ã€‚\n"
"ã“ã‚Œã¯æ–°ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ã‹ã€ã‚¨ãƒ©ãƒ¼ã‚’è¨­å®šã—ã¦ *NULL* ã‚’è¿”ã™ã¹ãã§ã™ã€‚"

#: ../../c-api/module.rst:316
msgid ""
"This function should be kept minimal. In particular, it should not call "
"arbitrary Python code, as trying to import the same module again may result "
"in an infinite loop."
msgstr ""
"ã“ã®é–¢æ•°ã¯æœ€å°é™ã«ç•™ã‚ã¦ãŠãã¹ãã§ã™ã€‚\n"
"ç‰¹ã«ä»»æ„ã®Pythonã‚³ãƒ¼ãƒ‰ã‚’å‘¼ã³å‡ºã™ã¹ãã§ã¯ãªãã€åŒã˜ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã‚ˆã†ã¨ã™ã‚‹ã¨ç„¡é™ãƒ«ãƒ¼ãƒ—ã«é™¥ã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../c-api/module.rst:320
msgid ""
"Multiple ``Py_mod_create`` slots may not be specified in one module "
"definition."
msgstr "è¤‡æ•°ã® ``Py_mod_create`` ã‚¹ãƒ­ãƒƒãƒˆã‚’1ã¤ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®šç¾©ã«è¨­å®šã—ãªã„æ–¹ãŒã‚ˆã„ã§ã™ã€‚"

#: ../../c-api/module.rst:323
msgid ""
"If ``Py_mod_create`` is not specified, the import machinery will create a "
"normal module object using :c:func:`PyModule_New`. The name is taken from "
"*spec*, not the definition, to allow extension modules to dynamically adjust"
" to their place in the module hierarchy and be imported under different "
"names through symlinks, all while sharing a single module definition."
msgstr ""
"``Py_mod_create`` ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã¯ :c:func:`PyModule_New` ã‚’ä½¿ã£ã¦é€šå¸¸ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã—ã¾ã™ã€‚\n"
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ã¯å®šç¾©ã§ã¯ãªã *spec* ã‹ã‚‰å–å¾—ã•ã‚Œã€ã“ã‚Œã«ã‚ˆã£ã¦æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå‹•çš„ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«éšå±¤ã«ãŠã‘ã‚‹ä½ç½®ã‚’èª¿æ•´ã§ããŸã‚Šã€ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã‚’é€šã—ã¦åŒä¸€ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®šç¾©ã‚’å…±æœ‰ã—ã¤ã¤åˆ¥ã®åå‰ã§ã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ããŸã‚Šã—ã¾ã™ã€‚"

#: ../../c-api/module.rst:329
msgid ""
"There is no requirement for the returned object to be an instance of "
":c:type:`PyModule_Type`. Any type can be used, as long as it supports "
"setting and getting import-related attributes. However, only "
"``PyModule_Type`` instances may be returned if the ``PyModuleDef`` has "
"non-*NULL* ``m_traverse``, ``m_clear``, ``m_free``; non-zero ``m_size``; or "
"slots other than ``Py_mod_create``."
msgstr ""
"è¿”ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ :c:type:`PyModule_Type` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚\n"
"ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«é–¢é€£ã™ã‚‹å±æ€§ã®è¨­å®šã¨å–å¾—ãŒã§ãã‚‹é™ã‚Šã¯ã€ã©ã‚“ãªå‹ã§ã‚‚ä½¿ãˆã¾ã™ã€‚\n"
"ã—ã‹ã—ã€ ``PyModuleDef`` ãŒ *NULL* ã§ãªã„ ``m_traverse``, ``m_clear``, ``m_free`` ã€ã‚‚ã—ãã¯ã‚¼ãƒ­ã§ãªã„ ``m_size`` ã€ã‚‚ã—ãã¯ ``Py_mod_create`` ä»¥å¤–ã®ã‚¹ãƒ­ãƒƒãƒˆã‚’æŒã¤å ´åˆã¯ã€ ``PyModule_Type`` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã¿ãŒè¿”ã•ã‚Œã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../c-api/module.rst:338
msgid ""
"Specifies a function that is called to *execute* the module. This is "
"equivalent to executing the code of a Python module: typically, this "
"function adds classes and constants to the module. The signature of the "
"function is:"
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ *å®Ÿè¡Œã™ã‚‹* ã¨ãã«å‘¼ã°ã‚Œã‚‹é–¢æ•°ã‚’æŒ‡å®šã—ã¾ã™ã€‚\n"
"ã“ã‚Œã¯Pythonãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã®ã¨åŒç­‰ã§ã™:\n"
"ã“ã®é–¢æ•°ã¯ãŸã„ã¦ã„ã¯ã‚¯ãƒ©ã‚¹ã¨å®šæ•°ã‚’ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã—ã¾ã™ã€‚\n"
"ã“ã®é–¢æ•°ã®ã‚·ã‚°ãƒãƒãƒ£ã¯ä»¥ä¸‹ã§ã™:"

#: ../../c-api/module.rst:345
msgid ""
"If multiple ``Py_mod_exec`` slots are specified, they are processed in the "
"order they appear in the *m_slots* array."
msgstr "è¤‡æ•°ã® ``Py_mod_exec`` ã‚¹ãƒ­ãƒƒãƒˆãŒè¨­å®šã•ã‚Œã¦ã„ãŸå ´åˆã¯ã€ *m_slots* é…åˆ—ã«ç¾ã‚ŒãŸé †ã«å‡¦ç†ã•ã‚Œã¦ã„ãã¾ã™ã€‚"

#: ../../c-api/module.rst:348
msgid "See :PEP:`489` for more details on multi-phase initialization."
msgstr "å¤šæ®µéšåˆæœŸåŒ–ã«ã¤ã„ã¦ã‚ˆã‚Šè©³ã—ãã¯ :PEP:`489` ã‚’è¦‹ã¦ãã ã•ã„ã€‚"

#: ../../c-api/module.rst:351
msgid "Low-level module creation functions"
msgstr "ä½æ°´æº–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä½œæˆé–¢æ•°"

#: ../../c-api/module.rst:353
msgid ""
"The following functions are called under the hood when using multi-phase "
"initialization. They can be used directly, for example when creating module "
"objects dynamically. Note that both ``PyModule_FromDefAndSpec`` and "
"``PyModule_ExecDef`` must be called to fully initialize a module."
msgstr ""
"ä»¥ä¸‹ã®é–¢æ•°ã¯ã€å¤šæ®µéšåˆæœŸåŒ–ã‚’ä½¿ã†ã¨ãã«è£å´ã§å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚\n"
"ä¾‹ãˆã°ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‹•çš„ã«ç”Ÿæˆã™ã‚‹ã¨ãã«ã€ã“ã‚Œã‚‰ã®é–¢æ•°ã‚’ç›´æ¥ä½¿ãˆã¾ã™ã€‚\n"
"``PyModule_FromDefAndSpec`` ãŠã‚ˆã³ ``PyModule_ExecDef`` ã®ã©ã¡ã‚‰ã‚‚ã€å‘¼ã³å‡ºã—ãŸå¾Œã«ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå®Œå…¨ã«åˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/module.rst:360
msgid ""
"Create a new module object, given the definition in *module* and the "
"ModuleSpec *spec*.  This behaves like :c:func:`PyModule_FromDefAndSpec2` "
"with *module_api_version* set to :const:`PYTHON_API_VERSION`."
msgstr ""
"*module* ã¨ ModuleSpec ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® *spec* ã§å®šç¾©ã•ã‚ŒãŸã¨ãŠã‚Šã«æ–°ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã—ã¾ã™ã€‚\n"
"ã“ã®é–¢æ•°ã¯ã€ :c:func:`PyModule_FromDefAndSpec2` é–¢æ•°ã® *module_api_version* ã« :const:`PYTHON_API_VERSION` ã‚’æŒ‡å®šã—ãŸæ™‚ã¨ãŠãªã˜ã‚ˆã†ã«ãµã‚‹ã¾ã„ã¾ã™ã€‚"

#: ../../c-api/module.rst:368
msgid ""
"Create a new module object, given the definition in *module* and the "
"ModuleSpec *spec*, assuming the API version *module_api_version*. If that "
"version does not match the version of the running interpreter, a "
":exc:`RuntimeWarning` is emitted."
msgstr ""
"APIãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ *module_api_version* ã¨ã—ã¦ã€ *module* ã¨ ModuleSpec ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® *spec* ã§å®šç¾©ã•ã‚ŒãŸã¨ãŠã‚Šã«æ–°ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã—ã¾ã™ã€‚\n"
"ã‚‚ã—æŒ‡å®šã•ã‚ŒãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒå®Ÿè¡Œã—ã¦ã„ã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ç•°ãªã‚‹å ´åˆã¯ã€ :exc:`RuntimeWarning` ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚"

#: ../../c-api/module.rst:375
msgid ""
"Most uses of this function should be using :c:func:`PyModule_FromDefAndSpec`"
" instead; only use this if you are sure you need it."
msgstr ""
"ã»ã¨ã‚“ã©ã®å ´åˆã€ã“ã®é–¢æ•°ã§ã¯ãªã :c:func:`PyModule_FromDefAndSpec` ã‚’åˆ©ç”¨ã™ã‚‹ã¹ãã§ã™ã€‚\n"
"ã“ã®é–¢æ•°ã¯ã€ã“ã®é–¢æ•°ã®å¿…è¦æ€§ã‚’ç†è§£ã—ã¦ã„ã‚‹ã¨ãã«ã ã‘åˆ©ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../c-api/module.rst:382
msgid "Process any execution slots (:c:data:`Py_mod_exec`) given in *def*."
msgstr "*def* ã§ä¸ãˆã‚‰ã‚ŒãŸä»»æ„ã®å®Ÿè¡Œã‚¹ãƒ­ãƒƒãƒˆ (:c:data:`Py_mod_exec`) ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚"

#: ../../c-api/module.rst:388
msgid ""
"Set the docstring for *module* to *docstring*. This function is called "
"automatically when creating a module from ``PyModuleDef``, using either "
"``PyModule_Create`` or ``PyModule_FromDefAndSpec``."
msgstr ""
"*module* ã® docstring ã‚’ *docstring* ã«è¨­å®šã—ã¾ã™ã€‚\n"
"ã“ã®é–¢æ•°ã¯ã€ ``PyModuleDef`` ã‹ã‚‰ ``PyModule_Create`` ã‚‚ã—ãã¯ ``PyModule_FromDefAndSpec`` ã‚’ä½¿ã£ã¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç”Ÿæˆã™ã‚‹ã¨ãã«è‡ªå‹•çš„ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/module.rst:397
msgid ""
"Add the functions from the *NULL* terminated *functions* array to *module*. "
"Refer to the :c:type:`PyMethodDef` documentation for details on individual "
"entries (due to the lack of a shared module namespace, module level "
"\"functions\" implemented in C typically receive the module as their first "
"parameter, making them similar to instance methods on Python classes). This "
"function is called automatically when creating a module from "
"``PyModuleDef``, using either ``PyModule_Create`` or "
"``PyModule_FromDefAndSpec``."
msgstr ""
"çµ‚ç«¯ãŒ *NULL* ã«ãªã£ã¦ã„ã‚‹ *functions* é…åˆ—ã«ã‚ã‚‹é–¢æ•°ã‚’ *module* ã«è¿½åŠ ã—ã¾ã™ã€‚\n"
":c:type:`PyMethodDef` æ§‹é€ ä½“ã®å€‹ã€…ã®ã‚¨ãƒ³ãƒˆãƒªã«ã¤ã„ã¦ã¯ PyMethodDef ã®èª¬æ˜ã‚’å‚ç…§ã—ã¦ãã ã•ã„ (ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ç©ºé–“ãŒå…±æœ‰ã•ã‚Œã¦ã„ãªã„ã®ã§ã€ C ã§å®Ÿè£…ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ« \"é–¢æ•°\" ã¯ãŸã„ã¦ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’1ã¤ç›®ã®å¼•æ•°ã¨ã—ã¦å—ã‘å–ã‚Šã€ Python ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã«ä¼¼ãŸå½¢ã«ã—ã¾ã™)ã€‚\n"
"ã“ã®é–¢æ•°ã¯ã€ ``PyModuleDef`` ã‹ã‚‰ ``PyModule_Create`` ã‚‚ã—ãã¯ ``PyModule_FromDefAndSpec`` ã‚’ä½¿ã£ã¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç”Ÿæˆã™ã‚‹ã¨ãã«è‡ªå‹•çš„ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/module.rst:409
msgid "Support functions"
msgstr "ã‚µãƒãƒ¼ãƒˆé–¢æ•°"

#: ../../c-api/module.rst:411
msgid ""
"The module initialization function (if using single phase initialization) or"
" a function called from a module execution slot (if using multi-phase "
"initialization), can use the following functions to help initialize the "
"module state:"
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åˆæœŸåŒ–é–¢æ•° (ä¸€æ®µéšåˆæœŸåŒ–ã‚’ä½¿ã†å ´åˆ) ã€ã‚ã‚‹ã„ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å®Ÿè¡Œã‚¹ãƒ­ãƒƒãƒˆã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã‚‹é–¢æ•° (å¤šæ®µéšåˆæœŸåŒ–ã‚’ä½¿ã†å ´åˆ) "
"ã¯æ¬¡ã®é–¢æ•°ã‚’ä½¿ã†ã¨ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® state ã®åˆæœŸåŒ–ã‚’ç°¡å˜ã«ã§ãã¾ã™:"

#: ../../c-api/module.rst:418
msgid ""
"Add an object to *module* as *name*.  This is a convenience function which "
"can be used from the module's initialization function.  This steals a "
"reference to *value*.  Return ``-1`` on error, ``0`` on success."
msgstr ""
"*module* ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ *name* ã¨ã—ã¦è¿½åŠ ã—ã¾ã™ã€‚\n"
"ã“ã®é–¢æ•°ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åˆæœŸåŒ–é–¢æ•°ã‹ã‚‰åˆ©ç”¨ã•ã‚Œã‚‹ä¾¿åˆ©é–¢æ•°ã§ã™ã€‚\n"
"ã“ã‚Œã¯ *value* ã¸ã®å‚ç…§ã‚’ç›—ã¿ã¾ã™ã€‚\n"
"ã‚¨ãƒ©ãƒ¼ã®ã¨ãã«ã¯ ``-1`` ã‚’ã€æˆåŠŸã—ãŸã¨ãã«ã¯ ``0`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/module.rst:424
msgid ""
"Add an integer constant to *module* as *name*.  This convenience function "
"can be used from the module's initialization function. Return ``-1`` on "
"error, ``0`` on success."
msgstr ""
"*module* ã«æ•´æ•°å®šæ•°ã‚’ *name* ã¨ã—ã¦è¿½åŠ ã—ã¾ã™ã€‚ã“ã®ä¾¿å®œé–¢æ•°ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åˆæœŸåŒ–é–¢æ•°ã‹ã‚‰åˆ©ç”¨ã•ã‚Œã¦ã„ã¾ã™ã€‚ã‚¨ãƒ©ãƒ¼ã®ã¨ãã«ã¯ ``-1``"
" ã‚’ã€æˆåŠŸã—ãŸã¨ãã«ã¯ ``0`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/module.rst:431
msgid ""
"Add a string constant to *module* as *name*.  This convenience function can "
"be used from the module's initialization function.  The string *value* must "
"be *NULL*-terminated.  Return ``-1`` on error, ``0`` on success."
msgstr ""
"*module* ã«æ–‡å­—åˆ—å®šæ•°ã‚’ *name* ã¨ã—ã¦è¿½åŠ ã—ã¾ã™ã€‚\n"
"ã“ã®ä¾¿åˆ©é–¢æ•°ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åˆæœŸåŒ–é–¢æ•°ã‹ã‚‰åˆ©ç”¨ã•ã‚Œã¦ã„ã¾ã™ã€‚\n"
"æ–‡å­—åˆ— *value* ã¯ *NULL* çµ‚ç«¯ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\n"
"ã‚¨ãƒ©ãƒ¼ã®ã¨ãã«ã¯ ``-1`` ã‚’ã€æˆåŠŸã—ãŸã¨ãã«ã¯ ``0`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/module.rst:438
msgid ""
"Add an int constant to *module*. The name and the value are taken from "
"*macro*. For example ``PyModule_AddIntMacro(module, AF_INET)`` adds the int "
"constant *AF_INET* with the value of *AF_INET* to *module*. Return ``-1`` on"
" error, ``0`` on success."
msgstr ""
"*module* ã« int å®šæ•°ã‚’è¿½åŠ ã—ã¾ã™ã€‚åå‰ã¨å€¤ã¯ *macro* ã‹ã‚‰å–å¾—ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ "
"``PyModule_AddIntMacro(module, AF_INET)`` ã¨ã™ã‚‹ã¨ã€ *AF_INET* ã¨ã„ã†åå‰ã® int å‹å®šæ•°ã‚’ "
"*AF_INET* ã®å€¤ã§ *module* ã«è¿½åŠ ã—ã¾ã™ã€‚ã‚¨ãƒ©ãƒ¼æ™‚ã«ã¯ ``-1`` ã‚’ã€æˆåŠŸæ™‚ã«ã¯ ``0`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/module.rst:446
msgid "Add a string constant to *module*."
msgstr "æ–‡å­—åˆ—å®šæ•°ã‚’ *module* ã«è¿½åŠ ã—ã¾ã™ã€‚"

#: ../../c-api/module.rst:450
msgid "Module lookup"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ¤œç´¢"

#: ../../c-api/module.rst:452
msgid ""
"Single-phase initialization creates singleton modules that can be looked up "
"in the context of the current interpreter. This allows the module object to "
"be retrieved later with only a reference to the module definition."
msgstr ""
"ä¸€æ®µéšåˆæœŸåŒ–ã¯ã€ç¾åœ¨ã®ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰æ¢ã›ã‚‹ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç”Ÿæˆã—ã¾ã™ã€‚\n"
"ã“ã‚Œã«ã‚ˆã£ã¦ã€å¾Œã‹ã‚‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®šç¾©ã¸ã®å‚ç…§ã ã‘ã§ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå–å¾—ã§ãã¾ã™ã€‚"

#: ../../c-api/module.rst:456
msgid ""
"These functions will not work on modules created using multi-phase "
"initialization, since multiple such modules can be created from a single "
"definition."
msgstr "å¤šæ®µéšåˆæœŸåŒ–ã‚’ä½¿ã†ã¨å˜ä¸€ã®å®šç¾©ã‹ã‚‰è¤‡æ•°ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒä½œæˆã§ãã‚‹ã®ã§ã€ã“ã‚Œã‚‰ã®é–¢æ•°ã¯å¤šæ®µéšåˆæœŸåŒ–ã‚’ä½¿ã£ã¦ä½œæˆã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯ä½¿ãˆã¾ã›ã‚“ã€‚"

#: ../../c-api/module.rst:461
msgid ""
"Returns the module object that was created from *def* for the current "
"interpreter. This method requires that the module object has been attached "
"to the interpreter state with :c:func:`PyState_AddModule` beforehand. In "
"case the corresponding module object is not found or has not been attached "
"to the interpreter state yet, it returns *NULL*."
msgstr ""
"ç¾åœ¨ã®ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã® *def* ã‹ã‚‰ä½œã‚‰ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®å‰ææ¡ä»¶ã¨ã—ã¦ã€å‰ã‚‚ã£ã¦ "
":c:func:`PyState_AddModule` ã§ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã® state "
"ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é€£çµã—ã¦ãŠãã“ã¨ã‚’è¦æ±‚ã—ã¾ã™ã€‚å¯¾å¿œã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè¦‹ä»˜ã‹ã‚‰ãªã„ã€ã‚‚ã—ãã¯äº‹å‰ã«ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã® state "
"ã«é€£çµã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€ *NULL* ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/module.rst:468
msgid ""
"Attaches the module object passed to the function to the interpreter state. "
"This allows the module object to be accessible via "
":c:func:`PyState_FindModule`."
msgstr ""
"é–¢æ•°ã«æ¸¡ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã® state ã«é€£çµã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã‚’ä½¿ã†ã“ã¨ã§ "
":c:func:`PyState_FindModule` ã‹ã‚‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/module.rst:471
msgid "Only effective on modules created using single-phase initialization."
msgstr "ä¸€æ®µéšåˆæœŸåŒ–ã‚’ä½¿ã£ã¦ä½œæˆã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã®ã¿æœ‰åŠ¹ã§ã™ã€‚"

#: ../../c-api/module.rst:477
msgid ""
"Removes the module object created from *def* from the interpreter state."
msgstr "*def* ã‹ã‚‰ä½œã‚‰ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ state ã‹ã‚‰å‰Šé™¤ã—ã¾ã™ã€‚"
