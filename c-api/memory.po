# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Nozomu Kaneko <nozom.kaneko@gmail.com>, 2017
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2017
# E. Kawashima, 2017
# Arihiro TAKASE, 2017
# Naoki INADA <songofacandy@gmail.com>, 2017
# Osamu NAKAMURA, 2017
# tomoğŸ§, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-30 05:56+0900\n"
"PO-Revision-Date: 2017-02-16 17:37+0000\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/memory.rst:8
msgid "Memory Management"
msgstr "ãƒ¡ãƒ¢ãƒªç®¡ç†"

#: ../../c-api/memory.rst:17
msgid "Overview"
msgstr "æ¦‚è¦"

#: ../../c-api/memory.rst:19
msgid ""
"Memory management in Python involves a private heap containing all Python "
"objects and data structures. The management of this private heap is ensured "
"internally by the *Python memory manager*.  The Python memory manager has "
"different components which deal with various dynamic storage management "
"aspects, like sharing, segmentation, preallocation or caching."
msgstr ""
"Python ã«ãŠã‘ã‚‹ãƒ¡ãƒ¢ãƒªç®¡ç†ã«ã¯ã€å…¨ã¦ã® Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ãƒ‡ãƒ¼ã‚¿æ§‹é€ ãŒå…¥ã£ãŸãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ’ãƒ¼ãƒ— (private heap) "
"ãŒå¿…é ˆã§ã™ã€‚ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ’ãƒ¼ãƒ—ã®ç®¡ç†ã¯ã€å†…éƒ¨çš„ã«ã¯ *Python ãƒ¡ãƒ¢ãƒªãƒãƒãƒ¼ã‚¸ãƒ£ (Python memory manager)* "
"ãŒç¢ºå®Ÿã«è¡Œã„ã¾ã™ã€‚Python ãƒ¡ãƒ¢ãƒªãƒãƒãƒ¼ã‚¸ãƒ£ã«ã¯ã€å…±æœ‰ (sharing)ã€ã‚»ã‚°ãƒ¡ãƒ³ãƒˆåˆ†å‰² (segmentation)ã€äº‹å‰å‰²ã‚Šå½“ã¦ "
"(preallocation)ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥åŒ– (caching) ã¨ã„ã£ãŸã€æ§˜ã€…ãªå‹•çš„è¨˜æ†¶ç®¡ç†ã®å´é¢ã‚’æ‰±ã†ãŸã‚ã«ã€å€‹åˆ¥ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../c-api/memory.rst:25
msgid ""
"At the lowest level, a raw memory allocator ensures that there is enough "
"room in the private heap for storing all Python-related data by interacting "
"with the memory manager of the operating system. On top of the raw memory "
"allocator, several object-specific allocators operate on the same heap and "
"implement distinct memory management policies adapted to the peculiarities "
"of every object type. For example, integer objects are managed differently "
"within the heap than strings, tuples or dictionaries because integers imply "
"different storage requirements and speed/space tradeoffs. The Python memory "
"manager thus delegates some of the work to the object-specific allocators, "
"but ensures that the latter operate within the bounds of the private heap."
msgstr ""
"æœ€ä½æ°´æº–å±¤ã§ã¯ã€ç´ ã®ãƒ¡ãƒ¢ãƒªæ“ä½œé–¢æ•° (raw memory allocator) "
"ãŒã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ¡ãƒ¢ãƒªç®¡ç†æ©Ÿæ§‹ã¨ã‚„ã‚Šã¨ã‚Šã—ã¦ã€ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ’ãƒ¼ãƒ—å†…ã«Python "
"é–¢é€£ã®å…¨ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’è¨˜æ†¶ã™ã‚‹ã®ã«ååˆ†ãªç©ºããŒã‚ã‚‹ã‹ã©ã†ã‹ç¢ºèªã—ã¾ã™ã€‚ç´ ã®ãƒ¡ãƒ¢ãƒªæ“ä½œé–¢æ•°ã®ä¸Šã«ã¯ã€ã„ãã¤ã‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå›ºæœ‰ã®ãƒ¡ãƒ¢ãƒªæ“ä½œé–¢æ•°ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã¯åŒã˜ãƒ’ãƒ¼ãƒ—ã‚’æ“ä½œã—ã€å„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹å›ºæœ‰ã®äº‹æƒ…ã«åˆã£ãŸãƒ¡ãƒ¢ãƒªç®¡ç†ãƒãƒªã‚·ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚ä¾‹ãˆã°ã€æ•´æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ–‡å­—åˆ—ã‚„ã‚¿ãƒ—ãƒ«ã€è¾æ›¸ã¨ã¯é•ã£ãŸã‚„ã‚Šæ–¹ã§ãƒ’ãƒ¼ãƒ—å†…ã§ç®¡ç†ã•ã‚Œã¾ã™ã€‚ã¨ã„ã†ã®ã‚‚ã€æ•´æ•°ã«ã¯å€¤ã‚’è¨˜æ†¶ã™ã‚‹ä¸Šã§ç‰¹åˆ¥ãªè¦ä»¶ãŒã‚ã‚Šã€é€Ÿåº¦/å®¹é‡ã®ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•ãŒå­˜åœ¨ã™ã‚‹ã‹ã‚‰ã§ã™ã€‚ã“ã®ã‚ˆã†ã«ã€Python"
" "
"ãƒ¡ãƒ¢ãƒªãƒãƒã‚¸ãƒ£ã¯ä½œæ¥­ã®ã„ãã¤ã‹ã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå›ºæœ‰ã®ãƒ¡ãƒ¢ãƒªæ“ä½œé–¢æ•°ã«å§”è­²ã—ã¾ã™ãŒã€ã“ã‚Œã‚‰ã®é–¢æ•°ãŒãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ’ãƒ¼ãƒ—ã‹ã‚‰ã¯ã¿å‡ºã—ã¦ãƒ¡ãƒ¢ãƒªç®¡ç†ã‚’è¡Œã‚ãªã„ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚"

#: ../../c-api/memory.rst:36
msgid ""
"It is important to understand that the management of the Python heap is "
"performed by the interpreter itself and that the user has no control over "
"it, even if they regularly manipulate object pointers to memory blocks "
"inside that heap.  The allocation of heap space for Python objects and other"
" internal buffers is performed on demand by the Python memory manager "
"through the Python/C API functions listed in this document."
msgstr ""

#: ../../c-api/memory.rst:49
msgid ""
"To avoid memory corruption, extension writers should never try to operate on"
" Python objects with the functions exported by the C library: "
":c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` and :c:func:`free`.  "
"This will result in  mixed calls between the C allocator and the Python "
"memory manager with fatal consequences, because they implement different "
"algorithms and operate on different heaps.  However, one may safely allocate"
" and release memory blocks with the C library allocator for individual "
"purposes, as shown in the following example::"
msgstr ""
"ãƒ¡ãƒ¢ãƒªç®¡ç†ã®å´©å£Šã‚’é¿ã‘ã‚‹ãŸã‚ã€æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä½œè€…ã¯æ±ºã—ã¦ Python  ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ C ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒå…¬é–‹ã—ã¦ã„ã‚‹é–¢æ•°: "
":c:func:`malloc` ã€ :c:func:`calloc` ã€ :c:func:`realloc` ãŠã‚ˆã³ :c:func:`free` "
"ã§æ“ä½œã—ã‚ˆã†ã¨ã—ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ã“ã†ã—ãŸé–¢æ•°ã‚’ä½¿ã†ã¨ã€C ã®ãƒ¡ãƒ¢ãƒªæ“ä½œé–¢æ•°ã¨ Python ãƒ¡ãƒ¢ãƒªãƒãƒãƒ¼ã‚¸ãƒ£ã¨ã®é–“ã§é–¢æ•°å‘¼ã³å‡ºã—ãŒäº¤éŒ¯ã—ã¾ã™ã€‚ C "
"ã®ãƒ¡ãƒ¢ãƒªæ“ä½œé–¢æ•°ã¨Python "
"ãƒ¡ãƒ¢ãƒªãƒãƒãƒ¼ã‚¸ãƒ£ã¯ç•°ãªã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§å®Ÿè£…ã•ã‚Œã¦ã„ã¦ã€ç•°ãªã‚‹ãƒ’ãƒ¼ãƒ—ã‚’æ“ä½œã™ã‚‹ãŸã‚ã€å‘¼ã³å‡ºã—ã®äº¤éŒ¯ã¯è‡´å‘½çš„ãªçµæœã‚’æ‹›ãã¾ã™ã€‚ã¨ã¯ã„ãˆã€å€‹åˆ¥ã®ç›®çš„ã®ãŸã‚ãªã‚‰ã€"
" C ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ¡ãƒ¢ãƒªæ“ä½œé–¢æ•°ã‚’ä½¿ã£ã¦å®‰å…¨ã«ãƒ¡ãƒ¢ãƒªã‚’ç¢ºä¿ã—ãŸã‚Šè§£æ”¾ã—ãŸã‚Šã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€ä»¥ä¸‹ãŒãã®ã‚ˆã†ãªä¾‹ã§ã™::"

#: ../../c-api/memory.rst:68
msgid ""
"In this example, the memory request for the I/O buffer is handled by the C "
"library allocator. The Python memory manager is involved only in the "
"allocation of the string object returned as a result."
msgstr ""
"ã“ã®ä¾‹ã§ã¯ã€I/O ãƒãƒƒãƒ•ã‚¡ã«å¯¾ã™ã‚‹ãƒ¡ãƒ¢ãƒªè¦æ±‚ã¯ C ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ¡ãƒ¢ãƒªæ“ä½œé–¢æ•°ã‚’ä½¿ã£ã¦ã„ã¾ã™ã€‚Python "
"ãƒ¡ãƒ¢ãƒªãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã¯æˆ»ã‚Šå€¤ã¨ã—ã¦è¿”ã•ã‚Œã‚‹æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç¢ºä¿ã™ã‚‹æ™‚ã«ã ã‘å¿…è¦ã§ã™ã€‚"

#: ../../c-api/memory.rst:72
msgid ""
"In most situations, however, it is recommended to allocate memory from the "
"Python heap specifically because the latter is under control of the Python "
"memory manager. For example, this is required when the interpreter is "
"extended with new object types written in C. Another reason for using the "
"Python heap is the desire to *inform* the Python memory manager about the "
"memory needs of the extension module. Even when the requested memory is used"
" exclusively for internal, highly-specific purposes, delegating all memory "
"requests to the Python memory manager causes the interpreter to have a more "
"accurate image of its memory footprint as a whole. Consequently, under "
"certain circumstances, the Python memory manager may or may not trigger "
"appropriate actions, like garbage collection, memory compaction or other "
"preventive procedures. Note that by using the C library allocator as shown "
"in the previous example, the allocated memory for the I/O buffer escapes "
"completely the Python memory manager."
msgstr ""
"ã¨ã¯ã„ãˆã€ã»ã¨ã‚“ã©ã®çŠ¶æ³ã§ã¯ã€ãƒ¡ãƒ¢ãƒªã®æ“ä½œã¯ Python ãƒ’ãƒ¼ãƒ—ã«å›ºå®šã—ã¦è¡Œã†ã‚ˆã†å‹§ã‚ã¾ã™ã€‚ãªãœãªã‚‰ã€Python ãƒ’ãƒ¼ãƒ—ã¯ Python "
"ãƒ¡ãƒ¢ãƒªãƒãƒã‚¸ãƒ£ã®ç®¡ç†ä¸‹ã«ã‚ã‚‹ã‹ã‚‰ã§ã™ã€‚ä¾‹ãˆã°ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’ C "
"ã§æ›¸ã‹ã‚ŒãŸæ–°ãŸãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã§æ‹¡å¼µã™ã‚‹éš›ã«ã¯ã€ãƒ’ãƒ¼ãƒ—ã§ã®ãƒ¡ãƒ¢ãƒªç®¡ç†ãŒå¿…è¦ã§ã™ã€‚Python "
"ãƒ’ãƒ¼ãƒ—ã‚’ä½¿ã£ãŸæ–¹ãŒã‚ˆã„ã‚‚ã†ä¸€ã¤ã®ç†ç”±ã¨ã—ã¦ã€æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå¿…è¦ã¨ã—ã¦ã„ã‚‹ãƒ¡ãƒ¢ãƒªã«ã¤ã„ã¦ Python ãƒ¡ãƒ¢ãƒªãƒãƒãƒ¼ã‚¸ãƒ£ã« *æƒ…å ±ã‚’æä¾›* "
"ã—ã¦ã»ã—ã„ã¨ã„ã†ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ãŸã¨ãˆå¿…è¦ãªãƒ¡ãƒ¢ãƒªãŒå†…éƒ¨çš„ã‹ã¤éå¸¸ã«ç‰¹åŒ–ã—ãŸç”¨é€”ã«å¯¾ã—ã¦æ’ä»–çš„ã«ç”¨ã„ã‚‰ã‚Œã‚‹ã‚‚ã®ã ã¨ã—ã¦ã‚‚ã€å…¨ã¦ã®ãƒ¡ãƒ¢ãƒªæ“ä½œè¦æ±‚ã‚’ "
"Python ãƒ¡ãƒ¢ãƒªãƒãƒãƒ¼ã‚¸ãƒ£ã«å§”è­²ã™ã‚Œã°ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ã‚ˆã‚Šæ­£ç¢ºãªãƒ¡ãƒ¢ãƒªãƒ•ãƒƒãƒˆãƒ—ãƒªãƒ³ãƒˆã®å…¨ä½“åƒã‚’æŠŠæ¡ã§ãã¾ã™ã€‚ãã®çµæœã€ç‰¹å®šã®çŠ¶æ³ã§ã¯ã€Python "
"ãƒ¡ãƒ¢ãƒªãƒãƒãƒ¼ã‚¸ãƒ£ãŒã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚„ãƒ¡ãƒ¢ãƒªã®ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆåŒ–ã€ãã®ä»–ä½•ã‚‰ã‹ã®äºˆé˜²æªç½®ã¨ã„ã£ãŸã€é©åˆ‡ãªå‹•ä½œã‚’ãƒˆãƒªã‚¬ã§ãã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ä¸Šã®ä¾‹ã§ç¤ºã—ãŸã‚ˆã†ã«"
" C ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ¡ãƒ¢ãƒªæ“ä½œé–¢æ•°ã‚’ä½¿ã†ã¨ã€I/O ãƒãƒƒãƒ•ã‚¡ç”¨ã«ç¢ºä¿ã—ãŸãƒ¡ãƒ¢ãƒªã¯ Python "
"ãƒ¡ãƒ¢ãƒªãƒãƒãƒ¼ã‚¸ãƒ£ã®ç®¡ç†ã‹ã‚‰å®Œå…¨ã«å¤–ã‚Œã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../c-api/memory.rst:88
msgid ""
"The :envvar:`PYTHONMALLOC` environment variable can be used to configure the"
" memory allocators used by Python."
msgstr "ç’°å¢ƒå¤‰æ•° :envvar:`PYTHONMALLOC` ã‚’ä½¿ç”¨ã—ã¦ Python ãŒåˆ©ç”¨ã™ã‚‹ãƒ¡ãƒ¢ãƒªã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã‚’åˆ¶å¾¡ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../c-api/memory.rst:91
msgid ""
"The :envvar:`PYTHONMALLOCSTATS` environment variable can be used to print "
"statistics of the :ref:`pymalloc memory allocator <pymalloc>` every time a "
"new pymalloc object arena is created, and on shutdown."
msgstr ""
"ç’°å¢ƒå¤‰æ•° :envvar:`PYTHONMALLOCSTATS` ã‚’ä½¿ç”¨ã—ã¦ã€æ–°ãŸãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¢ãƒªãƒ¼ãƒŠãŒç”Ÿæˆã•ã‚Œã‚‹æ™‚ã¨ã€ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³æ™‚ã« "
":ref:`pymalloc ãƒ¡ãƒ¢ãƒªã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ <pymalloc>` ã®çµ±è¨ˆæƒ…å ±ã‚’è¡¨ç¤ºã§ãã¾ã™ã€‚"

#: ../../c-api/memory.rst:97
msgid "Raw Memory Interface"
msgstr "ç”Ÿãƒ¡ãƒ¢ãƒªã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹"

#: ../../c-api/memory.rst:99
msgid ""
"The following function sets are wrappers to the system allocator. These "
"functions are thread-safe, the :term:`GIL <global interpreter lock>` does "
"not need to be held."
msgstr ""
"ä»¥ä¸‹ã®é–¢æ•°ç¾¤ã¯ã‚·ã‚¹ãƒ†ãƒ ã®ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã‚’ãƒ©ãƒƒãƒ—ã—ã¾ã™ã€‚\n"
"ã“ã‚Œã‚‰ã®é–¢æ•°ã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã§ã€ :term:`GIL <global interpreter lock>` ã‚’ä¿æŒã—ã¦ã„ãªãã¦ã‚‚å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../c-api/memory.rst:103
msgid ""
"The :ref:`default raw memory allocator <default-memory-allocators>` uses the"
" following functions: :c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` "
"and :c:func:`free`; call ``malloc(1)`` (or ``calloc(1, 1)``) when requesting"
" zero bytes."
msgstr ""

#: ../../c-api/memory.rst:112 ../../c-api/memory.rst:183
#: ../../c-api/memory.rst:285
msgid ""
"Allocates *n* bytes and returns a pointer of type :c:type:`void\\*` to the "
"allocated memory, or *NULL* if the request fails."
msgstr ""
"*n* ãƒã‚¤ãƒˆã‚’å‰²ã‚Šå½“ã¦ã€ãã®ãƒ¡ãƒ¢ãƒªã‚’æŒ‡ã™ :c:type:`void\\*` å‹ã®ãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚è¦æ±‚ãŒå¤±æ•—ã—ãŸå ´åˆ *NULL* ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/memory.rst:115
msgid ""
"Requesting zero bytes returns a distinct non-*NULL* pointer if possible, as "
"if ``PyMem_RawMalloc(1)`` had been called instead. The memory will not have "
"been initialized in any way."
msgstr ""
"0ãƒã‚¤ãƒˆã‚’è¦æ±‚ã™ã‚‹ã¨ã€ ``PyMem_RawMalloc(1)`` ãŒå‘¼ã°ã‚ŒãŸã¨ãã¨åŒã˜ã‚ˆã†ã«ã€å¯èƒ½ãªã‚‰ *NULL* "
"ã§ãªã„ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚ç¢ºä¿ã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªãƒ¼ã«ã¯ã„ã‹ãªã‚‹åˆæœŸåŒ–ã‚‚è¡Œã‚ã‚Œã¾ã›ã‚“ã€‚"

#: ../../c-api/memory.rst:122 ../../c-api/memory.rst:193
#: ../../c-api/memory.rst:295
msgid ""
"Allocates *nelem* elements each whose size in bytes is *elsize* and returns "
"a pointer of type :c:type:`void\\*` to the allocated memory, or *NULL* if "
"the request fails. The memory is initialized to zeros."
msgstr ""
"å„è¦ç´ ãŒ *elsize* ãƒã‚¤ãƒˆã®è¦ç´  *nelem* å€‹åˆ†ã®ãƒ¡ãƒ¢ãƒªãƒ¼ã‚’ç¢ºä¿ã—ã€ãã®ãƒ¡ãƒ¢ãƒªãƒ¼ã‚’æŒ‡ã™ :c:type:`void\\*` "
"å‹ã®ãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚ã‚¢ãƒ­ã‚±ãƒ¼ãƒˆã«å¤±æ•—ã—ãŸå ´åˆã¯ *NULL* ã‚’è¿”ã—ã¾ã™ã€‚ç¢ºä¿ã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªãƒ¼é ˜åŸŸã¯ã‚¼ãƒ­ã§åˆæœŸåŒ–ã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/memory.rst:126
msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-*NULL* pointer if possible, as if ``PyMem_RawCalloc(1, 1)`` had been "
"called instead."
msgstr ""
"è¦ç´ æ•°ã‹è¦ç´ ã®ã‚µã‚¤ã‚ºãŒ0ãƒã‚¤ãƒˆã®è¦æ±‚ã«å¯¾ã—ã¦ã¯ã€å¯èƒ½ãªã‚‰ ``PyMem_RawCalloc(1, 1)`` ãŒå‘¼ã°ã‚ŒãŸã®ã¨åŒã˜ã‚ˆã†ã«ã€ãƒ¦ãƒ‹ãƒ¼ã‚¯ãª "
"*NULL* ã§ãªã„ãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/memory.rst:135 ../../c-api/memory.rst:206
#: ../../c-api/memory.rst:308
msgid ""
"Resizes the memory block pointed to by *p* to *n* bytes. The contents will "
"be unchanged to the minimum of the old and the new sizes."
msgstr "*p* ãŒæŒ‡ã™ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‚’ *n* ãƒã‚¤ãƒˆã«ãƒªã‚µã‚¤ã‚ºã—ã¾ã™ã€‚å¤ã„ã‚µã‚¤ã‚ºã¨æ–°ã—ã„ã‚µã‚¤ã‚ºã®å°ã•ã„æ–¹ã¾ã§ã®å†…å®¹ã¯å¤‰æ›´ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../c-api/memory.rst:138
msgid ""
"If *p* is *NULL*, the call is equivalent to ``PyMem_RawMalloc(n)``; else if "
"*n* is equal to zero, the memory block is resized but is not freed, and the "
"returned pointer is non-*NULL*."
msgstr ""
"*p* ãŒ *NULL* ã®å ´åˆå‘¼ã³å‡ºã—ã¯ ``PyMem_RawMalloc(n)`` ã¨ç­‰ä¾¡ã§ã™ã€‚ãã†ã§ãªãã€ *n* "
"ãŒã‚¼ãƒ­ã«ç­‰ã—ã„å ´åˆã€ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã¯ãƒªã‚µã‚¤ã‚ºã•ã‚Œã¾ã™ãŒè§£æ”¾ã•ã‚Œã¾ã›ã‚“ã€‚è¿”ã•ã‚ŒãŸãƒã‚¤ãƒ³ã‚¿ã¯é *NULL* ã§ã™ã€‚"

#: ../../c-api/memory.rst:142
msgid ""
"Unless *p* is *NULL*, it must have been returned by a previous call to "
":c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` or "
":c:func:`PyMem_RawCalloc`."
msgstr ""
"*p* ãŒ *NULL* ã§ãªã„é™ã‚Šã€*p* ã¯ãã‚Œã‚ˆã‚Šå‰ã® :c:func:`PyMem_RawMalloc`, "
":c:func:`PyMem_RawRealloc`, :c:func:`PyMem_RawCalloc` ã®å‘¼ã³å‡ºã—ã«ã‚ˆã‚Šè¿”ã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/memory.rst:146
msgid ""
"If the request fails, :c:func:`PyMem_RawRealloc` returns *NULL* and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"è¦æ±‚ãŒå¤±æ•—ã—ãŸå ´åˆ :c:func:`PyMem_RawRealloc` ã¯ *NULL* ã‚’è¿”ã—ã€ *p* "
"ã¯å‰ã®ãƒ¡ãƒ¢ãƒªã‚¨ãƒªã‚¢ã‚’ã•ã™æœ‰åŠ¹ãªãƒã‚¤ãƒ³ã‚¿ã®ã¾ã¾ã§ã™ã€‚"

#: ../../c-api/memory.rst:152
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a"
" previous call to :c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` or "
":c:func:`PyMem_RawCalloc`.  Otherwise, or if ``PyMem_RawFree(p)`` has been "
"called before, undefined behavior occurs."
msgstr ""

#: ../../c-api/memory.rst:157 ../../c-api/memory.rst:227
#: ../../c-api/memory.rst:329
msgid "If *p* is *NULL*, no operation is performed."
msgstr "*p* ãŒ *NULL* ã®å ´åˆä½•ã‚‚ã—ã¾ã›ã‚“ã€‚"

#: ../../c-api/memory.rst:163
msgid "Memory Interface"
msgstr "ãƒ¡ãƒ¢ãƒªã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹"

#: ../../c-api/memory.rst:165 ../../c-api/memory.rst:271
msgid ""
"The following function sets, modeled after the ANSI C standard, but "
"specifying behavior when requesting zero bytes, are available for allocating"
" and releasing memory from the Python heap."
msgstr ""
"ä»¥ä¸‹ã®é–¢æ•°ç¾¤ãŒåˆ©ç”¨ã—ã¦ Python ãƒ’ãƒ¼ãƒ—ã«å¯¾ã—ã¦ãƒ¡ãƒ¢ãƒªã‚’ç¢ºä¿ã—ãŸã‚Šè§£æ”¾ã—ãŸã‚Šå‡ºæ¥ã¾ã™ã€‚ã“ã‚Œã‚‰ã®é–¢æ•°ã¯ ANSI C "
"æ¨™æº–ã«å¾“ã£ã¦ãƒ¢ãƒ‡ãƒ«åŒ–ã•ã‚Œã¦ã„ã¾ã™ãŒã€0 ãƒã‚¤ãƒˆã‚’è¦æ±‚ã—ãŸéš›ã®å‹•ä½œã«ã¤ã„ã¦ã‚‚å®šç¾©ã—ã¦ã„ã¾ã™:"

#: ../../c-api/memory.rst:169
msgid ""
"The :ref:`default memory allocator <default-memory-allocators>` uses the "
":ref:`pymalloc memory allocator <pymalloc>`."
msgstr ""

#: ../../c-api/memory.rst:174 ../../c-api/memory.rst:280
msgid ""
"The :term:`GIL <global interpreter lock>` must be held when using these "
"functions."
msgstr "ã“ã‚Œã‚‰ã®é–¢æ•°ã‚’å‘¼ã¶ã¨ãã«ã¯ã€ :term:`GIL <global interpreter lock>` ã‚’ä¿æŒã—ã¦ãŠãå¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../c-api/memory.rst:179
msgid ""
"The default allocator is now pymalloc instead of system :c:func:`malloc`."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãŒã‚·ã‚¹ãƒ†ãƒ ã® :c:func:`malloc` ã‹ã‚‰ pymalloc ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../c-api/memory.rst:186
msgid ""
"Requesting zero bytes returns a distinct non-*NULL* pointer if possible, as "
"if ``PyMem_Malloc(1)`` had been called instead. The memory will not have "
"been initialized in any way."
msgstr ""
"0ãƒã‚¤ãƒˆã‚’è¦æ±‚ã™ã‚‹ã¨ã€ ``PyMem_Malloc(1)`` ãŒå‘¼ã°ã‚ŒãŸã¨ãã¨åŒã˜ã‚ˆã†ã«ã€å¯èƒ½ãªã‚‰ *NULL* ã§ãªã„ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚\n"
"ç¢ºä¿ã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªãƒ¼ã«ã¯ã„ã‹ãªã‚‹åˆæœŸåŒ–ã‚‚è¡Œã‚ã‚Œã¾ã›ã‚“ã€‚"

#: ../../c-api/memory.rst:197
msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-*NULL* pointer if possible, as if ``PyMem_Calloc(1, 1)`` had been called"
" instead."
msgstr ""
"è¦ç´ æ•°ã‹è¦ç´ ã®ã‚µã‚¤ã‚ºãŒ0ãƒã‚¤ãƒˆã®è¦æ±‚ã«å¯¾ã—ã¦ã¯ã€å¯èƒ½ãªã‚‰ ``PyMem_Calloc(1, 1)`` ãŒå‘¼ã°ã‚ŒãŸã®ã¨åŒã˜ã‚ˆã†ã«ã€ãƒ¦ãƒ‹ãƒ¼ã‚¯ãª "
"*NULL* ã§ãªã„ãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/memory.rst:209
msgid ""
"If *p* is *NULL*, the call is equivalent to ``PyMem_Malloc(n)``; else if *n*"
" is equal to zero, the memory block is resized but is not freed, and the "
"returned pointer is non-*NULL*."
msgstr ""
"*p* ãŒ *NULL* ã®å ´åˆå‘¼ã³å‡ºã—ã¯ ``PyMem_Malloc(n)`` ã¨ç­‰ä¾¡ã§ã™ã€‚ãã†ã§ãªãã€ *n* "
"ãŒã‚¼ãƒ­ã«ç­‰ã—ã„å ´åˆã€ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã¯ãƒªã‚µã‚¤ã‚ºã•ã‚Œã¾ã™ãŒè§£æ”¾ã•ã‚Œã¾ã›ã‚“ã€‚è¿”ã•ã‚ŒãŸãƒã‚¤ãƒ³ã‚¿ã¯é *NULL* ã§ã™ã€‚"

#: ../../c-api/memory.rst:213
msgid ""
"Unless *p* is *NULL*, it must have been returned by a previous call to "
":c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` or :c:func:`PyMem_Calloc`."
msgstr ""
"*p* ãŒ *NULL* ã§ãªã„é™ã‚Šã€*p* ã¯ãã‚Œã‚ˆã‚Šå‰ã® :c:func:`PyMem_Malloc`, "
":c:func:`PyMem_Realloc` ã¾ãŸã¯ :c:func:`PyMem_Calloc` ã®å‘¼ã³å‡ºã—ã«ã‚ˆã‚Šè¿”ã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/memory.rst:216
msgid ""
"If the request fails, :c:func:`PyMem_Realloc` returns *NULL* and *p* remains"
" a valid pointer to the previous memory area."
msgstr ""
"è¦æ±‚ãŒå¤±æ•—ã—ãŸå ´åˆ :c:func:`PyMem_Realloc` ã¯ *NULL* ã‚’è¿”ã—ã€ *p* "
"ã¯å‰ã®ãƒ¡ãƒ¢ãƒªã‚¨ãƒªã‚¢ã‚’ã•ã™æœ‰åŠ¹ãªãƒã‚¤ãƒ³ã‚¿ã®ã¾ã¾ã§ã™ã€‚"

#: ../../c-api/memory.rst:222
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a"
" previous call to :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` or "
":c:func:`PyMem_Calloc`.  Otherwise, or if ``PyMem_Free(p)`` has been called "
"before, undefined behavior occurs."
msgstr ""
"*p* ãŒæŒ‡ã™ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã—ã¾ã™ã€‚ *p* ã¯ä»¥å‰å‘¼ã³å‡ºã—ãŸ :c:func:`PyMem_Malloc`ã€ "
":c:func:`PyMem_Realloc`ã€ã¾ãŸã¯ :c:func:`PyMem_Calloc` ã®è¿”ã—ãŸå€¤ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã‚„ "
"``PyMem_Free(p)`` ã‚’å‘¼ã³å‡ºã—ãŸå¾Œã ã£ãŸå ´åˆã€æœªå®šç¾©ã®å‹•ä½œã«ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/memory.rst:229
msgid ""
"The following type-oriented macros are provided for convenience.  Note  that"
" *TYPE* refers to any C type."
msgstr "ä»¥ä¸‹ã«æŒ™ã’ã‚‹å‹å¯¾è±¡ã®ãƒã‚¯ãƒ­ã¯åˆ©ä¾¿æ€§ã®ãŸã‚ã«æä¾›ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã§ã™ã€‚*TYPE* ã¯ä»»æ„ã® C ã®å‹ã‚’è¡¨ã—ã¾ã™ã€‚"

#: ../../c-api/memory.rst:235
msgid ""
"Same as :c:func:`PyMem_Malloc`, but allocates ``(n * sizeof(TYPE))`` bytes "
"of memory.  Returns a pointer cast to :c:type:`TYPE\\*`.  The memory will "
"not have been initialized in any way."
msgstr ""
":c:func:`PyMem_Malloc` ã¨åŒã˜ã§ã™ãŒã€ ``(n * sizeof(TYPE))`` ãƒã‚¤ãƒˆã®ãƒ¡ãƒ¢ãƒªã‚’ç¢ºä¿ã—ã¾ã™ã€‚ "
":c:type:`TYPE\\*` ã«å‹ã‚­ãƒ£ã‚¹ãƒˆã•ã‚ŒãŸãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚ãƒ¡ãƒ¢ãƒªã«ã¯ä½•ã®åˆæœŸåŒ–ã‚‚è¡Œã‚ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"

#: ../../c-api/memory.rst:242
msgid ""
"Same as :c:func:`PyMem_Realloc`, but the memory block is resized to ``(n * "
"sizeof(TYPE))`` bytes.  Returns a pointer cast to :c:type:`TYPE\\*`. On "
"return, *p* will be a pointer to the new memory area, or *NULL* in the event"
" of failure."
msgstr ""
":c:func:`PyMem_Realloc` ã¨åŒã˜ã§ã™ãŒã€ ``(n * sizeof(TYPE))`` ãƒã‚¤ãƒˆã«ã‚µã‚¤ã‚ºå¤‰æ›´ã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªã‚’ç¢ºä¿ã—ã¾ã™ã€‚\n"
":c:type:`TYPE\\*` ã«å‹ã‚­ãƒ£ã‚¹ãƒˆã•ã‚ŒãŸãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚\n"
"é–¢æ•°ãŒçµ‚ã‚ã£ãŸã¨ãã€ *p* ã¯æ–°ã—ã„ãƒ¡ãƒ¢ãƒªé ˜åŸŸã®ãƒã‚¤ãƒ³ã‚¿ã‹ã€å¤±æ•—ã—ãŸå ´åˆã¯ *NULL* ã«ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/memory.rst:247
msgid ""
"This is a C preprocessor macro; *p* is always reassigned.  Save the original"
" value of *p* to avoid losing memory when handling errors."
msgstr ""
"ã“ã‚Œã¯ C ãƒ—ãƒªãƒ—ãƒ­ã‚»ãƒƒã‚µãƒã‚¯ãƒ­ã§ã™ã€‚*p* ã¯å¸¸ã«å†ä»£å…¥ã•ã‚Œã¾ã™ã€‚ã‚¨ãƒ©ãƒ¼å‡¦ç†æ™‚ã«ãƒ¡ãƒ¢ãƒªã‚’å¤±ã†ã®ã‚’é¿ã‘ã‚‹ã«ã¯ *p* ã®å…ƒã®å€¤ã‚’ä¿å­˜ã—ã¦ãã ã•ã„ã€‚"

#: ../../c-api/memory.rst:253
msgid "Same as :c:func:`PyMem_Free`."
msgstr ":c:func:`PyMem_Free` ã¨åŒã˜ã§ã™ã€‚"

#: ../../c-api/memory.rst:255
msgid ""
"In addition, the following macro sets are provided for calling the Python "
"memory allocator directly, without involving the C API functions listed "
"above. However, note that their use does not preserve binary compatibility "
"across Python versions and is therefore deprecated in extension modules."
msgstr ""
"ä¸Šè¨˜ã«åŠ ãˆã¦ã€C API é–¢æ•°ã‚’ä»‹ã™ã‚‹ã“ã¨ãªã Python "
"ãƒ¡ãƒ¢ãƒªæ“ä½œé–¢æ•°ã‚’ç›´æ¥å‘¼ã³å‡ºã™ãŸã‚ã®ä»¥ä¸‹ã®ãƒã‚¯ãƒ­ã‚»ãƒƒãƒˆãŒæä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚ãŸã ã—ã€ã“ã‚Œã‚‰ã®ãƒã‚¯ãƒ­ã¯ Python "
"ãƒãƒ¼ã‚¸ãƒ§ãƒ³é–“ã§ã®ãƒã‚¤ãƒŠãƒªäº’æ›æ€§ã‚’ä¿ã¦ãšã€ãã‚Œã‚†ãˆã«æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯æ’¤å»ƒã•ã‚Œã¦ã„ã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../c-api/memory.rst:260
msgid "``PyMem_MALLOC(size)``"
msgstr "``PyMem_MALLOC(size)``"

#: ../../c-api/memory.rst:261
msgid "``PyMem_NEW(type, size)``"
msgstr "``PyMem_NEW(type, size)``"

#: ../../c-api/memory.rst:262
msgid "``PyMem_REALLOC(ptr, size)``"
msgstr "``PyMem_REALLOC(ptr, size)``"

#: ../../c-api/memory.rst:263
msgid "``PyMem_RESIZE(ptr, type, size)``"
msgstr "``PyMem_RESIZE(ptr, type, size)``"

#: ../../c-api/memory.rst:264
msgid "``PyMem_FREE(ptr)``"
msgstr "``PyMem_FREE(ptr)``"

#: ../../c-api/memory.rst:265
msgid "``PyMem_DEL(ptr)``"
msgstr "``PyMem_DEL(ptr)``"

#: ../../c-api/memory.rst:269
msgid "Object allocators"
msgstr ""

#: ../../c-api/memory.rst:275
msgid ""
"The :ref:`default object allocator <default-memory-allocators>` uses the "
":ref:`pymalloc memory allocator <pymalloc>`."
msgstr ""

#: ../../c-api/memory.rst:288
msgid ""
"Requesting zero bytes returns a distinct non-*NULL* pointer if possible, as "
"if ``PyObject_Malloc(1)`` had been called instead. The memory will not have "
"been initialized in any way."
msgstr ""

#: ../../c-api/memory.rst:299
msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-*NULL* pointer if possible, as if ``PyObject_Calloc(1, 1)`` had been "
"called instead."
msgstr ""

#: ../../c-api/memory.rst:311
msgid ""
"If *p* is *NULL*, the call is equivalent to ``PyObject_Malloc(n)``; else if "
"*n* is equal to zero, the memory block is resized but is not freed, and the "
"returned pointer is non-*NULL*."
msgstr ""

#: ../../c-api/memory.rst:315
msgid ""
"Unless *p* is *NULL*, it must have been returned by a previous call to "
":c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` or "
":c:func:`PyObject_Calloc`."
msgstr ""

#: ../../c-api/memory.rst:318
msgid ""
"If the request fails, :c:func:`PyObject_Realloc` returns *NULL* and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""

#: ../../c-api/memory.rst:324
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a"
" previous call to :c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` or "
":c:func:`PyObject_Calloc`.  Otherwise, or if ``PyObject_Free(p)`` has been "
"called before, undefined behavior occurs."
msgstr ""

#: ../../c-api/memory.rst:335
msgid "Default Memory Allocators"
msgstr ""

#: ../../c-api/memory.rst:337
msgid "Default memory allocators:"
msgstr ""

#: ../../c-api/memory.rst:340
msgid "Configuration"
msgstr "Configuration"

#: ../../c-api/memory.rst:340
msgid "Name"
msgstr "åå‰"

#: ../../c-api/memory.rst:340
msgid "PyMem_RawMalloc"
msgstr ""

#: ../../c-api/memory.rst:340
msgid "PyMem_Malloc"
msgstr ""

#: ../../c-api/memory.rst:340
msgid "PyObject_Malloc"
msgstr ""

#: ../../c-api/memory.rst:342
msgid "Release build"
msgstr ""

#: ../../c-api/memory.rst:342
msgid "``\"pymalloc\"``"
msgstr ""

#: ../../c-api/memory.rst:342 ../../c-api/memory.rst:344
#: ../../c-api/memory.rst:344 ../../c-api/memory.rst:344
msgid "``malloc``"
msgstr ""

#: ../../c-api/memory.rst:342 ../../c-api/memory.rst:342
msgid "``pymalloc``"
msgstr ""

#: ../../c-api/memory.rst:343
msgid "Debug build"
msgstr ""

#: ../../c-api/memory.rst:343
msgid "``\"pymalloc_debug\"``"
msgstr ""

#: ../../c-api/memory.rst:343 ../../c-api/memory.rst:345
#: ../../c-api/memory.rst:345 ../../c-api/memory.rst:345
msgid "``malloc`` + debug"
msgstr ""

#: ../../c-api/memory.rst:343 ../../c-api/memory.rst:343
msgid "``pymalloc`` + debug"
msgstr ""

#: ../../c-api/memory.rst:344 ../../c-api/memory.rst:345
msgid "Release build, without pymalloc"
msgstr ""

#: ../../c-api/memory.rst:344
msgid "``\"malloc\"``"
msgstr ""

#: ../../c-api/memory.rst:345
msgid "``\"malloc_debug\"``"
msgstr ""

#: ../../c-api/memory.rst:348
msgid "Legend:"
msgstr ""

#: ../../c-api/memory.rst:350
msgid "Name: value for :envvar:`PYTHONMALLOC` environment variable"
msgstr ""

#: ../../c-api/memory.rst:351
msgid ""
"``malloc``: system allocators from the standard C library, C functions: "
":c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` and :c:func:`free`"
msgstr ""

#: ../../c-api/memory.rst:353
msgid "``pymalloc``: :ref:`pymalloc memory allocator <pymalloc>`"
msgstr ""

#: ../../c-api/memory.rst:354
msgid "\"+ debug\": with debug hooks installed by :c:func:`PyMem_SetupDebugHooks`"
msgstr ""

#: ../../c-api/memory.rst:358
msgid "Customize Memory Allocators"
msgstr "ãƒ¡ãƒ¢ãƒªã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹"

#: ../../c-api/memory.rst:364
msgid ""
"Structure used to describe a memory block allocator. The structure has four "
"fields:"
msgstr "ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã‚’è¨˜è¿°ã™ã‚‹ãŸã‚ã®æ§‹é€ ä½“ã§ã™ã€‚4ã¤ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒã¡ã¾ã™:"

#: ../../c-api/memory.rst:368 ../../c-api/memory.rst:506
msgid "Field"
msgstr "ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰"

#: ../../c-api/memory.rst:368 ../../c-api/memory.rst:506
msgid "Meaning"
msgstr "æ„å‘³"

#: ../../c-api/memory.rst:370 ../../c-api/memory.rst:508
msgid "``void *ctx``"
msgstr "``void *ctx``"

#: ../../c-api/memory.rst:370 ../../c-api/memory.rst:508
msgid "user context passed as first argument"
msgstr "ç¬¬ä¸€å¼•æ•°ã¨ã—ã¦æ¸¡ã•ã‚Œã‚‹ãƒ¦ãƒ¼ã‚¶ã‚³ãƒ³ãƒ†ã‚¯ã‚¹ãƒˆ"

#: ../../c-api/memory.rst:372
msgid "``void* malloc(void *ctx, size_t size)``"
msgstr "``void* malloc(void *ctx, size_t size)``"

#: ../../c-api/memory.rst:372
msgid "allocate a memory block"
msgstr "ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‚’å‰²ã‚Šå½“ã¦ã¾ã™"

#: ../../c-api/memory.rst:374
msgid "``void* calloc(void *ctx, size_t nelem, size_t elsize)``"
msgstr "``void* calloc(void *ctx, size_t nelem, size_t elsize)``"

#: ../../c-api/memory.rst:374
msgid "allocate a memory block initialized with zeros"
msgstr "0ã§åˆæœŸåŒ–ã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‚’å‰²ã‚Šå½“ã¦ã¾ã™"

#: ../../c-api/memory.rst:377
msgid "``void* realloc(void *ctx, void *ptr, size_t new_size)``"
msgstr "``void* realloc(void *ctx, void *ptr, size_t new_size)``"

#: ../../c-api/memory.rst:377
msgid "allocate or resize a memory block"
msgstr "ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‚’å‰²ã‚Šå½“ã¦ã‚‹ã‹ãƒªã‚µã‚¤ã‚ºã—ã¾ã™"

#: ../../c-api/memory.rst:379
msgid "``void free(void *ctx, void *ptr)``"
msgstr "``void free(void *ctx, void *ptr)``"

#: ../../c-api/memory.rst:379
msgid "free a memory block"
msgstr "ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã™ã‚‹"

#: ../../c-api/memory.rst:382
msgid ""
"The :c:type:`PyMemAllocator` structure was renamed to "
":c:type:`PyMemAllocatorEx` and a new ``calloc`` field was added."
msgstr ""
":c:type:`PyMemAllocator` æ§‹é€ ä½“ãŒ :c:type:`PyMemAllocatorEx` ã«ãƒªãƒãƒ¼ãƒ ã•ã‚ŒãŸä¸Šã§ "
"``calloc`` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../c-api/memory.rst:389
msgid "Enum used to identify an allocator domain. Domains:"
msgstr "ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’åŒå®šã™ã‚‹ãŸã‚ã®åˆ—æŒ™å‹ã§ã™ã€‚ãƒ‰ãƒ¡ã‚¤ãƒ³ã¯:"

#: ../../c-api/memory.rst:393 ../../c-api/memory.rst:402
#: ../../c-api/memory.rst:411
msgid "Functions:"
msgstr "é–¢æ•°:"

#: ../../c-api/memory.rst:395
msgid ":c:func:`PyMem_RawMalloc`"
msgstr ":c:func:`PyMem_RawMalloc`"

#: ../../c-api/memory.rst:396
msgid ":c:func:`PyMem_RawRealloc`"
msgstr ":c:func:`PyMem_RawRealloc`"

#: ../../c-api/memory.rst:397
msgid ":c:func:`PyMem_RawCalloc`"
msgstr ":c:func:`PyMem_RawCalloc`"

#: ../../c-api/memory.rst:398
msgid ":c:func:`PyMem_RawFree`"
msgstr ":c:func:`PyMem_RawFree`"

#: ../../c-api/memory.rst:404
msgid ":c:func:`PyMem_Malloc`,"
msgstr ":c:func:`PyMem_Malloc`,"

#: ../../c-api/memory.rst:405
msgid ":c:func:`PyMem_Realloc`"
msgstr ":c:func:`PyMem_Realloc`"

#: ../../c-api/memory.rst:406
msgid ":c:func:`PyMem_Calloc`"
msgstr ":c:func:`PyMem_Calloc`"

#: ../../c-api/memory.rst:407
msgid ":c:func:`PyMem_Free`"
msgstr ":c:func:`PyMem_Free`"

#: ../../c-api/memory.rst:413
msgid ":c:func:`PyObject_Malloc`"
msgstr ":c:func:`PyObject_Malloc`"

#: ../../c-api/memory.rst:414
msgid ":c:func:`PyObject_Realloc`"
msgstr ":c:func:`PyObject_Realloc`"

#: ../../c-api/memory.rst:415
msgid ":c:func:`PyObject_Calloc`"
msgstr ":c:func:`PyObject_Calloc`"

#: ../../c-api/memory.rst:416
msgid ":c:func:`PyObject_Free`"
msgstr ":c:func:`PyObject_Free`"

#: ../../c-api/memory.rst:420
msgid "Get the memory block allocator of the specified domain."
msgstr "æŒ‡å®šã•ã‚ŒãŸãƒ‰ãƒ¡ã‚¤ãƒ³ã®ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¾ã™ã€‚"

#: ../../c-api/memory.rst:425
msgid "Set the memory block allocator of the specified domain."
msgstr "æŒ‡å®šã•ã‚ŒãŸãƒ‰ãƒ¡ã‚¤ãƒ³ã®ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã‚’è¨­å®šã—ã¾ã™ã€‚"

#: ../../c-api/memory.rst:427
msgid ""
"The new allocator must return a distinct non-NULL pointer when requesting "
"zero bytes."
msgstr "æ–°ã—ã„ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã¯ã€0ãƒã‚¤ãƒˆã‚’è¦æ±‚ã•ã‚ŒãŸã¨ããƒ¦ãƒ‹ãƒ¼ã‚¯ãª NULL ã§ãªã„ãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/memory.rst:430
msgid ""
"For the :c:data:`PYMEM_DOMAIN_RAW` domain, the allocator must be thread-"
"safe: the :term:`GIL <global interpreter lock>` is not held when the "
"allocator is called."
msgstr ""
":c:data:`PYMEM_DOMAIN_RAW` ãƒ‰ãƒ¡ã‚¤ãƒ³ã§ã¯ã€ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“: ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã¨ã "
":term:`GIL <global interpreter lock>` ã¯ä¿æŒã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"

#: ../../c-api/memory.rst:434
msgid ""
"If the new allocator is not a hook (does not call the previous allocator), "
"the :c:func:`PyMem_SetupDebugHooks` function must be called to reinstall the"
" debug hooks on top on the new allocator."
msgstr ""
"æ–°ã—ã„ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãŒãƒ•ãƒƒã‚¯ã§ãªã„ (1ã¤å‰ã®ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã‚’å‘¼ã³å‡ºã•ãªã„) å ´åˆã€ :c:func:`PyMem_SetupDebugHooks` "
"é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã€æ–°ã—ã„ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã®ä¸Šã«ãƒ‡ãƒãƒƒã‚°ãƒ•ãƒƒã‚¯ã‚’å†åº¦è¨­ç½®ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/memory.rst:441
msgid "Setup hooks to detect bugs in the Python memory allocator functions."
msgstr "Python ãƒ¡ãƒ¢ãƒªã‚¢ãƒ­ã‚±ãƒ¼ã‚¿é–¢æ•°ã®ãƒã‚°ã‚’æ¤œå‡ºã™ã‚‹ãŸã‚ã®ãƒ•ãƒƒã‚¯ã‚’è¨­å®šã—ã¾ã™ã€‚"

#: ../../c-api/memory.rst:443
msgid ""
"Newly allocated memory is filled with the byte ``0xCB``, freed memory is "
"filled with the byte ``0xDB``."
msgstr "æ–°ãŸã«å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸãƒ¡ãƒ¢ãƒªã¯ãƒã‚¤ãƒˆ ``0xCB`` ã§åŸ‹ã‚ã‚‰ã‚Œã€è§£æ”¾ã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªã¯ãƒã‚¤ãƒˆ ``0xDB`` ã§åŸ‹ã‚ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../c-api/memory.rst:446
msgid "Runtime checks:"
msgstr "å®Ÿè¡Œæ™‚ãƒã‚§ãƒƒã‚¯:"

#: ../../c-api/memory.rst:448
msgid ""
"Detect API violations, ex: :c:func:`PyObject_Free` called on a buffer "
"allocated by :c:func:`PyMem_Malloc`"
msgstr ""
"API é•åã‚’æ¤œå‡ºã—ã¾ã™ã€‚ä¾‹: :c:func:`PyMem_Malloc` ãŒå‰²ã‚Šå½“ã¦ãŸãƒãƒƒãƒ•ã‚¡ã«å¯¾ã—ã¦ "
":c:func:`PyObject_Free` ã‚’å‘¼ã³ã ã—ãŸã€‚"

#: ../../c-api/memory.rst:450
msgid "Detect write before the start of the buffer (buffer underflow)"
msgstr "ãƒãƒƒãƒ•ã‚¡ã®é–‹å§‹å‰ã®æ›¸ãè¾¼ã¿ (ãƒãƒƒãƒ•ã‚¡ã‚¢ãƒ³ãƒ€ãƒ¼ãƒ•ãƒ­ãƒ¼) ã‚’æ¤œå‡ºã—ã¾ã™"

#: ../../c-api/memory.rst:451
msgid "Detect write after the end of the buffer (buffer overflow)"
msgstr "ãƒãƒƒãƒ•ã‚¡çµ‚äº†å¾Œã®æ›¸ãè¾¼ã¿ (ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼) ã‚’æ¤œå‡ºã—ã¾ã™"

#: ../../c-api/memory.rst:452
msgid ""
"Check that the :term:`GIL <global interpreter lock>` is held when allocator "
"functions of :c:data:`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`) and "
":c:data:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) domains are called"
msgstr ""

#: ../../c-api/memory.rst:457
msgid ""
"On error, the debug hooks use the :mod:`tracemalloc` module to get the "
"traceback where a memory block was allocated. The traceback is only "
"displayed if :mod:`tracemalloc` is tracing Python memory allocations and the"
" memory block was traced."
msgstr ""

#: ../../c-api/memory.rst:462
msgid ""
"These hooks are :ref:`installed by default <default-memory-allocators>` if "
"Python is compiled in debug mode. The :envvar:`PYTHONMALLOC` environment "
"variable can be used to install debug hooks on a Python compiled in release "
"mode."
msgstr ""

#: ../../c-api/memory.rst:467
msgid ""
"This function now also works on Python compiled in release mode. On error, "
"the debug hooks now use :mod:`tracemalloc` to get the traceback where a "
"memory block was allocated. The debug hooks now also check if the GIL is "
"held when functions of :c:data:`PYMEM_DOMAIN_OBJ` and "
":c:data:`PYMEM_DOMAIN_MEM` domains are called."
msgstr ""

#: ../../c-api/memory.rst:478
msgid "The pymalloc allocator"
msgstr "pymalloc ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿"

#: ../../c-api/memory.rst:480
msgid ""
"Python has a *pymalloc* allocator optimized for small objects (smaller or "
"equal to 512 bytes) with a short lifetime. It uses memory mappings called "
"\"arenas\" with a fixed size of 256 KiB. It falls back to "
":c:func:`PyMem_RawMalloc` and :c:func:`PyMem_RawRealloc` for allocations "
"larger than 512 bytes."
msgstr ""

#: ../../c-api/memory.rst:485
msgid ""
"*pymalloc* is the :ref:`default allocator <default-memory-allocators>` of "
"the :c:data:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) and "
":c:data:`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`) domains."
msgstr ""

#: ../../c-api/memory.rst:489
msgid "The arena allocator uses the following functions:"
msgstr "ã‚¢ãƒªãƒ¼ãƒŠã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã¯ã€æ¬¡ã®é–¢æ•°ã‚’ä½¿ã„ã¾ã™:"

#: ../../c-api/memory.rst:491
msgid ":c:func:`VirtualAlloc` and :c:func:`VirtualFree` on Windows,"
msgstr "Windows ã§ã¯ :c:func:`VirtualAlloc` ã¨ :c:func:`VirtualFree`ã€"

#: ../../c-api/memory.rst:492
msgid ":c:func:`mmap` and :c:func:`munmap` if available,"
msgstr "åˆ©ç”¨ã§ãã‚‹å ´åˆã€:c:func:`mmap` ã¨ :c:func:`munmap`ã€"

#: ../../c-api/memory.rst:493
msgid ":c:func:`malloc` and :c:func:`free` otherwise."
msgstr "ãã‚Œä»¥å¤–ã®å ´åˆã¯ :c:func:`malloc` ã¨ :c:func:`free`ã€‚"

#: ../../c-api/memory.rst:496
msgid "Customize pymalloc Arena Allocator"
msgstr "pymalloc ã‚¢ãƒªãƒ¼ãƒŠã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º"

#: ../../c-api/memory.rst:502
msgid ""
"Structure used to describe an arena allocator. The structure has three "
"fields:"
msgstr "ã‚¢ãƒªãƒ¼ãƒŠã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã‚’è¨˜è¿°ã™ã‚‹ãŸã‚ã®æ§‹é€ ä½“ã§ã™ã€‚3ã¤ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒã¡ã¾ã™:"

#: ../../c-api/memory.rst:510
msgid "``void* alloc(void *ctx, size_t size)``"
msgstr "``void* alloc(void *ctx, size_t size)``"

#: ../../c-api/memory.rst:510
msgid "allocate an arena of size bytes"
msgstr "size ãƒã‚¤ãƒˆã®ã‚¢ãƒªãƒ¼ãƒŠã‚’å‰²ã‚Šå½“ã¦ã¾ã™"

#: ../../c-api/memory.rst:512
msgid "``void free(void *ctx, size_t size, void *ptr)``"
msgstr "``void free(void *ctx, size_t size, void *ptr)``"

#: ../../c-api/memory.rst:512
msgid "free an arena"
msgstr "ã‚¢ãƒªãƒ¼ãƒŠã‚’è§£æ”¾ã—ã¾ã™"

#: ../../c-api/memory.rst:517
msgid "Get the arena allocator."
msgstr "ã‚¢ãƒªãƒ¼ãƒŠã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¾ã™ã€‚"

#: ../../c-api/memory.rst:521
msgid "Set the arena allocator."
msgstr "ã‚¢ãƒªãƒ¼ãƒŠã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã‚’è¨­å®šã—ã¾ã™ã€‚"

#: ../../c-api/memory.rst:525
msgid "tracemalloc C API"
msgstr ""

#: ../../c-api/memory.rst:549
msgid "Examples"
msgstr "ä½¿ç”¨ä¾‹"

#: ../../c-api/memory.rst:551
msgid ""
"Here is the example from section :ref:`memoryoverview`, rewritten so that "
"the I/O buffer is allocated from the Python heap by using the first function"
" set::"
msgstr ""
"æœ€åˆã«è¿°ã¹ãŸé–¢æ•°ã‚»ãƒƒãƒˆã‚’ä½¿ã£ã¦ã€ :ref:`memoryoverview` ç¯€ã®ä¾‹ã‚’ Python ãƒ’ãƒ¼ãƒ—ã« I/O "
"ãƒãƒƒãƒ•ã‚¡ã‚’ãƒ¡ãƒ¢ãƒªç¢ºä¿ã™ã‚‹ã‚ˆã†ã«æ›¸ãæ›ãˆãŸã‚‚ã®ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™::"

#: ../../c-api/memory.rst:564
msgid "The same code using the type-oriented function set::"
msgstr "åŒã˜ã‚³ãƒ¼ãƒ‰ã‚’å‹å¯¾è±¡ã®é–¢æ•°ã‚»ãƒƒãƒˆã§æ›¸ã„ãŸã‚‚ã®ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™::"

#: ../../c-api/memory.rst:576
msgid ""
"Note that in the two examples above, the buffer is always manipulated via "
"functions belonging to the same set. Indeed, it is required to use the same "
"memory API family for a given memory block, so that the risk of mixing "
"different allocators is reduced to a minimum. The following code sequence "
"contains two errors, one of which is labeled as *fatal* because it mixes two"
" different allocators operating on different heaps. ::"
msgstr ""
"ä¸Šã®äºŒã¤ã®ä¾‹ã§ã¯ã€ãƒãƒƒãƒ•ã‚¡ã‚’å¸¸ã«åŒã˜é–¢æ•°ã‚»ãƒƒãƒˆã«å±ã™ã‚‹é–¢æ•°ã§æ“ä½œã—ã¦ã„ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚å®Ÿéš›ã€ã‚ã‚‹ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã«å¯¾ã™ã‚‹æ“ä½œã¯ã€ç•°ãªã‚‹ãƒ¡ãƒ¢ãƒªæ“ä½œæ©Ÿæ§‹ã‚’æ··ç”¨ã™ã‚‹å±é™ºã‚’æ¸›ã‚‰ã™ãŸã‚ã«ã€åŒã˜ãƒ¡ãƒ¢ãƒª"
" API "
"ãƒ•ã‚¡ãƒŸãƒªã‚’ä½¿ã£ã¦è¡Œã†ã“ã¨ãŒå¿…è¦ã§ã™ã€‚ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã«ã¯äºŒã¤ã®ã‚¨ãƒ©ãƒ¼ãŒã‚ã‚Šã€ãã®ã†ã¡ã®ä¸€ã¤ã«ã¯ç•°ãªã‚‹ãƒ’ãƒ¼ãƒ—ã‚’æ“ä½œã™ã‚‹åˆ¥ã®ãƒ¡ãƒ¢ãƒªæ“ä½œé–¢æ•°ã‚’æ··ç”¨ã—ã¦ã„ã‚‹ã®ã§ "
"*è‡´å‘½çš„ (Fatal)* ã¨ãƒ©ãƒ™ãƒ«ã¥ã‘ã‚’ã—ã¦ã„ã¾ã™ã€‚ ::"

#: ../../c-api/memory.rst:591
msgid ""
"In addition to the functions aimed at handling raw memory blocks from the "
"Python heap, objects in Python are allocated and released with "
":c:func:`PyObject_New`, :c:func:`PyObject_NewVar` and "
":c:func:`PyObject_Del`."
msgstr ""
"ç´ ã®ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‚’ Python ãƒ’ãƒ¼ãƒ—ä¸Šã§æ“ä½œã™ã‚‹é–¢æ•°ã«åŠ ãˆã€ :c:func:`PyObject_New` ã€ "
":c:func:`PyObject_NewVar` ã€ãŠã‚ˆã³ :c:func:`PyObject_Del` ã‚’ä½¿ã†ã¨ã€ Python "
"ã«ãŠã‘ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ¡ãƒ¢ãƒªç¢ºä¿ã—ãŸã‚Šè§£æ”¾ã—ãŸã‚Šã§ãã¾ã™ã€‚"

#: ../../c-api/memory.rst:595
msgid ""
"These will be explained in the next chapter on defining and implementing new"
" object types in C."
msgstr "ã“ã‚Œã‚‰ã®é–¢æ•°ã«ã¤ã„ã¦ã¯ã€æ¬¡ç« ã® C ã«ã‚ˆã‚‹æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã®å®šç¾©ã‚„å®Ÿè£…ã«é–¢ã™ã‚‹è¨˜è¿°ã®ä¸­ã§èª¬æ˜ã—ã¾ã™ã€‚"
