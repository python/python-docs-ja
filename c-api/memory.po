# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-20 13:43+0900\n"
"PO-Revision-Date: 2018-06-20 04:47+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/memory.rst:8
msgid "Memory Management"
msgstr "ãƒ¡ãƒ¢ãƒªç®¡ç†"

#: ../../c-api/memory.rst:17
msgid "Overview"
msgstr "æ¦‚è¦"

#: ../../c-api/memory.rst:19
msgid ""
"Memory management in Python involves a private heap containing all Python "
"objects and data structures. The management of this private heap is ensured "
"internally by the *Python memory manager*.  The Python memory manager has "
"different components which deal with various dynamic storage management "
"aspects, like sharing, segmentation, preallocation or caching."
msgstr "Python ã«ãŠã‘ã‚‹ãƒ¡ãƒ¢ãƒªç®¡ç†ã«ã¯ã€å…¨ã¦ã® Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ãƒ‡ãƒ¼ã‚¿æ§‹é€ ãŒå…¥ã£ãŸãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ’ãƒ¼ãƒ— (private heap) ãŒå¿…é ˆã§ã™ã€‚ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ’ãƒ¼ãƒ—ã®ç®¡ç†ã¯ã€å†…éƒ¨çš„ã«ã¯ *Python ãƒ¡ãƒ¢ãƒªãƒãƒãƒ¼ã‚¸ãƒ£ (Python memory manager)* ãŒç¢ºå®Ÿã«è¡Œã„ã¾ã™ã€‚Python ãƒ¡ãƒ¢ãƒªãƒãƒãƒ¼ã‚¸ãƒ£ã«ã¯ã€å…±æœ‰ (sharing)ã€ã‚»ã‚°ãƒ¡ãƒ³ãƒˆåˆ†å‰² (segmentation)ã€äº‹å‰å‰²ã‚Šå½“ã¦ (preallocation)ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥åŒ– (caching) ã¨ã„ã£ãŸã€æ§˜ã€…ãªå‹•çš„è¨˜æ†¶ç®¡ç†ã®å´é¢ã‚’æ‰±ã†ãŸã‚ã«ã€å€‹åˆ¥ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../c-api/memory.rst:25
msgid ""
"At the lowest level, a raw memory allocator ensures that there is enough "
"room in the private heap for storing all Python-related data by interacting "
"with the memory manager of the operating system. On top of the raw memory "
"allocator, several object-specific allocators operate on the same heap and "
"implement distinct memory management policies adapted to the peculiarities "
"of every object type. For example, integer objects are managed differently "
"within the heap than strings, tuples or dictionaries because integers imply "
"different storage requirements and speed/space tradeoffs. The Python memory "
"manager thus delegates some of the work to the object-specific allocators, "
"but ensures that the latter operate within the bounds of the private heap."
msgstr "æœ€ä½æ°´æº–å±¤ã§ã¯ã€ç´ ã®ãƒ¡ãƒ¢ãƒªæ“ä½œé–¢æ•° (raw memory allocator) ãŒã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ¡ãƒ¢ãƒªç®¡ç†æ©Ÿæ§‹ã¨ã‚„ã‚Šã¨ã‚Šã—ã¦ã€ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ’ãƒ¼ãƒ—å†…ã«Python é–¢é€£ã®å…¨ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’è¨˜æ†¶ã™ã‚‹ã®ã«ååˆ†ãªç©ºããŒã‚ã‚‹ã‹ã©ã†ã‹ç¢ºèªã—ã¾ã™ã€‚ç´ ã®ãƒ¡ãƒ¢ãƒªæ“ä½œé–¢æ•°ã®ä¸Šã«ã¯ã€ã„ãã¤ã‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå›ºæœ‰ã®ãƒ¡ãƒ¢ãƒªæ“ä½œé–¢æ•°ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã¯åŒã˜ãƒ’ãƒ¼ãƒ—ã‚’æ“ä½œã—ã€å„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹å›ºæœ‰ã®äº‹æƒ…ã«åˆã£ãŸãƒ¡ãƒ¢ãƒªç®¡ç†ãƒãƒªã‚·ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚ä¾‹ãˆã°ã€æ•´æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ–‡å­—åˆ—ã‚„ã‚¿ãƒ—ãƒ«ã€è¾æ›¸ã¨ã¯é•ã£ãŸã‚„ã‚Šæ–¹ã§ãƒ’ãƒ¼ãƒ—å†…ã§ç®¡ç†ã•ã‚Œã¾ã™ã€‚ã¨ã„ã†ã®ã‚‚ã€æ•´æ•°ã«ã¯å€¤ã‚’è¨˜æ†¶ã™ã‚‹ä¸Šã§ç‰¹åˆ¥ãªè¦ä»¶ãŒã‚ã‚Šã€é€Ÿåº¦/å®¹é‡ã®ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•ãŒå­˜åœ¨ã™ã‚‹ã‹ã‚‰ã§ã™ã€‚ã“ã®ã‚ˆã†ã«ã€Python ãƒ¡ãƒ¢ãƒªãƒãƒã‚¸ãƒ£ã¯ä½œæ¥­ã®ã„ãã¤ã‹ã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå›ºæœ‰ã®ãƒ¡ãƒ¢ãƒªæ“ä½œé–¢æ•°ã«å§”è­²ã—ã¾ã™ãŒã€ã“ã‚Œã‚‰ã®é–¢æ•°ãŒãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ’ãƒ¼ãƒ—ã‹ã‚‰ã¯ã¿å‡ºã—ã¦ãƒ¡ãƒ¢ãƒªç®¡ç†ã‚’è¡Œã‚ãªã„ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚"

#: ../../c-api/memory.rst:36
msgid ""
"It is important to understand that the management of the Python heap is "
"performed by the interpreter itself and that the user has no control over "
"it, even if they regularly manipulate object pointers to memory blocks "
"inside that heap.  The allocation of heap space for Python objects and other"
" internal buffers is performed on demand by the Python memory manager "
"through the Python/C API functions listed in this document."
msgstr ""

#: ../../c-api/memory.rst:49
msgid ""
"To avoid memory corruption, extension writers should never try to operate on"
" Python objects with the functions exported by the C library: "
":c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` and :c:func:`free`.  "
"This will result in  mixed calls between the C allocator and the Python "
"memory manager with fatal consequences, because they implement different "
"algorithms and operate on different heaps.  However, one may safely allocate"
" and release memory blocks with the C library allocator for individual "
"purposes, as shown in the following example::"
msgstr "ãƒ¡ãƒ¢ãƒªç®¡ç†ã®å´©å£Šã‚’é¿ã‘ã‚‹ãŸã‚ã€æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä½œè€…ã¯æ±ºã—ã¦ Python  ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ C ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒå…¬é–‹ã—ã¦ã„ã‚‹é–¢æ•°: :c:func:`malloc` ã€ :c:func:`calloc` ã€ :c:func:`realloc` ãŠã‚ˆã³ :c:func:`free` ã§æ“ä½œã—ã‚ˆã†ã¨ã—ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ã“ã†ã—ãŸé–¢æ•°ã‚’ä½¿ã†ã¨ã€C ã®ãƒ¡ãƒ¢ãƒªæ“ä½œé–¢æ•°ã¨ Python ãƒ¡ãƒ¢ãƒªãƒãƒãƒ¼ã‚¸ãƒ£ã¨ã®é–“ã§é–¢æ•°å‘¼ã³å‡ºã—ãŒäº¤éŒ¯ã—ã¾ã™ã€‚ C ã®ãƒ¡ãƒ¢ãƒªæ“ä½œé–¢æ•°ã¨Python ãƒ¡ãƒ¢ãƒªãƒãƒãƒ¼ã‚¸ãƒ£ã¯ç•°ãªã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§å®Ÿè£…ã•ã‚Œã¦ã„ã¦ã€ç•°ãªã‚‹ãƒ’ãƒ¼ãƒ—ã‚’æ“ä½œã™ã‚‹ãŸã‚ã€å‘¼ã³å‡ºã—ã®äº¤éŒ¯ã¯è‡´å‘½çš„ãªçµæœã‚’æ‹›ãã¾ã™ã€‚ã¨ã¯ã„ãˆã€å€‹åˆ¥ã®ç›®çš„ã®ãŸã‚ãªã‚‰ã€ C ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ¡ãƒ¢ãƒªæ“ä½œé–¢æ•°ã‚’ä½¿ã£ã¦å®‰å…¨ã«ãƒ¡ãƒ¢ãƒªã‚’ç¢ºä¿ã—ãŸã‚Šè§£æ”¾ã—ãŸã‚Šã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€ä»¥ä¸‹ãŒãã®ã‚ˆã†ãªä¾‹ã§ã™::"

#: ../../c-api/memory.rst:68
msgid ""
"In this example, the memory request for the I/O buffer is handled by the C "
"library allocator. The Python memory manager is involved only in the "
"allocation of the string object returned as a result."
msgstr "ã“ã®ä¾‹ã§ã¯ã€I/O ãƒãƒƒãƒ•ã‚¡ã«å¯¾ã™ã‚‹ãƒ¡ãƒ¢ãƒªè¦æ±‚ã¯ C ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ¡ãƒ¢ãƒªæ“ä½œé–¢æ•°ã‚’ä½¿ã£ã¦ã„ã¾ã™ã€‚Python ãƒ¡ãƒ¢ãƒªãƒãƒã‚¸ãƒ£ã¯æˆ»ã‚Šå€¤ã¨ã—ã¦è¿”ã•ã‚Œã‚‹æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç¢ºä¿ã™ã‚‹æ™‚ã«ã ã‘å¿…è¦ã§ã™ã€‚"

#: ../../c-api/memory.rst:72
msgid ""
"In most situations, however, it is recommended to allocate memory from the "
"Python heap specifically because the latter is under control of the Python "
"memory manager. For example, this is required when the interpreter is "
"extended with new object types written in C. Another reason for using the "
"Python heap is the desire to *inform* the Python memory manager about the "
"memory needs of the extension module. Even when the requested memory is used"
" exclusively for internal, highly-specific purposes, delegating all memory "
"requests to the Python memory manager causes the interpreter to have a more "
"accurate image of its memory footprint as a whole. Consequently, under "
"certain circumstances, the Python memory manager may or may not trigger "
"appropriate actions, like garbage collection, memory compaction or other "
"preventive procedures. Note that by using the C library allocator as shown "
"in the previous example, the allocated memory for the I/O buffer escapes "
"completely the Python memory manager."
msgstr "ã¨ã¯ã„ãˆã€ã»ã¨ã‚“ã©ã®çŠ¶æ³ã§ã¯ã€ãƒ¡ãƒ¢ãƒªã®æ“ä½œã¯ Python ãƒ’ãƒ¼ãƒ—ã«å›ºå®šã—ã¦è¡Œã†ã‚ˆã†å‹§ã‚ã¾ã™ã€‚ãªãœãªã‚‰ã€Python ãƒ’ãƒ¼ãƒ—ã¯ Python ãƒ¡ãƒ¢ãƒªãƒãƒã‚¸ãƒ£ã®ç®¡ç†ä¸‹ã«ã‚ã‚‹ã‹ã‚‰ã§ã™ã€‚ä¾‹ãˆã°ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’ C ã§æ›¸ã‹ã‚ŒãŸæ–°ãŸãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã§æ‹¡å¼µã™ã‚‹éš›ã«ã¯ã€ãƒ’ãƒ¼ãƒ—ã§ã®ãƒ¡ãƒ¢ãƒªç®¡ç†ãŒå¿…è¦ã§ã™ã€‚Python ãƒ’ãƒ¼ãƒ—ã‚’ä½¿ã£ãŸæ–¹ãŒã‚ˆã„ã‚‚ã†ä¸€ã¤ã®ç†ç”±ã¨ã—ã¦ã€æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå¿…è¦ã¨ã—ã¦ã„ã‚‹ãƒ¡ãƒ¢ãƒªã«ã¤ã„ã¦ Python ãƒ¡ãƒ¢ãƒªãƒãƒãƒ¼ã‚¸ãƒ£ã« *æƒ…å ±ã‚’æä¾›* ã—ã¦ã»ã—ã„ã¨ã„ã†ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ãŸã¨ãˆå¿…è¦ãªãƒ¡ãƒ¢ãƒªãŒå†…éƒ¨çš„ã‹ã¤éå¸¸ã«ç‰¹åŒ–ã—ãŸç”¨é€”ã«å¯¾ã—ã¦æ’ä»–çš„ã«ç”¨ã„ã‚‰ã‚Œã‚‹ã‚‚ã®ã ã¨ã—ã¦ã‚‚ã€å…¨ã¦ã®ãƒ¡ãƒ¢ãƒªæ“ä½œè¦æ±‚ã‚’ Python ãƒ¡ãƒ¢ãƒªãƒãƒãƒ¼ã‚¸ãƒ£ã«å§”è­²ã™ã‚Œã°ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ã‚ˆã‚Šæ­£ç¢ºãªãƒ¡ãƒ¢ãƒªãƒ•ãƒƒãƒˆãƒ—ãƒªãƒ³ãƒˆ (memory footprint) ã®å…¨ä½“åƒã‚’æŠŠæ¡ã§ãã¾ã™ã€‚ãã®çµæœã€ç‰¹å®šã®çŠ¶æ³ã§ã¯ã€Python ãƒ¡ãƒ¢ãƒªãƒãƒãƒ¼ã‚¸ãƒ£ãŒã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚„ãƒ¡ãƒ¢ãƒªã®ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆåŒ–ã€ãã®ä»–ä½•ã‚‰ã‹ã®äºˆé˜²æªç½®ã¨ã„ã£ãŸã€é©åˆ‡ãªå‹•ä½œã‚’ãƒˆãƒªã‚¬ã§ãã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ä¸Šã®ä¾‹ã§ç¤ºã—ãŸã‚ˆã†ã« C ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ¡ãƒ¢ãƒªæ“ä½œé–¢æ•°ã‚’ä½¿ã†ã¨ã€I/O ãƒãƒƒãƒ•ã‚¡ç”¨ã«ç¢ºä¿ã—ãŸãƒ¡ãƒ¢ãƒªã¯ Python ãƒ¡ãƒ¢ãƒªãƒãƒãƒ¼ã‚¸ãƒ£ã®ç®¡ç†ã‹ã‚‰å®Œå…¨ã«å¤–ã‚Œã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../c-api/memory.rst:90
msgid "Memory Interface"
msgstr "ãƒ¡ãƒ¢ãƒªã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹"

#: ../../c-api/memory.rst:92
msgid ""
"The following function sets, modeled after the ANSI C standard, but "
"specifying behavior when requesting zero bytes, are available for allocating"
" and releasing memory from the Python heap:"
msgstr "Python ãƒ’ãƒ¼ãƒ—ã«å¯¾ã—ã¦ãƒ¡ãƒ¢ãƒªã‚’ç¢ºä¿ã—ãŸã‚Šè§£æ”¾ã—ãŸã‚Šã™ã‚‹ãŸã‚ã«ã€ä»¥ä¸‹ã®é–¢æ•°ã‚»ãƒƒãƒˆãŒåˆ©ç”¨ã§ãã¾ã™ã€‚ã“ã‚Œã‚‰ã®é–¢æ•°ã¯ ANSI C æ¨™æº–ã«å¾“ã£ã¦ãƒ¢ãƒ‡ãƒ«åŒ–ã•ã‚Œã¦ã„ã¾ã™ãŒã€0 ãƒã‚¤ãƒˆã®é ˜åŸŸã‚’è¦æ±‚ã—ãŸéš›ã®å‹•ä½œã«ã¤ã„ã¦ã‚‚å®šç¾©ã—ã¦ã„ã¾ã™:"

#: ../../c-api/memory.rst:99
msgid ""
"Allocates *n* bytes and returns a pointer of type :c:type:`void\\*` to the "
"allocated memory, or *NULL* if the request fails. Requesting zero bytes "
"returns a distinct non-*NULL* pointer if possible, as if ``PyMem_Malloc(1)``"
" had been called instead. The memory will not have been initialized in any "
"way."
msgstr "*n* ãƒã‚¤ãƒˆã‚’ãƒ¡ãƒ¢ãƒªç¢ºä¿ã—ã€ç¢ºä¿ã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªã‚’æŒ‡ã™ :c:type:`void\\*`  å‹ã®ãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚ç¢ºä¿è¦æ±‚ã«å¤±æ•—ã—ãŸå ´åˆã«ã¯ *NULL* ã‚’ è¿”ã—ã¾ã™ã€‚ 0 ãƒã‚¤ãƒˆã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆã™ã‚‹ã¨ã€å¯èƒ½ãªã‚‰ã°ç‹¬ç«‹ã—ãŸé *NULL* ã®ãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®ãƒã‚¤ãƒ³ã‚¿ã¯ ``PyMem_Malloc(1)`` ã‚’ä»£ã‚ã‚Šã«å‘¼ã‚“ã ã¨ãã®ã‚ˆã†ãªãƒ¡ãƒ¢ãƒªé ˜åŸŸã‚’æŒ‡ã—ã¦ã„ã¾ã™ã€‚ç¢ºä¿ã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªé ˜åŸŸã¯ã„ã‹ãªã‚‹åˆæœŸåŒ–ã‚‚è¡Œã‚ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"

#: ../../c-api/memory.rst:107
msgid ""
"Resizes the memory block pointed to by *p* to *n* bytes. The contents will "
"be unchanged to the minimum of the old and the new sizes. If *p* is *NULL*, "
"the call is equivalent to ``PyMem_Malloc(n)``; else if *n* is equal to zero,"
" the memory block is resized but is not freed, and the returned pointer is "
"non-*NULL*.  Unless *p* is *NULL*, it must have been returned by a previous "
"call to :c:func:`PyMem_Malloc` or :c:func:`PyMem_Realloc`. If the request "
"fails, :c:func:`PyMem_Realloc` returns *NULL* and *p* remains a valid "
"pointer to the previous memory area."
msgstr "*p* ãŒæŒ‡ã—ã¦ã„ã‚‹ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‚’ *n* ãƒã‚¤ãƒˆã«ã‚µã‚¤ã‚ºå¤‰æ›´ã—ã¾ã™ã€‚ãƒ¡ãƒ¢ãƒªã®å†…å®¹ã®ã†ã¡ã€æ–°æ—§ã®ã‚µã‚¤ã‚ºã®ã†ã¡å°ã•ã„æ–¹ã¾ã§ã®é ˜åŸŸã¯å¤‰æ›´ã•ã‚Œã¾ã›ã‚“ã€‚ *p* ãŒ *NULL* ãªã‚‰ã°ã€ã“ã®é–¢æ•°ã¯ ``PyMem_Malloc(n)`` ã¨ç­‰ä¾¡ã«ãªã‚Šã¾ã™; *p* ãŒ *NULL* ã§ã¯ãªã *n* ãŒã‚¼ãƒ­ã«ç­‰ã—ã„å ´åˆã¯ã€ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã¯ã‚µã‚¤ã‚ºå¤‰æ›´ã•ã‚Œã¾ã™ãŒã€è§£æ”¾ã¯ã•ã‚Œãšã€é *NULL* ã®ãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚ *p* ã®å€¤ãŒ *NULL* ã§ãªã„ãªã‚‰ã°ã€ãã‚Œã¯ä»¥å‰å‘¼ã³å‡ºã—ãŸ :c:func:`PyMem_Malloc` ã‚„ :c:func:`PyMem_Realloc` ã®è¿”ã—ãŸå€¤ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãƒ¡ãƒ¢ãƒªè¦æ±‚ãŒå¤±æ•—ã—ãŸå ´åˆã¯ã€ :c:func:`PyMem_Realloc` ã¯ *NULL* ã‚’è¿”ã—ã€ *p* ã¯ä»¥å‰ã®ãƒ¡ãƒ¢ãƒªé ˜åŸŸã¸ã®æ­£ã—ã„ãƒã‚¤ãƒ³ã‚¿ã®ã¾ã¾ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/memory.rst:119
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a"
" previous call to :c:func:`PyMem_Malloc` or :c:func:`PyMem_Realloc`.  "
"Otherwise, or if ``PyMem_Free(p)`` has been called before, undefined "
"behavior occurs. If *p* is *NULL*, no operation is performed."
msgstr "*p* ãŒæŒ‡ã™ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã—ã¾ã™ã€‚ *p* ã¯ä»¥å‰å‘¼ã³å‡ºã—ãŸ :c:func:`PyMem_Malloc` ã‚„ :c:func:`PyMem_Realloc` ã®è¿”ã—ãŸå€¤ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã‚„ã€ ``PyMem_Free(p)`` ã‚’ å‘¼ã³å‡ºã—ãŸå¾Œã ã£ãŸå ´åˆã€æœªå®šç¾©ã®å‹•ä½œã«ãªã‚Šã¾ã™ã€‚ *p* ãŒ *NULL* ãªã‚‰ã€ä½•ã‚‚è¡Œã„ã¾ã›ã‚“ã€‚"

#: ../../c-api/memory.rst:124
msgid ""
"The following type-oriented macros are provided for convenience.  Note  that"
" *TYPE* refers to any C type."
msgstr "ä»¥ä¸‹ã«æŒ™ã’ã‚‹å‹å¯¾è±¡ã®ãƒã‚¯ãƒ­ã¯åˆ©ä¾¿æ€§ã®ãŸã‚ã«æä¾›ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã§ã™ã€‚*TYPE* ã¯ä»»æ„ã® C ã®å‹ã‚’è¡¨ã—ã¾ã™ã€‚"

#: ../../c-api/memory.rst:130
msgid ""
"Same as :c:func:`PyMem_Malloc`, but allocates ``(n * sizeof(TYPE))`` bytes "
"of memory.  Returns a pointer cast to :c:type:`TYPE\\*`.  The memory will "
"not have been initialized in any way."
msgstr ":c:func:`PyMem_Malloc` ã¨åŒã˜ã§ã™ãŒã€ ``(n * sizeof(TYPE))`` ãƒã‚¤ãƒˆã®ãƒ¡ãƒ¢ãƒªã‚’ç¢ºä¿ã—ã¾ã™ã€‚ :c:type:`TYPE\\*` ã«å‹ã‚­ãƒ£ã‚¹ãƒˆã•ã‚ŒãŸãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚ãƒ¡ãƒ¢ãƒªã«ã¯ä½•ã®åˆæœŸåŒ–ã‚‚è¡Œã‚ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"

#: ../../c-api/memory.rst:137
msgid ""
"Same as :c:func:`PyMem_Realloc`, but the memory block is resized to ``(n * "
"sizeof(TYPE))`` bytes.  Returns a pointer cast to :c:type:`TYPE\\*`. On "
"return, *p* will be a pointer to the new memory area, or *NULL* in the event"
" of failure.  This is a C preprocessor macro; p is always reassigned.  Save "
"the original value of p to avoid losing memory when handling errors."
msgstr ":c:func:`PyMem_Realloc` ã¨åŒã˜ã§ã™ãŒã€ ``(n * sizeof(TYPE))`` ãƒã‚¤ãƒˆã«ã‚µã‚¤ã‚ºå¤‰æ›´ã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªã‚’ç¢ºä¿ã—ã¾ã™ã€‚ :c:type:`TYPE\\*` ã«å‹ã‚­ãƒ£ã‚¹ãƒˆã•ã‚ŒãŸãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚é–¢æ•°ãŒçµ‚ã‚ã£ãŸã¨ãã€ *p* ã¯æ–°ã—ã„ãƒ¡ãƒ¢ãƒªé ˜åŸŸã®ãƒã‚¤ãƒ³ã‚¿ã‹ã€å¤±æ•—ã—ãŸå ´åˆã¯ *NULL* ã«ãªã‚Šã¾ã™ã€‚ã“ã‚Œã¯ C ãƒ—ãƒªãƒ—ãƒ­ã‚»ãƒƒã‚µã®ãƒã‚¯ãƒ­ã§ã€ p ã¯å¸¸ã«ä¸Šæ›¸ãã•ã‚Œã¾ã™ã€‚ã‚¨ãƒ©ãƒ¼ã‚’å‡¦ç†ã™ã‚‹ã¨ãã«ãƒ¡ãƒ¢ãƒªã‚’å¤±ã†äº‹ã‚’é¿ã‘ã‚‹ã«ã¯ã€ p ã®å…ƒã®å€¤ã‚’ä¿å­˜ã—ã¦ãŠã„ã¦ãã ã•ã„ã€‚"

#: ../../c-api/memory.rst:146
msgid "Same as :c:func:`PyMem_Free`."
msgstr ":c:func:`PyMem_Free` ã¨åŒã˜ã§ã™ã€‚"

#: ../../c-api/memory.rst:148
msgid ""
"In addition, the following macro sets are provided for calling the Python "
"memory allocator directly, without involving the C API functions listed "
"above. However, note that their use does not preserve binary compatibility "
"across Python versions and is therefore deprecated in extension modules."
msgstr "ä¸Šè¨˜ã«åŠ ãˆã¦ã€C API é–¢æ•°ã‚’ä»‹ã™ã‚‹ã“ã¨ãªã Python ãƒ¡ãƒ¢ãƒªæ“ä½œé–¢æ•°ã‚’ç›´æ¥å‘¼ã³å‡ºã™ãŸã‚ã®ä»¥ä¸‹ã®ãƒã‚¯ãƒ­ã‚»ãƒƒãƒˆãŒæä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚ãŸã ã—ã€ã“ã‚Œã‚‰ã®ãƒã‚¯ãƒ­ã¯ Python ãƒãƒ¼ã‚¸ãƒ§ãƒ³é–“ã§ã®ãƒã‚¤ãƒŠãƒªäº’æ›æ€§ã‚’ä¿ã¦ãšã€ãã‚Œã‚†ãˆã«æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯æ’¤å»ƒã•ã‚Œã¦ã„ã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../c-api/memory.rst:153
msgid ":c:func:`PyMem_MALLOC`, :c:func:`PyMem_REALLOC`, :c:func:`PyMem_FREE`."
msgstr ":c:func:`PyMem_MALLOC` ã€ :c:func:`PyMem_REALLOC` ã€ :c:func:`PyMem_FREE` ã€‚"

#: ../../c-api/memory.rst:155
msgid ":c:func:`PyMem_NEW`, :c:func:`PyMem_RESIZE`, :c:func:`PyMem_DEL`."
msgstr ":c:func:`PyMem_NEW` ã€ :c:func:`PyMem_RESIZE` ã€ :c:func:`PyMem_DEL` ã€‚"

#: ../../c-api/memory.rst:159
msgid "Object allocators"
msgstr ""

#: ../../c-api/memory.rst:161
msgid ""
"The following function sets, modeled after the ANSI C standard, but "
"specifying behavior when requesting zero bytes, are available for allocating"
" and releasing memory from the Python heap."
msgstr "ä»¥ä¸‹ã®é–¢æ•°ç¾¤ãŒåˆ©ç”¨ã—ã¦ Python ãƒ’ãƒ¼ãƒ—ã«å¯¾ã—ã¦ãƒ¡ãƒ¢ãƒªã‚’ç¢ºä¿ã—ãŸã‚Šè§£æ”¾ã—ãŸã‚Šå‡ºæ¥ã¾ã™ã€‚ã“ã‚Œã‚‰ã®é–¢æ•°ã¯ ANSI C æ¨™æº–ã«å¾“ã£ã¦ãƒ¢ãƒ‡ãƒ«åŒ–ã•ã‚Œã¦ã„ã¾ã™ãŒã€0 ãƒã‚¤ãƒˆã‚’è¦æ±‚ã—ãŸéš›ã®å‹•ä½œã«ã¤ã„ã¦ã‚‚å®šç¾©ã—ã¦ã„ã¾ã™:"

#: ../../c-api/memory.rst:165
msgid ""
"By default, these functions use :ref:`pymalloc memory allocator <pymalloc>`."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã“ã‚Œã‚‰ã®é–¢æ•°ã¯ :ref:`pymalloc ãƒ¡ãƒ¢ãƒªã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ <pymalloc>` ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚"

#: ../../c-api/memory.rst:169
msgid ""
"The :term:`GIL <global interpreter lock>` must be held when using these "
"functions."
msgstr "ã“ã‚Œã‚‰ã®é–¢æ•°ã‚’å‘¼ã¶ã¨ãã«ã¯ã€ :term:`GIL <global interpreter lock>` ã‚’ä¿æŒã—ã¦ãŠãå¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../c-api/memory.rst:174
msgid ""
"Allocates *n* bytes and returns a pointer of type :c:type:`void\\*` to the "
"allocated memory, or *NULL* if the request fails."
msgstr "*n* ãƒã‚¤ãƒˆã‚’å‰²ã‚Šå½“ã¦ã€ãã®ãƒ¡ãƒ¢ãƒªã‚’æŒ‡ã™ :c:type:`void\\*` å‹ã®ãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚è¦æ±‚ãŒå¤±æ•—ã—ãŸå ´åˆ *NULL* ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/memory.rst:177
msgid ""
"Requesting zero bytes returns a distinct non-*NULL* pointer if possible, as "
"if ``PyObject_Malloc(1)`` had been called instead. The memory will not have "
"been initialized in any way."
msgstr ""

#: ../../c-api/memory.rst:184
msgid ""
"Resizes the memory block pointed to by *p* to *n* bytes. The contents will "
"be unchanged to the minimum of the old and the new sizes."
msgstr "*p* ãŒæŒ‡ã™ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‚’ *n* ãƒã‚¤ãƒˆã«ãƒªã‚µã‚¤ã‚ºã—ã¾ã™ã€‚å¤ã„ã‚µã‚¤ã‚ºã¨æ–°ã—ã„ã‚µã‚¤ã‚ºã®å°ã•ã„æ–¹ã¾ã§ã®å†…å®¹ã¯å¤‰æ›´ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../c-api/memory.rst:187
msgid ""
"If *p* is *NULL*, the call is equivalent to ``PyObject_Malloc(n)``; else if "
"*n* is equal to zero, the memory block is resized but is not freed, and the "
"returned pointer is non-*NULL*."
msgstr ""

#: ../../c-api/memory.rst:191
msgid ""
"Unless *p* is *NULL*, it must have been returned by a previous call to "
":c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` or "
":c:func:`PyObject_Calloc`."
msgstr ""

#: ../../c-api/memory.rst:194
msgid ""
"If the request fails, :c:func:`PyObject_Realloc` returns *NULL* and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""

#: ../../c-api/memory.rst:200
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a"
" previous call to :c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` or "
":c:func:`PyObject_Calloc`.  Otherwise, or if ``PyObject_Free(p)`` has been "
"called before, undefined behavior occurs."
msgstr ""

#: ../../c-api/memory.rst:205
msgid "If *p* is *NULL*, no operation is performed."
msgstr "*p* ãŒ *NULL* ã®å ´åˆä½•ã‚‚ã—ã¾ã›ã‚“ã€‚"

#: ../../c-api/memory.rst:208
msgid "In addition, the following macro sets are provided:"
msgstr ""

#: ../../c-api/memory.rst:210
msgid ":c:func:`PyObject_MALLOC`: alias to :c:func:`PyObject_Malloc`"
msgstr ""

#: ../../c-api/memory.rst:211
msgid ":c:func:`PyObject_REALLOC`: alias to :c:func:`PyObject_Realloc`"
msgstr ""

#: ../../c-api/memory.rst:212
msgid ":c:func:`PyObject_FREE`: alias to :c:func:`PyObject_Free`"
msgstr ""

#: ../../c-api/memory.rst:213
msgid ":c:func:`PyObject_Del`: alias to :c:func:`PyObject_Free`"
msgstr ""

#: ../../c-api/memory.rst:214
msgid ""
":c:func:`PyObject_DEL`: alias to :c:func:`PyObject_FREE` (so finally an "
"alias to :c:func:`PyObject_Free`)"
msgstr ""

#: ../../c-api/memory.rst:221
msgid "The pymalloc allocator"
msgstr "pymalloc ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿"

#: ../../c-api/memory.rst:223
msgid ""
"Python has a *pymalloc* allocator optimized for small objects (smaller or "
"equal to 512 bytes) with a short lifetime. It uses memory mappings called "
"\"arenas\" with a fixed size of 256 KiB. It falls back to :c:func:`malloc` "
"and :c:func:`realloc` for allocations larger than 512 bytes."
msgstr ""

#: ../../c-api/memory.rst:228
msgid "*pymalloc* is the default allocator of :c:func:`PyObject_Malloc`."
msgstr ""

#: ../../c-api/memory.rst:230
msgid "The arena allocator uses the following functions:"
msgstr "ã‚¢ãƒªãƒ¼ãƒŠã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã¯ã€æ¬¡ã®é–¢æ•°ã‚’ä½¿ã„ã¾ã™:"

#: ../../c-api/memory.rst:232
msgid ":c:func:`mmap` and :c:func:`munmap` if available,"
msgstr "åˆ©ç”¨ã§ãã‚‹å ´åˆã€:c:func:`mmap` ã¨ :c:func:`munmap`ã€"

#: ../../c-api/memory.rst:233
msgid ":c:func:`malloc` and :c:func:`free` otherwise."
msgstr "ãã‚Œä»¥å¤–ã®å ´åˆã¯ :c:func:`malloc` ã¨ :c:func:`free`ã€‚"

#: ../../c-api/memory.rst:235
msgid ""
"The threshold changed from 256 to 512 bytes. The arena allocator now uses "
":c:func:`mmap` if available."
msgstr ""

#: ../../c-api/memory.rst:243
msgid "Examples"
msgstr "ä¾‹"

#: ../../c-api/memory.rst:245
msgid ""
"Here is the example from section :ref:`memoryoverview`, rewritten so that "
"the I/O buffer is allocated from the Python heap by using the first function"
" set::"
msgstr "æœ€åˆã«è¿°ã¹ãŸé–¢æ•°ã‚»ãƒƒãƒˆã‚’ä½¿ã£ã¦ã€ :ref:`memoryoverview` ç¯€ã®ä¾‹ã‚’ Python ãƒ’ãƒ¼ãƒ—ã« I/O ãƒãƒƒãƒ•ã‚¡ã‚’ãƒ¡ãƒ¢ãƒªç¢ºä¿ã™ã‚‹ã‚ˆã†ã«æ›¸ãæ›ãˆãŸã‚‚ã®ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™::"

#: ../../c-api/memory.rst:258
msgid "The same code using the type-oriented function set::"
msgstr "åŒã˜ã‚³ãƒ¼ãƒ‰ã‚’å‹å¯¾è±¡ã®é–¢æ•°ã‚»ãƒƒãƒˆã§æ›¸ã„ãŸã‚‚ã®ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™::"

#: ../../c-api/memory.rst:270
msgid ""
"Note that in the two examples above, the buffer is always manipulated via "
"functions belonging to the same set. Indeed, it is required to use the same "
"memory API family for a given memory block, so that the risk of mixing "
"different allocators is reduced to a minimum. The following code sequence "
"contains two errors, one of which is labeled as *fatal* because it mixes two"
" different allocators operating on different heaps. ::"
msgstr "ä¸Šã®äºŒã¤ã®ä¾‹ã§ã¯ã€ãƒãƒƒãƒ•ã‚¡ã‚’å¸¸ã«åŒã˜é–¢æ•°ã‚»ãƒƒãƒˆã«å±ã™ã‚‹é–¢æ•°ã§æ“ä½œã—ã¦ã„ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚å®Ÿéš›ã€ã‚ã‚‹ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã«å¯¾ã™ã‚‹æ“ä½œã¯ã€ç•°ãªã‚‹ãƒ¡ãƒ¢ãƒªæ“ä½œæ©Ÿæ§‹ã‚’æ··ç”¨ã™ã‚‹å±é™ºã‚’æ¸›ã‚‰ã™ãŸã‚ã«ã€åŒã˜ãƒ¡ãƒ¢ãƒª API ãƒ•ã‚¡ãƒŸãƒªã‚’ä½¿ã£ã¦è¡Œã†ã“ã¨ãŒå¿…è¦ã§ã™ã€‚ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã«ã¯äºŒã¤ã®ã‚¨ãƒ©ãƒ¼ãŒã‚ã‚Šã€ãã®ã†ã¡ã®ä¸€ã¤ã«ã¯ç•°ãªã‚‹ãƒ’ãƒ¼ãƒ—ã‚’æ“ä½œã™ã‚‹åˆ¥ã®ãƒ¡ãƒ¢ãƒªæ“ä½œé–¢æ•°ã‚’æ··ç”¨ã—ã¦ã„ã‚‹ã®ã§ *è‡´å‘½çš„ (Fatal)* ã¨ãƒ©ãƒ™ãƒ«ã¥ã‘ã‚’ã—ã¦ã„ã¾ã™ã€‚ ::"

#: ../../c-api/memory.rst:285
msgid ""
"In addition to the functions aimed at handling raw memory blocks from the "
"Python heap, objects in Python are allocated and released with "
":c:func:`PyObject_New`, :c:func:`PyObject_NewVar` and "
":c:func:`PyObject_Del`."
msgstr "ç´ ã®ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‚’ Python ãƒ’ãƒ¼ãƒ—ä¸Šã§æ“ä½œã™ã‚‹é–¢æ•°ã«åŠ ãˆã€ :c:func:`PyObject_New` ã€ :c:func:`PyObject_NewVar` ã€ãŠã‚ˆã³ :c:func:`PyObject_Del` ã‚’ä½¿ã†ã¨ã€ Python ã«ãŠã‘ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ¡ãƒ¢ãƒªç¢ºä¿ã—ãŸã‚Šè§£æ”¾ã—ãŸã‚Šã§ãã¾ã™ã€‚"

#: ../../c-api/memory.rst:289
msgid ""
"These will be explained in the next chapter on defining and implementing new"
" object types in C."
msgstr "ã“ã‚Œã‚‰ã®é–¢æ•°ã«ã¤ã„ã¦ã¯ã€æ¬¡ç« ã® C ã«ã‚ˆã‚‹æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã®å®šç¾©ã‚„å®Ÿè£…ã«é–¢ã™ã‚‹è¨˜è¿°ã®ä¸­ã§èª¬æ˜ã—ã¾ã™ã€‚"
