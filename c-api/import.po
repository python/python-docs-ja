# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# tomoğŸ§, 2017
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-21 01:52+0900\n"
"PO-Revision-Date: 2018-01-20 20:54+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/import.rst:6
msgid "Importing Modules"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ"

#: ../../c-api/import.rst:16
msgid ""
"This is a simplified interface to :c:func:`PyImport_ImportModuleEx` below, "
"leaving the *globals* and *locals* arguments set to *NULL* and *level* set "
"to 0.  When the *name* argument contains a dot (when it specifies a "
"submodule of a package), the *fromlist* argument is set to the list "
"``['*']`` so that the return value is the named module rather than the top-"
"level package containing it as would otherwise be the case.  (Unfortunately,"
" this has an additional side effect when *name* in fact specifies a "
"subpackage instead of a submodule: the submodules specified in the package's"
" ``__all__`` variable are  loaded.)  Return a new reference to the imported "
"module, or *NULL* with an exception set on failure.  Before Python 2.4, the "
"module may still be created in the failure case --- examine ``sys.modules`` "
"to find out.  Starting with Python 2.4, a failing import of a module no "
"longer leaves the module in ``sys.modules``."
msgstr "ã“ã®é–¢æ•°ã¯ä¸‹ã§è¿°ã¹ã‚‹ :c:func:`PyImport_ImportModuleEx` ã‚’å˜ç´”åŒ–ã—ãŸã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã§ã€ *globals* ãŠã‚ˆã³ *locals* å¼•æ•°ã‚’ *NULL* ã®ã¾ã¾ã«ã—ã€ *level* ã‚’ 0 ã«ã—ãŸã‚‚ã®ã§ã™ã€‚ *name* å¼•æ•°ã«ãƒ‰ãƒƒãƒˆãŒå«ã¾ã‚Œã‚‹å ´åˆ (ã‚ã‚‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æŒ‡å®šã—ã¦ã„ã‚‹å ´åˆ)ã€ *fromlist* å¼•æ•°ãŒãƒªã‚¹ãƒˆ ``['*']`` ã«è¿½åŠ ã•ã‚Œã€æˆ»ã‚Šå€¤ãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å«ã‚€ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã¯ãªãåå‰ã¤ããƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« (named module) ã«ãªã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ (æ®‹å¿µãªãŒã‚‰ã“ã®ã‚„ã‚Šæ–¹ã«ã¯ã€ *name* ãŒå®Ÿéš›ã«ã¯ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ãªãã‚µãƒ–ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’æŒ‡å®šã—ã¦ã„ã‚‹å ´åˆã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã® ``__all__`` å¤‰æ•°ã«æŒ‡å®šã•ã‚Œã¦ã„ã‚‹ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã—ã¾ã†ã¨ã„ã†å‰¯ä½œç”¨ãŒã‚ã‚Šã¾ã™ã€‚) import ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¸ã®æ–°ãŸãªå‚ç…§ã‚’è¿”ã—ã¾ã™ã€‚å¤±æ•—ã—ãŸå ´åˆã«ã¯ä¾‹å¤–ã‚’ã‚»ãƒƒãƒˆã—ã€ *NULL* ã‚’è¿”ã—ã¾ã™ã€‚ Python 2.4 ã‚ˆã‚Šå‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ã€å¤±æ•—ã—ãŸå ´åˆã§ã‚‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ç”Ÿæˆã•ã‚Œã¦ã„ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ --- ``sys.modules`` ã‚’ä½¿ã£ã¦èª¿ã¹ã¦ãã ã•ã„ã€‚ Python 2.4 ä»¥é™ã§ã¯ã€ import ã«å¤±æ•—ã—ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ ``sys.modules`` ã«æ®‹ã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/import.rst:30 ../../c-api/import.rst:64
msgid "Failing imports remove incomplete module objects."
msgstr "import ã«å¤±æ•—ã—ãŸå ´åˆã€ä¸å®Œå…¨ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’é™¤å»ã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../c-api/import.rst:33 ../../c-api/import.rst:97
msgid "Always uses absolute imports."
msgstr "å¸¸ã«ã€çµ¶å¯¾ import ã‚’ä½¿ã†ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../c-api/import.rst:39
msgid ""
"This version of :c:func:`PyImport_ImportModule` does not block. It's "
"intended to be used in C functions that import other modules to execute a "
"function. The import may block if another thread holds the import lock. The "
"function :c:func:`PyImport_ImportModuleNoBlock` never blocks. It first tries"
" to fetch the module from sys.modules and falls back to "
":c:func:`PyImport_ImportModule` unless the lock is held, in which case the "
"function will raise an :exc:`ImportError`."
msgstr "ã“ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® :c:func:`PyImport_ImportModule` ã¯ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã›ã‚“ã€‚é–¢æ•°ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã«ä»–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹Cé–¢æ•°ã‹ã‚‰ä½¿ã‚ã‚Œã‚‹ã“ã¨ã‚’æ„å›³ã—ã¦ã„ã¾ã™ã€‚ã‚¤ãƒ³ãƒãƒ¼ãƒˆå‡¦ç†ã¯ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ­ãƒƒã‚¯ã‚’æŒã£ã¦ã„ã‚‹å ´åˆã¯ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã›ã‚“ã€‚ã¾ãš sys.modules ã‹ã‚‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ•ã‚§ãƒƒãƒã‚’è©¦ã¿ã€å¤±æ•—ã—ãŸã‚‰ã€ãƒ­ãƒƒã‚¯ãŒå–ã‚‰ã‚Œã¦ã„ãªã‘ã‚Œã° :c:func:`PyImport_ImportModule` ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚ãƒ­ãƒƒã‚¯ãŒå–ã‚‰ã‚Œã¦ã„ãŸå ´åˆã¯ :exc:`ImportError` ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚"

#: ../../c-api/import.rst:54 ../../c-api/import.rst:74
msgid ""
"Import a module.  This is best described by referring to the built-in Python"
" function :func:`__import__`, as the standard :func:`__import__` function "
"calls this function directly."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ import ã—ã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® import ã«ã¤ã„ã¦ã¯çµ„ã¿è¾¼ã¿ã® Python é–¢æ•° :func:`__import__` ã‚’èª­ã‚€ã¨ã‚ˆãåˆ†ã‹ã‚Šã¾ã™ã€‚ã¨ã„ã†ã®ã‚‚ã€æ¨™æº–ã® :func:`__import__`  ã¯ã“ã®é–¢æ•°ã‚’ç›´æ¥å‘¼ã³å‡ºã—ã¦ã„ã‚‹ã‹ã‚‰ã§ã™ã€‚"

#: ../../c-api/import.rst:58
msgid ""
"The return value is a new reference to the imported module or top-level "
"package, or *NULL* with an exception set on failure (before Python 2.4, the "
"module may still be created in this case).  Like for :func:`__import__`, the"
" return value when a submodule of a package was requested is normally the "
"top-level package, unless a non-empty *fromlist* was given."
msgstr "æˆ»ã‚Šå€¤ã¯ import ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¸ã®æ–°ãŸãªå‚ç…§ã«ãªã‚Šã¾ã™ã€‚å¤±æ•—ã—ãŸå ´åˆã«ã¯ä¾‹å¤–ã‚’ã‚»ãƒƒãƒˆã—ã€ *NULL* ã‚’è¿”ã—ã¾ã™ (Python 2.4 ã‚ˆã‚Šã‚‚å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ç”Ÿæˆã•ã‚Œã¦ã„ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™) :func:`__import__` ã¨åŒã˜ãã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«å¯¾ã—ã¦ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¦æ±‚ã—ãŸå ´åˆã®æˆ»ã‚Šå€¤ã¯é€šå¸¸ã€ç©ºã§ãªã„ *fromlist* ã‚’æŒ‡å®šã—ãªã„é™ã‚Šãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/import.rst:67
msgid ""
"The function is an alias for :c:func:`PyImport_ImportModuleLevel` with "
"``-1`` as level, meaning relative import."
msgstr "ã“ã®é–¢æ•°ã¯ :c:func:`PyImport_ImportModuleLevel` ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã§ã™ã€‚ level ã«ã¯ç›¸å¯¾ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’æ„å‘³ã™ã‚‹ ``-1`` ãŒæ¸¡ã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/import.rst:78
msgid ""
"The return value is a new reference to the imported module or top-level "
"package, or *NULL* with an exception set on failure.  Like for "
":func:`__import__`, the return value when a submodule of a package was "
"requested is normally the top-level package, unless a non-empty *fromlist* "
"was given."
msgstr "æˆ»ã‚Šå€¤ã¯ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¸ã®æ–°ã—ã„å‚ç…§ã‹ã€å¤±æ•—ã—ãŸå ´åˆã¯ä¾‹å¤–ã‚’è¨­å®šã—ã¦ *NULL* ã‚’è¿”ã—ã¾ã™ã€‚ :func:`__import__` ã¨åŒã˜ã‚ˆã†ã«ã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦æ±‚ã•ã‚ŒãŸã¨ãã¯ã€ç©ºã§ãªã„ *fromlist* ã‚’æ¸¡ã•ã‚ŒãŸæ™‚ä»¥å¤–ã¯ã€ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/import.rst:92
msgid ""
"This is a higher-level interface that calls the current \"import hook "
"function\". It invokes the :func:`__import__` function from the "
"``__builtins__`` of the current globals.  This means that the import is done"
" using whatever import hooks are installed in the current environment, e.g. "
"by :mod:`rexec` or :mod:`ihooks`."
msgstr "ç¾åœ¨ã® \"import ãƒ•ãƒƒã‚¯é–¢æ•°\" ã‚’å‘¼ã³å‡ºã™ãŸã‚ã®é«˜æ°´æº–ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã§ã™ã€‚ã“ã®é–¢æ•°ã¯ç¾åœ¨ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°è¾æ›¸å†…ã® ``__builtins__`` ã‹ã‚‰ :func:`__import__` é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ã™ãªã‚ã¡ã€ç¾åœ¨ã®ç’°å¢ƒã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹ import ãƒ•ãƒƒã‚¯ã€ä¾‹ãˆã° :mod:`rexec` ã‚„ :mod:`ihooks` ã‚’ä½¿ã£ã¦ import ã‚’è¡Œã„ã¾ã™ã€‚"

#: ../../c-api/import.rst:105
msgid ""
"Reload a module.  This is best described by referring to the built-in Python"
" function :func:`reload`, as the standard :func:`reload` function calls this"
" function directly.  Return a new reference to the reloaded module, or "
"*NULL* with an exception set on failure (the module still exists in this "
"case)."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å†ãƒ­ãƒ¼ãƒ‰ (reload) ã—ã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å†ãƒ­ãƒ¼ãƒ‰ã«ã¤ã„ã¦ã¯çµ„ã¿è¾¼ã¿ã® Python é–¢æ•° :func:`reload` ã‚’èª­ã‚€ã¨ã‚ˆãåˆ†ã‹ã‚Šã¾ã™ã€‚ã¨ã„ã†ã®ã‚‚ã€æ¨™æº–ã® :func:`reload` ã¯ã“ã®é–¢æ•°ã‚’ç›´æ¥å‘¼ã³å‡ºã—ã¦ã„ã‚‹ã‹ã‚‰ã§ã™ã€‚æˆ»ã‚Šå€¤ã¯å†ãƒ­ãƒ¼ãƒ‰ã—ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¸ã®æ–°ãŸãªå‚ç…§ã«ãªã‚Šã¾ã™ã€‚å¤±æ•—ã—ãŸå ´åˆã«ã¯ä¾‹å¤–ã‚’ã‚»ãƒƒãƒˆã—ã€ *NULL* ã‚’è¿”ã—ã¾ã™ (ãã®å ´åˆã§ã‚‚ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ç”Ÿæˆã•ã‚Œã¦ã„ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™)"

#: ../../c-api/import.rst:113
msgid ""
"Return the module object corresponding to a module name.  The *name* "
"argument may be of the form ``package.module``. First check the modules "
"dictionary if there's one there, and if not, create a new one and insert it "
"in the modules dictionary. Return *NULL* with an exception set on failure."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã«å¯¾å¿œã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚*name* å¼•æ•°ã¯ ``package.module`` ã®å½¢å¼ã§ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚ã¾ãšãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è¾æ›¸ã«è©²å½“ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚ã‚‹ã‹ã©ã†ã‹èª¿ã¹ã€ãªã‘ã‚Œã°æ–°ãŸãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç”Ÿæˆã—ã¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è¾æ›¸ã«æŒ¿å…¥ã—ã¾ã™ã€‚å¤±æ•—ã—ãŸå ´åˆã«ã¯ä¾‹å¤–ã‚’ã‚»ãƒƒãƒˆã—ã¦ *NULL* ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/import.rst:120
msgid ""
"This function does not load or import the module; if the module wasn't "
"already loaded, you will get an empty module object. Use "
":c:func:`PyImport_ImportModule` or one of its variants to import a module.  "
"Package structures implied by a dotted name for *name* are not created if "
"not already present."
msgstr "ã“ã®é–¢æ•°ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® import ã‚„ãƒ­ãƒ¼ãƒ‰ã‚’è¡Œã„ã¾ã›ã‚“; ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã¾ã ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã€ç©ºã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¾—ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ :c:func:`PyImport_ImportModule` ã‚„ãã®åˆ¥å½¢å¼ã‚’ä½¿ã£ã¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ import ã—ã¦ãã ã•ã„ã€‚ãƒ‰ãƒƒãƒˆåè¡¨è¨˜ã§æŒ‡å®šã—ãŸ *name* ãŒå­˜åœ¨ã—ãªã„å ´åˆã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸æ§‹é€ ã¯ä½œæˆã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../c-api/import.rst:130
msgid ""
"Given a module name (possibly of the form ``package.module``) and a code "
"object read from a Python bytecode file or obtained from the built-in "
"function :func:`compile`, load the module.  Return a new reference to the "
"module object, or *NULL* with an exception set if an error occurred.  Before"
" Python 2.4, the module could still be created in error cases.  Starting "
"with Python 2.4, *name* is removed from :attr:`sys.modules` in error cases, "
"and even if *name* was already in :attr:`sys.modules` on entry to "
":c:func:`PyImport_ExecCodeModule`.  Leaving incompletely initialized modules"
" in :attr:`sys.modules` is dangerous, as imports of such modules have no way"
" to know that the module object is an unknown (and probably damaged with "
"respect to the module author's intents) state."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å (``package.module`` å½¢å¼ã§ã‚‚ã‹ã¾ã„ã¾ã›ã‚“) ãŠã‚ˆã³ Python ã®ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚„çµ„ã¿è¾¼ã¿é–¢æ•° :func:`compile` ã§å¾—ã‚‰ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å…ƒã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®æ–°ãŸãªå‚ç…§ã‚’è¿”ã—ã¾ã™ã€‚å¤±æ•—ã—ãŸå ´åˆã«ã¯ä¾‹å¤–ã‚’ã‚»ãƒƒãƒˆã—ã€ *NULL* ã‚’è¿”ã—ã¾ã™ã€‚Python 2.4 ä»¥å‰ã§ã¯ã€å¤±æ•—ã—ãŸå ´åˆã§ã‚‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ç”Ÿæˆã•ã‚Œã¦ã„ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã—ãŸã€‚ Python 2.4 ä»¥é™ã§ã¯ã€ãŸã¨ãˆ :c:func:`PyImport_ExecCodeModule` ã®å‡¦ç†ã«å…¥ã£ãŸæ™‚ã« *name* ãŒ :attr:`sys.modules` ã«å…¥ã£ã¦ã„ãŸã¨ã—ã¦ã‚‚ã€ import ã«å¤±æ•—ã—ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ :attr:`sys.modules` ã«æ®‹ã‚Šã¾ã›ã‚“ã€‚åˆæœŸåŒ–ã®ä¸å®Œå…¨ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ :attr:`sys.modules` ã«æ®‹ã™ã®ã¯å±é™ºã§ã‚ã‚Šã€ãã®ã‚ˆã†ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ import ã™ã‚‹ã‚³ãƒ¼ãƒ‰ã«ã¨ã£ã¦ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®çŠ¶æ…‹ãŒã‚ã‹ã‚‰ãªã„ (ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä½œè€…ã®æ„å›³ã‹ã‚‰å¤–ã‚ŒãŸå£Šã‚ŒãŸçŠ¶æ…‹ã‹ã‚‚ã—ã‚Œãªã„) ã‹ã‚‰ã§ã™ã€‚"

#: ../../c-api/import.rst:141
msgid ""
"The module's :attr:`__file__` attribute will be set to the code object's "
":c:member:`co_filename`."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® :attr:`__file__` å±æ€§ãŒã€ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :c:member:`co_filename` ã«è¨­å®šã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/import.rst:144
msgid ""
"This function will reload the module if it was already imported.  See "
":c:func:`PyImport_ReloadModule` for the intended way to reload a module."
msgstr "ã“ã®é–¢æ•°ã¯ã€ã™ã§ã« import ã•ã‚Œã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å ´åˆã«ã¯å†ãƒ­ãƒ¼ãƒ‰ã‚’è¡Œã„ã¾ã™ã€‚æ„å›³çš„ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å†ãƒ­ãƒ¼ãƒ‰ã‚’è¡Œã†æ–¹æ³•ã¯ :c:func:`PyImport_ReloadModule` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../c-api/import.rst:147
msgid ""
"If *name* points to a dotted name of the form ``package.module``, any "
"package structures not already created will still not be created."
msgstr "*name* ãŒ ``package.module`` å½¢å¼ã®ãƒ‰ãƒƒãƒˆåè¡¨è¨˜ã§ã‚ã£ãŸå ´åˆã€ã¾ã ä½œæˆã•ã‚Œã¦ã„ãªã„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸æ§‹é€ ã¯ãã®ä½œæˆã•ã‚Œãªã„ã¾ã¾ã«ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/import.rst:150
msgid "*name* is removed from :attr:`sys.modules` in error cases."
msgstr "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã« *name* ã‚’ :attr:`sys.modules` ã‹ã‚‰é™¤å»ã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../c-api/import.rst:156
msgid ""
"Like :c:func:`PyImport_ExecCodeModule`, but the :attr:`__file__` attribute "
"of the module object is set to *pathname* if it is non-``NULL``."
msgstr ":c:func:`PyImport_ExecCodeModule` ã¨ä¼¼ã¦ã„ã¾ã™ãŒã€*pathname* ãŒ ``NULL`` ã§ãªã„å ´åˆã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :attr:`__file__` å±æ€§ã« *pathname* ãŒè¨­å®šã•ã‚Œã‚‹ç‚¹ãŒç•°ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/import.rst:162
msgid ""
"Return the magic number for Python bytecode files (a.k.a. :file:`.pyc` and "
":file:`.pyo` files).  The magic number should be present in the first four "
"bytes of the bytecode file, in little-endian byte order."
msgstr "Python ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ« (ã„ã‚ã‚†ã‚‹ :file:`.pyc` ãŠã‚ˆã³ :file:`.pyo` ãƒ•ã‚¡ã‚¤ãƒ«) ã®ãƒã‚¸ãƒƒã‚¯ãƒŠãƒ³ãƒã‚’è¿”ã—ã¾ã™ã€‚ãƒã‚¸ãƒƒã‚¯ãƒŠãƒ³ãƒã¯ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã®å…ˆé ­ 4 ãƒã‚¤ãƒˆã«ãƒªãƒˆãƒ«ã‚¨ãƒ³ãƒ‡ã‚£ã‚¢ãƒ³æ•´åˆ—ã§é…ç½®ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../c-api/import.rst:169
msgid ""
"Return the dictionary used for the module administration (a.k.a. "
"``sys.modules``).  Note that this is a per-interpreter variable."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ç®¡ç†ã®ãŸã‚ã®è¾æ›¸ (ã„ã‚ã‚†ã‚‹ ``sys.modules``)ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®è¾æ›¸ã¯ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã”ã¨ã«ä¸€ã¤ã ã‘ã‚ã‚‹å¤‰æ•°ãªã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../c-api/import.rst:175
msgid ""
"Return an importer object for a :data:`sys.path`/:attr:`pkg.__path__` item "
"*path*, possibly by fetching it from the :data:`sys.path_importer_cache` "
"dict.  If it wasn't yet cached, traverse :data:`sys.path_hooks` until a hook"
" is found that can handle the path item.  Return ``None`` if no hook could; "
"this tells our caller it should fall back to the built-in import mechanism. "
"Cache the result in :data:`sys.path_importer_cache`.  Return a new reference"
" to the importer object."
msgstr ":data:`sys.path`/:attr:`pkg.__path__` ã®è¦ç´  *path* ã®ã€ importer ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚å¯èƒ½ãªã‚‰ã€ :data:`sys.path_importer_cache` ã‹ã‚‰ãƒ•ã‚§ãƒƒãƒã—ã¾ã™ã€‚ã¾ã ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚Œã¦ã„ãªã„å ´åˆã€ãã®ãƒ‘ã‚¹ã‚’æ‰±ãˆã‚‹ hook ãŒè¦‹ã¤ã‹ã‚‹ã¾ã§ :data:`sys.path_hooks` ã‚’å·¡å›ã—ã¾ã™ã€‚ hook ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã€ ``None`` ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®å ´åˆã€å‘¼ã³å‡ºã—å…ƒã¯ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¾ã™ã€‚çµæœã¯ :data:`sys.path_importer_cache` ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚Œã¾ã™ã€‚ importer ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®æ–°ã—ã„å‚ç…§ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/import.rst:188
msgid "Initialize the import mechanism.  For internal use only."
msgstr "import æ©Ÿæ§‹ã‚’åˆæœŸåŒ–ã—ã¾ã™ã€‚å†…éƒ¨ä½¿ç”¨ã ã‘ã®ãŸã‚ã®é–¢æ•°ã§ã™ã€‚"

#: ../../c-api/import.rst:193
msgid "Empty the module table.  For internal use only."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ç©ºã«ã—ã¾ã™ã€‚å†…éƒ¨ä½¿ç”¨ã ã‘ã®ãŸã‚ã®é–¢æ•°ã§ã™ã€‚"

#: ../../c-api/import.rst:198
msgid "Finalize the import mechanism.  For internal use only."
msgstr "import æ©Ÿæ§‹ã‚’çµ‚äº†å‡¦ç†ã—ã¾ã™ã€‚å†…éƒ¨ä½¿ç”¨ã ã‘ã®ãŸã‚ã®é–¢æ•°ã§ã™ã€‚"

#: ../../c-api/import.rst:203 ../../c-api/import.rst:208
msgid "For internal use only."
msgstr "å†…éƒ¨ä½¿ç”¨ã ã‘ã®ãŸã‚ã®é–¢æ•°ã§ã™ã€‚"

#: ../../c-api/import.rst:213
msgid ""
"Load a frozen module named *name*.  Return ``1`` for success, ``0`` if the "
"module is not found, and ``-1`` with an exception set if the initialization "
"failed.  To access the imported module on a successful load, use "
":c:func:`PyImport_ImportModule`.  (Note the misnomer --- this function would"
" reload the module if it was already imported.)"
msgstr "*name* ã¨ã„ã†åå‰ã®ãƒ•ãƒªãƒ¼ã‚º (freeze) ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚æˆåŠŸã™ã‚‹ã¨ ``1`` ã‚’ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã«ã¯ ``0`` ã‚’ã€åˆæœŸåŒ–ãŒå¤±æ•—ã—ãŸå ´åˆã«ã¯ä¾‹å¤–ã‚’ã‚»ãƒƒãƒˆã—ã¦ ``-1`` ã‚’è¿”ã—ã¾ã™ã€‚ãƒ­ãƒ¼ãƒ‰ã«æˆåŠŸã—ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã«ã¯ :c:func:`PyImport_ImportModule` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚ (Note ã“ã®é–¢æ•°åã¯ã„ã•ã•ã‹èª¤ç§°ã‚ã„ã¦ã„ã¾ã™ --- ã“ã®é–¢æ•°ã¯ã™ã§ã« import æ¸ˆã¿ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ã—ã¾ã„ã¾ã™ã€‚)"

#: ../../c-api/import.rst:224
msgid ""
"This is the structure type definition for frozen module descriptors, as "
"generated by the :program:`freeze` utility (see :file:`Tools/freeze/` in the"
" Python source distribution).  Its definition, found in "
":file:`Include/import.h`, is::"
msgstr ":program:`freeze` ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãŒç”Ÿæˆã™ã‚‹ã‚ˆã†ãªãƒ•ãƒªãƒ¼ã‚ºåŒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®æ§‹é€ ä½“å‹å®šç¾©ã§ã™ã€‚ (Python ã‚½ãƒ¼ã‚¹é…å¸ƒç‰©ã® :file:`Tools/freeze/` ã‚’å‚ç…§ã—ã¦ãã ã•ã„) ã“ã®æ§‹é€ ä½“ã®å®šç¾©ã¯ :file:`Include/import.h` ã«ã‚ã‚Šã€ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™::"

#: ../../c-api/import.rst:238
msgid ""
"This pointer is initialized to point to an array of :c:type:`struct _frozen`"
" records, terminated by one whose members are all *NULL* or zero.  When a "
"frozen module is imported, it is searched in this table.  Third-party code "
"could play tricks with this to provide a dynamically created collection of "
"frozen modules."
msgstr "ã“ã®ãƒã‚¤ãƒ³ã‚¿ã¯ :c:type:`struct _frozen` ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ãªã‚Šã€çµ‚ç«¯ã®è¦ç´ ã®ãƒ¡ãƒ³ãƒãŒ *NULL* ã‹ã‚¼ãƒ­ã«ãªã£ã¦ã„ã‚‹ã‚ˆã†ãªé…åˆ—ã‚’æŒ‡ã™ã‚ˆã†åˆæœŸåŒ–ã•ã‚Œã¾ã™ã€‚ãƒ•ãƒªãƒ¼ã‚ºã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ import ã™ã‚‹ã¨ãã€ã“ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’æ¤œç´¢ã—ã¾ã™ã€‚ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£è£½ã®ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ã“ã®ãƒã‚¤ãƒ³ã‚¿ã«ä»•æ›ã‘ã‚’è¬›ã˜ã¦ã€å‹•çš„ã«ç”Ÿæˆã•ã‚ŒãŸãƒ•ãƒªãƒ¼ã‚ºåŒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®é›†åˆã‚’æä¾›ã™ã‚‹ã‚ˆã†ã«ã§ãã¾ã™ã€‚"

#: ../../c-api/import.rst:246
msgid ""
"Add a single module to the existing table of built-in modules.  This is a "
"convenience wrapper around :c:func:`PyImport_ExtendInittab`, returning "
"``-1`` if the table could not be extended.  The new module can be imported "
"by the name *name*, and uses the function *initfunc* as the initialization "
"function called on the first attempted import.  This should be called before"
" :c:func:`Py_Initialize`."
msgstr "æ—¢å­˜ã®çµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ†ãƒ¼ãƒ–ãƒ«ã«å˜ä¸€ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¿½åŠ ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯åˆ©ä¾¿æ€§ã‚’ç›®çš„ã¨ã—ãŸ :c:func:`PyImport_ExtendInittab` ã®ãƒ©ãƒƒãƒ‘é–¢æ•°ã§ã€ãƒ†ãƒ¼ãƒ–ãƒ«ãŒæ‹¡å¼µã§ããªã„ã¨ãã«ã¯ ``-1`` ã‚’è¿”ã—ã¾ã™ã€‚æ–°ãŸãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ *name* ã§ import ã§ãã€æœ€åˆã« import ã‚’è©¦ã¿ãŸéš›ã«å‘¼ã³å‡ºã•ã‚Œã‚‹é–¢æ•°ã¨ã—ã¦ *initfunc* ã‚’ä½¿ã„ã¾ã™ã€‚ :c:func:`Py_Initialize` ã‚ˆã‚Šã‚‚å‰ã«å‘¼ã³å‡ºã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/import.rst:256
msgid ""
"Structure describing a single entry in the list of built-in modules.  Each "
"of these structures gives the name and initialization function for a module "
"built into the interpreter.  Programs which embed Python may use an array of"
" these structures in conjunction with :c:func:`PyImport_ExtendInittab` to "
"provide additional built-in modules.  The structure is defined in "
":file:`Include/import.h` as::"
msgstr "çµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒªã‚¹ãƒˆå†…ã®ä¸€ã¤ã®ã‚¨ãƒ³ãƒˆãƒªã‚’è¨˜è¿°ã—ã¦ã„ã‚‹æ§‹é€ ä½“ã§ã™ã€‚ãƒªã‚¹ãƒˆå†…ã®å„æ§‹é€ ä½“ã«ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿å†…ã«çµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ã¨åˆæœŸåŒ–é–¢æ•°ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã™ã€‚ Python ã‚’åŸ‹ã‚è¾¼ã‚€ã‚ˆã†ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€ã“ã®æ§‹é€ ä½“ã®é…åˆ—ã¨ :c:func:`PyImport_ExtendInittab` ã‚’çµ„ã¿åˆã‚ã›ã¦ã€è¿½åŠ ã®çµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æä¾›ã§ãã¾ã™ã€‚æ§‹é€ ä½“ã¯ :file:`Include/import.h` ã§ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™::"

#: ../../c-api/import.rst:271
msgid ""
"Add a collection of modules to the table of built-in modules.  The *newtab* "
"array must end with a sentinel entry which contains *NULL* for the "
":attr:`name` field; failure to provide the sentinel value can result in a "
"memory fault. Returns ``0`` on success or ``-1`` if insufficient memory "
"could be allocated to extend the internal table.  In the event of failure, "
"no modules are added to the internal table.  This should be called before "
":c:func:`Py_Initialize`."
msgstr "çµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã«ä¸€ç¾¤ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¿½åŠ ã—ã¾ã™ã€‚é…åˆ— *newtab* ã¯ :attr:`name` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒ *NULL* ã«ãªã£ã¦ã„ã‚‹ã‚»ãƒ³ãƒãƒãƒ« (sentinel) ã‚¨ãƒ³ãƒˆãƒªã§çµ‚ç«¯ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“; ã‚»ãƒ³ãƒãƒãƒ«å€¤ã‚’ä¸ãˆã‚‰ã‚Œãªã‹ã£ãŸå ´åˆã«ã¯ãƒ¡ãƒ¢ãƒªé•åã«ãªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚æˆåŠŸã™ã‚‹ã¨ ``0`` ã‚’ã€å†…éƒ¨ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’æ‹¡å¼µã™ã‚‹ã®ã«ååˆ†ãªãƒ¡ãƒ¢ãƒªã‚’ç¢ºä¿ã§ããªã‹ã£ãŸå ´åˆã«ã¯ ``-1`` ã‚’è¿”ã—ã¾ã™ã€‚æ“ä½œãŒå¤±æ•—ã—ãŸå ´åˆã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ä¸€åˆ‡å†…éƒ¨ãƒ†ãƒ¼ãƒ–ãƒ«ã«è¿½åŠ ã•ã‚Œã¾ã›ã‚“ã€‚ :c:func:`Py_Initialize` ã‚ˆã‚Šã‚‚å‰ã«å‘¼ã³å‡ºã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"
