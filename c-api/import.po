# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# tomo, 2017
# 秘湯 <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 01:01+0900\n"
"PO-Revision-Date: 2019-09-01 05:18+0000\n"
"Last-Translator: tomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/"
"language/ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/import.rst:6
msgid "Importing Modules"
msgstr "モジュールのインポート"

#: ../../c-api/import.rst:16
msgid ""
"This is a simplified interface to :c:func:`PyImport_ImportModuleEx` below, "
"leaving the *globals* and *locals* arguments set to *NULL* and *level* set "
"to 0.  When the *name* argument contains a dot (when it specifies a "
"submodule of a package), the *fromlist* argument is set to the list "
"``['*']`` so that the return value is the named module rather than the top-"
"level package containing it as would otherwise be the case.  (Unfortunately, "
"this has an additional side effect when *name* in fact specifies a "
"subpackage instead of a submodule: the submodules specified in the package's "
"``__all__`` variable are  loaded.)  Return a new reference to the imported "
"module, or *NULL* with an exception set on failure.  Before Python 2.4, the "
"module may still be created in the failure case --- examine ``sys.modules`` "
"to find out.  Starting with Python 2.4, a failing import of a module no "
"longer leaves the module in ``sys.modules``."
msgstr ""
"この関数は下で述べる :c:func:`PyImport_ImportModuleEx` を単純化したインタ"
"フェースで、 *globals* および *locals* 引数を *NULL* のままにし、 *level* を "
"0 にしたものです。 *name* 引数にドットが含まれる場合 (あるパッケージのサブモ"
"ジュールを指定している場合)、 *fromlist* 引数がリスト ``['*']`` に追加され、"
"戻り値がモジュールを含むトップレベルパッケージではなく名前つきモジュール "
"(named module) になるようにします。 (残念ながらこのやり方には、 *name* が実際"
"にはサブモジュールでなくサブパッケージを指定している場合、パッケージの "
"``__all__`` 変数に指定されているサブモジュールがロードされてしまうという副作"
"用があります。) import されたモジュールへの新たな参照を返します。失敗した場合"
"には例外をセットし、 *NULL* を返します。 Python 2.4 より前のバージョンでは、"
"失敗した場合でもモジュールは生成されていることがあります --- ``sys.modules`` "
"を使って調べてください。 Python 2.4 以降では、 import に失敗したモジュールは "
"``sys.modules`` に残りません。"

#: ../../c-api/import.rst:30 ../../c-api/import.rst:64
msgid "Failing imports remove incomplete module objects."
msgstr "import に失敗した場合、不完全なモジュールを除去するようになりました。"

#: ../../c-api/import.rst:33 ../../c-api/import.rst:97
msgid "Always uses absolute imports."
msgstr "常に、絶対 import を使うようになりました。"

#: ../../c-api/import.rst:39
msgid ""
"This version of :c:func:`PyImport_ImportModule` does not block. It's "
"intended to be used in C functions that import other modules to execute a "
"function. The import may block if another thread holds the import lock. The "
"function :c:func:`PyImport_ImportModuleNoBlock` never blocks. It first tries "
"to fetch the module from sys.modules and falls back to :c:func:"
"`PyImport_ImportModule` unless the lock is held, in which case the function "
"will raise an :exc:`ImportError`."
msgstr ""
"このバージョンの :c:func:`PyImport_ImportModule` はブロックしません。関数を実"
"行するために他のモジュールをインポートするC関数から使われることを意図していま"
"す。インポート処理は他のスレッドがインポートロックを持っている場合はブロック"
"します。この関数はブロックしません。まず sys.modules からモジュールのフェッチ"
"を試み、失敗したら、ロックが取られていなければ :c:func:"
"`PyImport_ImportModule` を実行します。ロックが取られていた場合は :exc:"
"`ImportError` を発生させます。"

#: ../../c-api/import.rst:54 ../../c-api/import.rst:74
msgid ""
"Import a module.  This is best described by referring to the built-in Python "
"function :func:`__import__`, as the standard :func:`__import__` function "
"calls this function directly."
msgstr ""
"モジュールを import します。モジュールの import については組み込みの Python "
"関数 :func:`__import__` を読むとよく分かります。というのも、標準の :func:"
"`__import__`  はこの関数を直接呼び出しているからです。"

#: ../../c-api/import.rst:58
msgid ""
"The return value is a new reference to the imported module or top-level "
"package, or *NULL* with an exception set on failure (before Python 2.4, the "
"module may still be created in this case).  Like for :func:`__import__`, the "
"return value when a submodule of a package was requested is normally the top-"
"level package, unless a non-empty *fromlist* was given."
msgstr ""
"戻り値は import されたモジュールかトップレベルパッケージへの新たな参照になり"
"ます。失敗した場合には例外をセットし、 *NULL* を返します (Python 2.4 よりも前"
"のバージョンでは、モジュールは生成されている場合があります) :func:"
"`__import__` と同じく、パッケージに対してサブモジュールを要求した場合の戻り値"
"は通常、空でない *fromlist* を指定しない限りトップレベルパッケージになりま"
"す。"

#: ../../c-api/import.rst:67
msgid ""
"The function is an alias for :c:func:`PyImport_ImportModuleLevel` with "
"``-1`` as level, meaning relative import."
msgstr ""
"この関数は :c:func:`PyImport_ImportModuleLevel` のエイリアスです。 level には"
"相対インポートを意味する ``-1`` が渡されます。"

#: ../../c-api/import.rst:78
msgid ""
"The return value is a new reference to the imported module or top-level "
"package, or *NULL* with an exception set on failure.  Like for :func:"
"`__import__`, the return value when a submodule of a package was requested "
"is normally the top-level package, unless a non-empty *fromlist* was given."
msgstr ""
"戻り値は、インポートされたモジュールかトップレベルパッケージへの新しい参照"
"か、失敗した場合は例外を設定して *NULL* を返します。 :func:`__import__` と同"
"じように、パッケージのサブモジュールが要求されたときは、空でない *fromlist* "
"を渡された時以外は、トップレベルのパッケージを返します。"

#: ../../c-api/import.rst:92
msgid ""
"This is a higher-level interface that calls the current \"import hook "
"function\". It invokes the :func:`__import__` function from the "
"``__builtins__`` of the current globals.  This means that the import is done "
"using whatever import hooks are installed in the current environment, e.g. "
"by :mod:`rexec` or :mod:`ihooks`."
msgstr ""
"現在の \"import フック関数\" を呼び出すための高水準のインタフェースです。この"
"関数は現在のグローバル変数辞書内の ``__builtins__`` から :func:`__import__` "
"関数を呼び出します。すなわち、現在の環境にインストールされている import フッ"
"ク、例えば :mod:`rexec` や :mod:`ihooks` を使って import を行います。"

#: ../../c-api/import.rst:105
msgid ""
"Reload a module.  This is best described by referring to the built-in Python "
"function :func:`reload`, as the standard :func:`reload` function calls this "
"function directly.  Return a new reference to the reloaded module, or *NULL* "
"with an exception set on failure (the module still exists in this case)."
msgstr ""
"モジュールを再ロード (reload) します。モジュールの再ロードについては組み込み"
"の Python 関数 :func:`reload` を読むとよく分かります。というのも、標準の :"
"func:`reload` はこの関数を直接呼び出しているからです。戻り値は再ロードしたモ"
"ジュールかトップレベルパッケージへの新たな参照になります。失敗した場合には例"
"外をセットし、 *NULL* を返します (その場合でも、モジュールは生成されている場"
"合があります)"

#: ../../c-api/import.rst:113
msgid ""
"Return the module object corresponding to a module name.  The *name* "
"argument may be of the form ``package.module``. First check the modules "
"dictionary if there's one there, and if not, create a new one and insert it "
"in the modules dictionary. Return *NULL* with an exception set on failure."
msgstr ""
"モジュール名に対応するモジュールオブジェクトを返します。*name* 引数は "
"``package.module`` の形式でもかまいません。まずモジュール辞書に該当するモ"
"ジュールがあるかどうか調べ、なければ新たなモジュールを生成してモジュール辞書"
"に挿入します。失敗した場合には例外をセットして *NULL* を返します。"

#: ../../c-api/import.rst:120
msgid ""
"This function does not load or import the module; if the module wasn't "
"already loaded, you will get an empty module object. Use :c:func:"
"`PyImport_ImportModule` or one of its variants to import a module.  Package "
"structures implied by a dotted name for *name* are not created if not "
"already present."
msgstr ""
"この関数はモジュールの import やロードを行いません; モジュールがまだロードさ"
"れていなければ、空のモジュールオブジェクトを得ることになります。 :c:func:"
"`PyImport_ImportModule` やその別形式を使ってモジュールを import してくださ"
"い。ドット名表記で指定した *name* が存在しない場合、パッケージ構造は作成され"
"ません。"

#: ../../c-api/import.rst:130
msgid ""
"Given a module name (possibly of the form ``package.module``) and a code "
"object read from a Python bytecode file or obtained from the built-in "
"function :func:`compile`, load the module.  Return a new reference to the "
"module object, or *NULL* with an exception set if an error occurred.  Before "
"Python 2.4, the module could still be created in error cases.  Starting with "
"Python 2.4, *name* is removed from :attr:`sys.modules` in error cases, and "
"even if *name* was already in :attr:`sys.modules` on entry to :c:func:"
"`PyImport_ExecCodeModule`.  Leaving incompletely initialized modules in :"
"attr:`sys.modules` is dangerous, as imports of such modules have no way to "
"know that the module object is an unknown (and probably damaged with respect "
"to the module author's intents) state."
msgstr ""
"モジュール名 (``package.module`` 形式でもかまいません) および Python のバイト"
"コードファイルや組み込み関数 :func:`compile` で得られたコードオブジェクトを元"
"にモジュールをロードします。モジュールオブジェクトへの新たな参照を返します。"
"失敗した場合には例外をセットし、 *NULL* を返します。Python 2.4 以前では、失敗"
"した場合でもモジュールは生成されていることがありました。 Python 2.4 以降で"
"は、たとえ :c:func:`PyImport_ExecCodeModule` の処理に入った時に *name* が :"
"attr:`sys.modules` に入っていたとしても、 import に失敗したモジュールは :"
"attr:`sys.modules` に残りません。初期化の不完全なモジュールを :attr:`sys."
"modules` に残すのは危険であり、そのようなモジュールを import するコードにとっ"
"ては、モジュールの状態がわからない (モジュール作者の意図から外れた壊れた状態"
"かもしれない) からです。"

#: ../../c-api/import.rst:141
msgid ""
"The module's :attr:`__file__` attribute will be set to the code object's :c:"
"member:`co_filename`."
msgstr ""
"モジュールの :attr:`__file__` 属性が、コードオブジェクトの :c:member:"
"`co_filename` に設定されます。"

#: ../../c-api/import.rst:144
msgid ""
"This function will reload the module if it was already imported.  See :c:"
"func:`PyImport_ReloadModule` for the intended way to reload a module."
msgstr ""
"この関数は、すでに import されているモジュールの場合には再ロードを行います。"
"意図的にモジュールの再ロードを行う方法は :c:func:`PyImport_ReloadModule` を参"
"照してください。"

#: ../../c-api/import.rst:147
msgid ""
"If *name* points to a dotted name of the form ``package.module``, any "
"package structures not already created will still not be created."
msgstr ""
"*name* が ``package.module`` 形式のドット名表記であった場合、まだ作成されてい"
"ないパッケージ構造はその作成されないままになります。"

#: ../../c-api/import.rst:150
msgid "*name* is removed from :attr:`sys.modules` in error cases."
msgstr ""
"エラーが発生した場合に *name* を :attr:`sys.modules` から除去するようになりま"
"した。"

#: ../../c-api/import.rst:156
msgid ""
"Like :c:func:`PyImport_ExecCodeModule`, but the :attr:`__file__` attribute "
"of the module object is set to *pathname* if it is non-``NULL``."
msgstr ""
":c:func:`PyImport_ExecCodeModule` と似ていますが、*pathname* が ``NULL`` でな"
"い場合にモジュールオブジェクトの :attr:`__file__` 属性に *pathname* が設定さ"
"れる点が異なります。"

#: ../../c-api/import.rst:162
msgid ""
"Return the magic number for Python bytecode files (a.k.a. :file:`.pyc` and :"
"file:`.pyo` files).  The magic number should be present in the first four "
"bytes of the bytecode file, in little-endian byte order."
msgstr ""
"Python バイトコードファイル (いわゆる :file:`.pyc` および :file:`.pyo` ファイ"
"ル) のマジックナンバを返します。マジックナンバはバイトコードファイルの先頭 4 "
"バイトにリトルエンディアン整列で配置されています。"

#: ../../c-api/import.rst:169
msgid ""
"Return the dictionary used for the module administration (a.k.a. ``sys."
"modules``).  Note that this is a per-interpreter variable."
msgstr ""
"モジュール管理のための辞書 (いわゆる ``sys.modules``)を返します。この辞書はイ"
"ンタプリタごとに一つだけある変数なので注意してください。"

#: ../../c-api/import.rst:175
msgid ""
"Return an importer object for a :data:`sys.path`/:attr:`pkg.__path__` item "
"*path*, possibly by fetching it from the :data:`sys.path_importer_cache` "
"dict.  If it wasn't yet cached, traverse :data:`sys.path_hooks` until a hook "
"is found that can handle the path item.  Return ``None`` if no hook could; "
"this tells our caller it should fall back to the built-in import mechanism. "
"Cache the result in :data:`sys.path_importer_cache`.  Return a new reference "
"to the importer object."
msgstr ""
":data:`sys.path`/:attr:`pkg.__path__` の要素 *path* の、 importer オブジェク"
"トを返します。可能なら、 :data:`sys.path_importer_cache` からフェッチします。"
"まだキャッシュされていない場合、そのパスを扱える hook が見つかるまで :data:"
"`sys.path_hooks` を巡回します。 hook が見つからない場合、 ``None`` を返しま"
"す。この場合、呼び出し元はビルトインのインポート機構にフォールバックします。"
"結果は :data:`sys.path_importer_cache` にキャッシュされます。 importer オブ"
"ジェクトへの新しい参照を返します。"

#: ../../c-api/import.rst:188
msgid "Initialize the import mechanism.  For internal use only."
msgstr "import 機構を初期化します。内部使用だけのための関数です。"

#: ../../c-api/import.rst:193
msgid "Empty the module table.  For internal use only."
msgstr "モジュールテーブルを空にします。内部使用だけのための関数です。"

#: ../../c-api/import.rst:198
msgid "Finalize the import mechanism.  For internal use only."
msgstr "import 機構を終了処理します。内部使用だけのための関数です。"

#: ../../c-api/import.rst:203 ../../c-api/import.rst:208
msgid "For internal use only."
msgstr "内部使用だけのための関数です。"

#: ../../c-api/import.rst:213
msgid ""
"Load a frozen module named *name*.  Return ``1`` for success, ``0`` if the "
"module is not found, and ``-1`` with an exception set if the initialization "
"failed.  To access the imported module on a successful load, use :c:func:"
"`PyImport_ImportModule`.  (Note the misnomer --- this function would reload "
"the module if it was already imported.)"
msgstr ""
"*name* という名前のフリーズ (freeze) されたモジュールをロードします。成功する"
"と ``1`` を、モジュールが見つからなかった場合には ``0`` を、初期化が失敗した"
"場合には例外をセットして ``-1`` を返します。ロードに成功したモジュールにアク"
"セスするには :c:func:`PyImport_ImportModule` を使ってください。 (Note この関"
"数名はいささか誤称めいています --- この関数はすでに import 済みのモジュールを"
"リロードしてしまいます。)"

#: ../../c-api/import.rst:224
msgid ""
"This is the structure type definition for frozen module descriptors, as "
"generated by the :program:`freeze` utility (see :file:`Tools/freeze/` in the "
"Python source distribution).  Its definition, found in :file:`Include/import."
"h`, is::"
msgstr ""
":program:`freeze` ユーティリティが生成するようなフリーズ化モジュールデスクリ"
"プタの構造体型定義です。 (Python ソース配布物の :file:`Tools/freeze/` を参照"
"してください) この構造体の定義は :file:`Include/import.h` にあり、以下のよう"
"になっています::"

#: ../../c-api/import.rst:238
msgid ""
"This pointer is initialized to point to an array of :c:type:`struct _frozen` "
"records, terminated by one whose members are all *NULL* or zero.  When a "
"frozen module is imported, it is searched in this table.  Third-party code "
"could play tricks with this to provide a dynamically created collection of "
"frozen modules."
msgstr ""
"このポインタは :c:type:`struct _frozen` のレコードからなり、終端の要素のメン"
"バが *NULL* かゼロになっているような配列を指すよう初期化されます。フリーズさ"
"れたモジュールを import するとき、このテーブルを検索します。サードパーティ製"
"のコードからこのポインタに仕掛けを講じて、動的に生成されたフリーズ化モジュー"
"ルの集合を提供するようにできます。"

#: ../../c-api/import.rst:246
msgid ""
"Add a single module to the existing table of built-in modules.  This is a "
"convenience wrapper around :c:func:`PyImport_ExtendInittab`, returning "
"``-1`` if the table could not be extended.  The new module can be imported "
"by the name *name*, and uses the function *initfunc* as the initialization "
"function called on the first attempted import.  This should be called "
"before :c:func:`Py_Initialize`."
msgstr ""
"既存の組み込みモジュールテーブルに単一のモジュールを追加します。この関数は利"
"便性を目的とした :c:func:`PyImport_ExtendInittab` のラッパ関数で、テーブルが"
"拡張できないときには ``-1`` を返します。新たなモジュールは *name* で import "
"でき、最初に import を試みた際に呼び出される関数として *initfunc* を使いま"
"す。 :c:func:`Py_Initialize` よりも前に呼び出さなければなりません。"

#: ../../c-api/import.rst:256
msgid ""
"Structure describing a single entry in the list of built-in modules.  Each "
"of these structures gives the name and initialization function for a module "
"built into the interpreter.  Programs which embed Python may use an array of "
"these structures in conjunction with :c:func:`PyImport_ExtendInittab` to "
"provide additional built-in modules.  The structure is defined in :file:"
"`Include/import.h` as::"
msgstr ""
"組み込みモジュールリスト内の一つのエントリを記述している構造体です。リスト内"
"の各構造体には、インタプリタ内に組み込まれているモジュールの名前と初期化関数"
"が指定されています。 Python を埋め込むようなプログラムは、この構造体の配列"
"と :c:func:`PyImport_ExtendInittab` を組み合わせて、追加の組み込みモジュール"
"を提供できます。構造体は :file:`Include/import.h` で以下のように定義されてい"
"ます::"

#: ../../c-api/import.rst:271
msgid ""
"Add a collection of modules to the table of built-in modules.  The *newtab* "
"array must end with a sentinel entry which contains *NULL* for the :attr:"
"`name` field; failure to provide the sentinel value can result in a memory "
"fault. Returns ``0`` on success or ``-1`` if insufficient memory could be "
"allocated to extend the internal table.  In the event of failure, no modules "
"are added to the internal table.  This should be called before :c:func:"
"`Py_Initialize`."
msgstr ""
"組み込みモジュールのテーブルに一群のモジュールを追加します。配列 *newtab* "
"は :attr:`name` フィールドが *NULL* になっているセンチネル (sentinel) エント"
"リで終端されていなければなりません; センチネル値を与えられなかった場合にはメ"
"モリ違反になるかもしれません。成功すると ``0`` を、内部テーブルを拡張するのに"
"十分なメモリを確保できなかった場合には ``-1`` を返します。操作が失敗した場"
"合、モジュールは一切内部テーブルに追加されません。 :c:func:`Py_Initialize` よ"
"りも前に呼び出さなければなりません。"
