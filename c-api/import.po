# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-05 15:01+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/import.rst:6
msgid "Importing Modules"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ"

#: ../../c-api/import.rst:16
msgid ""
"This is a simplified interface to :c:func:`PyImport_ImportModuleEx` below, "
"leaving the *globals* and *locals* arguments set to *NULL* and *level* set "
"to 0.  When the *name* argument contains a dot (when it specifies a "
"submodule of a package), the *fromlist* argument is set to the list "
"``['*']`` so that the return value is the named module rather than the top-"
"level package containing it as would otherwise be the case.  (Unfortunately,"
" this has an additional side effect when *name* in fact specifies a "
"subpackage instead of a submodule: the submodules specified in the package's"
" ``__all__`` variable are  loaded.)  Return a new reference to the imported "
"module, or *NULL* with an exception set on failure.  A failing import of a "
"module doesn't leave the module in :data:`sys.modules`."
msgstr ""
"ã“ã®é–¢æ•°ã¯ä¸‹ã§è¿°ã¹ã‚‹ :c:func:`PyImport_ImportModuleEx` ã‚’å˜ç´”åŒ–ã—ãŸã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã§ã€ *globals* ãŠã‚ˆã³ "
"*locals*  å¼•æ•°ã‚’ *NULL* ã®ã¾ã¾ã«ã—ã€ *level* ã‚’ 0 ã«ã—ãŸã‚‚ã®ã§ã™ã€‚ *name* å¼•æ•°ã«ãƒ‰ãƒƒãƒˆãŒå«ã¾ã‚Œã‚‹å ´åˆ "
"(ã‚ã‚‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æŒ‡å®šã—ã¦ã„ã‚‹å ´åˆ)ã€ *fromlist* å¼•æ•°ãŒãƒªã‚¹ãƒˆ ``['*']`` "
"ã«è¿½åŠ ã•ã‚Œã€æˆ»ã‚Šå€¤ãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å«ã‚€ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã¯ãªãåå‰ã¤ããƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« (named module) ã«ãªã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ "
"(æ®‹å¿µãªãŒã‚‰ã“ã®ã‚„ã‚Šæ–¹ã«ã¯ã€ *name* ãŒå®Ÿéš›ã«ã¯ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ãªãã‚µãƒ–ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’æŒ‡å®šã—ã¦ã„ã‚‹å ´åˆã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®  ``__all__``   "
"å¤‰æ•°ã«æŒ‡å®šã•ã‚Œã¦ã„ã‚‹ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã—ã¾ã†ã¨ã„ã†å‰¯ä½œç”¨ãŒã‚ã‚Šã¾ã™ã€‚) "
"ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¸ã®æ–°ãŸãªå‚ç…§ã‚’è¿”ã—ã¾ã™ã€‚å¤±æ•—ã—ãŸå ´åˆã«ã¯ä¾‹å¤–ã‚’ã‚»ãƒƒãƒˆã—ã€ *NULL* ã‚’è¿”ã—ã¾ã™ã€‚ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ "
":data:`sys.modules` ã«æ®‹ã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/import.rst:28 ../../c-api/import.rst:89
msgid "This function always uses absolute imports."
msgstr "ã“ã®é–¢æ•°ã¯å¸¸ã«çµ¶å¯¾ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../c-api/import.rst:33
msgid ""
"This function is a deprecated alias of :c:func:`PyImport_ImportModule`."
msgstr "ã“ã®é–¢æ•°ã¯ã€ :c:func:`PyImport_ImportModule` ã®å»ƒæ­¢äºˆå®šã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã§ã™ã€‚"

#: ../../c-api/import.rst:35
msgid ""
"This function used to fail immediately when the import lock was held by "
"another thread.  In Python 3.3 though, the locking scheme switched to per-"
"module locks for most purposes, so this function's special behaviour isn't "
"needed anymore."
msgstr ""
"ã“ã®é–¢æ•°ã¯ã€å¾“æ¥ã¯åˆ¥ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«ã‚ˆã£ã¦ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ­ãƒƒã‚¯ãŒè¡Œã‚ã‚Œã¦ã„ãŸå ´åˆã¯å³åº§ã«å¤±æ•—ã—ã¦ã„ã¾ã—ãŸã€‚ã—ã‹ã— Python 3.3 "
"ã§ã¯ã€å¤§éƒ¨åˆ†ã®ç›®çš„ã§ãƒ­ãƒƒã‚¯ã‚¹ã‚­ãƒ¼ãƒ ãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã”ã¨ã®ãƒ­ãƒƒã‚¯ã«ç§»è¡Œã—ãŸã®ã§ã€ã“ã®é–¢æ•°ã®ç‰¹åˆ¥ãªæŒ¯ã‚‹èˆã„ã¯ã‚‚ã¯ã‚„å¿…è¦ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/import.rst:46
msgid ""
"Import a module.  This is best described by referring to the built-in Python"
" function :func:`__import__`."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«ã¤ã„ã¦ã¯çµ„ã¿è¾¼ã¿ã® Python é–¢æ•° :func:`__import__` "
"ã‚’èª­ã‚€ã¨ã‚ˆãã‚ã‹ã‚Šã¾ã™ã€‚"

#: ../../c-api/import.rst:49 ../../c-api/import.rst:65
msgid ""
"The return value is a new reference to the imported module or top-level "
"package, or *NULL* with an exception set on failure.  Like for "
":func:`__import__`, the return value when a submodule of a package was "
"requested is normally the top-level package, unless a non-empty *fromlist* "
"was given."
msgstr ""
"æˆ»ã‚Šå€¤ã¯ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¸ã®æ–°ã—ã„å‚ç…§ã‹ã€å¤±æ•—ã—ãŸå ´åˆã¯ä¾‹å¤–ã‚’è¨­å®šã—ã¦ *NULL* ã‚’è¿”ã—ã¾ã™ã€‚ "
":func:`__import__` ã¨åŒã˜ã‚ˆã†ã«ã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦æ±‚ã•ã‚ŒãŸã¨ãã¯ã€ç©ºã§ãªã„ *fromlist* "
"ã‚’æ¸¡ã•ã‚ŒãŸæ™‚ä»¥å¤–ã¯ã€ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/import.rst:55
msgid ""
"Failing imports remove incomplete module objects, like with "
":c:func:`PyImport_ImportModule`."
msgstr ""
"ã‚¤ãƒ³ãƒãƒ¼ãƒˆãŒå¤±æ•—ã—ãŸå ´åˆã¯ã€:c:func:`PyImport_ImportModule` ã¨åŒæ§˜ã«ä¸å®Œå…¨ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‰Šé™¤ã—ã¾ã™ã€‚"

#: ../../c-api/import.rst:61
msgid ""
"Import a module.  This is best described by referring to the built-in Python"
" function :func:`__import__`, as the standard :func:`__import__` function "
"calls this function directly."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«ã¤ã„ã¦ã¯çµ„ã¿è¾¼ã¿ã® Python é–¢æ•° :func:`__import__` "
"ã‚’èª­ã‚€ã¨ã‚ˆãåˆ†ã‹ã‚Šã¾ã™ã€‚ã¨ã„ã†ã®ã‚‚ã€æ¨™æº–ã® :func:`__import__`  ã¯ã“ã®é–¢æ•°ã‚’ç›´æ¥å‘¼ã³å‡ºã—ã¦ã„ã‚‹ã‹ã‚‰ã§ã™ã€‚"

#: ../../c-api/import.rst:75
msgid ""
"Similar to :c:func:`PyImport_ImportModuleLevelObject`, but the name is a "
"UTF-8 encoded string instead of a Unicode object."
msgstr ""
":c:func:`PyImport_ImportModuleLevelObject` ã¨ä¼¼ã¦ã„ã¾ã™ãŒã€name ãŒ Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ãªã"
" UTF-8 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸæ–‡å­—åˆ—ã§ã‚ã‚‹ç‚¹ã§ç•°ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/import.rst:78
msgid "Negative values for *level* are no longer accepted."
msgstr "*level* ã«ã¯ã‚‚ã¯ã‚„è² ã®å€¤ã¯ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚"

#: ../../c-api/import.rst:83
msgid ""
"This is a higher-level interface that calls the current \"import hook "
"function\" (with an explicit *level* of 0, meaning absolute import).  It "
"invokes the :func:`__import__` function from the ``__builtins__`` of the "
"current globals.  This means that the import is done using whatever import "
"hooks are installed in the current environment."
msgstr ""
"ç¾åœ¨ã® \"ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ•ãƒƒã‚¯é–¢æ•°\" ã‚’å‘¼ã³å‡ºã™ãŸã‚ã®é«˜æ°´æº–ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã§ã™ (*level* ã« 0 ã‚’æ˜ç¤ºã™ã‚‹ã¨ã€çµ¶å¯¾ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’æ„å‘³ã—ã¾ã™)ã€‚"
" ã“ã®é–¢æ•°ã¯ç¾åœ¨ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°è¾æ›¸å†…ã® ``__builtins__`` ã‹ã‚‰ :func:`__import__` "
"é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ã™ãªã‚ã¡ã€ç¾åœ¨ã®ç’°å¢ƒã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ•ãƒƒã‚¯ä½¿ã£ã¦ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’è¡Œã„ã¾ã™ã€‚"

#: ../../c-api/import.rst:94
msgid ""
"Reload a module.  Return a new reference to the reloaded module, or *NULL* "
"with an exception set on failure (the module still exists in this case)."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å†ãƒ­ãƒ¼ãƒ‰ (reload) "
"ã—ã¾ã™ã€‚æˆ»ã‚Šå€¤ã¯å†ãƒ­ãƒ¼ãƒ‰ã—ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¸ã®æ–°ãŸãªå‚ç…§ã«ãªã‚Šã¾ã™ã€‚å¤±æ•—ã—ãŸå ´åˆã«ã¯ä¾‹å¤–ã‚’ã‚»ãƒƒãƒˆã—ã€*NULL* ã‚’è¿”ã—ã¾ã™ "
"(ãã®å ´åˆã§ã‚‚ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ç”Ÿæˆã•ã‚Œã¦ã„ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™)ã€‚"

#: ../../c-api/import.rst:100
msgid ""
"Return the module object corresponding to a module name.  The *name* "
"argument may be of the form ``package.module``. First check the modules "
"dictionary if there's one there, and if not, create a new one and insert it "
"in the modules dictionary. Return *NULL* with an exception set on failure."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã«å¯¾å¿œã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚*name* å¼•æ•°ã¯ ``package.module`` "
"ã®å½¢å¼ã§ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚ã¾ãšãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è¾æ›¸ã«è©²å½“ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚ã‚‹ã‹ã©ã†ã‹èª¿ã¹ã€ãªã‘ã‚Œã°æ–°ãŸãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç”Ÿæˆã—ã¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è¾æ›¸ã«æŒ¿å…¥ã—ã¾ã™ã€‚å¤±æ•—ã—ãŸå ´åˆã«ã¯ä¾‹å¤–ã‚’ã‚»ãƒƒãƒˆã—ã¦"
" *NULL* ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/import.rst:107
msgid ""
"This function does not load or import the module; if the module wasn't "
"already loaded, you will get an empty module object. Use "
":c:func:`PyImport_ImportModule` or one of its variants to import a module.  "
"Package structures implied by a dotted name for *name* are not created if "
"not already present."
msgstr ""
"ã“ã®é–¢æ•°ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚„ãƒ­ãƒ¼ãƒ‰ã‚’è¡Œã„ã¾ã›ã‚“; ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã¾ã ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã€ç©ºã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¾—ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ "
":c:func:`PyImport_ImportModule` ã‚„ãã®åˆ¥å½¢å¼ã‚’ä½¿ã£ã¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ãã ã•ã„ã€‚ãƒ‰ãƒƒãƒˆåè¡¨è¨˜ã§æŒ‡å®šã—ãŸ "
"*name* ãŒå­˜åœ¨ã—ãªã„å ´åˆã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸æ§‹é€ ã¯ä½œæˆã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../c-api/import.rst:117
msgid ""
"Similar to :c:func:`PyImport_AddModuleObject`, but the name is a UTF-8 "
"encoded string instead of a Unicode object."
msgstr ""
":c:func:`PyImport_AddModuleObject` ã¨ä¼¼ã¦ã„ã¾ã™ãŒã€name ãŒ UTF-8 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸæ–‡å­—åˆ—ã§ã¯ãªã "
"Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ç”¨ã™ã‚‹ç‚¹ã§ç•°ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/import.rst:125
msgid ""
"Given a module name (possibly of the form ``package.module``) and a code "
"object read from a Python bytecode file or obtained from the built-in "
"function :func:`compile`, load the module.  Return a new reference to the "
"module object, or *NULL* with an exception set if an error occurred.  *name*"
" is removed from :attr:`sys.modules` in error cases, even if *name* was "
"already in :attr:`sys.modules` on entry to "
":c:func:`PyImport_ExecCodeModule`.  Leaving incompletely initialized modules"
" in :attr:`sys.modules` is dangerous, as imports of such modules have no way"
" to know that the module object is an unknown (and probably damaged with "
"respect to the module author's intents) state."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å (``package.module`` å½¢å¼ã§ã‚‚æ§‹ã„ã¾ã›ã‚“) ãŠã‚ˆã³ Python ã®ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚„çµ„ã¿è¾¼ã¿é–¢æ•° "
":func:`compile`  "
"ã§å¾—ã‚‰ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å…ƒã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®æ–°ãŸãªå‚ç…§ã‚’è¿”ã—ã¾ã™ã€‚å¤±æ•—ã—ãŸå ´åˆã«ã¯ä¾‹å¤–ã‚’ã‚»ãƒƒãƒˆã—ã€ "
"*NULL* ã‚’è¿”ã—ã¾ã™ã€‚ãŸã¨ãˆ :c:func:`PyImport_ExecCodeModule` ã®å‡¦ç†ã«å…¥ã£ãŸæ™‚ã« *name* ãŒ "
":attr:`sys.modules` ã«å…¥ã£ã¦ã„ãŸã¨ã—ã¦ã‚‚ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ :attr:`sys.modules` "
"ã«æ®‹ã‚Šã¾ã›ã‚“ã€‚åˆæœŸåŒ–ã®ä¸å®Œå…¨ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ :attr:`sys.modules` "
"ã«æ®‹ã™ã®ã¯å±é™ºã§ã‚ã‚Šã€ãã®ã‚ˆã†ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã‚³ãƒ¼ãƒ‰ã«ã¨ã£ã¦ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®çŠ¶æ…‹ãŒã‚ã‹ã‚‰ãªã„ "
"(ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä½œè€…ã®æ„å›³ã‹ã‚‰å¤–ã‚ŒãŸå£Šã‚ŒãŸçŠ¶æ…‹ã‹ã‚‚ã—ã‚Œãªã„) ã‹ã‚‰ã§ã™ã€‚"

#: ../../c-api/import.rst:135
msgid ""
"The module's :attr:`__spec__` and :attr:`__loader__` will be set, if not set"
" already, with the appropriate values.  The spec's loader will be set to the"
" module's ``__loader__`` (if set) and to an instance of "
":class:`SourceFileLoader` otherwise."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® :attr:`__spec__` ã¨ :attr:`__loader__` ãŒã¾ã è¨­å®šã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã€é©åˆ‡ãªå€¤ãŒè¨­å®šã•ã‚Œã¾ã™ã€‚spec "
"ã® ãƒ­ãƒ¼ãƒ€ãƒ¼ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® ``__loader__`` ãŒ (ã‚‚ã—è¨­å®šã•ã‚Œã¦ã„ã‚Œã°) ãã‚Œã«è¨­å®šã•ã‚Œã€ãã†ã§ãªã‘ã‚Œã°  "
":class:`SourceFileLoader` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«è¨­å®šã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/import.rst:140
msgid ""
"The module's :attr:`__file__` attribute will be set to the code object's "
":c:member:`co_filename`.  If applicable, :attr:`__cached__` will also be "
"set."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® :attr:`__file__`  å±æ€§ã¯ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :c:member:`co_filename` "
"ã¸è¨­å®šã•ã‚Œã¾ã™ã€‚ã‚‚ã—é©åˆ‡ãªå ´åˆã¯ã€ :attr:`__cached__`  ã¸ã‚‚è¨­å®šã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/import.rst:144
msgid ""
"This function will reload the module if it was already imported.  See "
":c:func:`PyImport_ReloadModule` for the intended way to reload a module."
msgstr ""
"ã“ã®é–¢æ•°ã¯ã€ã™ã§ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å ´åˆã«ã¯å†ãƒ­ãƒ¼ãƒ‰ã‚’è¡Œã„ã¾ã™ã€‚æ„å›³çš„ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å†ãƒ­ãƒ¼ãƒ‰ã‚’è¡Œã†æ–¹æ³•ã¯ "
":c:func:`PyImport_ReloadModule` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../c-api/import.rst:147
msgid ""
"If *name* points to a dotted name of the form ``package.module``, any "
"package structures not already created will still not be created."
msgstr ""
"*name* ãŒ ``package.module`` "
"å½¢å¼ã®ãƒ‰ãƒƒãƒˆåè¡¨è¨˜ã§ã‚ã£ãŸå ´åˆã€ã¾ã ä½œæˆã•ã‚Œã¦ã„ãªã„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸æ§‹é€ ã¯ãã®ä½œæˆã•ã‚Œãªã„ã¾ã¾ã«ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/import.rst:150
msgid ""
"See also :c:func:`PyImport_ExecCodeModuleEx` and "
":c:func:`PyImport_ExecCodeModuleWithPathnames`."
msgstr ""
":c:func:`PyImport_ExecCodeModuleEx` ã¨ "
":c:func:`PyImport_ExecCodeModuleWithPathnames` ã‚‚å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../c-api/import.rst:156
msgid ""
"Like :c:func:`PyImport_ExecCodeModule`, but the :attr:`__file__` attribute "
"of the module object is set to *pathname* if it is non-``NULL``."
msgstr ""
":c:func:`PyImport_ExecCodeModule` ã¨ä¼¼ã¦ã„ã¾ã™ãŒã€*pathname* ãŒ ``NULL`` "
"ã§ãªã„å ´åˆã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :attr:`__file__` å±æ€§ã« *pathname* ãŒè¨­å®šã•ã‚Œã‚‹ç‚¹ãŒç•°ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/import.rst:159
msgid "See also :c:func:`PyImport_ExecCodeModuleWithPathnames`."
msgstr ":c:func:`PyImport_ExecCodeModuleWithPathnames` ã‚‚å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../c-api/import.rst:164
msgid ""
"Like :c:func:`PyImport_ExecCodeModuleEx`, but the :attr:`__cached__` "
"attribute of the module object is set to *cpathname* if it is non-``NULL``."
"  Of the three functions, this is the preferred one to use."
msgstr ""
":c:func:`PyImport_ExecCodeModuleEx` ã¨ä¼¼ã¦ã„ã¾ã™ãŒã€*cpathname* ãŒ ``NULL`` "
"ã§ãªã„å ´åˆã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :attr:`__cached__` å±æ€§ã« *cpathname* ãŒè¨­å®šã•ã‚Œã‚‹ç‚¹ãŒç•°ãªã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã® 3 "
"ã¤ã®é–¢æ•°ã®ã†ã¡ã€ã“ã®é–¢æ•°ã®ä½¿ç”¨ãŒæœ›ã¾ã—ã„ã§ã™ã€‚"

#: ../../c-api/import.rst:173
msgid ""
"Like :c:func:`PyImport_ExecCodeModuleObject`, but *name*, *pathname* and "
"*cpathname* are UTF-8 encoded strings. Attempts are also made to figure out "
"what the value for *pathname* should be from *cpathname* if the former is "
"set to ``NULL``."
msgstr ""
":c:func:`PyImport_ExecCodeModuleObject` ã¨ä¼¼ã¦ã„ã¾ã™ãŒã€ *name* ã¨ *pathname*ã€ "
"*cpathname* ãŒ UTF-8 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸæ–‡å­—åˆ—ã§ã‚ã‚‹ç‚¹ãŒç•°ãªã‚Šã¾ã™ã€‚ã‚‚ã— *pathname* ãŒ ``NULL`` "
"ã®å ´åˆã€*cpathname* ã‹ã‚‰ã€*pathname* ã©ã®ã‚ˆã†ãªå€¤ã«ãªã‚‹ã¹ãã‹ã‚’çŸ¥ã‚‹è©¦ã¿ã‚‚ãªã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/import.rst:179
msgid ""
"Uses :func:`imp.source_from_cache()` in calculating the source path if only "
"the bytecode path is provided."
msgstr ""
"ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ã®ãƒ‘ã‚¹ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã«ã®ã¿ :func:`imp.source_from_cache()` ãŒã‚½ãƒ¼ã‚¹ãƒ‘ã‚¹ã®è¨ˆç®—ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/import.rst:186
msgid ""
"Return the magic number for Python bytecode files (a.k.a. :file:`.pyc` "
"file). The magic number should be present in the first four bytes of the "
"bytecode file, in little-endian byte order. Returns ``-1`` on error."
msgstr ""
"Python ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ« (åˆ¥å :file:`.pyc` ãƒ•ã‚¡ã‚¤ãƒ«) "
"ã®ãƒã‚¸ãƒƒã‚¯ãƒŠãƒ³ãƒãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚ãƒã‚¸ãƒƒã‚¯ãƒŠãƒ³ãƒãƒ¼ã¯ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã®æœ€åˆã®4ãƒã‚¤ãƒˆã«ã€ãƒªãƒˆãƒ«ã‚¨ãƒ³ãƒ‡ã‚£ã‚¢ãƒ³ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ãƒ¼ã§ç¾ã‚Œã‚‹ã¹ãã§ã™ã€‚ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯"
" ``-1`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/import.rst:190
msgid "Return value of ``-1`` upon failure."
msgstr "å¤±æ•—ã—ãŸå ´åˆã¯ ``-1`` ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/import.rst:196
msgid ""
"Return the magic tag string for :pep:`3147` format Python bytecode file "
"names.  Keep in mind that the value at ``sys.implementation.cache_tag`` is "
"authoritative and should be used instead of this function."
msgstr ""
"ãƒã‚¸ãƒƒã‚¯ã‚¿ã‚°æ–‡å­—åˆ—ã‚’ Python ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«åã® :pep:`3147` "
"ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§è¿”ã—ã¾ã™ã€‚``sys.implementation.cache_tag`` "
"ã®å€¤ãŒä¿¡é ¼ã§ãã€ã‹ã¤ã“ã®é–¢æ•°ã®ä»£ã‚ã‚Šã«ä½¿ç”¨ã™ã¹ãã§ã‚ã‚‹ã“ã¨ã‚’è‚ã«å‘½ã˜ã¾ã—ã‚‡ã†ã€‚"

#: ../../c-api/import.rst:204
msgid ""
"Return the dictionary used for the module administration (a.k.a. "
"``sys.modules``).  Note that this is a per-interpreter variable."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ç®¡ç†ã®ãŸã‚ã®è¾æ›¸ (ã„ã‚ã‚†ã‚‹ ``sys.modules``)ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®è¾æ›¸ã¯ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã”ã¨ã«ä¸€ã¤ã ã‘ã‚ã‚‹å¤‰æ•°ãªã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../c-api/import.rst:210
msgid ""
"Return a finder object for a :data:`sys.path`/:attr:`pkg.__path__` item "
"*path*, possibly by fetching it from the :data:`sys.path_importer_cache` "
"dict.  If it wasn't yet cached, traverse :data:`sys.path_hooks` until a hook"
" is found that can handle the path item.  Return ``None`` if no hook could; "
"this tells our caller that the :term:`path based finder` could not find a "
"finder for this path item. Cache the result in "
":data:`sys.path_importer_cache`. Return a new reference to the finder "
"object."
msgstr ""
":data:`sys.path` ã‚‚ã—ãã¯ :attr:`pkg.__path__` ã®è¦ç´ ã§ã‚ã‚‹ *path* ã‚’è¦‹ä»˜ã‘ã‚‹ãŸã‚ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚å ´åˆã«ã‚ˆã£ã¦ã¯ :data:`sys.path_importer_cache` è¾æ›¸ã‹ã‚‰å–å¾—ã™ã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚\n"
"ã‚‚ã—ã¾ã ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚Œã¦ã„ãªã‹ã£ãŸå ´åˆã¯ã€ path è¦ç´ ã‚’æ‰±ãˆã‚‹ãƒ•ãƒƒã‚¯ãŒè¦‹ä»˜ã‹ã‚‹ã¾ã§ :data:`sys.path_hooks` ã‚’èµ°æŸ»ã—ã¾ã™ã€‚\n"
"ã©ã®ãƒ•ãƒƒã‚¯ã‚‚ path è¦ç´ ã‚’æ‰±ãˆãªã„å ´åˆã¯ ``None`` ã‚’è¿”ã—ã¾ã™; ã“ã‚Œã«ã‚ˆã‚Šã€ :term:`path based finder` ãŒã“ã® path è¦ç´ ã‚’è¦‹ä»˜ã‘ã‚‹ãŸã‚ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå¾—ã‚‰ã‚Œãªã‹ã£ãŸã“ã¨ã‚’å‘¼ã³å‡ºã—å…ƒã«ä¼ãˆã¾ã™ã€‚\n"
"æœ€çµ‚çš„ã«å¾—ã‚‰ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ :data:`sys.path_importer_cache` ã¸ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®æ–°ãŸãªå‚ç…§ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/import.rst:221
msgid "Initialize the import mechanism.  For internal use only."
msgstr "ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã‚’åˆæœŸåŒ–ã—ã¾ã™ã€‚å†…éƒ¨ä½¿ç”¨ã ã‘ã®ãŸã‚ã®é–¢æ•°ã§ã™ã€‚"

#: ../../c-api/import.rst:226
msgid "Empty the module table.  For internal use only."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ç©ºã«ã—ã¾ã™ã€‚å†…éƒ¨ä½¿ç”¨ã ã‘ã®ãŸã‚ã®é–¢æ•°ã§ã™ã€‚"

#: ../../c-api/import.rst:231
msgid "Finalize the import mechanism.  For internal use only."
msgstr "ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã‚’çµ‚äº†å‡¦ç†ã—ã¾ã™ã€‚å†…éƒ¨ä½¿ç”¨ã ã‘ã®ãŸã‚ã®é–¢æ•°ã§ã™ã€‚"

#: ../../c-api/import.rst:236
msgid "For internal use only."
msgstr "å†…éƒ¨ä½¿ç”¨ã ã‘ã®ãŸã‚ã®é–¢æ•°ã§ã™ã€‚"

#: ../../c-api/import.rst:241
msgid ""
"Load a frozen module named *name*.  Return ``1`` for success, ``0`` if the "
"module is not found, and ``-1`` with an exception set if the initialization "
"failed.  To access the imported module on a successful load, use "
":c:func:`PyImport_ImportModule`.  (Note the misnomer --- this function would"
" reload the module if it was already imported.)"
msgstr ""
"*name* ã¨ã„ã†åå‰ã®ãƒ•ãƒªãƒ¼ã‚º (freeze) ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚æˆåŠŸã™ã‚‹ã¨ ``1`` ã‚’ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã«ã¯ "
"``0`` ã‚’ã€åˆæœŸåŒ–ãŒå¤±æ•—ã—ãŸå ´åˆã«ã¯ä¾‹å¤–ã‚’ã‚»ãƒƒãƒˆã—ã¦ ``-1`` ã‚’è¿”ã—ã¾ã™ã€‚ãƒ­ãƒ¼ãƒ‰ã«æˆåŠŸã—ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã«ã¯ "
":c:func:`PyImport_ImportModule` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚ (Note ã“ã®é–¢æ•°ã¯ã„ã•ã•ã‹èª¤è§£ã‚’æ‹›ãåå‰ã§ã™ --- "
"ã“ã®é–¢æ•°ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã™ã§ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãŸã‚‰ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ã—ã¾ã„ã¾ã™ã€‚)"

#: ../../c-api/import.rst:249
msgid "The ``__file__`` attribute is no longer set on the module."
msgstr "``__file__`` å±æ€§ã¯ã‚‚ã†ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚»ãƒƒãƒˆã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../c-api/import.rst:255
msgid ""
"Similar to :c:func:`PyImport_ImportFrozenModuleObject`, but the name is a "
"UTF-8 encoded string instead of a Unicode object."
msgstr ""
":c:func:`PyImport_ImportFrozenModuleObject` ã¨ä¼¼ã¦ã„ã¾ã™ãŒã€name ã¯ UTF-8 "
"ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸæ–‡å­—åˆ—ã®ä»£ã‚ã‚Šã«ã€ Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ç”¨ã™ã‚‹ç‚¹ãŒç•°ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/import.rst:263
msgid ""
"This is the structure type definition for frozen module descriptors, as "
"generated by the :program:`freeze` utility (see :file:`Tools/freeze/` in the"
" Python source distribution).  Its definition, found in "
":file:`Include/import.h`, is::"
msgstr ""
":program:`freeze` ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãŒç”Ÿæˆã™ã‚‹ã‚ˆã†ãªãƒ•ãƒªãƒ¼ã‚ºåŒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®æ§‹é€ ä½“å‹å®šç¾©ã§ã™ã€‚ (Python ã‚½ãƒ¼ã‚¹é…å¸ƒç‰©ã® "
":file:`Tools/freeze/` ã‚’å‚ç…§ã—ã¦ãã ã•ã„) ã“ã®æ§‹é€ ä½“ã®å®šç¾©ã¯ :file:`Include/import.h` "
"ã«ã‚ã‚Šã€ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™::"

#: ../../c-api/import.rst:277
msgid ""
"This pointer is initialized to point to an array of :c:type:`struct _frozen`"
" records, terminated by one whose members are all *NULL* or zero.  When a "
"frozen module is imported, it is searched in this table.  Third-party code "
"could play tricks with this to provide a dynamically created collection of "
"frozen modules."
msgstr ""
"ã“ã®ãƒã‚¤ãƒ³ã‚¿ã¯ :c:type:`struct _frozen` ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ãªã‚Šã€çµ‚ç«¯ã®è¦ç´ ã®ãƒ¡ãƒ³ãƒãŒ *NULL* "
"ã‹ã‚¼ãƒ­ã«ãªã£ã¦ã„ã‚‹ã‚ˆã†ãªé…åˆ—ã‚’æŒ‡ã™ã‚ˆã†åˆæœŸåŒ–ã•ã‚Œã¾ã™ã€‚ãƒ•ãƒªãƒ¼ã‚ºã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã¨ãã€ã“ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’æ¤œç´¢ã—ã¾ã™ã€‚ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£è£½ã®ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ã“ã®ãƒã‚¤ãƒ³ã‚¿ã«ä»•æ›ã‘ã‚’è¬›ã˜ã¦ã€å‹•çš„ã«ç”Ÿæˆã•ã‚ŒãŸãƒ•ãƒªãƒ¼ã‚ºåŒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®é›†åˆã‚’æä¾›ã™ã‚‹ã‚ˆã†ã«ã§ãã¾ã™ã€‚"

#: ../../c-api/import.rst:285
msgid ""
"Add a single module to the existing table of built-in modules.  This is a "
"convenience wrapper around :c:func:`PyImport_ExtendInittab`, returning "
"``-1`` if the table could not be extended.  The new module can be imported "
"by the name *name*, and uses the function *initfunc* as the initialization "
"function called on the first attempted import.  This should be called before"
" :c:func:`Py_Initialize`."
msgstr ""
"æ—¢å­˜ã®çµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ†ãƒ¼ãƒ–ãƒ«ã«å˜ä¸€ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¿½åŠ ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯åˆ©ä¾¿æ€§ã‚’ç›®çš„ã¨ã—ãŸ "
":c:func:`PyImport_ExtendInittab` ã®ãƒ©ãƒƒãƒ‘é–¢æ•°ã§ã€ãƒ†ãƒ¼ãƒ–ãƒ«ãŒæ‹¡å¼µã§ããªã„ã¨ãã«ã¯ ``-1`` "
"ã‚’è¿”ã—ã¾ã™ã€‚æ–°ãŸãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ *name* ã§ã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ãã€æœ€åˆã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’è©¦ã¿ãŸéš›ã«å‘¼ã³å‡ºã•ã‚Œã‚‹é–¢æ•°ã¨ã—ã¦ *initfunc* ã‚’ä½¿ã„ã¾ã™ã€‚ "
":c:func:`Py_Initialize` ã‚ˆã‚Šã‚‚å‰ã«å‘¼ã³å‡ºã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/import.rst:295
msgid ""
"Structure describing a single entry in the list of built-in modules.  Each "
"of these structures gives the name and initialization function for a module "
"built into the interpreter.  The name is an ASCII encoded string.  Programs "
"which embed Python may use an array of these structures in conjunction with "
":c:func:`PyImport_ExtendInittab` to provide additional built-in modules. The"
" structure is defined in :file:`Include/import.h` as::"
msgstr ""
"çµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒªã‚¹ãƒˆå†…ã®ä¸€ã¤ã®ã‚¨ãƒ³ãƒˆãƒªã‚’è¨˜è¿°ã—ã¦ã„ã‚‹æ§‹é€ ä½“ã§ã™ã€‚ãƒªã‚¹ãƒˆå†…ã®å„æ§‹é€ ä½“ã«ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿å†…ã«çµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ã¨åˆæœŸåŒ–é–¢æ•°ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã™ã€‚"
" Python ã‚’åŸ‹ã‚è¾¼ã‚€ã‚ˆã†ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€ã“ã®æ§‹é€ ä½“ã®é…åˆ—ã¨ :c:func:`PyImport_ExtendInittab` "
"ã‚’çµ„ã¿åˆã‚ã›ã¦ã€è¿½åŠ ã®çµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æä¾›ã§ãã¾ã™ã€‚æ§‹é€ ä½“ã¯ :file:`Include/import.h` ã§ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™::"

#: ../../c-api/import.rst:310
msgid ""
"Add a collection of modules to the table of built-in modules.  The *newtab* "
"array must end with a sentinel entry which contains *NULL* for the "
":attr:`name` field; failure to provide the sentinel value can result in a "
"memory fault. Returns ``0`` on success or ``-1`` if insufficient memory "
"could be allocated to extend the internal table.  In the event of failure, "
"no modules are added to the internal table.  This should be called before "
":c:func:`Py_Initialize`."
msgstr ""
"çµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã«ä¸€ç¾¤ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¿½åŠ ã—ã¾ã™ã€‚é…åˆ— *newtab* ã¯ :attr:`name` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒ *NULL* "
"ã«ãªã£ã¦ã„ã‚‹ã‚»ãƒ³ãƒãƒãƒ« (sentinel) ã‚¨ãƒ³ãƒˆãƒªã§çµ‚ç«¯ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“; "
"ã‚»ãƒ³ãƒãƒãƒ«å€¤ã‚’ä¸ãˆã‚‰ã‚Œãªã‹ã£ãŸå ´åˆã«ã¯ãƒ¡ãƒ¢ãƒªé•åã«ãªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚æˆåŠŸã™ã‚‹ã¨ ``0`` "
"ã‚’ã€å†…éƒ¨ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’æ‹¡å¼µã™ã‚‹ã®ã«ååˆ†ãªãƒ¡ãƒ¢ãƒªã‚’ç¢ºä¿ã§ããªã‹ã£ãŸå ´åˆã«ã¯ ``-1`` "
"ã‚’è¿”ã—ã¾ã™ã€‚æ“ä½œãŒå¤±æ•—ã—ãŸå ´åˆã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ä¸€åˆ‡å†…éƒ¨ãƒ†ãƒ¼ãƒ–ãƒ«ã«è¿½åŠ ã•ã‚Œã¾ã›ã‚“ã€‚ :c:func:`Py_Initialize` "
"ã‚ˆã‚Šã‚‚å‰ã«å‘¼ã³å‡ºã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"
