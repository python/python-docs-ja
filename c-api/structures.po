# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-12-30 14:59+0000\n"
"PO-Revision-Date: 2022-11-05 17:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2022\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/structures.rst:6
msgid "Common Object Structures"
msgstr "共通のオブジェクト構造体 (common object structure)"

#: ../../c-api/structures.rst:8
msgid ""
"There are a large number of structures which are used in the definition of "
"object types for Python.  This section describes these structures and how "
"they are used."
msgstr ""
"Python では、オブジェクト型を定義する上で数多くの構造体が使われます。この節で"
"は三つの構造体とその利用方法について説明します。"

#: ../../c-api/structures.rst:14
msgid "Base object types and macros"
msgstr ""

#: ../../c-api/structures.rst:16
msgid ""
"All Python objects ultimately share a small number of fields at the "
"beginning of the object's representation in memory.  These are represented "
"by the :c:type:`PyObject` and :c:type:`PyVarObject` types, which are "
"defined, in turn, by the expansions of some macros also used, whether "
"directly or indirectly, in the definition of all other Python objects."
msgstr ""
"全ての Python オブジェクトは、オブジェクトのメモリ内表現の先頭部分にある少数"
"のフィールドを完全に共有しています。\n"
"このフィールドは :c:type:`PyObject` 型および :c:type:`PyVarObject` 型で表現さ"
"れます。\n"
"これらの型もまた、他の全ての Python  オブジェクトの定義で直接または間接的に使"
"われているマクロを使って定義されています。"

#: ../../c-api/structures.rst:25
msgid ""
"All object types are extensions of this type.  This is a type which contains "
"the information Python needs to treat a pointer to an object as an object.  "
"In a normal \"release\" build, it contains only the object's reference count "
"and a pointer to the corresponding type object. Nothing is actually declared "
"to be a :c:type:`PyObject`, but every pointer to a Python object can be cast "
"to a :c:expr:`PyObject*`.  Access to the members must be done by using the "
"macros :c:macro:`Py_REFCNT` and :c:macro:`Py_TYPE`."
msgstr ""
"全てのオブジェクト型はこの型を拡張したものです。\n"
"この型には、あるオブジェクトを指すポインタをオブジェクトとして Python から扱"
"うのに必要な情報が入っています。\n"
"通常の \"リリース\" ビルドでは、この構造体にはオブジェクトの参照カウントとオ"
"ブジェクトに対応する型オブジェクトだけが入っています。\n"
"実際には :c:type:`PyObject` であることは宣言されていませんが、全ての Python "
"オブジェクトへのポインタは :c:expr:`PyObject*` へキャストできます。\n"
"メンバにアクセスするには :c:macro:`Py_REFCNT` マクロと :c:macro:`Py_TYPE` マ"
"クロを使わなければなりません。"

#: ../../c-api/structures.rst:37
msgid ""
"This is an extension of :c:type:`PyObject` that adds the :attr:`ob_size` "
"field.  This is only used for objects that have some notion of *length*. "
"This type does not often appear in the Python/C API. Access to the members "
"must be done by using the macros :c:macro:`Py_REFCNT`, :c:macro:`Py_TYPE`, "
"and :c:macro:`Py_SIZE`."
msgstr ""
":c:type:`PyObject` を拡張して、 :attr:`ob_size` フィールドを追加したもので"
"す。\n"
"この構造体は、 *長さ (length)* の概念を持つオブジェクトだけに対して使いま"
"す。\n"
"この型が Python/C API で使われることはほとんどありません。\n"
"メンバにアクセスするには :c:macro:`Py_REFCNT` マクロ、 :c:macro:`Py_TYPE` マ"
"クロ、 :c:macro:`Py_SIZE` マクロを使わなければなりません。"

#: ../../c-api/structures.rst:46
msgid ""
"This is a macro used when declaring new types which represent objects "
"without a varying length.  The PyObject_HEAD macro expands to::"
msgstr ""
"可変な長さを持たないオブジェクトを表現する新しい型を宣言するときに使うマクロ"
"です。\n"
"PyObject_HEAD マクロは次のように展開されます::"

#: ../../c-api/structures.rst:51
msgid "See documentation of :c:type:`PyObject` above."
msgstr "上にある :c:type:`PyObject` のドキュメントを参照してください。"

#: ../../c-api/structures.rst:56
msgid ""
"This is a macro used when declaring new types which represent objects with a "
"length that varies from instance to instance. The PyObject_VAR_HEAD macro "
"expands to::"
msgstr ""
"インスタンスごとに異なる長さを持つオブジェクトを表現する新しい型を宣言すると"
"きに使うマクロです。\n"
"PyObject_VAR_HEAD マクロは次のように展開されます::"

#: ../../c-api/structures.rst:62
msgid "See documentation of :c:type:`PyVarObject` above."
msgstr "上にある :c:type:`PyVarObject` のドキュメントを参照してください。"

#: ../../c-api/structures.rst:67
msgid ""
"Test if the *x* object is the *y* object, the same as ``x is y`` in Python."
msgstr ""

#: ../../c-api/structures.rst:74
msgid ""
"Test if an object is the ``None`` singleton, the same as ``x is None`` in "
"Python."
msgstr ""

#: ../../c-api/structures.rst:82
msgid ""
"Test if an object is the ``True`` singleton, the same as ``x is True`` in "
"Python."
msgstr ""

#: ../../c-api/structures.rst:90
msgid ""
"Test if an object is the ``False`` singleton, the same as ``x is False`` in "
"Python."
msgstr ""

#: ../../c-api/structures.rst:98
msgid "Get the type of the Python object *o*."
msgstr ""

#: ../../c-api/structures.rst:100
msgid "Return a :term:`borrowed reference`."
msgstr ""

#: ../../c-api/structures.rst:102
msgid "Use the :c:func:`Py_SET_TYPE` function to set an object type."
msgstr ""

#: ../../c-api/structures.rst:107
msgid ""
"Return non-zero if the object *o* type is *type*. Return zero otherwise. "
"Equivalent to: ``Py_TYPE(o) == type``."
msgstr ""

#: ../../c-api/structures.rst:115
msgid "Set the object *o* type to *type*."
msgstr ""

#: ../../c-api/structures.rst:122
msgid "Get the reference count of the Python object *o*."
msgstr "Python オブジェクト *o* の参照カウントを取得します。"

#: ../../c-api/structures.rst:124
msgid ""
":c:func:`Py_REFCNT()` is changed to the inline static function. Use :c:func:"
"`Py_SET_REFCNT()` to set an object reference count."
msgstr ""

#: ../../c-api/structures.rst:131
msgid "Set the object *o* reference counter to *refcnt*."
msgstr "オブジェクト *o* の参照カウントを *refcnt* に設定します。"

#: ../../c-api/structures.rst:138
msgid "Get the size of the Python object *o*."
msgstr ""

#: ../../c-api/structures.rst:140
msgid "Use the :c:func:`Py_SET_SIZE` function to set an object size."
msgstr ""

#: ../../c-api/structures.rst:145
msgid "Set the object *o* size to *size*."
msgstr ""

#: ../../c-api/structures.rst:152
msgid ""
"This is a macro which expands to initialization values for a new :c:type:"
"`PyObject` type.  This macro expands to::"
msgstr ""
"新しい :c:type:`PyObject` 型のための初期値に展開するマクロです。このマクロは"
"次のように展開されます。 ::"

#: ../../c-api/structures.rst:161
msgid ""
"This is a macro which expands to initialization values for a new :c:type:"
"`PyVarObject` type, including the :attr:`ob_size` field. This macro expands "
"to::"
msgstr ""
"新しい、 :attr:`ob_size` フィールドを含む :c:type:`PyVarObject` 型のための初"
"期値に展開するマクロです。このマクロは次のように展開されます。 ::"

#: ../../c-api/structures.rst:170
msgid "Implementing functions and methods"
msgstr ""

#: ../../c-api/structures.rst:174
msgid ""
"Type of the functions used to implement most Python callables in C. "
"Functions of this type take two :c:expr:`PyObject*` parameters and return "
"one such value.  If the return value is ``NULL``, an exception shall have "
"been set.  If not ``NULL``, the return value is interpreted as the return "
"value of the function as exposed in Python.  The function must return a new "
"reference."
msgstr ""

#: ../../c-api/structures.rst:181
msgid "The function signature is::"
msgstr "関数のシグネチャは次のとおりです ::"

#: ../../c-api/structures.rst:188
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :const:`METH_VARARGS | METH_KEYWORDS`. The function signature is::"
msgstr ""

#: ../../c-api/structures.rst:199
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :const:`METH_FASTCALL`. The function signature is::"
msgstr ""

#: ../../c-api/structures.rst:209
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :const:`METH_FASTCALL | METH_KEYWORDS`. The function signature is::"
msgstr ""

#: ../../c-api/structures.rst:220
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :const:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`. The function "
"signature is::"
msgstr ""

#: ../../c-api/structures.rst:235
msgid ""
"Structure used to describe a method of an extension type.  This structure "
"has four fields:"
msgstr ""
"拡張型のメソッドを記述する際に用いる構造体です。この構造体には 4 つのフィール"
"ドがあります:"

#: ../../c-api/structures.rst:240
msgid "name of the method"
msgstr "メソッド名"

#: ../../c-api/structures.rst:244
msgid "pointer to the C implementation"
msgstr "C 実装へのポインタ"

#: ../../c-api/structures.rst:248
msgid "flags bits indicating how the call should be constructed"
msgstr ""

#: ../../c-api/structures.rst:252 ../../c-api/structures.rst:411
msgid "points to the contents of the docstring"
msgstr "docstring の内容を指すポインタ"

#: ../../c-api/structures.rst:254
msgid ""
"The :c:member:`ml_meth` is a C function pointer.  The functions may be of "
"different types, but they always return :c:expr:`PyObject*`.  If the "
"function is not of the :c:type:`PyCFunction`, the compiler will require a "
"cast in the method table. Even though :c:type:`PyCFunction` defines the "
"first parameter as :c:expr:`PyObject*`, it is common that the method "
"implementation uses the specific C type of the *self* object."
msgstr ""
":c:member:`ml_meth` は C の関数ポインタです。関数は別の型で定義されていてもか"
"まいませんが、常に :c:expr:`PyObject*` を返します。関数が :c:type:"
"`PyFunction` でない場合、メソッドテーブル内でキャストを行うようコンパイラが要"
"求することになるでしょう。 :c:type:`PyCFunction` では最初のパラメタが :c:"
"expr:`PyObject*` 型であると定義していますが、固有の C 型を *self* オブジェク"
"トに使う実装はよく行われています。"

#: ../../c-api/structures.rst:261
msgid ""
"The :c:member:`ml_flags` field is a bitfield which can include the following "
"flags. The individual flags indicate either a calling convention or a "
"binding convention."
msgstr ""

#: ../../c-api/structures.rst:265
msgid "There are these calling conventions:"
msgstr ""

#: ../../c-api/structures.rst:269
msgid ""
"This is the typical calling convention, where the methods have the type :c:"
"type:`PyCFunction`. The function expects two :c:expr:`PyObject*` values. The "
"first one is the *self* object for methods; for module functions, it is the "
"module object.  The second parameter (often called *args*) is a tuple object "
"representing all arguments. This parameter is typically processed using :c:"
"func:`PyArg_ParseTuple` or :c:func:`PyArg_UnpackTuple`."
msgstr ""
":c:type:`PyCFunction` 型のメソッドで典型的に使われる呼び出し規約です。関数"
"は :c:expr:`PyObject*` 型の引数値を二つ要求します。最初の引数はメソッドの "
"*self* オブジェクトです; モジュール関数の場合、これはモジュールオブジェクトで"
"す。第二のパラメタ (よく *args* と呼ばれます) は、全ての引数を表現するタプル"
"オブジェクトです。パラメタは通常、 :c:func:`PyArg_ParseTuple` や :c:func:"
"`PyArg_UnpackTuple` で処理されます。"

#: ../../c-api/structures.rst:279
msgid ""
"Methods with these flags must be of type :c:type:`PyCFunctionWithKeywords`. "
"The function expects three parameters: *self*, *args*, *kwargs* where "
"*kwargs* is a dictionary of all the keyword arguments or possibly ``NULL`` "
"if there are no keyword arguments.  The parameters are typically processed "
"using :c:func:`PyArg_ParseTupleAndKeywords`."
msgstr ""

#: ../../c-api/structures.rst:288
msgid ""
"Fast calling convention supporting only positional arguments. The methods "
"have the type :c:type:`_PyCFunctionFast`. The first parameter is *self*, the "
"second parameter is a C array of :c:expr:`PyObject*` values indicating the "
"arguments and the third parameter is the number of arguments (the length of "
"the array)."
msgstr ""

#: ../../c-api/structures.rst:298
msgid "``METH_FASTCALL`` is now part of the stable ABI."
msgstr ""

#: ../../c-api/structures.rst:303
msgid ""
"Extension of :const:`METH_FASTCALL` supporting also keyword arguments, with "
"methods of type :c:type:`_PyCFunctionFastWithKeywords`. Keyword arguments "
"are passed the same way as in the :ref:`vectorcall protocol <vectorcall>`: "
"there is an additional fourth :c:expr:`PyObject*` parameter which is a tuple "
"representing the names of the keyword arguments (which are guaranteed to be "
"strings) or possibly ``NULL`` if there are no keywords.  The values of the "
"keyword arguments are stored in the *args* array, after the positional "
"arguments."
msgstr ""

#: ../../c-api/structures.rst:318
msgid ""
"Extension of :const:`METH_FASTCALL | METH_KEYWORDS` supporting the *defining "
"class*, that is, the class that contains the method in question. The "
"defining class might be a superclass of ``Py_TYPE(self)``."
msgstr ""

#: ../../c-api/structures.rst:322
msgid ""
"The method needs to be of type :c:type:`PyCMethod`, the same as for "
"``METH_FASTCALL | METH_KEYWORDS`` with ``defining_class`` argument added "
"after ``self``."
msgstr ""

#: ../../c-api/structures.rst:331
msgid ""
"Methods without parameters don't need to check whether arguments are given "
"if they are listed with the :const:`METH_NOARGS` flag.  They need to be of "
"type :c:type:`PyCFunction`.  The first parameter is typically named *self* "
"and will hold a reference to the module or object instance.  In all cases "
"the second parameter will be ``NULL``."
msgstr ""
"引数のないメソッドは、 :const:`METH_NOARGS` フラグをつけた場合、必要な引数が"
"指定されているかをチェックしなくなります。こうしたメソッドは :c:type:"
"`PyCFunction` 型でなくてはなりません。第一のパラメタは *self* になり、モ"
"ジュールかオブジェクトインスタンスへの参照を保持することになります。いずれに"
"せよ、第二のパラメタは ``NULL`` になります。"

#: ../../c-api/structures.rst:340
msgid ""
"Methods with a single object argument can be listed with the :const:`METH_O` "
"flag, instead of invoking :c:func:`PyArg_ParseTuple` with a ``\"O\"`` "
"argument. They have the type :c:type:`PyCFunction`, with the *self* "
"parameter, and a :c:expr:`PyObject*` parameter representing the single "
"argument."
msgstr ""
"単一のオブジェクト引数だけをとるメソッドは、 :c:func:`PyArg_ParseTuple` を引"
"数 ``\"O\"`` にして呼び出す代わりに、 :const:`METH_O` フラグつきで指定できま"
"す。メソッドは :c:type:`PyCFunction` 型で、 *self* パラメタと単一の引数を表現"
"する :c:expr:`PyObject*` パラメタを伴います。"

#: ../../c-api/structures.rst:346
msgid ""
"These two constants are not used to indicate the calling convention but the "
"binding when use with methods of classes.  These may not be used for "
"functions defined for modules.  At most one of these flags may be set for "
"any given method."
msgstr ""
"以下の二つの定数は、呼び出し規約を示すものではなく、クラスのメソッドとして使"
"う際の束縛方式を示すものです。モジュールに対して定義された関数で用いてはなり"
"ません。メソッドに対しては、最大で一つしかこのフラグをセットできません。"

#: ../../c-api/structures.rst:356
msgid ""
"The method will be passed the type object as the first parameter rather than "
"an instance of the type.  This is used to create *class methods*, similar to "
"what is created when using the :func:`classmethod` built-in function."
msgstr ""
"メソッドの最初の引数には、型のインスタンスではなく型オブジェクトが渡されま"
"す。このフラグは組み込み関数 :func:`classmethod` を使って生成するのと同じ *ク"
"ラスメソッド (class method)* を生成するために使われます。"

#: ../../c-api/structures.rst:366
msgid ""
"The method will be passed ``NULL`` as the first parameter rather than an "
"instance of the type.  This is used to create *static methods*, similar to "
"what is created when using the :func:`staticmethod` built-in function."
msgstr ""
"メソッドの最初の引数には、型のインスタンスではなく ``NULL`` が渡されます。こ"
"のフラグは、 :func:`staticmethod` を使って生成するのと同じ *静的メソッド "
"(static method)* を生成するために使われます。"

#: ../../c-api/structures.rst:370
msgid ""
"One other constant controls whether a method is loaded in place of another "
"definition with the same method name."
msgstr ""
"もう一つの定数は、あるメソッドを同名の別のメソッド定義と置き換えるかどうかを"
"制御します。"

#: ../../c-api/structures.rst:376
msgid ""
"The method will be loaded in place of existing definitions.  Without "
"*METH_COEXIST*, the default is to skip repeated definitions.  Since slot "
"wrappers are loaded before the method table, the existence of a "
"*sq_contains* slot, for example, would generate a wrapped method named :meth:"
"`__contains__` and preclude the loading of a corresponding PyCFunction with "
"the same name.  With the flag defined, the PyCFunction will be loaded in "
"place of the wrapper object and will co-exist with the slot.  This is "
"helpful because calls to PyCFunctions are optimized more than wrapper object "
"calls."
msgstr ""
"メソッドを既存の定義を置き換える形でロードします。 *METH_COEXIST* を指定しな"
"ければ、デフォルトの設定にしたがって、定義が重複しないようスキップします。ス"
"ロットラッパーはメソッドテーブルよりも前にロードされるので、例えば "
"*sq_contains* スロットはラップしているメソッド :meth:`__contains__` を生成"
"し、同名の PyCFunction のロードを阻止します。このフラグを定義すると、 "
"PyCFunction はラッパーオブジェクトを置き換える形でロードされ、スロットと連立"
"します。 PyCFunctions の呼び出しはラッパーオブジェクトの呼び出しよりも最適化"
"されているので、こうした仕様が便利になります。"

#: ../../c-api/structures.rst:388
msgid "Accessing attributes of extension types"
msgstr ""

#: ../../c-api/structures.rst:392
msgid ""
"Structure which describes an attribute of a type which corresponds to a C "
"struct member.  Its fields are:"
msgstr ""
"type の C 構造体のメンバとして格納されている、ある型の属性を表す構造体です。"
"この構造体のフィールドは以下のとおりです:"

#: ../../c-api/structures.rst:396 ../../c-api/structures.rst:492
msgid "Field"
msgstr "フィールド"

#: ../../c-api/structures.rst:396 ../../c-api/structures.rst:492
msgid "C Type"
msgstr "C の型"

#: ../../c-api/structures.rst:396 ../../c-api/structures.rst:492
msgid "Meaning"
msgstr "意味"

#: ../../c-api/structures.rst:398
msgid ":attr:`name`"
msgstr ":attr:`name`"

#: ../../c-api/structures.rst:398 ../../c-api/structures.rst:411
#: ../../c-api/structures.rst:427 ../../c-api/structures.rst:494
#: ../../c-api/structures.rst:502
msgid "const char \\*"
msgstr ""

#: ../../c-api/structures.rst:398
msgid "name of the member"
msgstr "メンバ名"

#: ../../c-api/structures.rst:400
msgid ":attr:`!type`"
msgstr ":attr:`!type`"

#: ../../c-api/structures.rst:400 ../../c-api/structures.rst:407
#: ../../c-api/structures.rst:423
msgid "int"
msgstr "int"

#: ../../c-api/structures.rst:400
msgid "the type of the member in the C struct"
msgstr "C 構造体の中のメンバの型"

#: ../../c-api/structures.rst:403
msgid ":attr:`offset`"
msgstr ":attr:`offset`"

#: ../../c-api/structures.rst:403 ../../c-api/structures.rst:439
msgid "Py_ssize_t"
msgstr "Py_ssize_t"

#: ../../c-api/structures.rst:403
msgid ""
"the offset in bytes that the member is located on the type's object struct"
msgstr "そのメンバの type object 構造体中の場所の offset バイト数"

#: ../../c-api/structures.rst:407
msgid ":attr:`flags`"
msgstr ":attr:`flags`"

#: ../../c-api/structures.rst:407
msgid "flag bits indicating if the field should be read-only or writable"
msgstr "フィールドが読み出し専用か書込み可能なのかを示すビットフラグ"

#: ../../c-api/structures.rst:411
msgid ":attr:`doc`"
msgstr ":attr:`doc`"

#: ../../c-api/structures.rst:415
msgid ""
":attr:`!type` can be one of many ``T_`` macros corresponding to various C "
"types.  When the member is accessed in Python, it will be converted to the "
"equivalent Python type."
msgstr ""
":attr:`!type` はたくさんのCの型を意味する ``T_`` マクロのうちの1つです。メン"
"バが Python からアクセスされるとき、そのメンバは対応する Python の型に変換さ"
"れます。"

#: ../../c-api/structures.rst:420
msgid "Macro name"
msgstr "マクロ名"

#: ../../c-api/structures.rst:420
msgid "C type"
msgstr "C の型"

#: ../../c-api/structures.rst:422
msgid "T_SHORT"
msgstr "T_SHORT"

#: ../../c-api/structures.rst:422
msgid "short"
msgstr "short"

#: ../../c-api/structures.rst:423
msgid "T_INT"
msgstr "T_INT"

#: ../../c-api/structures.rst:424
msgid "T_LONG"
msgstr "T_LONG"

#: ../../c-api/structures.rst:424
msgid "long"
msgstr "long"

#: ../../c-api/structures.rst:425
msgid "T_FLOAT"
msgstr "T_FLOAT"

#: ../../c-api/structures.rst:425
msgid "float"
msgstr "浮動小数点数"

#: ../../c-api/structures.rst:426
msgid "T_DOUBLE"
msgstr "T_DOUBLE"

#: ../../c-api/structures.rst:426
msgid "double"
msgstr "double"

#: ../../c-api/structures.rst:427
msgid "T_STRING"
msgstr "T_STRING"

#: ../../c-api/structures.rst:428
msgid "T_OBJECT"
msgstr "T_OBJECT"

#: ../../c-api/structures.rst:428 ../../c-api/structures.rst:429
msgid "PyObject \\*"
msgstr "PyObject \\*"

#: ../../c-api/structures.rst:429
msgid "T_OBJECT_EX"
msgstr "T_OBJECT_EX"

#: ../../c-api/structures.rst:430
msgid "T_CHAR"
msgstr "T_CHAR"

#: ../../c-api/structures.rst:430 ../../c-api/structures.rst:431
#: ../../c-api/structures.rst:436
msgid "char"
msgstr "char"

#: ../../c-api/structures.rst:431
msgid "T_BYTE"
msgstr "T_BYTE"

#: ../../c-api/structures.rst:432
msgid "T_UBYTE"
msgstr "T_UBYTE"

#: ../../c-api/structures.rst:432
msgid "unsigned char"
msgstr "unsigned char"

#: ../../c-api/structures.rst:433
msgid "T_UINT"
msgstr "T_UINT"

#: ../../c-api/structures.rst:433
msgid "unsigned int"
msgstr "unsigned int"

#: ../../c-api/structures.rst:434
msgid "T_USHORT"
msgstr "T_USHORT"

#: ../../c-api/structures.rst:434
msgid "unsigned short"
msgstr "unsigned short"

#: ../../c-api/structures.rst:435
msgid "T_ULONG"
msgstr "T_ULONG"

#: ../../c-api/structures.rst:435
msgid "unsigned long"
msgstr "unsigned long"

#: ../../c-api/structures.rst:436
msgid "T_BOOL"
msgstr "T_BOOL"

#: ../../c-api/structures.rst:437
msgid "T_LONGLONG"
msgstr "T_LONGLONG"

#: ../../c-api/structures.rst:437
msgid "long long"
msgstr "long long"

#: ../../c-api/structures.rst:438
msgid "T_ULONGLONG"
msgstr "T_ULONGLONG"

#: ../../c-api/structures.rst:438
msgid "unsigned long long"
msgstr "unsigned long long"

#: ../../c-api/structures.rst:439
msgid "T_PYSSIZET"
msgstr "T_PYSSIZET"

#: ../../c-api/structures.rst:442
msgid ""
":c:macro:`T_OBJECT` and :c:macro:`T_OBJECT_EX` differ in that :c:macro:"
"`T_OBJECT` returns ``None`` if the member is ``NULL`` and :c:macro:"
"`T_OBJECT_EX` raises an :exc:`AttributeError`.  Try to use :c:macro:"
"`T_OBJECT_EX` over :c:macro:`T_OBJECT` because :c:macro:`T_OBJECT_EX` "
"handles use of the :keyword:`del` statement on that attribute more correctly "
"than :c:macro:`T_OBJECT`."
msgstr ""
":c:macro:`T_OBJECT` と :c:macro:`T_OBJECT_EX` が異なっているのは、 :c:macro:"
"`T_OBJECT` はメンバが ``NULL`` だったときに ``None`` を返すのに対し、 :c:"
"macro:`T_OBJECT_EX` は :exc:`AttributeError` を送出する点です。\n"
":c:macro:`T_OBJECT_EX` は :c:macro:`T_OBJECT` より属性に対する :keyword:"
"`del` 文を正しくあつかうので、できれば :c:macro:`T_OBJECT` ではなく :c:macro:"
"`T_OBJECT_EX` を使ってください。"

#: ../../c-api/structures.rst:449
msgid ""
":attr:`flags` can be ``0`` for write and read access or :c:macro:`READONLY` "
"for read-only access.  Using :c:macro:`T_STRING` for :attr:`type` implies :c:"
"macro:`READONLY`.  :c:macro:`T_STRING` data is interpreted as UTF-8. Only :c:"
"macro:`T_OBJECT` and :c:macro:`T_OBJECT_EX` members can be deleted.  (They "
"are set to ``NULL``)."
msgstr ""

#: ../../c-api/structures.rst:457
msgid ""
"Heap allocated types (created using :c:func:`PyType_FromSpec` or similar), "
"``PyMemberDef`` may contain definitions for the special members "
"``__dictoffset__``, ``__weaklistoffset__`` and ``__vectorcalloffset__``, "
"corresponding to :c:member:`~PyTypeObject.tp_dictoffset`, :c:member:"
"`~PyTypeObject.tp_weaklistoffset` and :c:member:`~PyTypeObject."
"tp_vectorcall_offset` in type objects. These must be defined with "
"``T_PYSSIZET`` and ``READONLY``, for example::"
msgstr ""

#: ../../c-api/structures.rst:474
msgid ""
"Get an attribute belonging to the object at address *obj_addr*.  The "
"attribute is described by ``PyMemberDef`` *m*.  Returns ``NULL`` on error."
msgstr ""

#: ../../c-api/structures.rst:481
msgid ""
"Set an attribute belonging to the object at address *obj_addr* to object "
"*o*. The attribute to set is described by ``PyMemberDef`` *m*.  Returns "
"``0`` if successful and a negative value on failure."
msgstr ""

#: ../../c-api/structures.rst:488
msgid ""
"Structure to define property-like access for a type. See also description of "
"the :c:member:`PyTypeObject.tp_getset` slot."
msgstr ""
"型のプロパティのようなアクセスを定義するための構造体です。 :c:member:"
"`PyTypeObject.tp_getset` スロットの説明も参照してください。"

#: ../../c-api/structures.rst:494
msgid "name"
msgstr "name"

#: ../../c-api/structures.rst:494
msgid "attribute name"
msgstr "属性名"

#: ../../c-api/structures.rst:496
msgid "get"
msgstr "get"

#: ../../c-api/structures.rst:496
msgid "getter"
msgstr "getter"

#: ../../c-api/structures.rst:496
msgid "C function to get the attribute"
msgstr ""

#: ../../c-api/structures.rst:498
msgid "set"
msgstr "集合"

#: ../../c-api/structures.rst:498
msgid "setter"
msgstr "setter"

#: ../../c-api/structures.rst:498
msgid ""
"optional C function to set or delete the attribute, if omitted the attribute "
"is readonly"
msgstr ""
"属性をセット/削除する任意のC言語関数。省略された場合、属性は読み取り専用にな"
"ります。"

#: ../../c-api/structures.rst:502
msgid "doc"
msgstr "doc"

#: ../../c-api/structures.rst:502
msgid "optional docstring"
msgstr "任意のドキュメンテーション文字列"

#: ../../c-api/structures.rst:504
msgid "closure"
msgstr "closure"

#: ../../c-api/structures.rst:504
msgid "void \\*"
msgstr "void \\*"

#: ../../c-api/structures.rst:504
msgid ""
"optional function pointer, providing additional data for getter and setter"
msgstr "getterとsetterの追加データを提供する、オプションの関数ポインタ。"

#: ../../c-api/structures.rst:509
msgid ""
"The ``get`` function takes one :c:expr:`PyObject*` parameter (the instance) "
"and a function pointer (the associated ``closure``)::"
msgstr ""
"``get`` 関数は :c:expr:`PyObject*` パラメータ (インスタンス) と関数ポインタ "
"(関連する``closure``) を1つ受け取ります。"

#: ../../c-api/structures.rst:514
msgid ""
"It should return a new reference on success or ``NULL`` with a set exception "
"on failure."
msgstr ""
"成功または失敗時に ``NULL`` と例外の集合にされたときは新しい参照を返します。"

#: ../../c-api/structures.rst:517
msgid ""
"``set`` functions take two :c:expr:`PyObject*` parameters (the instance and "
"the value to be set) and a function pointer (the associated ``closure``)::"
msgstr ""
"``set`` 関数は :c:expr:`PyObject*` パラメータ (インスタンスとセットされるべき"
"値) と関数ポインタ (関連する``closure``) を受け取ります。"

#: ../../c-api/structures.rst:522
msgid ""
"In case the attribute should be deleted the second parameter is ``NULL``. "
"Should return ``0`` on success or ``-1`` with a set exception on failure."
msgstr ""
"属性を削除する場合は、2 番目のパラメータに ``NULL`` を指定します。成功した場"
"合は ``0`` を、失敗した場合は ``-1`` を例外として返します。"
