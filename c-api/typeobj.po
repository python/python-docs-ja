# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 01:01+0900\n"
"PO-Revision-Date: 2019-09-01 05:18+0000\n"
"Last-Translator: tomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/"
"language/ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/typeobj.rst:6
msgid "Type Objects"
msgstr "型オブジェクト"

#: ../../c-api/typeobj.rst:8
msgid ""
"Perhaps one of the most important structures of the Python object system is "
"the structure that defines a new type: the :c:type:`PyTypeObject` "
"structure.  Type objects can be handled using any of the :c:func:"
"`PyObject_\\*` or :c:func:`PyType_\\*` functions, but do not offer much "
"that's interesting to most Python applications. These objects are "
"fundamental to how objects behave, so they are very important to the "
"interpreter itself and to any extension module that implements new types."
msgstr ""
"新スタイルの型を定義する構造体: :c:type:`PyTypeObject` 構造体は、おそらく "
"Python オブジェクトシステムの中で最も重要な構造体の1つでしょう。型オブジェク"
"トは :c:func:`PyObject_\\*` 系や :c:func:`PyType_\\*` 系の関数で扱えますが、"
"ほとんどの Python アプリケーションにとって、さして面白みのある機能を提供しま"
"せん。型オブジェクトはオブジェクトがどのように振舞うかを決める基盤ですから、"
"インタプリタ自体や新たな型を定義する拡張モジュールでは非常に重要な存在です。"

#: ../../c-api/typeobj.rst:16
msgid ""
"Type objects are fairly large compared to most of the standard types. The "
"reason for the size is that each type object stores a large number of "
"values, mostly C function pointers, each of which implements a small part of "
"the type's functionality.  The fields of the type object are examined in "
"detail in this section.  The fields will be described in the order in which "
"they occur in the structure."
msgstr ""
"型オブジェクトは標準の型 (standard type) に比べるとかなり大きな構造体です。各"
"型オブジェクトは多くの値を保持しており、そのほとんどは C 関数へのポインタで、"
"それぞれの関数はその型の機能の小さい部分を実装しています。この節では、型オブ"
"ジェクトの各フィールドについて詳細を説明します。各フィールドは、構造体内で出"
"現する順番に説明されています。"

#: ../../c-api/typeobj.rst:23
msgid ""
"Typedefs: unaryfunc, binaryfunc, ternaryfunc, inquiry, coercion, intargfunc, "
"intintargfunc, intobjargproc, intintobjargproc, objobjargproc, destructor, "
"freefunc, printfunc, getattrfunc, getattrofunc, setattrfunc, setattrofunc, "
"cmpfunc, reprfunc, hashfunc"
msgstr ""
"Typedefs: unaryfunc, binaryfunc, ternaryfunc, inquiry, coercion, intargfunc, "
"intintargfunc, intobjargproc, intintobjargproc, objobjargproc, destructor, "
"freefunc, printfunc, getattrfunc, getattrofunc, setattrfunc, setattrofunc, "
"cmpfunc, reprfunc, hashfunc"

#: ../../c-api/typeobj.rst:28
msgid ""
"The structure definition for :c:type:`PyTypeObject` can be found in :file:"
"`Include/object.h`.  For convenience of reference, this repeats the "
"definition found there:"
msgstr ""
":c:type:`PyTypeObject` の構造体定義は :file:`Include/object.h` で見つけられる"
"はずです。参照の手間を省くために、ここでは定義を繰り返します:"

#: ../../c-api/typeobj.rst:35
msgid ""
"The type object structure extends the :c:type:`PyVarObject` structure. The :"
"attr:`ob_size` field is used for dynamic types (created by  :func:"
"`type_new`, usually called from a class statement). Note that :c:data:"
"`PyType_Type` (the metatype) initializes :c:member:`~PyTypeObject."
"tp_itemsize`, which means that its instances (i.e. type objects) *must* have "
"the :attr:`ob_size` field."
msgstr ""
"型オブジェクト構造体は :c:type:`PyVarObject` 構造体を拡張したものです。 :"
"attr:`ob_size` フィールドは、(通常 class 文が呼び出す :func:`type_new` で生成"
"される) 動的な型に使います。 :c:data:`PyType_Type` (メタタイプ) は :c:member:"
"`~PyTypeObject.tp_itemsize` を初期化するので注意してください。すなわち、 イン"
"スタンス (つまり型オブジェクト) には :attr:`ob_size` フィールドが存在しなけれ"
"ば *なりません* 。"

#: ../../c-api/typeobj.rst:45
msgid ""
"These fields are only present when the macro ``Py_TRACE_REFS`` is defined. "
"Their initialization to *NULL* is taken care of by the "
"``PyObject_HEAD_INIT`` macro.  For statically allocated objects, these "
"fields always remain *NULL*. For dynamically allocated objects, these two "
"fields are used to link the object into a doubly-linked list of *all* live "
"objects on the heap.  This could be used for various debugging purposes; "
"currently the only use is to print the objects that are still alive at the "
"end of a run when the environment variable :envvar:`PYTHONDUMPREFS` is set."
msgstr ""
"これらのフィールドはマクロ ``Py_TRACE_REFS`` が定義されている場合のみ存在しま"
"す。 ``PyObject_HEAD_INIT`` マクロを使うと、フィールドを *NULL* に初期化しま"
"す。静的にメモリ確保されているオブジェクトでは、これらのフィールドは常に "
"*NULL* のままです。動的にメモリ確保されるオブジェクトの場合、これら二つの"
"フィールドは、ヒープ上の *全ての* 存続中のオブジェクトからなる二重リンクリス"
"トでオブジェクトをリンクする際に使われます。このことは様々なデバッグ目的に利"
"用できます; 現状では、環境変数 :envvar:`PYTHONDUMPREFS` が設定されているとき"
"に、プログラムの実行終了時点で存続しているオブジェクトを出力するのが唯一の用"
"例です。"

#: ../../c-api/typeobj.rst:54
msgid "These fields are not inherited by subtypes."
msgstr "サブタイプはこのフィールドを継承しません。"

#: ../../c-api/typeobj.rst:59
msgid ""
"This is the type object's reference count, initialized to ``1`` by the "
"``PyObject_HEAD_INIT`` macro.  Note that for statically allocated type "
"objects, the type's instances (objects whose :attr:`ob_type` points back to "
"the type) do *not* count as references.  But for dynamically allocated type "
"objects, the instances *do* count as references."
msgstr ""
"型オブジェクトの参照カウントで、 ``PyObject_HEAD_INIT`` はこの値を ``1`` に初"
"期化します。静的にメモリ確保された型オブジェクトでは、型のインスタンス (:"
"attr:`ob_type` が該当する型を指しているオブジェクト) は参照をカウントする対象"
"には *なりません* 。動的にメモリ確保される型オブジェクトの場合、インスタンス"
"は参照カウントの対象に *なります* 。"

#: ../../c-api/typeobj.rst:65 ../../c-api/typeobj.rst:100
#: ../../c-api/typeobj.rst:128
msgid "This field is not inherited by subtypes."
msgstr "サブタイプはこのフィールドを継承しません。"

#: ../../c-api/typeobj.rst:67
msgid ""
"This field used to be an :c:type:`int` type. This might require changes in "
"your code for properly supporting 64-bit systems."
msgstr ""
"このフィールドは以前は :c:type:`int` でした。この変更により、 64bit システム"
"を正しくサポートするには修正が必要になります。"

#: ../../c-api/typeobj.rst:74
msgid ""
"This is the type's type, in other words its metatype.  It is initialized by "
"the argument to the ``PyObject_HEAD_INIT`` macro, and its value should "
"normally be ``&PyType_Type``.  However, for dynamically loadable extension "
"modules that must be usable on Windows (at least), the compiler complains "
"that this is not a valid initializer.  Therefore, the convention is to pass "
"*NULL* to the ``PyObject_HEAD_INIT`` macro and to initialize this field "
"explicitly at the start of the module's initialization function, before "
"doing anything else.  This is typically done like this::"
msgstr ""
"型自体の型、別の言い方をするとメタタイプです。 ``PyObject_HEAD_INIT`` マクロ"
"で初期化され、通常は ``&PyType_Type`` になります。しかし、(少なくとも) "
"Windows で利用できる動的ロード可能な拡張モジュールでは、コンパイラは有効な初"
"期化ではないと文句をつけます。そこで、ならわしとして、 "
"``PyObject_HEAD_INIT`` には *NULL* を渡して初期化しておき、他の操作を行う前に"
"モジュールの初期化関数で明示的にこのフィールドを初期化することになっていま"
"す。この操作は以下のように行います::"

#: ../../c-api/typeobj.rst:85
msgid ""
"This should be done before any instances of the type are created. :c:func:"
"`PyType_Ready` checks if :attr:`ob_type` is *NULL*, and if so, initializes "
"it: in Python 2.2, it is set to ``&PyType_Type``; in Python 2.2.1 and later "
"it is initialized to the :attr:`ob_type` field of the base class. :c:func:"
"`PyType_Ready` will not change this field if it is non-zero."
msgstr ""
"上の操作は、該当する型のいかなるインスタンス生成よりも前にしておかねばなりま"
"せん。 :c:func:`PyType_Ready` は :attr:`ob_type` が *NULL* かどうか調べ、 "
"*NULL* の場合には初期化します: Python 2.2 では、 ``&PyType_Type`` にセットし"
"ます; in Python 2.2.1 およびそれ以降では基底クラスの :attr:`ob_type` フィール"
"ドに初期化します。 :attr:`ob_type` が非ゼロの場合、 :c:func:`PyType_Ready` は"
"このフィールドを変更しません。"

#: ../../c-api/typeobj.rst:91
msgid ""
"In Python 2.2, this field is not inherited by subtypes.  In 2.2.1, and in "
"2.3 and beyond, it is inherited by subtypes."
msgstr ""
"Python 2.2 では、サブタイプはこのフィールドを継承しません。 2.2.1 と 2.3 以降"
"では、サブタイプはこのフィールドを継承します。"

#: ../../c-api/typeobj.rst:97
msgid ""
"For statically allocated type objects, this should be initialized to zero.  "
"For dynamically allocated type objects, this field has a special internal "
"meaning."
msgstr ""
"静的にメモリ確保されている型オブジェクトの場合、このフィールドはゼロに初期化"
"されます。動的にメモリ確保されている型オブジェクトの場合、このフィールドは内"
"部使用される特殊な意味を持ちます。"

#: ../../c-api/typeobj.rst:105
msgid ""
"Pointer to a NUL-terminated string containing the name of the type. For "
"types that are accessible as module globals, the string should be the full "
"module name, followed by a dot, followed by the type name; for built-in "
"types, it should be just the type name.  If the module is a submodule of a "
"package, the full package name is part of the full module name.  For "
"example, a type named :class:`T` defined in module :mod:`M` in subpackage :"
"mod:`Q` in package :mod:`P` should have the :c:member:`~PyTypeObject."
"tp_name` initializer ``\"P.Q.M.T\"``."
msgstr ""
"型の名前が入っている NUL 終端された文字列へのポインタです。モジュールのグロー"
"バル変数としてアクセスできる型の場合、この文字列は完全なモジュール名、ドッ"
"ト、そして型の名前と続く文字列になります; 組み込み型の場合、ただの型の名前で"
"す。モジュールがあるパッケージのサブモジュールの場合、完全なパッケージ名が完"
"全なモジュール名の一部になっています。例えば、パッケージ :mod:`P` 内のサブモ"
"ジュール :mod:`Q` に入っているモジュール :mod:`M` 内で定義されている :class:"
"`T` は、 :c:member:`~PyTypeObject.tp_name` を ``\"P.Q.M.T\"`` に初期化しま"
"す。"

#: ../../c-api/typeobj.rst:113
msgid ""
"For dynamically allocated type objects, this should just be the type name, "
"and the module name explicitly stored in the type dict as the value for key "
"``'__module__'``."
msgstr ""
"動的にメモリ確保される型オブジェクトの場合、このフィールドは単に型の名前にな"
"り、モジュール名は型の辞書内でキー ``'__module__'`` に対する値として明示的に"
"保存されます。"

#: ../../c-api/typeobj.rst:117
msgid ""
"For statically allocated type objects, the tp_name field should contain a "
"dot. Everything before the last dot is made accessible as the :attr:"
"`__module__` attribute, and everything after the last dot is made accessible "
"as the :attr:`~definition.__name__` attribute."
msgstr ""
"静的にメモリ確保される型オブジェクトの場合、 :attr:`tp_name` フィールドには"
"ドットが含まれているはずです。\n"
"最後のドットよりも前にある部分文字列全体は :attr:`__module__` 属性として、ま"
"たドットよりも後ろにある部分は :attr:`~definition.__name__` 属性としてアクセ"
"スできます。"

#: ../../c-api/typeobj.rst:122
msgid ""
"If no dot is present, the entire :c:member:`~PyTypeObject.tp_name` field is "
"made accessible as the :attr:`~definition.__name__` attribute, and the :attr:"
"`__module__` attribute is undefined (unless explicitly set in the "
"dictionary, as explained above).  This means your type will be impossible to "
"pickle.  Additionally, it will not be listed in module documentations "
"created with pydoc."
msgstr ""
"ドットが入っていない場合、 :c:member:`~PyTypeObject.tp_name` フィールドの内容"
"全てが :attr:`~definition.__name__` 属性になり、 :attr:`__module__` 属性は "
"(前述のように型の辞書内で明示的にセットしないかぎり) 未定義になります。\n"
"このため、その型は pickle 化できないことになります。\n"
"さらに、 pydoc が作成するモジュールドキュメントのリストにも載らなくなります。"

#: ../../c-api/typeobj.rst:134
msgid ""
"These fields allow calculating the size in bytes of instances of the type."
msgstr ""
"これらのフィールドは、型インスタンスのバイトサイズを計算できるようにします。"

#: ../../c-api/typeobj.rst:136
msgid ""
"There are two kinds of types: types with fixed-length instances have a zero :"
"c:member:`~PyTypeObject.tp_itemsize` field, types with variable-length "
"instances have a non-zero :c:member:`~PyTypeObject.tp_itemsize` field.  For "
"a type with fixed-length instances, all instances have the same size, given "
"in :c:member:`~PyTypeObject.tp_basicsize`."
msgstr ""
"型には二つの種類があります: 固定長インスタンスの型は、 :c:member:"
"`~PyTypeObject.tp_itemsize` フィールドがゼロで、可変長インスタンスの方は :c:"
"member:`~PyTypeObject.tp_itemsize` フィールドが非ゼロの値になります。固定長イ"
"ンスタンスの型の場合、全てのインスタンスは等しく :c:member:`~PyTypeObject."
"tp_basicsize` で与えられたサイズになります。"

#: ../../c-api/typeobj.rst:141
msgid ""
"For a type with variable-length instances, the instances must have an :attr:"
"`ob_size` field, and the instance size is :c:member:`~PyTypeObject."
"tp_basicsize` plus N times :c:member:`~PyTypeObject.tp_itemsize`, where N is "
"the \"length\" of the object.  The value of N is typically stored in the "
"instance's :attr:`ob_size` field.  There are exceptions:  for example, long "
"ints use a negative :attr:`ob_size` to indicate a negative number, and N is "
"``abs(ob_size)`` there.  Also, the presence of an :attr:`ob_size` field in "
"the instance layout doesn't mean that the instance structure is variable-"
"length (for example, the structure for the list type has fixed-length "
"instances, yet those instances have a meaningful :attr:`ob_size` field)."
msgstr ""
"可変長インスタンスの型の場合、インスタンスには :attr:`ob_size` フィールドがな"
"くてはならず、インスタンスのサイズは N をオブジェクトの \"長さ\" として、 :c:"
"member:`~PyTypeObject.tp_basicsize` と N かける :c:member:`~PyTypeObject."
"tp_itemsize` の加算になります。N の値は通常、インスタンスの :attr:`ob_size` "
"フィールドに記憶されます。ただし例外がいくつかあります: 例えば、長整数では負"
"の値を :attr:`ob_size` に使って、インスタンスの表す値が負であることを示し、 "
"N 自体は ``abs(ob_size)`` になります。また、 :attr:`ob_size` フィールドがある"
"からといって、必ずしもインスタンスが可変長であることを意味しません (例えば、"
"リスト型の構造体は固定長のインスタンスになるにもかかわらず、インスタンスには"
"ちゃんと意味を持った :attr:`ob_size` フィールドがあります)。"

#: ../../c-api/typeobj.rst:152
msgid ""
"The basic size includes the fields in the instance declared by the macro :c:"
"macro:`PyObject_HEAD` or :c:macro:`PyObject_VAR_HEAD` (whichever is used to "
"declare the instance struct) and this in turn includes the :attr:`_ob_prev` "
"and :attr:`_ob_next` fields if they are present.  This means that the only "
"correct way to get an initializer for the :c:member:`~PyTypeObject."
"tp_basicsize` is to use the ``sizeof`` operator on the struct used to "
"declare the instance layout. The basic size does not include the GC header "
"size (this is new in Python 2.2; in 2.1 and 2.0, the GC header size was "
"included in :c:member:`~PyTypeObject.tp_basicsize`)."
msgstr ""
"基本サイズには、 :c:macro:`PyObject_HEAD` マクロまたは :c:macro:"
"`PyObject_VAR_HEAD` マクロ (インスタンス構造体を宣言するのに使ったどちらかの"
"マクロ) で宣言されているフィールドが入っています。さらに、 :attr:`_ob_prev` "
"および :attr:`_ob_next` フィールドがある場合、これらのフィールドもサイズに加"
"算されます。従って、 :c:member:`~PyTypeObject.tp_basicsize` の正しい初期化パ"
"ラメタを得るには、インスタンスデータのレイアウトを宣言するのに使う構造体に対"
"して ``sizeof`` 演算子を使うしかありません。基本サイズには、GC ヘッダサイズは"
"入っていません (これは Python 2.2 からの新しい仕様です; 2.1 や 2.0 では、GC "
"ヘッダサイズは :c:member:`~PyTypeObject.tp_basicsize` に入っていました)。"

#: ../../c-api/typeobj.rst:161
msgid ""
"These fields are inherited separately by subtypes.  If the base type has a "
"non-zero :c:member:`~PyTypeObject.tp_itemsize`, it is generally not safe to "
"set :c:member:`~PyTypeObject.tp_itemsize` to a different non-zero value in a "
"subtype (though this depends on the implementation of the base type)."
msgstr ""
"これらのフィールドはサブタイプに別々に継承されます。基底タイプが 0 でない :c:"
"member:`~PyTypeObject.tp_itemsize` を持っていた場合、基底タイプの実装に依存し"
"ますが、一般的にはサブタイプで別の 0 で無い値を :c:member:`~PyTypeObject."
"tp_itemsize` に設定するのは安全ではありません。"

#: ../../c-api/typeobj.rst:166
msgid ""
"A note about alignment: if the variable items require a particular "
"alignment, this should be taken care of by the value of :c:member:"
"`~PyTypeObject.tp_basicsize`.  Example: suppose a type implements an array "
"of ``double``. :c:member:`~PyTypeObject.tp_itemsize` is ``sizeof(double)``. "
"It is the programmer's responsibility that :c:member:`~PyTypeObject."
"tp_basicsize` is a multiple of ``sizeof(double)`` (assuming this is the "
"alignment requirement for ``double``)."
msgstr ""
"アラインメントに関する注釈: 変数の各要素を配置する際に特定のアラインメントが"
"必要となる場合、 :c:member:`~PyTypeObject.tp_basicsize` の値に気をつけなけれ"
"ばなりません。例: ある型が ``double`` の配列を実装しているとします。 :c:"
"member:`~PyTypeObject.tp_itemsize` は ``sizeof(double)`` です。 :c:member:"
"`~PyTypeObject.tp_basicsize` が ``sizeof(double)`` (ここではこれを "
"``double`` のアラインメントが要求するサイズと仮定する) の個数分のサイズになる"
"ようにするのはプログラマの責任です。"

#: ../../c-api/typeobj.rst:176
msgid ""
"A pointer to the instance destructor function.  This function must be "
"defined unless the type guarantees that its instances will never be "
"deallocated (as is the case for the singletons ``None`` and ``Ellipsis``)."
msgstr ""
"インスタンスのデストラクタ関数へのポインタです。この関数は (単量子 ``None`` "
"や ``Ellipsis`` の場合のように) インスタンスが決してメモリ解放されない型でな"
"い限り必ず定義しなければなりません。"

#: ../../c-api/typeobj.rst:180
msgid ""
"The destructor function is called by the :c:func:`Py_DECREF` and :c:func:"
"`Py_XDECREF` macros when the new reference count is zero.  At this point, "
"the instance is still in existence, but there are no references to it.  The "
"destructor function should free all references which the instance owns, free "
"all memory buffers owned by the instance (using the freeing function "
"corresponding to the allocation function used to allocate the buffer), and "
"finally (as its last action) call the type's :c:member:`~PyTypeObject."
"tp_free` function.  If the type is not subtypable (doesn't have the :const:"
"`Py_TPFLAGS_BASETYPE` flag bit set), it is permissible to call the object "
"deallocator directly instead of via :c:member:`~PyTypeObject.tp_free`.  The "
"object deallocator should be the one used to allocate the instance; this is "
"normally :c:func:`PyObject_Del` if the instance was allocated using :c:func:"
"`PyObject_New` or :c:func:`PyObject_VarNew`, or :c:func:`PyObject_GC_Del` if "
"the instance was allocated using :c:func:`PyObject_GC_New` or :c:func:"
"`PyObject_GC_NewVar`."
msgstr ""
"デストラクタ関数は、参照カウントが新たにゼロになった際に :c:func:`Py_DECREF` "
"や :c:func:`Py_XDECREF` マクロから呼び出されます。呼び出された時点では、イン"
"スタンスはまだ存在しますが、インスタンスに対する参照は全くない状態です。デス"
"トラクタ関数はインスタンスが保持している全ての参照を解放し、インスタンスが確"
"保している全てのメモリバッファを (バッファの確保時に使った関数に対応するメモ"
"リ解放関数を使って) 解放し、最後に (デストラクタ関数の最後の操作として) その"
"型の :c:member:`~PyTypeObject.tp_free` 関数を呼び出します。ある型がサブタイプ"
"を作成できない (:const:`Py_TPFLAGS_BASETYPE` フラグがセットされていない) 場"
"合、 :c:member:`~PyTypeObject.tp_free` の代わりにオブジェクトのメモリ解放関"
"数 (deallocator) を直接呼び出してもかまいません。オブジェクトのメモリ解放関数"
"は、インスタンスのメモリ確保を行う際に使った関数に対応したものでなければなり"
"ません; インスタンスを :c:func:`PyObject_New` や :c:func:`PyObject_VarNew` で"
"メモリ確保した場合には、通常 :c:func:`PyObject_Del` を使い、 :c:func:"
"`PyObject_GC_New` や :c:func:`PyObject_GC_NewVar` で確保した場合には :c:func:"
"`PyObject_GC_Del` を使います。"

#: ../../c-api/typeobj.rst:195 ../../c-api/typeobj.rst:224
#: ../../c-api/typeobj.rst:291 ../../c-api/typeobj.rst:359
#: ../../c-api/typeobj.rst:377 ../../c-api/typeobj.rst:768
#: ../../c-api/typeobj.rst:786 ../../c-api/typeobj.rst:864
#: ../../c-api/typeobj.rst:962
msgid "This field is inherited by subtypes."
msgstr "サブタイプはこのフィールドを継承します。"

#: ../../c-api/typeobj.rst:200
msgid "An optional pointer to the instance print function."
msgstr ""
"オプションのフィールドで、インスタンスの出力 (print) を行う関数を指すポインタ"
"です。"

#: ../../c-api/typeobj.rst:202
msgid ""
"The print function is only called when the instance is printed to a *real* "
"file; when it is printed to a pseudo-file (like a :class:`~StringIO."
"StringIO` instance), the instance's :c:member:`~PyTypeObject.tp_repr` or :c:"
"member:`~PyTypeObject.tp_str` function is called to convert it to a string.  "
"These are also called when the type's :c:member:`~PyTypeObject.tp_print` "
"field is *NULL*.  A type should never implement :c:member:`~PyTypeObject."
"tp_print` in a way that produces different output than :c:member:"
"`~PyTypeObject.tp_repr` or :c:member:`~PyTypeObject.tp_str` would."
msgstr ""
"出力関数は、インスタンスが *実体のある (real)* ファイルに出力される場合にのみ"
"呼び出されます; (:class:`~StringIO.StringIO` インスタンスのような) 擬似ファイ"
"ルに出力される場合には、インスタンスの :c:member:`~PyTypeObject.tp_repr` や :"
"c:member:`~PyTypeObject.tp_str` が指す関数が呼び出され、文字列への変換を行い"
"ます。また、 :c:member:`~PyTypeObject.tp_print` が *NULL* の場合にもこれらの"
"関数が呼び出されます。 :c:member:`~PyTypeObject.tp_repr` や :c:member:"
"`~PyTypeObject.tp_str` と異なる出力を生成するような :c:member:`~PyTypeObject."
"tp_print` は、決して型に実装してはなりません。"

#: ../../c-api/typeobj.rst:209
msgid ""
"The print function is called with the same signature as :c:func:"
"`PyObject_Print`: ``int tp_print(PyObject *self, FILE *file, int flags)``.  "
"The *self* argument is the instance to be printed.  The *file* argument is "
"the stdio file to which it is to be printed.  The *flags* argument is "
"composed of flag bits. The only flag bit currently defined is :const:"
"`Py_PRINT_RAW`. When the :const:`Py_PRINT_RAW` flag bit is set, the instance "
"should be printed the same way as :c:member:`~PyTypeObject.tp_str` would "
"format it; when the :const:`Py_PRINT_RAW` flag bit is clear, the instance "
"should be printed the same was as :c:member:`~PyTypeObject.tp_repr` would "
"format it. It should return ``-1`` and set an exception condition when an "
"error occurred during the comparison."
msgstr ""
"出力関数は :c:func:`PyObject_Print` と同じシグネチャ: ``int "
"tp_print(PyObject *self, FILE *file, int flags)`` で呼び出されます。 *self* "
"引数は出力されるインスタンスを指します。 *file* 引数は出力先となる標準入出力 "
"(stdio) ファイルです。 *flags* 引数はフラグビットを組み合わせた値です。現在定"
"義されているフラグビットは :const:`Py_PRINT_RAW` のみです。 :const:"
"`Py_PRINT_RAW` フラグビットがセットされていれば、インスタンスは :c:member:"
"`~PyTypeObject.tp_str` と同じ書式で出力されます; :const:`Py_PRINT_RAW` フラグ"
"ビットがクリアされていれば、インスタンスは :c:member:`~PyTypeObject.tp_repr` "
"と同じ書式で出力されます。操作中にエラーが生じたときは、この関数は ``-1`` を"
"返して例外状態をセットしなければなりません。"

#: ../../c-api/typeobj.rst:220
msgid ""
"It is possible that the :c:member:`~PyTypeObject.tp_print` field will be "
"deprecated. In any case, it is recommended not to define :c:member:"
"`~PyTypeObject.tp_print`, but instead to rely on :c:member:`~PyTypeObject."
"tp_repr` and :c:member:`~PyTypeObject.tp_str` for printing."
msgstr ""
":c:member:`~PyTypeObject.tp_print` フィールドは撤廃されるかもしれません。いず"
"れにせよ、 :c:member:`~PyTypeObject.tp_print` は定義せず、代わりに :c:member:"
"`~PyTypeObject.tp_repr` や :c:member:`~PyTypeObject.tp_str` に頼って出力を行"
"うようにしてください。"

#: ../../c-api/typeobj.rst:229
msgid "An optional pointer to the get-attribute-string function."
msgstr ""
"オプションのフィールドです。ポインタで、 get-attribute-string を行う関数を指"
"します。"

#: ../../c-api/typeobj.rst:231
msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :c:member:`~PyTypeObject.tp_getattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name.  The signature is ::"
msgstr ""
"このフィールドは非推奨です。\n"
"このフィールドを定義するときは、 :c:member:`~PyTypeObject.tp_getattro` 関数と"
"同じように動作し、属性名は Python 文字列 オブジェクトではなく C 文字列で指定"
"するような関数を指すようにしなければなりません。\n"
"シグネチャは次の通りです::"

#: ../../c-api/typeobj.rst:237
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_getattro`: a subtype inherits both :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject."
"tp_getattro` are both *NULL*."
msgstr ""
"このフィールドは :c:member:`~PyTypeObject.tp_getattro` と共にサブタイプに継承"
"されます: すなわち、サブタイプの :c:member:`~PyTypeObject.tp_getattr` およ"
"び :c:member:`~PyTypeObject.tp_getattro` が共に *NULL* の場合、サブタイプは基"
"底タイプから :c:member:`~PyTypeObject.tp_getattr` と :c:member:"
"`~PyTypeObject.tp_getattro` を両方とも継承します。"

#: ../../c-api/typeobj.rst:244 ../../c-api/typeobj.rst:395
msgid ""
"An optional pointer to the function for setting and deleting attributes."
msgstr "オプションのポインタで、属性の設定と削除を行う関数を指します。"

#: ../../c-api/typeobj.rst:246
msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :c:member:`~PyTypeObject.tp_setattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name.  The signature is ::"
msgstr ""
"このフィールドは非推奨です。\n"
"このフィールドを定義するときは、 :c:member:`~PyTypeObject.tp_setattro` 関数と"
"同じように動作し、属性名は Python 文字列 オブジェクトではなく C 文字列で指定"
"するような関数を指すようにしなければなりません。\n"
"シグネチャは次の通りです::"

#: ../../c-api/typeobj.rst:252
msgid ""
"The *v* argument is set to *NULL* to delete the attribute. This field is "
"inherited by subtypes together with :c:member:`~PyTypeObject.tp_setattro`: a "
"subtype inherits both :c:member:`~PyTypeObject.tp_setattr` and :c:member:"
"`~PyTypeObject.tp_setattro` from its base type when the subtype's :c:member:"
"`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject.tp_setattro` are "
"both *NULL*."
msgstr ""
"引数 *v* に *NULL* を設定すると属性を削除します。\n"
"このフィールドは :c:member:`~PyTypeObject.tp_setattro` と共にサブタイプに継承"
"されます: すなわち、サブタイプの :c:member:`~PyTypeObject.tp_setattr` およ"
"び :c:member:`~PyTypeObject.tp_setattro` が両方とも *NULL* のとき、サブタイプ"
"は基底タイプから :c:member:`~PyTypeObject.tp_setattr` と :c:member:"
"`~PyTypeObject.tp_setattro` を両方とも継承します。"

#: ../../c-api/typeobj.rst:260
msgid "An optional pointer to the three-way comparison function."
msgstr ""
"オプションのフィールドです。ポインタで、三値比較 (three-way comparison) を行"
"う関数を指します。"

#: ../../c-api/typeobj.rst:262
msgid ""
"The signature is the same as for :c:func:`PyObject_Compare`. The function "
"should return ``1`` if *self* greater than *other*, ``0`` if *self* is equal "
"to *other*, and ``-1`` if *self* less than *other*.  It should return ``-1`` "
"and set an exception condition when an error occurred during the comparison."
msgstr ""
"シグネチャは :c:func:`PyObject_Compare` と同じです。この関数は *self* が "
"*other* よりも大きければ ``1``, *self* と *other* の値が等しければ ``0``, "
"*self* が *other* より小さければ ``-1`` を返します。この関数は、比較操作中に"
"エラーが生じた場合、例外状態をセットして ``-1`` を返さねばなりません。"

#: ../../c-api/typeobj.rst:267
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_richcompare` and :c:member:`~PyTypeObject.tp_hash`: a subtypes inherits "
"all three of :c:member:`~PyTypeObject.tp_compare`, :c:member:`~PyTypeObject."
"tp_richcompare`, and :c:member:`~PyTypeObject.tp_hash` when the subtype's :c:"
"member:`~PyTypeObject.tp_compare`, :c:member:`~PyTypeObject.tp_richcompare`, "
"and :c:member:`~PyTypeObject.tp_hash` are all *NULL*."
msgstr ""
"このフィールドは :c:member:`~PyTypeObject.tp_richcompare` および :c:member:"
"`~PyTypeObject.tp_hash` と共にサブタイプに継承されます: すなわち、サブタイプ"
"の :c:member:`~PyTypeObject.tp_compare`, :c:member:`~PyTypeObject."
"tp_richcompare` および :c:member:`~PyTypeObject.tp_hash` が共に *NULL* の場"
"合、サブタイプは基底タイプから :c:member:`~PyTypeObject.tp_compare`, :c:"
"member:`~PyTypeObject.tp_richcompare`, :c:member:`~PyTypeObject.tp_hash` の三"
"つを一緒に継承します。"

#: ../../c-api/typeobj.rst:277
msgid ""
"An optional pointer to a function that implements the built-in function :"
"func:`repr`."
msgstr ""
"オプションのフィールドです。ポインタで、組み込み関数 :func:`repr` を実装して"
"いる関数を指します。"

#: ../../c-api/typeobj.rst:280
msgid ""
"The signature is the same as for :c:func:`PyObject_Repr`; it must return a "
"string or a Unicode object.  Ideally, this function should return a string "
"that, when passed to :func:`eval`, given a suitable environment, returns an "
"object with the same value.  If this is not feasible, it should return a "
"string starting with ``'<'`` and ending with ``'>'`` from which both the "
"type and the value of the object can be deduced."
msgstr ""
"シグネチャは :c:func:`PyObject_Repr` と同じです。この関数は文字列オブジェクト"
"か Unicode オブジェクトを返さなければなりません。理想的には、この関数が返す文"
"字列は、適切な環境で :func:`eval` に渡した場合、同じ値を持つオブジェクトにな"
"るような文字列でなければなりません。不可能な場合には、オブジェクトの型と値か"
"ら導出した内容の入った ``'<'`` から始まって ``'>'`` で終わる文字列を返さなけ"
"ればなりません。"

#: ../../c-api/typeobj.rst:287
msgid ""
"When this field is not set, a string of the form ``<%s object at %p>`` is "
"returned, where ``%s`` is replaced by the type name, and ``%p`` by the "
"object's memory address."
msgstr ""
"このフィールドが設定されていない場合、 ``<%s object at %p>`` の形式をとる文字"
"列が返されます。 ``%s`` は型の名前に、 ``%p`` はオブジェクトのメモリアドレス"
"に置き換えられます。"

#: ../../c-api/typeobj.rst:295
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the number protocol.  These fields are documented "
"in :ref:`number-structs`."
msgstr ""
"数値プロトコルを実装した追加の構造体を指すポインタです。これらのフィールドに"
"ついては :ref:`number-structs` で説明されています。"

#: ../../c-api/typeobj.rst:299
msgid ""
"The :c:member:`~PyTypeObject.tp_as_number` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
":c:member:`~PyTypeObject.tp_as_number` フィールドは継承されませんが、そこの含"
"まれるフィールドが個別に継承されます。"

#: ../../c-api/typeobj.rst:305
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the sequence protocol.  These fields are documented "
"in :ref:`sequence-structs`."
msgstr ""
"シーケンスプロトコルを実装した追加の構造体を指すポインタです。これらのフィー"
"ルドについては :ref:`sequence-structs` で説明されています。"

#: ../../c-api/typeobj.rst:309
msgid ""
"The :c:member:`~PyTypeObject.tp_as_sequence` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
":c:member:`~PyTypeObject.tp_as_sequence` フィールドは継承されませんが、これに"
"含まれるフィールドが個別に継承されます。"

#: ../../c-api/typeobj.rst:315
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the mapping protocol.  These fields are documented "
"in :ref:`mapping-structs`."
msgstr ""
"マッピングプロトコルを実装した追加の構造体を指すポインタです。これらのフィー"
"ルドについては :ref:`mapping-structs` で説明されています。"

#: ../../c-api/typeobj.rst:319
msgid ""
"The :c:member:`~PyTypeObject.tp_as_mapping` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
":c:member:`~PyTypeObject.tp_as_mapping` フィールドは継承されませんが、これに"
"含まれるフィールドが個別に継承されます。"

#: ../../c-api/typeobj.rst:327
msgid ""
"An optional pointer to a function that implements the built-in function :"
"func:`hash`."
msgstr ""
"オプションのフィールドです。ポインタで、組み込み関数 :func:`hash` を実装して"
"いる関数を指します。"

#: ../../c-api/typeobj.rst:330
msgid ""
"The signature is the same as for :c:func:`PyObject_Hash`; it must return a C "
"long.  The value ``-1`` should not be returned as a normal return value; "
"when an error occurs during the computation of the hash value, the function "
"should set an exception and return ``-1``."
msgstr ""
"シグネチャは :c:func:`PyObject_Hash` と同じです。この関数は C の :c:type:"
"`long` 型の値を返さねばなりません。通常時には ``-1`` を戻り値にしてはなりませ"
"ん; ハッシュ値の計算中にエラーが生じた場合、関数は例外をセットして ``-1`` を"
"返さねばなりません。"

#: ../../c-api/typeobj.rst:335
msgid ""
"This field can be set explicitly to :c:func:`PyObject_HashNotImplemented` to "
"block inheritance of the hash method from a parent type. This is interpreted "
"as the equivalent of ``__hash__ = None`` at the Python level, causing "
"``isinstance(o, collections.Hashable)`` to correctly return ``False``. Note "
"that the converse is also true - setting ``__hash__ = None`` on a class at "
"the Python level will result in the ``tp_hash`` slot being set to :c:func:"
"`PyObject_HashNotImplemented`."
msgstr ""
"このフィールドは明示的に :c:func:`PyObject_HashNotImplemented` に設定すること"
"で、親 type からのハッシュメソッドの継承をブロックすることができます。これは "
"Python レベルでの ``__hash__ = None`` と同等に解釈され、 ``isinstance(o, "
"collections.Hashable)`` が正しく ``False`` を返すようになります。逆もまた可能"
"であることに注意してください - Python レベルで ``__hash__ = None`` を設定する"
"ことで ``tp_hash`` スロットは :c:func:`PyObject_HashNotImplemented` に設定さ"
"れます。"

#: ../../c-api/typeobj.rst:343
msgid ""
"When this field is not set, two possibilities exist: if the :c:member:"
"`~PyTypeObject.tp_compare` and :c:member:`~PyTypeObject.tp_richcompare` "
"fields are both *NULL*, a default hash value based on the object's address "
"is returned; otherwise, a :exc:`TypeError` is raised."
msgstr ""
"このフィールドが設定されていない場合、二つの可能性があります: :c:member:"
"`~PyTypeObject.tp_compare` および :c:member:`~PyTypeObject.tp_richcompare` "
"フィールドの両方が *NULL* の場合、オブジェクトのアドレスに基づいたデフォルト"
"のハッシュ値が返されます; それ以外の場合、 :exc:`TypeError` が送出されます。"

#: ../../c-api/typeobj.rst:347
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_richcompare` and :c:member:`~PyTypeObject.tp_compare`: a subtypes "
"inherits all three of :c:member:`~PyTypeObject.tp_compare`, :c:member:"
"`~PyTypeObject.tp_richcompare`, and :c:member:`~PyTypeObject.tp_hash`, when "
"the subtype's :c:member:`~PyTypeObject.tp_compare`, :c:member:`~PyTypeObject."
"tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` are all *NULL*."
msgstr ""
"このフィールドは :c:member:`~PyTypeObject.tp_compare` および :c:member:"
"`~PyTypeObject.tp_richcompare` と共にサブタイプに継承されます: すなわち、サブ"
"タイプの :c:member:`~PyTypeObject.tp_compare`, :c:member:`~PyTypeObject."
"tp_richcompare` および :c:member:`~PyTypeObject.tp_hash` が共に *NULL* の場"
"合、サブタイプは基底タイプから :c:member:`~PyTypeObject.tp_compare`, :c:"
"member:`~PyTypeObject.tp_richcompare`, :c:member:`~PyTypeObject.tp_hash` の三"
"つをいずれも継承します。"

#: ../../c-api/typeobj.rst:355
msgid ""
"An optional pointer to a function that implements calling the object.  This "
"should be *NULL* if the object is not callable.  The signature is the same "
"as for :c:func:`PyObject_Call`."
msgstr ""
"オプションのフィールドです。ポインタで、オブジェクトの呼び出しを実装している"
"関数を指します。オブジェクトが呼び出し可能でない場合には *NULL* にしなければ"
"なりません。シグネチャは :c:func:`PyObject_Call` と同じです。"

#: ../../c-api/typeobj.rst:364
msgid ""
"An optional pointer to a function that implements the built-in operation :"
"func:`str`.  (Note that :class:`str` is a type now, and :func:`str` calls "
"the constructor for that type.  This constructor calls :c:func:"
"`PyObject_Str` to do the actual work, and :c:func:`PyObject_Str` will call "
"this handler.)"
msgstr ""
"オプションのフィールドです。ポインタで、組み込みの演算 :func:`str` を実装して"
"いる関数を指します。(:class:`str` が型の一つになったため、 :func:`str` は :"
"class:`str` のコンストラクタを呼び出すことに注意してください。このコンストラ"
"クタは実際の処理を行う上で :c:func:`PyObject_Str` を呼び出し、さらに :c:func:"
"`PyObject_Str` がこのハンドラを呼び出すことになります。)"

#: ../../c-api/typeobj.rst:369
msgid ""
"The signature is the same as for :c:func:`PyObject_Str`; it must return a "
"string or a Unicode object.  This function should return a \"friendly\" "
"string representation of the object, as this is the representation that will "
"be used by the print statement."
msgstr ""
"シグネチャは :c:func:`PyObject_Str` と同じです; この関数は文字列オブジェクト"
"か Unicode オブジェクトを返さねばなりません。また、この関数はオブジェクトを "
"\"分かりやすく (friendly)\" 表現した文字列を返さねばなりません。というのは、"
"この文字列は :keyword:`print` 文で使われることになる表記だからです。"

#: ../../c-api/typeobj.rst:374
msgid ""
"When this field is not set, :c:func:`PyObject_Repr` is called to return a "
"string representation."
msgstr ""
"このフィールドが設定されていない場合、文字列表現を返すためには :c:func:"
"`PyObject_Repr` が呼び出されます。"

#: ../../c-api/typeobj.rst:382
msgid "An optional pointer to the get-attribute function."
msgstr ""
"オプションのフィールドです。ポインタで、 get-attribute を実装している関数を指"
"します。"

#: ../../c-api/typeobj.rst:384
msgid ""
"The signature is the same as for :c:func:`PyObject_GetAttr`.  It is usually "
"convenient to set this field to :c:func:`PyObject_GenericGetAttr`, which "
"implements the normal way of looking for object attributes."
msgstr ""
"シグネチャは :c:func:`PyObject_GetAttr` と同じです。対する通常の属性検索を実"
"装している :c:func:`PyObject_GenericGetAttr` をこのフィールドに設定しておくと"
"往々にして便利です。"

#: ../../c-api/typeobj.rst:388
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_getattr`: a subtype inherits both :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject."
"tp_getattro` are both *NULL*."
msgstr ""
"このフィールドは :c:member:`~PyTypeObject.tp_getattr` と共にサブタイプに継承"
"されます: すなわち、サブタイプの :c:member:`~PyTypeObject.tp_getattr` およ"
"び :c:member:`~PyTypeObject.tp_getattro` が共に *NULL* の場合、サブタイプは基"
"底タイプから :c:member:`~PyTypeObject.tp_getattr` と :c:member:"
"`~PyTypeObject.tp_getattro` を両方とも継承します。"

#: ../../c-api/typeobj.rst:397
msgid ""
"The signature is the same as for :c:func:`PyObject_SetAttr`, but setting *v* "
"to *NULL* to delete an attribute must be supported.  It is usually "
"convenient to set this field to :c:func:`PyObject_GenericSetAttr`, which "
"implements the normal way of setting object attributes."
msgstr ""
"シグネチャは :c:func:`PyObject_SetAttr` と同じですが、 *v* に *NULL* を指定し"
"て属性を削除できるようにしなければなりません。\n"
"通常の属性設定を実装している :c:func:`PyObject_GenericSetAttr`  をこのフィー"
"ルドに設定しておくとたいていの場合は便利です。"

#: ../../c-api/typeobj.rst:402
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_setattr`: a subtype inherits both :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject."
"tp_setattro` are both *NULL*."
msgstr ""
"このフィールドは :c:member:`~PyTypeObject.tp_setattr` と共にサブタイプに継承"
"されます: すなわち、サブタイプの :c:member:`~PyTypeObject.tp_setattr` およ"
"び :c:member:`~PyTypeObject.tp_setattro` が共に *NULL* の場合、サブタイプは基"
"底タイプから :c:member:`~PyTypeObject.tp_setattr` と :c:member:"
"`~PyTypeObject.tp_setattro` を両方とも継承します。"

#: ../../c-api/typeobj.rst:409
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the buffer interface.  These fields are documented "
"in :ref:`buffer-structs`."
msgstr ""
"バッファインタフェースを実装しているオブジェクトにのみ関連する、一連のフィー"
"ルド群が入った別の構造体を指すポインタです。構造体内の各フィールドは :ref:"
"`buffer-structs` で説明します。"

#: ../../c-api/typeobj.rst:413
msgid ""
"The :c:member:`~PyTypeObject.tp_as_buffer` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
":c:member:`~PyTypeObject.tp_as_buffer` フィールド自体は継承されませんが、これ"
"に含まれるフィールドは個別に継承されます。"

#: ../../c-api/typeobj.rst:419
msgid ""
"This field is a bit mask of various flags.  Some flags indicate variant "
"semantics for certain situations; others are used to indicate that certain "
"fields in the type object (or in the extension structures referenced via :c:"
"member:`~PyTypeObject.tp_as_number`, :c:member:`~PyTypeObject."
"tp_as_sequence`, :c:member:`~PyTypeObject.tp_as_mapping`, and :c:member:"
"`~PyTypeObject.tp_as_buffer`) that were historically not always present are "
"valid; if such a flag bit is clear, the type fields it guards must not be "
"accessed and must be considered to have a zero or *NULL* value instead."
msgstr ""
"このフィールドは様々なフラグからなるビットマスクです。いくつかのフラグは、特"
"定の状況において変則的なセマンティクスが適用されることを示します; その他のフ"
"ラグは、型オブジェクト (あるいは :c:member:`~PyTypeObject.tp_as_number` 、 :"
"c:member:`~PyTypeObject.tp_as_sequence` 、 :c:member:`~PyTypeObject."
"tp_as_mapping` 、 および :c:member:`~PyTypeObject.tp_as_buffer` が参照してい"
"る拡張機能構造体) の特定のフィールドのうち、過去から現在までずっと存在してい"
"たわけではないものが有効になっていることを示すために使われます; フラグビット"
"がクリアされていれば、フラグが保護しているフィールドにはアクセスしない代わり"
"に、その値はゼロか *NULL* になっているとみなさなければなりません。"

#: ../../c-api/typeobj.rst:427
msgid ""
"Inheritance of this field is complicated.  Most flag bits are inherited "
"individually, i.e. if the base type has a flag bit set, the subtype inherits "
"this flag bit.  The flag bits that pertain to extension structures are "
"strictly inherited if the extension structure is inherited, i.e. the base "
"type's value of the flag bit is copied into the subtype together with a "
"pointer to the extension structure.  The :const:`Py_TPFLAGS_HAVE_GC` flag "
"bit is inherited together with the :c:member:`~PyTypeObject.tp_traverse` "
"and :c:member:`~PyTypeObject.tp_clear` fields, i.e. if the :const:"
"`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and the :c:member:"
"`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear` fields in "
"the subtype exist (as indicated by the :const:`Py_TPFLAGS_HAVE_RICHCOMPARE` "
"flag bit) and have *NULL* values."
msgstr ""
"このフィールドの継承は複雑です。ほとんどのフラグビットは個別に継承されます。"
"つまり、基底タイプであるフラグビットがセットされている場合、サブタイプはその"
"フラグビットを継承します。機能拡張のための構造体に関するフラグビットは、その"
"機能拡張構造体が継承されるときに限定して継承されます。すなわち、基底タイプの"
"フラグビットの値は、機能拡張構造体へのポインタと一緒にサブタイプにコピーされ"
"ます。 :const:`Py_TPFLAGS_HAVE_GC` フラグビットは、 :c:member:`~PyTypeObject."
"tp_traverse` および :c:member:`~PyTypeObject.tp_clear` フィールドと合わせてコ"
"ピーされます。すなわち、サブタイプの :const:`Py_TPFLAGS_HAVE_GC` フラグビット"
"がクリアで、かつ (:const:`Py_TPFLAGS_HAVE_RICHCOMPARE` フラグビットの指定に"
"よって) :c:member:`~PyTypeObject.tp_traverse` および :c:member:"
"`~PyTypeObject.tp_clear` フィールドがサブタイプ内に存在しており、かつ値が "
"*NULL* の場合に基底タイプから値を継承します。"

#: ../../c-api/typeobj.rst:439
msgid ""
"The following bit masks are currently defined; these can be ORed together "
"using the ``|`` operator to form the value of the :c:member:`~PyTypeObject."
"tp_flags` field.  The macro :c:func:`PyType_HasFeature` takes a type and a "
"flags value, *tp* and *f*, and checks whether ``tp->tp_flags & f`` is non-"
"zero."
msgstr ""
"以下に挙げるビットマスクは現在定義されているものです; フラグは ``|`` 演算子で"
"論理和を取って :c:member:`~PyTypeObject.tp_flags` フィールドの値を作成できま"
"す。 :c:func:`PyType_HasFeature` マクロは型とフラグ値、 *tp* および *f* をと"
"り、 ``tp->tp_flags & f`` が非ゼロかどうか調べます。"

#: ../../c-api/typeobj.rst:447
msgid ""
"If this bit is set, the :c:type:`PyBufferProcs` struct referenced by :c:"
"member:`~PyTypeObject.tp_as_buffer` has the :attr:`bf_getcharbuffer` field."
msgstr ""
"このビットがセットされていれば、 :c:member:`~PyTypeObject.tp_as_buffer` が参"
"照する :c:type:`PyBufferProcs` 構造体には :attr:`bf_getcharbuffer` フィールド"
"があります。"

#: ../../c-api/typeobj.rst:453
msgid ""
"If this bit is set, the :c:type:`PySequenceMethods` struct referenced by :c:"
"member:`~PyTypeObject.tp_as_sequence` has the :attr:`sq_contains` field."
msgstr ""
"このビットがセットされていれば、 :c:member:`~PyTypeObject.tp_as_sequence` が"
"参照する :c:type:`PySequenceMethods` 構造体には :attr:`sq_contains` フィール"
"ドがあります。"

#: ../../c-api/typeobj.rst:459
msgid ""
"This bit is obsolete.  The bit it used to name is no longer in use.  The "
"symbol is now defined as zero."
msgstr ""
"このビットは旧式のものです。このシンボルが指し示していたビットはもはや使われ"
"ていません。シンボルの現在の定義はゼロになっています。"

#: ../../c-api/typeobj.rst:465
msgid ""
"If this bit is set, the :c:type:`PySequenceMethods` struct referenced by :c:"
"member:`~PyTypeObject.tp_as_sequence` and the :c:type:`PyNumberMethods` "
"structure referenced by :c:member:`~PyTypeObject.tp_as_number` contain the "
"fields for in-place operators. In particular, this means that the :c:type:"
"`PyNumberMethods` structure has the fields :attr:`nb_inplace_add`, :attr:"
"`nb_inplace_subtract`, :attr:`nb_inplace_multiply`, :attr:"
"`nb_inplace_divide`, :attr:`nb_inplace_remainder`, :attr:"
"`nb_inplace_power`, :attr:`nb_inplace_lshift`, :attr:`nb_inplace_rshift`, :"
"attr:`nb_inplace_and`, :attr:`nb_inplace_xor`, and :attr:`nb_inplace_or`; "
"and the :c:type:`PySequenceMethods` struct has the fields :attr:"
"`sq_inplace_concat` and :attr:`sq_inplace_repeat`."
msgstr ""
"このビットがセットされていれば、 :c:member:`~PyTypeObject.tp_as_sequence` が"
"参照する :c:type:`PySequenceMethods` 構造体、および :c:member:`~PyTypeObject."
"tp_as_number` が参照する :c:type:`PyNumberMethods` 構造体には in-place 演算に"
"関するフィールドが入っています。具体的に言うと、 :c:type:`PyNumberMethods` 構"
"造体はフィールド :attr:`nb_inplace_add`, :attr:`nb_inplace_subtract`, :attr:"
"`nb_inplace_multiply`, :attr:`nb_inplace_divide`, :attr:"
"`nb_inplace_remainder`, :attr:`nb_inplace_power`, :attr:"
"`nb_inplace_lshift`, :attr:`nb_inplace_rshift`, :attr:`nb_inplace_and`, :"
"attr:`nb_inplace_xor`,および :attr:`nb_inplace_or` を持つことになります; ま"
"た、 :c:type:`PySequenceMethods` 構造体はフィールド :attr:"
"`sq_inplace_concat` および :attr:`sq_inplace_repeat` を持つことになります。"

#: ../../c-api/typeobj.rst:480
msgid ""
"If this bit is set, the binary and ternary operations in the :c:type:"
"`PyNumberMethods` structure referenced by :c:member:`~PyTypeObject."
"tp_as_number` accept arguments of arbitrary object types, and do their own "
"type conversions if needed.  If this bit is clear, those operations require "
"that all arguments have the current type as their type, and the caller is "
"supposed to perform a coercion operation first.  This applies to :attr:"
"`nb_add`, :attr:`nb_subtract`, :attr:`nb_multiply`, :attr:`nb_divide`, :attr:"
"`nb_remainder`, :attr:`nb_divmod`, :attr:`nb_power`, :attr:`nb_lshift`, :"
"attr:`nb_rshift`, :attr:`nb_and`, :attr:`nb_xor`, and :attr:`nb_or`."
msgstr ""
"このビットがセットされていれば、 :c:member:`~PyTypeObject.tp_as_number` が参"
"照する :c:type:`PyNumberMethods` 構造体内で定義されている二項演算子および三項"
"演算子は任意のオブジェクト型を非演算子にとるようになり、必要に応じて引数の型"
"変換を行います。このビットがクリアなら、演算子は全ての引数が現在のオブジェク"
"ト型と同じであるよう要求し、演算の呼び出し側は演算に先立って型変換を行うもの"
"と想定します。対象となる演算子は :attr:`nb_add`, :attr:`nb_subtract`, :attr:"
"`nb_multiply`, :attr:`nb_divide`, :attr:`nb_remainder`, :attr:`nb_divmod`, :"
"attr:`nb_power`, :attr:`nb_lshift`, :attr:`nb_rshift`, :attr:`nb_and`, :attr:"
"`nb_xor`,および :attr:`nb_or` です。"

#: ../../c-api/typeobj.rst:493
msgid ""
"If this bit is set, the type object has the :c:member:`~PyTypeObject."
"tp_richcompare` field, as well as the :c:member:`~PyTypeObject.tp_traverse` "
"and the :c:member:`~PyTypeObject.tp_clear` fields."
msgstr ""
"このビットがセットされていれば、型オブジェクトには :c:member:`~PyTypeObject."
"tp_richcompare` フィールド、そして :c:member:`~PyTypeObject.tp_traverse` およ"
"び :c:member:`~PyTypeObject.tp_clear` フィールドがあります。"

#: ../../c-api/typeobj.rst:499
msgid ""
"If this bit is set, the :c:member:`~PyTypeObject.tp_weaklistoffset` field is "
"defined.  Instances of a type are weakly referenceable if the type's :c:"
"member:`~PyTypeObject.tp_weaklistoffset` field has a value greater than zero."
msgstr ""
"このビットがセットされていれば、構造体には :c:member:`~PyTypeObject."
"tp_weaklistoffset` フィールドが定義されています。 :c:member:`~PyTypeObject."
"tp_weaklistoffset` フィールドの値がゼロより大きければ、この型のインスタンスは"
"弱参照で参照できます。"

#: ../../c-api/typeobj.rst:506
msgid ""
"If this bit is set, the type object has the :c:member:`~PyTypeObject."
"tp_iter` and :c:member:`~PyTypeObject.tp_iternext` fields."
msgstr ""
"このビットがセットされていれば、型オブジェクトには :c:member:`~PyTypeObject."
"tp_iter` および :c:member:`~PyTypeObject.tp_iternext` フィールドがあります。"

#: ../../c-api/typeobj.rst:512
msgid ""
"If this bit is set, the type object has several new fields defined starting "
"in Python 2.2: :c:member:`~PyTypeObject.tp_methods`, :c:member:"
"`~PyTypeObject.tp_members`, :c:member:`~PyTypeObject.tp_getset`, :c:member:"
"`~PyTypeObject.tp_base`, :c:member:`~PyTypeObject.tp_dict`, :c:member:"
"`~PyTypeObject.tp_descr_get`, :c:member:`~PyTypeObject.tp_descr_set`, :c:"
"member:`~PyTypeObject.tp_dictoffset`, :c:member:`~PyTypeObject.tp_init`, :c:"
"member:`~PyTypeObject.tp_alloc`, :c:member:`~PyTypeObject.tp_new`, :c:member:"
"`~PyTypeObject.tp_free`, :c:member:`~PyTypeObject.tp_is_gc`, :c:member:"
"`~PyTypeObject.tp_bases`, :c:member:`~PyTypeObject.tp_mro`, :c:member:"
"`~PyTypeObject.tp_cache`, :c:member:`~PyTypeObject.tp_subclasses`, and :c:"
"member:`~PyTypeObject.tp_weaklist`."
msgstr ""
"このビットがセットされていれば、型オブジェクトは Python 2.2 以降で定義されて"
"いる新たなフィールド: :c:member:`~PyTypeObject.tp_methods`, :c:member:"
"`~PyTypeObject.tp_members`, :c:member:`~PyTypeObject.tp_getset`, :c:member:"
"`~PyTypeObject.tp_base`, :c:member:`~PyTypeObject.tp_dict`, :c:member:"
"`~PyTypeObject.tp_descr_get`, :c:member:`~PyTypeObject.tp_descr_set`, :c:"
"member:`~PyTypeObject.tp_dictoffset`, :c:member:`~PyTypeObject.tp_init`, :c:"
"member:`~PyTypeObject.tp_alloc`, :c:member:`~PyTypeObject.tp_new`, :c:member:"
"`~PyTypeObject.tp_free`, :c:member:`~PyTypeObject.tp_is_gc`, :c:member:"
"`~PyTypeObject.tp_bases`, :c:member:`~PyTypeObject.tp_mro`, :c:member:"
"`~PyTypeObject.tp_cache`, :c:member:`~PyTypeObject.tp_subclasses`,および :c:"
"member:`~PyTypeObject.tp_weaklist` があります。"

#: ../../c-api/typeobj.rst:522
msgid ""
"This bit is set when the type object itself is allocated on the heap.  In "
"this case, the :attr:`ob_type` field of its instances is considered a "
"reference to the type, and the type object is INCREF'ed when a new instance "
"is created, and DECREF'ed when an instance is destroyed (this does not apply "
"to instances of subtypes; only the type referenced by the instance's ob_type "
"gets INCREF'ed or DECREF'ed)."
msgstr ""
"型オブジェクト自体がヒープにメモリ確保される場合にセットされるビットです。型"
"オブジェクト自体がヒープにメモリ確保される場合、インスタンスの :attr:"
"`ob_type` フィールドは型オブジェクトへの参照とみなされます。この場合、新たな"
"インスタンスを生成する度に型オブジェクトを INCREF し、インスタンスを解放する"
"たびに DECREF します (サブタイプのインスタンスには適当されません; インスタン"
"スが :attr:`ob_type` で参照している型だけが INCREF および DECREF されます)。"

#: ../../c-api/typeobj.rst:532
msgid ""
"This bit is set when the type can be used as the base type of another type.  "
"If this bit is clear, the type cannot be subtyped (similar to a \"final\" "
"class in Java)."
msgstr ""
"型を別の型の基底タイプとして使える場合にセットされるビットです。このビットが"
"クリアならば、この型のサブタイプは生成できません (Java における \"final\" ク"
"ラスに似たクラスになります)。"

#: ../../c-api/typeobj.rst:539
msgid ""
"This bit is set when the type object has been fully initialized by :c:func:"
"`PyType_Ready`."
msgstr ""
"型オブジェクトが :c:func:`PyType_Ready` で完全に初期化されるとセットされる"
"ビットです。"

#: ../../c-api/typeobj.rst:545
msgid ""
"This bit is set while :c:func:`PyType_Ready` is in the process of "
"initializing the type object."
msgstr ""
":c:func:`PyType_Ready` による型オブジェクトの初期化処理中にセットされるビット"
"です。"

#: ../../c-api/typeobj.rst:551
msgid ""
"This bit is set when the object supports garbage collection.  If this bit is "
"set, instances must be created using :c:func:`PyObject_GC_New` and destroyed "
"using :c:func:`PyObject_GC_Del`.  More information in section :ref:"
"`supporting-cycle-detection`.  This bit also implies that the GC-related "
"fields :c:member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject."
"tp_clear` are present in the type object; but those fields also exist when :"
"const:`Py_TPFLAGS_HAVE_GC` is clear but :const:`Py_TPFLAGS_HAVE_RICHCOMPARE` "
"is set."
msgstr ""
"オブジェクトがガベージコレクション (GC) をサポートする場合にセットされるビッ"
"トです。このビットがセットされている場合、インスタンスは :c:func:"
"`PyObject_GC_New` を使って生成し、 :c:func:`PyObject_GC_Del` を使って破壊しな"
"ければなりません。詳しい情報は :ref:`supporting-cycle-detection` にあります。"
"このビットはまた、GC に関連するフィールド :c:member:`~PyTypeObject."
"tp_traverse` および :c:member:`~PyTypeObject.tp_clear` が型オブジェクト内に存"
"在することを示します; しかし、これらのフィールドは :const:"
"`Py_TPFLAGS_HAVE_GC` がクリアでも :const:`Py_TPFLAGS_HAVE_RICHCOMPARE` がセッ"
"トされている場合には存在します。"

#: ../../c-api/typeobj.rst:563
msgid ""
"This is a bitmask of all the bits that pertain to the existence of certain "
"fields in the type object and its extension structures. Currently, it "
"includes the following bits: :const:`Py_TPFLAGS_HAVE_GETCHARBUFFER`, :const:"
"`Py_TPFLAGS_HAVE_SEQUENCE_IN`, :const:`Py_TPFLAGS_HAVE_INPLACEOPS`, :const:"
"`Py_TPFLAGS_HAVE_RICHCOMPARE`, :const:`Py_TPFLAGS_HAVE_WEAKREFS`, :const:"
"`Py_TPFLAGS_HAVE_ITER`, and :const:`Py_TPFLAGS_HAVE_CLASS`."
msgstr ""
"型オブジェクトおよび拡張機能構造体の特定のフィールドの存在の有無に関連する全"
"てのビットからなるビットマスクです。現状では、このビットマスクには以下のビッ"
"ト: :const:`Py_TPFLAGS_HAVE_GETCHARBUFFER`, :const:"
"`Py_TPFLAGS_HAVE_SEQUENCE_IN`, :const:`Py_TPFLAGS_HAVE_INPLACEOPS`, :const:"
"`Py_TPFLAGS_HAVE_RICHCOMPARE`, :const:`Py_TPFLAGS_HAVE_WEAKREFS`, :const:"
"`Py_TPFLAGS_HAVE_ITER`,および :const:`Py_TPFLAGS_HAVE_CLASS` が入っています。"

#: ../../c-api/typeobj.rst:573
msgid ""
"An optional pointer to a NUL-terminated C string giving the docstring for "
"this type object.  This is exposed as the :attr:`__doc__` attribute on the "
"type and instances of the type."
msgstr ""
"オプションのフィールドです。ポインタで、この型オブジェクトの docstring を与え"
"る NUL 終端された C の文字列を指します。この値は型オブジェクトと型のインスタ"
"ンスにおける :attr:`__doc__` 属性として公開されます。"

#: ../../c-api/typeobj.rst:577
msgid "This field is *not* inherited by subtypes."
msgstr "サブタイプはこのフィールドを継承 *しません* 。"

#: ../../c-api/typeobj.rst:579
msgid ""
"The following three fields only exist if the :const:"
"`Py_TPFLAGS_HAVE_RICHCOMPARE` flag bit is set."
msgstr ""
"以下の三つのフィールドは、 :const:`Py_TPFLAGS_HAVE_RICHCOMPARE` フラグビット"
"がセットされている場合にのみ存在します。"

#: ../../c-api/typeobj.rst:585
msgid ""
"An optional pointer to a traversal function for the garbage collector.  This "
"is only used if the :const:`Py_TPFLAGS_HAVE_GC` flag bit is set.  More "
"information about Python's garbage collection scheme can be found in "
"section :ref:`supporting-cycle-detection`."
msgstr ""
"オプションのフィールドです。ポインタで、ガベージコレクタのためのトラバーサル"
"関数 (traversal function) を指します。 :const:`Py_TPFLAGS_HAVE_GC` がセットさ"
"れている場合にのみ使われます。Pythonのガベージコレクションの枠組みに関する詳"
"細は :ref:`supporting-cycle-detection` にあります。"

#: ../../c-api/typeobj.rst:590
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` pointer is used by the garbage "
"collector to detect reference cycles. A typical implementation of a :c:"
"member:`~PyTypeObject.tp_traverse` function simply calls :c:func:`Py_VISIT` "
"on each of the instance's members that are Python objects.  For example, "
"this is function :c:func:`local_traverse` from the :mod:`thread` extension "
"module::"
msgstr ""
":c:member:`~PyTypeObject.tp_traverse` ポインタは、ガベージコレクタが循環参照"
"を見つけるために使われます。 :c:member:`~PyTypeObject.tp_traverse` 関数の典型"
"的な実装は、インスタンスの各メンバのうち Pythonオブジェクトに対して :c:func:"
"`Py_VISIT` を呼び出します。例えば、次のコードは :mod:`thread` 拡張モジュール"
"の :c:func:`local_traverse` 関数になります::"

#: ../../c-api/typeobj.rst:605
msgid ""
"Note that :c:func:`Py_VISIT` is called only on those members that can "
"participate in reference cycles.  Although there is also a ``self->key`` "
"member, it can only be *NULL* or a Python string and therefore cannot be "
"part of a reference cycle."
msgstr ""
":c:func:`Py_VISIT` が循環参照になる恐れのあるメンバにだけ呼び出されていること"
"に注目してください。 ``self->key`` メンバもありますが、それは *NULL* か "
"Python文字列なので、循環参照の一部になることはありません。"

#: ../../c-api/typeobj.rst:609
msgid ""
"On the other hand, even if you know a member can never be part of a cycle, "
"as a debugging aid you may want to visit it anyway just so the :mod:`gc` "
"module's :func:`~gc.get_referents` function will include it."
msgstr ""
"一方、メンバが循環参照の一部になり得ないと判っていても、デバッグ目的で巡回し"
"たい場合があるかもしれないので、 :mod:`gc` モジュールの :func:`~gc."
"get_referents` 関数は循環参照になり得ないメンバも返します。"

#: ../../c-api/typeobj.rst:613
msgid ""
"Note that :c:func:`Py_VISIT` requires the *visit* and *arg* parameters to :c:"
"func:`local_traverse` to have these specific names; don't name them just "
"anything."
msgstr ""
":c:func:`Py_VISIT` は :c:func:`local_traverse` が *visit* と *arg* という決"
"まった名前の引数を持つことを要求します。"

#: ../../c-api/typeobj.rst:617
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_clear` and the :const:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :c:"
"member:`~PyTypeObject.tp_traverse`, and :c:member:`~PyTypeObject.tp_clear` "
"are all inherited from the base type if they are all zero in the subtype "
"*and* the subtype has the :const:`Py_TPFLAGS_HAVE_RICHCOMPARE` flag bit set."
msgstr ""
"このフィールドは :c:member:`~PyTypeObject.tp_clear` および :const:"
"`Py_TPFLAGS_HAVE_GC` フラグビットと一緒に継承されます: フラグビット、 :c:"
"member:`~PyTypeObject.tp_traverse`,および :c:member:`~PyTypeObject.tp_clear` "
"の値がサブタイプで全てゼロになっており、 *かつ* サブタイプで :const:"
"`Py_TPFLAGS_HAVE_RICHCOMPARE` フラグビットがセットされている場合に、基底タイ"
"プから値を継承します。"

#: ../../c-api/typeobj.rst:626
msgid ""
"An optional pointer to a clear function for the garbage collector. This is "
"only used if the :const:`Py_TPFLAGS_HAVE_GC` flag bit is set."
msgstr ""
"オプションのフィールドです。ポインタで、ガベージコレクタにおける消去関数 "
"(clear function) を指します。 :const:`Py_TPFLAGS_HAVE_GC` がセットされている"
"場合にのみ使われます。"

#: ../../c-api/typeobj.rst:629
msgid ""
"The :c:member:`~PyTypeObject.tp_clear` member function is used to break "
"reference cycles in cyclic garbage detected by the garbage collector.  Taken "
"together, all :c:member:`~PyTypeObject.tp_clear` functions in the system "
"must combine to break all reference cycles.  This is subtle, and if in any "
"doubt supply a :c:member:`~PyTypeObject.tp_clear` function.  For example, "
"the tuple type does not implement a :c:member:`~PyTypeObject.tp_clear` "
"function, because it's possible to prove that no reference cycle can be "
"composed entirely of tuples. Therefore the :c:member:`~PyTypeObject."
"tp_clear` functions of other types must be sufficient to break any cycle "
"containing a tuple.  This isn't immediately obvious, and there's rarely a "
"good reason to avoid implementing :c:member:`~PyTypeObject.tp_clear`."
msgstr ""
":c:member:`~PyTypeObject.tp_clear` メンバ関数は GC が検出した循環しているゴミ"
"の循環参照を壊すために用いられます。総合的な視点で考えると、システム内の全て"
"の :c:member:`~PyTypeObject.tp_clear` 関数が連携して、全ての循環参照を破壊し"
"なければなりません。 (訳注: ある型が :c:member:`~PyTypeObject.tp_clear` を実"
"装しなくても全ての循環参照が破壊できるのであれば実装しなくても良い) これはと"
"ても繊細で、もし少しでも不確かな部分があるのであれば、 :c:member:"
"`~PyTypeObject.tp_clear` 関数を提供するべきです。例えば、タプルは :c:member:"
"`~PyTypeObject.tp_clear` を実装しません。なぜなら、タプルだけで構成された循環"
"参照がみつかることは無いからです。従って、タプル以外の型の :c:member:"
"`~PyTypeObject.tp_clear` 関数だけで、タプルを含むどんな循環参照も必ず破壊でき"
"ることになります。これは簡単に判ることではなく、 :c:member:`~PyTypeObject."
"tp_clear` の実装を避ける良い理由はめったにありません。"

#: ../../c-api/typeobj.rst:639
msgid ""
"Implementations of :c:member:`~PyTypeObject.tp_clear` should drop the "
"instance's references to those of its members that may be Python objects, "
"and set its pointers to those members to *NULL*, as in the following "
"example::"
msgstr ""
"次の例にあるように、 :c:member:`~PyTypeObject.tp_clear` の実装は、インスタン"
"スから Python オブジェクトだと思われるメンバへの参照を外し、それらのメンバへ"
"のポインタに *NULL* をセットすべきです::"

#: ../../c-api/typeobj.rst:653
msgid ""
"The :c:func:`Py_CLEAR` macro should be used, because clearing references is "
"delicate:  the reference to the contained object must not be decremented "
"until after the pointer to the contained object is set to *NULL*.  This is "
"because decrementing the reference count may cause the contained object to "
"become trash, triggering a chain of reclamation activity that may include "
"invoking arbitrary Python code (due to finalizers, or weakref callbacks, "
"associated with the contained object). If it's possible for such code to "
"reference *self* again, it's important that the pointer to the contained "
"object be *NULL* at that time, so that *self* knows the contained object can "
"no longer be used.  The :c:func:`Py_CLEAR` macro performs the operations in "
"a safe order."
msgstr ""
"参照のクリアはデリケートなので、 :c:func:`Py_CLEAR` マクロを使うべきです: ポ"
"インタを *NULL* にセットするまで、そのオブジェクトの参照カウントをデクリメン"
"トしてはいけません。参照カウントのデクリメントすると、そのオブジェクトが破棄"
"されるかもしれず、 (そのオブジェクトに関連付けられたファイナライザ、弱参照の"
"コールバックにより) 任意のPythonコードの実行を含む後片付け処理が実行されるか"
"もしれないからです。もしそういったコードが再び *self* を参照することがあれ"
"ば、すでに持っていたオブジェクトへのポインタは *NULL* になっているので、 "
"*self* は所有していたオブジェクトをもう利用できないことを認識できます。 :c:"
"func:`Py_CLEAR` マクロはその手続きを安全な順番で実行します。"

#: ../../c-api/typeobj.rst:664
msgid ""
"Because the goal of :c:member:`~PyTypeObject.tp_clear` functions is to break "
"reference cycles, it's not necessary to clear contained objects like Python "
"strings or Python integers, which can't participate in reference cycles. On "
"the other hand, it may be convenient to clear all contained Python objects, "
"and write the type's :c:member:`~PyTypeObject.tp_dealloc` function to "
"invoke :c:member:`~PyTypeObject.tp_clear`."
msgstr ""
":c:member:`~PyTypeObject.tp_clear` 関数の目的は参照カウントを破壊することなの"
"で、 Python 文字列や Python 整数のような、循環参照に含むことのできないオブ"
"ジェクトをクリアする必要はありません。一方、所有する全ての Python オブジェク"
"トをクリアするようにし、その型の :c:member:`~PyTypeObject.tp_dealloc` 関数"
"が :c:member:`~PyTypeObject.tp_clear` 関数を実行するようにすると実装が楽にな"
"るでしょう。"

#: ../../c-api/typeobj.rst:670
msgid ""
"More information about Python's garbage collection scheme can be found in "
"section :ref:`supporting-cycle-detection`."
msgstr ""
"Pythonのガベージコレクションの仕組みについての詳細は、 :ref:`supporting-"
"cycle-detection` にあります。"

#: ../../c-api/typeobj.rst:673
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_traverse` and the :const:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :c:"
"member:`~PyTypeObject.tp_traverse`, and :c:member:`~PyTypeObject.tp_clear` "
"are all inherited from the base type if they are all zero in the subtype "
"*and* the subtype has the :const:`Py_TPFLAGS_HAVE_RICHCOMPARE` flag bit set."
msgstr ""
"このフィールドは :c:member:`~PyTypeObject.tp_traverse` および :const:"
"`Py_TPFLAGS_HAVE_GC` フラグビットと一緒に継承されます: フラグビット、 :c:"
"member:`~PyTypeObject.tp_traverse`,および :c:member:`~PyTypeObject.tp_clear` "
"の値がサブタイプで全てゼロになっており、 *かつ* サブタイプで :const:"
"`Py_TPFLAGS_HAVE_RICHCOMPARE` フラグビットがセットされている場合に、基底タイ"
"プから値を継承します。"

#: ../../c-api/typeobj.rst:682
msgid ""
"An optional pointer to the rich comparison function, whose signature is "
"``PyObject *tp_richcompare(PyObject *a, PyObject *b, int op)``."
msgstr ""
"オプションのフィールドで、拡張比較関数 (rich comparison function) を指すポイ"
"ンタです。拡張比較関数のシグネチャは ``PyObject *tp_richcompare(PyObject *a, "
"PyObject *b, int op)`` です。"

#: ../../c-api/typeobj.rst:685
msgid ""
"The function should return the result of the comparison (usually ``Py_True`` "
"or ``Py_False``).  If the comparison is undefined, it must return "
"``Py_NotImplemented``, if another error occurred it must return ``NULL`` and "
"set an exception condition."
msgstr ""
"この関数は、比較結果を返すべきです。(普通は ``Py_True`` か ``Py_False`` で"
"す。) 比較が未定義の場合は、``Py_NotImplemented`` を、それ以外のエラーが発生"
"した場合には例外状態をセットして ``NULL`` を返さなければなりません。"

#: ../../c-api/typeobj.rst:692
msgid ""
"If you want to implement a type for which only a limited set of comparisons "
"makes sense (e.g. ``==`` and ``!=``, but not ``<`` and friends), directly "
"raise :exc:`TypeError` in the rich comparison function."
msgstr ""
"限られた種類の比較だけが可能 (例えば、 ``==`` と ``!=`` が可能で ``<`` などが"
"不可能) な型を実装したい場合、拡張比較関数で直接 :exc:`TypeError` を返しま"
"す。"

#: ../../c-api/typeobj.rst:696
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_compare` and :c:member:`~PyTypeObject.tp_hash`: a subtype inherits all "
"three of :c:member:`~PyTypeObject.tp_compare`, :c:member:`~PyTypeObject."
"tp_richcompare`, and :c:member:`~PyTypeObject.tp_hash`, when the subtype's :"
"c:member:`~PyTypeObject.tp_compare`, :c:member:`~PyTypeObject."
"tp_richcompare`, and :c:member:`~PyTypeObject.tp_hash` are all *NULL*."
msgstr ""
"このフィールドは :c:member:`~PyTypeObject.tp_compare` および :c:member:"
"`~PyTypeObject.tp_hash` と共にサブタイプに継承されます: すなわち、サブタイプ"
"の :c:member:`~PyTypeObject.tp_compare`, :c:member:`~PyTypeObject."
"tp_richcompare` および :c:member:`~PyTypeObject.tp_hash` が共に *NULL* の場"
"合、サブタイプは基底タイプから :c:member:`~PyTypeObject.tp_compare`, :c:"
"member:`~PyTypeObject.tp_richcompare`, :c:member:`~PyTypeObject.tp_hash` の三"
"つを一緒に継承します。"

#: ../../c-api/typeobj.rst:701
msgid ""
"The following constants are defined to be used as the third argument for :c:"
"member:`~PyTypeObject.tp_richcompare` and for :c:func:`PyObject_RichCompare`:"
msgstr ""
":c:member:`~PyTypeObject.tp_richcompare` および :c:func:"
"`PyObject_RichCompare` 関数の第三引数に使うための定数としては以下が定義されて"
"います:"

#: ../../c-api/typeobj.rst:705
msgid "Constant"
msgstr "定数"

#: ../../c-api/typeobj.rst:705
msgid "Comparison"
msgstr "比較"

#: ../../c-api/typeobj.rst:707
msgid ":const:`Py_LT`"
msgstr ":const:`Py_LT`"

#: ../../c-api/typeobj.rst:707
msgid "``<``"
msgstr "``<``"

#: ../../c-api/typeobj.rst:709
msgid ":const:`Py_LE`"
msgstr ":const:`Py_LE`"

#: ../../c-api/typeobj.rst:709
msgid "``<=``"
msgstr "``<=``"

#: ../../c-api/typeobj.rst:711
msgid ":const:`Py_EQ`"
msgstr ":const:`Py_EQ`"

#: ../../c-api/typeobj.rst:711
msgid "``==``"
msgstr "``==``"

#: ../../c-api/typeobj.rst:713
msgid ":const:`Py_NE`"
msgstr ":const:`Py_NE`"

#: ../../c-api/typeobj.rst:713
msgid "``!=``"
msgstr "``!=``"

#: ../../c-api/typeobj.rst:715
msgid ":const:`Py_GT`"
msgstr ":const:`Py_GT`"

#: ../../c-api/typeobj.rst:715
msgid "``>``"
msgstr "``>``"

#: ../../c-api/typeobj.rst:717
msgid ":const:`Py_GE`"
msgstr ":const:`Py_GE`"

#: ../../c-api/typeobj.rst:717
msgid "``>=``"
msgstr "``>=``"

#: ../../c-api/typeobj.rst:721
msgid ""
"The next field only exists if the :const:`Py_TPFLAGS_HAVE_WEAKREFS` flag bit "
"is set."
msgstr ""
"次のフィールドは、 :const:`Py_TPFLAGS_HAVE_WEAKREFS` フラグビットがセットされ"
"ている場合にのみ存在します。"

#: ../../c-api/typeobj.rst:726
msgid ""
"If the instances of this type are weakly referenceable, this field is "
"greater than zero and contains the offset in the instance structure of the "
"weak reference list head (ignoring the GC header, if present); this offset "
"is used by :c:func:`PyObject_ClearWeakRefs` and the :c:func:`PyWeakref_\\*` "
"functions.  The instance structure needs to include a field of type :c:type:"
"`PyObject\\*` which is initialized to *NULL*."
msgstr ""
"型のインスタンスが弱参照可能な場合、このフィールドはゼロよりも大きな数にな"
"り、インスタンス構造体における弱参照リストの先頭を示すオフセットが入ります "
"(GC ヘッダがある場合には無視します); このオフセット値は :c:func:"
"`PyObject_ClearWeakRefs` および :c:func:`PyWeakref_\\*` 関数が利用します。イ"
"ンスタンス構造体には、 *NULL* に初期化された :c:type:`PyObject\\*` 型のフィー"
"ルドが入っていなければなりません。"

#: ../../c-api/typeobj.rst:733
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_weaklist`; that "
"is the list head for weak references to the type object itself."
msgstr ""
"このフィールドを :c:member:`~PyTypeObject.tp_weaklist` と混同しないようにして"
"ください; これは型オブジェクト自身への弱参照からなるリストの先頭です。"

#: ../../c-api/typeobj.rst:736
msgid ""
"This field is inherited by subtypes, but see the rules listed below. A "
"subtype may override this offset; this means that the subtype uses a "
"different weak reference list head than the base type.  Since the list head "
"is always found via :c:member:`~PyTypeObject.tp_weaklistoffset`, this should "
"not be a problem."
msgstr ""
"このフィールドはサブタイプに継承されますが、以下の規則を読んでください。サブ"
"タイプはこのオフセット値をオーバライドすることがあります; 従って、サブタイプ"
"では弱参照リストの先頭が基底タイプとは異なる場合があります。リストの先頭は常"
"に :c:member:`~PyTypeObject.tp_weaklistoffset` で分かるはずなので、このことは"
"問題にはならないはずです。"

#: ../../c-api/typeobj.rst:741
msgid ""
"When a type defined by a class statement has no :attr:`~object.__slots__` "
"declaration, and none of its base types are weakly referenceable, the type "
"is made weakly referenceable by adding a weak reference list head slot to "
"the instance layout and setting the :c:member:`~PyTypeObject."
"tp_weaklistoffset` of that slot's offset."
msgstr ""
":keyword:`class` 文で定義された型に :attr:`~object.__slots__` 宣言が全くな"
"く、かつ基底タイプが弱参照可能でない場合、その型を弱参照可能にするには弱参照"
"リストの先頭を表すスロットをインスタンスデータレイアウト構造体に追加し、ス"
"ロットのオフセットを :c:member:`~PyTypeObject.tp_weaklistoffset` に設定しま"
"す。"

#: ../../c-api/typeobj.rst:746
msgid ""
"When a type's :attr:`__slots__` declaration contains a slot named :attr:"
"`__weakref__`, that slot becomes the weak reference list head for instances "
"of the type, and the slot's offset is stored in the type's :c:member:"
"`~PyTypeObject.tp_weaklistoffset`."
msgstr ""
"型の :attr:`__slots__` の宣言に :attr:`__weakref__` という名前のスロットが含"
"まれているとき、スロットはその型のインスタンスにおける弱参照リストの先頭を表"
"すスロットになり、スロットのオフセットが型の :c:member:`~PyTypeObject."
"tp_weaklistoffset` に入ります。"

#: ../../c-api/typeobj.rst:751
msgid ""
"When a type's :attr:`__slots__` declaration does not contain a slot named :"
"attr:`__weakref__`, the type inherits its :c:member:`~PyTypeObject."
"tp_weaklistoffset` from its base type."
msgstr ""
"型の :attr:`__slots__` 宣言が :attr:`__weakref__` という名前のスロットを含ん"
"でいないとき、その型は基底タイプから :c:member:`~PyTypeObject."
"tp_weaklistoffset` を継承します。"

#: ../../c-api/typeobj.rst:755
msgid ""
"The next two fields only exist if the :const:`Py_TPFLAGS_HAVE_ITER` flag bit "
"is set."
msgstr ""
"次の二つのフィールドは、 :const:`Py_TPFLAGS_HAVE_ITER` フラグビットがセットさ"
"れている場合にのみ存在します。"

#: ../../c-api/typeobj.rst:761
msgid ""
"An optional pointer to a function that returns an iterator for the object.  "
"Its presence normally signals that the instances of this type are iterable "
"(although sequences may be iterable without this function, and classic "
"instances always have this function, even if they don't define an :meth:"
"`__iter__` method)."
msgstr ""
"オプションの変数で、そのオブジェクトのイテレータを返す関数へのポインタです。"
"この値が存在することは、通常この型のインスタンスがイテレート可能であることを"
"示しています。(しかし、シーケンスはこの関数がなくてもイテレート可能ですし、旧"
"スタイルクラスのインスタンスは :meth:`__iter__` メソッドを定義していなくても"
"この関数を持っています)"

#: ../../c-api/typeobj.rst:766
msgid "This function has the same signature as :c:func:`PyObject_GetIter`."
msgstr "この関数は :c:func:`PyObject_GetIter` と同じシグネチャを持っています。"

#: ../../c-api/typeobj.rst:773
msgid ""
"An optional pointer to a function that returns the next item in an iterator. "
"When the iterator is exhausted, it must return *NULL*; a :exc:"
"`StopIteration` exception may or may not be set.  When another error occurs, "
"it must return *NULL* too.  Its presence normally signals that the instances "
"of this type are iterators (although classic instances always have this "
"function, even if they don't define a :meth:`~iterator.next` method)."
msgstr ""
"オプションのフィールドで、イテレータにおいて次の要素を返す関数へのポインタで"
"す。イテレータの要素がなくなると、この関数は *NULL* を返さなければなりませ"
"ん。 :exc:`StopIteration` 例外は設定してもしなくても良いです。その他のエラー"
"が発生したときも、 *NULL* を返さなければなりません。このフィールドがあると、"
"通常この型のインスタンスがイテレータであることを示します (ただし、旧スタイル"
"のインスタンスでは、たとえ :meth:`~iterator.next` メソッドが定義されていなく"
"ても常にこの関数を持っています)。"

#: ../../c-api/typeobj.rst:780
msgid ""
"Iterator types should also define the :c:member:`~PyTypeObject.tp_iter` "
"function, and that function should return the iterator instance itself (not "
"a new iterator instance)."
msgstr ""
"イテレータ型では、 :c:member:`~PyTypeObject.tp_iter` 関数も定義されていなけれ"
"ばならず、その関数は (新たなイテレータインスタンスではなく) イテレータインス"
"タンス自体を返さねばなりません。"

#: ../../c-api/typeobj.rst:784
msgid "This function has the same signature as :c:func:`PyIter_Next`."
msgstr "この関数のシグネチャは :c:func:`PyIter_Next` と同じです。"

#: ../../c-api/typeobj.rst:788
msgid ""
"The next fields, up to and including :c:member:`~PyTypeObject.tp_weaklist`, "
"only exist if the :const:`Py_TPFLAGS_HAVE_CLASS` flag bit is set."
msgstr ""
"次の :c:member:`~PyTypeObject.tp_weaklist` までのフィールドは、 :const:"
"`Py_TPFLAGS_HAVE_CLASS` フラグビットがセットされている場合にのみ存在します。"

#: ../../c-api/typeobj.rst:794
msgid ""
"An optional pointer to a static *NULL*-terminated array of :c:type:"
"`PyMethodDef` structures, declaring regular methods of this type."
msgstr ""
"オプションのフィールドです。ポインタで、この型の正規 (regular) のメソッドを宣"
"言している :c:type:`PyMethodDef` 構造体からなる、 *NULL* で終端された静的な配"
"列を指します。"

#: ../../c-api/typeobj.rst:797
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a method descriptor."
msgstr ""
"配列の各要素ごとに、メソッドデスクリプタの入った、要素が型の辞書 (下記の :c:"
"member:`~PyTypeObject.tp_dict` 参照) に追加されます。"

#: ../../c-api/typeobj.rst:800
msgid ""
"This field is not inherited by subtypes (methods are inherited through a "
"different mechanism)."
msgstr ""
"サブタイプはこのフィールドを継承しません (メソッドは別個のメカニズムで継承さ"
"れています)。"

#: ../../c-api/typeobj.rst:806
msgid ""
"An optional pointer to a static *NULL*-terminated array of :c:type:"
"`PyMemberDef` structures, declaring regular data members (fields or slots) "
"of instances of this type."
msgstr ""
"オプションのフィールドです。ポインタで、型の正規 (regular) のデータメンバ "
"(フィールドおよびスロット) を宣言している :c:type:`PyMemberDef` 構造体からな"
"る、 *NULL* で終端された静的な配列を指します。"

#: ../../c-api/typeobj.rst:810
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a member descriptor."
msgstr ""
"配列の各要素ごとに、メンバデスクリプタの入った、要素が型の辞書 (下記の :c:"
"member:`~PyTypeObject.tp_dict` 参照) に追加されます。"

#: ../../c-api/typeobj.rst:813
msgid ""
"This field is not inherited by subtypes (members are inherited through a "
"different mechanism)."
msgstr ""
"サブタイプはこのフィールドを継承しません (メンバは別個のメカニズムで継承され"
"ています)。"

#: ../../c-api/typeobj.rst:819
msgid ""
"An optional pointer to a static *NULL*-terminated array of :c:type:"
"`PyGetSetDef` structures, declaring computed attributes of instances of this "
"type."
msgstr ""
"オプションのフィールドです。ポインタで、インスタンスの算出属性 (computed "
"attribute) を宣言している :c:type:`PyGetSetDef` 構造体からなる、 *NULL* で終"
"端された静的な配列を指します。"

#: ../../c-api/typeobj.rst:822
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a getset descriptor."
msgstr ""
"配列の各要素ごとに、 getter/setter デスクリプタの入った、要素が型の辞書 (下記"
"の :c:member:`~PyTypeObject.tp_dict` 参照) に追加されます。"

#: ../../c-api/typeobj.rst:825
msgid ""
"This field is not inherited by subtypes (computed attributes are inherited "
"through a different mechanism)."
msgstr ""
"サブタイプはこのフィールドを継承しません (算出属性は別個のメカニズムで継承さ"
"れています)。"

#: ../../c-api/typeobj.rst:831
msgid ""
"An optional pointer to a base type from which type properties are "
"inherited.  At this level, only single inheritance is supported; multiple "
"inheritance require dynamically creating a type object by calling the "
"metatype."
msgstr ""
"オプションのフィールドです。ポインタで、型に関するプロパティを継承する基底タ"
"イプへのポインタです。このフィールドのレベルでは、単継承 (single "
"inheritance) だけがサポートされています; 多重継承はメタタイプの呼び出しによる"
"動的な型オブジェクトの生成を必要とします。"

#: ../../c-api/typeobj.rst:835
msgid ""
"This field is not inherited by subtypes (obviously), but it defaults to "
"``&PyBaseObject_Type`` (which to Python programmers is known as the type :"
"class:`object`)."
msgstr ""
"(当たり前ですが) サブタイプはこのフィールドを継承しません。しかし、このフィー"
"ルドのデフォルト値は (Python プログラマは :class:`object` 型として知ってい"
"る) ``&PyBaseObject_Type`` になります。"

#: ../../c-api/typeobj.rst:842
msgid "The type's dictionary is stored here by :c:func:`PyType_Ready`."
msgstr ""
"型の辞書は :c:func:`PyType_Ready` によってこのフィールドに収められます。"

#: ../../c-api/typeobj.rst:844
msgid ""
"This field should normally be initialized to *NULL* before PyType_Ready is "
"called; it may also be initialized to a dictionary containing initial "
"attributes for the type.  Once :c:func:`PyType_Ready` has initialized the "
"type, extra attributes for the type may be added to this dictionary only if "
"they don't correspond to overloaded operations (like :meth:`__add__`)."
msgstr ""
"このフィールドは通常、 :c:func:`PyType_Ready` を呼び出す前に *NULL* に初期化"
"しておかなければなりません; あるいは、型の初期属性の入った辞書で初期化してお"
"いてもかまいません。 :c:func:`PyType_Ready` が型をひとたび初期化すると、型の"
"新たな属性をこの辞書に追加できるのは、属性が (:meth:`__add__` のような) オー"
"バロード用演算でないときだけです。"

#: ../../c-api/typeobj.rst:850
msgid ""
"This field is not inherited by subtypes (though the attributes defined in "
"here are inherited through a different mechanism)."
msgstr ""
"サブタイプはこのフィールドを継承しません (が、この辞書内で定義されている属性"
"は異なるメカニズムで継承されます)。"

#: ../../c-api/typeobj.rst:856
msgid "An optional pointer to a \"descriptor get\" function."
msgstr ""
"オプションのフィールドです。ポインタで、 \"デスクリプタ get\" 関数を指しま"
"す。"

#: ../../c-api/typeobj.rst:858 ../../c-api/typeobj.rst:872
#: ../../c-api/typeobj.rst:944 ../../c-api/typeobj.rst:969
#: ../../c-api/typeobj.rst:1000
msgid "The function signature is ::"
msgstr "関数のシグネチャは次のとおりです ::"

#: ../../c-api/typeobj.rst:869
msgid ""
"An optional pointer to a function for setting and deleting a descriptor's "
"value."
msgstr ""
"オプションのポインタで、デスクリプタの値の設定と削除を行う関数を指します。"

#: ../../c-api/typeobj.rst:876
msgid ""
"The *value* argument is set to *NULL* to delete the value. This field is "
"inherited by subtypes."
msgstr ""
"*value* 引数に *NULL* を設定して値を消します。\n"
"このフィールドはサブタイプに継承されます。"

#: ../../c-api/typeobj.rst:884
msgid ""
"If the instances of this type have a dictionary containing instance "
"variables, this field is non-zero and contains the offset in the instances "
"of the type of the instance variable dictionary; this offset is used by :c:"
"func:`PyObject_GenericGetAttr`."
msgstr ""
"型のインスタンスにインスタンス変数の入った辞書がある場合、このフィールドは非"
"ゼロの値になり、型のインスタンスデータ構造体におけるインスタンス変数辞書への"
"オフセットが入ります; このオフセット値は :c:func:`PyObject_GenericGetAttr` が"
"使います。"

#: ../../c-api/typeobj.rst:889
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_dict`; that is "
"the dictionary for attributes of the type object itself."
msgstr ""
"このフィールドを :c:member:`~PyTypeObject.tp_dict` と混同しないようにしてくだ"
"さい; これは型オブジェクト自身の属性の辞書です。"

#: ../../c-api/typeobj.rst:892
msgid ""
"If the value of this field is greater than zero, it specifies the offset "
"from the start of the instance structure.  If the value is less than zero, "
"it specifies the offset from the *end* of the instance structure.  A "
"negative offset is more expensive to use, and should only be used when the "
"instance structure contains a variable-length part.  This is used for "
"example to add an instance variable dictionary to subtypes of :class:`str` "
"or :class:`tuple`. Note that the :c:member:`~PyTypeObject.tp_basicsize` "
"field should account for the dictionary added to the end in that case, even "
"though the dictionary is not included in the basic object layout.  On a "
"system with a pointer size of 4 bytes, :c:member:`~PyTypeObject."
"tp_dictoffset` should be set to ``-4`` to indicate that the dictionary is at "
"the very end of the structure."
msgstr ""
"このフィールドの値がゼロより大きければ、値はインスタンス構造体の先頭からの オ"
"フセットを表します。値がゼロより小さければ、インスタンス構造体の *末尾* から"
"のオフセットを表します。負のオフセットを使うコストは比較的高くつくので、 イン"
"スタンス構造体に可変長部分があるときのみ使うべきです。例えば、 :class:`str` "
"や :class:`tuple` のサブタイプにインスタンス変数の辞書を追加する場合には、負"
"のオフセットを使います。この場合、たとえ辞書が基本のオブジェクトレイアウトに"
"含まれていなくても、 :c:member:`~PyTypeObject.tp_basicsize` フィールドは追加"
"された辞書を考慮にいれなければならないことに注意してください。ポインタサイズ"
"が 4 バイトのシステムでは、 構造体の最後尾に辞書が宣言されていることを示す場"
"合、 :c:member:`~PyTypeObject.tp_dictoffset` を ``-4`` にしなければなりませ"
"ん。"

#: ../../c-api/typeobj.rst:904
msgid ""
"The real dictionary offset in an instance can be computed from a negative :c:"
"member:`~PyTypeObject.tp_dictoffset` as follows::"
msgstr ""
"負の :c:member:`~PyTypeObject.tp_dictoffset` から、インスタンスでの実際のオフ"
"セットを計算するには以下のようにします::"

#: ../../c-api/typeobj.rst:911
msgid ""
"where :c:member:`~PyTypeObject.tp_basicsize`, :c:member:`~PyTypeObject."
"tp_itemsize` and :c:member:`~PyTypeObject.tp_dictoffset` are taken from the "
"type object, and :attr:`ob_size` is taken from the instance.  The absolute "
"value is taken because long ints use the sign of :attr:`ob_size` to store "
"the sign of the number.  (There's never a need to do this calculation "
"yourself; it is done for you by :c:func:`_PyObject_GetDictPtr`.)"
msgstr ""
"ここで、 :c:member:`~PyTypeObject.tp_basicsize`, :c:member:`~PyTypeObject."
"tp_itemsize` および :c:member:`~PyTypeObject.tp_dictoffset` は型オブジェクト"
"から取り出され、 :attr:`ob_size` はインスタンスから取り出されます。長整数は符"
"号を記憶するのに :attr:`ob_size` の符号を使うため、 :attr:`ob_size` は絶対値"
"を使います。(この計算を自分で行う必要はまったくありません; :c:func:"
"`_PyObject_GetDictPtr` がやってくれます。)"

#: ../../c-api/typeobj.rst:917
msgid ""
"This field is inherited by subtypes, but see the rules listed below. A "
"subtype may override this offset; this means that the subtype instances "
"store the dictionary at a difference offset than the base type.  Since the "
"dictionary is always found via :c:member:`~PyTypeObject.tp_dictoffset`, this "
"should not be a problem."
msgstr ""
"このフィールドはサブタイプに継承されますが、以下の規則を読んでください。サブ"
"タイプはこのオフセット値をオーバライドすることがあります; 従って、サブタイプ"
"では辞書のオフセットが基底タイプとは異なる場合があります。辞書のオフセットは"
"常に :c:member:`~PyTypeObject.tp_dictoffset` で分かるはずなので、このことは問"
"題にはならないはずです。"

#: ../../c-api/typeobj.rst:922
msgid ""
"When a type defined by a class statement has no :attr:`~object.__slots__` "
"declaration, and none of its base types has an instance variable dictionary, "
"a dictionary slot is added to the instance layout and the :c:member:"
"`~PyTypeObject.tp_dictoffset` is set to that slot's offset."
msgstr ""
":keyword:`class` 文で定義された型に :attr:`~object.__slots__` 宣言がなく、か"
"つ基底タイプの全てにインスタンス変数辞書がない場合、辞書のスロットをインスタ"
"ンスデータレイアウト構造体に追加し、スロットのオフセットを :c:member:"
"`~PyTypeObject.tp_dictoffset` に設定します。"

#: ../../c-api/typeobj.rst:927
msgid ""
"When a type defined by a class statement has a :attr:`__slots__` "
"declaration, the type inherits its :c:member:`~PyTypeObject.tp_dictoffset` "
"from its base type."
msgstr ""
":keyword:`class` 文で定義された型に :attr:`__slots__` 宣言がある場合、この型"
"は基底タイプから :c:member:`~PyTypeObject.tp_dictoffset` を継承します。"

#: ../../c-api/typeobj.rst:930
msgid ""
"(Adding a slot named :attr:`~object.__dict__` to the :attr:`__slots__` "
"declaration does not have the expected effect, it just causes confusion.  "
"Maybe this should be added as a feature just like :attr:`__weakref__` "
"though.)"
msgstr ""
"(:attr:`~object.__dict__` という名前のスロットを :attr:`__slots__` 宣言に追加"
"しても、期待どおりの効果は得られず、単に混乱を招くだけになります。とはいえ、"
"これは将来 :attr:`__weakref__` のように追加されるはずです。)"

#: ../../c-api/typeobj.rst:937
msgid "An optional pointer to an instance initialization function."
msgstr ""
"オプションのフィールドです。ポインタで、インスタンス初期化関数を指します。"

#: ../../c-api/typeobj.rst:939
msgid ""
"This function corresponds to the :meth:`__init__` method of classes.  Like :"
"meth:`__init__`, it is possible to create an instance without calling :meth:"
"`__init__`, and it is possible to reinitialize an instance by calling its :"
"meth:`__init__` method again."
msgstr ""
"この関数はクラスにおける :meth:`__init__` メソッドに対応します。 :meth:"
"`__init__` と同様、 :meth:`__init__` を呼び出さずにインスタンスを作成できま"
"す。また、 :meth:`__init__` を再度呼び出してインスタンスの再初期化もできま"
"す。"

#: ../../c-api/typeobj.rst:948
msgid ""
"The self argument is the instance to be initialized; the *args* and *kwds* "
"arguments represent positional and keyword arguments of the call to :meth:"
"`__init__`."
msgstr ""
"*self* 引数は初期化するインスタンスです; *args* および *kwds* 引数は、 :meth:"
"`__init__` を呼び出す際の固定引数およびキーワード引数です。"

#: ../../c-api/typeobj.rst:952
msgid ""
"The :c:member:`~PyTypeObject.tp_init` function, if not *NULL*, is called "
"when an instance is created normally by calling its type, after the type's :"
"c:member:`~PyTypeObject.tp_new` function has returned an instance of the "
"type.  If the :c:member:`~PyTypeObject.tp_new` function returns an instance "
"of some other type that is not a subtype of the original type, no :c:member:"
"`~PyTypeObject.tp_init` function is called; if :c:member:`~PyTypeObject."
"tp_new` returns an instance of a subtype of the original type, the "
"subtype's :c:member:`~PyTypeObject.tp_init` is called.  (VERSION NOTE: "
"described here is what is implemented in Python 2.2.1 and later.  In Python "
"2.2, the :c:member:`~PyTypeObject.tp_init` of the type of the object "
"returned by :c:member:`~PyTypeObject.tp_new` was always called, if not "
"*NULL*.)"
msgstr ""
":c:member:`~PyTypeObject.tp_init` 関数のフィールドが *NULL* でない場合、型の"
"呼び出しで普通にインスタンスを生成する際に、型の :c:member:`~PyTypeObject."
"tp_new` がインスタンスを返した後に :c:member:`~PyTypeObject.tp_init` が呼び出"
"されます。 :c:member:`~PyTypeObject.tp_new` が元の型のサブタイプでない別の型"
"を返す場合、 :c:member:`~PyTypeObject.tp_init` は全く呼び出されません; :c:"
"member:`~PyTypeObject.tp_new` が元の型のサブタイプのインスタンスを返す場合、"
"サブタイプの :c:member:`~PyTypeObject.tp_init` が呼び出されます。 (VERSION "
"NOTE: ここに書かれている内容は、Python 2.2.1 以降での実装に関するものです。"
"Python 2.2 では、 :c:member:`~PyTypeObject.tp_init` は *NULL* でない限り :c:"
"member:`~PyTypeObject.tp_new` が返す全てのオブジェクトに対して常に呼び出され"
"ます。) not *NULL*.)"

#: ../../c-api/typeobj.rst:967
msgid "An optional pointer to an instance allocation function."
msgstr ""
"オプションのフィールドです。ポインタで、インスタンスのメモリ確保関数を指しま"
"す。"

#: ../../c-api/typeobj.rst:973
msgid ""
"The purpose of this function is to separate memory allocation from memory "
"initialization.  It should return a pointer to a block of memory of adequate "
"length for the instance, suitably aligned, and initialized to zeros, but "
"with :attr:`ob_refcnt` set to ``1`` and :attr:`ob_type` set to the type "
"argument.  If the type's :c:member:`~PyTypeObject.tp_itemsize` is non-zero, "
"the object's :attr:`ob_size` field should be initialized to *nitems* and the "
"length of the allocated memory block should be ``tp_basicsize + "
"nitems*tp_itemsize``, rounded up to a multiple of ``sizeof(void*)``; "
"otherwise, *nitems* is not used and the length of the block should be :c:"
"member:`~PyTypeObject.tp_basicsize`."
msgstr ""
"この関数の目的は、メモリ確保をメモリ初期化から分離することにあります。この関"
"数は、インスタンス用の的確なサイズ、適切なアラインメント、ゼロによる初期化が"
"なされ、 :attr:`ob_refcnt` を ``1`` に、 :attr:`ob_type` を型引数 (type "
"argument) にセットしたメモリブロックへのポインタを返さねばなりません。型の :"
"c:member:`~PyTypeObject.tp_itemsize` がゼロでない場合、オブジェクトの :attr:"
"`ob_size` フィールドは *nitems* に初期化され、確保されるメモリブロックの長さ"
"は ``tp_basicsize + nitems*tp_itemsize`` を ``sizeof(void*)`` の倍数に切り上"
"げた値になるはずです; それ以外の場合、 *nitems* の値は使われず、メモリブロッ"
"クの長さは :c:member:`~PyTypeObject.tp_basicsize` になるはずです。"

#: ../../c-api/typeobj.rst:983
msgid ""
"Do not use this function to do any other instance initialization, not even "
"to allocate additional memory; that should be done by :c:member:"
"`~PyTypeObject.tp_new`."
msgstr ""
"この関数をインスタンス初期化の他のどの処理にも、追加でメモリ確保をする場合で"
"さえ使ってはなりません; そうした処理は :c:member:`~PyTypeObject.tp_new` で行"
"わねばなりません。"

#: ../../c-api/typeobj.rst:986
msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement); in the latter, this field is always "
"set to :c:func:`PyType_GenericAlloc`, to force a standard heap allocation "
"strategy. That is also the recommended value for statically defined types."
msgstr ""
"静的なサブタイプはこのフィールドを継承しますが、動的なサブタイプ (:keyword:"
"`class` 文で生成するサブタイプ) の場合は継承しません; 後者の場合、このフィー"
"ルドは常に :c:func:`PyType_GenericAlloc` にセットされ、標準のヒープ上メモリ確"
"保戦略が強制されます。静的に定義する型の場合でも、 :c:func:"
"`PyType_GenericAlloc` を推奨します。"

#: ../../c-api/typeobj.rst:994
msgid "An optional pointer to an instance creation function."
msgstr ""
"オプションのフィールドです。ポインタで、インスタンス生成関数を指します。"

#: ../../c-api/typeobj.rst:996
msgid ""
"If this function is *NULL* for a particular type, that type cannot be called "
"to create new instances; presumably there is some other way to create "
"instances, like a factory function."
msgstr ""
"このフィールドが *NULL* を指している型では、型を呼び出して新たなインスタンス"
"を生成できません; こうした型では、おそらくファクトリ関数のように、インスタン"
"スを生成する他の方法があるはずです。"

#: ../../c-api/typeobj.rst:1004
msgid ""
"The subtype argument is the type of the object being created; the *args* and "
"*kwds* arguments represent positional and keyword arguments of the call to "
"the type.  Note that subtype doesn't have to equal the type whose :c:member:"
"`~PyTypeObject.tp_new` function is called; it may be a subtype of that type "
"(but not an unrelated type)."
msgstr ""
"*subtype* 引数は生成するオブジェクトの型です; *args* および *kwds* 引数は、型"
"を呼び出すときの位置引数およびキーワード引数です。サブタイプは :c:member:"
"`~PyTypeObject.tp_new` 関数を呼び出すときに使う型と同じである必要はないことに"
"注意してください; その型の (無関係ではない) サブタイプのこともあります。"

#: ../../c-api/typeobj.rst:1010
msgid ""
"The :c:member:`~PyTypeObject.tp_new` function should call ``subtype-"
">tp_alloc(subtype, nitems)`` to allocate space for the object, and then do "
"only as much further initialization as is absolutely necessary.  "
"Initialization that can safely be ignored or repeated should be placed in "
"the :c:member:`~PyTypeObject.tp_init` handler.  A good rule of thumb is that "
"for immutable types, all initialization should take place in :c:member:"
"`~PyTypeObject.tp_new`, while for mutable types, most initialization should "
"be deferred to :c:member:`~PyTypeObject.tp_init`."
msgstr ""
":c:member:`~PyTypeObject.tp_new` 関数は ``subtype->tp_alloc(subtype, "
"nitems)`` を呼び出してオブジェクトのメモリ領域を確保し、初期化で絶対に必要と"
"される処理だけを行います。省略したり繰り返したりしても問題のない初期化処理"
"は :c:member:`~PyTypeObject.tp_init` ハンドラ内に配置しなければなりません。だ"
"いたいの目安としては、変更不能な型では初期化は全て :c:member:`~PyTypeObject."
"tp_new` で行い、一方、変更可能な型ではほとんどの初期化を :c:member:"
"`~PyTypeObject.tp_init` に回すべきです。"

#: ../../c-api/typeobj.rst:1018
msgid ""
"This field is inherited by subtypes, except it is not inherited by static "
"types whose :c:member:`~PyTypeObject.tp_base` is *NULL* or "
"``&PyBaseObject_Type``.  The latter exception is a precaution so that old "
"extension types don't become callable simply by being linked with Python 2.2."
msgstr ""
"サブタイプはこのフィールドを継承します。例外として、 :c:member:"
"`~PyTypeObject.tp_base` が *NULL* か ``&PyBaseObject_Type`` になっている静的"
"な型では継承しません。後者が例外になっているのは、旧式の拡張型が Python 2.2 "
"でリンクされたときに呼び出し可能オブジェクトにならないようにするための予防措"
"置です。"

#: ../../c-api/typeobj.rst:1026
msgid "An optional pointer to an instance deallocation function."
msgstr ""
"オプションのフィールドです。ポインタで、インスタンスのメモリ解放関数を指しま"
"す。"

#: ../../c-api/typeobj.rst:1028
msgid ""
"The signature of this function has changed slightly: in Python 2.2 and "
"2.2.1, its signature is :c:type:`destructor`::"
msgstr ""
"この関数のシグネチャは少し変更されています; Python 2.2 および 2.2.1 では、シ"
"グネチャは :c:type:`destructor` ::"

#: ../../c-api/typeobj.rst:1033
msgid "In Python 2.3 and beyond, its signature is :c:type:`freefunc`::"
msgstr ""
"でしたが、 Python 2.3 以降では、シグネチャは :c:type:`freefunc` になっていま"
"す::"

#: ../../c-api/typeobj.rst:1037
msgid ""
"The only initializer that is compatible with both versions is "
"``_PyObject_Del``, whose definition has suitably adapted in Python 2.3."
msgstr ""
"両方のバージョンと互換性のある初期値は ``_PyObject_Del`` です。 "
"``_PyObject_Del`` の定義は Python 2.3 で適切に対応できるよう変更されました。"

#: ../../c-api/typeobj.rst:1040
msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement); in the latter, this field is set to "
"a deallocator suitable to match :c:func:`PyType_GenericAlloc` and the value "
"of the :const:`Py_TPFLAGS_HAVE_GC` flag bit."
msgstr ""
"静的なサブタイプはこのフィールドを継承しますが、動的なサブタイプ (:keyword:"
"`class` 文で生成するサブタイプ) の場合は継承しません; 後者の場合、このフィー"
"ルドには :c:func:`PyType_GenericAlloc` と :const:`Py_TPFLAGS_HAVE_GC` フラグ"
"ビットの値に対応させるのにふさわしいメモリ解放関数がセットされます。"

#: ../../c-api/typeobj.rst:1048
msgid "An optional pointer to a function called by the garbage collector."
msgstr ""
"オプションのフィールドです。ポインタで、ガベージコレクタから呼び出される関数"
"を指します。"

#: ../../c-api/typeobj.rst:1050
msgid ""
"The garbage collector needs to know whether a particular object is "
"collectible or not.  Normally, it is sufficient to look at the object's "
"type's :c:member:`~PyTypeObject.tp_flags` field, and check the :const:"
"`Py_TPFLAGS_HAVE_GC` flag bit.  But some types have a mixture of statically "
"and dynamically allocated instances, and the statically allocated instances "
"are not collectible.  Such types should define this function; it should "
"return ``1`` for a collectible instance, and ``0`` for a non-collectible "
"instance. The signature is ::"
msgstr ""
"ガベージコレクタは、オブジェクトを回収して良いかどうかを知る必要があります。"
"通常は、オブジェクトの型の :c:member:`~PyTypeObject.tp_flags` フィールドを見"
"て、 :const:`Py_TPFLAGS_HAVE_GC` フラグビットを調べるだけで十分です。しかし、"
"ある型では静的にメモリ確保されたインスタンスと動的にメモリ確保されたインスタ"
"ンスが混じっていて、静的にメモリ確保されたインスタンスは回収できません。こう"
"した型では、関数を定義しなければなりません; 関数はインスタンスが回収可能の場"
"合には ``1`` を、回収不能の場合には ``0`` を返さねばなりません。シグネチャ"
"は ::"

#: ../../c-api/typeobj.rst:1060
msgid ""
"(The only example of this are types themselves.  The metatype, :c:data:"
"`PyType_Type`, defines this function to distinguish between statically and "
"dynamically allocated types.)"
msgstr ""
"(上記のような型の例は、型オブジェクト自体です。メタタイプ :c:data:"
"`PyType_Type` は、型のメモリ確保が静的か動的かを区別するためにこの関数を定義"
"しています。)"

#: ../../c-api/typeobj.rst:1064
msgid ""
"This field is inherited by subtypes.  (VERSION NOTE: in Python 2.2, it was "
"not inherited.  It is inherited in 2.2.1 and later versions.)"
msgstr ""
"サブタイプはこのフィールドを継承します。 (VERSION NOTE: Python 2.2 では、この"
"フィールドは継承されませんでした。 2.2.1 以降のバージョンから継承されるように"
"なりました。)"

#: ../../c-api/typeobj.rst:1070
msgid "Tuple of base types."
msgstr "基底型からなるタプルです。"

#: ../../c-api/typeobj.rst:1072
msgid ""
"This is set for types created by a class statement.  It should be *NULL* for "
"statically defined types."
msgstr ""
":keyword:`class` 文で生成されたクラスの場合このフィールドがセットされます。静"
"的に定義されている型の場合には、このフィールドは *NULL* になります。"

#: ../../c-api/typeobj.rst:1075
msgid "This field is not inherited."
msgstr "このフィールドは継承されません。"

#: ../../c-api/typeobj.rst:1080
msgid ""
"Tuple containing the expanded set of base types, starting with the type "
"itself and ending with :class:`object`, in Method Resolution Order."
msgstr ""
"基底タイプ群を展開した集合が入っているタプルです。集合は該当する型自体からは"
"じまり、 :class:`object` で終わります。メソッド解決順序 (Method Resolution "
"Order) に従って並んでいます。"

#: ../../c-api/typeobj.rst:1083
msgid ""
"This field is not inherited; it is calculated fresh by :c:func:"
"`PyType_Ready`."
msgstr ""
"このフィールドは継承されません; フィールドの値は :c:func:`PyType_Ready` で毎"
"回計算されます。"

#: ../../c-api/typeobj.rst:1088
msgid "Unused.  Not inherited.  Internal use only."
msgstr "使用されていません。継承されません。内部で使用するためだけのものです。"

#: ../../c-api/typeobj.rst:1093
msgid ""
"List of weak references to subclasses.  Not inherited.  Internal use only."
msgstr ""
"サブクラスへの弱参照からなるリストです。継承されません。内部で使用するためだ"
"けのものです。"

#: ../../c-api/typeobj.rst:1098
msgid ""
"Weak reference list head, for weak references to this type object.  Not "
"inherited.  Internal use only."
msgstr "この型オブジェクトに対する弱参照からなるリストの先頭です。"

#: ../../c-api/typeobj.rst:1101
msgid ""
"The remaining fields are only defined if the feature test macro :const:"
"`COUNT_ALLOCS` is defined, and are for internal use only. They are "
"documented here for completeness.  None of these fields are inherited by "
"subtypes. See the :envvar:`PYTHONSHOWALLOCCOUNT` environment variable."
msgstr ""

#: ../../c-api/typeobj.rst:1109
msgid "Number of allocations."
msgstr "メモリ確保の回数です。"

#: ../../c-api/typeobj.rst:1114
msgid "Number of frees."
msgstr "メモリ解放の回数です。"

#: ../../c-api/typeobj.rst:1119
msgid "Maximum simultaneously allocated objects."
msgstr "同時にメモリ確保できる最大オブジェクト数です。"

#: ../../c-api/typeobj.rst:1124
msgid ""
"Pointer to the next type object with a non-zero :c:member:`~PyTypeObject."
"tp_allocs` field."
msgstr ""
"次のゼロでない :c:member:`~PyTypeObject.tp_allocs` フィールドを持つ型オブジェ"
"クトへのポインタです。"

#: ../../c-api/typeobj.rst:1126
msgid ""
"Also, note that, in a garbage collected Python, tp_dealloc may be called "
"from any Python thread, not just the thread which created the object (if the "
"object becomes part of a refcount cycle, that cycle might be collected by a "
"garbage collection on any thread).  This is not a problem for Python API "
"calls, since the thread on which tp_dealloc is called will own the Global "
"Interpreter Lock (GIL). However, if the object being destroyed in turn "
"destroys objects from some other C or C++ library, care should be taken to "
"ensure that destroying those objects on the thread which called tp_dealloc "
"will not violate any assumptions of the library."
msgstr ""
"また、 Python のガベージコレクションでは、 *tp_dealloc* を呼び出すのはオブ"
"ジェクトを生成したスレッドだけではなく、任意の Python スレッドかもしれないと"
"いう点にも注意して下さい。 (オブジェクトが循環参照の一部の場合、任意のスレッ"
"ドのガベージコレクションによって解放されてしまうかもしれません)。Python API "
"側からみれば、 *tp_dealloc* を呼び出すスレッドはグローバルインタプリタロック "
"(GIL: Global Interpreter Lock) を獲得するので、これは問題ではありません。しか"
"しながら、削除されようとしているオブジェクトが何らかの C や C++ ライブラリ由"
"来のオブジェクトを削除する場合、 *tp_dealloc* を呼び出すスレッドのオブジェク"
"トを削除することで、ライブラリの仮定している何らかの規約に違反しないように気"
"を付ける必要があります。"

#: ../../c-api/typeobj.rst:1140
msgid "Number Object Structures"
msgstr "数値オブジェクト構造体"

#: ../../c-api/typeobj.rst:1147
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the number protocol.  Almost every function below is used by the "
"function of similar name documented in the :ref:`number` section."
msgstr ""
"拡張型で数値型プロトコルを実装するために使われる関数群へのポインタを保持する"
"ために使われる構造体です。以下のほとんどすべての関数は :ref:`number` で解説さ"
"れている似た名前の関数から利用されます。"

#: ../../c-api/typeobj.rst:1151
msgid "Here is the structure definition::"
msgstr "以下は構造体の定義です::"

#: ../../c-api/typeobj.rst:1202
msgid ""
"Binary and ternary functions may receive different kinds of arguments, "
"depending on the flag bit :const:`Py_TPFLAGS_CHECKTYPES`:"
msgstr ""
"2引数および3引数の関数は、 :const:`Py_TPFLAGS_CHECKTYPES` フラグによっては、"
"異なる種類の引数を受け取るかもしれません。"

#: ../../c-api/typeobj.rst:1205
msgid ""
"If :const:`Py_TPFLAGS_CHECKTYPES` is not set, the function arguments are "
"guaranteed to be of the object's type; the caller is responsible for calling "
"the coercion method specified by the :attr:`nb_coerce` member to convert the "
"arguments:"
msgstr ""
":const:`Py_TPFLAGS_CHECKTYPES` がセットされていない場合、関数の引数はオブジェ"
"クトの型であることが保証されます。呼び出し側は :attr:`nb_coerce` メンバで指定"
"されている型強制メソッドを呼び出して引数を変換する責任があります。"

#: ../../c-api/typeobj.rst:1212
msgid ""
"This function is used by :c:func:`PyNumber_CoerceEx` and has the same "
"signature.  The first argument is always a pointer to an object of the "
"defined type.  If the conversion to a common \"larger\" type is possible, "
"the function replaces the pointers with new references to the converted "
"objects and returns ``0``.  If the conversion is not possible, the function "
"returns ``1``.  If an error condition is set, it will return ``-1``."
msgstr ""
"この関数は :c:func:`PyNumber_CoerceEx` から利用され、同じシグネチャを持ちま"
"す。最初の引数は定義された型のオブジェクトを指すポインタでなければなりませ"
"ん。共通の \"大きな\" 型への変換が可能であれば、この関数はポインタを変換後の"
"オブジェクトへの新しい参照へ置き換えて、 ``0`` を返します。変換ができないな"
"ら、この関数は ``1`` を返します。エラーが設定荒れた場合は、 ``-1`` を返しま"
"す。"

#: ../../c-api/typeobj.rst:1219
msgid ""
"If the :const:`Py_TPFLAGS_CHECKTYPES` flag is set, binary and ternary "
"functions must check the type of all their operands, and implement the "
"necessary conversions (at least one of the operands is an instance of the "
"defined type).  This is the recommended way; with Python 3 coercion will "
"disappear completely."
msgstr ""
":const:`Py_TPFLAGS_CHECKTYPES` フラグがセットされている場合、2引数および 3引"
"数関数はすべてのオペランドの型をチェクし、必要な変換を行わなければなりませ"
"ん。 (少なくとも、オペランドのうち1つは定義している型のものです) これは推奨さ"
"れた方式です。 Python 3 では型強制は完全に取り除かれています。"

#: ../../c-api/typeobj.rst:1225
msgid ""
"If the operation is not defined for the given operands, binary and ternary "
"functions must return ``Py_NotImplemented``, if another error occurred they "
"must return ``NULL`` and set an exception."
msgstr ""
"与えられたオペランドに対して操作が定義されていな場合は、2引数および3引数関数"
"は ``Py_NotImplemented`` を返さなければなりません。その他のエラーが発生した場"
"合は、例外を設定して ``NULL`` を返さなければなりません。"

#: ../../c-api/typeobj.rst:1233
msgid "Mapping Object Structures"
msgstr "マップ型オブジェクト構造体"

#: ../../c-api/typeobj.rst:1240
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the mapping protocol.  It has three members:"
msgstr ""
"拡張型でマップ型プロトコルを実装するために使われる関数群へのポインタを保持す"
"るために使われる構造体です。以下の3つのメンバを持っています:"

#: ../../c-api/typeobj.rst:1245
msgid ""
"This function is used by :c:func:`PyMapping_Length` and :c:func:"
"`PyObject_Size`, and has the same signature.  This slot may be set to *NULL* "
"if the object has no defined length."
msgstr ""
"この関数は :c:func:`PyMapping_Length` や :c:func:`PyObject_Size` から利用さ"
"れ、それらと同じシグネチャを持っています。オブジェクトが定義された長さを持た"
"ない場合は、このスロットは *NULL* に設定されることがあります。"

#: ../../c-api/typeobj.rst:1251
msgid ""
"This function is used by :c:func:`PyObject_GetItem` and has the same "
"signature.  This slot must be filled for the :c:func:`PyMapping_Check` "
"function to return ``1``, it can be *NULL* otherwise."
msgstr ""
"この関数は :c:func:`PyObject_GetItem` から利用され、同じシグネチャを持ってい"
"ます。このスロットは :c:func:`PyMapping_Check` が ``1`` を返すためには必要"
"で、そうでなければ *NULL* の場合があります。"

#: ../../c-api/typeobj.rst:1257
msgid ""
"This function is used by :c:func:`PyObject_SetItem` and :c:func:"
"`PyObject_DelItem`.  It has the same signature as :c:func:"
"`PyObject_SetItem`, but *v* can also be set to *NULL* to delete an item.  If "
"this slot is *NULL*, the object does not support item assignment and "
"deletion."
msgstr ""
"この関数は :c:func:`PyObject_SetItem` および :c:func:`PyObject_DelItem` から"
"利用されます。\n"
":c:func:`PyObject_SetItem` と同じシグネチャを持ちますが、 *v* に *NULL* を設"
"定して要素の削除もできます。このスロットが *NULL* の場合は、このオブジェクト"
"はアイテムの代入と削除をサポートしません。"

#: ../../c-api/typeobj.rst:1267
msgid "Sequence Object Structures"
msgstr "シーケンスオブジェクト構造体"

#: ../../c-api/typeobj.rst:1274
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the sequence protocol."
msgstr ""
"拡張型でシーケンス型プロトコルを実装するために使われる関数群へのポインタを保"
"持するために使われる構造体です。"

#: ../../c-api/typeobj.rst:1279
msgid ""
"This function is used by :c:func:`PySequence_Size` and :c:func:"
"`PyObject_Size`, and has the same signature."
msgstr ""
"この関数は :c:func:`PySequence_Size` や :c:func:`PyObject_Size` から利用さ"
"れ、それらと同じシグネチャを持っています。"

#: ../../c-api/typeobj.rst:1284
msgid ""
"This function is used by :c:func:`PySequence_Concat` and has the same "
"signature.  It is also used by the ``+`` operator, after trying the numeric "
"addition via the :c:member:`~PyTypeObject.tp_as_number.nb_add` slot."
msgstr ""
"この関数は :c:func:`PySequence_Concat` で利用され、同じシグネチャを持っていま"
"す。また、 ``+`` 演算子でも、 :c:member:`~PyTypeObject.tp_as_number.nb_add` "
"スロットによる数値加算を試した後に利用されます。"

#: ../../c-api/typeobj.rst:1290
msgid ""
"This function is used by :c:func:`PySequence_Repeat` and has the same "
"signature.  It is also used by the ``*`` operator, after trying numeric "
"multiplication via the :c:member:`~PyTypeObject.tp_as_number.nb_multiply` "
"slot."
msgstr ""
"この関数は :c:func:`PySequence_Repeat` で利用され、同じシグネチャを持っていま"
"す。また、 ``*`` 演算でも、 :c:member:`~PyTypeObject.tp_as_number."
"nb_multiply` スロットによる数値乗算を試したあとに利用されます。"

#: ../../c-api/typeobj.rst:1297
msgid ""
"This function is used by :c:func:`PySequence_GetItem` and has the same "
"signature.  This slot must be filled for the :c:func:`PySequence_Check` "
"function to return ``1``, it can be *NULL* otherwise."
msgstr ""
"この関数は :c:func:`PySequence_GetItem` から利用され、同じシグネチャを持って"
"います。このスロットは :c:func:`PySequence_Check` が ``1`` を返すためには埋め"
"なければならず、それ以外の場合は *NULL* の可能性があります。"

#: ../../c-api/typeobj.rst:1301
msgid ""
"Negative indexes are handled as follows: if the :attr:`sq_length` slot is "
"filled, it is called and the sequence length is used to compute a positive "
"index which is passed to :attr:`sq_item`.  If :attr:`sq_length` is *NULL*, "
"the index is passed as is to the function."
msgstr ""
"負のインデックスは次のように処理されます: :attr:`sq_length` スロットが埋めら"
"れていれば、それを呼び出してシーケンスの長さから正のインデックスを計算し、 :"
"attr:`sq_item` に渡します。 :attr:`sq_length` が *NULL* の場合は、インデック"
"スはそのままこの関数に渡されます。"

#: ../../c-api/typeobj.rst:1308
msgid ""
"This function is used by :c:func:`PySequence_SetItem` and has the same "
"signature.  This slot may be left to *NULL* if the object does not support "
"item assignment and deletion."
msgstr ""
"この関数は :c:func:`PySequence_SetItem` から利用され、同じシグネチャを持って"
"います。\n"
"オブジェクトが要素の代入と削除をサポートしていない場合は、このスロットは "
"*NULL* かもしれません。"

#: ../../c-api/typeobj.rst:1314
msgid ""
"This function may be used by :c:func:`PySequence_Contains` and has the same "
"signature.  This slot may be left to *NULL*, in this case :c:func:"
"`PySequence_Contains` simply traverses the sequence until it finds a match."
msgstr ""
"この関数は :c:func:`PySequence_Contains` から利用され、同じシグネチャを持って"
"います。このスロットは *NULL* の場合があり、その時 :c:func:"
"`PySequence_Contains` はシンプルにマッチするオブジェクトを見つけるまでシーケ"
"ンスを巡回します。"

#: ../../c-api/typeobj.rst:1321
msgid ""
"This function is used by :c:func:`PySequence_InPlaceConcat` and has the same "
"signature.  It should modify its first operand, and return it."
msgstr ""
"この関数は :c:func:`PySequence_InPlaceConcat` から利用され、同じシグネチャを"
"持っています。この関数は最初のオペランドを修正してそれを返すべきです。"

#: ../../c-api/typeobj.rst:1326
msgid ""
"This function is used by :c:func:`PySequence_InPlaceRepeat` and has the same "
"signature.  It should modify its first operand, and return it."
msgstr ""
"この関数は :c:func:`PySequence_InPlaceRepeat` から利用され、同じシグネチャを"
"持っています。この関数は最初のオペランドを修正してそれを返すべきです。"

#: ../../c-api/typeobj.rst:1336
msgid "Buffer Object Structures"
msgstr "バッファオブジェクト構造体 (buffer object structure)"

#: ../../c-api/typeobj.rst:1341
msgid ""
"The buffer interface exports a model where an object can expose its internal "
"data as a set of chunks of data, where each chunk is specified as a pointer/"
"length pair.  These chunks are called :dfn:`segments` and are presumed to be "
"non-contiguous in memory."
msgstr ""
"バッファインタフェースは、あるオブジェクトの内部データを一連のデータチャンク "
"(chunk) として見せるモデルを外部から利用できるようにします。各チャンクはポイ"
"ンタ/データ長からなるペアで指定します。チャンクはセグメント(:dfn:`segment`) "
"と呼ばれ、メモリ内に不連続的に配置されるものと想定されています。"

#: ../../c-api/typeobj.rst:1346
msgid ""
"If an object does not export the buffer interface, then its :c:member:"
"`~PyTypeObject.tp_as_buffer` member in the :c:type:`PyTypeObject` structure "
"should be *NULL*.  Otherwise, the :c:member:`~PyTypeObject.tp_as_buffer` "
"will point to a :c:type:`PyBufferProcs` structure."
msgstr ""
"バッファインタフェースを利用できるようにしたくないオブジェクトでは、 :c:type:"
"`PyTypeObject` 構造体の :c:member:`~PyTypeObject.tp_as_buffer` メンバを "
"*NULL* にしなくてはなりません。利用できるようにする場合、 :c:member:"
"`~PyTypeObject.tp_as_buffer` は :c:type:`PyBufferProcs` 構造体を指さねばなり"
"ません。"

#: ../../c-api/typeobj.rst:1352
msgid ""
"It is very important that your :c:type:`PyTypeObject` structure uses :const:"
"`Py_TPFLAGS_DEFAULT` for the value of the :c:member:`~PyTypeObject.tp_flags` "
"member rather than ``0``.  This tells the Python runtime that your :c:type:"
"`PyBufferProcs` structure contains the :attr:`bf_getcharbuffer` slot. Older "
"versions of Python did not have this member, so a new Python interpreter "
"using an old extension needs to be able to test for its presence before "
"using it."
msgstr ""
":c:type:`PyTypeObject` 構造体の :c:member:`~PyTypeObject.tp_flags` メンバの値"
"を ``0`` でなく :const:`Py_TPFLAGS_DEFAULT` にしておくことがとても重要です。"
"この設定は、 :c:type:`PyBufferProcs` 構造体に :attr:`bf_getcharbuffer` スロッ"
"トが入っていることを Python ランタイムに教えます。 Python の古いバージョンに"
"は :attr:`bf_getcharbuffer` メンバが存在しないので、古い拡張モジュールを使お"
"うとしている新しいバージョンの Python インタプリタは、このメンバがあるかどう"
"かテストしてから使えるようにする必要があるのです。"

#: ../../c-api/typeobj.rst:1362
msgid ""
"Structure used to hold the function pointers which define an implementation "
"of the buffer protocol."
msgstr ""
"バッファプロトコルの実装を定義している関数群へのポインタを保持するのに使われ"
"る構造体です。"

#: ../../c-api/typeobj.rst:1365
msgid ""
"The first slot is :attr:`bf_getreadbuffer`, of type :c:type:"
"`readbufferproc`. If this slot is *NULL*, then the object does not support "
"reading from the internal data.  This is non-sensical, so implementors "
"should fill this in, but callers should test that the slot contains a non-"
"*NULL* value."
msgstr ""

#: ../../c-api/typeobj.rst:1370
msgid ""
"The next slot is :attr:`bf_getwritebuffer` having type :c:type:"
"`writebufferproc`.  This slot may be *NULL* if the object does not allow "
"writing into its returned buffers."
msgstr ""

#: ../../c-api/typeobj.rst:1374
msgid ""
"The third slot is :attr:`bf_getsegcount`, with type :c:type:`segcountproc`. "
"This slot must not be *NULL* and is used to inform the caller how many "
"segments the object contains.  Simple objects such as :c:type:"
"`PyString_Type` and :c:type:`PyBuffer_Type` objects contain a single segment."
msgstr ""

#: ../../c-api/typeobj.rst:1381
msgid ""
"The last slot is :attr:`bf_getcharbuffer`, of type :c:type:`charbufferproc`. "
"This slot will only be present if the :const:`Py_TPFLAGS_HAVE_GETCHARBUFFER` "
"flag is present in the :c:member:`~PyTypeObject.tp_flags` field of the "
"object's :c:type:`PyTypeObject`. Before using this slot, the caller should "
"test whether it is present by using the :c:func:`PyType_HasFeature` "
"function.  If the flag is present, :attr:`bf_getcharbuffer` may be *NULL*, "
"indicating that the object's contents cannot be used as *8-bit characters*. "
"The slot function may also raise an error if the object's contents cannot be "
"interpreted as 8-bit characters. For example, if the object is an array "
"which is configured to hold floating point values, an exception may be "
"raised if a caller attempts to use :attr:`bf_getcharbuffer` to fetch a "
"sequence of 8-bit characters. This notion of exporting the internal buffers "
"as \"text\" is used to distinguish between objects that are binary in "
"nature, and those which have character-based content."
msgstr ""

#: ../../c-api/typeobj.rst:1397
msgid ""
"The current policy seems to state that these characters may be multi-byte "
"characters. This implies that a buffer size of *N* does not mean there are "
"*N* characters present."
msgstr ""
"現在のポリシでは、文字 (character) はマルチバイト文字でもかまわないと決めてい"
"るように思われます。従って、サイズ *N* のバッファが *N* 個のキャラクタからな"
"るとはかぎらないことになります。"

#: ../../c-api/typeobj.rst:1404
msgid ""
"Flag bit set in the type structure to indicate that the :attr:"
"`bf_getcharbuffer` slot is known.  This being set does not indicate that the "
"object supports the buffer interface or that the :attr:`bf_getcharbuffer` "
"slot is non-*NULL*."
msgstr ""
"型構造体中のフラグビットで、 :attr:`bf_getcharbuffer` スロットが既知の値に"
"なっていることを示します。このフラグビットがセットされていたとしても、オブ"
"ジェクトがバッファインタフェースをサポートしていることや、 :attr:"
"`bf_getcharbuffer` スロットが *NULL* でないことを示すわけではありません。"

#: ../../c-api/typeobj.rst:1411
msgid ""
"Return a pointer to a readable segment of the buffer in ``*ptrptr``.  This "
"function is allowed to raise an exception, in which case it must return "
"``-1``. The *segment* which is specified must be zero or positive, and "
"strictly less than the number of segments returned by the :attr:"
"`bf_getsegcount` slot function.  On success, it returns the length of the "
"segment, and sets ``*ptrptr`` to a pointer to that memory."
msgstr ""
"``*ptrptr`` の中の読み出し可能なバッファセグメントへのポインタを返します。こ"
"の関数は例外を送出してもよく、送出する場合には ``-1`` を返さねばなりません。 "
"*segment* に渡す値はゼロまたは正の値で、 :attr:`bf_getsegcount` スロット関数"
"が返すセグメント数よりも必ず小さな値でなければなりません。成功すると、セグメ"
"ントのサイズを返し、 ``*ptrptr`` をそのセグメントを指すポインタ値にセットしま"
"す。"

#: ../../c-api/typeobj.rst:1421
msgid ""
"Return a pointer to a writable memory buffer in ``*ptrptr``, and the length "
"of that segment as the function return value.  The memory buffer must "
"correspond to buffer segment *segment*.  Must return ``-1`` and set an "
"exception on error. :exc:`TypeError` should be raised if the object only "
"supports read-only buffers, and :exc:`SystemError` should be raised when "
"*segment* specifies a segment that doesn't exist."
msgstr ""
"読み出し可能なバッファセグメントへのポインタを ``*ptrptr`` に返し、セグメント"
"の長さを関数の戻り値として返します。エラーによる例外の場合には ``-1`` を "
"``-1`` を返さねばなりません。オブジェクトが呼び出し専用バッファしかサポートし"
"ていない場合には :exc:`TypeError` を、 *segment* が存在しないセグメントを指し"
"ている場合には :exc:`SystemError` を送出しなければなりません。"

#: ../../c-api/typeobj.rst:1435
msgid ""
"Return the number of memory segments which comprise the buffer.  If *lenp* "
"is not *NULL*, the implementation must report the sum of the sizes (in "
"bytes) of all segments in ``*lenp``. The function cannot fail."
msgstr ""
"バッファを構成するメモリセグメントの数を返します。 *lenp* が *NULL* でない場"
"合、この関数の実装は全てのセグメントのサイズ (バイト単位) の合計値を "
"``*lenp`` を介して報告しなければなりません。この関数呼び出しは失敗させられま"
"せん。"

#: ../../c-api/typeobj.rst:1442
msgid ""
"Return the size of the segment *segment* that *ptrptr*  is set to.  "
"``*ptrptr`` is set to the memory buffer. Returns ``-1`` on error."
msgstr ""
"セグメント *segment* のメモリバッファを *ptrptr* に入れ、そのサイズを返しま"
"す。エラーのときに ``-1`` を返します。"
