# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# tomo, 2020
# Osamu NAKAMURA, 2021
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 16:06+0000\n"
"PO-Revision-Date: 2020-05-30 11:51+0000\n"
"Last-Translator: Osamu NAKAMURA, 2021\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/typeobj.rst:6
msgid "Type Objects"
msgstr "型オブジェクト"

#: ../../c-api/typeobj.rst:8
msgid ""
"Perhaps one of the most important structures of the Python object system is "
"the structure that defines a new type: the :c:type:`PyTypeObject` "
"structure.  Type objects can be handled using any of the :c:func:"
"`PyObject_\\*` or :c:func:`PyType_\\*` functions, but do not offer much "
"that's interesting to most Python applications. These objects are "
"fundamental to how objects behave, so they are very important to the "
"interpreter itself and to any extension module that implements new types."
msgstr ""
"新スタイルの型を定義する構造体: :c:type:`PyTypeObject` 構造体は、おそらく "
"Python オブジェクトシステムの中で最も重要な構造体の1つでしょう。型オブジェク"
"トは :c:func:`PyObject_\\*` 系や :c:func:`PyType_\\*` 系の関数で扱えますが、"
"ほとんどの Python アプリケーションにとって、さして面白みのある機能を提供しま"
"せん。型オブジェクトはオブジェクトがどのように振舞うかを決める基盤ですから、"
"インタプリタ自体や新たな型を定義する拡張モジュールでは非常に重要な存在です。"

#: ../../c-api/typeobj.rst:16
msgid ""
"Type objects are fairly large compared to most of the standard types. The "
"reason for the size is that each type object stores a large number of "
"values, mostly C function pointers, each of which implements a small part of "
"the type's functionality.  The fields of the type object are examined in "
"detail in this section.  The fields will be described in the order in which "
"they occur in the structure."
msgstr ""
"型オブジェクトは標準の型 (standard type) に比べるとかなり大きな構造体です。各"
"型オブジェクトは多くの値を保持しており、そのほとんどは C 関数へのポインタで、"
"それぞれの関数はその型の機能の小さい部分を実装しています。この節では、型オブ"
"ジェクトの各フィールドについて詳細を説明します。各フィールドは、構造体内で出"
"現する順番に説明されています。"

#: ../../c-api/typeobj.rst:23
msgid ""
"In addition to the following quick reference, the :ref:`typedef-examples` "
"section provides at-a-glance insight into the meaning and use of :c:type:"
"`PyTypeObject`."
msgstr ""
"以下のクイックリファレンスに加えて、 :ref:`typedef-examples` 節では :c:type:"
"`PyTypeObject` の意味と使い方を一目で理解できる例を載せています。"

#: ../../c-api/typeobj.rst:29
msgid "Quick Reference"
msgstr "クイックリファレンス"

#: ../../c-api/typeobj.rst:34
msgid "\"tp slots\""
msgstr "\"tp slots\""

#: ../../c-api/typeobj.rst:40
msgid "PyTypeObject Slot [#slots]_"
msgstr "PyTypeObject Slot [#slots]_"

#: ../../c-api/typeobj.rst:40 ../../c-api/typeobj.rst:200
msgid ":ref:`Type <slot-typedefs-table>`"
msgstr ":ref:`型 <slot-typedefs-table>`"

#: ../../c-api/typeobj.rst:40
msgid "special methods/attrs"
msgstr "特殊メソッド/特殊属性"

#: ../../c-api/typeobj.rst:40
msgid "Info [#cols]_"
msgstr "Info [#cols]_"

#: ../../c-api/typeobj.rst:42
msgid "O"
msgstr "O"

#: ../../c-api/typeobj.rst:42
msgid "T"
msgstr "T"

#: ../../c-api/typeobj.rst:42
msgid "D"
msgstr "D"

#: ../../c-api/typeobj.rst:42
msgid "I"
msgstr "I"

#: ../../c-api/typeobj.rst:44
msgid "<R> :c:member:`~PyTypeObject.tp_name`"
msgstr "<R> :c:member:`~PyTypeObject.tp_name`"

#: ../../c-api/typeobj.rst:44 ../../c-api/typeobj.rst:86
#: ../../c-api/typeobj.rst:0
msgid "const char *"
msgstr "const char *"

#: ../../c-api/typeobj.rst:44
msgid "__name__"
msgstr "__name__"

#: ../../c-api/typeobj.rst:44 ../../c-api/typeobj.rst:46
#: ../../c-api/typeobj.rst:48 ../../c-api/typeobj.rst:50
#: ../../c-api/typeobj.rst:62 ../../c-api/typeobj.rst:70
#: ../../c-api/typeobj.rst:72 ../../c-api/typeobj.rst:74
#: ../../c-api/typeobj.rst:76 ../../c-api/typeobj.rst:79
#: ../../c-api/typeobj.rst:84 ../../c-api/typeobj.rst:86
#: ../../c-api/typeobj.rst:88 ../../c-api/typeobj.rst:90
#: ../../c-api/typeobj.rst:92 ../../c-api/typeobj.rst:99
#: ../../c-api/typeobj.rst:101 ../../c-api/typeobj.rst:103
#: ../../c-api/typeobj.rst:105 ../../c-api/typeobj.rst:107
#: ../../c-api/typeobj.rst:109 ../../c-api/typeobj.rst:111
#: ../../c-api/typeobj.rst:115 ../../c-api/typeobj.rst:117
#: ../../c-api/typeobj.rst:120 ../../c-api/typeobj.rst:122
#: ../../c-api/typeobj.rst:124 ../../c-api/typeobj.rst:126
#: ../../c-api/typeobj.rst:128 ../../c-api/typeobj.rst:130
#: ../../c-api/typeobj.rst:146
msgid "X"
msgstr "X"

#: ../../c-api/typeobj.rst:46
msgid ":c:member:`~PyTypeObject.tp_basicsize`"
msgstr ":c:member:`~PyTypeObject.tp_basicsize`"

#: ../../c-api/typeobj.rst:46 ../../c-api/typeobj.rst:48
#: ../../c-api/typeobj.rst:52 ../../c-api/typeobj.rst:99
#: ../../c-api/typeobj.rst:120 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:413
msgid "Py_ssize_t"
msgstr "Py_ssize_t"

#: ../../c-api/typeobj.rst:48
msgid ":c:member:`~PyTypeObject.tp_itemsize`"
msgstr ":c:member:`~PyTypeObject.tp_itemsize`"

#: ../../c-api/typeobj.rst:50
msgid ":c:member:`~PyTypeObject.tp_dealloc`"
msgstr ":c:member:`~PyTypeObject.tp_dealloc`"

#: ../../c-api/typeobj.rst:50 ../../c-api/typeobj.rst:142
#: ../../c-api/typeobj.rst:146 ../../c-api/typeobj.rst:343
msgid ":c:type:`destructor`"
msgstr ":c:type:`destructor`"

#: ../../c-api/typeobj.rst:52
msgid ":c:member:`~PyTypeObject.tp_vectorcall_offset`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall_offset`"

#: ../../c-api/typeobj.rst:52 ../../c-api/typeobj.rst:84
#: ../../c-api/typeobj.rst:99 ../../c-api/typeobj.rst:113
#: ../../c-api/typeobj.rst:120 ../../c-api/typeobj.rst:124
#: ../../c-api/typeobj.rst:126 ../../c-api/typeobj.rst:128
msgid "?"
msgstr "?"

#: ../../c-api/typeobj.rst:54
msgid "(:c:member:`~PyTypeObject.tp_getattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_getattr`)"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:367
msgid ":c:type:`getattrfunc`"
msgstr ":c:type:`getattrfunc`"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:76
msgid "__getattribute__, __getattr__"
msgstr "__getattribute__, __getattr__"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:57
#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:88
#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:92
msgid "G"
msgstr "G"

#: ../../c-api/typeobj.rst:57
msgid "(:c:member:`~PyTypeObject.tp_setattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_setattr`)"

#: ../../c-api/typeobj.rst:57 ../../c-api/typeobj.rst:372
msgid ":c:type:`setattrfunc`"
msgstr ":c:type:`setattrfunc`"

#: ../../c-api/typeobj.rst:57 ../../c-api/typeobj.rst:79
msgid "__setattr__, __delattr__"
msgstr "__setattr__, __delattr__"

#: ../../c-api/typeobj.rst:60
msgid ":c:member:`~PyTypeObject.tp_as_async`"
msgstr ":c:member:`~PyTypeObject.tp_as_async`"

#: ../../c-api/typeobj.rst:60
msgid ":c:type:`PyAsyncMethods` *"
msgstr ":c:type:`PyAsyncMethods` *"

#: ../../c-api/typeobj.rst:60 ../../c-api/typeobj.rst:64
#: ../../c-api/typeobj.rst:66 ../../c-api/typeobj.rst:68
msgid ":ref:`sub-slots`"
msgstr ":ref:`sub-slots`"

#: ../../c-api/typeobj.rst:60 ../../c-api/typeobj.rst:64
#: ../../c-api/typeobj.rst:66 ../../c-api/typeobj.rst:68
#: ../../c-api/typeobj.rst:82
msgid "%"
msgstr "%"

#: ../../c-api/typeobj.rst:62
msgid ":c:member:`~PyTypeObject.tp_repr`"
msgstr ":c:member:`~PyTypeObject.tp_repr`"

#: ../../c-api/typeobj.rst:62 ../../c-api/typeobj.rst:74
#: ../../c-api/typeobj.rst:365
msgid ":c:type:`reprfunc`"
msgstr ":c:type:`reprfunc`"

#: ../../c-api/typeobj.rst:62
msgid "__repr__"
msgstr "__repr__"

#: ../../c-api/typeobj.rst:64
msgid ":c:member:`~PyTypeObject.tp_as_number`"
msgstr ":c:member:`~PyTypeObject.tp_as_number`"

#: ../../c-api/typeobj.rst:64
msgid ":c:type:`PyNumberMethods` *"
msgstr ":c:type:`PyNumberMethods` *"

#: ../../c-api/typeobj.rst:66
msgid ":c:member:`~PyTypeObject.tp_as_sequence`"
msgstr ":c:member:`~PyTypeObject.tp_as_sequence`"

#: ../../c-api/typeobj.rst:66
msgid ":c:type:`PySequenceMethods` *"
msgstr ":c:type:`PySequenceMethods` *"

#: ../../c-api/typeobj.rst:68
msgid ":c:member:`~PyTypeObject.tp_as_mapping`"
msgstr ":c:member:`~PyTypeObject.tp_as_mapping`"

#: ../../c-api/typeobj.rst:68
msgid ":c:type:`PyMappingMethods` *"
msgstr ":c:type:`PyMappingMethods` *"

#: ../../c-api/typeobj.rst:70
msgid ":c:member:`~PyTypeObject.tp_hash`"
msgstr ":c:member:`~PyTypeObject.tp_hash`"

#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:401
msgid ":c:type:`hashfunc`"
msgstr ":c:type:`hashfunc`"

#: ../../c-api/typeobj.rst:70
msgid "__hash__"
msgstr "__hash__"

#: ../../c-api/typeobj.rst:72
msgid ":c:member:`~PyTypeObject.tp_call`"
msgstr ":c:member:`~PyTypeObject.tp_call`"

#: ../../c-api/typeobj.rst:72 ../../c-api/typeobj.rst:234
#: ../../c-api/typeobj.rst:237 ../../c-api/typeobj.rst:437
msgid ":c:type:`ternaryfunc`"
msgstr ":c:type:`ternaryfunc`"

#: ../../c-api/typeobj.rst:72
msgid "__call__"
msgstr "__call__"

#: ../../c-api/typeobj.rst:74
msgid ":c:member:`~PyTypeObject.tp_str`"
msgstr ":c:member:`~PyTypeObject.tp_str`"

#: ../../c-api/typeobj.rst:74
msgid "__str__"
msgstr "__str__"

#: ../../c-api/typeobj.rst:76
msgid ":c:member:`~PyTypeObject.tp_getattro`"
msgstr ":c:member:`~PyTypeObject.tp_getattro`"

#: ../../c-api/typeobj.rst:76 ../../c-api/typeobj.rst:378
msgid ":c:type:`getattrofunc`"
msgstr ":c:type:`getattrofunc`"

#: ../../c-api/typeobj.rst:79
msgid ":c:member:`~PyTypeObject.tp_setattro`"
msgstr ":c:member:`~PyTypeObject.tp_setattro`"

#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:383
msgid ":c:type:`setattrofunc`"
msgstr ":c:type:`setattrofunc`"

#: ../../c-api/typeobj.rst:82
msgid ":c:member:`~PyTypeObject.tp_as_buffer`"
msgstr ":c:member:`~PyTypeObject.tp_as_buffer`"

#: ../../c-api/typeobj.rst:82
msgid ":c:type:`PyBufferProcs` *"
msgstr ":c:type:`PyBufferProcs` *"

#: ../../c-api/typeobj.rst:84
msgid ":c:member:`~PyTypeObject.tp_flags`"
msgstr ":c:member:`~PyTypeObject.tp_flags`"

#: ../../c-api/typeobj.rst:84
msgid "unsigned long"
msgstr "unsigned long"

#: ../../c-api/typeobj.rst:86
msgid ":c:member:`~PyTypeObject.tp_doc`"
msgstr ":c:member:`~PyTypeObject.tp_doc`"

#: ../../c-api/typeobj.rst:86
msgid "__doc__"
msgstr "__doc__"

#: ../../c-api/typeobj.rst:88
msgid ":c:member:`~PyTypeObject.tp_traverse`"
msgstr ":c:member:`~PyTypeObject.tp_traverse`"

#: ../../c-api/typeobj.rst:88 ../../c-api/typeobj.rst:347
msgid ":c:type:`traverseproc`"
msgstr ":c:type:`traverseproc`"

#: ../../c-api/typeobj.rst:90
msgid ":c:member:`~PyTypeObject.tp_clear`"
msgstr ":c:member:`~PyTypeObject.tp_clear`"

#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:130
#: ../../c-api/typeobj.rst:245 ../../c-api/typeobj.rst:426
msgid ":c:type:`inquiry`"
msgstr ":c:type:`inquiry`"

#: ../../c-api/typeobj.rst:92
msgid ":c:member:`~PyTypeObject.tp_richcompare`"
msgstr ":c:member:`~PyTypeObject.tp_richcompare`"

#: ../../c-api/typeobj.rst:92 ../../c-api/typeobj.rst:403
msgid ":c:type:`richcmpfunc`"
msgstr ":c:type:`richcmpfunc`"

#: ../../c-api/typeobj.rst:92
msgid "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"
msgstr "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"

#: ../../c-api/typeobj.rst:99
msgid ":c:member:`~PyTypeObject.tp_weaklistoffset`"
msgstr ":c:member:`~PyTypeObject.tp_weaklistoffset`"

#: ../../c-api/typeobj.rst:101
msgid ":c:member:`~PyTypeObject.tp_iter`"
msgstr ":c:member:`~PyTypeObject.tp_iter`"

#: ../../c-api/typeobj.rst:101 ../../c-api/typeobj.rst:409
msgid ":c:type:`getiterfunc`"
msgstr ":c:type:`getiterfunc`"

#: ../../c-api/typeobj.rst:101
msgid "__iter__"
msgstr "__iter__"

#: ../../c-api/typeobj.rst:103
msgid ":c:member:`~PyTypeObject.tp_iternext`"
msgstr ":c:member:`~PyTypeObject.tp_iternext`"

#: ../../c-api/typeobj.rst:103 ../../c-api/typeobj.rst:411
msgid ":c:type:`iternextfunc`"
msgstr ":c:type:`iternextfunc`"

#: ../../c-api/typeobj.rst:103
msgid "__next__"
msgstr "__next__"

#: ../../c-api/typeobj.rst:105
msgid ":c:member:`~PyTypeObject.tp_methods`"
msgstr ":c:member:`~PyTypeObject.tp_methods`"

#: ../../c-api/typeobj.rst:105
msgid ":c:type:`PyMethodDef` []"
msgstr ":c:type:`PyMethodDef` []"

#: ../../c-api/typeobj.rst:107
msgid ":c:member:`~PyTypeObject.tp_members`"
msgstr ":c:member:`~PyTypeObject.tp_members`"

#: ../../c-api/typeobj.rst:107
msgid ":c:type:`PyMemberDef` []"
msgstr ":c:type:`PyMemberDef` []"

#: ../../c-api/typeobj.rst:109
msgid ":c:member:`~PyTypeObject.tp_getset`"
msgstr ":c:member:`~PyTypeObject.tp_getset`"

#: ../../c-api/typeobj.rst:109
msgid ":c:type:`PyGetSetDef` []"
msgstr ":c:type:`PyGetSetDef` []"

#: ../../c-api/typeobj.rst:111
msgid ":c:member:`~PyTypeObject.tp_base`"
msgstr ":c:member:`~PyTypeObject.tp_base`"

#: ../../c-api/typeobj.rst:111 ../../c-api/typeobj.rst:0
msgid ":c:type:`PyTypeObject` *"
msgstr ":c:type:`PyTypeObject` *"

#: ../../c-api/typeobj.rst:111
msgid "__base__"
msgstr "__base__"

#: ../../c-api/typeobj.rst:113
msgid ":c:member:`~PyTypeObject.tp_dict`"
msgstr ":c:member:`~PyTypeObject.tp_dict`"

#: ../../c-api/typeobj.rst:113 ../../c-api/typeobj.rst:132
#: ../../c-api/typeobj.rst:134 ../../c-api/typeobj.rst:136
#: ../../c-api/typeobj.rst:138 ../../c-api/typeobj.rst:140
#: ../../c-api/typeobj.rst:338 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:353 ../../c-api/typeobj.rst:365
#: ../../c-api/typeobj.rst:367 ../../c-api/typeobj.rst:378
#: ../../c-api/typeobj.rst:389 ../../c-api/typeobj.rst:401
#: ../../c-api/typeobj.rst:403 ../../c-api/typeobj.rst:409
#: ../../c-api/typeobj.rst:411 ../../c-api/typeobj.rst:413
#: ../../c-api/typeobj.rst:428 ../../c-api/typeobj.rst:432
#: ../../c-api/typeobj.rst:437 ../../c-api/typeobj.rst:443
msgid ":c:type:`PyObject` *"
msgstr ":c:type:`PyObject` *"

#: ../../c-api/typeobj.rst:113
msgid "__dict__"
msgstr "__dict__"

#: ../../c-api/typeobj.rst:115
msgid ":c:member:`~PyTypeObject.tp_descr_get`"
msgstr ":c:member:`~PyTypeObject.tp_descr_get`"

#: ../../c-api/typeobj.rst:115 ../../c-api/typeobj.rst:389
msgid ":c:type:`descrgetfunc`"
msgstr ":c:type:`descrgetfunc`"

#: ../../c-api/typeobj.rst:115
msgid "__get__"
msgstr "__get__"

#: ../../c-api/typeobj.rst:117
msgid ":c:member:`~PyTypeObject.tp_descr_set`"
msgstr ":c:member:`~PyTypeObject.tp_descr_set`"

#: ../../c-api/typeobj.rst:117 ../../c-api/typeobj.rst:395
msgid ":c:type:`descrsetfunc`"
msgstr ":c:type:`descrsetfunc`"

#: ../../c-api/typeobj.rst:117
msgid "__set__, __delete__"
msgstr "__set__, __delete__"

#: ../../c-api/typeobj.rst:120
msgid ":c:member:`~PyTypeObject.tp_dictoffset`"
msgstr ":c:member:`~PyTypeObject.tp_dictoffset`"

#: ../../c-api/typeobj.rst:122
msgid ":c:member:`~PyTypeObject.tp_init`"
msgstr ":c:member:`~PyTypeObject.tp_init`"

#: ../../c-api/typeobj.rst:122 ../../c-api/typeobj.rst:359
msgid ":c:type:`initproc`"
msgstr ":c:type:`initproc`"

#: ../../c-api/typeobj.rst:122
msgid "__init__"
msgstr "__init__"

#: ../../c-api/typeobj.rst:124
msgid ":c:member:`~PyTypeObject.tp_alloc`"
msgstr ":c:member:`~PyTypeObject.tp_alloc`"

#: ../../c-api/typeobj.rst:124 ../../c-api/typeobj.rst:338
msgid ":c:type:`allocfunc`"
msgstr ":c:type:`allocfunc`"

#: ../../c-api/typeobj.rst:126
msgid ":c:member:`~PyTypeObject.tp_new`"
msgstr ":c:member:`~PyTypeObject.tp_new`"

#: ../../c-api/typeobj.rst:126 ../../c-api/typeobj.rst:353
msgid ":c:type:`newfunc`"
msgstr ":c:type:`newfunc`"

#: ../../c-api/typeobj.rst:126
msgid "__new__"
msgstr "__new__"

#: ../../c-api/typeobj.rst:128
msgid ":c:member:`~PyTypeObject.tp_free`"
msgstr ":c:member:`~PyTypeObject.tp_free`"

#: ../../c-api/typeobj.rst:128 ../../c-api/typeobj.rst:345
msgid ":c:type:`freefunc`"
msgstr ":c:type:`freefunc`"

#: ../../c-api/typeobj.rst:130
msgid ":c:member:`~PyTypeObject.tp_is_gc`"
msgstr ":c:member:`~PyTypeObject.tp_is_gc`"

#: ../../c-api/typeobj.rst:132
msgid "<:c:member:`~PyTypeObject.tp_bases`>"
msgstr "<:c:member:`~PyTypeObject.tp_bases`>"

#: ../../c-api/typeobj.rst:132
msgid "__bases__"
msgstr "__bases__"

#: ../../c-api/typeobj.rst:132 ../../c-api/typeobj.rst:134
msgid "~"
msgstr "~"

#: ../../c-api/typeobj.rst:134
msgid "<:c:member:`~PyTypeObject.tp_mro`>"
msgstr "<:c:member:`~PyTypeObject.tp_mro`>"

#: ../../c-api/typeobj.rst:134
msgid "__mro__"
msgstr "__mro__"

#: ../../c-api/typeobj.rst:136
msgid "[:c:member:`~PyTypeObject.tp_cache`]"
msgstr "[:c:member:`~PyTypeObject.tp_cache`]"

#: ../../c-api/typeobj.rst:138
msgid "[:c:member:`~PyTypeObject.tp_subclasses`]"
msgstr "[:c:member:`~PyTypeObject.tp_subclasses`]"

#: ../../c-api/typeobj.rst:138
msgid "__subclasses__"
msgstr "__subclasses__"

#: ../../c-api/typeobj.rst:140
msgid "[:c:member:`~PyTypeObject.tp_weaklist`]"
msgstr "[:c:member:`~PyTypeObject.tp_weaklist`]"

#: ../../c-api/typeobj.rst:142
msgid "(:c:member:`~PyTypeObject.tp_del`)"
msgstr "(:c:member:`~PyTypeObject.tp_del`)"

#: ../../c-api/typeobj.rst:144
msgid "[:c:member:`~PyTypeObject.tp_version_tag`]"
msgstr "[:c:member:`~PyTypeObject.tp_version_tag`]"

#: ../../c-api/typeobj.rst:144
msgid "unsigned int"
msgstr "unsigned int"

#: ../../c-api/typeobj.rst:146
msgid ":c:member:`~PyTypeObject.tp_finalize`"
msgstr ":c:member:`~PyTypeObject.tp_finalize`"

#: ../../c-api/typeobj.rst:146
msgid "__del__"
msgstr "__del__"

#: ../../c-api/typeobj.rst:149
msgid ""
"If :const:`COUNT_ALLOCS` is defined then the following (internal-only) "
"fields exist as well:"
msgstr ""
":const:`COUNT_ALLOCS` が定義されている場合、次の (内部専用) フィールドも使え"
"ます::"

#: ../../c-api/typeobj.rst:152
msgid ":c:member:`~PyTypeObject.tp_allocs`"
msgstr ":c:member:`~PyTypeObject.tp_allocs`"

#: ../../c-api/typeobj.rst:153
msgid ":c:member:`~PyTypeObject.tp_frees`"
msgstr ":c:member:`~PyTypeObject.tp_frees`"

#: ../../c-api/typeobj.rst:154
msgid ":c:member:`~PyTypeObject.tp_maxalloc`"
msgstr ":c:member:`~PyTypeObject.tp_maxalloc`"

#: ../../c-api/typeobj.rst:155
msgid ":c:member:`~PyTypeObject.tp_prev`"
msgstr ":c:member:`~PyTypeObject.tp_prev`"

#: ../../c-api/typeobj.rst:156
msgid ":c:member:`~PyTypeObject.tp_next`"
msgstr ":c:member:`~PyTypeObject.tp_next`"

#: ../../c-api/typeobj.rst:159
msgid ""
"A slot name in parentheses indicates it is (effectively) deprecated. Names "
"in angle brackets should be treated as read-only. Names in square brackets "
"are for internal use only. \"<R>\" (as a prefix) means the field is required "
"(must be non-``NULL``)."
msgstr ""
"丸括弧で囲われているスロット名は、それが (実質的に) 非推奨であることを示して"
"います。\n"
"山括弧で囲われているスロット名は、読み出し専用として扱われるべきです。\n"
"角括弧で囲われているスロット名は、内部でのみ使われます。\n"
"(接頭辞としての) \"<R>\" は、このフィールドが必須であること (``NULL`` でない"
"こと) を意味します。"

#: ../../c-api/typeobj.rst:163
msgid "Columns:"
msgstr "列:"

#: ../../c-api/typeobj.rst:165
msgid "**\"O\"**:  set on :c:type:`PyBaseObject_Type`"
msgstr ""

#: ../../c-api/typeobj.rst:167
msgid "**\"T\"**:  set on :c:type:`PyType_Type`"
msgstr ""

#: ../../c-api/typeobj.rst:169
msgid "**\"D\"**:  default (if slot is set to ``NULL``)"
msgstr ""

#: ../../c-api/typeobj.rst:179
msgid "**\"I\"**:  inheritance"
msgstr ""

#: ../../c-api/typeobj.rst:188
msgid ""
"Note that some slots are effectively inherited through the normal attribute "
"lookup chain."
msgstr ""

#: ../../c-api/typeobj.rst:194
msgid "sub-slots"
msgstr "sub-slots"

#: ../../c-api/typeobj.rst:200
msgid "Slot"
msgstr "Slot"

#: ../../c-api/typeobj.rst:200
msgid "special methods"
msgstr "特殊メソッド"

#: ../../c-api/typeobj.rst:203
msgid ":c:member:`~PyAsyncMethods.am_await`"
msgstr ":c:member:`~PyAsyncMethods.am_await`"

#: ../../c-api/typeobj.rst:203 ../../c-api/typeobj.rst:205
#: ../../c-api/typeobj.rst:207 ../../c-api/typeobj.rst:239
#: ../../c-api/typeobj.rst:241 ../../c-api/typeobj.rst:243
#: ../../c-api/typeobj.rst:247 ../../c-api/typeobj.rst:274
#: ../../c-api/typeobj.rst:278 ../../c-api/typeobj.rst:288
#: ../../c-api/typeobj.rst:428
msgid ":c:type:`unaryfunc`"
msgstr ":c:type:`unaryfunc`"

#: ../../c-api/typeobj.rst:203
msgid "__await__"
msgstr "__await__"

#: ../../c-api/typeobj.rst:205
msgid ":c:member:`~PyAsyncMethods.am_aiter`"
msgstr ":c:member:`~PyAsyncMethods.am_aiter`"

#: ../../c-api/typeobj.rst:205
msgid "__aiter__"
msgstr "__aiter__"

#: ../../c-api/typeobj.rst:207
msgid ":c:member:`~PyAsyncMethods.am_anext`"
msgstr ":c:member:`~PyAsyncMethods.am_anext`"

#: ../../c-api/typeobj.rst:207
msgid "__anext__"
msgstr "__anext__"

#: ../../c-api/typeobj.rst:211
msgid ":c:member:`~PyNumberMethods.nb_add`"
msgstr ":c:member:`~PyNumberMethods.nb_add`"

#: ../../c-api/typeobj.rst:211 ../../c-api/typeobj.rst:214
#: ../../c-api/typeobj.rst:216 ../../c-api/typeobj.rst:219
#: ../../c-api/typeobj.rst:221 ../../c-api/typeobj.rst:224
#: ../../c-api/typeobj.rst:226 ../../c-api/typeobj.rst:229
#: ../../c-api/typeobj.rst:231 ../../c-api/typeobj.rst:249
#: ../../c-api/typeobj.rst:252 ../../c-api/typeobj.rst:254
#: ../../c-api/typeobj.rst:257 ../../c-api/typeobj.rst:259
#: ../../c-api/typeobj.rst:262 ../../c-api/typeobj.rst:264
#: ../../c-api/typeobj.rst:267 ../../c-api/typeobj.rst:269
#: ../../c-api/typeobj.rst:272 ../../c-api/typeobj.rst:280
#: ../../c-api/typeobj.rst:282 ../../c-api/typeobj.rst:284
#: ../../c-api/typeobj.rst:286 ../../c-api/typeobj.rst:290
#: ../../c-api/typeobj.rst:293 ../../c-api/typeobj.rst:299
#: ../../c-api/typeobj.rst:308 ../../c-api/typeobj.rst:319
#: ../../c-api/typeobj.rst:432
msgid ":c:type:`binaryfunc`"
msgstr ":c:type:`binaryfunc`"

#: ../../c-api/typeobj.rst:211
msgid "__add__ __radd__"
msgstr "__add__ __radd__"

#: ../../c-api/typeobj.rst:214
msgid ":c:member:`~PyNumberMethods.nb_inplace_add`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_add`"

#: ../../c-api/typeobj.rst:214 ../../c-api/typeobj.rst:319
msgid "__iadd__"
msgstr "__iadd__"

#: ../../c-api/typeobj.rst:216
msgid ":c:member:`~PyNumberMethods.nb_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_subtract`"

#: ../../c-api/typeobj.rst:216
msgid "__sub__ __rsub__"
msgstr "__sub__ __rsub__"

#: ../../c-api/typeobj.rst:219
msgid ":c:member:`~PyNumberMethods.nb_inplace_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_subtract`"

#: ../../c-api/typeobj.rst:219
msgid "__sub__"
msgstr "__sub__"

#: ../../c-api/typeobj.rst:221
msgid ":c:member:`~PyNumberMethods.nb_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_multiply`"

#: ../../c-api/typeobj.rst:221
msgid "__mul__ __rmul__"
msgstr "__mul__ __rmul__"

#: ../../c-api/typeobj.rst:224
msgid ":c:member:`~PyNumberMethods.nb_inplace_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_multiply`"

#: ../../c-api/typeobj.rst:224 ../../c-api/typeobj.rst:310
msgid "__mul__"
msgstr "__mul__"

#: ../../c-api/typeobj.rst:226
msgid ":c:member:`~PyNumberMethods.nb_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_remainder`"

#: ../../c-api/typeobj.rst:226
msgid "__mod__ __rmod__"
msgstr "__mod__ __rmod__"

#: ../../c-api/typeobj.rst:229
msgid ":c:member:`~PyNumberMethods.nb_inplace_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_remainder`"

#: ../../c-api/typeobj.rst:229
msgid "__mod__"
msgstr "__mod__"

#: ../../c-api/typeobj.rst:231
msgid ":c:member:`~PyNumberMethods.nb_divmod`"
msgstr ":c:member:`~PyNumberMethods.nb_divmod`"

#: ../../c-api/typeobj.rst:231
msgid "__divmod__ __rdivmod__"
msgstr "__divmod__ __rdivmod__"

#: ../../c-api/typeobj.rst:234
msgid ":c:member:`~PyNumberMethods.nb_power`"
msgstr ":c:member:`~PyNumberMethods.nb_power`"

#: ../../c-api/typeobj.rst:234
msgid "__pow__ __rpow__"
msgstr "__pow__ __rpow__"

#: ../../c-api/typeobj.rst:237
msgid ":c:member:`~PyNumberMethods.nb_inplace_power`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_power`"

#: ../../c-api/typeobj.rst:237
msgid "__pow__"
msgstr "__pow__"

#: ../../c-api/typeobj.rst:239
msgid ":c:member:`~PyNumberMethods.nb_negative`"
msgstr ":c:member:`~PyNumberMethods.nb_negative`"

#: ../../c-api/typeobj.rst:239
msgid "__neg__"
msgstr "__neg__"

#: ../../c-api/typeobj.rst:241
msgid ":c:member:`~PyNumberMethods.nb_positive`"
msgstr ":c:member:`~PyNumberMethods.nb_positive`"

#: ../../c-api/typeobj.rst:241
msgid "__pos__"
msgstr "__pos__"

#: ../../c-api/typeobj.rst:243
msgid ":c:member:`~PyNumberMethods.nb_absolute`"
msgstr ":c:member:`~PyNumberMethods.nb_absolute`"

#: ../../c-api/typeobj.rst:243
msgid "__abs__"
msgstr "__abs__"

#: ../../c-api/typeobj.rst:245
msgid ":c:member:`~PyNumberMethods.nb_bool`"
msgstr ":c:member:`~PyNumberMethods.nb_bool`"

#: ../../c-api/typeobj.rst:245
msgid "__bool__"
msgstr "__bool__"

#: ../../c-api/typeobj.rst:247
msgid ":c:member:`~PyNumberMethods.nb_invert`"
msgstr ":c:member:`~PyNumberMethods.nb_invert`"

#: ../../c-api/typeobj.rst:247
msgid "__invert__"
msgstr "__invert__"

#: ../../c-api/typeobj.rst:249
msgid ":c:member:`~PyNumberMethods.nb_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_lshift`"

#: ../../c-api/typeobj.rst:249
msgid "__lshift__ __rlshift__"
msgstr "__lshift__ __rlshift__"

#: ../../c-api/typeobj.rst:252
msgid ":c:member:`~PyNumberMethods.nb_inplace_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_lshift`"

#: ../../c-api/typeobj.rst:252
msgid "__lshift__"
msgstr "__lshift__"

#: ../../c-api/typeobj.rst:254
msgid ":c:member:`~PyNumberMethods.nb_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_rshift`"

#: ../../c-api/typeobj.rst:254
msgid "__rshift__ __rrshift__"
msgstr "__rshift__ __rrshift__"

#: ../../c-api/typeobj.rst:257
msgid ":c:member:`~PyNumberMethods.nb_inplace_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_rshift`"

#: ../../c-api/typeobj.rst:257
msgid "__rshift__"
msgstr "__rshift__"

#: ../../c-api/typeobj.rst:259
msgid ":c:member:`~PyNumberMethods.nb_and`"
msgstr ":c:member:`~PyNumberMethods.nb_and`"

#: ../../c-api/typeobj.rst:259
msgid "__and__ __rand__"
msgstr "__and__ __rand__"

#: ../../c-api/typeobj.rst:262
msgid ":c:member:`~PyNumberMethods.nb_inplace_and`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_and`"

#: ../../c-api/typeobj.rst:262
msgid "__and__"
msgstr "__and__"

#: ../../c-api/typeobj.rst:264
msgid ":c:member:`~PyNumberMethods.nb_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_xor`"

#: ../../c-api/typeobj.rst:264
msgid "__xor__ __rxor__"
msgstr "__xor__ __rxor__"

#: ../../c-api/typeobj.rst:267
msgid ":c:member:`~PyNumberMethods.nb_inplace_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_xor`"

#: ../../c-api/typeobj.rst:267
msgid "__xor__"
msgstr "__xor__"

#: ../../c-api/typeobj.rst:269
msgid ":c:member:`~PyNumberMethods.nb_or`"
msgstr ":c:member:`~PyNumberMethods.nb_or`"

#: ../../c-api/typeobj.rst:269
msgid "__or__ __ror__"
msgstr "__or__ __ror__"

#: ../../c-api/typeobj.rst:272
msgid ":c:member:`~PyNumberMethods.nb_inplace_or`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_or`"

#: ../../c-api/typeobj.rst:272
msgid "__or__"
msgstr "__or__"

#: ../../c-api/typeobj.rst:274
msgid ":c:member:`~PyNumberMethods.nb_int`"
msgstr ":c:member:`~PyNumberMethods.nb_int`"

#: ../../c-api/typeobj.rst:274
msgid "__int__"
msgstr "__int__"

#: ../../c-api/typeobj.rst:276
msgid ":c:member:`~PyNumberMethods.nb_reserved`"
msgstr ":c:member:`~PyNumberMethods.nb_reserved`"

#: ../../c-api/typeobj.rst:276 ../../c-api/typeobj.rst:343
#: ../../c-api/typeobj.rst:345 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:426
msgid "void *"
msgstr "void *"

#: ../../c-api/typeobj.rst:278
msgid ":c:member:`~PyNumberMethods.nb_float`"
msgstr ":c:member:`~PyNumberMethods.nb_float`"

#: ../../c-api/typeobj.rst:278
msgid "__float__"
msgstr "__float__"

#: ../../c-api/typeobj.rst:280
msgid ":c:member:`~PyNumberMethods.nb_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_floor_divide`"

#: ../../c-api/typeobj.rst:280 ../../c-api/typeobj.rst:282
msgid "__floordiv__"
msgstr "__floordiv__"

#: ../../c-api/typeobj.rst:282
msgid ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"

#: ../../c-api/typeobj.rst:284
msgid ":c:member:`~PyNumberMethods.nb_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_true_divide`"

#: ../../c-api/typeobj.rst:284 ../../c-api/typeobj.rst:286
msgid "__truediv__"
msgstr "__truediv__"

#: ../../c-api/typeobj.rst:286
msgid ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"

#: ../../c-api/typeobj.rst:288
msgid ":c:member:`~PyNumberMethods.nb_index`"
msgstr ":c:member:`~PyNumberMethods.nb_index`"

#: ../../c-api/typeobj.rst:288
msgid "__index__"
msgstr "__index__"

#: ../../c-api/typeobj.rst:290
msgid ":c:member:`~PyNumberMethods.nb_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_matrix_multiply`"

#: ../../c-api/typeobj.rst:290
msgid "__matmul__ __rmatmul__"
msgstr "__matmul__ __rmatmul__"

#: ../../c-api/typeobj.rst:293
msgid ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"

#: ../../c-api/typeobj.rst:293
msgid "__matmul__"
msgstr "__matmul__"

#: ../../c-api/typeobj.rst:297
msgid ":c:member:`~PyMappingMethods.mp_length`"
msgstr ":c:member:`~PyMappingMethods.mp_length`"

#: ../../c-api/typeobj.rst:297 ../../c-api/typeobj.rst:306
#: ../../c-api/typeobj.rst:413
msgid ":c:type:`lenfunc`"
msgstr ":c:type:`lenfunc`"

#: ../../c-api/typeobj.rst:297 ../../c-api/typeobj.rst:306
msgid "__len__"
msgstr "__len__"

#: ../../c-api/typeobj.rst:299
msgid ":c:member:`~PyMappingMethods.mp_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_subscript`"

#: ../../c-api/typeobj.rst:299 ../../c-api/typeobj.rst:312
msgid "__getitem__"
msgstr "__getitem__"

#: ../../c-api/typeobj.rst:301
msgid ":c:member:`~PyMappingMethods.mp_ass_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_ass_subscript`"

#: ../../c-api/typeobj.rst:301 ../../c-api/typeobj.rst:458
msgid ":c:type:`objobjargproc`"
msgstr ":c:type:`objobjargproc`"

#: ../../c-api/typeobj.rst:301
msgid "__setitem__, __delitem__"
msgstr "__setitem__, __delitem__"

#: ../../c-api/typeobj.rst:306
msgid ":c:member:`~PySequenceMethods.sq_length`"
msgstr ":c:member:`~PySequenceMethods.sq_length`"

#: ../../c-api/typeobj.rst:308
msgid ":c:member:`~PySequenceMethods.sq_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_concat`"

#: ../../c-api/typeobj.rst:308
msgid "__add__"
msgstr "__add__"

#: ../../c-api/typeobj.rst:310
msgid ":c:member:`~PySequenceMethods.sq_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_repeat`"

#: ../../c-api/typeobj.rst:310 ../../c-api/typeobj.rst:312
#: ../../c-api/typeobj.rst:321 ../../c-api/typeobj.rst:443
msgid ":c:type:`ssizeargfunc`"
msgstr ":c:type:`ssizeargfunc`"

#: ../../c-api/typeobj.rst:312
msgid ":c:member:`~PySequenceMethods.sq_item`"
msgstr ":c:member:`~PySequenceMethods.sq_item`"

#: ../../c-api/typeobj.rst:314
msgid ":c:member:`~PySequenceMethods.sq_ass_item`"
msgstr ":c:member:`~PySequenceMethods.sq_ass_item`"

#: ../../c-api/typeobj.rst:314 ../../c-api/typeobj.rst:448
msgid ":c:type:`ssizeobjargproc`"
msgstr ":c:type:`ssizeobjargproc`"

#: ../../c-api/typeobj.rst:314
msgid "__setitem__ __delitem__"
msgstr "__setitem__ __delitem__"

#: ../../c-api/typeobj.rst:317
msgid ":c:member:`~PySequenceMethods.sq_contains`"
msgstr ":c:member:`~PySequenceMethods.sq_contains`"

#: ../../c-api/typeobj.rst:317 ../../c-api/typeobj.rst:453
msgid ":c:type:`objobjproc`"
msgstr ":c:type:`objobjproc`"

#: ../../c-api/typeobj.rst:317
msgid "__contains__"
msgstr "__contains__"

#: ../../c-api/typeobj.rst:319
msgid ":c:member:`~PySequenceMethods.sq_inplace_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_concat`"

#: ../../c-api/typeobj.rst:321
msgid ":c:member:`~PySequenceMethods.sq_inplace_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_repeat`"

#: ../../c-api/typeobj.rst:321
msgid "__imul__"
msgstr "__imul__"

#: ../../c-api/typeobj.rst:325
msgid ":c:member:`~PyBufferProcs.bf_getbuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_getbuffer`"

#: ../../c-api/typeobj.rst:325
msgid ":c:func:`getbufferproc`"
msgstr ":c:func:`getbufferproc`"

#: ../../c-api/typeobj.rst:327
msgid ":c:member:`~PyBufferProcs.bf_releasebuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_releasebuffer`"

#: ../../c-api/typeobj.rst:327
msgid ":c:func:`releasebufferproc`"
msgstr ":c:func:`releasebufferproc`"

#: ../../c-api/typeobj.rst:333
msgid "slot typedefs"
msgstr "スロットの定義型 (typedef)"

#: ../../c-api/typeobj.rst:336
msgid "typedef"
msgstr "定義型 (typedef)"

#: ../../c-api/typeobj.rst:336
msgid "Parameter Types"
msgstr "引数型"

#: ../../c-api/typeobj.rst:336
msgid "Return Type"
msgstr "返り値型"

#: ../../c-api/typeobj.rst:343 ../../c-api/typeobj.rst:345
#: ../../c-api/typeobj.rst:421
msgid "void"
msgstr "void"

#: ../../c-api/typeobj.rst:0
msgid ":c:type:`visitproc`"
msgstr ":c:type:`visitproc`"

#: ../../c-api/typeobj.rst:347 ../../c-api/typeobj.rst:359
#: ../../c-api/typeobj.rst:372 ../../c-api/typeobj.rst:383
#: ../../c-api/typeobj.rst:395 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:415 ../../c-api/typeobj.rst:426
#: ../../c-api/typeobj.rst:448 ../../c-api/typeobj.rst:453
#: ../../c-api/typeobj.rst:458
msgid "int"
msgstr "int"

#: ../../c-api/typeobj.rst:401
msgid "Py_hash_t"
msgstr "Py_hash_t"

#: ../../c-api/typeobj.rst:415
msgid ":c:type:`getbufferproc`"
msgstr ":c:type:`getbufferproc`"

#: ../../c-api/typeobj.rst:0
msgid ":c:type:`Py_buffer` *"
msgstr ":c:type:`Py_buffer` *"

#: ../../c-api/typeobj.rst:421
msgid ":c:type:`releasebufferproc`"
msgstr ":c:type:`releasebufferproc`"

#: ../../c-api/typeobj.rst:465
msgid "See :ref:`slot-typedefs` below for more detail."
msgstr ""

#: ../../c-api/typeobj.rst:469
msgid "PyTypeObject Definition"
msgstr "PyTypeObject 定義"

#: ../../c-api/typeobj.rst:471
msgid ""
"The structure definition for :c:type:`PyTypeObject` can be found in :file:"
"`Include/object.h`.  For convenience of reference, this repeats the "
"definition found there:"
msgstr ""
":c:type:`PyTypeObject` の構造体定義は :file:`Include/object.h` で見つけられる"
"はずです。参照の手間を省くために、ここでは定義を繰り返します:"

#: ../../c-api/typeobj.rst:481
msgid "PyObject Slots"
msgstr "PyObject スロット"

#: ../../c-api/typeobj.rst:483
msgid ""
"The type object structure extends the :c:type:`PyVarObject` structure. The :"
"attr:`ob_size` field is used for dynamic types (created by  :func:"
"`type_new`, usually called from a class statement). Note that :c:data:"
"`PyType_Type` (the metatype) initializes :c:member:`~PyTypeObject."
"tp_itemsize`, which means that its instances (i.e. type objects) *must* have "
"the :attr:`ob_size` field."
msgstr ""
"型オブジェクト構造体は :c:type:`PyVarObject` 構造体を拡張したものです。 :"
"attr:`ob_size` フィールドは、(通常 class 文が呼び出す :func:`type_new` で生成"
"される) 動的な型に使います。 :c:data:`PyType_Type` (メタタイプ) は :c:member:"
"`~PyTypeObject.tp_itemsize` を初期化するので注意してください。すなわち、 イン"
"スタンス (つまり型オブジェクト) には :attr:`ob_size` フィールドが存在しなけれ"
"ば *なりません* 。"

#: ../../c-api/typeobj.rst:493
msgid ""
"These fields are only present when the macro ``Py_TRACE_REFS`` is defined. "
"Their initialization to ``NULL`` is taken care of by the "
"``PyObject_HEAD_INIT`` macro.  For statically allocated objects, these "
"fields always remain ``NULL``. For dynamically allocated objects, these two "
"fields are used to link the object into a doubly-linked list of *all* live "
"objects on the heap.  This could be used for various debugging purposes; "
"currently the only use is to print the objects that are still alive at the "
"end of a run when the environment variable :envvar:`PYTHONDUMPREFS` is set."
msgstr ""
"これらのフィールドはマクロ ``Py_TRACE_REFS`` が定義されている場合のみ存在しま"
"す。 ``PyObject_HEAD_INIT`` マクロを使うと、フィールドを ``NULL`` に初期化し"
"ます。静的にメモリ確保されているオブジェクトでは、これらのフィールドは常に "
"``NULL`` のままです。動的にメモリ確保されるオブジェクトの場合、これら二つの"
"フィールドは、ヒープ上の *全ての* 存続中のオブジェクトからなる二重リンクリス"
"トでオブジェクトをリンクする際に使われます。このことは様々なデバッグ目的に利"
"用できます; 現状では、環境変数 :envvar:`PYTHONDUMPREFS` が設定されているとき"
"に、プログラムの実行終了時点で存続しているオブジェクトを出力するのが唯一の用"
"例です。"

#: ../../c-api/typeobj.rst:502 ../../c-api/typeobj.rst:515
#: ../../c-api/typeobj.rst:538 ../../c-api/typeobj.rst:551
#: ../../c-api/typeobj.rst:593 ../../c-api/typeobj.rst:636
#: ../../c-api/typeobj.rst:682 ../../c-api/typeobj.rst:738
#: ../../c-api/typeobj.rst:757 ../../c-api/typeobj.rst:774
#: ../../c-api/typeobj.rst:792 ../../c-api/typeobj.rst:816
#: ../../c-api/typeobj.rst:833 ../../c-api/typeobj.rst:845
#: ../../c-api/typeobj.rst:857 ../../c-api/typeobj.rst:890
#: ../../c-api/typeobj.rst:908 ../../c-api/typeobj.rst:928
#: ../../c-api/typeobj.rst:949 ../../c-api/typeobj.rst:975
#: ../../c-api/typeobj.rst:994 ../../c-api/typeobj.rst:1010
#: ../../c-api/typeobj.rst:1047 ../../c-api/typeobj.rst:1058
#: ../../c-api/typeobj.rst:1068 ../../c-api/typeobj.rst:1078
#: ../../c-api/typeobj.rst:1092 ../../c-api/typeobj.rst:1111
#: ../../c-api/typeobj.rst:1134 ../../c-api/typeobj.rst:1179
#: ../../c-api/typeobj.rst:1203 ../../c-api/typeobj.rst:1257
#: ../../c-api/typeobj.rst:1318 ../../c-api/typeobj.rst:1377
#: ../../c-api/typeobj.rst:1407 ../../c-api/typeobj.rst:1439
#: ../../c-api/typeobj.rst:1462 ../../c-api/typeobj.rst:1475
#: ../../c-api/typeobj.rst:1490 ../../c-api/typeobj.rst:1504
#: ../../c-api/typeobj.rst:1534 ../../c-api/typeobj.rst:1554
#: ../../c-api/typeobj.rst:1580 ../../c-api/typeobj.rst:1598
#: ../../c-api/typeobj.rst:1638 ../../c-api/typeobj.rst:1689
#: ../../c-api/typeobj.rst:1706 ../../c-api/typeobj.rst:1744
#: ../../c-api/typeobj.rst:1765 ../../c-api/typeobj.rst:1797
#: ../../c-api/typeobj.rst:1814 ../../c-api/typeobj.rst:1825
#: ../../c-api/typeobj.rst:1835 ../../c-api/typeobj.rst:1844
#: ../../c-api/typeobj.rst:1854 ../../c-api/typeobj.rst:1868
#: ../../c-api/typeobj.rst:1906
msgid "**Inheritance:**"
msgstr "**継承:**"

#: ../../c-api/typeobj.rst:504
msgid "These fields are not inherited by subtypes."
msgstr "サブタイプはこのフィールドを継承しません。"

#: ../../c-api/typeobj.rst:509
msgid ""
"This is the type object's reference count, initialized to ``1`` by the "
"``PyObject_HEAD_INIT`` macro.  Note that for statically allocated type "
"objects, the type's instances (objects whose :attr:`ob_type` points back to "
"the type) do *not* count as references.  But for dynamically allocated type "
"objects, the instances *do* count as references."
msgstr ""
"型オブジェクトの参照カウントで、 ``PyObject_HEAD_INIT`` はこの値を ``1`` に初"
"期化します。静的にメモリ確保された型オブジェクトでは、型のインスタンス (:"
"attr:`ob_type` が該当する型を指しているオブジェクト) は参照をカウントする対象"
"には *なりません* 。動的にメモリ確保される型オブジェクトの場合、インスタンス"
"は参照カウントの対象に *なります* 。"

#: ../../c-api/typeobj.rst:517 ../../c-api/typeobj.rst:553
#: ../../c-api/typeobj.rst:595
msgid "This field is not inherited by subtypes."
msgstr "サブタイプはこのフィールドを継承しません。"

#: ../../c-api/typeobj.rst:522
msgid ""
"This is the type's type, in other words its metatype.  It is initialized by "
"the argument to the ``PyObject_HEAD_INIT`` macro, and its value should "
"normally be ``&PyType_Type``.  However, for dynamically loadable extension "
"modules that must be usable on Windows (at least), the compiler complains "
"that this is not a valid initializer.  Therefore, the convention is to pass "
"``NULL`` to the ``PyObject_HEAD_INIT`` macro and to initialize this field "
"explicitly at the start of the module's initialization function, before "
"doing anything else.  This is typically done like this::"
msgstr ""
"型自体の型、別の言い方をするとメタタイプです。 ``PyObject_HEAD_INIT`` マクロ"
"で初期化され、通常は ``&PyType_Type`` になります。しかし、(少なくとも) "
"Windows で利用できる動的ロード可能な拡張モジュールでは、コンパイラは有効な初"
"期化ではないと文句をつけます。そこで、ならわしとして、 "
"``PyObject_HEAD_INIT`` には ``NULL`` を渡して初期化しておき、他の操作を行う前"
"にモジュールの初期化関数で明示的にこのフィールドを初期化することになっていま"
"す。この操作は以下のように行います::"

#: ../../c-api/typeobj.rst:533
msgid ""
"This should be done before any instances of the type are created. :c:func:"
"`PyType_Ready` checks if :attr:`ob_type` is ``NULL``, and if so, initializes "
"it to the :attr:`ob_type` field of the base class. :c:func:`PyType_Ready` "
"will not change this field if it is non-zero."
msgstr ""
"上の操作は、該当する型のいかなるインスタンス生成よりも前にしておかなければな"
"りません。 :c:func:`PyType_Ready` は :attr:`ob_type` が ``NULL`` かどうか調"
"べ、 ``NULL`` の場合には基底クラスの :attr:`ob_type` フィールドで初期化しま"
"す。 ob_type フィールドがゼロでない場合、 :c:func:`PyType_Ready` はこのフィー"
"ルドを変更しません。"

#: ../../c-api/typeobj.rst:540 ../../c-api/typeobj.rst:684
#: ../../c-api/typeobj.rst:818 ../../c-api/typeobj.rst:910
#: ../../c-api/typeobj.rst:930 ../../c-api/typeobj.rst:1441
#: ../../c-api/typeobj.rst:1464 ../../c-api/typeobj.rst:1582
#: ../../c-api/typeobj.rst:1600 ../../c-api/typeobj.rst:1691
#: ../../c-api/typeobj.rst:1799 ../../c-api/typeobj.rst:1908
msgid "This field is inherited by subtypes."
msgstr "サブタイプはこのフィールドを継承します。"

#: ../../c-api/typeobj.rst:544
msgid "PyVarObject Slots"
msgstr "PyVarObject スロット"

#: ../../c-api/typeobj.rst:548
msgid ""
"For statically allocated type objects, this should be initialized to zero.  "
"For dynamically allocated type objects, this field has a special internal "
"meaning."
msgstr ""
"静的にメモリ確保されている型オブジェクトの場合、このフィールドはゼロに初期化"
"されます。動的にメモリ確保されている型オブジェクトの場合、このフィールドは内"
"部使用される特殊な意味を持ちます。"

#: ../../c-api/typeobj.rst:557
msgid "PyTypeObject Slots"
msgstr "PyTypeObject スロット"

#: ../../c-api/typeobj.rst:559
msgid ""
"Each slot has a section describing inheritance.  If :c:func:`PyType_Ready` "
"may set a value when the field is set to ``NULL`` then there will also be a "
"\"Default\" section.  (Note that many fields set on :c:type:"
"`PyBaseObject_Type` and :c:type:`PyType_Type` effectively act as defaults.)"
msgstr ""

#: ../../c-api/typeobj.rst:566
msgid ""
"Pointer to a NUL-terminated string containing the name of the type. For "
"types that are accessible as module globals, the string should be the full "
"module name, followed by a dot, followed by the type name; for built-in "
"types, it should be just the type name.  If the module is a submodule of a "
"package, the full package name is part of the full module name.  For "
"example, a type named :class:`T` defined in module :mod:`M` in subpackage :"
"mod:`Q` in package :mod:`P` should have the :c:member:`~PyTypeObject."
"tp_name` initializer ``\"P.Q.M.T\"``."
msgstr ""
"型の名前が入っている NUL 終端された文字列へのポインタです。モジュールのグロー"
"バル変数としてアクセスできる型の場合、この文字列は完全なモジュール名、ドッ"
"ト、そして型の名前と続く文字列になります; 組み込み型の場合、ただの型の名前で"
"す。モジュールがあるパッケージのサブモジュールの場合、完全なパッケージ名が完"
"全なモジュール名の一部になっています。例えば、パッケージ :mod:`P` 内のサブモ"
"ジュール :mod:`Q` に入っているモジュール :mod:`M` 内で定義されている :class:"
"`T` は、 :c:member:`~PyTypeObject.tp_name` を ``\"P.Q.M.T\"`` に初期化しま"
"す。"

#: ../../c-api/typeobj.rst:574
msgid ""
"For dynamically allocated type objects, this should just be the type name, "
"and the module name explicitly stored in the type dict as the value for key "
"``'__module__'``."
msgstr ""
"動的にメモリ確保される型オブジェクトの場合、このフィールドは単に型の名前にな"
"り、モジュール名は型の辞書内でキー ``'__module__'`` に対する値として明示的に"
"保存されます。"

#: ../../c-api/typeobj.rst:578
msgid ""
"For statically allocated type objects, the tp_name field should contain a "
"dot. Everything before the last dot is made accessible as the :attr:"
"`__module__` attribute, and everything after the last dot is made accessible "
"as the :attr:`~definition.__name__` attribute."
msgstr ""
"静的にメモリ確保される型オブジェクトの場合、 tp_name フィールドにはドットが含"
"まれているはずです。\n"
"最後のドットよりも前にある部分文字列全体は :attr:`__module__` 属性として、ま"
"たドットよりも後ろにある部分は :attr:`~definition.__name__` 属性としてアクセ"
"スできます。"

#: ../../c-api/typeobj.rst:583
msgid ""
"If no dot is present, the entire :c:member:`~PyTypeObject.tp_name` field is "
"made accessible as the :attr:`~definition.__name__` attribute, and the :attr:"
"`__module__` attribute is undefined (unless explicitly set in the "
"dictionary, as explained above).  This means your type will be impossible to "
"pickle.  Additionally, it will not be listed in module documentations "
"created with pydoc."
msgstr ""
"ドットが入っていない場合、 :c:member:`~PyTypeObject.tp_name` フィールドの内容"
"全てが :attr:`~definition.__name__` 属性になり、 :attr:`__module__` 属性は "
"(前述のように型の辞書内で明示的にセットしないかぎり) 未定義になります。\n"
"このため、その型は pickle 化できないことになります。\n"
"さらに、 pydoc が作成するモジュールドキュメントのリストにも載らなくなります。"

#: ../../c-api/typeobj.rst:589
msgid ""
"This field must not be ``NULL``.  It is the only required field in :c:func:"
"`PyTypeObject` (other than potentially :c:member:`~PyTypeObject."
"tp_itemsize`)."
msgstr ""

#: ../../c-api/typeobj.rst:601
msgid ""
"These fields allow calculating the size in bytes of instances of the type."
msgstr ""
"これらのフィールドは、型インスタンスのバイトサイズを計算できるようにします。"

#: ../../c-api/typeobj.rst:603
msgid ""
"There are two kinds of types: types with fixed-length instances have a zero :"
"c:member:`~PyTypeObject.tp_itemsize` field, types with variable-length "
"instances have a non-zero :c:member:`~PyTypeObject.tp_itemsize` field.  For "
"a type with fixed-length instances, all instances have the same size, given "
"in :c:member:`~PyTypeObject.tp_basicsize`."
msgstr ""
"型には二つの種類があります: 固定長インスタンスの型は、 :c:member:"
"`~PyTypeObject.tp_itemsize` フィールドがゼロで、可変長インスタンスの方は :c:"
"member:`~PyTypeObject.tp_itemsize` フィールドが非ゼロの値になります。固定長イ"
"ンスタンスの型の場合、全てのインスタンスは等しく :c:member:`~PyTypeObject."
"tp_basicsize` で与えられたサイズになります。"

#: ../../c-api/typeobj.rst:608
msgid ""
"For a type with variable-length instances, the instances must have an :attr:"
"`ob_size` field, and the instance size is :c:member:`~PyTypeObject."
"tp_basicsize` plus N times :c:member:`~PyTypeObject.tp_itemsize`, where N is "
"the \"length\" of the object.  The value of N is typically stored in the "
"instance's :attr:`ob_size` field.  There are exceptions:  for example, ints "
"use a negative :attr:`ob_size` to indicate a negative number, and N is "
"``abs(ob_size)`` there.  Also, the presence of an :attr:`ob_size` field in "
"the instance layout doesn't mean that the instance structure is variable-"
"length (for example, the structure for the list type has fixed-length "
"instances, yet those instances have a meaningful :attr:`ob_size` field)."
msgstr ""
"可変長インスタンスの型の場合、インスタンスには :attr:`ob_size`  フィールドが"
"なくてはならず、インスタンスのサイズは N をオブジェクトの \"長さ\" として、 :"
"c:member:`~PyTypeObject.tp_basicsize` と :c:member:`~PyTypeObject."
"tp_itemsize` の N 倍を足したものになります。 N の値は通常、インスタンスの :"
"attr:`ob_size`  フィールドに記憶されます。ただし例外がいくつかあります: 例え"
"ば、整数では負の値を :attr:`ob_size` に使って、インスタンスの表す値が負である"
"ことを示し、 N 自体は ``abs(ob_size)`` になります。また、 :attr:`ob_size` "
"フィールドがあるからといって、必ずしもインスタンスが可変長であることを意味し"
"ません (例えば、 リスト型の構造体は固定長のインスタンスになるにもかかわらず、"
"インスタンスにはちゃんと意味を持った :attr:`ob_size` フィールドがあります)。"

#: ../../c-api/typeobj.rst:619
msgid ""
"The basic size includes the fields in the instance declared by the macro :c:"
"macro:`PyObject_HEAD` or :c:macro:`PyObject_VAR_HEAD` (whichever is used to "
"declare the instance struct) and this in turn includes the :attr:`_ob_prev` "
"and :attr:`_ob_next` fields if they are present.  This means that the only "
"correct way to get an initializer for the :c:member:`~PyTypeObject."
"tp_basicsize` is to use the ``sizeof`` operator on the struct used to "
"declare the instance layout. The basic size does not include the GC header "
"size."
msgstr ""
"基本サイズには、 :c:macro:`PyObject_HEAD` マクロまたは  :c:macro:"
"`PyObject_VAR_HEAD` マクロ (インスタンス構造体を宣言するのに使ったどちらかの"
"マクロ) で宣言されているフィールドが入っています。さらに、 :attr:`_ob_prev` "
"および :attr:`_ob_next` フィールドがある場合、これらのフィールドもサイズに加"
"算されます。従って、 :c:member:`~PyTypeObject.tp_basicsize` の正しい初期化値"
"を得るには、インスタンスデータのレイアウトを宣言するのに使う構造体に対して "
"``sizeof`` 演算子を使うしかありません。基本サイズには、GC ヘッダサイズは入っ"
"ていません。"

#: ../../c-api/typeobj.rst:627
msgid ""
"A note about alignment: if the variable items require a particular "
"alignment, this should be taken care of by the value of :c:member:"
"`~PyTypeObject.tp_basicsize`.  Example: suppose a type implements an array "
"of ``double``. :c:member:`~PyTypeObject.tp_itemsize` is ``sizeof(double)``. "
"It is the programmer's responsibility that :c:member:`~PyTypeObject."
"tp_basicsize` is a multiple of ``sizeof(double)`` (assuming this is the "
"alignment requirement for ``double``)."
msgstr ""
"アラインメントに関する注釈: 変数の各要素を配置する際に特定のアラインメントが"
"必要となる場合、 :c:member:`~PyTypeObject.tp_basicsize` の値に気をつけなけれ"
"ばなりません。例: ある型が ``double`` の配列を実装しているとします。 :c:"
"member:`~PyTypeObject.tp_itemsize` は ``sizeof(double)`` です。 :c:member:"
"`~PyTypeObject.tp_basicsize` が ``sizeof(double)`` (ここではこれを "
"``double`` のアラインメントが要求するサイズと仮定する) の個数分のサイズになる"
"ようにするのはプログラマの責任です。"

#: ../../c-api/typeobj.rst:634
msgid ""
"For any type with variable-length instances, this field must not be ``NULL``."
msgstr ""

#: ../../c-api/typeobj.rst:638
msgid ""
"These fields are inherited separately by subtypes.  If the base type has a "
"non-zero :c:member:`~PyTypeObject.tp_itemsize`, it is generally not safe to "
"set :c:member:`~PyTypeObject.tp_itemsize` to a different non-zero value in a "
"subtype (though this depends on the implementation of the base type)."
msgstr ""
"これらのフィールドはサブタイプに別々に継承されます。基底タイプが 0 でない :c:"
"member:`~PyTypeObject.tp_itemsize` を持っていた場合、基底タイプの実装に依存し"
"ますが、一般的にはサブタイプで別の 0 で無い値を :c:member:`~PyTypeObject."
"tp_itemsize` に設定するのは安全ではありません。"

#: ../../c-api/typeobj.rst:646
msgid ""
"A pointer to the instance destructor function.  This function must be "
"defined unless the type guarantees that its instances will never be "
"deallocated (as is the case for the singletons ``None`` and ``Ellipsis``).  "
"The function signature is::"
msgstr ""
"インスタンスのデストラクタ関数へのポインタです。この関数は (単量子 ``None`` "
"や ``Ellipsis`` の場合のように) インスタンスが決してメモリ解放されない型でな"
"い限り必ず定義しなければなりません。シグネチャは次の通りです::"

#: ../../c-api/typeobj.rst:652
msgid ""
"The destructor function is called by the :c:func:`Py_DECREF` and :c:func:"
"`Py_XDECREF` macros when the new reference count is zero.  At this point, "
"the instance is still in existence, but there are no references to it.  The "
"destructor function should free all references which the instance owns, free "
"all memory buffers owned by the instance (using the freeing function "
"corresponding to the allocation function used to allocate the buffer), and "
"call the type's :c:member:`~PyTypeObject.tp_free` function.  If the type is "
"not subtypable (doesn't have the :const:`Py_TPFLAGS_BASETYPE` flag bit set), "
"it is permissible to call the object deallocator directly instead of via :c:"
"member:`~PyTypeObject.tp_free`.  The object deallocator should be the one "
"used to allocate the instance; this is normally :c:func:`PyObject_Del` if "
"the instance was allocated using :c:func:`PyObject_New` or :c:func:"
"`PyObject_VarNew`, or :c:func:`PyObject_GC_Del` if the instance was "
"allocated using :c:func:`PyObject_GC_New` or :c:func:`PyObject_GC_NewVar`."
msgstr ""
"デストラクタ関数は、参照カウントが新たにゼロになった際に :c:func:`Py_DECREF` "
"や :c:func:`Py_XDECREF` マクロから呼び出されます。呼び出された時点では、イン"
"スタンスはまだ存在しますが、インスタンスに対する参照は全くない状態です。デス"
"トラクタ関数はインスタンスが保持している全ての参照を解放し、インスタンスが確"
"保している全てのメモリバッファを (バッファの確保時に使った関数に対応するメモ"
"リ解放関数を使って) 解放し、その型の  :c:member:`~PyTypeObject.tp_free` 関数"
"を呼び出します。ある型がサブタイプを作成できない (:const:"
"`Py_TPFLAGS_BASETYPE` フラグがセットされていない) 場合、 :c:member:"
"`~PyTypeObject.tp_free` の代わりにオブジェクトのメモリ解放関数 (deallocator) "
"を直接呼び出してもかまいません。オブジェクトのメモリ解放関数は、インスタンス"
"のメモリ確保を行う際に使った関数に対応したものでなければなりません; インスタ"
"ンスを :c:func:`PyObject_New` や :c:func:`PyObject_VarNew` でメモリ 確保した"
"場合には、通常 :c:func:`PyObject_Del` を使い、 :c:func:`PyObject_GC_New` や :"
"c:func:`PyObject_GC_NewVar` で確保した場合には :c:func:`PyObject_GC_Del` を使"
"います。"

#: ../../c-api/typeobj.rst:667
msgid ""
"Finally, if the type is heap allocated (:const:`Py_TPFLAGS_HEAPTYPE`), the "
"deallocator should decrement the reference count for its type object after "
"calling the type deallocator. In order to avoid dangling pointers, the "
"recommended way to achieve this is:"
msgstr ""

#: ../../c-api/typeobj.rst:689
msgid ""
"An optional offset to a per-instance function that implements calling the "
"object using the *vectorcall* protocol, a more efficient alternative of the "
"simpler :c:member:`~PyTypeObject.tp_call`."
msgstr ""

#: ../../c-api/typeobj.rst:693
msgid ""
"This field is only used if the flag :const:`_Py_TPFLAGS_HAVE_VECTORCALL` is "
"set. If so, this must be a positive integer containing the offset in the "
"instance of a :c:type:`vectorcallfunc` pointer. The signature is the same as "
"for :c:func:`_PyObject_Vectorcall`::"
msgstr ""

#: ../../c-api/typeobj.rst:700
msgid ""
"The *vectorcallfunc* pointer may be zero, in which case the instance behaves "
"as if :const:`_Py_TPFLAGS_HAVE_VECTORCALL` was not set: calling the instance "
"falls back to :c:member:`~PyTypeObject.tp_call`."
msgstr ""

#: ../../c-api/typeobj.rst:704
msgid ""
"Any class that sets ``_Py_TPFLAGS_HAVE_VECTORCALL`` must also set :c:member:"
"`~PyTypeObject.tp_call` and make sure its behaviour is consistent with the "
"*vectorcallfunc* function. This can be done by setting *tp_call* to "
"``PyVectorcall_Call``:"
msgstr ""

#: ../../c-api/typeobj.rst:711
msgid ""
"Call *callable*'s *vectorcallfunc* with positional and keyword arguments "
"given in a tuple and dict, respectively."
msgstr ""

#: ../../c-api/typeobj.rst:714
msgid ""
"This function is intended to be used in the ``tp_call`` slot. It does not "
"fall back to ``tp_call`` and it currently does not check the "
"``_Py_TPFLAGS_HAVE_VECTORCALL`` flag. To call an object, use one of the :c:"
"func:`PyObject_Call <PyObject_Call>` functions instead."
msgstr ""

#: ../../c-api/typeobj.rst:722
msgid ""
"It is not recommended for :ref:`heap types <heap-types>` to implement the "
"vectorcall protocol. When a user sets ``__call__`` in Python code, only "
"``tp_call`` is updated, possibly making it inconsistent with the vectorcall "
"function."
msgstr ""

#: ../../c-api/typeobj.rst:729
msgid ""
"The semantics of the ``tp_vectorcall_offset`` slot are provisional and "
"expected to be finalized in Python 3.9. If you use vectorcall, plan for "
"updating your code for Python 3.9."
msgstr ""

#: ../../c-api/typeobj.rst:735
msgid ""
"This slot was used for print formatting in Python 2.x. In Python 3.0 to 3.7, "
"it was reserved and named ``tp_print``."
msgstr ""

#: ../../c-api/typeobj.rst:740
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_call`: a subtype inherits :c:member:`~PyTypeObject.tp_vectorcall_offset` "
"from its base type when the subtype’s :c:member:`~PyTypeObject.tp_call` is "
"``NULL``."
msgstr ""

#: ../../c-api/typeobj.rst:745
msgid ""
"Note that `heap types`_ (including subclasses defined in Python) do not "
"inherit the :const:`_Py_TPFLAGS_HAVE_VECTORCALL` flag."
msgstr ""

#: ../../c-api/typeobj.rst:751
msgid "An optional pointer to the get-attribute-string function."
msgstr "オプションのポインタで、get-attribute-string を行う関数を指します。"

#: ../../c-api/typeobj.rst:753
msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :c:member:`~PyTypeObject.tp_getattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"このフィールドは非推奨です。\n"
"このフィールドを定義するときは、 :c:member:`~PyTypeObject.tp_getattro` 関数と"
"同じように動作し、属性名は Python 文字列 オブジェクトではなく C 文字列で指定"
"するような関数を指すようにしなければなりません。"

#: ../../c-api/typeobj.rst:759 ../../c-api/typeobj.rst:951
msgid "Group: :attr:`tp_getattr`, :attr:`tp_getattro`"
msgstr ""

#: ../../c-api/typeobj.rst:761
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_getattro`: a subtype inherits both :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject."
"tp_getattro` are both ``NULL``."
msgstr ""
"このフィールドは :c:member:`~PyTypeObject.tp_getattro` と共にサブタイプに継承"
"されます: すなわち、サブタイプの :c:member:`~PyTypeObject.tp_getattr` およ"
"び :c:member:`~PyTypeObject.tp_getattro` が共に ``NULL`` の場合、サブタイプは"
"基底タイプから :c:member:`~PyTypeObject.tp_getattr` と :c:member:"
"`~PyTypeObject.tp_getattro` を両方とも継承します。"

#: ../../c-api/typeobj.rst:768 ../../c-api/typeobj.rst:964
msgid ""
"An optional pointer to the function for setting and deleting attributes."
msgstr "オプションのポインタで、属性の設定と削除を行う関数を指します。"

#: ../../c-api/typeobj.rst:770
msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :c:member:`~PyTypeObject.tp_setattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"このフィールドは非推奨です。\n"
"このフィールドを定義するときは、 :c:member:`~PyTypeObject.tp_setattro` 関数と"
"同じように動作し、属性名は Python 文字列 オブジェクトではなく C 文字列で指定"
"するような関数を指すようにしなければなりません。"

#: ../../c-api/typeobj.rst:776 ../../c-api/typeobj.rst:977
msgid "Group: :attr:`tp_setattr`, :attr:`tp_setattro`"
msgstr ""

#: ../../c-api/typeobj.rst:778
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_setattro`: a subtype inherits both :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject."
"tp_setattro` are both ``NULL``."
msgstr ""
"このフィールドは :c:member:`~PyTypeObject.tp_setattro` と共にサブタイプに継承"
"されます: すなわち、サブタイプの :c:member:`~PyTypeObject.tp_setattr` およ"
"び :c:member:`~PyTypeObject.tp_setattro` が共に ``NULL`` の場合、サブタイプは"
"基底タイプから :c:member:`~PyTypeObject.tp_setattr` と :c:member:"
"`~PyTypeObject.tp_setattro` を両方とも継承します。"

#: ../../c-api/typeobj.rst:785
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement :term:`awaitable` and :term:`asynchronous iterator` "
"protocols at the C-level.  See :ref:`async-structs` for details."
msgstr ""
"追加の構造体を指すポインタです。\n"
"この構造体は、 C レベルで :term:`awaitable` プロトコルと :term:`asynchronous "
"iterator` プロトコルを実装するオブジェクトだけに関係するフィールドを持ちま"
"す。\n"
"詳しいことは :ref:`async-structs` を参照してください。"

#: ../../c-api/typeobj.rst:789
msgid "Formerly known as ``tp_compare`` and ``tp_reserved``."
msgstr "以前は ``tp_compare`` や ``tp_reserved`` として知られていました。"

#: ../../c-api/typeobj.rst:794
msgid ""
"The :c:member:`~PyTypeObject.tp_as_async` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
":c:member:`~PyTypeObject.tp_as_async` フィールドは継承されませんが、これに含"
"まれるフィールドが個別に継承されます。"

#: ../../c-api/typeobj.rst:802
msgid ""
"An optional pointer to a function that implements the built-in function :"
"func:`repr`."
msgstr ""
"オプションのポインタで、組み込み関数 :func:`repr` を実装している関数を指しま"
"す。"

#: ../../c-api/typeobj.rst:805
msgid "The signature is the same as for :c:func:`PyObject_Repr`::"
msgstr ""

#: ../../c-api/typeobj.rst:809
msgid ""
"The function must return a string or a Unicode object.  Ideally, this "
"function should return a string that, when passed to :func:`eval`, given a "
"suitable environment, returns an object with the same value.  If this is not "
"feasible, it should return a string starting with ``'<'`` and ending with "
"``'>'`` from which both the type and the value of the object can be deduced."
msgstr ""
"この関数は文字列オブジェクトか Unicode オブジェクトを返さなければなりません。"
"理想的には、この関数が返す文字列は、適切な環境で :func:`eval` に渡した場合、"
"同じ値を持つオブジェクトになるような文字列でなければなりません。不可能な場合"
"には、オブジェクトの型と値から導出した内容の入った ``'<'`` から始まって "
"``'>'`` で終わる文字列を返さなければなりません。"

#: ../../c-api/typeobj.rst:820 ../../c-api/typeobj.rst:932
#: ../../c-api/typeobj.rst:957 ../../c-api/typeobj.rst:983
#: ../../c-api/typeobj.rst:1025 ../../c-api/typeobj.rst:1386
#: ../../c-api/typeobj.rst:1538 ../../c-api/typeobj.rst:1559
#: ../../c-api/typeobj.rst:1657 ../../c-api/typeobj.rst:1693
#: ../../c-api/typeobj.rst:1711 ../../c-api/typeobj.rst:1749
#: ../../c-api/typeobj.rst:1770 ../../c-api/typeobj.rst:1801
msgid "**Default:**"
msgstr "**デフォルト**"

#: ../../c-api/typeobj.rst:822
msgid ""
"When this field is not set, a string of the form ``<%s object at %p>`` is "
"returned, where ``%s`` is replaced by the type name, and ``%p`` by the "
"object's memory address."
msgstr ""
"このフィールドが設定されていない場合、 ``<%s object at %p>`` の形式をとる文字"
"列が返されます。 ``%s`` は型の名前に、 ``%p`` はオブジェクトのメモリアドレス"
"に置き換えられます。"

#: ../../c-api/typeobj.rst:829
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the number protocol.  These fields are documented "
"in :ref:`number-structs`."
msgstr ""
"数値プロトコルを実装した追加の構造体を指すポインタです。これらのフィールドに"
"ついては :ref:`number-structs` で説明されています。"

#: ../../c-api/typeobj.rst:835
msgid ""
"The :c:member:`~PyTypeObject.tp_as_number` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
":c:member:`~PyTypeObject.tp_as_number` フィールドは継承されませんが、そこの含"
"まれるフィールドが個別に継承されます。"

#: ../../c-api/typeobj.rst:841
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the sequence protocol.  These fields are documented "
"in :ref:`sequence-structs`."
msgstr ""
"シーケンスプロトコルを実装した追加の構造体を指すポインタです。これらのフィー"
"ルドについては :ref:`sequence-structs` で説明されています。"

#: ../../c-api/typeobj.rst:847
msgid ""
"The :c:member:`~PyTypeObject.tp_as_sequence` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
":c:member:`~PyTypeObject.tp_as_sequence` フィールドは継承されませんが、これに"
"含まれるフィールドが個別に継承されます。"

#: ../../c-api/typeobj.rst:853
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the mapping protocol.  These fields are documented "
"in :ref:`mapping-structs`."
msgstr ""
"マッピングプロトコルを実装した追加の構造体を指すポインタです。これらのフィー"
"ルドについては :ref:`mapping-structs` で説明されています。"

#: ../../c-api/typeobj.rst:859
msgid ""
"The :c:member:`~PyTypeObject.tp_as_mapping` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
":c:member:`~PyTypeObject.tp_as_mapping` フィールドは継承されませんが、これに"
"含まれるフィールドが個別に継承されます。"

#: ../../c-api/typeobj.rst:867
msgid ""
"An optional pointer to a function that implements the built-in function :"
"func:`hash`."
msgstr ""
"オプションのポインタで、組み込み関数 :func:`hash` を実装している関数を指しま"
"す。"

#: ../../c-api/typeobj.rst:870
msgid "The signature is the same as for :c:func:`PyObject_Hash`::"
msgstr ""

#: ../../c-api/typeobj.rst:874
msgid ""
"The value ``-1`` should not be returned as a normal return value; when an "
"error occurs during the computation of the hash value, the function should "
"set an exception and return ``-1``."
msgstr ""
"この関数は C の :c:type:`long` 型の値を返さねばなりません。通常時には ``-1`` "
"を戻り値にしてはなりません; ハッシュ値の計算中にエラーが生じた場合、関数は例"
"外をセットして ``-1`` を返さねばなりません。"

#: ../../c-api/typeobj.rst:878
msgid ""
"When this field is not set (*and* :attr:`tp_richcompare` is not set), an "
"attempt to take the hash of the object raises :exc:`TypeError`. This is the "
"same as setting it to :c:func:`PyObject_HashNotImplemented`."
msgstr ""

#: ../../c-api/typeobj.rst:882
msgid ""
"This field can be set explicitly to :c:func:`PyObject_HashNotImplemented` to "
"block inheritance of the hash method from a parent type. This is interpreted "
"as the equivalent of ``__hash__ = None`` at the Python level, causing "
"``isinstance(o, collections.Hashable)`` to correctly return ``False``. Note "
"that the converse is also true - setting ``__hash__ = None`` on a class at "
"the Python level will result in the ``tp_hash`` slot being set to :c:func:"
"`PyObject_HashNotImplemented`."
msgstr ""
"このフィールドは明示的に :c:func:`PyObject_HashNotImplemented` に設定すること"
"で、親 type からのハッシュメソッドの継承をブロックすることができます。これは "
"Python レベルでの ``__hash__ = None`` と同等に解釈され、 ``isinstance(o, "
"collections.Hashable)`` が正しく ``False`` を返すようになります。逆もまた可能"
"であることに注意してください - Python レベルで ``__hash__ = None`` を設定する"
"ことで ``tp_hash`` スロットは :c:func:`PyObject_HashNotImplemented` に設定さ"
"れます。"

#: ../../c-api/typeobj.rst:892 ../../c-api/typeobj.rst:1379
msgid "Group: :attr:`tp_hash`, :attr:`tp_richcompare`"
msgstr ""

#: ../../c-api/typeobj.rst:894
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_richcompare`: a subtype inherits both of :c:member:`~PyTypeObject."
"tp_richcompare` and :c:member:`~PyTypeObject.tp_hash`, when the subtype's :c:"
"member:`~PyTypeObject.tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` "
"are both ``NULL``."
msgstr ""
"このフィールドは :c:member:`~PyTypeObject.tp_richcompare` と共にサブタイプに"
"継承されます: すなわち、サブタイプの :c:member:`~PyTypeObject."
"tp_richcompare` および :c:member:`~PyTypeObject.tp_hash` が両方とも ``NULL`` "
"のとき、サブタイプは基底タイプから :c:member:`~PyTypeObject.tp_richcompare` "
"と :c:member:`~PyTypeObject.tp_hash` を両方とも継承します。"

#: ../../c-api/typeobj.rst:902
msgid ""
"An optional pointer to a function that implements calling the object.  This "
"should be ``NULL`` if the object is not callable.  The signature is the same "
"as for :c:func:`PyObject_Call`::"
msgstr ""
"オプションのポインタで、オブジェクトの呼び出しを実装している関数を指します。"
"オブジェクトが呼び出し可能でない場合には ``NULL`` にしなければなりません。シ"
"グネチャは :c:func:`PyObject_Call` と同じです。"

#: ../../c-api/typeobj.rst:915
msgid ""
"An optional pointer to a function that implements the built-in operation :"
"func:`str`.  (Note that :class:`str` is a type now, and :func:`str` calls "
"the constructor for that type.  This constructor calls :c:func:"
"`PyObject_Str` to do the actual work, and :c:func:`PyObject_Str` will call "
"this handler.)"
msgstr ""
"オプションのポインタで、組み込みの演算 :func:`str` を実装している関数を指しま"
"す。(:class:`str` が型の一つになったため、 :func:`str` は :class:`str` のコン"
"ストラクタを呼び出すことに注意してください。このコンストラクタは実際の処理を"
"行う上で :c:func:`PyObject_Str` を呼び出し、さらに :c:func:`PyObject_Str` が"
"このハンドラを呼び出すことになります。)"

#: ../../c-api/typeobj.rst:920
msgid "The signature is the same as for :c:func:`PyObject_Str`::"
msgstr ""

#: ../../c-api/typeobj.rst:924
msgid ""
"The function must return a string or a Unicode object.  It should be a "
"\"friendly\" string representation of the object, as this is the "
"representation that will be used, among other things, by the :func:`print` "
"function."
msgstr ""
"この関数は文字列オブジェクトか Unicode オブジェクトを返さなければなりません。"
"それはオブジェクトを \"分かりやすく (friendly)\" 表現した文字列でなければなり"
"ません。というのは、この文字列はとりわけ :func:`print` 関数で使われることにな"
"る表記だからです。"

#: ../../c-api/typeobj.rst:934
msgid ""
"When this field is not set, :c:func:`PyObject_Repr` is called to return a "
"string representation."
msgstr ""
"このフィールドが設定されていない場合、文字列表現を返すためには :c:func:"
"`PyObject_Repr` が呼び出されます。"

#: ../../c-api/typeobj.rst:940
msgid "An optional pointer to the get-attribute function."
msgstr "オプションのポインタで、get-attribute を実装している関数を指します。"

#: ../../c-api/typeobj.rst:942
msgid "The signature is the same as for :c:func:`PyObject_GetAttr`::"
msgstr ""

#: ../../c-api/typeobj.rst:946
msgid ""
"It is usually convenient to set this field to :c:func:"
"`PyObject_GenericGetAttr`, which implements the normal way of looking for "
"object attributes."
msgstr ""
"通常の属性検索を実装している :c:func:`PyObject_GenericGetAttr`  をこのフィー"
"ルドに設定しておくとたいていの場合は便利です。"

#: ../../c-api/typeobj.rst:953
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_getattr`: a subtype inherits both :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject."
"tp_getattro` are both ``NULL``."
msgstr ""
"このフィールドは :c:member:`~PyTypeObject.tp_getattr` と共にサブタイプに継承"
"されます: すなわち、サブタイプの :c:member:`~PyTypeObject.tp_getattr` およ"
"び :c:member:`~PyTypeObject.tp_getattro` が共に ``NULL`` の場合、サブタイプは"
"基底タイプから :c:member:`~PyTypeObject.tp_getattr` と :c:member:"
"`~PyTypeObject.tp_getattro` を両方とも継承します。"

#: ../../c-api/typeobj.rst:959
msgid ":c:type:`PyBaseObject_Type` uses :c:func:`PyObject_GenericGetAttr`."
msgstr ""

#: ../../c-api/typeobj.rst:966
msgid "The signature is the same as for :c:func:`PyObject_SetAttr`::"
msgstr ""

#: ../../c-api/typeobj.rst:970
msgid ""
"In addition, setting *value* to ``NULL`` to delete an attribute must be "
"supported.  It is usually convenient to set this field to :c:func:"
"`PyObject_GenericSetAttr`, which implements the normal way of setting object "
"attributes."
msgstr ""
"さらに、*value* に ``NULL`` を指定して属性を削除できるようにしなければなりま"
"せん。\n"
"通常のオブジェクト属性設定を実装している :c:func:`PyObject_GenericSetAttr`  "
"をこのフィールドに設定しておくとたいていの場合は便利です。"

#: ../../c-api/typeobj.rst:979
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_setattr`: a subtype inherits both :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject."
"tp_setattro` are both ``NULL``."
msgstr ""
"このフィールドは :c:member:`~PyTypeObject.tp_setattr` と共にサブタイプに継承"
"されます: すなわち、サブタイプの :c:member:`~PyTypeObject.tp_setattr` およ"
"び :c:member:`~PyTypeObject.tp_setattro` が共に ``NULL`` の場合、サブタイプは"
"基底タイプから :c:member:`~PyTypeObject.tp_setattr` と :c:member:"
"`~PyTypeObject.tp_setattro` を両方とも継承します。"

#: ../../c-api/typeobj.rst:985
msgid ":c:type:`PyBaseObject_Type` uses :c:func:`PyObject_GenericSetAttr`."
msgstr ""

#: ../../c-api/typeobj.rst:990
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the buffer interface.  These fields are documented "
"in :ref:`buffer-structs`."
msgstr ""
"バッファインタフェースを実装しているオブジェクトにのみ関連する、一連のフィー"
"ルド群が入った別の構造体を指すポインタです。構造体内の各フィールドは :ref:"
"`buffer-structs` で説明します。"

#: ../../c-api/typeobj.rst:996
msgid ""
"The :c:member:`~PyTypeObject.tp_as_buffer` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
":c:member:`~PyTypeObject.tp_as_buffer` フィールド自体は継承されませんが、これ"
"に含まれるフィールドは個別に継承されます。"

#: ../../c-api/typeobj.rst:1002
msgid ""
"This field is a bit mask of various flags.  Some flags indicate variant "
"semantics for certain situations; others are used to indicate that certain "
"fields in the type object (or in the extension structures referenced via :c:"
"member:`~PyTypeObject.tp_as_number`, :c:member:`~PyTypeObject."
"tp_as_sequence`, :c:member:`~PyTypeObject.tp_as_mapping`, and :c:member:"
"`~PyTypeObject.tp_as_buffer`) that were historically not always present are "
"valid; if such a flag bit is clear, the type fields it guards must not be "
"accessed and must be considered to have a zero or ``NULL`` value instead."
msgstr ""
"このフィールドは様々なフラグからなるビットマスクです。いくつかのフラグは、特"
"定の状況において変則的なセマンティクスが適用されることを示します; その他のフ"
"ラグは、型オブジェクト (あるいは :c:member:`~PyTypeObject.tp_as_number` 、 :"
"c:member:`~PyTypeObject.tp_as_sequence` 、 :c:member:`~PyTypeObject."
"tp_as_mapping` 、 および :c:member:`~PyTypeObject.tp_as_buffer` が参照してい"
"る拡張機能構造体) の特定のフィールドのうち、過去から現在までずっと存在してい"
"たわけではないものが有効になっていることを示すために使われます; フラグビット"
"がクリアされていれば、フラグが保護しているフィールドにはアクセスしない代わり"
"に、その値はゼロか ``NULL`` になっているとみなさなければなりません。"

#: ../../c-api/typeobj.rst:1012
msgid ""
"Inheritance of this field is complicated.  Most flag bits are inherited "
"individually, i.e. if the base type has a flag bit set, the subtype inherits "
"this flag bit.  The flag bits that pertain to extension structures are "
"strictly inherited if the extension structure is inherited, i.e. the base "
"type's value of the flag bit is copied into the subtype together with a "
"pointer to the extension structure.  The :const:`Py_TPFLAGS_HAVE_GC` flag "
"bit is inherited together with the :c:member:`~PyTypeObject.tp_traverse` "
"and :c:member:`~PyTypeObject.tp_clear` fields, i.e. if the :const:"
"`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and the :c:member:"
"`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear` fields in "
"the subtype exist and have ``NULL`` values."
msgstr ""
"このフィールドの継承は込み入っています。ほとんどのフラグは個別に継承されま"
"す。すなわち、基底タイプのフラグビットが設定されていたら、サブタイプのフラグ"
"ビットもそれを引き継ぎます。拡張機能構造体が継承される場合は、拡張機能構造体"
"に関係するフラグビットは厳密に継承されます。すなわち、基底タイプのフラグビッ"
"トの値は、拡張機能構造体へのポインタと共に、サブタイプにコピーされます。 :"
"const:`Py_TPFLAGS_HAVE_GC` フラグビットは :c:member:`~PyTypeObject."
"tp_traverse` フィールドと :c:member:`~PyTypeObject.tp_clear` フィールドと共に"
"継承されます。すなわち、サブタイプにおいて、 :const:`Py_TPFLAGS_HAVE_GC` フラ"
"グビットがクリアされていて、 :c:member:`~PyTypeObject.tp_traverse` フィールド"
"と :c:member:`~PyTypeObject.tp_clear` フィールドが存在し ``NULL`` になってい"
"る場合に継承されます。"

#: ../../c-api/typeobj.rst:1027
msgid ""
":c:type:`PyBaseObject_Type` uses ``Py_TPFLAGS_DEFAULT | "
"Py_TPFLAGS_BASETYPE``."
msgstr ""

#: ../../c-api/typeobj.rst:1030
msgid "**Bit Masks:**"
msgstr ""

#: ../../c-api/typeobj.rst:1032
msgid ""
"The following bit masks are currently defined; these can be ORed together "
"using the ``|`` operator to form the value of the :c:member:`~PyTypeObject."
"tp_flags` field.  The macro :c:func:`PyType_HasFeature` takes a type and a "
"flags value, *tp* and *f*, and checks whether ``tp->tp_flags & f`` is non-"
"zero."
msgstr ""
"以下に挙げるビットマスクは現在定義されているものです; フラグは ``|`` 演算子で"
"論理和を取って :c:member:`~PyTypeObject.tp_flags` フィールドの値を作成できま"
"す。 :c:func:`PyType_HasFeature` マクロは型とフラグ値、 *tp* および *f* をと"
"り、 ``tp->tp_flags & f`` が非ゼロかどうか調べます。"

#: ../../c-api/typeobj.rst:1039
msgid ""
"This bit is set when the type object itself is allocated on the heap, for "
"example, types created dynamically using :c:func:`PyType_FromSpec`.  In this "
"case, the :attr:`ob_type` field of its instances is considered a reference "
"to the type, and the type object is INCREF'ed when a new instance is "
"created, and DECREF'ed when an instance is destroyed (this does not apply to "
"instances of subtypes; only the type referenced by the instance's ob_type "
"gets INCREF'ed or DECREF'ed)."
msgstr ""

#: ../../c-api/typeobj.rst:1049 ../../c-api/typeobj.rst:1060
#: ../../c-api/typeobj.rst:1070 ../../c-api/typeobj.rst:1080
#: ../../c-api/typeobj.rst:1113
msgid "???"
msgstr ""

#: ../../c-api/typeobj.rst:1054
msgid ""
"This bit is set when the type can be used as the base type of another type.  "
"If this bit is clear, the type cannot be subtyped (similar to a \"final\" "
"class in Java)."
msgstr ""
"型を別の型の基底タイプとして使える場合にセットされるビットです。このビットが"
"クリアならば、この型のサブタイプは生成できません (Java における \"final\" ク"
"ラスに似たクラスになります)。"

#: ../../c-api/typeobj.rst:1065
msgid ""
"This bit is set when the type object has been fully initialized by :c:func:"
"`PyType_Ready`."
msgstr ""
"型オブジェクトが :c:func:`PyType_Ready` で完全に初期化されるとセットされる"
"ビットです。"

#: ../../c-api/typeobj.rst:1075
msgid ""
"This bit is set while :c:func:`PyType_Ready` is in the process of "
"initializing the type object."
msgstr ""
":c:func:`PyType_Ready` による型オブジェクトの初期化処理中にセットされるビット"
"です。"

#: ../../c-api/typeobj.rst:1085
msgid ""
"This bit is set when the object supports garbage collection.  If this bit is "
"set, instances must be created using :c:func:`PyObject_GC_New` and destroyed "
"using :c:func:`PyObject_GC_Del`.  More information in section :ref:"
"`supporting-cycle-detection`.  This bit also implies that the GC-related "
"fields :c:member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject."
"tp_clear` are present in the type object."
msgstr ""
"オブジェクトがガベージコレクション (GC) をサポートする場合にセットされるビッ"
"トです。このビットがセットされている場合、インスタンスは :c:func:"
"`PyObject_GC_New` を使って生成し、 :c:func:`PyObject_GC_Del` を使って破棄しな"
"ければなりません。詳しい情報は :ref:`supporting-cycle-detection` にあります。"
"このビットは、GC に関連するフィールド :c:member:`~PyTypeObject.tp_traverse` "
"および :c:member:`~PyTypeObject.tp_clear` が型オブジェクト内に存在することも"
"示しています。"

#: ../../c-api/typeobj.rst:1094 ../../c-api/typeobj.rst:1259
#: ../../c-api/typeobj.rst:1320
msgid ""
"Group: :const:`Py_TPFLAGS_HAVE_GC`, :attr:`tp_traverse`, :attr:`tp_clear`"
msgstr ""

#: ../../c-api/typeobj.rst:1096
msgid ""
"The :const:`Py_TPFLAGS_HAVE_GC` flag bit is inherited together with the :"
"attr:`tp_traverse` and :attr:`tp_clear` fields, i.e.  if the :const:"
"`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and the :attr:"
"`tp_traverse` and :attr:`tp_clear` fields in the subtype exist and have "
"``NULL`` values."
msgstr ""

#: ../../c-api/typeobj.rst:1106
msgid ""
"This is a bitmask of all the bits that pertain to the existence of certain "
"fields in the type object and its extension structures. Currently, it "
"includes the following bits: :const:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`, :"
"const:`Py_TPFLAGS_HAVE_VERSION_TAG`."
msgstr ""
"型オブジェクトおよび拡張機能構造体の特定のフィールドの存在の有無に関連する全"
"てのビットからなるビットマスクです。現状では、このビットマスクには以下のビッ"
"ト: :const:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION` および :const:"
"`Py_TPFLAGS_HAVE_VERSION_TAG` が入っています。"

#: ../../c-api/typeobj.rst:1118
msgid "This bit indicates that objects behave like unbound methods."
msgstr ""

#: ../../c-api/typeobj.rst:1120
msgid "If this flag is set for ``type(meth)``, then:"
msgstr ""

#: ../../c-api/typeobj.rst:1122
msgid ""
"``meth.__get__(obj, cls)(*args, **kwds)`` (with ``obj`` not None) must be "
"equivalent to ``meth(obj, *args, **kwds)``."
msgstr ""

#: ../../c-api/typeobj.rst:1125
msgid ""
"``meth.__get__(None, cls)(*args, **kwds)`` must be equivalent to "
"``meth(*args, **kwds)``."
msgstr ""

#: ../../c-api/typeobj.rst:1128
msgid ""
"This flag enables an optimization for typical method calls like ``obj."
"meth()``: it avoids creating a temporary \"bound method\" object for ``obj."
"meth``."
msgstr ""

#: ../../c-api/typeobj.rst:1136
msgid ""
"This flag is never inherited by heap types. For extension types, it is "
"inherited whenever :c:member:`~PyTypeObject.tp_descr_get` is inherited."
msgstr ""

#: ../../c-api/typeobj.rst:1153
msgid ""
"These flags are used by functions such as :c:func:`PyLong_Check` to quickly "
"determine if a type is a subclass of a built-in type; such specific checks "
"are faster than a generic check, like :c:func:`PyObject_IsInstance`. Custom "
"types that inherit from built-ins should have their :c:member:`~PyTypeObject."
"tp_flags` set appropriately, or the code that interacts with such types will "
"behave differently depending on what kind of check is used."
msgstr ""
"これらのフラグは :c:func:`PyLong_Check` のような関数が、型がとある組み込み型"
"のサブクラスかどうかを素早く判断するのに使われます;\n"
"この専用のチェックは :c:func:`PyObject_IsInstance` のような汎用的なチェックよ"
"りも高速です。\n"
"組み込み型を継承した独自の型では :c:member:`~PyTypeObject.tp_flags` を適切に"
"設定すべきで、そうしないとその型が関わるコードでは、どんなチェックの方法が使"
"われるかによって振る舞いが異なってしまうでしょう。"

#: ../../c-api/typeobj.rst:1164
msgid ""
"This bit is set when the :c:member:`~PyTypeObject.tp_finalize` slot is "
"present in the type structure."
msgstr ""
"型構造体に :c:member:`~PyTypeObject.tp_finalize` スロットが存在しているときに"
"セットされるビットです。"

#: ../../c-api/typeobj.rst:1169
msgid ""
"This flag isn't necessary anymore, as the interpreter assumes the :c:member:"
"`~PyTypeObject.tp_finalize` slot is always present in the type structure."
msgstr ""

#: ../../c-api/typeobj.rst:1176
msgid ""
"This bit is set when the class implements the vectorcall protocol. See :c:"
"member:`~PyTypeObject.tp_vectorcall_offset` for details."
msgstr ""

#: ../../c-api/typeobj.rst:1181
msgid ""
"This bit is set on *static* subtypes if ``tp_flags`` is not overridden: a "
"subtype inherits ``_Py_TPFLAGS_HAVE_VECTORCALL`` from its base type when the "
"subtype’s :c:member:`~PyTypeObject.tp_call` is ``NULL`` and the subtype's "
"``Py_TPFLAGS_HEAPTYPE`` is not set."
msgstr ""

#: ../../c-api/typeobj.rst:1186
msgid "`Heap types`_ do not inherit ``_Py_TPFLAGS_HAVE_VECTORCALL``."
msgstr ""

#: ../../c-api/typeobj.rst:1190
msgid ""
"This flag is provisional and expected to become public in Python 3.9, with a "
"different name and, possibly, changed semantics. If you use vectorcall, plan "
"for updating your code for Python 3.9."
msgstr ""

#: ../../c-api/typeobj.rst:1199
msgid ""
"An optional pointer to a NUL-terminated C string giving the docstring for "
"this type object.  This is exposed as the :attr:`__doc__` attribute on the "
"type and instances of the type."
msgstr ""
"オプションのポインタで、この型オブジェクトの docstring を与える NUL 終端され"
"た C の文字列を指します。この値は型オブジェクトと型のインスタンスにおける :"
"attr:`__doc__` 属性として公開されます。"

#: ../../c-api/typeobj.rst:1205
msgid "This field is *not* inherited by subtypes."
msgstr "サブタイプはこのフィールドを継承 *しません* 。"

#: ../../c-api/typeobj.rst:1210
msgid ""
"An optional pointer to a traversal function for the garbage collector.  This "
"is only used if the :const:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The "
"signature is::"
msgstr ""

#: ../../c-api/typeobj.rst:1215 ../../c-api/typeobj.rst:1315
msgid ""
"More information about Python's garbage collection scheme can be found in "
"section :ref:`supporting-cycle-detection`."
msgstr ""
"Pythonのガベージコレクションの仕組みについての詳細は、 :ref:`supporting-"
"cycle-detection` にあります。"

#: ../../c-api/typeobj.rst:1218
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` pointer is used by the garbage "
"collector to detect reference cycles. A typical implementation of a :c:"
"member:`~PyTypeObject.tp_traverse` function simply calls :c:func:`Py_VISIT` "
"on each of the instance's members that are Python objects that the instance "
"owns. For example, this is function :c:func:`local_traverse` from the :mod:"
"`_thread` extension module::"
msgstr ""

#: ../../c-api/typeobj.rst:1233
msgid ""
"Note that :c:func:`Py_VISIT` is called only on those members that can "
"participate in reference cycles.  Although there is also a ``self->key`` "
"member, it can only be ``NULL`` or a Python string and therefore cannot be "
"part of a reference cycle."
msgstr ""
":c:func:`Py_VISIT` が循環参照になる恐れのあるメンバにだけ呼び出されていること"
"に注目してください。 ``self->key`` メンバもありますが、それは ``NULL`` か "
"Python文字列なので、循環参照の一部になることはありません。"

#: ../../c-api/typeobj.rst:1237
msgid ""
"On the other hand, even if you know a member can never be part of a cycle, "
"as a debugging aid you may want to visit it anyway just so the :mod:`gc` "
"module's :func:`~gc.get_referents` function will include it."
msgstr ""
"一方、メンバが循環参照の一部になり得ないと判っていても、デバッグ目的で巡回し"
"たい場合があるかもしれないので、 :mod:`gc` モジュールの :func:`~gc."
"get_referents` 関数は循環参照になり得ないメンバも返します。"

#: ../../c-api/typeobj.rst:1242
msgid ""
"When implementing :c:member:`~PyTypeObject.tp_traverse`, only the members "
"that the instance *owns* (by having strong references to them) must be "
"visited. For instance, if an object supports weak references via the :c:"
"member:`~PyTypeObject.tp_weaklist` slot, the pointer supporting the linked "
"list (what *tp_weaklist* points to) must **not** be visited as the instance "
"does not directly own the weak references to itself (the weakreference list "
"is there to support the weak reference machinery, but the instance has no "
"strong reference to the elements inside it, as they are allowed to be "
"removed even if the instance is still alive)."
msgstr ""

#: ../../c-api/typeobj.rst:1253
msgid ""
"Note that :c:func:`Py_VISIT` requires the *visit* and *arg* parameters to :c:"
"func:`local_traverse` to have these specific names; don't name them just "
"anything."
msgstr ""
":c:func:`Py_VISIT` は :c:func:`local_traverse` が *visit* と *arg* という決"
"まった名前の引数を持つことを要求します。"

#: ../../c-api/typeobj.rst:1261
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_clear` and the :const:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :c:"
"member:`~PyTypeObject.tp_traverse`, and :c:member:`~PyTypeObject.tp_clear` "
"are all inherited from the base type if they are all zero in the subtype."
msgstr ""
"このフィールドは :c:member:`~PyTypeObject.tp_clear` および :const:"
"`Py_TPFLAGS_HAVE_GC` フラグビットと共にサブタイプに継承されます: すなわち、サ"
"ブタイプの :c:member:`~PyTypeObject.tp_traverse` および :c:member:"
"`~PyTypeObject.tp_clear` が両方ともゼロの場合、サブタイプは基底タイプから :c:"
"member:`~PyTypeObject.tp_traverse` と :c:member:`~PyTypeObject.tp_clear` を両"
"方とも継承します。"

#: ../../c-api/typeobj.rst:1269
msgid ""
"An optional pointer to a clear function for the garbage collector. This is "
"only used if the :const:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The signature "
"is::"
msgstr ""
"オプションのポインタで、ガベージコレクタにおける消去関数 (clear function) を"
"指します。 :const:`Py_TPFLAGS_HAVE_GC` がセットされている場合にのみ使われま"
"す。シグネチャは次の通りです::"

#: ../../c-api/typeobj.rst:1274
msgid ""
"The :c:member:`~PyTypeObject.tp_clear` member function is used to break "
"reference cycles in cyclic garbage detected by the garbage collector.  Taken "
"together, all :c:member:`~PyTypeObject.tp_clear` functions in the system "
"must combine to break all reference cycles.  This is subtle, and if in any "
"doubt supply a :c:member:`~PyTypeObject.tp_clear` function.  For example, "
"the tuple type does not implement a :c:member:`~PyTypeObject.tp_clear` "
"function, because it's possible to prove that no reference cycle can be "
"composed entirely of tuples. Therefore the :c:member:`~PyTypeObject."
"tp_clear` functions of other types must be sufficient to break any cycle "
"containing a tuple.  This isn't immediately obvious, and there's rarely a "
"good reason to avoid implementing :c:member:`~PyTypeObject.tp_clear`."
msgstr ""
":c:member:`~PyTypeObject.tp_clear` メンバ関数は GC が検出した循環しているゴミ"
"の循環参照を壊すために用いられます。総合的な視点で考えると、システム内の全て"
"の :c:member:`~PyTypeObject.tp_clear` 関数が連携して、全ての循環参照を破壊し"
"なければなりません。 (訳注: ある型が :c:member:`~PyTypeObject.tp_clear` を実"
"装しなくても全ての循環参照が破壊できるのであれば実装しなくても良い) これはと"
"ても繊細で、もし少しでも不確かな部分があるのであれば、 :c:member:"
"`~PyTypeObject.tp_clear` 関数を提供するべきです。例えば、タプルは :c:member:"
"`~PyTypeObject.tp_clear` を実装しません。なぜなら、タプルだけで構成された循環"
"参照がみつかることは無いからです。従って、タプル以外の型の :c:member:"
"`~PyTypeObject.tp_clear` 関数だけで、タプルを含むどんな循環参照も必ず破壊でき"
"ることになります。これは簡単に判ることではなく、 :c:member:`~PyTypeObject."
"tp_clear` の実装を避ける良い理由はめったにありません。"

#: ../../c-api/typeobj.rst:1284
msgid ""
"Implementations of :c:member:`~PyTypeObject.tp_clear` should drop the "
"instance's references to those of its members that may be Python objects, "
"and set its pointers to those members to ``NULL``, as in the following "
"example::"
msgstr ""
"次の例にあるように、 :c:member:`~PyTypeObject.tp_clear` の実装は、インスタン"
"スから Python オブジェクトだと思われるメンバへの参照を外し、それらのメンバへ"
"のポインタに ``NULL`` をセットすべきです::"

#: ../../c-api/typeobj.rst:1298
msgid ""
"The :c:func:`Py_CLEAR` macro should be used, because clearing references is "
"delicate:  the reference to the contained object must not be decremented "
"until after the pointer to the contained object is set to ``NULL``.  This is "
"because decrementing the reference count may cause the contained object to "
"become trash, triggering a chain of reclamation activity that may include "
"invoking arbitrary Python code (due to finalizers, or weakref callbacks, "
"associated with the contained object). If it's possible for such code to "
"reference *self* again, it's important that the pointer to the contained "
"object be ``NULL`` at that time, so that *self* knows the contained object "
"can no longer be used.  The :c:func:`Py_CLEAR` macro performs the operations "
"in a safe order."
msgstr ""
"参照のクリアはデリケートなので、 :c:func:`Py_CLEAR` マクロを使うべきです: ポ"
"インタを ``NULL`` にセットするまで、そのオブジェクトの参照カウントをデクリメ"
"ントしてはいけません。参照カウントのデクリメントすると、そのオブジェクトが破"
"棄されるかもしれず、 (そのオブジェクトに関連付けられたファイナライザ、弱参照"
"のコールバックにより) 任意のPythonコードの実行を含む後片付け処理が実行される"
"かもしれないからです。もしそういったコードが再び *self* を参照することがあれ"
"ば、すでに持っていたオブジェクトへのポインタは ``NULL`` になっているので、 "
"*self* は所有していたオブジェクトをもう利用できないことを認識できます。 :c:"
"func:`Py_CLEAR` マクロはその手続きを安全な順番で実行します。"

#: ../../c-api/typeobj.rst:1309
msgid ""
"Because the goal of :c:member:`~PyTypeObject.tp_clear` functions is to break "
"reference cycles, it's not necessary to clear contained objects like Python "
"strings or Python integers, which can't participate in reference cycles. On "
"the other hand, it may be convenient to clear all contained Python objects, "
"and write the type's :c:member:`~PyTypeObject.tp_dealloc` function to "
"invoke :c:member:`~PyTypeObject.tp_clear`."
msgstr ""
":c:member:`~PyTypeObject.tp_clear` 関数の目的は参照カウントを破壊することなの"
"で、 Python 文字列や Python 整数のような、循環参照に含むことのできないオブ"
"ジェクトをクリアする必要はありません。一方、所有する全ての Python オブジェク"
"トをクリアするようにし、その型の :c:member:`~PyTypeObject.tp_dealloc` 関数"
"が :c:member:`~PyTypeObject.tp_clear` 関数を実行するようにすると実装が楽にな"
"るでしょう。"

#: ../../c-api/typeobj.rst:1322
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_traverse` and the :const:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :c:"
"member:`~PyTypeObject.tp_traverse`, and :c:member:`~PyTypeObject.tp_clear` "
"are all inherited from the base type if they are all zero in the subtype."
msgstr ""
"このフィールドは :c:member:`~PyTypeObject.tp_traverse` および :const:"
"`Py_TPFLAGS_HAVE_GC` フラグビットと共にサブタイプに継承されます: すなわち、サ"
"ブタイプの :c:member:`~PyTypeObject.tp_traverse` および :c:member:"
"`~PyTypeObject.tp_clear` が両方ともゼロの場合、サブタイプは基底タイプから :c:"
"member:`~PyTypeObject.tp_traverse` と :c:member:`~PyTypeObject.tp_clear` を両"
"方とも継承します。"

#: ../../c-api/typeobj.rst:1330
msgid ""
"An optional pointer to the rich comparison function, whose signature is::"
msgstr ""
"オプションのポインタで、拡張比較関数を指します。シグネチャは次の通りです::"

#: ../../c-api/typeobj.rst:1334
msgid ""
"The first parameter is guaranteed to be an instance of the type that is "
"defined by :c:type:`PyTypeObject`."
msgstr ""

#: ../../c-api/typeobj.rst:1337
msgid ""
"The function should return the result of the comparison (usually ``Py_True`` "
"or ``Py_False``).  If the comparison is undefined, it must return "
"``Py_NotImplemented``, if another error occurred it must return ``NULL`` and "
"set an exception condition."
msgstr ""
"この関数は、比較結果を返すべきです。(普通は ``Py_True`` か ``Py_False`` で"
"す。) 比較が未定義の場合は、``Py_NotImplemented`` を、それ以外のエラーが発生"
"した場合には例外状態をセットして ``NULL`` を返さなければなりません。"

#: ../../c-api/typeobj.rst:1342
msgid ""
"The following constants are defined to be used as the third argument for :c:"
"member:`~PyTypeObject.tp_richcompare` and for :c:func:`PyObject_RichCompare`:"
msgstr ""
":c:member:`~PyTypeObject.tp_richcompare` および :c:func:"
"`PyObject_RichCompare` 関数の第三引数に使うための定数としては以下が定義されて"
"います:"

#: ../../c-api/typeobj.rst:1346
msgid "Constant"
msgstr "定数"

#: ../../c-api/typeobj.rst:1346
msgid "Comparison"
msgstr "比較"

#: ../../c-api/typeobj.rst:1348
msgid ":const:`Py_LT`"
msgstr ":const:`Py_LT`"

#: ../../c-api/typeobj.rst:1348
msgid "``<``"
msgstr "``<``"

#: ../../c-api/typeobj.rst:1350
msgid ":const:`Py_LE`"
msgstr ":const:`Py_LE`"

#: ../../c-api/typeobj.rst:1350
msgid "``<=``"
msgstr "``<=``"

#: ../../c-api/typeobj.rst:1352
msgid ":const:`Py_EQ`"
msgstr ":const:`Py_EQ`"

#: ../../c-api/typeobj.rst:1352
msgid "``==``"
msgstr "``==``"

#: ../../c-api/typeobj.rst:1354
msgid ":const:`Py_NE`"
msgstr ":const:`Py_NE`"

#: ../../c-api/typeobj.rst:1354
msgid "``!=``"
msgstr "``!=``"

#: ../../c-api/typeobj.rst:1356
msgid ":const:`Py_GT`"
msgstr ":const:`Py_GT`"

#: ../../c-api/typeobj.rst:1356
msgid "``>``"
msgstr "``>``"

#: ../../c-api/typeobj.rst:1358
msgid ":const:`Py_GE`"
msgstr ":const:`Py_GE`"

#: ../../c-api/typeobj.rst:1358
msgid "``>=``"
msgstr "``>=``"

#: ../../c-api/typeobj.rst:1361
msgid ""
"The following macro is defined to ease writing rich comparison functions:"
msgstr ""
"拡張比較関数(rich comparison functions)を簡単に記述するためのマクロが定義され"
"ています:"

#: ../../c-api/typeobj.rst:1365
msgid ""
"Return ``Py_True`` or ``Py_False`` from the function, depending on the "
"result of a comparison. VAL_A and VAL_B must be orderable by C comparison "
"operators (for example, they may be C ints or floats). The third argument "
"specifies the requested operation, as for :c:func:`PyObject_RichCompare`."
msgstr ""
"比較した結果に応じて ``Py_True` か `Py_False` を返します。\n"
"VAL_A と VAL_B は C の比較演算によって順序付け可能でなければなりません（例え"
"ばこれらは C言語の整数か浮動小数点数になるでしょう）。三番目の引数には :c:"
"func:`PyObject_RichCompare` と同様に要求された演算を指定します。"

#: ../../c-api/typeobj.rst:1371
msgid "The return value's reference count is properly incremented."
msgstr "返り値の参照カウントは適切にインクリメントされます。"

#: ../../c-api/typeobj.rst:1373
msgid "On error, sets an exception and returns ``NULL`` from the function."
msgstr "エラー時には、例外を設定して、関数から ``NULL`` でリターンします。"

#: ../../c-api/typeobj.rst:1381
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_hash`: a subtype inherits :c:member:`~PyTypeObject.tp_richcompare` and :c:"
"member:`~PyTypeObject.tp_hash` when the subtype's :c:member:`~PyTypeObject."
"tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` are both ``NULL``."
msgstr ""
"このフィールドは :c:member:`~PyTypeObject.tp_hash` と共にサブタイプに継承され"
"ます: すなわち、サブタイプの :c:member:`~PyTypeObject.tp_richcompare` およ"
"び :c:member:`~PyTypeObject.tp_hash` が両方とも ``NULL`` のとき、サブタイプは"
"基底タイプから :c:member:`~PyTypeObject.tp_richcompare` と :c:member:"
"`~PyTypeObject.tp_hash` を両方とも継承します。"

#: ../../c-api/typeobj.rst:1388
msgid ""
":c:type:`PyBaseObject_Type` provides a :attr:`tp_richcompare` "
"implementation, which may be inherited.  However, if only :attr:`tp_hash` is "
"defined, not even the inherited function is used and instances of the type "
"will not be able to participate in any comparisons."
msgstr ""

#: ../../c-api/typeobj.rst:1397
msgid ""
"If the instances of this type are weakly referenceable, this field is "
"greater than zero and contains the offset in the instance structure of the "
"weak reference list head (ignoring the GC header, if present); this offset "
"is used by :c:func:`PyObject_ClearWeakRefs` and the :c:func:`PyWeakref_\\*` "
"functions.  The instance structure needs to include a field of type :c:type:"
"`PyObject*` which is initialized to ``NULL``."
msgstr ""

#: ../../c-api/typeobj.rst:1404
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_weaklist`; that "
"is the list head for weak references to the type object itself."
msgstr ""
"このフィールドを :c:member:`~PyTypeObject.tp_weaklist` と混同しないようにして"
"ください; これは型オブジェクト自身への弱参照からなるリストの先頭です。"

#: ../../c-api/typeobj.rst:1409
msgid ""
"This field is inherited by subtypes, but see the rules listed below. A "
"subtype may override this offset; this means that the subtype uses a "
"different weak reference list head than the base type.  Since the list head "
"is always found via :c:member:`~PyTypeObject.tp_weaklistoffset`, this should "
"not be a problem."
msgstr ""
"このフィールドはサブタイプに継承されますが、以下の規則を読んでください。サブ"
"タイプはこのオフセット値をオーバライドすることがあります; 従って、サブタイプ"
"では弱参照リストの先頭が基底タイプとは異なる場合があります。リストの先頭は常"
"に :c:member:`~PyTypeObject.tp_weaklistoffset` で分かるはずなので、このことは"
"問題にはならないはずです。"

#: ../../c-api/typeobj.rst:1414
msgid ""
"When a type defined by a class statement has no :attr:`~object.__slots__` "
"declaration, and none of its base types are weakly referenceable, the type "
"is made weakly referenceable by adding a weak reference list head slot to "
"the instance layout and setting the :c:member:`~PyTypeObject."
"tp_weaklistoffset` of that slot's offset."
msgstr ""
":keyword:`class` 文で定義された型に :attr:`~object.__slots__` 宣言が全くな"
"く、かつ基底タイプが弱参照可能でない場合、その型を弱参照可能にするには弱参照"
"リストの先頭を表すスロットをインスタンスデータレイアウト構造体に追加し、ス"
"ロットのオフセットを :c:member:`~PyTypeObject.tp_weaklistoffset` に設定しま"
"す。"

#: ../../c-api/typeobj.rst:1419
msgid ""
"When a type's :attr:`__slots__` declaration contains a slot named :attr:"
"`__weakref__`, that slot becomes the weak reference list head for instances "
"of the type, and the slot's offset is stored in the type's :c:member:"
"`~PyTypeObject.tp_weaklistoffset`."
msgstr ""
"型の :attr:`__slots__` の宣言に :attr:`__weakref__` という名前のスロットが含"
"まれているとき、スロットはその型のインスタンスにおける弱参照リストの先頭を表"
"すスロットになり、スロットのオフセットが型の :c:member:`~PyTypeObject."
"tp_weaklistoffset` に入ります。"

#: ../../c-api/typeobj.rst:1424
msgid ""
"When a type's :attr:`__slots__` declaration does not contain a slot named :"
"attr:`__weakref__`, the type inherits its :c:member:`~PyTypeObject."
"tp_weaklistoffset` from its base type."
msgstr ""
"型の :attr:`__slots__` 宣言が :attr:`__weakref__` という名前のスロットを含ん"
"でいないとき、その型は基底タイプから :c:member:`~PyTypeObject."
"tp_weaklistoffset` を継承します。"

#: ../../c-api/typeobj.rst:1431
msgid ""
"An optional pointer to a function that returns an iterator for the object.  "
"Its presence normally signals that the instances of this type are iterable "
"(although sequences may be iterable without this function)."
msgstr ""
"オプションの変数で、そのオブジェクトのイテレータを返す関数へのポインタです。"
"この値が存在することは、通常この型のインスタンスがイテレート可能であることを"
"示しています (しかし、シーケンスはこの関数がなくてもイテレート可能です)。"

#: ../../c-api/typeobj.rst:1435
msgid "This function has the same signature as :c:func:`PyObject_GetIter`::"
msgstr "この関数は :c:func:`PyObject_GetIter` と同じシグネチャを持っています::"

#: ../../c-api/typeobj.rst:1446
msgid ""
"An optional pointer to a function that returns the next item in an iterator. "
"The signature is::"
msgstr ""
"オプションのポインタで、イテレーターの次の要素を返す関数を指します。シグネ"
"チャは次の通りです::"

#: ../../c-api/typeobj.rst:1451
msgid ""
"When the iterator is exhausted, it must return ``NULL``; a :exc:"
"`StopIteration` exception may or may not be set.  When another error occurs, "
"it must return ``NULL`` too.  Its presence signals that the instances of "
"this type are iterators."
msgstr ""
"イテレータの要素がなくなると、この関数は ``NULL`` を返さなければなりませ"
"ん。 :exc:`StopIteration` 例外は設定してもしなくても良いです。その他のエラー"
"が発生したときも、 ``NULL`` を返さなければなりません。このフィールドがある"
"と、この型のインスタンスがイテレータであることを示します。"

#: ../../c-api/typeobj.rst:1456
msgid ""
"Iterator types should also define the :c:member:`~PyTypeObject.tp_iter` "
"function, and that function should return the iterator instance itself (not "
"a new iterator instance)."
msgstr ""
"イテレータ型では、 :c:member:`~PyTypeObject.tp_iter` 関数も定義されていなけれ"
"ばならず、その関数は (新たなイテレータインスタンスではなく) イテレータインス"
"タンス自体を返さねばなりません。"

#: ../../c-api/typeobj.rst:1460
msgid "This function has the same signature as :c:func:`PyIter_Next`."
msgstr "この関数のシグネチャは :c:func:`PyIter_Next` と同じです。"

#: ../../c-api/typeobj.rst:1469
msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyMethodDef` structures, declaring regular methods of this type."
msgstr ""
"オプションのポインタで、この型の正規 (regular) のメソッドを宣言している :c:"
"type:`PyMethodDef` 構造体からなる、 ``NULL`` で終端された静的な配列を指しま"
"す。"

#: ../../c-api/typeobj.rst:1472
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a method descriptor."
msgstr ""
"配列の各要素ごとに、メソッドデスクリプタの入った、要素が型の辞書 (下記の :c:"
"member:`~PyTypeObject.tp_dict` 参照) に追加されます。"

#: ../../c-api/typeobj.rst:1477
msgid ""
"This field is not inherited by subtypes (methods are inherited through a "
"different mechanism)."
msgstr ""
"サブタイプはこのフィールドを継承しません (メソッドは別個のメカニズムで継承さ"
"れています)。"

#: ../../c-api/typeobj.rst:1483
msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyMemberDef` structures, declaring regular data members (fields or slots) "
"of instances of this type."
msgstr ""
"オプションのポインタで、型の正規 (regular) のデータメンバ (フィールドおよびス"
"ロット) を宣言している :c:type:`PyMemberDef` 構造体からなる、 ``NULL`` で終端"
"された静的な配列を指します。"

#: ../../c-api/typeobj.rst:1487
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a member descriptor."
msgstr ""
"配列の各要素ごとに、メンバデスクリプタの入った要素が型の辞書 (下記の :c:"
"member:`~PyTypeObject.tp_dict` 参照) に追加されます。"

#: ../../c-api/typeobj.rst:1492
msgid ""
"This field is not inherited by subtypes (members are inherited through a "
"different mechanism)."
msgstr ""
"サブタイプはこのフィールドを継承しません (メンバは別個のメカニズムで継承され"
"ています)。"

#: ../../c-api/typeobj.rst:1498
msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyGetSetDef` structures, declaring computed attributes of instances of this "
"type."
msgstr ""
"オプションのポインタで、インスタンスの算出属性 (computed attribute) を宣言し"
"ている :c:type:`PyGetSetDef` 構造体からなる、 ``NULL`` で終端された静的な配列"
"を指します。"

#: ../../c-api/typeobj.rst:1501
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a getset descriptor."
msgstr ""
"配列の各要素ごとに、 getter/setter デスクリプタの入った、要素が型の辞書 (下記"
"の :c:member:`~PyTypeObject.tp_dict` 参照) に追加されます。"

#: ../../c-api/typeobj.rst:1506
msgid ""
"This field is not inherited by subtypes (computed attributes are inherited "
"through a different mechanism)."
msgstr ""
"サブタイプはこのフィールドを継承しません (算出属性は別個のメカニズムで継承さ"
"れています)。"

#: ../../c-api/typeobj.rst:1512
msgid ""
"An optional pointer to a base type from which type properties are "
"inherited.  At this level, only single inheritance is supported; multiple "
"inheritance require dynamically creating a type object by calling the "
"metatype."
msgstr ""
"オプションのポインタで、型に関するプロパティを継承する基底タイプを指します。"
"このフィールドのレベルでは、単継承 (single inheritance) だけがサポートされて"
"います; 多重継承はメタタイプの呼び出しによる動的な型オブジェクトの生成を必要"
"とします。"

#: ../../c-api/typeobj.rst:1520
msgid ""
"Slot initialization is subject to the rules of initializing globals. C99 "
"requires the initializers to be \"address constants\".  Function designators "
"like :c:func:`PyType_GenericNew`, with implicit conversion to a pointer, are "
"valid C99 address constants."
msgstr ""

#: ../../c-api/typeobj.rst:1525
msgid ""
"However, the unary '&' operator applied to a non-static variable like :c:"
"func:`PyBaseObject_Type` is not required to produce an address constant.  "
"Compilers may support this (gcc does), MSVC does not. Both compilers are "
"strictly standard conforming in this particular behavior."
msgstr ""

#: ../../c-api/typeobj.rst:1531
msgid ""
"Consequently, :c:member:`~PyTypeObject.tp_base` should be set in the "
"extension module's init function."
msgstr ""

#: ../../c-api/typeobj.rst:1536
msgid "This field is not inherited by subtypes (obviously)."
msgstr "(当たり前ですが) サブタイプはこのフィールドを継承しません。"

#: ../../c-api/typeobj.rst:1540
msgid ""
"This field defaults to ``&PyBaseObject_Type`` (which to Python programmers "
"is known as the type :class:`object`)."
msgstr ""
"このフィールドのデフォルト値は (Python プログラマは :class:`object` 型として"
"知っている) ``&PyBaseObject_Type`` になります。"

#: ../../c-api/typeobj.rst:1546
msgid "The type's dictionary is stored here by :c:func:`PyType_Ready`."
msgstr ""
"型の辞書は :c:func:`PyType_Ready` によってこのフィールドに収められます。"

#: ../../c-api/typeobj.rst:1548
msgid ""
"This field should normally be initialized to ``NULL`` before PyType_Ready is "
"called; it may also be initialized to a dictionary containing initial "
"attributes for the type.  Once :c:func:`PyType_Ready` has initialized the "
"type, extra attributes for the type may be added to this dictionary only if "
"they don't correspond to overloaded operations (like :meth:`__add__`)."
msgstr ""
"このフィールドは通常、 :c:func:`PyType_Ready` を呼び出す前に ``NULL`` に初期"
"化しておかなければなりません; あるいは、型の初期属性の入った辞書で初期化して"
"おいてもかまいません。 :c:func:`PyType_Ready` が型をひとたび初期化すると、型"
"の新たな属性をこの辞書に追加できるのは、属性が (:meth:`__add__` のような) "
"オーバロード用演算でないときだけです。"

#: ../../c-api/typeobj.rst:1556
msgid ""
"This field is not inherited by subtypes (though the attributes defined in "
"here are inherited through a different mechanism)."
msgstr ""
"サブタイプはこのフィールドを継承しません (が、この辞書内で定義されている属性"
"は異なるメカニズムで継承されます)。"

#: ../../c-api/typeobj.rst:1561
msgid ""
"If this field is ``NULL``, :c:func:`PyType_Ready` will assign a new "
"dictionary to it."
msgstr ""

#: ../../c-api/typeobj.rst:1566
msgid ""
"It is not safe to use :c:func:`PyDict_SetItem` on or otherwise modify :c:"
"member:`~PyTypeObject.tp_dict` with the dictionary C-API."
msgstr ""
":c:member:`~PyTypeObject.tp_dict` に :c:func:`PyDict_SetItem` を使ったり、辞"
"書 C-API で編集するのは安全ではありません。"

#: ../../c-api/typeobj.rst:1572
msgid "An optional pointer to a \"descriptor get\" function."
msgstr "オプションのポインタで、デスクリプタの get 関数を指します。"

#: ../../c-api/typeobj.rst:1574 ../../c-api/typeobj.rst:1590
#: ../../c-api/typeobj.rst:1672 ../../c-api/typeobj.rst:1702
#: ../../c-api/typeobj.rst:1726
msgid "The function signature is::"
msgstr "関数のシグネチャは次のとおりです ::"

#: ../../c-api/typeobj.rst:1587
msgid ""
"An optional pointer to a function for setting and deleting a descriptor's "
"value."
msgstr ""
"オプションのポインタで、デスクリプタの値の設定と削除を行う関数を指します。"

#: ../../c-api/typeobj.rst:1594
msgid "The *value* argument is set to ``NULL`` to delete the value."
msgstr "値を削除するには、*value* 引数に ``NULL`` を設定します。"

#: ../../c-api/typeobj.rst:1605
msgid ""
"If the instances of this type have a dictionary containing instance "
"variables, this field is non-zero and contains the offset in the instances "
"of the type of the instance variable dictionary; this offset is used by :c:"
"func:`PyObject_GenericGetAttr`."
msgstr ""
"型のインスタンスにインスタンス変数の入った辞書がある場合、このフィールドは非"
"ゼロの値になり、型のインスタンスデータ構造体におけるインスタンス変数辞書への"
"オフセットが入ります; このオフセット値は :c:func:`PyObject_GenericGetAttr` が"
"使います。"

#: ../../c-api/typeobj.rst:1610
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_dict`; that is "
"the dictionary for attributes of the type object itself."
msgstr ""
"このフィールドを :c:member:`~PyTypeObject.tp_dict` と混同しないようにしてくだ"
"さい; これは型オブジェクト自身の属性の辞書です。"

#: ../../c-api/typeobj.rst:1613
msgid ""
"If the value of this field is greater than zero, it specifies the offset "
"from the start of the instance structure.  If the value is less than zero, "
"it specifies the offset from the *end* of the instance structure.  A "
"negative offset is more expensive to use, and should only be used when the "
"instance structure contains a variable-length part.  This is used for "
"example to add an instance variable dictionary to subtypes of :class:`str` "
"or :class:`tuple`. Note that the :c:member:`~PyTypeObject.tp_basicsize` "
"field should account for the dictionary added to the end in that case, even "
"though the dictionary is not included in the basic object layout.  On a "
"system with a pointer size of 4 bytes, :c:member:`~PyTypeObject."
"tp_dictoffset` should be set to ``-4`` to indicate that the dictionary is at "
"the very end of the structure."
msgstr ""
"このフィールドの値がゼロより大きければ、値はインスタンス構造体の先頭からの オ"
"フセットを表します。値がゼロより小さければ、インスタンス構造体の *末尾* から"
"のオフセットを表します。負のオフセットを使うコストは比較的高くつくので、 イン"
"スタンス構造体に可変長部分があるときのみ使うべきです。例えば、 :class:`str` "
"や :class:`tuple` のサブタイプにインスタンス変数の辞書を追加する場合には、負"
"のオフセットを使います。この場合、たとえ辞書が基本のオブジェクトレイアウトに"
"含まれていなくても、 :c:member:`~PyTypeObject.tp_basicsize` フィールドは追加"
"された辞書を考慮にいれなければならないことに注意してください。ポインタサイズ"
"が 4 バイトのシステムでは、 構造体の最後尾に辞書が宣言されていることを示す場"
"合、 :c:member:`~PyTypeObject.tp_dictoffset` を ``-4`` にしなければなりませ"
"ん。"

#: ../../c-api/typeobj.rst:1625
msgid ""
"The real dictionary offset in an instance can be computed from a negative :c:"
"member:`~PyTypeObject.tp_dictoffset` as follows::"
msgstr ""
"負の :c:member:`~PyTypeObject.tp_dictoffset` から、インスタンスでの実際のオフ"
"セットを計算するには以下のようにします::"

#: ../../c-api/typeobj.rst:1632
msgid ""
"where :c:member:`~PyTypeObject.tp_basicsize`, :c:member:`~PyTypeObject."
"tp_itemsize` and :c:member:`~PyTypeObject.tp_dictoffset` are taken from the "
"type object, and :attr:`ob_size` is taken from the instance.  The absolute "
"value is taken because ints use the sign of :attr:`ob_size` to store the "
"sign of the number.  (There's never a need to do this calculation yourself; "
"it is done for you by :c:func:`_PyObject_GetDictPtr`.)"
msgstr ""
"ここで、 :c:member:`~PyTypeObject.tp_basicsize`、 :c:member:`~PyTypeObject."
"tp_itemsize` および :c:member:`~PyTypeObject.tp_dictoffset` は型オブジェクト"
"から取り出され、 :attr:`ob_size` はインスタンスから取り出されます。\n"
"絶対値を取っているのは、整数は符号を記憶するのに :attr:`ob_size` の符号を使う"
"ためです。\n"
"(この計算を自分で行う必要はまったくありません; 計算は :c:func:"
"`_PyObject_GetDictPtr` がやってくれます。)"

#: ../../c-api/typeobj.rst:1640
msgid ""
"This field is inherited by subtypes, but see the rules listed below. A "
"subtype may override this offset; this means that the subtype instances "
"store the dictionary at a difference offset than the base type.  Since the "
"dictionary is always found via :c:member:`~PyTypeObject.tp_dictoffset`, this "
"should not be a problem."
msgstr ""
"このフィールドはサブタイプに継承されますが、以下の規則を読んでください。サブ"
"タイプはこのオフセット値をオーバライドすることがあります; 従って、サブタイプ"
"では辞書のオフセットが基底タイプとは異なる場合があります。辞書のオフセットは"
"常に :c:member:`~PyTypeObject.tp_dictoffset` で分かるはずなので、このことは問"
"題にはならないはずです。"

#: ../../c-api/typeobj.rst:1645
msgid ""
"When a type defined by a class statement has no :attr:`~object.__slots__` "
"declaration, and none of its base types has an instance variable dictionary, "
"a dictionary slot is added to the instance layout and the :c:member:"
"`~PyTypeObject.tp_dictoffset` is set to that slot's offset."
msgstr ""
":keyword:`class` 文で定義された型に :attr:`~object.__slots__` 宣言がなく、か"
"つ基底タイプの全てにインスタンス変数辞書がない場合、辞書のスロットをインスタ"
"ンスデータレイアウト構造体に追加し、スロットのオフセットを :c:member:"
"`~PyTypeObject.tp_dictoffset` に設定します。"

#: ../../c-api/typeobj.rst:1650
msgid ""
"When a type defined by a class statement has a :attr:`__slots__` "
"declaration, the type inherits its :c:member:`~PyTypeObject.tp_dictoffset` "
"from its base type."
msgstr ""
":keyword:`class` 文で定義された型に :attr:`__slots__` 宣言がある場合、この型"
"は基底タイプから :c:member:`~PyTypeObject.tp_dictoffset` を継承します。"

#: ../../c-api/typeobj.rst:1653
msgid ""
"(Adding a slot named :attr:`~object.__dict__` to the :attr:`__slots__` "
"declaration does not have the expected effect, it just causes confusion.  "
"Maybe this should be added as a feature just like :attr:`__weakref__` "
"though.)"
msgstr ""
"(:attr:`~object.__dict__` という名前のスロットを :attr:`__slots__` 宣言に追加"
"しても、期待どおりの効果は得られず、単に混乱を招くだけになります。とはいえ、"
"これは将来 :attr:`__weakref__` のように追加されるはずです。)"

#: ../../c-api/typeobj.rst:1659
msgid ""
"This slot has no default.  For static types, if the field is ``NULL`` then "
"no :attr:`__dict__` gets created for instances."
msgstr ""

#: ../../c-api/typeobj.rst:1665
msgid "An optional pointer to an instance initialization function."
msgstr "オプションのポインタで、インスタンス初期化関数を指します。"

#: ../../c-api/typeobj.rst:1667
msgid ""
"This function corresponds to the :meth:`__init__` method of classes.  Like :"
"meth:`__init__`, it is possible to create an instance without calling :meth:"
"`__init__`, and it is possible to reinitialize an instance by calling its :"
"meth:`__init__` method again."
msgstr ""
"この関数はクラスにおける :meth:`__init__` メソッドに対応します。 :meth:"
"`__init__` と同様、 :meth:`__init__` を呼び出さずにインスタンスを作成できま"
"す。また、 :meth:`__init__` を再度呼び出してインスタンスの再初期化もできま"
"す。"

#: ../../c-api/typeobj.rst:1676
msgid ""
"The self argument is the instance to be initialized; the *args* and *kwds* "
"arguments represent positional and keyword arguments of the call to :meth:"
"`__init__`."
msgstr ""
"*self* 引数は初期化するインスタンスです; *args* および *kwds* 引数は、 :meth:"
"`__init__` を呼び出す際の位置引数およびキーワード引数です。"

#: ../../c-api/typeobj.rst:1680
msgid ""
"The :c:member:`~PyTypeObject.tp_init` function, if not ``NULL``, is called "
"when an instance is created normally by calling its type, after the type's :"
"c:member:`~PyTypeObject.tp_new` function has returned an instance of the "
"type.  If the :c:member:`~PyTypeObject.tp_new` function returns an instance "
"of some other type that is not a subtype of the original type, no :c:member:"
"`~PyTypeObject.tp_init` function is called; if :c:member:`~PyTypeObject."
"tp_new` returns an instance of a subtype of the original type, the "
"subtype's :c:member:`~PyTypeObject.tp_init` is called."
msgstr ""
":c:member:`~PyTypeObject.tp_init` 関数のフィールドが ``NULL`` でない場合、通"
"常の型を呼び出す方法のインスタンス生成において、型の :c:member:"
"`~PyTypeObject.tp_new` 関数がインスタンスを返した後に呼び出されます。 :c:"
"member:`~PyTypeObject.tp_new` が元の型のサブタイプでない別の型を返す場合、 :"
"c:member:`~PyTypeObject.tp_init` は全く呼び出されません; :c:member:"
"`~PyTypeObject.tp_new` が元の型のサブタイプのインスタンスを返す場合、サブタイ"
"プの :c:member:`~PyTypeObject.tp_init` が呼び出されます。"

#: ../../c-api/typeobj.rst:1687
msgid "Returns ``0`` on success, ``-1`` and sets an exception on error."
msgstr ""
"成功のときには ``0`` を、エラー時には例外をセットして ``-1`` を返します。"

#: ../../c-api/typeobj.rst:1695
msgid "For static types this field does not have a default."
msgstr ""

#: ../../c-api/typeobj.rst:1700
msgid "An optional pointer to an instance allocation function."
msgstr "オプションのポインタで、インスタンスのメモリ確保関数を指します。"

#: ../../c-api/typeobj.rst:1708
msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement)."
msgstr ""

#: ../../c-api/typeobj.rst:1713
msgid ""
"For dynamic subtypes, this field is always set to :c:func:"
"`PyType_GenericAlloc`, to force a standard heap allocation strategy."
msgstr ""

#: ../../c-api/typeobj.rst:1717
msgid ""
"For static subtypes, :c:type:`PyBaseObject_Type` uses :c:func:"
"`PyType_GenericAlloc`.  That is the recommended value for all statically "
"defined types."
msgstr ""

#: ../../c-api/typeobj.rst:1724
msgid "An optional pointer to an instance creation function."
msgstr "オプションのポインタで、インスタンス生成関数を指します。"

#: ../../c-api/typeobj.rst:1730
msgid ""
"The subtype argument is the type of the object being created; the *args* and "
"*kwds* arguments represent positional and keyword arguments of the call to "
"the type.  Note that subtype doesn't have to equal the type whose :c:member:"
"`~PyTypeObject.tp_new` function is called; it may be a subtype of that type "
"(but not an unrelated type)."
msgstr ""
"*subtype* 引数は生成するオブジェクトの型です; *args* および *kwds* 引数は、型"
"を呼び出すときの位置引数およびキーワード引数です。サブタイプは :c:member:"
"`~PyTypeObject.tp_new` 関数を呼び出すときに使う型と同じである必要はないことに"
"注意してください; その型の (無関係ではない) サブタイプのこともあります。"

#: ../../c-api/typeobj.rst:1736
msgid ""
"The :c:member:`~PyTypeObject.tp_new` function should call ``subtype-"
">tp_alloc(subtype, nitems)`` to allocate space for the object, and then do "
"only as much further initialization as is absolutely necessary.  "
"Initialization that can safely be ignored or repeated should be placed in "
"the :c:member:`~PyTypeObject.tp_init` handler.  A good rule of thumb is that "
"for immutable types, all initialization should take place in :c:member:"
"`~PyTypeObject.tp_new`, while for mutable types, most initialization should "
"be deferred to :c:member:`~PyTypeObject.tp_init`."
msgstr ""
":c:member:`~PyTypeObject.tp_new` 関数は ``subtype->tp_alloc(subtype, "
"nitems)`` を呼び出してオブジェクトのメモリ領域を確保し、初期化で絶対に必要と"
"される処理だけを行います。省略したり繰り返したりしても問題のない初期化処理"
"は :c:member:`~PyTypeObject.tp_init` ハンドラ内に配置しなければなりません。だ"
"いたいの目安としては、変更不能な型では初期化は全て :c:member:`~PyTypeObject."
"tp_new` で行い、一方、変更可能な型ではほとんどの初期化を :c:member:"
"`~PyTypeObject.tp_init` に回すべきです。"

#: ../../c-api/typeobj.rst:1746
msgid ""
"This field is inherited by subtypes, except it is not inherited by static "
"types whose :c:member:`~PyTypeObject.tp_base` is ``NULL`` or "
"``&PyBaseObject_Type``."
msgstr ""
"サブタイプはこのフィールドを継承します。例外として、  :c:member:"
"`~PyTypeObject.tp_base` が ``NULL`` か ``&PyBaseObject_Type`` になっている静"
"的な型では継承しません。"

#: ../../c-api/typeobj.rst:1751
msgid ""
"For static types this field has no default.  This means if the slot is "
"defined as ``NULL``, the type cannot be called to create new instances; "
"presumably there is some other way to create instances, like a factory "
"function."
msgstr ""

#: ../../c-api/typeobj.rst:1759
msgid ""
"An optional pointer to an instance deallocation function.  Its signature is::"
msgstr ""
"オプションのポインタで、インスタンスのメモリ解放関数を指します。シグネチャは"
"以下の通りです::"

#: ../../c-api/typeobj.rst:1763
msgid ""
"An initializer that is compatible with this signature is :c:func:"
"`PyObject_Free`."
msgstr "このシグネチャと互換性のある初期化子は :c:func:`PyObject_Free` です。"

#: ../../c-api/typeobj.rst:1767
msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement)"
msgstr ""

#: ../../c-api/typeobj.rst:1772
msgid ""
"In dynamic subtypes, this field is set to a deallocator suitable to match :c:"
"func:`PyType_GenericAlloc` and the value of the :const:`Py_TPFLAGS_HAVE_GC` "
"flag bit."
msgstr ""

#: ../../c-api/typeobj.rst:1776
msgid "For static subtypes, :c:type:`PyBaseObject_Type` uses PyObject_Del."
msgstr ""

#: ../../c-api/typeobj.rst:1781
msgid "An optional pointer to a function called by the garbage collector."
msgstr ""
"オプションのポインタで、ガベージコレクタから呼び出される関数を指します。"

#: ../../c-api/typeobj.rst:1783
msgid ""
"The garbage collector needs to know whether a particular object is "
"collectible or not.  Normally, it is sufficient to look at the object's "
"type's :c:member:`~PyTypeObject.tp_flags` field, and check the :const:"
"`Py_TPFLAGS_HAVE_GC` flag bit.  But some types have a mixture of statically "
"and dynamically allocated instances, and the statically allocated instances "
"are not collectible.  Such types should define this function; it should "
"return ``1`` for a collectible instance, and ``0`` for a non-collectible "
"instance. The signature is::"
msgstr ""
"ガベージコレクタは、オブジェクトを回収して良いかどうかを知る必要があります。"
"通常は、オブジェクトの型の :c:member:`~PyTypeObject.tp_flags` フィールドを見"
"て、 :const:`Py_TPFLAGS_HAVE_GC` フラグビットを調べるだけで十分です。しかし、"
"ある型では静的にメモリ確保されたインスタンスと動的にメモリ確保されたインスタ"
"ンスが混じっていて、静的にメモリ確保されたインスタンスは回収できません。こう"
"した型では、関数を定義しなければなりません; 関数はインスタンスが回収可能の場"
"合には ``1`` を、回収不能の場合には ``0`` を返さねばなりません。シグネチャ"
"は::"

#: ../../c-api/typeobj.rst:1793
msgid ""
"(The only example of this are types themselves.  The metatype, :c:data:"
"`PyType_Type`, defines this function to distinguish between statically and "
"dynamically allocated types.)"
msgstr ""
"(上記のような型の例は、型オブジェクト自体です。メタタイプ :c:data:"
"`PyType_Type` は、型のメモリ確保が静的か動的かを区別するためにこの関数を定義"
"しています。)"

#: ../../c-api/typeobj.rst:1803
msgid ""
"This slot has no default.  If this field is ``NULL``, :const:"
"`Py_TPFLAGS_HAVE_GC` is used as the functional equivalent."
msgstr ""

#: ../../c-api/typeobj.rst:1809
msgid "Tuple of base types."
msgstr "基底型からなるタプルです。"

#: ../../c-api/typeobj.rst:1811
msgid ""
"This is set for types created by a class statement.  It should be ``NULL`` "
"for statically defined types."
msgstr ""
":keyword:`class` 文で生成されたクラスの場合このフィールドがセットされます。静"
"的に定義されている型の場合には、このフィールドは ``NULL`` になります。"

#: ../../c-api/typeobj.rst:1816 ../../c-api/typeobj.rst:1837
#: ../../c-api/typeobj.rst:1846 ../../c-api/typeobj.rst:1856
#: ../../c-api/typeobj.rst:1870
msgid "This field is not inherited."
msgstr "このフィールドは継承されません。"

#: ../../c-api/typeobj.rst:1821
msgid ""
"Tuple containing the expanded set of base types, starting with the type "
"itself and ending with :class:`object`, in Method Resolution Order."
msgstr ""
"基底タイプ群を展開した集合が入っているタプルです。集合は該当する型自体からは"
"じまり、 :class:`object` で終わります。メソッド解決順序 (Method Resolution "
"Order) に従って並んでいます。"

#: ../../c-api/typeobj.rst:1827
msgid ""
"This field is not inherited; it is calculated fresh by :c:func:"
"`PyType_Ready`."
msgstr ""
"このフィールドは継承されません; フィールドの値は :c:func:`PyType_Ready` で毎"
"回計算されます。"

#: ../../c-api/typeobj.rst:1833
msgid "Unused.  Internal use only."
msgstr "未使用のフィールドです。内部でのみ利用されます。"

#: ../../c-api/typeobj.rst:1842
msgid "List of weak references to subclasses.  Internal use only."
msgstr ""
"サブクラスへの弱参照からなるリストです。内部で使用するためだけのものです。"

#: ../../c-api/typeobj.rst:1851
msgid ""
"Weak reference list head, for weak references to this type object.  Not "
"inherited.  Internal use only."
msgstr "この型オブジェクトに対する弱参照からなるリストの先頭です。"

#: ../../c-api/typeobj.rst:1861
msgid ""
"This field is deprecated.  Use :c:member:`~PyTypeObject.tp_finalize` instead."
msgstr ""
"このフィールドは廃止されました。:c:member:`~PyTypeObject.tp_finalize` を代わ"
"りに利用してください。"

#: ../../c-api/typeobj.rst:1866
msgid "Used to index into the method cache.  Internal use only."
msgstr ""
"メソッドキャッシュへのインデックスとして使われます。内部使用だけのための関数"
"です。"

#: ../../c-api/typeobj.rst:1875
msgid ""
"An optional pointer to an instance finalization function.  Its signature is::"
msgstr ""
"オプションのポインタで、インスタンスの終了処理関数を指します。シグネチャは以"
"下の通りです::"

#: ../../c-api/typeobj.rst:1879
msgid ""
"If :c:member:`~PyTypeObject.tp_finalize` is set, the interpreter calls it "
"once when finalizing an instance.  It is called either from the garbage "
"collector (if the instance is part of an isolated reference cycle) or just "
"before the object is deallocated.  Either way, it is guaranteed to be called "
"before attempting to break reference cycles, ensuring that it finds the "
"object in a sane state."
msgstr ""
":c:member:`~PyTypeObject.tp_finalize` が設定されている場合、インスタンスを"
"ファイナライズするときに、インタプリタがこの関数を1回呼び出します。\n"
"ガベージコレクタ (このインスタンスが孤立した循環参照の一部だった場合) やオブ"
"ジェクトが破棄される直前にもこの関数は呼び出されます。\n"
"どちらの場合でも、循環参照を破壊しようとする前に呼び出されることが保証されて"
"いて、確実にオブジェクトが正常な状態にあるようにします。"

#: ../../c-api/typeobj.rst:1886
msgid ""
":c:member:`~PyTypeObject.tp_finalize` should not mutate the current "
"exception status; therefore, a recommended way to write a non-trivial "
"finalizer is::"
msgstr ""
":c:member:`~PyTypeObject.tp_finalize` は現在の例外状態を変更すべきではありま"
"せん; 従って、単純でないファイナライザを書くには次の方法が推奨されます::"

#: ../../c-api/typeobj.rst:1903
msgid ""
"For this field to be taken into account (even through inheritance), you must "
"also set the :const:`Py_TPFLAGS_HAVE_FINALIZE` flags bit."
msgstr ""
"このフィールドを (継承した場合も含めて) 考慮から漏らさないように、 :const:"
"`Py_TPFLAGS_HAVE_FINALIZE` フラグビットも設定しなければなりません。"

#: ../../c-api/typeobj.rst:1912
msgid "\"Safe object finalization\" (:pep:`442`)"
msgstr "\"オブジェクトの安全な終了処理\" (:pep:`442`)"

#: ../../c-api/typeobj.rst:1915
msgid ""
"The remaining fields are only defined if the feature test macro :const:"
"`COUNT_ALLOCS` is defined, and are for internal use only. They are "
"documented here for completeness.  None of these fields are inherited by "
"subtypes."
msgstr ""
"残りのフィールドは、機能テスト用のマクロである :const:`COUNT_ALLOCS` が定義さ"
"れている場合のみ利用でき、内部で使用するためだけのものです。これらのフィール"
"ドについて記述するのは単に完全性のためです。サブタイプはこれらのフィールドを"
"継承しません。"

#: ../../c-api/typeobj.rst:1922
msgid "Number of allocations."
msgstr "メモリ確保の回数です。"

#: ../../c-api/typeobj.rst:1926
msgid "Number of frees."
msgstr "メモリ解放の回数です。"

#: ../../c-api/typeobj.rst:1930
msgid "Maximum simultaneously allocated objects."
msgstr "同時にメモリ確保できる最大オブジェクト数です。"

#: ../../c-api/typeobj.rst:1934
msgid ""
"Pointer to the previous type object with a non-zero :c:member:`~PyTypeObject."
"tp_allocs` field."
msgstr ""

#: ../../c-api/typeobj.rst:1938
msgid ""
"Pointer to the next type object with a non-zero :c:member:`~PyTypeObject."
"tp_allocs` field."
msgstr ""
"次のゼロでない :c:member:`~PyTypeObject.tp_allocs` フィールドを持つ型オブジェ"
"クトへのポインタです。"

#: ../../c-api/typeobj.rst:1940
msgid ""
"Also, note that, in a garbage collected Python, :c:member:`~PyTypeObject."
"tp_dealloc` may be called from any Python thread, not just the thread which "
"created the object (if the object becomes part of a refcount cycle, that "
"cycle might be collected by a garbage collection on any thread).  This is "
"not a problem for Python API calls, since the thread on which tp_dealloc is "
"called will own the Global Interpreter Lock (GIL). However, if the object "
"being destroyed in turn destroys objects from some other C or C++ library, "
"care should be taken to ensure that destroying those objects on the thread "
"which called tp_dealloc will not violate any assumptions of the library."
msgstr ""
"また、 Python のガベージコレクションでは、 :c:member:`~PyTypeObject."
"tp_dealloc` を呼び出すのはオブジェクトを生成したスレッドだけではなく、任意の "
"Python スレッドかもしれないという点にも注意して下さい。 (オブジェクトが循環参"
"照の一部の場合、任意のスレッドのガベージコレクションによって解放されてしまう"
"かもしれません)。Python API 側からみれば、 *tp_dealloc* を呼び出すスレッドは"
"グローバルインタプリタロック (GIL: Global Interpreter Lock) を獲得するので、"
"これは問題ではありません。しかしながら、削除されようとしているオブジェクトが"
"何らかの C や C++ ライブラリ由来のオブジェクトを削除する場合、 *tp_dealloc* "
"を呼び出すスレッドのオブジェクトを削除することで、ライブラリの仮定している何"
"らかの規約に違反しないように気を付ける必要があります。"

#: ../../c-api/typeobj.rst:1954
msgid "Heap Types"
msgstr ""

#: ../../c-api/typeobj.rst:1956
msgid ""
"Traditionally, types defined in C code are *static*, that is, a static :c:"
"type:`PyTypeObject` structure is defined directly in code and initialized "
"using :c:func:`PyType_Ready`."
msgstr ""

#: ../../c-api/typeobj.rst:1960
msgid ""
"This results in types that are limited relative to types defined in Python:"
msgstr ""

#: ../../c-api/typeobj.rst:1962
msgid ""
"Static types are limited to one base, i.e. they cannot use multiple "
"inheritance."
msgstr ""

#: ../../c-api/typeobj.rst:1964
msgid ""
"Static type objects (but not necessarily their instances) are immutable. It "
"is not possible to add or modify the type object's attributes from Python."
msgstr ""

#: ../../c-api/typeobj.rst:1966
msgid ""
"Static type objects are shared across :ref:`sub-interpreters <sub-"
"interpreter-support>`, so they should not include any subinterpreter-"
"specific state."
msgstr ""

#: ../../c-api/typeobj.rst:1970
msgid ""
"Also, since :c:type:`PyTypeObject` is not part of the :ref:`stable ABI "
"<stable>`, any extension modules using static types must be compiled for a "
"specific Python minor version."
msgstr ""

#: ../../c-api/typeobj.rst:1974
msgid ""
"An alternative to static types is *heap-allocated types*, or *heap types* "
"for short, which correspond closely to classes created by Python's ``class`` "
"statement."
msgstr ""

#: ../../c-api/typeobj.rst:1978
msgid ""
"This is done by filling a :c:type:`PyType_Spec` structure and calling :c:"
"func:`PyType_FromSpecWithBases`."
msgstr ""

#: ../../c-api/typeobj.rst:1985
msgid "Number Object Structures"
msgstr "数値オブジェクト構造体"

#: ../../c-api/typeobj.rst:1992
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the number protocol.  Each function is used by the function of "
"similar name documented in the :ref:`number` section."
msgstr ""
"この構造体は数値型プロトコルを実装するために使われる関数群へのポインタを保持"
"しています。\n"
"以下のそれぞれの関数は :ref:`number` で解説されている似た名前の関数から利用さ"
"れます。"

#: ../../c-api/typeobj.rst:1998 ../../c-api/typeobj.rst:2322
msgid "Here is the structure definition::"
msgstr "以下は構造体の定義です::"

#: ../../c-api/typeobj.rst:2045
msgid ""
"Binary and ternary functions must check the type of all their operands, and "
"implement the necessary conversions (at least one of the operands is an "
"instance of the defined type).  If the operation is not defined for the "
"given operands, binary and ternary functions must return "
"``Py_NotImplemented``, if another error occurred they must return ``NULL`` "
"and set an exception."
msgstr ""
"二項関数と三項関数は、すべてのオペランドの型をチェックしなければならず、必要"
"な変換を実装しなければなりません (すくなくともオペランドの一つは定義している"
"型のインスタンスです). もし与えられたオペランドに対して操作が定義されなけれ"
"ば、二項関数と三項関数は ``Py_NotImplemented`` を返さなければならず、他のエ"
"ラーが起こった場合は、``NULL`` を返して例外を設定しなければなりません。"

#: ../../c-api/typeobj.rst:2054
msgid ""
"The :c:data:`nb_reserved` field should always be ``NULL``.  It was "
"previously called :c:data:`nb_long`, and was renamed in Python 3.0.1."
msgstr ""
":c:data:`nb_reserved` フィールドは常に ``NULL`` でなければなりません。以前"
"は :c:data:`nb_long` と呼ばれていて、 Python 3.0.1 で名前が変更されました。"

#: ../../c-api/typeobj.rst:2099
msgid "Mapping Object Structures"
msgstr "マップオブジェクト構造体"

#: ../../c-api/typeobj.rst:2106
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the mapping protocol.  It has three members:"
msgstr ""
"この構造体はマップ型プロトコルを実装するために使われる関数群へのポインタを保"
"持しています。\n"
"以下の3つのメンバを持っています:"

#: ../../c-api/typeobj.rst:2111
msgid ""
"This function is used by :c:func:`PyMapping_Size` and :c:func:"
"`PyObject_Size`, and has the same signature.  This slot may be set to "
"``NULL`` if the object has no defined length."
msgstr ""
"この関数は :c:func:`PyMapping_Size` や :c:func:`PyObject_Size` から利用され、"
"それらと同じシグネチャを持っています。オブジェクトが定義された長さを持たない"
"場合は、このスロットは ``NULL`` に設定されることがあります。"

#: ../../c-api/typeobj.rst:2117
msgid ""
"This function is used by :c:func:`PyObject_GetItem` and :c:func:"
"`PySequence_GetSlice`, and has the same signature as :c:func:`!"
"PyObject_GetItem`.  This slot must be filled for the :c:func:"
"`PyMapping_Check` function to return ``1``, it can be ``NULL`` otherwise."
msgstr ""
"この関数は :c:func:`PyObject_GetItem` および :c:func:`PySequence_GetSlice` か"
"ら利用され、:c:func:`PySequence_GetSlice` と同じシグネチャを持っています。こ"
"のスロットは :c:func:`PyMapping_Check` が ``1`` を返すためには必要で、そうで"
"なければ ``NULL`` の場合があります。"

#: ../../c-api/typeobj.rst:2125
msgid ""
"This function is used by :c:func:`PyObject_SetItem`, :c:func:"
"`PyObject_DelItem`, :c:func:`PyObject_SetSlice` and :c:func:"
"`PyObject_DelSlice`.  It has the same signature as :c:func:`!"
"PyObject_SetItem`, but *v* can also be set to ``NULL`` to delete an item.  "
"If this slot is ``NULL``, the object does not support item assignment and "
"deletion."
msgstr ""
"この関数は :c:func:`PyObject_SetItem`、:c:func:`PyObject_DelItem`、:c:func:"
"`PyObject_SetSlice` および :c:func:`PyObject_DelSlice` から利用されます。\n"
":c:func:`!PyObject_SetItem` と同じシグネチャを持ちますが、 *v* に ``NULL`` を"
"設定して要素の削除もできます。このスロットが ``NULL`` の場合は、このオブジェ"
"クトはアイテムの代入と削除をサポートしません。"

#: ../../c-api/typeobj.rst:2136
msgid "Sequence Object Structures"
msgstr "シーケンスオブジェクト構造体"

#: ../../c-api/typeobj.rst:2143
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the sequence protocol."
msgstr ""
"この構造体はシーケンス型プロトコルを実装するために使われる関数群へのポインタ"
"を保持しています。"

#: ../../c-api/typeobj.rst:2148
msgid ""
"This function is used by :c:func:`PySequence_Size` and :c:func:"
"`PyObject_Size`, and has the same signature.  It is also used for handling "
"negative indices via the :c:member:`~PySequenceMethods.sq_item` and the :c:"
"member:`~PySequenceMethods.sq_ass_item` slots."
msgstr ""

#: ../../c-api/typeobj.rst:2155
msgid ""
"This function is used by :c:func:`PySequence_Concat` and has the same "
"signature.  It is also used by the ``+`` operator, after trying the numeric "
"addition via the :c:member:`~PyNumberMethods.nb_add` slot."
msgstr ""
"この関数は :c:func:`PySequence_Concat` で利用され、同じシグネチャを持っていま"
"す。また、 ``+`` 演算子でも、 :c:member:`~PyNumberMethods.nb_add` スロットに"
"よる数値加算を試した後に利用されます。"

#: ../../c-api/typeobj.rst:2161
msgid ""
"This function is used by :c:func:`PySequence_Repeat` and has the same "
"signature.  It is also used by the ``*`` operator, after trying numeric "
"multiplication via the :c:member:`~PyNumberMethods.nb_multiply` slot."
msgstr ""
"この関数は :c:func:`PySequence_Repeat` で利用され、同じシグネチャを持っていま"
"す。また、 ``*`` 演算でも、 :c:member:`~PyNumberMethods.nb_multiply` スロット"
"による数値乗算を試したあとに利用されます。"

#: ../../c-api/typeobj.rst:2167
msgid ""
"This function is used by :c:func:`PySequence_GetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_GetItem`, after trying the "
"subscription via the :c:member:`~PyMappingMethods.mp_subscript` slot. This "
"slot must be filled for the :c:func:`PySequence_Check` function to return "
"``1``, it can be ``NULL`` otherwise."
msgstr ""

#: ../../c-api/typeobj.rst:2173
msgid ""
"Negative indexes are handled as follows: if the :attr:`sq_length` slot is "
"filled, it is called and the sequence length is used to compute a positive "
"index which is passed to :attr:`sq_item`.  If :attr:`sq_length` is ``NULL``, "
"the index is passed as is to the function."
msgstr ""
"負のインデックスは次のように処理されます: :attr:`sq_length` スロットが埋めら"
"れていれば、それを呼び出してシーケンスの長さから正のインデックスを計算し、 :"
"attr:`sq_item` に渡します。 :attr:`sq_length` が ``NULL`` の場合は、インデッ"
"クスはそのままこの関数に渡されます。"

#: ../../c-api/typeobj.rst:2180
msgid ""
"This function is used by :c:func:`PySequence_SetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_SetItem` and :c:func:"
"`PyObject_DelItem`, after trying the item assignment and deletion via the :c:"
"member:`~PyMappingMethods.mp_ass_subscript` slot. This slot may be left to "
"``NULL`` if the object does not support item assignment and deletion."
msgstr ""

#: ../../c-api/typeobj.rst:2189
msgid ""
"This function may be used by :c:func:`PySequence_Contains` and has the same "
"signature.  This slot may be left to ``NULL``, in this case :c:func:`!"
"PySequence_Contains` simply traverses the sequence until it finds a match."
msgstr ""
"この関数は :c:func:`PySequence_Contains` から利用され、同じシグネチャを持って"
"います。このスロットは ``NULL`` の場合があり、その時 :c:func:`!"
"PySequence_Contains` はシンプルにマッチするオブジェクトを見つけるまでシーケン"
"スを巡回します。"

#: ../../c-api/typeobj.rst:2196
msgid ""
"This function is used by :c:func:`PySequence_InPlaceConcat` and has the same "
"signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceConcat` "
"will fall back to :c:func:`PySequence_Concat`.  It is also used by the "
"augmented assignment ``+=``, after trying numeric in-place addition via the :"
"c:member:`~PyNumberMethods.nb_inplace_add` slot."
msgstr ""

#: ../../c-api/typeobj.rst:2205
msgid ""
"This function is used by :c:func:`PySequence_InPlaceRepeat` and has the same "
"signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceRepeat` "
"will fall back to :c:func:`PySequence_Repeat`.  It is also used by the "
"augmented assignment ``*=``, after trying numeric in-place multiplication "
"via the :c:member:`~PyNumberMethods.nb_inplace_multiply` slot."
msgstr ""

#: ../../c-api/typeobj.rst:2216
msgid "Buffer Object Structures"
msgstr "バッファオブジェクト構造体 (buffer object structure)"

#: ../../c-api/typeobj.rst:2224
msgid ""
"This structure holds pointers to the functions required by the :ref:`Buffer "
"protocol <bufferobjects>`. The protocol defines how an exporter object can "
"expose its internal data to consumer objects."
msgstr ""
"この構造体は :ref:`buffer プロトコル <bufferobjects>` が要求する関数群へのポ"
"インタを保持しています。\n"
"そのプロトコルは、エクスポーターオブジェクトが如何にして、その内部データをコ"
"ンシューマオブジェクトに渡すかを定義します。"

#: ../../c-api/typeobj.rst:2230 ../../c-api/typeobj.rst:2279
#: ../../c-api/typeobj.rst:2332 ../../c-api/typeobj.rst:2343
#: ../../c-api/typeobj.rst:2354
msgid "The signature of this function is::"
msgstr "この関数のシグネチャは以下の通りです::"

#: ../../c-api/typeobj.rst:2234
msgid ""
"Handle a request to *exporter* to fill in *view* as specified by *flags*. "
"Except for point (3), an implementation of this function MUST take these "
"steps:"
msgstr ""
"*flags* で指定された方法で *view* を埋めてほしいという *exporter* に対する要"
"求を処理します。ステップ(3) を除いて、この関数の実装では以下のステップを行わ"
"なければなりません:"

#: ../../c-api/typeobj.rst:2238
msgid ""
"Check if the request can be met. If not, raise :c:data:`PyExc_BufferError`, "
"set :c:data:`view->obj` to ``NULL`` and return ``-1``."
msgstr ""
"リクエストが合致するか確認します。\n"
"合致しない場合は、 :c:data:`PyExc_BufferError` を送出し、 :c:data:`view-"
">obj` に ``NULL`` を設定し ``-1`` を返します。"

#: ../../c-api/typeobj.rst:2241
msgid "Fill in the requested fields."
msgstr "要求されたフィールドを埋めます。"

#: ../../c-api/typeobj.rst:2243
msgid "Increment an internal counter for the number of exports."
msgstr "エクスポートした回数を保持する内部カウンタをインクリメントします。"

#: ../../c-api/typeobj.rst:2245
msgid ""
"Set :c:data:`view->obj` to *exporter* and increment :c:data:`view->obj`."
msgstr ""
":c:data:`view->obj` に *exporter* を設定し、 :c:data:`view->obj` をインクリメ"
"ントします。"

#: ../../c-api/typeobj.rst:2247
msgid "Return ``0``."
msgstr "``0`` を返します。"

#: ../../c-api/typeobj.rst:2249
msgid ""
"If *exporter* is part of a chain or tree of buffer providers, two main "
"schemes can be used:"
msgstr ""
"*exporter* がバッファプロバイダのチェインかツリーの一部であれば、２つの主要な"
"方式が使用できます:"

#: ../../c-api/typeobj.rst:2252
msgid ""
"Re-export: Each member of the tree acts as the exporting object and sets :c:"
"data:`view->obj` to a new reference to itself."
msgstr ""
"再エクスポート: ツリーの各要素がエクスポートされるオブジェクトとして振る舞"
"い、自身への新しい参照を :c:data:`view->obj` へセットします。"

#: ../../c-api/typeobj.rst:2255
msgid ""
"Redirect: The buffer request is redirected to the root object of the tree. "
"Here, :c:data:`view->obj` will be a new reference to the root object."
msgstr ""
"リダイレクト: バッファ要求がツリーのルートオブジェクトにリダイレクトされま"
"す。ここでは、 :c:data:`view->obj` はルートオブジェクトへの新しい参照になりま"
"す。"

#: ../../c-api/typeobj.rst:2259
msgid ""
"The individual fields of *view* are described in section :ref:`Buffer "
"structure <buffer-structure>`, the rules how an exporter must react to "
"specific requests are in section :ref:`Buffer request types <buffer-request-"
"types>`."
msgstr ""
"*view* の個別のフィールドは :ref:`バッファ構造体 <buffer-structure>` の節で説"
"明されており、エクスポートが特定の要求に対しどう対応しなければならないかの規"
"則は、 :ref:`バッファ要求のタイプ <buffer-request-types>` の節にあります。"

#: ../../c-api/typeobj.rst:2264
msgid ""
"All memory pointed to in the :c:type:`Py_buffer` structure belongs to the "
"exporter and must remain valid until there are no consumers left. :c:member:"
"`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, :c:member:`~Py_buffer."
"strides`, :c:member:`~Py_buffer.suboffsets` and :c:member:`~Py_buffer."
"internal` are read-only for the consumer."
msgstr ""
":c:type:`Py_buffer` 構造体の中から参照している全てのメモリはエクスポータに属"
"し、コンシューマがいなくなるまで有効でなくてはなりません。 :c:member:"
"`~Py_buffer.format` 、 :c:member:`~Py_buffer.shape` 、 :c:member:`~Py_buffer."
"strides` 、 :c:member:`~Py_buffer.suboffsets` 、 :c:member:`~Py_buffer."
"internal` はコンシューマからは読み出し専用です。"

#: ../../c-api/typeobj.rst:2271
msgid ""
":c:func:`PyBuffer_FillInfo` provides an easy way of exposing a simple bytes "
"buffer while dealing correctly with all request types."
msgstr ""
":c:func:`PyBuffer_FillInfo` は、全てのリクエストタイプを正しく扱う際に、単純"
"なバイトバッファを公開する簡単な方法を提供します。"

#: ../../c-api/typeobj.rst:2274
msgid ""
":c:func:`PyObject_GetBuffer` is the interface for the consumer that wraps "
"this function."
msgstr ""
":c:func:`PyObject_GetBuffer` は、この関数をラップするコンシューマ向けのインタ"
"フェースです。"

#: ../../c-api/typeobj.rst:2283
msgid ""
"Handle a request to release the resources of the buffer. If no resources "
"need to be released, :c:member:`PyBufferProcs.bf_releasebuffer` may be "
"``NULL``. Otherwise, a standard implementation of this function will take "
"these optional steps:"
msgstr ""
"バッファのリソースを開放する要求を処理します。もし開放する必要のあるリソース"
"がない場合、 :c:member:`PyBufferProcs.bf_releasebuffer` は ``NULL`` にしても"
"構いません。そうでない場合は、この関数の標準的な実装は、以下の任意の処理手順 "
"(optional step) を行います:"

#: ../../c-api/typeobj.rst:2288
msgid "Decrement an internal counter for the number of exports."
msgstr "エクスポートした回数を保持する内部カウンタをデクリメントします。"

#: ../../c-api/typeobj.rst:2290
msgid "If the counter is ``0``, free all memory associated with *view*."
msgstr ""
"カウンタが ``0`` の場合は、*view* に関連付けられた全てのメモリを解放します。"

#: ../../c-api/typeobj.rst:2292
msgid ""
"The exporter MUST use the :c:member:`~Py_buffer.internal` field to keep "
"track of buffer-specific resources. This field is guaranteed to remain "
"constant, while a consumer MAY pass a copy of the original buffer as the "
"*view* argument."
msgstr ""
"エクスポータは、バッファ固有のリソースを監視し続けるために :c:member:"
"`~Py_buffer.internal` フィールドを使わなければなりません。このフィールドは、"
"コンシューマが *view* 引数としてオリジナルのバッファのコピーを渡しているであ"
"ろう間、変わらないことが保証されています。"

#: ../../c-api/typeobj.rst:2298
msgid ""
"This function MUST NOT decrement :c:data:`view->obj`, since that is done "
"automatically in :c:func:`PyBuffer_Release` (this scheme is useful for "
"breaking reference cycles)."
msgstr ""
"この関数は、:c:data:`view->obj` をデクリメントしてはいけません、なぜならそれ"
"は :c:func:`PyBuffer_Release` で自動的に行われるからです(この方式は参照の循環"
"を防ぐのに有用です)。"

#: ../../c-api/typeobj.rst:2303
msgid ""
":c:func:`PyBuffer_Release` is the interface for the consumer that wraps this "
"function."
msgstr ""
":c:func:`PyBuffer_Release` は、この関数をラップするコンシューマ向けのインタ"
"フェースです。"

#: ../../c-api/typeobj.rst:2311
msgid "Async Object Structures"
msgstr "async オブジェクト構造体"

#: ../../c-api/typeobj.rst:2319
msgid ""
"This structure holds pointers to the functions required to implement :term:"
"`awaitable` and :term:`asynchronous iterator` objects."
msgstr ""
"この構造体は :term:`awaitable` オブジェクトと :term:`asynchronous iterator` "
"オブジェクトを実装するのに必要な関数へのポインタを保持しています。"

#: ../../c-api/typeobj.rst:2336
msgid ""
"The returned object must be an iterator, i.e. :c:func:`PyIter_Check` must "
"return ``1`` for it."
msgstr ""
"返されるオブジェクトはイテレータでなければなりません。\n"
"つまりこのオブジェクトに対して :c:func:`PyIter_Check` が ``1`` を返さなければ"
"なりません。"

#: ../../c-api/typeobj.rst:2339
msgid ""
"This slot may be set to ``NULL`` if an object is not an :term:`awaitable`."
msgstr ""
"オブジェクトが :term:`awaitable` でない場合、このスロットを ``NULL`` に設定し"
"ます。"

#: ../../c-api/typeobj.rst:2347
msgid ""
"Must return an :term:`awaitable` object.  See :meth:`__anext__` for details."
msgstr ""
":term:`awaitable` オブジェクトを返さなければなりません。\n"
"詳しいことは :meth:`__anext__` を参照してください。"

#: ../../c-api/typeobj.rst:2349
msgid ""
"This slot may be set to ``NULL`` if an object does not implement "
"asynchronous iteration protocol."
msgstr ""
"オブジェクトが非同期反復処理のプロトコルを実装していない場合、このスロットを "
"``NULL`` に設定します。"

#: ../../c-api/typeobj.rst:2358
msgid ""
"Must return an :term:`awaitable` object.  See :meth:`__anext__` for details. "
"This slot may be set to ``NULL``."
msgstr ""
":term:`awaitable` オブジェクトを返さなければなりません。\n"
"詳しいことは :meth:`__anext__` を参照してください。\n"
"このスロットは ``NULL`` に設定されていることもあります。"

#: ../../c-api/typeobj.rst:2365
msgid "Slot Type typedefs"
msgstr "Slot Type typedefs"

#: ../../c-api/typeobj.rst:2369
msgid ""
"The purpose of this function is to separate memory allocation from memory "
"initialization.  It should return a pointer to a block of memory of adequate "
"length for the instance, suitably aligned, and initialized to zeros, but "
"with :attr:`ob_refcnt` set to ``1`` and :attr:`ob_type` set to the type "
"argument.  If the type's :c:member:`~PyTypeObject.tp_itemsize` is non-zero, "
"the object's :attr:`ob_size` field should be initialized to *nitems* and the "
"length of the allocated memory block should be ``tp_basicsize + "
"nitems*tp_itemsize``, rounded up to a multiple of ``sizeof(void*)``; "
"otherwise, *nitems* is not used and the length of the block should be :c:"
"member:`~PyTypeObject.tp_basicsize`."
msgstr ""
"この関数の目的は、メモリ確保をメモリ初期化から分離することにあります。この関"
"数は、インスタンス用の的確なサイズ、適切なアラインメント、ゼロによる初期化が"
"なされ、 :attr:`ob_refcnt` を ``1`` に、 :attr:`ob_type` を型引数 (type "
"argument) にセットしたメモリブロックへのポインタを返さねばなりません。型の :"
"c:member:`~PyTypeObject.tp_itemsize` がゼロでない場合、オブジェクトの :attr:"
"`ob_size` フィールドは *nitems* に初期化され、確保されるメモリブロックの長さ"
"は ``tp_basicsize + nitems*tp_itemsize`` を ``sizeof(void*)`` の倍数に切り上"
"げた値になるはずです; それ以外の場合、 *nitems* の値は使われず、メモリブロッ"
"クの長さは :c:member:`~PyTypeObject.tp_basicsize` になるはずです。"

#: ../../c-api/typeobj.rst:2379
msgid ""
"This function should not do any other instance initialization, not even to "
"allocate additional memory; that should be done by :c:member:`~PyTypeObject."
"tp_new`."
msgstr ""
"この関数では他のいかなるインスタンス初期化も行ってはなりません。追加のメモリ"
"割り当てすらも行ってはなりません。そのような処理は :c:member:`~PyTypeObject."
"tp_new` で行われるべきです。"

#: ../../c-api/typeobj.rst:2386
msgid "See :c:member:`~PyTypeObject.tp_vectorcall_offset`."
msgstr ""

#: ../../c-api/typeobj.rst:2388
msgid ""
"Arguments to ``vectorcallfunc`` are the same as for :c:func:"
"`_PyObject_Vectorcall`."
msgstr ""

#: ../../c-api/typeobj.rst:2394
msgid "See :c:member:`~PyTypeObject.tp_free`."
msgstr ":c:member:`~PyTypeObject.tp_free`  を参照してください。"

#: ../../c-api/typeobj.rst:2398
msgid "See :c:member:`~PyTypeObject.tp_new`."
msgstr ":c:member:`~PyTypeObject.tp_new` を参照してください。"

#: ../../c-api/typeobj.rst:2402
msgid "See :c:member:`~PyTypeObject.tp_init`."
msgstr ":c:member:`~PyTypeObject.tp_init` を参照してください。"

#: ../../c-api/typeobj.rst:2406
msgid "See :c:member:`~PyTypeObject.tp_repr`."
msgstr ":c:member:`~PyTypeObject.tp_repr` を参照してください。"

#: ../../c-api/typeobj.rst:2410 ../../c-api/typeobj.rst:2419
msgid "Return the value of the named attribute for the object."
msgstr "オブジェクトの属性の値を返します。"

#: ../../c-api/typeobj.rst:2414 ../../c-api/typeobj.rst:2425
msgid ""
"Set the value of the named attribute for the object. The value argument is "
"set to ``NULL`` to delete the attribute."
msgstr ""
"オブジェクトの属性に値を設定します。属性を削除するには、 value 引数に "
"``NULL`` を設定します。"

#: ../../c-api/typeobj.rst:2421
msgid "See :c:member:`~PyTypeObject.tp_getattro`."
msgstr ":c:member:`~PyTypeObject.tp_getattro` を参照してください。"

#: ../../c-api/typeobj.rst:2428
msgid "See :c:member:`~PyTypeObject.tp_setattro`."
msgstr ":c:member:`~PyTypeObject.tp_setattro` を参照してください。"

#: ../../c-api/typeobj.rst:2432
msgid "See :c:member:`~PyTypeObject.tp_descrget`."
msgstr ":c:member:`~PyTypeObject.tp_descrget` を参照してください。"

#: ../../c-api/typeobj.rst:2436
msgid "See :c:member:`~PyTypeObject.tp_descrset`."
msgstr ":c:member:`~PyTypeObject.tp_descrset` を参照してください。"

#: ../../c-api/typeobj.rst:2440
msgid "See :c:member:`~PyTypeObject.tp_hash`."
msgstr ":c:member:`~PyTypeObject.tp_hash` を参照してください。"

#: ../../c-api/typeobj.rst:2444
msgid "See :c:member:`~PyTypeObject.tp_richcompare`."
msgstr ":c:member:`~PyTypeObject.tp_richcompare` を参照してください。"

#: ../../c-api/typeobj.rst:2448
msgid "See :c:member:`~PyTypeObject.tp_iter`."
msgstr ":c:member:`~PyTypeObject.tp_iter` を参照してください。"

#: ../../c-api/typeobj.rst:2452
msgid "See :c:member:`~PyTypeObject.tp_iternext`."
msgstr ":c:member:`~PyTypeObject.tp_iternext` を参照してください。"

#: ../../c-api/typeobj.rst:2478
msgid "Examples"
msgstr "使用例"

#: ../../c-api/typeobj.rst:2480
msgid ""
"The following are simple examples of Python type definitions.  They include "
"common usage you may encounter.  Some demonstrate tricky corner cases.  For "
"more examples, practical info, and a tutorial, see :ref:`defining-new-types` "
"and :ref:`new-types-topics`."
msgstr ""
"ここでは Python の型定義の簡単な例をいくつか挙げます。これらの例にはあなたが"
"遭遇する共通的な利用例を含んでいます。いくつかの例ではトリッキーなコーナー"
"ケースを実演しています。より多くの例や実践的な情報、チュートリアルが必要な"
"ら、:ref:`defining-new-types` や :ref:`new-types-topics` を参照してください。"

#: ../../c-api/typeobj.rst:2485
msgid "A basic static type::"
msgstr "基本的な静的型::"

#: ../../c-api/typeobj.rst:2502
msgid ""
"You may also find older code (especially in the CPython code base) with a "
"more verbose initializer::"
msgstr ""
"より冗長な初期化子を用いた古いコードを（特にCPythonのコードベース中で）見かけ"
"ることがあるかもしれません::"

#: ../../c-api/typeobj.rst:2546
msgid "A type that supports weakrefs, instance dicts, and hashing::"
msgstr "弱酸庄屋、インスタンス辞書、ハッシュをサポートする型::"

#: ../../c-api/typeobj.rst:2573
msgid ""
"A str subclass that cannot be subclassed and cannot be called to create "
"instances (e.g. uses a separate factory func)::"
msgstr ""
"サブクラス化を許可せず、インスタンスを生成するのに呼び出せない（つまり、別の"
"ファクトリー関数を呼び出す必要のある）str のサブクラス::"

#: ../../c-api/typeobj.rst:2592
msgid "The simplest static type (with fixed-length instances)::"
msgstr "もっとも単純な静的型(固定長のインスタンス)::"

#: ../../c-api/typeobj.rst:2603
msgid "The simplest static type (with variable-length instances)::"
msgstr "もっとも単純な静的型（可変長インスタンス）"
