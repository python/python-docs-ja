# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Nozomu Kaneko <nozom.kaneko@gmail.com>, 2017
# Arihiro TAKASE, 2017
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2017
# Kenji Noguchi <tokyo246@gmail.com>, 2017
# Naoki INADA <songofacandy@gmail.com>, 2017
# tomoğŸ§, 2017
# Osamu NAKAMURA, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-30 05:56+0900\n"
"PO-Revision-Date: 2017-02-16 17:33+0000\n"
"Last-Translator: Osamu NAKAMURA, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/arg.rst:6
msgid "Parsing arguments and building values"
msgstr "å¼•æ•°ã®è§£é‡ˆã¨å€¤ã®æ§‹ç¯‰"

#: ../../c-api/arg.rst:8
msgid ""
"These functions are useful when creating your own extensions functions and "
"methods.  Additional information and examples are available in :ref"
":`extending-index`."
msgstr ""
"ã“ã‚Œã‚‰ã®é–¢æ•°ã¯ç‹¬è‡ªã®æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ç”¨ã®é–¢æ•°ã‚„ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½œæˆã™ã‚‹éš›ã«ä¾¿åˆ©ã§ã™ã€‚è©³ã—ã„æƒ…å ±ã‚„ç”¨ä¾‹ã¯ :ref:`extending-index` "
"ã«ã‚ã‚Šã¾ã™ã€‚"

#: ../../c-api/arg.rst:12
msgid ""
"The first three of these functions described, :c:func:`PyArg_ParseTuple`, "
":c:func:`PyArg_ParseTupleAndKeywords`, and :c:func:`PyArg_Parse`, all use "
"*format strings* which are used to tell the function about the expected "
"arguments.  The format strings use the same syntax for each of these "
"functions."
msgstr ""
"æœ€åˆã«èª¬æ˜ã™ã‚‹ 3 ã¤ã®é–¢æ•°ã€ :c:func:`PyArg_ParseTuple`, "
":c:func:`PyArg_ParseTupleAndKeywords`,ãŠã‚ˆã³ :c:func:`PyArg_Parse` ã¯ã„ãšã‚Œã‚‚ *æ›¸å¼æ–‡å­—åˆ—"
" (format string)* "
"ã‚’ä½¿ã„ã¾ã™ã€‚æ›¸å¼æ–‡å­—åˆ—ã¯ã€é–¢æ•°ãŒå—ã‘å–ã‚‹ã¯ãšã®å¼•æ•°ã«é–¢ã™ã‚‹æƒ…å ±ã‚’ä¼ãˆã‚‹ã®ã«ç”¨ã„ã‚‰ã‚Œã¾ã™ã€‚ã„ãšã‚Œã®é–¢æ•°ã«ãŠã‘ã‚‹æ›¸å¼æ–‡å­—åˆ—ã‚‚ã€åŒã˜æ›¸å¼ã‚’ä½¿ã£ã¦ã„ã¾ã™ã€‚"

#: ../../c-api/arg.rst:19
msgid "Parsing arguments"
msgstr "å¼•æ•°ã‚’è§£æã™ã‚‹"

#: ../../c-api/arg.rst:21
msgid ""
"A format string consists of zero or more \"format units.\"  A format unit "
"describes one Python object; it is usually a single character or a "
"parenthesized sequence of format units.  With a few exceptions, a format "
"unit that is not a parenthesized sequence normally corresponds to a single "
"address argument to these functions.  In the following description, the "
"quoted form is the format unit; the entry in (round) parentheses is the "
"Python object type that matches the format unit; and the entry in [square] "
"brackets is the type of the C variable(s) whose address should be passed."
msgstr ""
"æ›¸å¼æ–‡å­—åˆ—ã¯ã€ã‚¼ãƒ­å€‹ã¾ãŸã¯ãã‚Œä»¥ä¸Šã® \"æ›¸å¼å˜ä½ (format unit)\" ã‹ã‚‰æˆã‚Šç«‹ã¡ã¾ã™ã€‚ 1ã¤ã®æ›¸å¼å˜ä½ã¯1ã¤ã® Python "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¡¨ã—ã¾ã™; "
"é€šå¸¸ã¯å˜ä¸€ã®æ–‡å­—ã‹ã€æ›¸å¼å˜ä½ã‹ã‚‰ãªã‚‹æ–‡å­—åˆ—ã‚’æ‹¬å¼§ã§å›²ã£ãŸã‚‚ã®ã«ãªã‚Šã¾ã™ã€‚ä¾‹å¤–ã¨ã—ã¦ã€æ‹¬å¼§ã§å›²ã‚ã‚Œã¦ã„ãªã„æ›¸å¼å˜ä½æ–‡å­—åˆ—ãŒå˜ä¸€ã®ã‚¢ãƒ‰ãƒ¬ã‚¹å¼•æ•°ã«å¯¾å¿œã™ã‚‹å ´åˆãŒã„ãã¤ã‹ã‚ã‚Šã¾ã™ã€‚ä»¥ä¸‹ã®èª¬æ˜ã§ã¯ã€å¼•ç”¨ç¬¦ã®ã¤ã„ãŸå½¢å¼ã¯æ›¸å¼å˜ä½ã§ã™;"
" (ä¸¸)æ‹¬å¼§ã§å›²ã£ãŸéƒ¨åˆ†ã¯æ›¸å¼å˜ä½ã«å¯¾å¿œã™ã‚‹ Python ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã§ã™; [è§’] æ‹¬å¼§ã¯å€¤ã‚’ã‚¢ãƒ‰ãƒ¬ã‚¹æ¸¡ã—ã™ã‚‹éš›ã«ä½¿ã† C ã®å¤‰æ•°å‹ã§ã™ã€‚"

#: ../../c-api/arg.rst:31
msgid "Strings and buffers"
msgstr "æ–‡å­—åˆ—ã¨ãƒãƒƒãƒ•ã‚¡"

#: ../../c-api/arg.rst:33
msgid ""
"These formats allow accessing an object as a contiguous chunk of memory. You"
" don't have to provide raw storage for the returned unicode or bytes area."
msgstr ""
"ä»¥ä¸‹ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«é€£ç¶šã—ãŸãƒ¡ãƒ¢ãƒªãƒãƒ£ãƒ³ã‚¯ã¨ã—ã¦ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã®ã‚‚ã®ã§ã™ã€‚è¿”ã•ã‚Œã‚‹ unicode ã‚„ bytes "
"ã®ãŸã‚ã«ç”Ÿã®ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚’ç”¨æ„ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/arg.rst:37
msgid ""
"In general, when a format sets a pointer to a buffer, the buffer is managed "
"by the corresponding Python object, and the buffer shares the lifetime of "
"this object.  You won't have to release any memory yourself. The only "
"exceptions are ``es``, ``es#``, ``et`` and ``et#``."
msgstr ""
"ä¸€èˆ¬ã«ã€ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãŒãƒãƒƒãƒ•ã‚¡ã«ãƒã‚¤ãƒ³ã‚¿ã‚’ã‚»ãƒƒãƒˆã™ã‚‹æ™‚ã¯ã€ãã®ãƒãƒƒãƒ•ã‚¡ã¯å¯¾å¿œã™ã‚‹ Python "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ˆã‚Šç®¡ç†ã•ã‚Œã€ãƒãƒƒãƒ•ã‚¡ã¯ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚’å…±æœ‰ã—ã¾ã™ã€‚è‡ªåˆ†è‡ªèº«ã§ãƒ¡ãƒ¢ãƒªã‚’è§£æ”¾ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®ä¾‹å¤–ã¯ã€ "
"``es``, ``es#``, ``et``, ``et#`` ã ã‘ã§ã™ã€‚"

#: ../../c-api/arg.rst:42
msgid ""
"However, when a :c:type:`Py_buffer` structure gets filled, the underlying "
"buffer is locked so that the caller can subsequently use the buffer even "
"inside a :c:type:`Py_BEGIN_ALLOW_THREADS` block without the risk of mutable "
"data being resized or destroyed.  As a result, **you have to call** "
":c:func:`PyBuffer_Release` after you have finished processing the data (or "
"in any early abort case)."
msgstr ""
"ãŸã ã—ã€ :c:type:`Py_buffer` æ§‹é€ ä½“ã«æ ¼ç´ã•ã‚ŒãŸãƒãƒƒãƒ•ã‚¡ãƒ¼ã¯ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã€å‘¼ã³å‡ºã—å´ã¯ãã®ãƒãƒƒãƒ•ã‚¡ãƒ¼ã‚’ "
":c:type:`Py_BEGIN_ALLOW_THREADS` ãƒ–ãƒ­ãƒƒã‚¯å†…ã§ã‚‚ã€ mutable "
"ãªãƒ‡ãƒ¼ã‚¿ãŒç ´æ£„ã•ã‚ŒãŸã‚Šãƒªã‚µã‚¤ã‚ºã•ã‚ŒãŸã‚Šã™ã‚‹ãƒªã‚¹ã‚¯ç„¡ã—ã«åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãã®ã‹ã‚ã‚Šã«ã€ãã®ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã™ã‚‹å‡¦ç†ãŒçµ‚ã‚ã£ãŸå ´åˆ "
"(ã‚‚ã—ãã¯å‡¦ç†ã›ãšã«ä¸­æ–­ã—ãŸå ´åˆ) ã«ã¯ **å¿…ãš** :c:func:`PyBuffer_Release` ã‚’å‘¼ã°ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/arg.rst:49
msgid "Unless otherwise stated, buffers are not NUL-terminated."
msgstr "ç‰¹ã«è¨€åŠã•ã‚Œã¦ã„ãªã„å ´åˆã€ãƒãƒƒãƒ•ã‚¡ãƒ¼ã¯ NUL çµ‚ç«¯ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"

#: ../../c-api/arg.rst:51
msgid ""
"Some formats require a read-only :term:`bytes-like object`, and set a "
"pointer instead of a buffer structure.  They work by checking that the "
"object's :c:member:`PyBufferProcs.bf_releasebuffer` field is *NULL*, which "
"disallows mutable objects such as :class:`bytearray`."
msgstr ""
"ã„ãã¤ã‹ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯èª­ã¿è¾¼ã¿å°‚ç”¨ã® :term:`bytes-like ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <bytes-like object>` "
"ã‚’å¿…è¦ã¨ã—ã€ãƒãƒƒãƒ•ã‚¡æ§‹é€ ä½“ã®ä»£ã‚ã‚Šã«ãƒã‚¤ãƒ³ã‚¿ã‚’ã‚»ãƒƒãƒˆã—ã¾ã™ã€‚ãã‚Œã‚‰ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® "
":c:member:`PyBufferProcs.bf_releasebuffer` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒ *NULL* "
"ã§ã‚ã‚‹ã“ã¨ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦å‹•ãã¾ã™ã€‚ã“ã‚Œã¯ :class:`bytearray` ãªã©ã®å¤‰æ›´å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç¦æ­¢ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:58
msgid ""
"For all ``#`` variants of formats (``s#``, ``y#``, etc.), the type of the "
"length argument (int or :c:type:`Py_ssize_t`) is controlled by defining the "
"macro :c:macro:`PY_SSIZE_T_CLEAN` before including :file:`Python.h`.  If the"
" macro was defined, length is a :c:type:`Py_ssize_t` rather than an "
":c:type:`int`. This behavior will change in a future Python version to only "
"support :c:type:`Py_ssize_t` and drop :c:type:`int` support. It is best to "
"always define :c:macro:`PY_SSIZE_T_CLEAN`."
msgstr ""
"å…¨ã¦ã® ``#`` å‹ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ (``s#``, ``y#``, ãªã©) ã«ãŠã„ã¦ã€length å¼•æ•°ã®å‹ (int ã‹ "
":c:type:`Py_ssize_t`) ã¯ :file:`Python.h` ã‚’ include ã™ã‚‹å‰ã« "
":c:macro:`PY_SSIZE_T_CLEAN` ãƒã‚¯ãƒ­ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã§åˆ¶å¾¡ã—ã¾ã™ã€‚ãƒã‚¯ãƒ­ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ length ã¯ "
":c:type:`int` å‹ã§ã¯ãªã :c:type:`Py_ssize_t` å‹ã«ãªã‚Šã¾ã™ã€‚ã“ã®æŒ™å‹•ã¯å°†æ¥ã® Python ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§å¤‰æ›´ã•ã‚Œã€ "
":c:type:`Py_ssize_t` ã®ã¿ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ :c:type:`int` ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œãªããªã‚‹ã§ã—ã‚‡ã†ã€‚å¸¸ã« "
":c:macro:`PY_SSIZE_T_CLEAN` ã‚’å®šç¾©ã—ãŸã»ã†ãŒè‰¯ã„ã§ã™ã€‚"

#: ../../c-api/arg.rst:85
msgid "``s`` (:class:`str`) [const char \\*]"
msgstr "``s`` (:class:`str`) [const char \\*]"

#: ../../c-api/arg.rst:68
msgid ""
"Convert a Unicode object to a C pointer to a character string. A pointer to "
"an existing string is stored in the character pointer variable whose address"
" you pass.  The C string is NUL-terminated. The Python string must not "
"contain embedded null code points; if it does, a :exc:`ValueError` exception"
" is raised. Unicode objects are converted to C strings using ``'utf-8'`` "
"encoding. If this conversion fails, a :exc:`UnicodeError` is raised."
msgstr ""
"Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã€ã‚­ãƒ£ãƒ©ã‚¯ã‚¿æ–‡å­—åˆ—ã‚’æŒ‡ã™ C "
"ã®ãƒã‚¤ãƒ³ã‚¿ã«å¤‰æ›ã—ã¾ã™ã€‚ã‚­ãƒ£ãƒ©ã‚¯ã‚¿å‹ãƒã‚¤ãƒ³ã‚¿å¤‰æ•°ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æ¸¡ã™ã¨ã€ã™ã§ã«å­˜åœ¨ã—ã¦ã„ã‚‹æ–‡å­—åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’ãã®å¤‰æ•°ã«è¨˜éŒ²ã—ã¾ã™ã€‚C æ–‡å­—åˆ—ã¯ NUL "
"ã§çµ‚ç«¯ã•ã‚Œã¦ã„ã¾ã™ã€‚Python ã®æ–‡å­—åˆ—å‹ã¯ã€ null ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆãŒé€”ä¸­ã«åŸ‹ã‚è¾¼ã¾ã‚Œã¦ã„ã¦ã¯ãªã‚Šã¾ã›ã‚“; ã‚‚ã—åŸ‹ã‚è¾¼ã¾ã‚Œã¦ã„ã‚Œã° "
":exc:`ValueError` ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ ``'utf-8'`` ã‚’ä½¿ã£ã¦ C "
"æ–‡å­—åˆ—ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚å¤‰æ›ã«å¤±æ•—ã™ã‚‹ã¨ :exc:`UnicodeError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:77
msgid ""
"This format does not accept :term:`bytes-like objects <bytes-like object>`."
"  If you want to accept filesystem paths and convert them to C character "
"strings, it is preferable to use the ``O&`` format with "
":c:func:`PyUnicode_FSConverter` as *converter*."
msgstr ""
"ã“ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ :term:`bytes-like objects <bytes-like object>` ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã›ã‚“ã€‚\n"
"ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ãƒ‘ã‚¹ã‚’å—ã‘å–ã£ã¦ C è¨€èªã®æ–‡å­—åˆ—ã«å¤‰æ›ã—ãŸã„å ´åˆã¯ã€ ``O&`` ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ã€\n"
"*converter* ã« :c:func:`PyUnicode_FSConverter` ã‚’æŒ‡å®šã—ã¦åˆ©ç”¨ã™ã‚‹ã¨è‰¯ã„ã§ã™ã€‚"

#: ../../c-api/arg.rst:83 ../../c-api/arg.rst:150
msgid ""
"Previously, :exc:`TypeError` was raised when embedded null code points were "
"encountered in the Python string."
msgstr "ä»¥å‰ã¯ Python æ–‡å­—åˆ—ã« null ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆãŒåŸ‹ã‚è¾¼ã¾ã‚Œã¦ã„ãŸã¨ãã« :exc:`TypeError` ã‚’é€å‡ºã—ã¦ã„ã¾ã—ãŸã€‚"

#: ../../c-api/arg.rst:91
msgid "``s*`` (:class:`str` or :term:`bytes-like object`) [Py_buffer]"
msgstr "``s*`` (:class:`str` ã¾ãŸã¯ :term:`bytes-like object`) [Py_buffer]"

#: ../../c-api/arg.rst:88
msgid ""
"This format accepts Unicode objects as well as bytes-like objects. It fills "
"a :c:type:`Py_buffer` structure provided by the caller. In this case the "
"resulting C string may contain embedded NUL bytes. Unicode objects are "
"converted to C strings using ``'utf-8'`` encoding."
msgstr ""
"ã“ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ bytes-like object ã‚’å—ã‘ä»˜ã‘ã¦ã€å‘¼ã³å‡ºã—å…ƒã‹ã‚‰æ¸¡ã•ã‚ŒãŸ :c:type:`Py_buffer` æ§‹é€ ä½“ã«å€¤ã‚’æ ¼ç´ã—ã¾ã™ã€‚\n"
"çµæœã® C æ–‡å­—åˆ—ã¯ NUL ãƒã‚¤ãƒˆã‚’å«ã‚€ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚\n"
"Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ ``'utf-8'`` ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§ C æ–‡å­—åˆ—ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/arg.rst:98
msgid ""
"``s#`` (:class:`str`, read-only :term:`bytes-like object`) [const char \\*, "
"int or :c:type:`Py_ssize_t`]"
msgstr ""
"``s#`` (:class:`str`, èª­ã¿å‡ºã—å°‚ç”¨ã® :term:`bytes-like object`) [const char \\*, "
"int or :c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:94
msgid ""
"Like ``s*``, except that it doesn't accept mutable objects. The result is "
"stored into two C variables, the first one a pointer to a C string, the "
"second one its length. The string may contain embedded null bytes. Unicode "
"objects are converted to C strings using ``'utf-8'`` encoding."
msgstr ""
"``s*`` ã¨åŒã˜ã§ã™ãŒã€ mutable "
"ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ã‘å–ã‚Šã¾ã›ã‚“ã€‚çµæœã¯2ã¤ã®Cå¤‰æ•°ã«æ ¼ç´ã•ã‚Œã¾ã™ã€‚1ã¤ç›®ã¯Cæ–‡å­—åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã§ã€2ã¤ç›®ã¯ãã®é•·ã•ã§ã™ã€‚å—ã‘å–ã£ãŸæ–‡å­—åˆ—ã¯ null "
"ãƒã‚¤ãƒˆã‚’å«ã‚€ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ ``'utf-8'`` ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’åˆ©ç”¨ã—ã¦ C æ–‡å­—åˆ—ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/arg.rst:102 ../../c-api/arg.rst:566
msgid "``z`` (:class:`str` or ``None``) [const char \\*]"
msgstr "``z`` (:class:`str` ã¾ãŸã¯ ``None``) [const char \\*]"

#: ../../c-api/arg.rst:101
msgid ""
"Like ``s``, but the Python object may also be ``None``, in which case the C "
"pointer is set to *NULL*."
msgstr ""
"``s`` ã«ä¼¼ã¦ã„ã¾ã™ãŒã€Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ ``None`` ã§ã‚‚ã‚ˆãã€ãã®å ´åˆã«ã¯ C ã®ãƒã‚¤ãƒ³ã‚¿ã¯ *NULL* ã«ã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/arg.rst:106
msgid ""
"``z*`` (:class:`str`, :term:`bytes-like object` or ``None``) [Py_buffer]"
msgstr ""
"``z*`` (:class:`str`, :term:`bytes-like object` ã¾ãŸã¯ ``None``) [Py_buffer]"

#: ../../c-api/arg.rst:105
msgid ""
"Like ``s*``, but the Python object may also be ``None``, in which case the "
"``buf`` member of the :c:type:`Py_buffer` structure is set to *NULL*."
msgstr ""
"``s*`` ã¨åŒã˜ã§ã™ãŒã€ Python ã® ``None`` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ã‘å–ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãã®å ´åˆã€ "
":c:type:`Py_buffer` æ§‹é€ ä½“ã® ``buf`` ãƒ¡ãƒ³ãƒãƒ¼ã¯ *NULL* ã«ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/arg.rst:110
msgid ""
"``z#`` (:class:`str`, read-only :term:`bytes-like object` or ``None``) "
"[const char \\*, int]"
msgstr ""
"``z#`` (:class:`str`, èª­ã¿å‡ºã—å°‚ç”¨ã® :term:`bytes-like object` ã¾ãŸã¯ ``None``) [const"
" char \\*, int]"

#: ../../c-api/arg.rst:109
msgid ""
"Like ``s#``, but the Python object may also be ``None``, in which case the C"
" pointer is set to *NULL*."
msgstr ""
"``s#`` ã«ä¼¼ã¦ã„ã¾ã™ãŒã€Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ ``None`` ã§ã‚‚ã‚ˆãã€ãã®å ´åˆã«ã¯ C ã®ãƒã‚¤ãƒ³ã‚¿ã¯ *NULL* ã«ã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/arg.rst:120
msgid "``y`` (read-only :term:`bytes-like object`) [const char \\*]"
msgstr "``y`` (èª­ã¿å‡ºã—å°‚ç”¨ã® :term:`bytes-like object`) [const char \\*]"

#: ../../c-api/arg.rst:113
msgid ""
"This format converts a bytes-like object to a C pointer to a character "
"string; it does not accept Unicode objects.  The bytes buffer must not "
"contain embedded null bytes; if it does, a :exc:`ValueError` exception is "
"raised."
msgstr ""
"ã“ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ bytes-like object ã‚’ã‚­ãƒ£ãƒ©ã‚¯ã‚¿æ–‡å­—åˆ—ã‚’æŒ‡ã™ C ã®ãƒã‚¤ãƒ³ã‚¿ã«å¤‰æ›ã—ã¾ã™; Unicode "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ã‘ä»˜ã‘ã¾ã›ã‚“ã€‚ãƒã‚¤ãƒˆãƒãƒƒãƒ•ã‚¡ã¯ null ãƒã‚¤ãƒˆã‚’å«ã‚€ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“; null ãƒã‚¤ãƒˆã‚’å«ã‚€å ´åˆã¯ "
":exc:`ValueError` ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:118
msgid ""
"Previously, :exc:`TypeError` was raised when embedded null bytes were "
"encountered in the bytes buffer."
msgstr "ä»¥å‰ã¯ bytes ãƒãƒƒãƒ•ã‚¡ã«ãƒŒãƒ«ãƒã‚¤ãƒˆãŒåŸ‹ã‚è¾¼ã¾ã‚Œã¦ã„ãŸã¨ãã« :exc:`TypeError` ã‚’é€å‡ºã—ã¦ã„ã¾ã—ãŸã€‚"

#: ../../c-api/arg.rst:125
msgid "``y*`` (:term:`bytes-like object`) [Py_buffer]"
msgstr "``y*`` (:term:`bytes-like object`) [Py_buffer]"

#: ../../c-api/arg.rst:123
msgid ""
"This variant on ``s*`` doesn't accept Unicode objects, only bytes-like "
"objects.  **This is the recommended way to accept binary data.**"
msgstr ""
"``s*`` ã®å¤‰å½¢ã§ã€ Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ã‘ä»˜ã‘ãšã€ bytes-like object ã®ã¿ã‚’å—ã‘ä»˜ã‘ã¾ã™ã€‚\n"
"**ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã‚’å—ã‘ä»˜ã‘ã‚‹ç›®çš„ã«ã¯ã€ã“ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ä½¿ã†ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ã€‚**"

#: ../../c-api/arg.rst:129
msgid "``y#`` (read-only :term:`bytes-like object`) [const char \\*, int]"
msgstr "``y#`` (èª­ã¿å‡ºã—å°‚ç”¨ã® :term:`bytes-like object`) [const char \\*, int]"

#: ../../c-api/arg.rst:128
msgid ""
"This variant on ``s#`` doesn't accept Unicode objects, only bytes-like "
"objects."
msgstr "``s#`` ã®å¤‰å½¢ã§ã€ Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ã‘ä»˜ã‘ãšã€bytes-like object ã ã‘ã‚’å—ã‘ä»˜ã‘ã¾ã™ã€‚"

#: ../../c-api/arg.rst:134
msgid "``S`` (:class:`bytes`) [PyBytesObject \\*]"
msgstr "``S`` (:class:`bytes`) [PyBytesObject \\*]"

#: ../../c-api/arg.rst:132
msgid ""
"Requires that the Python object is a :class:`bytes` object, without "
"attempting any conversion.  Raises :exc:`TypeError` if the object is not a "
"bytes object.  The C variable may also be declared as :c:type:`PyObject\\*`."
msgstr ""
"Pythonã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦ã€ :class:`bytes` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¦æ±‚ã—ã€ã„ã‹ãªã‚‹å¤‰æ›ã‚‚è¡Œã„ã¾ã›ã‚“ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ bytes "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ã€ :exc:`TypeError` ã‚’é€å‡ºã—ã¾ã™ã€‚C å¤‰æ•°ã¯ :c:type:`PyObject\\*` "
"ã¨å®£è¨€ã—ã¦ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚"

#: ../../c-api/arg.rst:139
msgid "``Y`` (:class:`bytearray`) [PyByteArrayObject \\*]"
msgstr "``Y`` (:class:`bytearray`) [PyByteArrayObject \\*]"

#: ../../c-api/arg.rst:137
msgid ""
"Requires that the Python object is a :class:`bytearray` object, without "
"attempting any conversion.  Raises :exc:`TypeError` if the object is not a "
":class:`bytearray` object. The C variable may also be declared as "
":c:type:`PyObject\\*`."
msgstr ""
"Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦ :class:`bytearray` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¦æ±‚ã—ã€ã„ã‹ãªã‚‹å¤‰æ›ã‚‚ãŠã“ãªã„ã¾ã›ã‚“ã€‚ ã‚‚ã—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ "
":class:`bytearray` ã§ãªã‘ã‚Œã°ã€ :exc:`TypeError` ã‚’é€å‡ºã—ã¾ã™ã€‚C å¤‰æ•°ã¯ "
":c:type:`PyObject\\*` ã¨ã—ã¦å®£è¨€ã—ã¦ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚"

#: ../../c-api/arg.rst:156
msgid "``u`` (:class:`str`) [const Py_UNICODE \\*]"
msgstr ""

#: ../../c-api/arg.rst:142
msgid ""
"Convert a Python Unicode object to a C pointer to a NUL-terminated buffer of"
" Unicode characters.  You must pass the address of a :c:type:`Py_UNICODE` "
"pointer variable, which will be filled with the pointer to an existing "
"Unicode buffer.  Please note that the width of a :c:type:`Py_UNICODE` "
"character depends on compilation options (it is either 16 or 32 bits). The "
"Python string must not contain embedded null code points; if it does, a "
":exc:`ValueError` exception is raised."
msgstr ""
"Python Unicodeã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ NULçµ‚ç«¯ã•ã‚ŒãŸUnicodeæ–‡å­—ãƒãƒƒãƒ•ã‚¡ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã«å¤‰æ›ã—ã¾ã™ã€‚ "
":c:type:`Py_UNICODE` ãƒã‚¤ãƒ³ã‚¿å¤‰æ•°ã¸ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æ¸¡ã•ãªã‘ã‚Œã°ãªã‚‰ãšã€ã“ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã«å­˜åœ¨ã™ã‚‹ Unicode "
"ãƒãƒƒãƒ•ã‚¡ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãŒæ ¼ç´ã•ã‚Œã¾ã™ã€‚ :c:type:`Py_UNICODE` æ–‡å­—ã®ãƒã‚¤ãƒˆå¹…ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚ªãƒ—ã‚·ãƒ§ãƒ³(16 "
"ã¾ãŸã¯32ãƒ“ãƒƒãƒˆã®ã©ã¡ã‚‰ã‹)ã«ä¾å­˜ã™ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚Python æ–‡å­—åˆ—ã¯ null ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’å«ã‚“ã§ã¯ãªã‚Šã¾ã›ã‚“; null "
"ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’å«ã‚€å ´åˆã€ :exc:`ValueError` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/arg.rst:157 ../../c-api/arg.rst:166 ../../c-api/arg.rst:174
#: ../../c-api/arg.rst:182
msgid ""
"Part of the old-style :c:type:`Py_UNICODE` API; please migrate to using "
":c:func:`PyUnicode_AsWideCharString`."
msgstr ""

#: ../../c-api/arg.rst:165
msgid "``u#`` (:class:`str`) [const Py_UNICODE \\*, int]"
msgstr ""

#: ../../c-api/arg.rst:159
msgid ""
"This variant on ``u`` stores into two C variables, the first one a pointer "
"to a Unicode data buffer, the second one its length.  This variant allows "
"null code points."
msgstr ""
"ã“ã‚Œã¯ ``u`` ã®ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ã§ã€å€¤ã‚’äºŒã¤ã®å¤‰æ•°ã«è¨˜éŒ²ã—ã¾ã™ã€‚ä¸€ã¤ç›®ã®å¤‰æ•°ã¯ Unicode "
"ãƒ‡ãƒ¼ã‚¿ãƒãƒƒãƒ•ã‚¡ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã§ã€äºŒã¤ç›®ã¯ãã®é•·ã•ã§ã™ã€‚ã“ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ null ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’å«ã‚€ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../c-api/arg.rst:173
msgid "``Z`` (:class:`str` or ``None``) [const Py_UNICODE \\*]"
msgstr ""

#: ../../c-api/arg.rst:168
msgid ""
"Like ``u``, but the Python object may also be ``None``, in which case the "
":c:type:`Py_UNICODE` pointer is set to *NULL*."
msgstr ""
"``u`` ã«ä¼¼ã¦ã„ã¾ã™ãŒã€Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ ``None`` ã§ã‚‚ã‚ˆãã€ãã®å ´åˆã«ã¯ :c:type:`Py_UNICODE` ãƒã‚¤ãƒ³ã‚¿ã¯"
" *NULL* ã«ã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/arg.rst:181
msgid "``Z#`` (:class:`str` or ``None``) [const Py_UNICODE \\*, int]"
msgstr ""

#: ../../c-api/arg.rst:176
msgid ""
"Like ``u#``, but the Python object may also be ``None``, in which case the "
":c:type:`Py_UNICODE` pointer is set to *NULL*."
msgstr ""
"``u#`` ã«ä¼¼ã¦ã„ã¾ã™ãŒã€ Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ ``None`` ã§ã‚‚ã‚ˆãã€ãã®å ´åˆã«ã¯ :c:type:`Py_UNICODE` "
"ãƒã‚¤ãƒ³ã‚¿ã¯ *NULL* ã«ã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/arg.rst:186
msgid "``U`` (:class:`str`) [PyObject \\*]"
msgstr "``U`` (:class:`str`) [PyObject \\*]"

#: ../../c-api/arg.rst:184
msgid ""
"Requires that the Python object is a Unicode object, without attempting any "
"conversion.  Raises :exc:`TypeError` if the object is not a Unicode object."
"  The C variable may also be declared as :c:type:`PyObject\\*`."
msgstr ""
"Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦ Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¦æ±‚ã—ã€ã„ã‹ãªã‚‹å¤‰æ›ã‚‚è¡Œã„ã¾ã›ã‚“ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ Unicode "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ãªã„å ´åˆã€ :exc:`TypeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚Cå¤‰æ•°ã¯ :c:type:`PyObject\\*` "
"ã¨ã—ã¦å®£è¨€ã—ã¦ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚"

#: ../../c-api/arg.rst:192
msgid "``w*`` (read-write :term:`bytes-like object`) [Py_buffer]"
msgstr "``w*`` (èª­ã¿æ›¸ãå¯èƒ½ãª :term:`bytes-like object`) [Py_buffer]"

#: ../../c-api/arg.rst:189
msgid ""
"This format accepts any object which implements the read-write buffer "
"interface. It fills a :c:type:`Py_buffer` structure provided by the caller. "
"The buffer may contain embedded null bytes. The caller have to call "
":c:func:`PyBuffer_Release` when it is done with the buffer."
msgstr ""
"ã“ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ã€èª­ã¿æ›¸ãå¯èƒ½ãª buffer interface ã‚’å®Ÿè£…ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ã‘ä»˜ã‘ã¾ã™ã€‚ å‘¼ã³å‡ºã—å…ƒã‹ã‚‰æ¸¡ã•ã‚ŒãŸ "
":c:type:`Py_buffer` æ§‹é€ ä½“ã«å€¤ã‚’æ ¼ç´ã—ã¾ã™ã€‚ãƒãƒƒãƒ•ã‚¡ã¯ nullãƒã‚¤ãƒˆã‚’å«ã‚€ã‹ã‚‚ã—ã‚Œãšã€å‘¼ã³å‡ºã—å…ƒã¯ãƒãƒƒãƒ•ã‚¡ã‚’ä½¿ã„çµ‚ã‚ã£ãŸã‚‰ "
":c:func:`PyBuffer_Release` ã‚’å‘¼ã³å‡ºã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/arg.rst:209
msgid "``es`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer]"
msgstr "``es`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer]"

#: ../../c-api/arg.rst:195
msgid ""
"This variant on ``s`` is used for encoding Unicode into a character buffer. "
"It only works for encoded data without embedded NUL bytes."
msgstr ""
"ã“ã‚Œã¯ ``s`` "
"ã®å¤‰åŒ–å½¢ã§ã€Unicodeã‚’ã‚­ãƒ£ãƒ©ã‚¯ã‚¿å‹ãƒãƒƒãƒ•ã‚¡ã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹ãŸã‚ã«ç”¨ã„ã‚‰ã‚Œã¾ã™ã€‚NULãƒã‚¤ãƒˆãŒåŸ‹ã‚è¾¼ã¾ã‚Œã¦ã„ãªã„ãƒ‡ãƒ¼ã‚¿ã§ã®ã¿å‹•ä½œã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:198
msgid ""
"This format requires two arguments.  The first is only used as input, and "
"must be a :c:type:`const char\\*` which points to the name of an encoding as"
" a NUL-terminated string, or *NULL*, in which case ``'utf-8'`` encoding is "
"used. An exception is raised if the named encoding is not known to Python.  "
"The second argument must be a :c:type:`char\\*\\*`; the value of the pointer"
" it references will be set to a buffer with the contents of the argument "
"text. The text will be encoded in the encoding specified by the first "
"argument."
msgstr ""
"ã“ã®æ›¸å¼ã«ã¯äºŒã¤ã®å¼•æ•°ãŒå¿…è¦ã§ã™ã€‚ä¸€ã¤ç›®ã¯å…¥åŠ›ã«ã®ã¿ç”¨ã„ã‚‰ã‚Œã€ NUL ã§çµ‚ç«¯ã•ã‚ŒãŸã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰åæ–‡å­—åˆ—ã‚’æŒ‡ã™ :c:type:`const "
"char\\*` å‹ã¾ãŸã¯ã€ ``'utf-8'`` ãŒä½¿ã‚ã‚Œã‚‹ã“ã¨ã‚’è¡¨ã™ *NULL* ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚æŒ‡å®šã—ãŸã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰åã‚’ Python "
"ãŒç†è§£ã§ããªã„å ´åˆã«ã¯ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚ç¬¬äºŒã®å¼•æ•°ã¯ :c:type:`char\\*\\*` ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“; "
"ã“ã®å¼•æ•°ãŒå‚ç…§ã—ã¦ã„ã‚‹ãƒã‚¤ãƒ³ã‚¿ã®å€¤ã¯ã€å¼•æ•°ã«æŒ‡å®šã—ãŸãƒ†ã‚­ã‚¹ãƒˆã®å†…å®¹ãŒå…¥ã£ãŸãƒãƒƒãƒ•ã‚¡ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã«ãªã‚Šã¾ã™ã€‚ãƒ†ã‚­ã‚¹ãƒˆã¯æœ€åˆã®å¼•æ•°ã«æŒ‡å®šã—ãŸã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰æ–¹å¼ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/arg.rst:206
msgid ""
":c:func:`PyArg_ParseTuple` will allocate a buffer of the needed size, copy "
"the encoded data into this buffer and adjust *\\*buffer* to reference the "
"newly allocated storage.  The caller is responsible for calling "
":c:func:`PyMem_Free` to free the allocated buffer after use."
msgstr ""
":c:func:`PyArg_ParseTuple` ã‚’ä½¿ã†ã¨ã€å¿…è¦ãªã‚µã‚¤ã‚ºã®ãƒãƒƒãƒ•ã‚¡ã‚’ç¢ºä¿ã—ã€ãã®ãƒãƒƒãƒ•ã‚¡ã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰å¾Œã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ã€ "
"*\\*buffer* ãŒã“ã®æ–°ãŸã«ç¢ºä¿ã•ã‚ŒãŸè¨˜æ†¶é ˜åŸŸã‚’æŒ‡ã™ã‚ˆã†ã«å¤‰æ›´ã—ã¾ã™ã€‚å‘¼ã³å‡ºã—å´ã«ã¯ã€ç¢ºä¿ã•ã‚ŒãŸãƒãƒƒãƒ•ã‚¡ã‚’ä½¿ã„çµ‚ã‚ã£ãŸå¾Œã« "
":c:func:`PyMem_Free` ã§è§£æ”¾ã™ã‚‹è²¬ä»»ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../c-api/arg.rst:214
msgid ""
"``et`` (:class:`str`, :class:`bytes` or :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer]"
msgstr ""
"``et`` (:class:`str`, :class:`bytes` ã¾ãŸã¯ :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer]"

#: ../../c-api/arg.rst:212
msgid ""
"Same as ``es`` except that byte string objects are passed through without "
"recoding them.  Instead, the implementation assumes that the byte string "
"object uses the encoding passed in as parameter."
msgstr ""
"``es`` "
"ã¨åŒã˜ã§ã™ã€‚ãŸã ã—ã€ãƒã‚¤ãƒˆæ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ç›´ã•ãšã«æ¸¡ã—ã¾ã™ã€‚ãã®ä»£ã‚ã‚Šã€å®Ÿè£…ã§ã¯ãƒã‚¤ãƒˆæ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãƒ‘ãƒ©ãƒ¡ã‚¿ã«æ¸¡ã—ãŸã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ã£ã¦ã„ã‚‹ã‚‚ã®ã¨ä»®å®šã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:245
msgid ""
"``es#`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer, int "
"\\*buffer_length]"
msgstr ""
"``es#`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer, int "
"\\*buffer_length]"

#: ../../c-api/arg.rst:217
msgid ""
"This variant on ``s#`` is used for encoding Unicode into a character buffer."
" Unlike the ``es`` format, this variant allows input data which contains NUL"
" characters."
msgstr ""
"``s#`` ã®å¤‰åŒ–å½¢ã§ã€Unicode ã‚’ã‚­ãƒ£ãƒ©ã‚¯ã‚¿å‹ãƒãƒƒãƒ•ã‚¡ã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹ãŸã‚ã«ç”¨ã„ã‚‰ã‚Œã¾ã™ã€‚``es`` "
"æ›¸å¼é•ã£ã¦ã€ã“ã®å¤‰åŒ–å½¢ã¯ãƒã‚¤ãƒˆãŒåŸ‹ã‚è¾¼ã¾ã‚Œã¦ã„ã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚"

#: ../../c-api/arg.rst:221
msgid ""
"It requires three arguments.  The first is only used as input, and must be a"
" :c:type:`const char\\*` which points to the name of an encoding as a NUL-"
"terminated string, or *NULL*, in which case ``'utf-8'`` encoding is used. An"
" exception is raised if the named encoding is not known to Python.  The "
"second argument must be a :c:type:`char\\*\\*`; the value of the pointer it "
"references will be set to a buffer with the contents of the argument text. "
"The text will be encoded in the encoding specified by the first argument. "
"The third argument must be a pointer to an integer; the referenced integer "
"will be set to the number of bytes in the output buffer."
msgstr ""
"ã“ã®æ›¸å¼ã«ã¯ä¸‰ã¤ã®å¼•æ•°ãŒå¿…è¦ã§ã™ã€‚ä¸€ã¤ç›®ã¯å…¥åŠ›ã«ã®ã¿ç”¨ã„ã‚‰ã‚Œã€ NUL ã§çµ‚ç«¯ã•ã‚ŒãŸã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰åæ–‡å­—åˆ—ã‚’æŒ‡ã™ :c:type:`const "
"char\\*` å‹ã‹ *NULL* ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ *NULL* ã®å ´åˆã«ã¯ ``'utf-8'`` ã‚’ä½¿ã„ã¾ã™ã€‚æŒ‡å®šã—ãŸã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰åã‚’ "
"Python ãŒç†è§£ã§ããªã„å ´åˆã«ã¯ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚ç¬¬äºŒã®å¼•æ•°ã¯ :c:type:`char\\*\\*` ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“; "
"ã“ã®å¼•æ•°ãŒå‚ç…§ã—ã¦ã„ã‚‹ãƒã‚¤ãƒ³ã‚¿ã®å€¤ã¯ã€å¼•æ•°ã«æŒ‡å®šã—ãŸãƒ†ã‚­ã‚¹ãƒˆã®å†…å®¹ãŒå…¥ã£ãŸãƒãƒƒãƒ•ã‚¡ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã«ãªã‚Šã¾ã™ã€‚ãƒ†ã‚­ã‚¹ãƒˆã¯æœ€åˆã®å¼•æ•°ã«æŒ‡å®šã—ãŸã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰æ–¹å¼ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚Œã¾ã™ã€‚ç¬¬ä¸‰ã®å¼•æ•°ã¯æ•´æ•°ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“;"
" ãƒã‚¤ãƒ³ã‚¿ãŒå‚ç…§ã—ã¦ã„ã‚‹æ•´æ•°ã®å€¤ã¯å‡ºåŠ›ãƒãƒƒãƒ•ã‚¡å†…ã®ãƒã‚¤ãƒˆæ•°ã«ã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/arg.rst:231
msgid "There are two modes of operation:"
msgstr "ã“ã®æ›¸å¼ã®å‡¦ç†ã«ã¯äºŒã¤ã®ãƒ¢ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã™:"

#: ../../c-api/arg.rst:233
msgid ""
"If *\\*buffer* points a *NULL* pointer, the function will allocate a buffer "
"of the needed size, copy the encoded data into this buffer and set "
"*\\*buffer* to reference the newly allocated storage.  The caller is "
"responsible for calling :c:func:`PyMem_Free` to free the allocated buffer "
"after usage."
msgstr ""
"*\\*buffer* ãŒ *NULL* "
"ãƒã‚¤ãƒ³ã‚¿ã‚’æŒ‡ã—ã¦ã„ã‚‹å ´åˆã€é–¢æ•°ã¯å¿…è¦ãªã‚µã‚¤ã‚ºã®ãƒãƒƒãƒ•ã‚¡ã‚’ç¢ºä¿ã—ã€ãã®ãƒãƒƒãƒ•ã‚¡ã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰å¾Œã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ã€ *\\*buffer* "
"ãŒã“ã®æ–°ãŸã«ç¢ºä¿ã•ã‚ŒãŸè¨˜æ†¶é ˜åŸŸã‚’æŒ‡ã™ã‚ˆã†ã«å¤‰æ›´ã—ã¾ã™ã€‚å‘¼ã³å‡ºã—å´ã«ã¯ã€ç¢ºä¿ã•ã‚ŒãŸãƒãƒƒãƒ•ã‚¡ã‚’ä½¿ã„çµ‚ã‚ã£ãŸå¾Œã« :c:func:`PyMem_Free` "
"ã§è§£æ”¾ã™ã‚‹è²¬ä»»ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../c-api/arg.rst:238
msgid ""
"If *\\*buffer* points to a non-*NULL* pointer (an already allocated buffer),"
" :c:func:`PyArg_ParseTuple` will use this location as the buffer and "
"interpret the initial value of *\\*buffer_length* as the buffer size.  It "
"will then copy the encoded data into the buffer and NUL-terminate it.  If "
"the buffer is not large enough, a :exc:`ValueError` will be set."
msgstr ""
"*\\*buffer* ãŒé *NULL* ã®ãƒã‚¤ãƒ³ã‚¿ (ã™ã§ã«ãƒ¡ãƒ¢ãƒªç¢ºä¿æ¸ˆã¿ã®ãƒãƒƒãƒ•ã‚¡) ã‚’æŒ‡ã—ã¦ã„ã‚‹å ´åˆã€ "
":c:func:`PyArg_ParseTuple` ã¯ã“ã®ãƒ¡ãƒ¢ãƒªä½ç½®ã‚’ãƒãƒƒãƒ•ã‚¡ã¨ã—ã¦ç”¨ã„ã€ *\\*buffer_length* "
"ã®åˆæœŸå€¤ã‚’ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºã¨ã—ã¦ç”¨ã„ã¾ã™ã€‚ PyArg_ParseTuple ã¯æ¬¡ã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰æ¸ˆã¿ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒãƒƒãƒ•ã‚¡ã«ã‚³ãƒ”ãƒ¼ã—ã¦ã€NUL "
"ã§çµ‚ç«¯ã—ã¾ã™ã€‚ãƒãƒƒãƒ•ã‚¡ã®å¤§ãã•ãŒè¶³ã‚Šãªã‘ã‚Œã° :exc:`ValueError` ãŒã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/arg.rst:244
msgid ""
"In both cases, *\\*buffer_length* is set to the length of the encoded data "
"without the trailing NUL byte."
msgstr "ã©ã¡ã‚‰ã®å ´åˆã‚‚ã€ *\\*buffer_length* ã¯çµ‚ç«¯ã® NUL ãƒã‚¤ãƒˆã‚’å«ã¾ãªã„ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰æ¸ˆã¿ãƒ‡ãƒ¼ã‚¿ã®é•·ã•ã«ã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/arg.rst:250
msgid ""
"``et#`` (:class:`str`, :class:`bytes` or :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer, int \\*buffer_length]"
msgstr ""
"``et#`` (:class:`str`, :class:`bytes` ã¾ãŸã¯ :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer, int \\*buffer_length]"

#: ../../c-api/arg.rst:248
msgid ""
"Same as ``es#`` except that byte string objects are passed through without "
"recoding them. Instead, the implementation assumes that the byte string "
"object uses the encoding passed in as parameter."
msgstr ""
"``es#`` "
"ã¨åŒã˜ã§ã™ã€‚ãŸã ã—ã€ãƒã‚¤ãƒˆæ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ç›´ã•ãšã«æ¸¡ã—ã¾ã™ã€‚ãã®ä»£ã‚ã‚Šã€å®Ÿè£…ã§ã¯ãƒã‚¤ãƒˆæ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãƒ‘ãƒ©ãƒ¡ã‚¿ã«æ¸¡ã—ãŸã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ã£ã¦ã„ã‚‹ã‚‚ã®ã¨ä»®å®šã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:253
msgid "Numbers"
msgstr "æ•°"

#: ../../c-api/arg.rst:257
msgid "``b`` (:class:`int`) [unsigned char]"
msgstr "``b`` (:class:`int`) [unsigned char]"

#: ../../c-api/arg.rst:256
msgid ""
"Convert a nonnegative Python integer to an unsigned tiny int, stored in a C "
":c:type:`unsigned char`."
msgstr "Python ã®éè² ã®æ•´æ•°ã‚’ã€ C ã® :c:type:`unsigned char` å‹ã®å°ã•ãªç¬¦å·ç„¡ã—æ•´æ•°ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:261 ../../c-api/arg.rst:600
msgid "``B`` (:class:`int`) [unsigned char]"
msgstr "``B`` (:class:`int`) [unsigned char]"

#: ../../c-api/arg.rst:260
msgid ""
"Convert a Python integer to a tiny int without overflow checking, stored in "
"a C :c:type:`unsigned char`."
msgstr ""
"Python ã®æ•´æ•°ã‚’ã€ã‚ªãƒ¼ãƒãƒ•ãƒ­ãƒ¼ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã‚ãšã«ã€ C ã® :c:type:`unsigned char` å‹ã®å°ã•ãªæ•´æ•°ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:264 ../../c-api/arg.rst:594
msgid "``h`` (:class:`int`) [short int]"
msgstr "``h`` (:class:`int`) [short int]"

#: ../../c-api/arg.rst:264
msgid "Convert a Python integer to a C :c:type:`short int`."
msgstr "Python ã®æ•´æ•°ã‚’ã€ C ã® :c:type:`short int` å‹ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:268 ../../c-api/arg.rst:603
msgid "``H`` (:class:`int`) [unsigned short int]"
msgstr "``H`` (:class:`int`) [unsigned short int]"

#: ../../c-api/arg.rst:267
msgid ""
"Convert a Python integer to a C :c:type:`unsigned short int`, without "
"overflow checking."
msgstr ""
"Python ã®æ•´æ•°ã‚’ã€ã‚ªãƒ¼ãƒãƒ•ãƒ­ãƒ¼ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã‚ãšã«ã€ C ã® :c:type:`unsigned short int` å‹ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:271 ../../c-api/arg.rst:588
msgid "``i`` (:class:`int`) [int]"
msgstr "``i`` (:class:`int`) [int]"

#: ../../c-api/arg.rst:271
msgid "Convert a Python integer to a plain C :c:type:`int`."
msgstr "Python ã®æ•´æ•°ã‚’ã€ C ã® :c:type:`int` å‹ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:275 ../../c-api/arg.rst:606
msgid "``I`` (:class:`int`) [unsigned int]"
msgstr "``I`` (:class:`int`) [unsigned int]"

#: ../../c-api/arg.rst:274
msgid ""
"Convert a Python integer to a C :c:type:`unsigned int`, without overflow "
"checking."
msgstr "Python ã®æ•´æ•°ã‚’ã€ã‚ªãƒ¼ãƒãƒ•ãƒ­ãƒ¼ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã‚ãšã«ã€ C ã® :c:type:`unsigned int` å‹ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:278 ../../c-api/arg.rst:597
msgid "``l`` (:class:`int`) [long int]"
msgstr "``l`` (:class:`int`) [long int]"

#: ../../c-api/arg.rst:278
msgid "Convert a Python integer to a C :c:type:`long int`."
msgstr "Python ã®æ•´æ•°ã‚’ã€ C ã® :c:type:`long int` å‹ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:282 ../../c-api/arg.rst:609
msgid "``k`` (:class:`int`) [unsigned long]"
msgstr "``k`` (:class:`int`) [unsigned long]"

#: ../../c-api/arg.rst:281
msgid ""
"Convert a Python integer to a C :c:type:`unsigned long` without overflow "
"checking."
msgstr "Python ã®æ•´æ•°ã‚’ã€ã‚ªãƒ¼ãƒãƒ•ãƒ­ãƒ¼ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã‚ãšã«ã€ C ã® :c:type:`unsigned long` å‹ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:285 ../../c-api/arg.rst:612
msgid "``L`` (:class:`int`) [long long]"
msgstr "``L`` (:class:`int`) [long long]"

#: ../../c-api/arg.rst:285
msgid "Convert a Python integer to a C :c:type:`long long`."
msgstr "Pythonã®intã‚’C :c:type:`long long` ã¸å¤‰æ›ã™ã‚‹ã€‚"

#: ../../c-api/arg.rst:289 ../../c-api/arg.rst:615
msgid "``K`` (:class:`int`) [unsigned long long]"
msgstr "``K`` (:class:`int`) [unsigned long long]"

#: ../../c-api/arg.rst:288
msgid ""
"Convert a Python integer to a C :c:type:`unsigned long long` without "
"overflow checking."
msgstr "Pythonã®intã‚’C :c:type:`unsigned long long` ã¸ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã®ç¢ºèªã‚’ã›ãšå¤‰æ›ã™ã‚‹"

#: ../../c-api/arg.rst:292 ../../c-api/arg.rst:618
msgid "``n`` (:class:`int`) [Py_ssize_t]"
msgstr "``n`` (:class:`int`) [Py_ssize_t]"

#: ../../c-api/arg.rst:292
msgid "Convert a Python integer to a C :c:type:`Py_ssize_t`."
msgstr "Python ã®æ•´æ•°ã‚’Cã® :c:type:`Py_ssize_t` å‹ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:299
msgid "``c`` (:class:`bytes` or :class:`bytearray` of length 1) [char]"
msgstr "``c`` (é•·ã• 1 ã®ã€ :class:`bytes` ã¾ãŸã¯ :class:`bytearray`) [char]"

#: ../../c-api/arg.rst:295
msgid ""
"Convert a Python byte, represented as a :class:`bytes` or :class:`bytearray`"
" object of length 1, to a C :c:type:`char`."
msgstr ""
"é•·ã• 1 ã® :class:`bytes` ã¾ãŸã¯ :class:`bytearray` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦è¡¨ç¾ã•ã‚Œã¦ã„ã‚‹ Python ãƒã‚¤ãƒˆã‚’ C "
"ã® :c:type:`char` å‹ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:298
msgid "Allow :class:`bytearray` objects."
msgstr ":class:`bytearray` ã‚’å—ã‘ä»˜ã‘ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../c-api/arg.rst:303 ../../c-api/arg.rst:626
msgid "``C`` (:class:`str` of length 1) [int]"
msgstr "``C`` (é•·ã• 1 ã® :class:`str`) [int]"

#: ../../c-api/arg.rst:302
msgid ""
"Convert a Python character, represented as a :class:`str` object of length "
"1, to a C :c:type:`int`."
msgstr ""
"é•·ã• 1 ã® :class:`str` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦è¡¨ç¾ã•ã‚Œã¦ã„ã‚‹ Python ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ã‚’ C ã® :c:type:`int` "
"å‹ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:306 ../../c-api/arg.rst:632
msgid "``f`` (:class:`float`) [float]"
msgstr "``f`` (:class:`float`) [float]"

#: ../../c-api/arg.rst:306
msgid "Convert a Python floating point number to a C :c:type:`float`."
msgstr "Python ã®æµ®å‹•å°æ•°ç‚¹å‹ã‚’ã€ C ã® :c:type:`float` å‹ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:309 ../../c-api/arg.rst:629
msgid "``d`` (:class:`float`) [double]"
msgstr "``d`` (:class:`float`) [double]"

#: ../../c-api/arg.rst:309
msgid "Convert a Python floating point number to a C :c:type:`double`."
msgstr "Python ã®æµ®å‹•å°æ•°ç‚¹å‹ã‚’ã€ C ã® :c:type:`double` å‹ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:312
msgid "``D`` (:class:`complex`) [Py_complex]"
msgstr "``D`` (:class:`complex`) [Py_complex]"

#: ../../c-api/arg.rst:312
msgid "Convert a Python complex number to a C :c:type:`Py_complex` structure."
msgstr "Python ã®è¤‡ç´ æ•°å‹ã‚’ã€ C ã® :c:type:`Py_complex` æ§‹é€ ä½“ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:315
msgid "Other objects"
msgstr "ãã®ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../c-api/arg.rst:320 ../../c-api/arg.rst:643
msgid "``O`` (object) [PyObject \\*]"
msgstr "``O`` (object) [PyObject \\*]"

#: ../../c-api/arg.rst:318
msgid ""
"Store a Python object (without any conversion) in a C object pointer.  The C"
" program thus receives the actual object that was passed.  The object's "
"reference count is not increased.  The pointer stored is not *NULL*."
msgstr ""
"Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ (ä¸€åˆ‡å¤‰æ›ã‚’è¡Œã‚ãšã«) C ã® Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ãƒã‚¤ãƒ³ã‚¿ã«ä¿å­˜ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€C "
"ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯å®Ÿéš›ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ã‘æ¸¡ã—ã•ã‚Œã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã¯å¢—åŠ ã—ã¾ã›ã‚“ã€‚ä¿å­˜ã•ã‚Œã‚‹ãƒã‚¤ãƒ³ã‚¿ãŒ *NULL* ã«ãªã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/arg.rst:327
msgid "``O!`` (object) [*typeobject*, PyObject \\*]"
msgstr "``O!`` (object) [*typeobject*, PyObject \\*]"

#: ../../c-api/arg.rst:323
msgid ""
"Store a Python object in a C object pointer.  This is similar to ``O``, but "
"takes two C arguments: the first is the address of a Python type object, the"
" second is the address of the C variable (of type :c:type:`PyObject\\*`) "
"into which the object pointer is stored.  If the Python object does not have"
" the required type, :exc:`TypeError` is raised."
msgstr ""
"Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ C ã® Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ãƒã‚¤ãƒ³ã‚¿ã«ä¿å­˜ã—ã¾ã™ã€‚ ``O`` ã«ä¼¼ã¦ã„ã¾ã™ãŒã€äºŒã¤ã® C ã®å¼•æ•°ã‚’ã¨ã‚Šã¾ã™: "
"ä¸€ã¤ç›®ã®å¼•æ•°ã¯ Python ã®å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã€äºŒã¤ç›®ã®å¼•æ•°ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ãŒä¿å­˜ã•ã‚Œã¦ã„ã‚‹ "
"(:c:type:`PyObject\\*` ã®) C ã®å¤‰æ•°ã¸ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã™ã€‚Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæŒ‡å®šã—ãŸå‹ã§ã¯ãªã„å ´åˆã€ "
":exc:`TypeError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:352 ../../c-api/arg.rst:657
msgid "``O&`` (object) [*converter*, *anything*]"
msgstr "``O&`` (object) [*converter*, *anything*]"

#: ../../c-api/arg.rst:332
msgid ""
"Convert a Python object to a C variable through a *converter* function.  "
"This takes two arguments: the first is a function, the second is the address"
" of a C variable (of arbitrary type), converted to :c:type:`void \\*`.  The "
"*converter* function in turn is called as follows::"
msgstr ""
"Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ *converter* é–¢æ•°ã‚’ä»‹ã—ã¦ C ã®å¤‰æ•°ã«å¤‰æ›ã—ã¾ã™ã€‚äºŒã¤ã®å¼•æ•°ã‚’ã¨ã‚Šã¾ã™: ä¸€ã¤ç›®ã¯é–¢æ•°ã§ã€äºŒã¤ç›®ã¯ "
"(ä»»æ„ã®å‹ã®) C å¤‰æ•°ã¸ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ :c:type:`void \\*` å‹ã«å¤‰æ›ã—ãŸã‚‚ã®ã§ã™ã€‚ *converter* "
"ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦å‘¼ã³å‡ºã•ã‚Œã¾ã™::"

#: ../../c-api/arg.rst:339
msgid ""
"where *object* is the Python object to be converted and *address* is the "
":c:type:`void\\*` argument that was passed to the :c:func:`PyArg_Parse\\*` "
"function. The returned *status* should be ``1`` for a successful conversion "
"and ``0`` if the conversion has failed.  When the conversion fails, the "
"*converter* function should raise an exception and leave the content of "
"*address* unmodified."
msgstr ""
"ã“ã“ã§ *object* ã¯å¤‰æ›å¯¾è±¡ã® Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã€ *address* ã¯ :c:func:`PyArg_Parse\\*` "
"ã«æ¸¡ã—ãŸ :c:type:`void\\*`  å‹ã®å¼•æ•°ã§ã™ã€‚æˆ»ã‚Šå€¤ *status* ã¯å¤‰æ›ã«æˆåŠŸã—ãŸéš›ã« ``1``,å¤±æ•—ã—ãŸå ´åˆã«ã¯ ``0`` "
"ã«ãªã‚Šã¾ã™ã€‚å¤‰æ›ã«å¤±æ•—ã—ãŸå ´åˆã€ *converter* é–¢æ•°ã¯ *address* ã®å†…å®¹ã‚’å¤‰æ›´ã›ãšã«ä¾‹å¤–ã‚’é€å‡ºã—ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/arg.rst:345
msgid ""
"If the *converter* returns ``Py_CLEANUP_SUPPORTED``, it may get called a "
"second time if the argument parsing eventually fails, giving the converter a"
" chance to release any memory that it had already allocated. In this second "
"call, the *object* parameter will be NULL; *address* will have the same "
"value as in the original call."
msgstr ""
"ã‚‚ã— *converter* ãŒ ``Py_CLEANUP_SUPPORTED`` "
"ã‚’è¿”ã™ã¨ã€å¼•æ•°ã®ãƒ‘ãƒ¼ã‚¹ãŒå¤±æ•—ã—ãŸéš›ã«ã€ã‚³ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ã‚’ã‚‚ã†ä¸€åº¦å‘¼ã³å‡ºã—ã€ã™ã§ã«å‰²ã‚Šå½“ã¦ãŸãƒ¡ãƒ¢ãƒªã‚’é–‹æ”¾ã™ã‚‹ãƒãƒ£ãƒ³ã‚¹ã‚’ä¸ãˆã¾ã™ã€‚äºŒåº¦ç›®ã®å‘¼ã³å‡ºã—ã§ã¯ "
"*object* å¼•æ•°ã¯ NULL ã«ãªã‚Šã€*address* ã¯æœ€åˆã®å‘¼ã³å‡ºã—ã¨åŒã˜å€¤ã«ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/arg.rst:351
msgid "``Py_CLEANUP_SUPPORTED`` was added."
msgstr "``Py_CLEANUP_SUPPORTED`` ã®è¿½åŠ ã€‚"

#: ../../c-api/arg.rst:361
msgid "``p`` (:class:`bool`) [int]"
msgstr "``p`` (:class:`bool`) [int]"

#: ../../c-api/arg.rst:355
msgid ""
"Tests the value passed in for truth (a boolean **p**\\ redicate) and "
"converts the result to its equivalent C true/false integer value. Sets the "
"int to ``1`` if the expression was true and ``0`` if it was false. This "
"accepts any valid Python value.  See :ref:`truth` for more information about"
" how Python tests values for truth."
msgstr ""
"çœŸå½å€¤ãŒæ±‚ã‚ã‚‰ã‚Œã‚‹ç®‡æ‰€ (a boolean **p**\\ redicate) ã«æ¸¡ã•ã‚ŒãŸå€¤ã‚’åˆ¤å®šã—ã€ãã®çµæœã‚’ç­‰ä¾¡ãª C ã® true/false æ•´æ•°å€¤ã«å¤‰æ›ã—ã¾ã™ã€‚\n"
"ã‚‚ã—å¼ãŒçœŸãªã‚‰ int ã«ã¯ ``1`` ãŒã€å½ãªã‚‰ ``0`` ãŒè¨­å®šã•ã‚Œã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ä»»æ„ã®æœ‰åŠ¹ãªPythonå€¤ã‚’å—ã‘ä»˜ã‘ã¾ã™ã€‚\n"
"PythonãŒå€¤ã®çœŸå½ã‚’ã©ã®ã‚ˆã†ã«åˆ¤å®šã™ã‚‹ã‹ã‚’çŸ¥ã‚ŠãŸã‘ã‚Œã°ã€ :ref:`truth` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../c-api/arg.rst:366 ../../c-api/arg.rst:660
msgid "``(items)`` (:class:`tuple`) [*matching-items*]"
msgstr "``(items)`` (:class:`tuple`) [*matching-items*]"

#: ../../c-api/arg.rst:364
msgid ""
"The object must be a Python sequence whose length is the number of format "
"units in *items*.  The C arguments must correspond to the individual format "
"units in *items*.  Format units for sequences may be nested."
msgstr ""
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ *items* ã«å…¥ã£ã¦ã„ã‚‹æ›¸å¼å˜ä½ã®æ•°ã ã‘ã®é•·ã•ã‚’æŒã¤ Python ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å„ C å¼•æ•°ã¯ "
"*items* å†…ã®å€‹ã€…ã®æ›¸å¼å˜ä½ã«å¯¾å¿œã¥ã‘ã§ããªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®æ›¸å¼å˜ä½ã¯å…¥ã‚Œå­æ§‹é€ ã«ã§ãã¾ã™ã€‚"

#: ../../c-api/arg.rst:368
msgid ""
"It is possible to pass \"long\" integers (integers whose value exceeds the "
"platform's :const:`LONG_MAX`) however no proper range checking is done --- "
"the most significant bits are silently truncated when the receiving field is"
" too small to receive the value (actually, the semantics are inherited from "
"downcasts in C --- your mileage may vary)."
msgstr ""
"\"é•·\" æ•´æ•° (ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã® :const:`LONG_MAX` ã‚’è¶…ãˆã‚‹å€¤ã®æ•´æ•°) ã‚’æ¸¡ã™ã®ã¯å¯èƒ½ã§ã™; "
"ã—ã‹ã—ãªãŒã‚‰ã€é©åˆ‡ãªå€¤åŸŸãƒã‚§ãƒƒã‚¯ã¯ã¾ã£ãŸãè¡Œã‚ã‚Œã¾ã›ã‚“ --- "
"å€¤ã‚’å—ã‘å–ã‚‹ãŸã‚ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒã€å€¤å…¨ã¦ã‚’å—ã‘å–ã‚‹ã«ã¯å°ã•ã™ãã‚‹å ´åˆã€ä¸Šæ¡ã®ãƒ“ãƒƒãƒˆç¾¤ã¯æš—é»™ã®ã†ã¡ã«åˆ‡ã‚Šè©°ã‚ã‚‰ã‚Œã¾ã™ (å®Ÿéš›ã®ã¨ã“ã‚ã€ã“ã®ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã¯ "
"C ã®ãƒ€ã‚¦ãƒ³ã‚­ãƒ£ã‚¹ãƒˆ (downcast) ã‹ã‚‰ç¶™æ‰¿ã—ã¦ã„ã¾ã™ --- ãã®æ©æµã¯äººãã‚Œãã‚Œã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒ)ã€‚"

#: ../../c-api/arg.rst:374
msgid ""
"A few other characters have a meaning in a format string.  These may not "
"occur inside nested parentheses.  They are:"
msgstr "ãã®ä»–ã€æ›¸å¼æ–‡å­—åˆ—ã«ãŠã„ã¦æ„å‘³ã‚’æŒã¤æ–‡å­—ãŒã„ãã¤ã‹ã‚ã‚Šã¾ã™ã€‚ãã‚Œã‚‰ã®æ–‡å­—ã¯æ‹¬å¼§ã«ã‚ˆã‚‹å…¥ã‚Œå­å†…ã«ã¯ä½¿ãˆã¾ã›ã‚“ã€‚ä»¥ä¸‹ã«æ–‡å­—ã‚’ç¤ºã—ã¾ã™:"

#: ../../c-api/arg.rst:382
msgid "``|``"
msgstr "``|``"

#: ../../c-api/arg.rst:378
msgid ""
"Indicates that the remaining arguments in the Python argument list are "
"optional. The C variables corresponding to optional arguments should be "
"initialized to their default value --- when an optional argument is not "
"specified, :c:func:`PyArg_ParseTuple` does not touch the contents of the "
"corresponding C variable(s)."
msgstr ""
"Python å¼•æ•°ãƒªã‚¹ãƒˆä¸­ã§ã€ã“ã®æ–‡å­—ä»¥é™ã®å¼•æ•°ãŒã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¼•æ•°ã«å¯¾å¿œã™ã‚‹ C "
"ã®å¤‰æ•°ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å€¤ã§åˆæœŸåŒ–ã—ã¦ãŠã‹ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ --- ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¼•æ•°ãŒçœç•¥ã•ã‚ŒãŸå ´åˆã€ "
":c:func:`PyArg_ParseTuple` ã¯å¯¾å¿œã™ã‚‹ C å¤‰æ•°ã®å†…å®¹ã«æ‰‹ã‚’åŠ ãˆã¾ã›ã‚“ã€‚"

#: ../../c-api/arg.rst:391
msgid "``$``"
msgstr "``$``"

#: ../../c-api/arg.rst:385
msgid ""
":c:func:`PyArg_ParseTupleAndKeywords` only: Indicates that the remaining "
"arguments in the Python argument list are keyword-only.  Currently, all "
"keyword-only arguments must also be optional arguments, so ``|`` must always"
" be specified before ``$`` in the format string."
msgstr ""
":c:func:`PyArg_ParseTupleAndKeywords` ã§ã®ã¿ä½¿ç”¨å¯èƒ½: å¾Œç¶šã®Pythonå¼•æ•°ãŒ keyword-"
"onlyã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚ç¾åœ¨ã€ã™ã¹ã¦ã®keyword-only å¼•æ•°ã¯ä»»æ„ã®å¼•æ•°ã§ãªã‘ã‚Œã°ãªã‚‰ãšã€ãã®ãŸã‚ ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ–‡å­—åˆ—ä¸­ã® ``|`` "
"ã¯å¸¸ã« ``$`` ã‚ˆã‚Šå‰ã«æŒ‡å®šã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/arg.rst:396
msgid "``:``"
msgstr "``:``"

#: ../../c-api/arg.rst:394
msgid ""
"The list of format units ends here; the string after the colon is used as "
"the function name in error messages (the \"associated value\" of the "
"exception that :c:func:`PyArg_ParseTuple` raises)."
msgstr ""
"ã“ã®æ–‡å­—ãŒã‚ã‚‹ã¨ã€æ›¸å¼å˜ä½ã®è¨˜è¿°ã¯ãã“ã§çµ‚ã‚ã‚Šã¾ã™; ã‚³ãƒ­ãƒ³ä»¥é™ã®æ–‡å­—åˆ—ã¯ã€ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ãŠã‘ã‚‹é–¢æ•°å "
"(:c:func:`PyArg_ParseTuple` ãŒé€å‡ºã™ã‚‹ä¾‹å¤–ã® \"ä»˜å±å€¤ (associated value)\") ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../c-api/arg.rst:401
msgid "``;``"
msgstr "``;``"

#: ../../c-api/arg.rst:399
msgid ""
"The list of format units ends here; the string after the semicolon is used "
"as the error message *instead* of the default error message.  ``:`` and "
"``;`` mutually exclude each other."
msgstr ""
"ã“ã®æ–‡å­—ãŒã‚ã‚‹ã¨ã€æ›¸å¼å˜ä½ã®è¨˜è¿°ã¯ãã“ã§çµ‚ã‚ã‚Šã¾ã™; ã‚»ãƒŸã‚³ãƒ­ãƒ³ä»¥é™ã®æ–‡å­—åˆ—ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ *ç½®ãæ›ãˆã‚‹* "
"ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚ ``:`` ã¨ ``;`` ã¯ç›¸äº’ã«æ’ä»–ã®æ–‡å­—ã§ã™ã€‚"

#: ../../c-api/arg.rst:403
msgid ""
"Note that any Python object references which are provided to the caller are "
"*borrowed* references; do not decrement their reference count!"
msgstr ""
"å‘¼ã³å‡ºã—å´ã«æä¾›ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã¯ã™ã¹ã¦ *å€Ÿç”¨* å‚ç…§ (borrowed reference) ã«ãªã‚Šã¾ã™; "
"ã“ã‚Œã‚‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã¦ã¯ãªã‚Šã¾ã›ã‚“!"

#: ../../c-api/arg.rst:406
msgid ""
"Additional arguments passed to these functions must be addresses of "
"variables whose type is determined by the format string; these are used to "
"store values from the input tuple.  There are a few cases, as described in "
"the list of format units above, where these parameters are used as input "
"values; they should match what is specified for the corresponding format "
"unit in that case."
msgstr ""
"ä»¥ä¸‹ã®é–¢æ•°ã«æ¸¡ã™è£œåŠ©å¼•æ•° (additional argument) ã¯ã€æ›¸å¼æ–‡å­—åˆ—ã‹ã‚‰æ±ºå®šã•ã‚Œã‚‹å‹ã¸ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“; "
"è£œåŠ©å¼•æ•°ã«æŒ‡å®šã—ãŸã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ã€ã‚¿ãƒ—ãƒ«ã‹ã‚‰å…¥åŠ›ã•ã‚ŒãŸå€¤ã‚’ä¿å­˜ã™ã‚‹ãŸã‚ã«ä½¿ã„ã¾ã™ã€‚ä¸Šã®æ›¸å¼å˜ä½ã®ãƒªã‚¹ãƒˆã§èª¬æ˜ã—ãŸã‚ˆã†ã«ã€è£œåŠ©å¼•æ•°ã‚’å…¥åŠ›å€¤ã¨ã—ã¦ä½¿ã†å ´åˆãŒã„ãã¤ã‹ã‚ã‚Šã¾ã™;"
" ãã®å ´åˆã€å¯¾å¿œã™ã‚‹æ›¸å¼å˜ä½ã®æŒ‡å®šã™ã‚‹å½¢å¼ã«å¾“ã†ã‚ˆã†ã«ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/arg.rst:412
msgid ""
"For the conversion to succeed, the *arg* object must match the format and "
"the format must be exhausted.  On success, the :c:func:`PyArg_Parse\\*` "
"functions return true, otherwise they return false and raise an appropriate "
"exception. When the :c:func:`PyArg_Parse\\*` functions fail due to "
"conversion failure in one of the format units, the variables at the "
"addresses corresponding to that and the following format units are left "
"untouched."
msgstr ""
"å¤‰æ›ã‚’æ­£ã—ãè¡Œã†ãŸã‚ã«ã¯ã€ *arg* "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ›¸å¼æ–‡å­—ã«ä¸€è‡´ã—ãªã‘ã‚Œã°ãªã‚‰ãšã€ã‹ã¤æ›¸å¼æ–‡å­—åˆ—å†…ã®æ›¸å¼å˜ä½ã«å…¨ã¦å€¤ãŒå…¥ã‚‹ã‚ˆã†ã«ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚æˆåŠŸã™ã‚‹ã¨ã€ "
":c:func:`PyArg_Parse\\*` "
"é–¢æ•°ã¯çœŸã‚’è¿”ã—ã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯å½ã‚’è¿”ã—ã€é©åˆ‡ãªä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚æ›¸å¼å˜ä½ã®ã©ã‚Œã‹ã®å¤‰æ›å¤±æ•—ã«ã‚ˆã‚Š "
":c:func:`PyArg_Parse\\*` ãŒå¤±æ•—ã—ãŸå ´åˆã€å¤±æ•—ã—ãŸæ›¸å¼å˜ä½ã«å¯¾å¿œã™ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ãã‚Œä»¥é™ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã®å†…å®¹ã¯å¤‰æ›´ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../c-api/arg.rst:421
msgid "API Functions"
msgstr "API é–¢æ•°"

#: ../../c-api/arg.rst:425
msgid ""
"Parse the parameters of a function that takes only positional parameters "
"into local variables.  Returns true on success; on failure, it returns false"
" and raises the appropriate exception."
msgstr ""
"ä½ç½®å¼•æ•°ã®ã¿ã‚’å¼•æ•°ã«ã¨ã‚‹é–¢æ•°ã®ãƒ‘ãƒ©ãƒ¡ã‚¿ã‚’è§£é‡ˆã—ã¦ã€ãƒ­ãƒ¼ã‚«ãƒ«ãªå¤‰æ•°ã«å¤‰æ›ã—ã¾ã™ã€‚æˆåŠŸã™ã‚‹ã¨çœŸã‚’è¿”ã—ã¾ã™;å¤±æ•—ã™ã‚‹ã¨å½ã‚’è¿”ã—ã€é©åˆ‡ãªä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:432
msgid ""
"Identical to :c:func:`PyArg_ParseTuple`, except that it accepts a va_list "
"rather than a variable number of arguments."
msgstr ":c:func:`PyArg_ParseTuple` ã¨åŒã˜ã§ã™ãŒã€å¯å¤‰é•·ã®å¼•æ•°ã§ã¯ãªã *va_list* ã‚’å¼•æ•°ã«ã¨ã‚Šã¾ã™ã€‚"

#: ../../c-api/arg.rst:438
msgid ""
"Parse the parameters of a function that takes both positional and keyword "
"parameters into local variables.  The *keywords* argument is a "
"*NULL*-terminated array of keyword parameter names.  Empty names denote :ref"
":`positional-only parameters <positional-only_parameter>`. Returns true on "
"success; on failure, it returns false and raises the appropriate exception."
msgstr ""
"ä½ç½®å¼•æ•°ã¨ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã®ä¸¡è€…ã‚’å–ã‚‹é–¢æ•°ã®å¼•æ•°ã‚’è§£é‡ˆã—ã¾ã™ã€‚ *keywords* å¼•æ•°ã¯ *NULL* ã§çµ‚ç«¯ã•ã‚ŒãŸã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰åã®é…åˆ—ã§ã™ã€‚\n"
"ç©ºã®åå‰ã¯ :ref:`ä½ç½®å¼•æ•°ã®ã¿ <positional-only_parameter>` ã‚’ç¤ºã—ã¾ã™ã€‚æˆåŠŸã—ãŸå ´åˆã€çœŸã‚’è¿”ã—ã¾ã™ã€‚å¤±æ•—ã—ãŸå ´åˆã¯å½ã‚’è¿”ã—ã€ã¾ãŸé©åˆ‡ãªä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚"

#: ../../c-api/arg.rst:445
msgid ""
"Added support for :ref:`positional-only parameters <positional-"
"only_parameter>`."
msgstr ":ref:`ä½ç½®å¼•æ•°ã®ã¿ <positional-only_parameter>` ã‚’è¿½åŠ ã—ãŸã€‚"

#: ../../c-api/arg.rst:452
msgid ""
"Identical to :c:func:`PyArg_ParseTupleAndKeywords`, except that it accepts a"
" va_list rather than a variable number of arguments."
msgstr ""
":c:func:`PyArg_ParseTupleAndKeywords` ã¨åŒã˜ã§ã™ãŒã€å¯å¤‰é•·ã®å¼•æ•°ã§ã¯ãªã *va_list* ã‚’å¼•æ•°ã«ã¨ã‚Šã¾ã™ã€‚"

#: ../../c-api/arg.rst:458
msgid ""
"Ensure that the keys in the keywords argument dictionary are strings.  This "
"is only needed if :c:func:`PyArg_ParseTupleAndKeywords` is not used, since "
"the latter already does this check."
msgstr ""
"ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’æ ¼ç´ã—ãŸè¾æ›¸ã®ã‚­ãƒ¼ãŒæ–‡å­—åˆ—ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ :c:func:`PyArg_ParseTupleAndKeywords`"
" ã‚’ä½¿ç”¨ã—ãªã„ã¨ãã«ã®ã¿å¿…è¦ã§ã€ãã®ç†ç”±ã¯å¾Œè€…ã®é–¢æ•°ã¯åŒæ§˜ã®ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿæ–½ã™ã‚‹ãŸã‚ã§ã™ã€‚"

#: ../../c-api/arg.rst:468
msgid ""
"Function used to deconstruct the argument lists of \"old-style\" functions "
"--- these are functions which use the :const:`METH_OLDARGS` parameter "
"parsing method, which has been removed in Python 3.  This is not recommended"
" for use in parameter parsing in new code, and most code in the standard "
"interpreter has been modified to no longer use this for that purpose.  It "
"does remain a convenient way to decompose other tuples, however, and may "
"continue to be used for that purpose."
msgstr ""
"\"æ—§ã‚¹ã‚¿ã‚¤ãƒ«\" ã®é–¢æ•°ã«ãŠã‘ã‚‹å¼•æ•°ãƒªã‚¹ãƒˆã‚’åˆ†æã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã‚‹é–¢æ•°ã§ã™ --- æ—§ã‚¹ã‚¿ã‚¤ãƒ«ã®é–¢æ•°ã¯ã€å¼•æ•°è§£é‡ˆæ‰‹æ³•ã«ã€Python 3 ã§å‰Šé™¤ã•ã‚ŒãŸ"
"  :const:`METH_OLDARGS` "
"ã‚’ä½¿ã„ã¾ã™ã€‚æ–°ãŸã«æ›¸ã‹ã‚Œã‚‹ã‚³ãƒ¼ãƒ‰ã§ã®ãƒ‘ãƒ©ãƒ¡ã‚¿è§£é‡ˆã«ã¯ã“ã®é–¢æ•°ã®ä½¿ç”¨ã¯å¥¨ã‚ã‚‰ã‚Œãšã€æ¨™æº–ã®ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ãŠã‘ã‚‹ã»ã¨ã‚“ã©ã®ã‚³ãƒ¼ãƒ‰ãŒã‚‚ã¯ã‚„å¼•æ•°è§£é‡ˆã®ãŸã‚ã«ã“ã®é–¢æ•°ã‚’ä½¿ã‚ãªã„ã‚ˆã†ã«å¤‰æ›´æ¸ˆã¿ã§ã™ã€‚ã“ã®é–¢æ•°ã‚’æ®‹ã—ã¦ã„ã‚‹ã®ã¯ã€ã“ã®é–¢æ•°ãŒä¾ç„¶ã¨ã—ã¦å¼•æ•°ä»¥å¤–ã®ã‚¿ãƒ—ãƒ«ã‚’åˆ†æã™ã‚‹ä¸Šã§ä¾¿åˆ©ã ã‹ã‚‰ã§ã™ãŒã€ã“ã®ç›®çš„ã«ãŠã„ã¦ã¯å°†æ¥ã‚‚ä½¿ã‚ã‚Œã¤ã¥ã‘ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../c-api/arg.rst:479
msgid ""
"A simpler form of parameter retrieval which does not use a format string to "
"specify the types of the arguments.  Functions which use this method to "
"retrieve their parameters should be declared as :const:`METH_VARARGS` in "
"function or method tables.  The tuple containing the actual parameters "
"should be passed as *args*; it must actually be a tuple.  The length of the "
"tuple must be at least *min* and no more than *max*; *min* and *max* may be "
"equal.  Additional arguments must be passed to the function, each of which "
"should be a pointer to a :c:type:`PyObject\\*` variable; these will be "
"filled in with the values from *args*; they will contain borrowed "
"references.  The variables which correspond to optional parameters not given"
" by *args* will not be filled in; these should be initialized by the caller."
" This function returns true on success and false if *args* is not a tuple or"
" contains the wrong number of elements; an exception will be set if there "
"was a failure."
msgstr ""
"ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å–å¾—ã‚’ç°¡å˜ã«ã—ãŸå½¢å¼ã§ã€å¼•æ•°ã®å‹ã‚’æŒ‡å®šã™ã‚‹æ›¸å¼æ–‡å­—åˆ—ã‚’ä½¿ã„ã¾ã›ã‚“ã€‚ãƒ‘ãƒ©ãƒ¡ã‚¿ã®å–å¾—ã«ã“ã®æ‰‹æ³•ã‚’ä½¿ã†é–¢æ•°ã¯ã€é–¢æ•°å®£è¨€ãƒ†ãƒ¼ãƒ–ãƒ«ã€ã¾ãŸã¯ãƒ¡ã‚½ãƒƒãƒ‰å®£è¨€ãƒ†ãƒ¼ãƒ–ãƒ«å†…ã§"
" :const:`METH_VARARGS` ã¨ã—ã¦å®£è¨€ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å®Ÿå¼•æ•°ã®å…¥ã£ãŸã‚¿ãƒ—ãƒ«ã¯ *args* ã«æ¸¡ã—ã¾ã™; "
"ã“ã®ã‚¿ãƒ—ãƒ«ã¯æœ¬å½“ã®ã‚¿ãƒ—ãƒ«ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚¿ãƒ—ãƒ«ã®é•·ã•ã¯å°‘ãªãã¨ã‚‚ *min* ã§ã€ *max* ã‚’è¶…ãˆã¦ã¯ãªã‚Šã¾ã›ã‚“; *min* ã¨ *max*"
" ãŒç­‰ã—ãã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚è£œåŠ©å¼•æ•°ã‚’é–¢æ•°ã«æ¸¡ã•ãªã‘ã‚Œã°ãªã‚‰ãšã€å„è£œåŠ©å¼•æ•°ã¯ :c:type:`PyObject\\*` "
"å¤‰æ•°ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“; ã“ã‚Œã‚‰ã®è£œåŠ©å¼•æ•°ã«ã¯ã€ *args* ã®å€¤ãŒå…¥ã‚Šã¾ã™; "
"å€¤ã®å‚ç…§ã¯å€Ÿç”¨å‚ç…§ã§ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ãƒ‘ãƒ©ãƒ¡ã‚¿ã«å¯¾å¿œã™ã‚‹å¤‰æ•°ã®ã†ã¡ã€ *args* ã«æŒ‡å®šã—ã¦ã„ãªã„ã‚‚ã®ã«ã¯å€¤ãŒå…¥ã‚Šã¾ã›ã‚“; "
"å‘¼ã³å‡ºã—å´ã¯ãã‚Œã‚‰ã®å€¤ã‚’åˆæœŸåŒ–ã—ã¦ãŠã‹ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®é–¢æ•°ã¯æˆåŠŸã™ã‚‹ã¨çœŸã‚’è¿”ã—ã€ *args* "
"ãŒã‚¿ãƒ—ãƒ«ã§ãªã„å ´åˆã‚„é–“é•ã£ãŸæ•°ã®è¦ç´ ãŒå…¥ã£ã¦ã„ã‚‹å ´åˆã«å½ã‚’è¿”ã—ã¾ã™; ä½•ã‚‰ã‹ã®å¤±æ•—ãŒèµ·ããŸå ´åˆã«ã¯ä¾‹å¤–ã‚’ã‚»ãƒƒãƒˆã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:493
msgid ""
"This is an example of the use of this function, taken from the sources for "
"the :mod:`_weakref` helper module for weak references::"
msgstr ""
"ã“ã®é–¢æ•°ã®ä½¿ç”¨ä¾‹ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™ã€‚ã“ã®ä¾‹ã¯ã€å¼±å‚ç…§ã®ãŸã‚ã® :mod:`_weakref` è£œåŠ©ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ã¨ã£ãŸã‚‚ã®ã§ã™::"

#: ../../c-api/arg.rst:509
msgid ""
"The call to :c:func:`PyArg_UnpackTuple` in this example is entirely "
"equivalent to this call to :c:func:`PyArg_ParseTuple`::"
msgstr ""
"ã“ã®ä¾‹ã«ãŠã‘ã‚‹ :c:func:`PyArg_UnpackTuple` å‘¼ã³å‡ºã—ã¯ã€ :c:func:`PyArg_ParseTuple` "
"ã‚’ä½¿ã£ãŸä»¥ä¸‹ã®å‘¼ã³å‡ºã—ã¨å…¨ãç­‰ä¾¡ã§ã™::"

#: ../../c-api/arg.rst:517
msgid "Building values"
msgstr "å€¤ã®æ§‹ç¯‰"

#: ../../c-api/arg.rst:521
msgid ""
"Create a new value based on a format string similar to those accepted by the"
" :c:func:`PyArg_Parse\\*` family of functions and a sequence of values.  "
"Returns the value or *NULL* in the case of an error; an exception will be "
"raised if *NULL* is returned."
msgstr ""
":c:func:`PyArg_Parse\\*` "
"ãƒ•ã‚¡ãƒŸãƒªã®é–¢æ•°ãŒå—ã‘å–ã‚‹ã®ã¨ä¼¼ãŸå½¢å¼ã®æ›¸å¼æ–‡å­—åˆ—ãŠã‚ˆã³å€¤åˆ—ã«åŸºã¥ã„ã¦ã€æ–°ãŸãªå€¤ã‚’ç”Ÿæˆã—ã¾ã™ã€‚ç”Ÿæˆã—ãŸå€¤ã‚’è¿”ã—ã¾ã™ã€‚ã‚¨ãƒ©ãƒ¼ã®å ´åˆã«ã¯ *NULL* "
"ã‚’è¿”ã—ã¾ã™; *NULL* ã‚’è¿”ã™å ´åˆã€ä¾‹å¤–ã‚’é€å‡ºã™ã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../c-api/arg.rst:526
msgid ""
":c:func:`Py_BuildValue` does not always build a tuple.  It builds a tuple "
"only if its format string contains two or more format units.  If the format "
"string is empty, it returns ``None``; if it contains exactly one format "
"unit, it returns whatever object is described by that format unit.  To force"
" it to return a tuple of size 0 or one, parenthesize the format string."
msgstr ""
":c:func:`Py_BuildValue` "
"ã¯å¸¸ã«ã‚¿ãƒ—ãƒ«ã‚’ç”Ÿæˆã™ã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚ã“ã®é–¢æ•°ãŒã‚¿ãƒ—ãƒ«ã‚’ç”Ÿæˆã™ã‚‹ã®ã¯ã€æ›¸å¼æ–‡å­—åˆ—ã«äºŒã¤ä»¥ä¸Šã®æ›¸å¼å˜ä½ãŒå…¥ã£ã¦ã„ã‚‹ã¨ãã ã‘ã§ã™ã€‚æ›¸å¼æ–‡å­—åˆ—ãŒç©ºã®å ´åˆ "
"``None`` ã‚’è¿”ã—ã¾ã™; æ›¸å¼å˜ä½ãŒå³å¯†ã«ä¸€ã¤ã ã‘å…¥ã£ã¦ã„ã‚‹å ´åˆã€æ›¸å¼å˜ä½ã§æŒ‡å®šã•ã‚Œã¦ã„ã‚‹ä½•ã‚‰ã‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå˜ä½“ã‚’è¿”ã—ã¾ã™ã€‚ã‚µã‚¤ã‚ºãŒã‚¼ãƒ­ã‚„ 1 "
"ã®ã‚¿ãƒ—ãƒ«ã‚’è¿”ã™ã‚ˆã†ã«å¼·åˆ¶ã™ã‚‹ã«ã¯ã€ä¸¸æ‹¬å¼§ã§å›²ã‚ã‚ŒãŸæ›¸å¼æ–‡å­—åˆ—ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../c-api/arg.rst:532
msgid ""
"When memory buffers are passed as parameters to supply data to build "
"objects, as for the ``s`` and ``s#`` formats, the required data is copied.  "
"Buffers provided by the caller are never referenced by the objects created "
"by :c:func:`Py_BuildValue`.  In other words, if your code invokes "
":c:func:`malloc` and passes the allocated memory to :c:func:`Py_BuildValue`,"
" your code is responsible for calling :c:func:`free` for that memory once "
":c:func:`Py_BuildValue` returns."
msgstr ""
"æ›¸å¼å˜ä½ ``s`` ã‚„ ``s#`` "
"ã®å ´åˆã®ã‚ˆã†ã«ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹ç¯‰ã™ã‚‹éš›ã«ãƒ‡ãƒ¼ã‚¿ã‚’ä¾›çµ¦ã™ã‚‹ãŸã‚ã«ãƒ¡ãƒ¢ãƒªãƒãƒƒãƒ•ã‚¡ã‚’ãƒ‘ãƒ©ãƒ¡ã‚¿ã¨ã—ã¦æ¸¡ã™å ´åˆã«ã¯ã€æŒ‡å®šã—ãŸãƒ‡ãƒ¼ã‚¿ã¯ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã™ã€‚ "
":c:func:`Py_BuildValue` ãŒç”Ÿæˆã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€å‘¼ã³å‡ºã—å´ãŒæä¾›ã—ãŸãƒãƒƒãƒ•ã‚¡ã‚’æ±ºã—ã¦å‚ç…§ã—ã¾ã›ã‚“ã€‚åˆ¥ã®è¨€ã„æ–¹ã‚’ã™ã‚Œã°ã€ "
":c:func:`malloc` ã‚’å‘¼ã³å‡ºã—ã¦ãƒ¡ãƒ¢ãƒªã‚’ç¢ºä¿ã—ã€ãã‚Œã‚’ :c:func:`Py_BuildValue` ã«æ¸¡ã—ãŸå ´åˆã€ã‚³ãƒ¼ãƒ‰å†…ã§ "
":c:func:`Py_BuildValue` ãŒè¿”ã£ãŸå¾Œã§ :c:func:`free` ã‚’å‘¼ã³å‡ºã™è²¬ä»»ãŒã‚ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚"

#: ../../c-api/arg.rst:540
msgid ""
"In the following description, the quoted form is the format unit; the entry "
"in (round) parentheses is the Python object type that the format unit will "
"return; and the entry in [square] brackets is the type of the C value(s) to "
"be passed."
msgstr ""
"ä»¥ä¸‹ã®èª¬æ˜ã§ã¯ã€å¼•ç”¨ç¬¦ã®ã¤ã„ãŸå½¢å¼ã¯æ›¸å¼å˜ä½ã§ã™; (ä¸¸)æ‹¬å¼§ã§å›²ã£ãŸéƒ¨åˆ†ã¯æ›¸å¼å˜ä½ãŒè¿”ã™ Python ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã§ã™; [è§’] "
"æ‹¬å¼§ã¯é–¢æ•°ã«æ¸¡ã™å€¤ã® C å¤‰æ•°å‹ã§ã™ã€‚"

#: ../../c-api/arg.rst:544
msgid ""
"The characters space, tab, colon and comma are ignored in format strings "
"(but not within format units such as ``s#``).  This can be used to make long"
" format strings a tad more readable."
msgstr ""
"æ›¸å¼æ–‡å­—åˆ—å†…ã§ã¯ã€(``s#`` ã®ã‚ˆã†ãªæ›¸å¼å˜ä½ã‚’é™¤ã„ã¦) "
"ã‚¹ãƒšãƒ¼ã‚¹ã€ã‚¿ãƒ–ã€ã‚³ãƒ­ãƒ³ãŠã‚ˆã³ã‚³ãƒ³ãƒã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‰ã®æ–‡å­—ã‚’ä½¿ã†ã¨ã€é•·ã„æ›¸å¼æ–‡å­—åˆ—ã‚’ã¡ã‚‡ã£ã¨ã ã‘èª­ã¿ã‚„ã™ãã§ãã¾ã™ã€‚"

#: ../../c-api/arg.rst:550
msgid "``s`` (:class:`str` or ``None``) [const char \\*]"
msgstr ""

#: ../../c-api/arg.rst:549
msgid ""
"Convert a null-terminated C string to a Python :class:`str` object using "
"``'utf-8'`` encoding. If the C string pointer is *NULL*, ``None`` is used."
msgstr ""
"nullçµ‚ç«¯ã•ã‚ŒãŸ C æ–‡å­—åˆ—ã‚’ã€ ``'utf-8'`` ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ç”¨ã„ã¦ã€ Python :class:`str` "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã—ã¾ã™ã€‚ã‚‚ã— C æ–‡å­—åˆ—ãƒã‚¤ãƒ³ã‚¿ãŒ *NULL* ã®å ´åˆã€ ``None`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/arg.rst:555
msgid "``s#`` (:class:`str` or ``None``) [const char \\*, int]"
msgstr ""

#: ../../c-api/arg.rst:553
msgid ""
"Convert a C string and its length to a Python :class:`str` object using "
"``'utf-8'`` encoding. If the C string pointer is *NULL*, the length is "
"ignored and ``None`` is returned."
msgstr ""
"C æ–‡å­—åˆ—ã¨ãã®é•·ã•ã‚’ ``'utf-8'`` ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ä½¿ã£ã¦ Python :class:`str` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã—ã¾ã™ã€‚C "
"æ–‡å­—åˆ—ãƒã‚¤ãƒ³ã‚¿ãŒ *NULL* ã®å ´åˆã€é•·ã•ã¯ç„¡è¦–ã•ã‚Œã€ ``None`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/arg.rst:559
msgid "``y`` (:class:`bytes`) [const char \\*]"
msgstr "``y`` (:class:`bytes`) [const char \\*]"

#: ../../c-api/arg.rst:558
msgid ""
"This converts a C string to a Python :class:`bytes` object.  If the C string"
" pointer is *NULL*, ``None`` is returned."
msgstr ""
"C æ–‡å­—åˆ—ã‚’Python :class:`bytes` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã—ã¾ã™ã€‚ã‚‚ã—C æ–‡å­—åˆ—ãƒã‚¤ãƒ³ã‚¿ãŒ *NULL* ã ã£ãŸå ´åˆã€``None`` "
"ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:563
msgid "``y#`` (:class:`bytes`) [const char \\*, int]"
msgstr "``y#`` (:class:`bytes`) [const char \\*, int]"

#: ../../c-api/arg.rst:562
msgid ""
"This converts a C string and its lengths to a Python object.  If the C "
"string pointer is *NULL*, ``None`` is returned."
msgstr ""
"ã“ã‚Œã¯ C æ–‡å­—åˆ—ã¨ãã®é•·ã•ã‹ã‚‰ Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã—ã¾ã™ã€‚C æ–‡å­—åˆ—ãƒã‚¤ãƒ³ã‚¿ãŒ *NULL* ã®å ´åˆã€é•·ã•ã¯ç„¡è¦–ã•ã‚Œ ``None`` "
"ã«ãªã‚Šã¾ã™ã€‚"

#: ../../c-api/arg.rst:566 ../../c-api/arg.rst:582
msgid "Same as ``s``."
msgstr "``s`` ã¨åŒã˜ã§ã™ã€‚"

#: ../../c-api/arg.rst:569
msgid "``z#`` (:class:`str` or ``None``) [const char \\*, int]"
msgstr ""

#: ../../c-api/arg.rst:569 ../../c-api/arg.rst:585
msgid "Same as ``s#``."
msgstr "``s#`` ã¨åŒã˜ã§ã™ã€‚"

#: ../../c-api/arg.rst:574
msgid "``u`` (:class:`str`) [const wchar_t \\*]"
msgstr ""

#: ../../c-api/arg.rst:572
msgid ""
"Convert a null-terminated :c:type:`wchar_t` buffer of Unicode (UTF-16 or "
"UCS-4) data to a Python Unicode object.  If the Unicode buffer pointer is "
"*NULL*, ``None`` is returned."
msgstr ""

#: ../../c-api/arg.rst:579
msgid "``u#`` (:class:`str`) [const wchar_t \\*, int]"
msgstr ""

#: ../../c-api/arg.rst:577
msgid ""
"Convert a Unicode (UTF-16 or UCS-4) data buffer and its length to a Python "
"Unicode object.   If the Unicode buffer pointer is *NULL*, the length is "
"ignored and ``None`` is returned."
msgstr ""

#: ../../c-api/arg.rst:582
msgid "``U`` (:class:`str` or ``None``) [const char \\*]"
msgstr ""

#: ../../c-api/arg.rst:585
msgid "``U#`` (:class:`str` or ``None``) [const char \\*, int]"
msgstr ""

#: ../../c-api/arg.rst:588
msgid "Convert a plain C :c:type:`int` to a Python integer object."
msgstr "é€šå¸¸ã® C ã® :c:type:`int` ã‚’ Python ã®æ•´æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:591
msgid "``b`` (:class:`int`) [char]"
msgstr "``b`` (:class:`int`) [char]"

#: ../../c-api/arg.rst:591
msgid "Convert a plain C :c:type:`char` to a Python integer object."
msgstr "é€šå¸¸ã®C ã® :c:type:`char` ã‚’ Python ã®æ•´æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:594
msgid "Convert a plain C :c:type:`short int` to a Python integer object."
msgstr "é€šå¸¸ã®C ã® :c:type:`short int` ã‚’ Python ã®æ•´æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:597
msgid "Convert a C :c:type:`long int` to a Python integer object."
msgstr "C ã® :c:type:`long int` ã‚’ Python ã®æ•´æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:600
msgid "Convert a C :c:type:`unsigned char` to a Python integer object."
msgstr "C ã® :c:type:`unsigned char` ã‚’ Python ã®æ•´æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:603
msgid "Convert a C :c:type:`unsigned short int` to a Python integer object."
msgstr "C ã® :c:type:`unsigned short int` ã‚’ Python ã®æ•´æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:606
msgid "Convert a C :c:type:`unsigned int` to a Python integer object."
msgstr "C ã® :c:type:`unsigned int` ã‚’ Python ã®æ•´æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:609
msgid "Convert a C :c:type:`unsigned long` to a Python integer object."
msgstr "C ã® :c:type:`unsigned long` ã‚’ Python ã®æ•´æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:612
msgid "Convert a C :c:type:`long long` to a Python integer object."
msgstr "C :c:type:`long long` ã‚’Pythonã®intã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸å¤‰æ›ã™ã‚‹ã€‚"

#: ../../c-api/arg.rst:615
msgid "Convert a C :c:type:`unsigned long long` to a Python integer object."
msgstr "C :c:type:`unsigned long long` ã‚’Pythonã®intã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸å¤‰æ›ã™ã‚‹ã€‚"

#: ../../c-api/arg.rst:618
msgid "Convert a C :c:type:`Py_ssize_t` to a Python integer."
msgstr "C ã® :c:type:`Py_ssize_t` ã‚’ Python ã®æ•´æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:622
msgid "``c`` (:class:`bytes` of length 1) [char]"
msgstr "``c`` (é•·ã•ãŒ 1 ã® :class:`bytes`) [char]"

#: ../../c-api/arg.rst:621
msgid ""
"Convert a C :c:type:`int` representing a byte to a Python :class:`bytes` "
"object of length 1."
msgstr ""
"ãƒã‚¤ãƒˆã‚’è¡¨ã™é€šå¸¸ã® C ã® :c:type:`int` ã‚’ã€é•·ã• 1 ã® Python ã® :class:`bytes` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:625
msgid ""
"Convert a C :c:type:`int` representing a character to Python :class:`str` "
"object of length 1."
msgstr ""
"æ–‡å­—ã‚’è¡¨ã™é€šå¸¸ã® C ã® :c:type:`int` ã‚’ã€é•·ã• 1 ã® Python ã® :class:`str` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:629
msgid "Convert a C :c:type:`double` to a Python floating point number."
msgstr "C ã® :c:type:`double` ã‚’ Python ã®æµ®å‹•å°æ•°ç‚¹æ•°ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:632
msgid "Convert a C :c:type:`float` to a Python floating point number."
msgstr "C ã® :c:type:`float` ã‚’ Python ã®æµ®å‹•å°æ•°ç‚¹æ•°ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:635
msgid "``D`` (:class:`complex`) [Py_complex \\*]"
msgstr "``D`` (:class:`complex`) [Py_complex \\*]"

#: ../../c-api/arg.rst:635
msgid "Convert a C :c:type:`Py_complex` structure to a Python complex number."
msgstr "C ã® :c:type:`Py_complex` æ§‹é€ ä½“ã‚’ Python ã®è¤‡ç´ æ•°å‹ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:638
msgid ""
"Pass a Python object untouched (except for its reference count, which is "
"incremented by one).  If the object passed in is a *NULL* pointer, it is "
"assumed that this was caused because the call producing the argument found "
"an error and set an exception. Therefore, :c:func:`Py_BuildValue` will "
"return *NULL* but won't raise an exception.  If no exception has been raised"
" yet, :exc:`SystemError` is set."
msgstr ""
"Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ‰‹ã‚’åŠ ãˆãšã«æ¸¡ã—ã¾ã™ (ãŸã ã—ã€å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã¯ 1 ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã¾ã™)ã€‚æ¸¡ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ *NULL* "
"ãƒã‚¤ãƒ³ã‚¿ã®å ´åˆã€ã“ã®å¼•æ•°ã‚’ç”Ÿæˆã™ã‚‹ã®ã«ä½¿ã£ãŸä½•ã‚‰ã‹ã®å‘¼ã³å‡ºã—ãŒã‚¨ãƒ©ãƒ¼ã«ãªã£ãŸã®ãŒåŸå› ã§ã‚ã‚‹ã¨ä»®å®šã—ã¦ã€ä¾‹å¤–ã‚’ã‚»ãƒƒãƒˆã—ã¾ã™ã€‚å¾“ã£ã¦ã“ã®ã¨ã "
":c:func:`Py_BuildValue` ã¯ *NULL* ã‚’è¿”ã—ã¾ã™ãŒä¾‹å¤–ã¯é€å‡ºã—ã¾ã›ã‚“ã€‚ä¾‹å¤–ã‚’ã¾ã é€å‡ºã—ã¦ã„ãªã‘ã‚Œã° "
":exc:`SystemError` ã‚’ã‚»ãƒƒãƒˆã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:646
msgid "``S`` (object) [PyObject \\*]"
msgstr "``S`` (object) [PyObject \\*]"

#: ../../c-api/arg.rst:646
msgid "Same as ``O``."
msgstr "``O`` ã¨åŒã˜ã§ã™ã€‚"

#: ../../c-api/arg.rst:651
msgid "``N`` (object) [PyObject \\*]"
msgstr "``N`` (object) [PyObject \\*]"

#: ../../c-api/arg.rst:649
msgid ""
"Same as ``O``, except it doesn't increment the reference count on the "
"object. Useful when the object is created by a call to an object constructor"
" in the argument list."
msgstr ""
"``O`` "
"ã¨åŒã˜ã§ã™ã€‚ãŸã ã—ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã¾ã›ã‚“ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå¼•æ•°ãƒªã‚¹ãƒˆå†…ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å‘¼ã³å‡ºã—ã«ã‚ˆã£ã¦ç”Ÿæˆã•ã‚Œã¦ã„ã‚‹å ´åˆã«ä¾¿åˆ©ã§ã™ã€‚"

#: ../../c-api/arg.rst:654
msgid ""
"Convert *anything* to a Python object through a *converter* function.  The "
"function is called with *anything* (which should be compatible with "
":c:type:`void \\*`) as its argument and should return a \"new\" Python "
"object, or *NULL* if an error occurred."
msgstr ""
"*anything* ã‚’ *converter* é–¢æ•°ã‚’ä»‹ã—ã¦ Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ *anything* "
"(:c:type:`void \\*` ã¨äº’æ›ã®å‹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“) ã‚’å¼•æ•°ã«ã—ã¦å‘¼ã³å‡ºã•ã‚Œã€\"æ–°ãŸãª\" ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ã‹ã€å¤±æ•—ã—ãŸå ´åˆã«ã¯"
" *NULL* ã‚’è¿”ã™ã‚ˆã†ã«ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../c-api/arg.rst:660
msgid ""
"Convert a sequence of C values to a Python tuple with the same number of "
"items."
msgstr "C ã®å€¤ã‹ã‚‰ãªã‚‹é…åˆ—ã‚’ã€åŒã˜è¦ç´ æ•°ã‚’æŒã¤ Python ã®ã‚¿ãƒ—ãƒ«ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:663
msgid "``[items]`` (:class:`list`) [*matching-items*]"
msgstr "``[items]`` (:class:`list`) [*matching-items*]"

#: ../../c-api/arg.rst:663
msgid ""
"Convert a sequence of C values to a Python list with the same number of "
"items."
msgstr "C ã®å€¤ã‹ã‚‰ãªã‚‹é…åˆ—ã‚’ã€åŒã˜è¦ç´ æ•°ã‚’æŒã¤ Python ã®ãƒªã‚¹ãƒˆã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:668
msgid "``{items}`` (:class:`dict`) [*matching-items*]"
msgstr "``{items}`` (:class:`dict`) [*matching-items*]"

#: ../../c-api/arg.rst:666
msgid ""
"Convert a sequence of C values to a Python dictionary.  Each pair of "
"consecutive C values adds one item to the dictionary, serving as key and "
"value, respectively."
msgstr "C ã®å€¤ã‹ã‚‰ãªã‚‹é…åˆ—ã‚’ Python ã®è¾æ›¸ã«å¤‰æ›ã—ã¾ã™ã€‚ä¸€é€£ã®ãƒšã‚¢ã‹ã‚‰ãªã‚‹ C ã®å€¤ãŒã€ãã‚Œãã‚Œã‚­ãƒ¼ãŠã‚ˆã³å€¤ã¨ãªã£ã¦è¾æ›¸ã«è¿½åŠ ã•ã‚Œã¾ã™ã€‚"

#: ../../c-api/arg.rst:670
msgid ""
"If there is an error in the format string, the :exc:`SystemError` exception "
"is set and *NULL* returned."
msgstr "æ›¸å¼æ–‡å­—åˆ—ã«é–¢ã™ã‚‹ã‚¨ãƒ©ãƒ¼ãŒç”Ÿã˜ã‚‹ã¨ã€ :exc:`SystemError` ä¾‹å¤–ã‚’ã‚»ãƒƒãƒˆã—ã¦ *NULL* ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../c-api/arg.rst:675
msgid ""
"Identical to :c:func:`Py_BuildValue`, except that it accepts a va_list "
"rather than a variable number of arguments."
msgstr ":c:func:`Py_BuildValue` ã¨åŒã˜ã§ã™ãŒã€å¯å¤‰é•·å¼•æ•°ã®ä»£ã‚ã‚Šã« va_list ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚"
