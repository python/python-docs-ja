# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# tomo, 2021
# mollinaca, 2021
# Takeshi Nakazato, 2021
# Atsuo Ishimoto <atsuoishimoto@gmail.com>, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-24 14:15+0000\n"
"PO-Revision-Date: 2021-06-28 00:51+0000\n"
"Last-Translator: Atsuo Ishimoto <atsuoishimoto@gmail.com>, 2022\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../distutils/setupscript.rst:5
msgid "Writing the Setup Script"
msgstr "setup スクリプトを書く"

#: ../../distutils/_setuptools_disclaimer.rst:3
msgid ""
"This document is being retained solely until the ``setuptools`` "
"documentation at https://setuptools.readthedocs.io/en/latest/setuptools.html "
"independently covers all of the relevant information currently included here."
msgstr ""
"このドキュメントは、 https://setuptools.readthedocs.io/en/latest/setuptools."
"html にある ``setuptools`` のドキュメントが現時点でここにある関連情報を全て網"
"羅するまで、単独でここに載せておかれます。"

#: ../../distutils/setupscript.rst:9
msgid ""
"The setup script is the centre of all activity in building, distributing, "
"and installing modules using the Distutils.  The main purpose of the setup "
"script is to describe your module distribution to the Distutils, so that the "
"various commands that operate on your modules do the right thing.  As we saw "
"in section :ref:`distutils-simple-example` above, the setup script consists "
"mainly of a call to :func:`setup`, and most information supplied to the "
"Distutils by the module developer is supplied as keyword arguments to :func:"
"`setup`."
msgstr ""
"setup スクリプトは、Distutils を使ってモジュールをビルドし、配布し、インス"
"トールする際の全ての動作の中心になります。 setup スクリプトの主な目的は、モ"
"ジュール配布物について Distutils に伝え、モジュール配布を操作するための様々な"
"コマンドを正しく動作させることにあります。上の :ref:`distutils-simple-"
"example` の節で見てきたように、 setup スクリプトは主に :func:`setup` の呼び出"
"しからなり、開発者が distutils に対して与えるほとんどの情報は :func:`setup` "
"のキーワード引数として指定されます。"

#: ../../distutils/setupscript.rst:17
msgid ""
"Here's a slightly more involved example, which we'll follow for the next "
"couple of sections: the Distutils' own setup script.  (Keep in mind that "
"although the Distutils are included with Python 1.6 and later, they also "
"have an independent existence so that Python 1.5.2 users can use them to "
"install other module distributions.  The Distutils' own setup script, shown "
"here, is used to install the package into Python 1.5.2.) ::"
msgstr ""
"ここではもう少しだけ複雑な例: Distutils 自体の setup スクリプト、を示します。"
"これについては、以降の二つの節でフォローします。 (Distutils が入っているのは "
"Python 1.6 以降であり、 Python 1.5.2 ユーザが他のモジュール配布物をインストー"
"ルできるようにするための独立したパッケージがあることを思い出してください。こ"
"こで示した、Distutils 自身の setup スクリプトは、Python 1.5.2 に Distutils "
"パッケージをインストールする際に使います。) ::"

#: ../../distutils/setupscript.rst:37
msgid ""
"There are only two differences between this and the trivial one-file "
"distribution presented in section :ref:`distutils-simple-example`: more "
"metadata, and the specification of pure Python modules by package, rather "
"than by module.  This is important since the Distutils consist of a couple "
"of dozen modules split into (so far) two packages; an explicit list of every "
"module would be tedious to generate and difficult to maintain.  For more "
"information on the additional meta-data, see section :ref:`meta-data`."
msgstr ""
"上の例と、 :ref:`distutils-simple-example` で示したファイル一つからなる小さな"
"配布物とは、違うところは二つしかありません: メタデータの追加と、モジュールで"
"はなくパッケージとして pure Python モジュール群を指定しているという点です。こ"
"の点は重要です。というのも、 Distutils は 2 ダースものモジュールが (今のとこ"
"ろ) 二つのパッケージに分かれて入っているからです; 各モジュールについていちい"
"ち明示的に記述したリストは、作成するのが面倒だし、維持するのも難しくなるで"
"しょう。その他のメタデータについては、 :ref:`meta-data` を参照してください。"

#: ../../distutils/setupscript.rst:45
msgid ""
"Note that any pathnames (files or directories) supplied in the setup script "
"should be written using the Unix convention, i.e. slash-separated.  The "
"Distutils will take care of converting this platform-neutral representation "
"into whatever is appropriate on your current platform before actually using "
"the pathname.  This makes your setup script portable across operating "
"systems, which of course is one of the major goals of the Distutils.  In "
"this spirit, all pathnames in this document are slash-separated."
msgstr ""
"setup スクリプトに与えるパス名 (ファイルまたはディレクトリ) は、 Unix におけ"
"るファイル名規約、つまりスラッシュ ('/') 区切りで書かねばなりません。"
"Distutils はこのプラットフォーム中立の表記を、実際にパス名として使う前に、現"
"在のプラットフォームに適した表記に注意深く変換します。この機能のおかげで、"
"setup スクリプトを異なるオペレーティングシステム間にわたって可搬性があるもの"
"にできます。言うまでもなく、これは Distutils の大きな目標の一つです。この精神"
"に従って、このドキュメントでは全てのパス名をスラッシュ区切りにしています。"

#: ../../distutils/setupscript.rst:53
msgid ""
"This, of course, only applies to pathnames given to Distutils functions.  If "
"you, for example, use standard Python functions such as :func:`glob.glob` "
"or :func:`os.listdir` to specify files, you should be careful to write "
"portable code instead of hardcoding path separators::"
msgstr ""
"もちろん、この取り決めは Distutils に渡すパス名だけに適用されます。もし、例え"
"ば :func:`glob.glob` や :func:`os.listdir` のような、標準の Python 関数を使っ"
"てファイル群を指定するのなら、パス区切り文字 (path separator) をハードコー"
"ディングせず、以下のように可搬性のあるコードを書くよう注意すべきです::"

#: ../../distutils/setupscript.rst:65
msgid "Listing whole packages"
msgstr "パッケージを全て列挙する"

#: ../../distutils/setupscript.rst:67
msgid ""
"The ``packages`` option tells the Distutils to process (build, distribute, "
"install, etc.) all pure Python modules found in each package mentioned in "
"the ``packages`` list.  In order to do this, of course, there has to be a "
"correspondence between package names and directories in the filesystem.  The "
"default correspondence is the most obvious one, i.e. package :mod:"
"`distutils` is found in the directory :file:`distutils` relative to the "
"distribution root. Thus, when you say ``packages = ['foo']`` in your setup "
"script, you are promising that the Distutils will find a file :file:`foo/"
"__init__.py` (which might be spelled differently on your system, but you get "
"the idea) relative to the directory where your setup script lives.  If you "
"break this promise, the Distutils will issue a warning but still process the "
"broken package anyway."
msgstr ""
"``packages`` オプションは、 ``packages`` リスト中で指定されている各々のパッ"
"ケージについて、パッケージ内に見つかった全ての pure Python モジュールを処理 "
"(ビルド、配布、インストール、等) するよう Distutils に指示します。このオプ"
"ションを指定するためには、当然のことながら各パッケージ名はファイルシステム上"
"のディレクトリ名と何らかの対応付けができなければなりません。デフォルトで使わ"
"れる対応関係はきわめてはっきりしたものです。すなわち、パッケージ :mod:"
"`distutils` が配布物ルートディレクトリからの相対パス :file:`distutils` で表さ"
"れるディレクトリ中にあるというものです。つまり、setup スクリプト中で "
"``packages = ['foo']`` と指定したら、スクリプトの置かれたディレクトリからの相"
"対パスで :file:`foo/__init__.py` を探し出せると Distutils に確約したことにな"
"ります。この約束を裏切ると Distutils は警告を出しますが、そのまま壊れたパッ"
"ケージの処理を継続します。"

#: ../../distutils/setupscript.rst:79
msgid ""
"If you use a different convention to lay out your source directory, that's "
"no problem: you just have to supply the ``package_dir`` option to tell the "
"Distutils about your convention.  For example, say you keep all Python "
"source under :file:`lib`, so that modules in the \"root package\" (i.e., not "
"in any package at all) are in :file:`lib`, modules in the :mod:`foo` package "
"are in :file:`lib/foo`, and so forth.  Then you would put ::"
msgstr ""
"ソースコードディレクトリの配置について違った規約を使っていても、まったく問題"
"はありません: 単に ``package_dir`` オプションを指定して、 Distutils に自分の"
"規約を教えればよいのです。例えば、全ての Python ソースコードを :file:`lib` 下"
"に置いて、 \"ルートパッケージ\" 内のモジュール (つまり、どのパッケージにも"
"入っていないモジュール) を :file:`lib` 内に入れ、 :mod:`foo` パッケージを :"
"file:`lib/foo` に入れる、といった具合にしたいのなら ::"

#: ../../distutils/setupscript.rst:88
msgid ""
"in your setup script.  The keys to this dictionary are package names, and an "
"empty package name stands for the root package.  The values are directory "
"names relative to your distribution root.  In this case, when you say "
"``packages = ['foo']``, you are promising that the file :file:`lib/foo/"
"__init__.py` exists."
msgstr ""
"を setup スクリプト内に入れます。辞書内のキーはパッケージ名で、空のパッケージ"
"名はルートパッケージを表します。キーに対応する値はルートパッケージからの相対"
"ディレクトリ名です、この場合、 ``packages = ['foo']`` を指定すれば、 :file:"
"`lib/foo/__init__.py` が存在すると Distutils に確約したことになります。"

#: ../../distutils/setupscript.rst:93
msgid ""
"Another possible convention is to put the :mod:`foo` package right in :file:"
"`lib`, the :mod:`foo.bar` package in :file:`lib/bar`, etc.  This would be "
"written in the setup script as ::"
msgstr ""
"もう一つの規約のあり方は :mod:`foo` パッケージを :file:`lib` に置き換え、 :"
"mod:`foo.bar` パッケージが :file:`lib/bar` にある、などとするものです。このよ"
"うな規約は、 setup スクリプトでは ::"

#: ../../distutils/setupscript.rst:99
msgid ""
"A ``package: dir`` entry in the ``package_dir`` dictionary implicitly "
"applies to all packages below *package*, so the :mod:`foo.bar` case is "
"automatically handled here.  In this example, having ``packages = ['foo', "
"'foo.bar']`` tells the Distutils to look for :file:`lib/__init__.py` and :"
"file:`lib/bar/__init__.py`.  (Keep in mind that although ``package_dir`` "
"applies recursively, you must explicitly list all packages in ``packages``: "
"the Distutils will *not* recursively scan your source tree looking for any "
"directory with an :file:`__init__.py` file.)"
msgstr ""
"のように書きます。 ``package_dir`` 辞書に ``package: dir`` のようなエントリが"
"あると、 *package* の下にある全てのパッケージに対してこの規則が暗黙のうちに適"
"用され、その結果 :mod:`foo.bar` の場合が自動的に処理されます。この例では、 "
"``packages = ['foo', 'foo.bar']`` は、 Distutils に :file:`lib/__init__.py` "
"と :file:`lib/bar/__init__.py` を探すように指示します。 (``package_dir`` は再"
"帰的に適用されますが、この場合 ``packages`` の下にある全てのパッケージを明示"
"的に指定しなければならないことを心に留めておいてください: Distutils は :file:"
"`__init__.py` を持つディレクトリをソースツリーから再帰的にさがしたりは *しま"
"せん* 。)"

#: ../../distutils/setupscript.rst:112
msgid "Listing individual modules"
msgstr "個々のモジュールを列挙する"

#: ../../distutils/setupscript.rst:114
msgid ""
"For a small module distribution, you might prefer to list all modules rather "
"than listing packages---especially the case of a single module that goes in "
"the \"root package\" (i.e., no package at all).  This simplest case was "
"shown in section :ref:`distutils-simple-example`; here is a slightly more "
"involved example::"
msgstr ""
"小さなモジュール配布物の場合、パッケージを列挙するよりも、全てのモジュールを"
"列挙するほうがよいと思うかもしれません --- 特に、単一のモジュールが \"ルート"
"パッケージ\" にインストールされる (すなわち、パッケージは全くない) ような場合"
"がそうです。この最も単純なケースは :ref:`distutils-simple-example` で示しまし"
"た; ここではもうちょっと入り組んだ例を示します::"

#: ../../distutils/setupscript.rst:121
msgid ""
"This describes two modules, one of them in the \"root\" package, the other "
"in the :mod:`pkg` package.  Again, the default package/directory layout "
"implies that these two modules can be found in :file:`mod1.py` and :file:"
"`pkg/mod2.py`, and that :file:`pkg/__init__.py` exists as well. And again, "
"you can override the package/directory correspondence using the "
"``package_dir`` option."
msgstr ""
"ここでは二つのモジュールについて述べていて、一方は \"ルート\" パッケージに入"
"り、他方は :mod:`pkg` パッケージに入ります。ここでも、デフォルトのパッケージ/"
"ディレクトリのレイアウトは、二つのモジュールが :file:`mod1.py` と :file:`pkg/"
"mod2.py` にあり、 :file:`pkg/__init__.py` が存在することを暗示しています。ま"
"た、パッケージ/ディレクトリの対応関係は ``package_dir`` オプションでも上書き"
"できます。"

#: ../../distutils/setupscript.rst:131
msgid "Describing extension modules"
msgstr "拡張モジュールについて記述する"

#: ../../distutils/setupscript.rst:133
msgid ""
"Just as writing Python extension modules is a bit more complicated than "
"writing pure Python modules, describing them to the Distutils is a bit more "
"complicated. Unlike pure modules, it's not enough just to list modules or "
"packages and expect the Distutils to go out and find the right files; you "
"have to specify the extension name, source file(s), and any compile/link "
"requirements (include directories, libraries to link with, etc.)."
msgstr ""
"pure Python モジュールを書くより Python 拡張モジュールを書く方がちょっとだけ"
"複雑なように、 Distutils での拡張モジュールに関する記述もちょっと複雑です。"
"pure モジュールと違い、単にモジュールやパッケージを列挙して、Distutils が正し"
"いファイルを見つけてくれると期待するだけでは十分ではありません; 拡張モジュー"
"ルの名前、ソースコードファイル (群) 、そして何らかのコンパイル/リンクに関する"
"必要事項 (include ディレクトリ、リンクすべきライブラリ、等) を指定しなければ"
"なりません。"

#: ../../distutils/setupscript.rst:142
msgid ""
"All of this is done through another keyword argument to :func:`setup`, the "
"``ext_modules`` option.  ``ext_modules`` is just a list of :class:"
"`~distutils.core.Extension` instances, each of which describes a single "
"extension module. Suppose your distribution includes a single extension, "
"called :mod:`foo` and implemented by :file:`foo.c`.  If no additional "
"instructions to the compiler/linker are needed, describing this extension is "
"quite simple::"
msgstr ""
"それらは全て、もう 1 つの :func:`setup` のオプション引数、 ``ext_modules`` オ"
"プションを通じて行われます。 ``ext_modules`` は単なる :class:`~distutils."
"core.Extension` のリストで、それぞれがある 1 つの拡張モジュールを記述していま"
"す。配布物に、 :mod:`foo` という名前の :file:`foo.c` に実装がある拡張モジュー"
"ルが 1 つ含まれているとします。コンパイラ/リンカへのこれ以上の指示が無い場合"
"は、拡張モジュールの記述は単純です::"

#: ../../distutils/setupscript.rst:152
msgid ""
"The :class:`Extension` class can be imported from :mod:`distutils.core` "
"along with :func:`setup`.  Thus, the setup script for a module distribution "
"that contains only this one extension and nothing else might be::"
msgstr ""
":class:`Extension` クラスは、 :func:`setup` によって、 :mod:`distutils.core` "
"から import されます。従って、拡張モジュールが一つだけ入っていて、他には何も"
"入っていないモジュール配布物を作成するための setup スクリプトは、以下のように"
"なるでしょう::"

#: ../../distutils/setupscript.rst:162
msgid ""
"The :class:`Extension` class (actually, the underlying extension-building "
"machinery implemented by the :command:`build_ext` command) supports a great "
"deal of flexibility in describing Python extensions, which is explained in "
"the following sections."
msgstr ""
":class:`Extension` クラス (実質的には、 :class:`Extension` クラスの根底にあ"
"る :command:`build_ext` コマンドで実装されている、拡張モジュールをビルドする"
"機構) は、Python 拡張モジュールをきわめて柔軟に記述できるようなサポートを提供"
"しています。これについては後の節で説明します。"

#: ../../distutils/setupscript.rst:169
msgid "Extension names and packages"
msgstr "拡張モジュールの名前とパッケージ"

#: ../../distutils/setupscript.rst:171
msgid ""
"The first argument to the :class:`~distutils.core.Extension` constructor is "
"always the name of the extension, including any package names.  For "
"example, ::"
msgstr ""
":class:`~distutils.core.Extension` コンストラクタの第 1 引数は、常に任意の"
"パッケージ名を含む拡張モジュールの名前です。例えば、 ::"

#: ../../distutils/setupscript.rst:176
msgid "describes an extension that lives in the root package, while ::"
msgstr ""
"とすると、拡張モジュールをルートパッケージに置くことになります。一方 ::"

#: ../../distutils/setupscript.rst:180
msgid ""
"describes the same extension in the :mod:`pkg` package.  The source files "
"and resulting object code are identical in both cases; the only difference "
"is where in the filesystem (and therefore where in Python's namespace "
"hierarchy) the resulting extension lives."
msgstr ""
"は、同じ拡張モジュールを :mod:`pkg` パッケージの下に置くよう記述しています。"
"ソースコードファイルと、作成されるオブジェクトコードはどちらの場合でも同じで"
"す; 作成された拡張モジュールがファイルシステム上のどこに置かれるか (すなわち "
"Python の名前空間上のどこに置かれるか) が違うにすぎません。"

#: ../../distutils/setupscript.rst:185
msgid ""
"If you have a number of extensions all in the same package (or all under the "
"same base package), use the ``ext_package`` keyword argument to :func:"
"`setup`.  For example, ::"
msgstr ""
"同じパッケージ内に (または、同じ基底パッケージ下に) いくつもの拡張モジュール"
"がある場合、 ``ext_package`` キーワード引数を :func:`setup` に指定します。例"
"えば、 ::"

#: ../../distutils/setupscript.rst:195
msgid ""
"will compile :file:`foo.c` to the extension :mod:`pkg.foo`, and :file:`bar."
"c` to :mod:`pkg.subpkg.bar`."
msgstr ""
"とすると、 :file:`foo.c` をコンパイルして :mod:`pkg.foo` にし、 :file:`bar."
"c` をコンパイルして :mod:`pkg.subpkg.bar` にします。"

#: ../../distutils/setupscript.rst:200
msgid "Extension source files"
msgstr "拡張モジュールのソースファイル"

#: ../../distutils/setupscript.rst:202
msgid ""
"The second argument to the :class:`~distutils.core.Extension` constructor is "
"a list of source files.  Since the Distutils currently only support C, C++, "
"and Objective-C extensions, these are normally C/C++/Objective-C source "
"files.  (Be sure to use appropriate extensions to distinguish C++ source "
"files: :file:`.cc` and :file:`.cpp` seem to be recognized by both Unix and "
"Windows compilers.)"
msgstr ""
":class:`~distutils.core.Extension` コンストラクタの第 2 引数は、ソースファイ"
"ルのリストです。 Distutils は現在 C 、 C++ 、 Objective-C 拡張モジュールしか"
"サポートしていないため、それらは通常は C/C++/Objective-C ソースファイルで"
"す。 (C++ ソースファイルと判別できるように適切な拡張子を使用するようにしてく"
"ださい: :file:`.cc` と :file:`.cpp` が Unix と Windows のコンパイラの両方が認"
"識できるようです。)"

#: ../../distutils/setupscript.rst:209
msgid ""
"However, you can also include SWIG interface (:file:`.i`) files in the list; "
"the :command:`build_ext` command knows how to deal with SWIG extensions: it "
"will run SWIG on the interface file and compile the resulting C/C++ file "
"into your extension."
msgstr ""
"ただし、 SWIG インターフェース (:file:`.i`) ファイルはリストに含められます; :"
"command:`build_ext` コマンドは、 SWIG で書かれた拡張パッケージをどう扱えばよ"
"いか心得ています: :command:`build_ext` は、インターフェースファイルを SWIG に"
"かけ、得られた C/C++ ファイルをコンパイルして拡張モジュールを生成します。"

#: ../../distutils/setupscript.rst:216
msgid ""
"This warning notwithstanding, options to SWIG can be currently passed like "
"this::"
msgstr ""
"この警告にかかわらず、現在次のようにしてSWIGに対してオプションを渡すことがで"
"きます::"

#: ../../distutils/setupscript.rst:225
msgid "Or on the commandline like this::"
msgstr "もしくは、次のようにコマンドラインからオプションを渡すこともできます::"

#: ../../distutils/setupscript.rst:229
msgid ""
"On some platforms, you can include non-source files that are processed by "
"the compiler and included in your extension.  Currently, this just means "
"Windows message text (:file:`.mc`) files and resource definition (:file:`."
"rc`) files for Visual C++. These will be compiled to binary resource (:file:"
"`.res`) files and linked into the executable."
msgstr ""
"プラットフォームによっては、コンパイラで処理され、拡張モジュールに取り込まれ"
"るような非ソースコードファイルを含められます。非ソースコードファイルとは、現"
"状では Visual C++向けの Windows メッセージテキスト (:file:`.mc`) ファイルや、"
"リソース定義 (:file:`.rc`) ファイルを指します。これらのファイルはバイナリリ"
"ソース (:file:`.res`) ファイルにコンパイルされ、実行ファイルにリンクされま"
"す。"

#: ../../distutils/setupscript.rst:237
msgid "Preprocessor options"
msgstr "プリプロセッサオプション"

#: ../../distutils/setupscript.rst:239
msgid ""
"Three optional arguments to :class:`~distutils.core.Extension` will help if "
"you need to specify include directories to search or preprocessor macros to "
"define/undefine: ``include_dirs``, ``define_macros``, and ``undef_macros``."
msgstr ""
"検索するインクルードディレクトリやプリプロセッサマクロの define/undefine を指"
"定する必要がある場合、 :class:`~distutils.core.Extension` の 3 つのオプション"
"引数が役に立ちます: ``include_dirs`` 、 ``define_macros`` 、 "
"``undef_macros`` です。"

#: ../../distutils/setupscript.rst:243
msgid ""
"For example, if your extension requires header files in the :file:`include` "
"directory under your distribution root, use the ``include_dirs`` option::"
msgstr ""
"例えば、拡張モジュールが配布物ルート下の :file:`include` ディレクトリにある"
"ヘッダファイルを必要とするときには、 ``include_dirs`` オプションを使います::"

#: ../../distutils/setupscript.rst:248
msgid ""
"You can specify absolute directories there; if you know that your extension "
"will only be built on Unix systems with X11R6 installed to :file:`/usr`, you "
"can get away with ::"
msgstr ""
"ここには絶対パスも指定できます; 例えば、自分の拡張モジュールが、 :file:`/"
"usr` の下にX11R6 をインストールした Unix システムだけでビルドされると知ってい"
"れば、このように書けます ::"

#: ../../distutils/setupscript.rst:254
msgid ""
"You should avoid this sort of non-portable usage if you plan to distribute "
"your code: it's probably better to write C code like  ::"
msgstr ""
"自分のコードを配布する際には、このような可搬性のない使い方は避けるべきです: "
"おそらく、C のコードを次のように書いたほうがましでしょう ::"

#: ../../distutils/setupscript.rst:259
msgid ""
"If you need to include header files from some other Python extension, you "
"can take advantage of the fact that header files are installed in a "
"consistent way by the Distutils :command:`install_headers` command.  For "
"example, the Numerical Python header files are installed (on a standard Unix "
"installation) to :file:`/usr/local/include/python1.5/Numerical`. (The exact "
"location will differ according to your platform and Python installation.)  "
"Since the Python include directory---\\ :file:`/usr/local/include/python1.5` "
"in this case---is always included in the search path when building Python "
"extensions, the best approach is to write C code like  ::"
msgstr ""
"他の Python 拡張モジュール由来のヘッダを include する必要があるなら、 "
"Distutils の :command:`install_header` コマンドが一貫した方法でヘッダファイル"
"をインストールするという事実を活用できます。例えば、 Numerical Python のヘッ"
"ダファイルは、 (標準的な Unix がインストールされた環境では) :file:`/usr/"
"local/include/python1.5/Numerical` にインストールされます。 (実際の場所は、プ"
"ラットフォームやどの Python をインストールしたかで異なります。) Python の "
"include ディレクトリ --- 今の例では :file:`/usr/local/include/python1.5` --- "
"は、 Python 拡張モジュールをビルドする際に常にヘッダファイル検索パスに取り込"
"まれるので、 C コードを書く上でもっともよいアプローチは、以下のようなものとな"
"ります ::"

#: ../../distutils/setupscript.rst:271
msgid ""
"If you must put the :file:`Numerical` include directory right into your "
"header search path, though, you can find that directory using the Distutils :"
"mod:`distutils.sysconfig` module::"
msgstr ""
":file:`Numerical` インクルードディレクトリ自体をヘッダ検索パスに置きたいのな"
"ら、このディレクトリを Distutils の :mod:`distutils.sysconfig` モジュールを"
"使って見つけさせられます::"

#: ../../distutils/setupscript.rst:281
msgid ""
"Even though this is quite portable---it will work on any Python "
"installation, regardless of platform---it's probably easier to just write "
"your C code in the sensible way."
msgstr ""
"この書き方も可搬性はあります --- プラットフォームに関わらず、どんな Python が"
"インストールされていても動作します --- が、単に実践的な書き方で C コードを書"
"く方が簡単でしょう。"

#: ../../distutils/setupscript.rst:285
msgid ""
"You can define and undefine pre-processor macros with the ``define_macros`` "
"and ``undef_macros`` options. ``define_macros`` takes a list of ``(name, "
"value)`` tuples, where ``name`` is the name of the macro to define (a "
"string) and ``value`` is its value: either a string or ``None``.  (Defining "
"a macro ``FOO`` to ``None`` is the equivalent of a bare ``#define FOO`` in "
"your C source: with most compilers, this sets ``FOO`` to the string ``1``.)  "
"``undef_macros`` is just a list of macros to undefine."
msgstr ""
"``define_macros`` および ``undef_macros`` オプションを使って、プリプロセッサ"
"マクロを定義 (define) したり、定義解除 (undefine) したりもできます。 "
"``define_macros`` はタプル ``(name, value)`` からなるリストを引数にとりま"
"す。 ``name`` は定義したいマクロの名前 (文字列) で、 ``value`` はその値です: "
"``value`` は文字列か ``None`` になります。(マクロ ``FOO`` を ``None`` にする"
"と、C ソースコード内で ``#define FOO`` と書いたのと同じになります: こう書く"
"と、ほとんどのコンパイラは ``FOO`` を文字列 ``1`` に設定します。) "
"``undef_macros`` には、定義解除したいマクロ名からなるリストを指定します。"

#: ../../distutils/setupscript.rst:293
msgid "For example::"
msgstr "例えば::"

#: ../../distutils/setupscript.rst:300
msgid "is the equivalent of having this at the top of every C source file::"
msgstr ""
"は、全ての C ソースコードファイルの先頭に、以下のマクロがあるのと同じになりま"
"す::"

#: ../../distutils/setupscript.rst:309
msgid "Library options"
msgstr "ライブラリオプション"

#: ../../distutils/setupscript.rst:311
msgid ""
"You can also specify the libraries to link against when building your "
"extension, and the directories to search for those libraries.  The "
"``libraries`` option is a list of libraries to link against, "
"``library_dirs`` is a list of directories to search for libraries at  link-"
"time, and ``runtime_library_dirs`` is a list of directories to  search for "
"shared (dynamically loaded) libraries at run-time."
msgstr ""
"拡張モジュールをビルドする際にリンクするライブラリや、ライブラリを検索する"
"ディレクトリも指定できます。 ``libraries`` はリンクするライブラリのリスト"
"で、 ``library_dirs`` はリンク時にライブラリを検索するディレクトリのリストで"
"す。また、 ``runtime_library_dirs`` は、実行時に共有ライブラリ (動的にロード"
"されるライブラリ) を検索するディレクトリのリストです。"

#: ../../distutils/setupscript.rst:317
msgid ""
"For example, if you need to link against libraries known to be in the "
"standard library search path on target systems ::"
msgstr ""
"例えば、ビルド対象システムの標準ライブラリ検索パスにあることが分かっているラ"
"イブラリをリンクする時には、以下のようにします ::"

#: ../../distutils/setupscript.rst:323
msgid ""
"If you need to link with libraries in a non-standard location, you'll have "
"to include the location in ``library_dirs``::"
msgstr ""
"非標準のパス上にあるライブラリをリンクしたいなら、その場所を "
"``library_dirs`` に入れておかなければなりません::"

#: ../../distutils/setupscript.rst:330
msgid ""
"(Again, this sort of non-portable construct should be avoided if you intend "
"to distribute your code.)"
msgstr ""
"(繰り返しになりますが、この手の可搬性のない書き方は、コードを配布するのが目的"
"なら避けるべきです。)"

#: ../../distutils/setupscript.rst:337
msgid "Other options"
msgstr "その他のオプション"

#: ../../distutils/setupscript.rst:339
msgid ""
"There are still some other options which can be used to handle special cases."
msgstr "他にもいくつかオプションがあり、特殊な状況を扱うために使います。"

#: ../../distutils/setupscript.rst:341
msgid ""
"The ``optional`` option is a boolean; if it is true, a build failure in the "
"extension will not abort the build process, but instead simply not install "
"the failing extension."
msgstr ""
"``optional`` オプションはブール型で、真の場合は拡張モジュールのビルドに失敗し"
"たときにビルドプロセス自体を停止せず、単にその拡張モジュールのインストールを"
"しません。"

#: ../../distutils/setupscript.rst:345
msgid ""
"The ``extra_objects`` option is a list of object files to be passed to the "
"linker. These files must not have extensions, as the default extension for "
"the compiler is used."
msgstr ""
"``extra_objects`` オプションには、リンカに渡すオブジェクトファイルのリストを"
"指定します。ファイル名には拡張子をつけてはならず、コンパイラで使われているデ"
"フォルトの拡張子が使われます。"

#: ../../distutils/setupscript.rst:349
msgid ""
"``extra_compile_args`` and ``extra_link_args`` can be used to specify "
"additional command line options for the respective compiler and linker "
"command lines."
msgstr ""
"``extra_compile_args`` および ``extra_link_args`` には、それぞれコンパイラと"
"リンカに渡す追加のコマンドライン引数を指定します。"

#: ../../distutils/setupscript.rst:353
msgid ""
"``export_symbols`` is only useful on Windows.  It can contain a list of "
"symbols (functions or variables) to be exported. This option is not needed "
"when building compiled extensions: Distutils  will automatically add "
"``initmodule`` to the list of exported symbols."
msgstr ""
"``export_symbols`` は Windows でのみ意味があります。このオプションには、公開 "
"(export) する (関数や変数の) シンボルのリストを入れられます。コンパイルして拡"
"張モジュールをビルドする際には、このオプションは不要です: Distutils は公開す"
"るシンボルを自動的に ``initmodule`` に渡すからです。"

#: ../../distutils/setupscript.rst:358
msgid ""
"The ``depends`` option is a list of files that the extension depends on (for "
"example header files). The build command will call the compiler on the "
"sources to rebuild extension if any on this files has been modified since "
"the previous build."
msgstr ""
"``depends`` オプションは、拡張モジュールが依存している(例: ヘッダーファイルな"
"どの) ファイルのリストです。このファイルのいずれかが前回のビルドから変更され"
"た時、ビルドコマンドはこのソースファイルをコンパイルしてリビルドします。"

#: ../../distutils/setupscript.rst:364
msgid "Relationships between Distributions and Packages"
msgstr "パッケージと配布物の関係"

#: ../../distutils/setupscript.rst:366
msgid "A distribution may relate to packages in three specific ways:"
msgstr "配布物はパッケージと3種類の方法で関係します:"

#: ../../distutils/setupscript.rst:368
msgid "It can require packages or modules."
msgstr "パッケージかモジュールを要求する。"

#: ../../distutils/setupscript.rst:370
msgid "It can provide packages or modules."
msgstr "パッケージかモジュールを提供する。"

#: ../../distutils/setupscript.rst:372
msgid "It can obsolete packages or modules."
msgstr "パッケージかモジュールを廃止する。"

#: ../../distutils/setupscript.rst:374
msgid ""
"These relationships can be specified using keyword arguments to the :func:"
"`distutils.core.setup` function."
msgstr ""
"これらの関係は、 :func:`distutils.core.setup` 関数のキーワード引数を利用して"
"指定することができます。"

#: ../../distutils/setupscript.rst:377
msgid ""
"Dependencies on other Python modules and packages can be specified by "
"supplying the *requires* keyword argument to :func:`setup`. The value must "
"be a list of strings.  Each string specifies a package that is required, and "
"optionally what versions are sufficient."
msgstr ""
"他のPythonモジュールやパッケージに対する依存は、 :func:`setup` の *requires* "
"キーワード引数で指定できます。引数の値は文字列のリストでなければなりません。"
"各文字列は、必要とするパッケージと、オプションとしてパッケージのバージョンを"
"指定します。"

#: ../../distutils/setupscript.rst:382
msgid ""
"To specify that any version of a module or package is required, the string "
"should consist entirely of the module or package name. Examples include "
"``'mymodule'`` and ``'xml.parsers.expat'``."
msgstr ""
"あるモジュールかパッケージの任意のバージョンが必要な場合、指定する文字列はモ"
"ジュール名かパッケージ名になります。例えば、 ``'mymodule'`` や ``'xml."
"parsers.expat'`` を含みます。"

#: ../../distutils/setupscript.rst:386
msgid ""
"If specific versions are required, a sequence of qualifiers can be supplied "
"in parentheses.  Each qualifier may consist of a comparison operator and a "
"version number.  The accepted comparison operators are::"
msgstr ""
"特定のバージョンが必要な場合、修飾子(qualifier)の列を加えることができます。各"
"修飾子は、比較演算子とバージョン番号からなります。利用できる比較演算子は::"

#: ../../distutils/setupscript.rst:393
msgid ""
"These can be combined by using multiple qualifiers separated by commas (and "
"optional whitespace).  In this case, all of the qualifiers must be matched; "
"a logical AND is used to combine the evaluations."
msgstr ""
"これらの修飾子はカンマ(空白文字を入れても良いです)で区切って複数並べることが"
"できます。その場合、全ての修飾子が適合する必要があります; 評価する時に論理AND"
"でつなげられます。"

#: ../../distutils/setupscript.rst:397
msgid "Let's look at a bunch of examples:"
msgstr "いくつかの例を見てみましょう:"

#: ../../distutils/setupscript.rst:400
msgid "Requires Expression"
msgstr "require式"

#: ../../distutils/setupscript.rst:400 ../../distutils/setupscript.rst:418
msgid "Explanation"
msgstr "説明"

#: ../../distutils/setupscript.rst:402
msgid "``==1.0``"
msgstr "``==1.0``"

#: ../../distutils/setupscript.rst:402
msgid "Only version ``1.0`` is compatible"
msgstr "version ``1.0`` のみが適合します"

#: ../../distutils/setupscript.rst:404
msgid "``>1.0, !=1.5.1, <2.0``"
msgstr "``>1.0, !=1.5.1, <2.0``"

#: ../../distutils/setupscript.rst:404
msgid ""
"Any version after ``1.0`` and before ``2.0`` is compatible, except ``1.5.1``"
msgstr ""
"``1.5.1`` を除いて、 ``1.0`` より後ろで ``2.0`` より前の全てのバージョンに適"
"合します。"

#: ../../distutils/setupscript.rst:408
msgid ""
"Now that we can specify dependencies, we also need to be able to specify "
"what we provide that other distributions can require.  This is done using "
"the *provides* keyword argument to :func:`setup`. The value for this keyword "
"is a list of strings, each of which names a Python module or package, and "
"optionally identifies the version.  If the version is not specified, it is "
"assumed to match that of the distribution."
msgstr ""
"これで、依存を指定することができました。同じように、この配布物が他の配布物に"
"必要とされる何を提供するのかを指定する必要があります。これは、 :func:`setup` "
"の *provides* キーワード引数によって指定できます。この引数の値は文字列のリス"
"トで、各要素はPythonモジュールかパッケージの名前です。バージョンを指定するこ"
"ともできます。もしバージョンが指定されなかった場合、配布物のバージョン番号が"
"利用されます。"

#: ../../distutils/setupscript.rst:415
msgid "Some examples:"
msgstr "いくつかの例です:"

#: ../../distutils/setupscript.rst:418
msgid "Provides Expression"
msgstr "provide 式"

#: ../../distutils/setupscript.rst:420
msgid "``mypkg``"
msgstr "``mypkg``"

#: ../../distutils/setupscript.rst:420
msgid "Provide ``mypkg``, using the distribution version"
msgstr "``mypkg`` を提供します。バージョンは配布物のものを使います。"

#: ../../distutils/setupscript.rst:423
msgid "``mypkg (1.1)``"
msgstr "``mypkg (1.1)``"

#: ../../distutils/setupscript.rst:423
msgid "Provide ``mypkg`` version 1.1, regardless of the distribution version"
msgstr ""
"``mypkg`` version 1.1 を提供します。配布物のバージョン番号は気にしません"

#: ../../distutils/setupscript.rst:427
msgid ""
"A package can declare that it obsoletes other packages using the *obsoletes* "
"keyword argument.  The value for this is similar to that of the *requires* "
"keyword: a list of strings giving module or package specifiers.  Each "
"specifier consists of a module or package name optionally followed by one or "
"more version qualifiers.  Version qualifiers are given in parentheses after "
"the module or package name."
msgstr ""
"パッケージは *obsoletes* キーワードを利用することで、他のパッケージを廃止する"
"ことを宣言することもできます。この値は *requires* キーワードと似ています: モ"
"ジュールやパッケージを指定する文字列のリストです。各文字列は、モジュールか"
"パッケージの名前と、オプションとして一つ以上のバージョン指定から構成されてい"
"ます。バージョン指定は、モジュールやパッケージの名前のうしろに、丸括弧 "
"(parentheses) でかこわれています。"

#: ../../distutils/setupscript.rst:434
msgid ""
"The versions identified by the qualifiers are those that are obsoleted by "
"the distribution being described.  If no qualifiers are given, all versions "
"of the named module or package are understood to be obsoleted."
msgstr ""
"指定されたバージョンは、その配布物によって廃止されるバージョンを示していま"
"す。バージョン指定が存在しない場合は、指定された名前のモジュールまたはパッ"
"ケージの全てが廃止されたと解釈されます。"

#: ../../distutils/setupscript.rst:441
msgid "Installing Scripts"
msgstr "スクリプトをインストールする"

#: ../../distutils/setupscript.rst:443
msgid ""
"So far we have been dealing with pure and non-pure Python modules, which are "
"usually not run by themselves but imported by scripts."
msgstr ""
"ここまでは、スクリプトから import され、それ自体では実行されないような pure "
"Python モジュールおよび非 pure Python モジュールについて扱ってきました。"

#: ../../distutils/setupscript.rst:446
msgid ""
"Scripts are files containing Python source code, intended to be started from "
"the command line.  Scripts don't require Distutils to do anything very "
"complicated. The only clever feature is that if the first line of the script "
"starts with ``#!`` and contains the word \"python\", the Distutils will "
"adjust the first line to refer to the current interpreter location. By "
"default, it is replaced with the current interpreter location.  The :option:"
"`!--executable` (or :option:`!-e`) option will allow the interpreter path to "
"be explicitly overridden."
msgstr ""
"スクリプトとは、Python ソースコードを含むファイルで、コマンドラインから実行で"
"きるよう作られているものです。スクリプトは Distutils に複雑なことを一切させま"
"せん。唯一の気の利いた機能は、スクリプトの最初の行が ``#!`` で始まっていて、 "
"\"python\" という単語が入っていた場合、Distutils は最初の行を現在使っているイ"
"ンタプリタを参照するよう置き換えます。デフォルトでは現在使っているインタプリ"
"タと置換しますが、オプション :option:`!--executable` (または :option:`!-e`) "
"を指定することで、明示的にインタプリタのパスを指定して上書きすることができま"
"す。"

#: ../../distutils/setupscript.rst:454
msgid ""
"The ``scripts`` option simply is a list of files to be handled in this way.  "
"From the PyXML setup script::"
msgstr ""
"``scripts`` オプションには、単に上で述べた方法で取り扱うべきファイルのリスト"
"を指定するだけです。PyXML の setup スクリプトを例に示します::"

#: ../../distutils/setupscript.rst:461
msgid ""
"All the scripts will also be added to the ``MANIFEST`` file if no template "
"is provided.  See :ref:`manifest`."
msgstr ""
"テンプレートが提供されない時、全てのスクリプトが ``MANIFEST`` ファイルに追加"
"されるようになりました。 :ref:`manifest` を参照してください"

#: ../../distutils/setupscript.rst:469
msgid "Installing Package Data"
msgstr "パッケージデータをインストールする"

#: ../../distutils/setupscript.rst:471
msgid ""
"Often, additional files need to be installed into a package.  These files "
"are often data that's closely related to the package's implementation, or "
"text files containing documentation that might be of interest to programmers "
"using the package.  These files are called :dfn:`package data`."
msgstr ""
"しばしばパッケージに追加のファイルをインストールする必要があります。このファ"
"イルは、パッケージの実装に強く関連したデータや、そのパッケージを使うプログラ"
"マーが必要とするドキュメントなどです。これらのファイルを :dfn:`パッケージデー"
"タ` と呼びます。"

#: ../../distutils/setupscript.rst:476
msgid ""
"Package data can be added to packages using the ``package_data`` keyword "
"argument to the :func:`setup` function.  The value must be a mapping from "
"package name to a list of relative path names that should be copied into the "
"package.  The paths are interpreted as relative to the directory containing "
"the package (information from the ``package_dir`` mapping is used if "
"appropriate); that is, the files are expected to be part of the package in "
"the source directories. They may contain glob patterns as well."
msgstr ""
"パッケージデータは関数 :func:`setup` にキーワード引数 ``package_data`` を与え"
"ることで追加できます。この値はパッケージ名から、パッケージへコピーされる相対"
"パス名リストへのマップである必要があります。それぞれのパスは対応するパッケー"
"ジが含まれるディレクトリ(もし適切なら ``package_dir`` のマッピングが利用され"
"ます)からの相対パスとして扱われます。つまり、ファイルはソースディレクトリ中に"
"パッケージの一部として存在すると仮定されています。この値にはグロブパターンを"
"含むことができます。"

#: ../../distutils/setupscript.rst:484
msgid ""
"The path names may contain directory portions; any necessary directories "
"will be created in the installation."
msgstr ""
"パス名にはディレクトリ部分を含むことができます。必要なディレクトリはインス"
"トール時に作成されます。"

#: ../../distutils/setupscript.rst:487
msgid ""
"For example, if a package should contain a subdirectory with several data "
"files, the files can be arranged like this in the source tree::"
msgstr ""
"たとえば、パッケージがいくつかのデータファイルを含むサブディレクトリを含んで"
"いる場合、ソースツリーでは以下のように配置できます::"

#: ../../distutils/setupscript.rst:500
msgid "The corresponding call to :func:`setup` might be::"
msgstr "対応する :func:`setup` 呼び出しは以下のようになります::"

#: ../../distutils/setupscript.rst:509
msgid ""
"All the files that match ``package_data`` will be added to the ``MANIFEST`` "
"file if no template is provided.  See :ref:`manifest`."
msgstr ""
"テンプレートが提供されない時、全ての ``package_data`` にマッチするファイルが "
"``MANIFEST`` ファイルに追加されるようになりました。 :ref:`manifest` を参照し"
"てください"

#: ../../distutils/setupscript.rst:517
msgid "Installing Additional Files"
msgstr "追加のファイルをインストールする"

#: ../../distutils/setupscript.rst:519
msgid ""
"The ``data_files`` option can be used to specify additional files needed by "
"the module distribution: configuration files, message catalogs, data files, "
"anything which doesn't fit in the previous categories."
msgstr ""
"``data_files`` オプションを使うと、モジュール配布物で必要な追加のファイル: 設"
"定ファイル、メッセージカタログ、データファイル、その他これまで述べてきたカテ"
"ゴリに収まらない全てのファイルを指定できます。"

#: ../../distutils/setupscript.rst:523
msgid ""
"``data_files`` specifies a sequence of (*directory*, *files*) pairs in the "
"following way::"
msgstr ""
"``data_files`` には、(*directory*, *files*) のペアを以下のように指定します::"

#: ../../distutils/setupscript.rst:531
msgid ""
"Each (*directory*, *files*) pair in the sequence specifies the installation "
"directory and the files to install there."
msgstr ""
"シーケンス中のそれぞれの (*directory*, *files*) ペアは、インストール先ディレ"
"クトリとそこにインストールするファイルのリストを指定します。"

#: ../../distutils/setupscript.rst:534
msgid ""
"Each file name in *files* is interpreted relative to the :file:`setup.py` "
"script at the top of the package source distribution. Note that you can "
"specify the directory where the data files will be installed, but you cannot "
"rename the data files themselves."
msgstr ""
"*files* リスト中の各ファイル名はパッケージのソースディストリビューションの最"
"上位にある :file:`setup.py` スクリプトからの相対パスとして解釈されます。デー"
"タファイルがインストールされるディレクトリは指定できますが、データファイルの"
"名前を変更することはできないことに注意してください。"

#: ../../distutils/setupscript.rst:539
msgid ""
"The *directory* should be a relative path. It is interpreted relative to the "
"installation prefix (Python's ``sys.prefix`` for system installations; "
"``site.USER_BASE`` for user installations). Distutils allows *directory* to "
"be an absolute installation path, but this is discouraged since it is "
"incompatible with the wheel packaging format. No directory information from "
"*files* is used to determine the final location of the installed file; only "
"the name of the file is used."
msgstr ""
"*directory* は相対パスである必要があり、インストールプレフィックス (システム"
"インストールの場合は Python の ``sys.prefix``; ユーザーインストールの場合は "
"``site.USER_BASE``) からの相対パスと解釈されます。 Distutils は *directory* "
"に絶対パスを指定することができますが、この方法は wheel パッケージング形式と互"
"換性がないため推奨されません。 *files* のディレクトリ情報はインストール先の決"
"定には使われません; ファイル名だけが使われます。"

#: ../../distutils/setupscript.rst:547
msgid ""
"You can specify the ``data_files`` options as a simple sequence of files "
"without specifying a target directory, but this is not recommended, and the :"
"command:`install` command will print a warning in this case. To install data "
"files directly in the target directory, an empty string should be given as "
"the directory."
msgstr ""
"``data_files`` オプションは、ターゲットディレクトリを指定せずに、単にファイル"
"の列を指定できます。しかし、このやり方は推奨されておらず、指定すると :"
"command:`install` コマンドが警告を出力します。ターゲットディレクトリにデータ"
"ファイルを直接インストールしたいなら、ディレクトリ名として空文字列を指定して"
"ください。"

#: ../../distutils/setupscript.rst:553
msgid ""
"All the files that match ``data_files`` will be added to the ``MANIFEST`` "
"file if no template is provided.  See :ref:`manifest`."
msgstr ""
"テンプレートが提供されない時、全ての ``data_files`` にマッチするファイルが "
"``MANIFEST`` ファイルに追加されるようになりました。 :ref:`manifest` を参照し"
"てください"

#: ../../distutils/setupscript.rst:561
msgid "Additional meta-data"
msgstr "追加のメタデータ"

#: ../../distutils/setupscript.rst:563
msgid ""
"The setup script may include additional meta-data beyond the name and "
"version. This information includes:"
msgstr ""
"setup スクリプトには、名前やバージョンにとどまらず、その他のメタデータを含め"
"られます。以下のような情報を含められます:"

#: ../../distutils/setupscript.rst:567
msgid "Meta-Data"
msgstr "メタデータ"

#: ../../distutils/setupscript.rst:567
msgid "Description"
msgstr "説明"

#: ../../distutils/setupscript.rst:567
msgid "Value"
msgstr "値"

#: ../../distutils/setupscript.rst:567
msgid "Notes"
msgstr "注釈"

#: ../../distutils/setupscript.rst:569
msgid "``name``"
msgstr "``name``"

#: ../../distutils/setupscript.rst:569
msgid "name of the package"
msgstr "パッケージ名"

#: ../../distutils/setupscript.rst:569 ../../distutils/setupscript.rst:571
#: ../../distutils/setupscript.rst:573 ../../distutils/setupscript.rst:578
#: ../../distutils/setupscript.rst:585 ../../distutils/setupscript.rst:601
msgid "short string"
msgstr "短い文字列"

#: ../../distutils/setupscript.rst:569 ../../distutils/setupscript.rst:583
msgid "\\(1)"
msgstr "\\(1)"

#: ../../distutils/setupscript.rst:571
msgid "``version``"
msgstr "``version``"

#: ../../distutils/setupscript.rst:571
msgid "version of this release"
msgstr "リリースのバージョン"

#: ../../distutils/setupscript.rst:571
msgid "(1)(2)"
msgstr "(1)(2)"

#: ../../distutils/setupscript.rst:573
msgid "``author``"
msgstr "``author``"

#: ../../distutils/setupscript.rst:573
msgid "package author's name"
msgstr "パッケージ作者名"

#: ../../distutils/setupscript.rst:573 ../../distutils/setupscript.rst:575
#: ../../distutils/setupscript.rst:578 ../../distutils/setupscript.rst:580
msgid "\\(3)"
msgstr "\\(3)"

#: ../../distutils/setupscript.rst:575
msgid "``author_email``"
msgstr "``author_email``"

#: ../../distutils/setupscript.rst:575
msgid "email address of the package author"
msgstr "パッケージ作者の電子メールアドレス"

#: ../../distutils/setupscript.rst:575 ../../distutils/setupscript.rst:580
msgid "email address"
msgstr "電子メールアドレス"

#: ../../distutils/setupscript.rst:578
msgid "``maintainer``"
msgstr "``maintainer``"

#: ../../distutils/setupscript.rst:578
msgid "package maintainer's name"
msgstr "パッケージメンテナンス担当者の名前"

#: ../../distutils/setupscript.rst:580
msgid "``maintainer_email``"
msgstr "``maintainer_email``"

#: ../../distutils/setupscript.rst:580
msgid "email address of the package maintainer"
msgstr "パッケージメンテナンス担当者の電子メールアドレス"

#: ../../distutils/setupscript.rst:583
msgid "``url``"
msgstr "``url``"

#: ../../distutils/setupscript.rst:583
msgid "home page for the package"
msgstr "パッケージのホームページ"

#: ../../distutils/setupscript.rst:583 ../../distutils/setupscript.rst:592
msgid "URL"
msgstr "URL"

#: ../../distutils/setupscript.rst:585
msgid "``description``"
msgstr "``description``"

#: ../../distutils/setupscript.rst:585
msgid "short, summary description of the package"
msgstr "パッケージについての簡潔な概要説明"

#: ../../distutils/setupscript.rst:589
msgid "``long_description``"
msgstr "``long_description``"

#: ../../distutils/setupscript.rst:589
msgid "longer description of the package"
msgstr "パッケージについての詳細な説明"

#: ../../distutils/setupscript.rst:589
msgid "long string"
msgstr "長い文字列"

#: ../../distutils/setupscript.rst:589
msgid "\\(4)"
msgstr "\\(4)"

#: ../../distutils/setupscript.rst:592
msgid "``download_url``"
msgstr "``download_url``"

#: ../../distutils/setupscript.rst:592
msgid "location where the package may be downloaded"
msgstr "パッケージをダウンロードできる場所"

#: ../../distutils/setupscript.rst:595
msgid "``classifiers``"
msgstr "``classifiers``"

#: ../../distutils/setupscript.rst:595
msgid "a list of classifiers"
msgstr "分類語のリスト"

#: ../../distutils/setupscript.rst:595 ../../distutils/setupscript.rst:597
#: ../../distutils/setupscript.rst:599
msgid "list of strings"
msgstr "文字列からなるリスト"

#: ../../distutils/setupscript.rst:595
msgid "(6)(7)"
msgstr "(6)(7)"

#: ../../distutils/setupscript.rst:597
msgid "``platforms``"
msgstr "``platforms``"

#: ../../distutils/setupscript.rst:597
msgid "a list of platforms"
msgstr "プラットフォームのリスト"

#: ../../distutils/setupscript.rst:597 ../../distutils/setupscript.rst:599
msgid "(6)(8)"
msgstr "(6)(8)"

#: ../../distutils/setupscript.rst:599
msgid "``keywords``"
msgstr "``keywords``"

#: ../../distutils/setupscript.rst:599
msgid "a list of keywords"
msgstr "キーワードのリスト"

#: ../../distutils/setupscript.rst:601
msgid "``license``"
msgstr "``license``"

#: ../../distutils/setupscript.rst:601
msgid "license for the package"
msgstr "パッケージのライセンス"

#: ../../distutils/setupscript.rst:601
msgid "\\(5)"
msgstr "\\(5)"

#: ../../distutils/setupscript.rst:604
msgid "Notes:"
msgstr "注釈:"

#: ../../distutils/setupscript.rst:607
msgid "These fields are required."
msgstr "必須のフィールドです。"

#: ../../distutils/setupscript.rst:610
msgid ""
"It is recommended that versions take the form *major.minor[.patch[.sub]]*."
msgstr ""
"バージョン番号は *major.minor[.patch[.sub]]* の形式をとるよう奨めます。"

#: ../../distutils/setupscript.rst:613
msgid ""
"Either the author or the maintainer must be identified. If maintainer is "
"provided, distutils lists it as the author in :file:`PKG-INFO`."
msgstr ""
"作者かメンテナのどちらかは必ず区別してください。メンテナが与えられると、"
"distutils は :file:`PKG-INFO` に作者としてリストします。"

#: ../../distutils/setupscript.rst:617
msgid ""
"The ``long_description`` field is used by PyPI when you publish a package, "
"to build its project page."
msgstr ""
"``long_description`` フィールドは、パッケージを PyPI で公開する際にプロジェク"
"トページ作成のために使われます。"

#: ../../distutils/setupscript.rst:621
msgid ""
"The ``license`` field is a text indicating the license covering the package "
"where the license is not a selection from the \"License\" Trove classifiers. "
"See the ``Classifier`` field. Notice that there's a ``licence`` distribution "
"option which is deprecated but still acts as an alias for ``license``."
msgstr ""
"``license`` フィールドは、ライセンスが \"License\" Trove 分類から選ばれたので"
"はない場合にパッケージをカバーするライセンスを示すテキストです。 "
"``Classifier`` フィールドを参照してください。お気づきの通り、廃止された "
"``licence`` というオプションがあり、未だに ``license`` のエイリアスとして働い"
"ています。"

#: ../../distutils/setupscript.rst:628
msgid "This field must be a list."
msgstr "このフィールドはリストでなければなりません。"

#: ../../distutils/setupscript.rst:631
msgid ""
"The valid classifiers are listed on `PyPI <https://pypi.org/classifiers>`_."
msgstr ""
"有効な分類語のリストは `PyPI <https://pypi.org/classifiers>`_ を参照してくだ"
"さい。"

#: ../../distutils/setupscript.rst:635
msgid ""
"To preserve backward compatibility, this field also accepts a string. If you "
"pass a comma-separated string ``'foo, bar'``, it will be converted to "
"``['foo', 'bar']``, Otherwise, it will be converted to a list of one string."
msgstr ""
"後方互換性を保つため、このフィールドはリストに加えて文字列も受け付けます。コ"
"ンマ区切りの文字列``'foo, bar'``を与えると、文字列のリスト``['foo', 'bar']``"
"に変換されます。それ以外の場合、1つの文字列だけを含むリストに変換されます。"

#: ../../distutils/setupscript.rst:641
msgid "'short string'"
msgstr "「短い文字列」"

#: ../../distutils/setupscript.rst:641
msgid "A single line of text, not more than 200 characters."
msgstr "200 文字以内の一行のテキスト。"

#: ../../distutils/setupscript.rst:645
msgid "'long string'"
msgstr "「長い文字列」"

#: ../../distutils/setupscript.rst:644
msgid ""
"Multiple lines of plain text in reStructuredText format (see http://docutils."
"sourceforge.net/)."
msgstr ""
"複数行からなり、ReStructuredText 形式で書かれたプレーンテキスト (http://"
"docutils.sourceforge.net/ を参照してください)。"

#: ../../distutils/setupscript.rst:648
msgid "'list of strings'"
msgstr "「文字列のリスト」"

#: ../../distutils/setupscript.rst:648
msgid "See below."
msgstr "下記を参照してください。"

#: ../../distutils/setupscript.rst:650
msgid ""
"Encoding the version information is an art in itself. Python packages "
"generally adhere to the version format *major.minor[.patch][sub]*. The major "
"number is 0 for initial, experimental releases of software. It is "
"incremented for releases that represent major milestones in a package. The "
"minor number is incremented when important new features are added to the "
"package. The patch number increments when bug-fix releases are made. "
"Additional trailing version information is sometimes used to indicate sub-"
"releases.  These are \"a1,a2,...,aN\" (for alpha releases, where "
"functionality and API may change), \"b1,b2,...,bN\" (for beta releases, "
"which only fix bugs) and \"pr1,pr2,...,prN\" (for final pre-release release "
"testing). Some examples:"
msgstr ""
"バージョン情報のコード化は、それ自体が一つのアートです。 Python のパッケージ"
"は一般的に、 *major.minor[.patch][sub]* というバージョン表記に従います。メ"
"ジャー (major) 番号は最初は 0 で、これはソフトウェアが実験的リリースにあるこ"
"とを示します。メジャー番号は、パッケージが主要な開発目標を達成したとき、それ"
"を示すために加算されてゆきます。マイナー (minor) 番号は、パッケージに重要な新"
"機能が追加されたときに加算されてゆきます。パッチ (patch) 番号は、バグフィクス"
"版のリリースが作成されたときに加算されます。末尾にバージョン情報が追加され、"
"サブリリースを示すこともあります。これは \"a1,a2,...,aN\" (アルファリリースの"
"場合で、機能や API が変更されているとき)、 \"b1,b2,...,bN\" (ベータリリースの"
"場合で、バグフィクスのみのとき) 、そして \"pr1,pr2,...,prN\"  (プレリリースの"
"最終段階で、リリーステストのとき) になります。以下に例を示します:"

#: ../../distutils/setupscript.rst:662
msgid "0.1.0"
msgstr "0.1.0"

#: ../../distutils/setupscript.rst:662
msgid "the first, experimental release of a package"
msgstr "パッケージの最初の実験的なリリース"

#: ../../distutils/setupscript.rst:665
msgid "1.0.1a2"
msgstr "1.0.1a2"

#: ../../distutils/setupscript.rst:665
msgid "the second alpha release of the first patch version of 1.0"
msgstr "1.0 の最初のパッチバージョンに対する、2 回目のアルファリリース"

#: ../../distutils/setupscript.rst:667
msgid "``classifiers`` must be specified in a list::"
msgstr "``classifiers`` はリストの中で指定しなければなりません::"

#: ../../distutils/setupscript.rst:688
msgid ""
":class:`~distutils.core.setup` now warns when ``classifiers``, ``keywords`` "
"or ``platforms`` fields are not specified as a list or a string."
msgstr ""
":class:`~distutils.core.setup` は``classifiers``, ``keywords``, ``platforms``"
"のいずれかのフィールドに文字列でもリストでもない値が指定されたときに、警告を"
"出すようになりました。"

#: ../../distutils/setupscript.rst:695
msgid "Debugging the setup script"
msgstr "setup スクリプトをデバッグする"

#: ../../distutils/setupscript.rst:697
msgid ""
"Sometimes things go wrong, and the setup script doesn't do what the "
"developer wants."
msgstr ""
"setup スクリプトのどこかがまずいと、開発者の思い通りに動作してくれません。"

#: ../../distutils/setupscript.rst:700
msgid ""
"Distutils catches any exceptions when running the setup script, and print a "
"simple error message before the script is terminated.  The motivation for "
"this behaviour is to not confuse administrators who don't know much about "
"Python and are trying to install a package.  If they get a big long "
"traceback from deep inside the guts of Distutils, they may think the package "
"or the Python installation is broken because they don't read all the way "
"down to the bottom and see that it's a permission problem."
msgstr ""
"Distutils は setup 実行時の全ての例外を捉えて、簡単なエラーメッセージを出力し"
"てからスクリプトを終了します。このような仕様にしているのは、 Python にあまり"
"詳しくない管理者がパッケージをインストールする際に混乱しなくてすむようにする"
"ためです。もし Distutils のはらわた深くからトレースバックした長大なメッセージ"
"を見たら、管理者はきっと Python のインストール自体がおかしくなっているのだと"
"勘違いして、トレースバックを最後まで読み進んで実はファイルパーミッションの問"
"題だったと気づいたりはしないでしょう。"

#: ../../distutils/setupscript.rst:708
msgid ""
"On the other hand, this doesn't help the developer to find the cause of the "
"failure. For this purpose, the :envvar:`DISTUTILS_DEBUG` environment "
"variable can be set to anything except an empty string, and distutils will "
"now print detailed information about what it is doing, dump the full "
"traceback when an exception occurs, and print the whole command line when an "
"external program (like a C compiler) fails."
msgstr ""
"しかし逆に、この仕様は開発者にとってはうまくいかない理由を見つける役には立ち"
"ません。そこで、 :envvar:`DISTUTILS_DEBUG` 環境変数を空文字以外の何らかの値に"
"設定しておけば、 Distutils が何を実行しているか詳しい情報を出力し、例外が発生"
"した場合には完全なトレースバックをダンプし、(C コンパイラのような) 外部プログ"
"ラムが失敗した時はコマンドライン全体を表示するようにできます。"
