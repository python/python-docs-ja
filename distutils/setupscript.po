# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Masato HASHIMOTO <cabezon.hashimoto@gmail.com>, 2017\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../distutils/setupscript.rst:5
msgid "Writing the Setup Script"
msgstr "setup スクリプトを書く"

#: ../../distutils/setupscript.rst:7
msgid ""
"The setup script is the centre of all activity in building, distributing, "
"and installing modules using the Distutils.  The main purpose of the setup "
"script is to describe your module distribution to the Distutils, so that the"
" various commands that operate on your modules do the right thing.  As we "
"saw in section :ref:`distutils-simple-example` above, the setup script "
"consists mainly of a call to :func:`setup`, and most information supplied to"
" the Distutils by the module developer is supplied as keyword arguments to "
":func:`setup`."
msgstr ""
"setup スクリプトは、Distutils を使ってモジュールをビルドし、配布し、インストールする際の全ての動作の中心になります。 setup "
"スクリプトの主な目的は、モジュール配布物について Distutils "
"に伝え、モジュール配布を操作するための様々なコマンドを正しく動作させることにあります。上の :ref:`distutils-simple-"
"example` の節で見てきたように、 setup スクリプトは主に :func:`setup` の呼び出しからなり、開発者が distuils "
"に対して与えるほとんどの情報は :func:`setup` のキーワード引数として指定されます。"

#: ../../distutils/setupscript.rst:15
msgid ""
"Here's a slightly more involved example, which we'll follow for the next "
"couple of sections: the Distutils' own setup script.  (Keep in mind that "
"although the Distutils are included with Python 1.6 and later, they also "
"have an independent existence so that Python 1.5.2 users can use them to "
"install other module distributions.  The Distutils' own setup script, shown "
"here, is used to install the package into Python 1.5.2.) ::"
msgstr ""
"ここではもう少しだけ複雑な例: Distutils 自体の setup スクリプト、を示します。これについては、以降の二つの節でフォローします。 "
"(Distutils が入っているのは Python 1.6 以降であり、 Python 1.5.2 "
"ユーザが他のモジュール配布物をインストールできるようにするための独立したパッケージがあることを思い出してください。ここで示した、Distutils "
"自身の setup スクリプトは、Python 1.5.2 に Distutils パッケージをインストールする際に使います。) ::"

#: ../../distutils/setupscript.rst:35
msgid ""
"There are only two differences between this and the trivial one-file "
"distribution presented in section :ref:`distutils-simple-example`: more "
"metadata, and the specification of pure Python modules by package, rather "
"than by module.  This is important since the Distutils consist of a couple "
"of dozen modules split into (so far) two packages; an explicit list of every"
" module would be tedious to generate and difficult to maintain.  For more "
"information on the additional meta-data, see section :ref:`meta-data`."
msgstr ""
"上の例と、 :ref:`distutils-simple-example` "
"で示したファイル一つからなる小さな配布物とは、違うところは二つしかありません: メタデータの追加と、モジュールではなくパッケージとして pure "
"Python モジュール群を指定しているという点です。この点は重要です。というのも、 Distutils は 2 ダースものモジュールが (今のところ)"
" 二つのパッケージに分かれて入っているからです; "
"各モジュールについていちいち明示的に記述したリストは、作成するのが面倒だし、維持するのも難しくなるでしょう。その他のメタデータについては、 :ref"
":`meta-data` を参照してください。"

#: ../../distutils/setupscript.rst:43
msgid ""
"Note that any pathnames (files or directories) supplied in the setup script "
"should be written using the Unix convention, i.e. slash-separated.  The "
"Distutils will take care of converting this platform-neutral representation "
"into whatever is appropriate on your current platform before actually using "
"the pathname.  This makes your setup script portable across operating "
"systems, which of course is one of the major goals of the Distutils.  In "
"this spirit, all pathnames in this document are slash-separated."
msgstr ""
"setup スクリプトに与えるパス名 (ファイルまたはディレクトリ) は、 Unix におけるファイル名規約、つまりスラッシュ ('/') "
"区切りで書かねばなりません。Distutils "
"はこのプラットフォーム中立の表記を、実際にパス名として使う前に、現在のプラットフォームに適した表記に注意深く変換します。この機能のおかげで、setup "
"スクリプトを異なるオペレーティングシステム間にわたって可搬性があるものにできます。言うまでもなく、これは Distutils "
"の大きな目標の一つです。この精神に従って、このドキュメントでは全てのパス名をスラッシュ区切りにしています。"

#: ../../distutils/setupscript.rst:51
msgid ""
"This, of course, only applies to pathnames given to Distutils functions.  If"
" you, for example, use standard Python functions such as :func:`glob.glob` "
"or :func:`os.listdir` to specify files, you should be careful to write "
"portable code instead of hardcoding path separators::"
msgstr ""
"もちろん、この取り決めは Distutils に渡すパス名だけに適用されます。もし、例えば :func:`glob.glob` や "
":func:`os.listdir` のような、標準の Python 関数を使ってファイル群を指定するのなら、パス区切り文字 (path "
"separator) をハードコーディングせず、以下のように可搬性のあるコードを書くよう注意すべきです::"

#: ../../distutils/setupscript.rst:63
msgid "Listing whole packages"
msgstr "パッケージを全て列挙する"

#: ../../distutils/setupscript.rst:65
msgid ""
"The ``packages`` option tells the Distutils to process (build, distribute, "
"install, etc.) all pure Python modules found in each package mentioned in "
"the ``packages`` list.  In order to do this, of course, there has to be a "
"correspondence between package names and directories in the filesystem.  The"
" default correspondence is the most obvious one, i.e. package "
":mod:`distutils` is found in the directory :file:`distutils` relative to the"
" distribution root. Thus, when you say ``packages = ['foo']`` in your setup "
"script, you are promising that the Distutils will find a file "
":file:`foo/__init__.py` (which might be spelled differently on your system, "
"but you get the idea) relative to the directory where your setup script "
"lives.  If you break this promise, the Distutils will issue a warning but "
"still process the broken package anyway."
msgstr ""
":option:`packages` オプションは、 :option:`packages` "
"リスト中で指定されている各々のパッケージについて、パッケージ内に見つかった全ての pure Python モジュールを処理 "
"(ビルド、配布、インストール、等) するよう Distutils "
"に指示します。このオプションを指定するためには、当然のことながら各パッケージ名はファイルシステム上のディレクトリ名と何らかの対応付けができなければなりません。デフォルトで使われる対応関係はきわめてはっきりしたものです。すなわち、パッケージ"
" :mod:`distutils` が配布物ルートディレクトリからの相対パス :file:`distutils` "
"で表されるディレクトリ中にあるというものです。つまり、setup スクリプト中で ``packages = ['foo']`` "
"と指定したら、スクリプトの置かれたディレクトリからの相対パスで :file:`foo/__init__.py` を探し出せると Distutils "
"に確約したことになります。この約束を裏切ると Distutils は警告を出しますが、そのまま壊れたパッケージの処理を継続します。"

#: ../../distutils/setupscript.rst:77
msgid ""
"If you use a different convention to lay out your source directory, that's "
"no problem: you just have to supply the ``package_dir`` option to tell the "
"Distutils about your convention.  For example, say you keep all Python "
"source under :file:`lib`, so that modules in the \"root package\" (i.e., not"
" in any package at all) are in :file:`lib`, modules in the :mod:`foo` "
"package are in :file:`lib/foo`, and so forth.  Then you would put ::"
msgstr ""
"ソースコードディレクトリの配置について違った規約を使っていても、まったく問題はありません: 単に ``package_dir`` オプションを指定して、"
" Distutils に自分の規約を教えればよいのです。例えば、全ての Python ソースコードを :file:`lib` 下に置いて、 "
"\"ルートパッケージ\" 内のモジュール (つまり、どのパッケージにも入っていないモジュール) を :file:`lib` 内に入れ、 "
":mod:`foo` パッケージを :file:`lib/foo` に入れる、といった具合にしたいのなら ::"

#: ../../distutils/setupscript.rst:86
msgid ""
"in your setup script.  The keys to this dictionary are package names, and an"
" empty package name stands for the root package.  The values are directory "
"names relative to your distribution root.  In this case, when you say "
"``packages = ['foo']``, you are promising that the file "
":file:`lib/foo/__init__.py` exists."
msgstr ""
"を setup "
"スクリプト内に入れます。辞書内のキーはパッケージ名で、空のパッケージ名はルートパッケージを表します。キーに対応する値はルートパッケージからの相対ディレクトリ名です、この場合、"
" ``packages = ['foo']`` を指定すれば、 :file:`lib/foo/__init__.py` が存在すると Distutils"
" に確約したことになります。"

#: ../../distutils/setupscript.rst:91
msgid ""
"Another possible convention is to put the :mod:`foo` package right in "
":file:`lib`, the :mod:`foo.bar` package in :file:`lib/bar`, etc.  This would"
" be written in the setup script as ::"
msgstr ""
"もう一つの規約のあり方は :mod:`foo` パッケージを :file:`lib` に置き換え、 :mod:`foo.bar` パッケージが "
":file:`lib/bar` にある、などとするものです。このような規約は、 setup スクリプトでは ::"

#: ../../distutils/setupscript.rst:97
msgid ""
"A ``package: dir`` entry in the ``package_dir`` dictionary implicitly "
"applies to all packages below *package*, so the :mod:`foo.bar` case is "
"automatically handled here.  In this example, having ``packages = ['foo', "
"'foo.bar']`` tells the Distutils to look for :file:`lib/__init__.py` and "
":file:`lib/bar/__init__.py`.  (Keep in mind that although ``package_dir`` "
"applies recursively, you must explicitly list all packages in ``packages``: "
"the Distutils will *not* recursively scan your source tree looking for any "
"directory with an :file:`__init__.py` file.)"
msgstr ""
"のように書きます。 :option:`package_dir` 辞書に ``package: dir`` のようなエントリがあると、 *package*"
" の下にある全てのパッケージに対してこの規則が暗黙のうちに適用され、その結果 :mod:`foo.bar` の場合が自動的に処理されます。この例では、 "
"``packages = ['foo', 'foo.bar']`` は、 Distutils に :file:`lib/__init__.py` と "
":file:`lib/bar/__init__.py` を探すように指示します。 (``package_dir`` は再帰的に適用されますが、この場合 "
"``packages`` の下にある全てのパッケージを明示的に指定しなければならないことを心に留めておいてください: Distutils は "
":file:`__init__.py` を持つディレクトリをソースツリーから再帰的にさがしたりは *しません* 。)"

#: ../../distutils/setupscript.rst:110
msgid "Listing individual modules"
msgstr "個々のモジュールを列挙する"

#: ../../distutils/setupscript.rst:112
msgid ""
"For a small module distribution, you might prefer to list all modules rather"
" than listing packages---especially the case of a single module that goes in"
" the \"root package\" (i.e., no package at all).  This simplest case was "
"shown in section :ref:`distutils-simple-example`; here is a slightly more "
"involved example::"
msgstr ""
"小さなモジュール配布物の場合、パッケージを列挙するよりも、全てのモジュールを列挙するほうがよいと思うかもしれません --- 特に、単一のモジュールが "
"\"ルートパッケージ\" にインストールされる (すなわち、パッケージは全くない) ような場合がそうです。この最も単純なケースは :ref"
":`distutils-simple-example` で示しました; ここではもうちょっと入り組んだ例を示します::"

#: ../../distutils/setupscript.rst:119
msgid ""
"This describes two modules, one of them in the \"root\" package, the other "
"in the :mod:`pkg` package.  Again, the default package/directory layout "
"implies that these two modules can be found in :file:`mod1.py` and "
":file:`pkg/mod2.py`, and that :file:`pkg/__init__.py` exists as well. And "
"again, you can override the package/directory correspondence using the "
"``package_dir`` option."
msgstr ""
"ここでは二つのモジュールについて述べていて、一方は \"ルート\" パッケージに入り、他方は :mod:`pkg` "
"パッケージに入ります。ここでも、デフォルトのパッケージ/ディレクトリのレイアウトは、二つのモジュールが :file:`mod1.py` と "
":file:`pkg/mod2.py` にあり、 :file:`pkg/__init__.py` "
"が存在することを暗示しています。また、パッケージ/ディレクトリの対応関係は ``package_dir`` オプションでも上書きできます。"

#: ../../distutils/setupscript.rst:129
msgid "Describing extension modules"
msgstr "拡張モジュールについて記述する"

#: ../../distutils/setupscript.rst:131
msgid ""
"Just as writing Python extension modules is a bit more complicated than "
"writing pure Python modules, describing them to the Distutils is a bit more "
"complicated. Unlike pure modules, it's not enough just to list modules or "
"packages and expect the Distutils to go out and find the right files; you "
"have to specify the extension name, source file(s), and any compile/link "
"requirements (include directories, libraries to link with, etc.)."
msgstr ""
"pure Python モジュールを書くより Python 拡張モジュールを書く方がちょっとだけ複雑なように、 Distutils "
"での拡張モジュールに関する記述もちょっと複雑です。pure モジュールと違い、単にモジュールやパッケージを列挙して、Distutils "
"が正しいファイルを見つけてくれると期待するだけでは十分ではありません; 拡張モジュールの名前、ソースコードファイル (群) "
"、そして何らかのコンパイル/リンクに関する必要事項 (include ディレクトリ、リンクすべきライブラリ、等) を指定しなければなりません。"

#: ../../distutils/setupscript.rst:140
msgid ""
"All of this is done through another keyword argument to :func:`setup`, the "
"``ext_modules`` option.  ``ext_modules`` is just a list of "
":class:`~distutils.core.Extension` instances, each of which describes a "
"single extension module. Suppose your distribution includes a single "
"extension, called :mod:`foo` and implemented by :file:`foo.c`.  If no "
"additional instructions to the compiler/linker are needed, describing this "
"extension is quite simple::"
msgstr ""
"それらは全て、もう 1 つの :func:`setup` のオプション引数、 ``ext_modules`` オプションを通じて行われます。 "
"``ext_modules`` は単なる :class:`~distutils.core.Extension` のリストで、それぞれがある 1 "
"つの拡張モジュールを記述しています。配布物に、 :mod:`foo` という名前の :file:`foo.c` に実装がある拡張モジュールが 1 "
"つ含まれているとします。コンパイラ/リンカへのこれ以上の指示が無い場合は、拡張モジュールの記述は単純です::"

#: ../../distutils/setupscript.rst:150
msgid ""
"The :class:`Extension` class can be imported from :mod:`distutils.core` "
"along with :func:`setup`.  Thus, the setup script for a module distribution "
"that contains only this one extension and nothing else might be::"
msgstr ""
":class:`Extension` クラスは、 :func:`setup` によって、 :mod:`distutils.core` から import"
" されます。従って、拡張モジュールが一つだけ入っていて、他には何も入っていないモジュール配布物を作成するための setup "
"スクリプトは、以下のようになるでしょう::"

#: ../../distutils/setupscript.rst:160
msgid ""
"The :class:`Extension` class (actually, the underlying extension-building "
"machinery implemented by the :command:`build_ext` command) supports a great "
"deal of flexibility in describing Python extensions, which is explained in "
"the following sections."
msgstr ""
":class:`Extension` クラス (実質的には、 :class:`Extension` クラスの根底にある "
":command:`build_ext` コマンドで実装されている、拡張モジュールをビルドする機構) は、Python "
"拡張モジュールをきわめて柔軟に記述できるようなサポートを提供しています。これについては後の節で説明します。"

#: ../../distutils/setupscript.rst:167
msgid "Extension names and packages"
msgstr "拡張モジュールの名前とパッケージ"

#: ../../distutils/setupscript.rst:169
msgid ""
"The first argument to the :class:`~distutils.core.Extension` constructor is "
"always the name of the extension, including any package names.  For example,"
" ::"
msgstr ""
":class:`~distutils.core.Extension` コンストラクタの第 1 "
"引数は、常に任意のパッケージ名を含む拡張モジュールの名前です。例えば、 ::"

#: ../../distutils/setupscript.rst:174
msgid "describes an extension that lives in the root package, while ::"
msgstr "とすると、拡張モジュールをルートパッケージに置くことになります。一方 ::"

#: ../../distutils/setupscript.rst:178
msgid ""
"describes the same extension in the :mod:`pkg` package.  The source files "
"and resulting object code are identical in both cases; the only difference "
"is where in the filesystem (and therefore where in Python's namespace "
"hierarchy) the resulting extension lives."
msgstr ""
"は、同じ拡張モジュールを :mod:`pkg` "
"パッケージの下に置くよう記述しています。ソースコードファイルと、作成されるオブジェクトコードはどちらの場合でも同じです; "
"作成された拡張モジュールがファイルシステム上のどこに置かれるか (すなわち Python の名前空間上のどこに置かれるか) が違うにすぎません。"

#: ../../distutils/setupscript.rst:183
msgid ""
"If you have a number of extensions all in the same package (or all under the"
" same base package), use the ``ext_package`` keyword argument to "
":func:`setup`.  For example, ::"
msgstr ""
"同じパッケージ内に (または、同じ基底パッケージ下に) いくつもの拡張モジュールがある場合、 ``ext_package`` キーワード引数を "
":func:`setup` に指定します。例えば、 ::"

#: ../../distutils/setupscript.rst:193
msgid ""
"will compile :file:`foo.c` to the extension :mod:`pkg.foo`, and "
":file:`bar.c` to :mod:`pkg.subpkg.bar`."
msgstr ""
"とすると、 :file:`foo.c` をコンパイルして :mod:`pkg.foo` にし、 :file:`bar.c` をコンパイルして "
":mod:`pkg.subpkg.bar` にします。"

#: ../../distutils/setupscript.rst:198
msgid "Extension source files"
msgstr "拡張モジュールのソースファイル"

#: ../../distutils/setupscript.rst:200
msgid ""
"The second argument to the :class:`~distutils.core.Extension` constructor is"
" a list of source files.  Since the Distutils currently only support C, C++,"
" and Objective-C extensions, these are normally C/C++/Objective-C source "
"files.  (Be sure to use appropriate extensions to distinguish C++ source "
"files: :file:`.cc` and :file:`.cpp` seem to be recognized by both Unix and "
"Windows compilers.)"
msgstr ""
":class:`~distutils.core.Extension` コンストラクタの第 2 引数は、ソースファイルのリストです。 Distutils "
"は現在 C 、 C++ 、 Objective-C 拡張モジュールしかサポートしていないため、それらは通常は C/C++/Objective-C "
"ソースファイルです。 (C++ ソースファイルと判別できるように適切な拡張子を使用するようにしてください: :file:`.cc` と "
":file:`.cpp` が Unix と Windows のコンパイラの両方が認識できるようです。)"

#: ../../distutils/setupscript.rst:207
msgid ""
"However, you can also include SWIG interface (:file:`.i`) files in the list;"
" the :command:`build_ext` command knows how to deal with SWIG extensions: it"
" will run SWIG on the interface file and compile the resulting C/C++ file "
"into your extension."
msgstr ""
"ただし、 SWIG インタフェース (:file:`.i`) ファイルはリストに含められます; :command:`build_ext` コマンドは、 "
"SWIG で書かれた拡張パッケージをどう扱えばよいか心得ています: :command:`build_ext` は、インタフェースファイルを SWIG "
"にかけ、得られた C/C++ ファイルをコンパイルして拡張モジュールを生成します。"

#: ../../distutils/setupscript.rst:214
msgid ""
"This warning notwithstanding, options to SWIG can be currently passed like "
"this::"
msgstr "この警告にかかわらず、現在次のようにしてSWIGに対してオプションを渡すことができます::"

#: ../../distutils/setupscript.rst:223
msgid "Or on the commandline like this::"
msgstr "もしくは、次のようにコマンドラインからオプションを渡すこともできます::"

#: ../../distutils/setupscript.rst:227
msgid ""
"On some platforms, you can include non-source files that are processed by "
"the compiler and included in your extension.  Currently, this just means "
"Windows message text (:file:`.mc`) files and resource definition "
"(:file:`.rc`) files for Visual C++. These will be compiled to binary "
"resource (:file:`.res`) files and linked into the executable."
msgstr ""
"プラットフォームによっては、コンパイラで処理され、拡張モジュールに取り込まれるような非ソースコードファイルを含められます。非ソースコードファイルとは、現状では"
" Visual C++向けの Windows メッセージテキスト (:file:`.mc`) ファイルや、リソース定義 (:file:`.rc`) "
"ファイルを指します。これらのファイルはバイナリリソース (:file:`.res`) ファイルにコンパイルされ、実行ファイルにリンクされます。"

#: ../../distutils/setupscript.rst:235
msgid "Preprocessor options"
msgstr "プリプロセッサオプション"

#: ../../distutils/setupscript.rst:237
msgid ""
"Three optional arguments to :class:`~distutils.core.Extension` will help if "
"you need to specify include directories to search or preprocessor macros to "
"define/undefine: ``include_dirs``, ``define_macros``, and ``undef_macros``."
msgstr ""
"検索するインクルードディレクトリやプリプロセッサマクロの define/undefine を指定する必要がある場合、 "
":class:`~distutils.core.Extension` の 3 つのオプション引数が役に立ちます: ``include_dirs`` 、 "
"``define_macros`` 、 ``undef_macros`` です。"

#: ../../distutils/setupscript.rst:241
msgid ""
"For example, if your extension requires header files in the :file:`include` "
"directory under your distribution root, use the ``include_dirs`` option::"
msgstr ""
"例えば、拡張モジュールが配布物ルート下の :file:`include` ディレクトリにあるヘッダファイルを必要とするときには、 "
"``include_dirs`` オプションを使います::"

#: ../../distutils/setupscript.rst:246
msgid ""
"You can specify absolute directories there; if you know that your extension "
"will only be built on Unix systems with X11R6 installed to :file:`/usr`, you"
" can get away with ::"
msgstr ""
"ここには絶対パスも指定できます; 例えば、自分の拡張モジュールが、 :file:`/usr` の下にX11R6 をインストールした Unix "
"システムだけでビルドされると知っていれば、このように書けます ::"

#: ../../distutils/setupscript.rst:252
msgid ""
"You should avoid this sort of non-portable usage if you plan to distribute "
"your code: it's probably better to write C code like  ::"
msgstr ""
"自分のコードを配布する際には、このような可搬性のない使い方は避けるべきです: おそらく、C のコードを次のように書いたほうがましでしょう ::"

#: ../../distutils/setupscript.rst:257
msgid ""
"If you need to include header files from some other Python extension, you "
"can take advantage of the fact that header files are installed in a "
"consistent way by the Distutils :command:`install_headers` command.  For "
"example, the Numerical Python header files are installed (on a standard Unix"
" installation) to :file:`/usr/local/include/python1.5/Numerical`. (The exact"
" location will differ according to your platform and Python installation.)  "
"Since the Python include directory---\\ :file:`/usr/local/include/python1.5`"
" in this case---is always included in the search path when building Python "
"extensions, the best approach is to write C code like  ::"
msgstr ""
"他の Python 拡張モジュール由来のヘッダを include する必要があるなら、 Distutils の "
":command:`install_header` コマンドが一貫した方法でヘッダファイルをインストールするという事実を活用できます。例えば、 "
"Numerical Python のヘッダファイルは、 (標準的な Unix がインストールされた環境では) "
":file:`/usr/local/include/python1.5/Numerical` にインストールされます。 "
"(実際の場所は、プラットフォームやどの Python をインストールしたかで異なります。) Python の include ディレクトリ --- "
"今の例では :file:`/usr/local/include/python1.5` --- は、 Python "
"拡張モジュールをビルドする際に常にヘッダファイル検索パスに取り込まれるので、 C コードを書く上でもっともよいアプローチは、以下のようなものとなります "
"::"

#: ../../distutils/setupscript.rst:269
msgid ""
"If you must put the :file:`Numerical` include directory right into your "
"header search path, though, you can find that directory using the Distutils "
":mod:`distutils.sysconfig` module::"
msgstr ""
":file:`Numerical` インクルードディレクトリ自体をヘッダ検索パスに置きたいのなら、このディレクトリを Distutils の "
":mod:`distutils.sysconfig` モジュールを使って見つけさせられます::"

#: ../../distutils/setupscript.rst:279
msgid ""
"Even though this is quite portable---it will work on any Python "
"installation, regardless of platform---it's probably easier to just write "
"your C code in the sensible way."
msgstr ""
"この書き方も可搬性はあります --- プラットフォームに関わらず、どんな Python がインストールされていても動作します --- "
"が、単に実践的な書き方で C コードを書く方が簡単でしょう。"

#: ../../distutils/setupscript.rst:283
msgid ""
"You can define and undefine pre-processor macros with the ``define_macros`` "
"and ``undef_macros`` options. ``define_macros`` takes a list of ``(name, "
"value)`` tuples, where ``name`` is the name of the macro to define (a "
"string) and ``value`` is its value: either a string or ``None``.  (Defining "
"a macro ``FOO`` to ``None`` is the equivalent of a bare ``#define FOO`` in "
"your C source: with most compilers, this sets ``FOO`` to the string ``1``.)"
"  ``undef_macros`` is just a list of macros to undefine."
msgstr ""
"``define_macros`` および ``undef_macros`` オプションを使って、プリプロセッサマクロを定義 (define) "
"したり、定義解除 (undefine) したりもできます。 ``define_macros`` はタプル ``(name, value)`` "
"からなるリストを引数にとります。 ``name`` は定義したいマクロの名前 (文字列) で、 ``value`` はその値です: ``value`` "
"は文字列か ``None`` になります。(マクロ ``FOO`` を ``None`` にすると、C ソースコード内で ``#define FOO``"
" と書いたのと同じになります: こう書くと、ほとんどのコンパイラは ``FOO`` を文字列 ``1`` に設定します。) "
"``undef_macros`` には、定義解除したいマクロ名からなるリストを指定します。"

#: ../../distutils/setupscript.rst:291
msgid "For example::"
msgstr "例えば::"

#: ../../distutils/setupscript.rst:298
msgid "is the equivalent of having this at the top of every C source file::"
msgstr "は、全ての C ソースコードファイルの先頭に、以下のマクロがあるのと同じになります::"

#: ../../distutils/setupscript.rst:307
msgid "Library options"
msgstr "ライブラリオプション"

#: ../../distutils/setupscript.rst:309
msgid ""
"You can also specify the libraries to link against when building your "
"extension, and the directories to search for those libraries.  The "
"``libraries`` option is a list of libraries to link against, "
"``library_dirs`` is a list of directories to search for libraries at  link-"
"time, and ``runtime_library_dirs`` is a list of directories to  search for "
"shared (dynamically loaded) libraries at run-time."
msgstr ""
"拡張モジュールをビルドする際にリンクするライブラリや、ライブラリを検索するディレクトリも指定できます。 ``libraries`` "
"はリンクするライブラリのリストで、 ``library_dirs`` はリンク時にライブラリを検索するディレクトリのリストです。また、 "
"``runtime_library_dirs`` は、実行時に共有ライブラリ (動的にロードされるライブラリ) を検索するディレクトリのリストです。"

#: ../../distutils/setupscript.rst:315
msgid ""
"For example, if you need to link against libraries known to be in the "
"standard library search path on target systems ::"
msgstr "例えば、ビルド対象システムの標準ライブラリ検索パスにあることが分かっているライブラリをリンクする時には、以下のようにします ::"

#: ../../distutils/setupscript.rst:321
msgid ""
"If you need to link with libraries in a non-standard location, you'll have "
"to include the location in ``library_dirs``::"
msgstr "非標準のパス上にあるライブラリをリンクしたいなら、その場所を ``library_dirs`` に入れておかなければなりません::"

#: ../../distutils/setupscript.rst:328
msgid ""
"(Again, this sort of non-portable construct should be avoided if you intend "
"to distribute your code.)"
msgstr "(繰り返しになりますが、この手の可搬性のない書き方は、コードを配布するのが目的なら避けるべきです。)"

#: ../../distutils/setupscript.rst:335
msgid "Other options"
msgstr "その他のオプション"

#: ../../distutils/setupscript.rst:337
msgid ""
"There are still some other options which can be used to handle special "
"cases."
msgstr "他にもいくつかオプションがあり、特殊な状況を扱うために使います。"

#: ../../distutils/setupscript.rst:339
msgid ""
"The ``optional`` option is a boolean; if it is true, a build failure in the "
"extension will not abort the build process, but instead simply not install "
"the failing extension."
msgstr ""
"``optional`` "
"オプションはブール型で、真の場合は拡張モジュールのビルドに失敗したときにビルドプロセス自体を停止せず、単にその拡張モジュールのインストールをしません。"

#: ../../distutils/setupscript.rst:343
msgid ""
"The ``extra_objects`` option is a list of object files to be passed to the "
"linker. These files must not have extensions, as the default extension for "
"the compiler is used."
msgstr ""
"``extra_objects`` "
"オプションには、リンカに渡すオブジェクトファイルのリストを指定します。ファイル名には拡張子をつけてはならず、コンパイラで使われているデフォルトの拡張子が使われます。"

#: ../../distutils/setupscript.rst:347
msgid ""
"``extra_compile_args`` and ``extra_link_args`` can be used to specify "
"additional command line options for the respective compiler and linker "
"command lines."
msgstr ""
"``extra_compile_args`` および ``extra_link_args`` "
"には、それぞれコンパイラとリンカに渡す追加のコマンドライン引数を指定します。"

#: ../../distutils/setupscript.rst:351
msgid ""
"``export_symbols`` is only useful on Windows.  It can contain a list of "
"symbols (functions or variables) to be exported. This option is not needed "
"when building compiled extensions: Distutils  will automatically add "
"``initmodule`` to the list of exported symbols."
msgstr ""
"``export_symbols`` は Windows でのみ意味があります。このオプションには、公開 (export) する (関数や変数の) "
"シンボルのリストを入れられます。コンパイルして拡張モジュールをビルドする際には、このオプションは不要です: Distutils "
"は公開するシンボルを自動的に ``initmodule`` に渡すからです。"

#: ../../distutils/setupscript.rst:356
msgid ""
"The ``depends`` option is a list of files that the extension depends on (for"
" example header files). The build command will call the compiler on the "
"sources to rebuild extension if any on this files has been modified since "
"the previous build."
msgstr ""
"``depends`` オプションは、拡張モジュールが依存している(例: ヘッダーファイルなどの) "
"ファイルのリストです。このファイルのいずれかが前回のビルドから変更された時、ビルドコマンドはこのソースファイルをコンパイルしてリビルドします。"

#: ../../distutils/setupscript.rst:362
msgid "Relationships between Distributions and Packages"
msgstr "パッケージと配布物の関係"

#: ../../distutils/setupscript.rst:364
msgid "A distribution may relate to packages in three specific ways:"
msgstr "配布物はパッケージと3種類の方法で関係します:"

#: ../../distutils/setupscript.rst:366
msgid "It can require packages or modules."
msgstr "パッケージかモジュールを要求する。"

#: ../../distutils/setupscript.rst:368
msgid "It can provide packages or modules."
msgstr "パッケージかモジュールを提供する。"

#: ../../distutils/setupscript.rst:370
msgid "It can obsolete packages or modules."
msgstr "パッケージかモジュールを廃止する。"

#: ../../distutils/setupscript.rst:372
msgid ""
"These relationships can be specified using keyword arguments to the "
":func:`distutils.core.setup` function."
msgstr "これらの関係は、 :func:`distutils.core.setup` 関数のキーワード引数を利用して指定することができます。"

#: ../../distutils/setupscript.rst:375
msgid ""
"Dependencies on other Python modules and packages can be specified by "
"supplying the *requires* keyword argument to :func:`setup`. The value must "
"be a list of strings.  Each string specifies a package that is required, and"
" optionally what versions are sufficient."
msgstr ""
"他のPythonモジュールやパッケージに対する依存は、 :func:`setup` の *requires* "
"キーワード引数で指定できます。引数の値は文字列のリストでなければなりません。各文字列は、必要とするパッケージと、オプションとしてパッケージのバージョンを指定します。"

#: ../../distutils/setupscript.rst:380
msgid ""
"To specify that any version of a module or package is required, the string "
"should consist entirely of the module or package name. Examples include "
"``'mymodule'`` and ``'xml.parsers.expat'``."
msgstr ""
"あるモジュールかパッケージの任意のバージョンが必要な場合、指定する文字列はモジュール名かパッケージ名になります。例えば、 ``'mymodule'`` "
"や ``'xml.parsers.expat'`` を含みます。"

#: ../../distutils/setupscript.rst:384
msgid ""
"If specific versions are required, a sequence of qualifiers can be supplied "
"in parentheses.  Each qualifier may consist of a comparison operator and a "
"version number.  The accepted comparison operators are::"
msgstr ""
"特定のバージョンが必要な場合、修飾子(qualifier)の列を加えることができます。各修飾子は、比較演算子とバージョン番号からなります。利用できる比較演算子は::"

#: ../../distutils/setupscript.rst:391
msgid ""
"These can be combined by using multiple qualifiers separated by commas (and "
"optional whitespace).  In this case, all of the qualifiers must be matched; "
"a logical AND is used to combine the evaluations."
msgstr ""
"これらの修飾子はカンマ(空白文字を入れても良いです)で区切って複数並べることができます。その場合、全ての修飾子が適合する必要があります; "
"評価する時に論理ANDでつなげられます。"

#: ../../distutils/setupscript.rst:395
msgid "Let's look at a bunch of examples:"
msgstr "いくつかの例を見てみましょう:"

#: ../../distutils/setupscript.rst:398
msgid "Requires Expression"
msgstr "require式"

#: ../../distutils/setupscript.rst:398 ../../distutils/setupscript.rst:416
msgid "Explanation"
msgstr "説明"

#: ../../distutils/setupscript.rst:400
msgid "``==1.0``"
msgstr "``==1.0``"

#: ../../distutils/setupscript.rst:400
msgid "Only version ``1.0`` is compatible"
msgstr "version ``1.0`` のみが適合します"

#: ../../distutils/setupscript.rst:402
msgid "``>1.0, !=1.5.1, <2.0``"
msgstr "``>1.0, !=1.5.1, <2.0``"

#: ../../distutils/setupscript.rst:402
msgid ""
"Any version after ``1.0`` and before ``2.0`` is compatible, except ``1.5.1``"
msgstr "``1.5.1`` を除いて、 ``1.0`` より後ろで ``2.0`` より前の全てのバージョンに適合します。"

#: ../../distutils/setupscript.rst:406
msgid ""
"Now that we can specify dependencies, we also need to be able to specify "
"what we provide that other distributions can require.  This is done using "
"the *provides* keyword argument to :func:`setup`. The value for this keyword"
" is a list of strings, each of which names a Python module or package, and "
"optionally identifies the version.  If the version is not specified, it is "
"assumed to match that of the distribution."
msgstr ""
"これで、依存を指定することができました。同じように、この配布物が他の配布物に必要とされる何を提供するのかを指定する必要があります。これは、 "
":func:`setup` の *provides* "
"キーワード引数によって指定できます。この引数の値は文字列のリストで、各要素はPythonモジュールかパッケージの名前です。バージョンを指定することもできます。もしバージョンが指定されなかった場合、配布物のバージョン番号が利用されます。"

#: ../../distutils/setupscript.rst:413
msgid "Some examples:"
msgstr "いくつかの例です:"

#: ../../distutils/setupscript.rst:416
msgid "Provides Expression"
msgstr "provide 式"

#: ../../distutils/setupscript.rst:418
msgid "``mypkg``"
msgstr "``mypkg``"

#: ../../distutils/setupscript.rst:418
msgid "Provide ``mypkg``, using the distribution version"
msgstr "``mypkg`` を提供します。バージョンは配布物のものを使います。"

#: ../../distutils/setupscript.rst:421
msgid "``mypkg (1.1)``"
msgstr "``mypkg (1.1)``"

#: ../../distutils/setupscript.rst:421
msgid "Provide ``mypkg`` version 1.1, regardless of the distribution version"
msgstr "``mypkg`` version 1.1 を提供します。配布物のバージョン番号は気にしません"

#: ../../distutils/setupscript.rst:425
msgid ""
"A package can declare that it obsoletes other packages using the *obsoletes*"
" keyword argument.  The value for this is similar to that of the *requires* "
"keyword: a list of strings giving module or package specifiers.  Each "
"specifier consists of a module or package name optionally followed by one or"
" more version qualifiers.  Version qualifiers are given in parentheses after"
" the module or package name."
msgstr ""
"パッケージは *obsoletes* キーワードを利用することで、他のパッケージを廃止することを宣言することもできます。この値は *requires* "
"キーワードと似ています: "
"モジュールやパッケージを指定する文字列のリストです。各文字列は、モジュールかパッケージの名前と、オプションとして一つ以上のバージョン指定から構成されています。バージョン指定は、モジュールやパッケージの名前のうしろに、丸括弧(parentheses)でかこわれています。"

#: ../../distutils/setupscript.rst:432
msgid ""
"The versions identified by the qualifiers are those that are obsoleted by "
"the distribution being described.  If no qualifiers are given, all versions "
"of the named module or package are understood to be obsoleted."
msgstr ""
"指定されたバージョンは、その配布物によって廃止されるバージョンを示しています。バージョン指定が存在しない場合は、指定された名前のモジュールまたはパッケージの全てが廃止されたと解釈されます。"

#: ../../distutils/setupscript.rst:439
msgid "Installing Scripts"
msgstr "スクリプトをインストールする"

#: ../../distutils/setupscript.rst:441
msgid ""
"So far we have been dealing with pure and non-pure Python modules, which are"
" usually not run by themselves but imported by scripts."
msgstr ""
"ここまでは、スクリプトから import され、それ自体では実行されないような pure Python モジュールおよび非 pure Python "
"モジュールについて扱ってきました。"

#: ../../distutils/setupscript.rst:444
msgid ""
"Scripts are files containing Python source code, intended to be started from"
" the command line.  Scripts don't require Distutils to do anything very "
"complicated. The only clever feature is that if the first line of the script"
" starts with ``#!`` and contains the word \"python\", the Distutils will "
"adjust the first line to refer to the current interpreter location. By "
"default, it is replaced with the current interpreter location.  The "
":option:`!--executable` (or :option:`!-e`) option will allow the interpreter"
" path to be explicitly overridden."
msgstr ""
"スクリプトとは、Python ソースコードを含むファイルで、コマンドラインから実行できるよう作られているものです。スクリプトは Distutils "
"に複雑なことを一切させません。唯一の気の利いた機能は、スクリプトの最初の行が ``#!`` で始まっていて、 \"python\" "
"という単語が入っていた場合、Distutils "
"は最初の行を現在使っているインタプリタを参照するよう置き換えます。デフォルトでは現在使っているインタプリタと置換しますが、オプション "
":option:`!--executable` (または :option:`!-e`) "
"を指定することで、明示的にインタプリタのパスを指定して上書きすることができます。"

#: ../../distutils/setupscript.rst:452
msgid ""
"The ``scripts`` option simply is a list of files to be handled in this way."
"  From the PyXML setup script::"
msgstr ""
"``scripts`` オプションには、単に上で述べた方法で取り扱うべきファイルのリストを指定するだけです。PyXML の setup "
"スクリプトを例に示します::"

#: ../../distutils/setupscript.rst:459
msgid ""
"All the scripts will also be added to the ``MANIFEST`` file if no template "
"is provided.  See :ref:`manifest`."
msgstr ""
"テンプレートが提供されない時、全てのスクリプトが ``MANIFEST`` ファイルに追加されるようになりました。 :ref:`manifest` "
"を参照してください"

#: ../../distutils/setupscript.rst:467
msgid "Installing Package Data"
msgstr "パッケージデータをインストールする"

#: ../../distutils/setupscript.rst:469
msgid ""
"Often, additional files need to be installed into a package.  These files "
"are often data that's closely related to the package's implementation, or "
"text files containing documentation that might be of interest to programmers"
" using the package.  These files are called :dfn:`package data`."
msgstr ""
"しばしばパッケージに追加のファイルをインストールする必要があります。このファイルは、パッケージの実装に強く関連したデータや、そのパッケージを使うプログラマーが必要とするドキュメントなどです。これらのファイルを"
" :dfn:`パッケージデータ` と呼びます。"

#: ../../distutils/setupscript.rst:474
msgid ""
"Package data can be added to packages using the ``package_data`` keyword "
"argument to the :func:`setup` function.  The value must be a mapping from "
"package name to a list of relative path names that should be copied into the"
" package.  The paths are interpreted as relative to the directory containing"
" the package (information from the ``package_dir`` mapping is used if "
"appropriate); that is, the files are expected to be part of the package in "
"the source directories. They may contain glob patterns as well."
msgstr ""
"パッケージデータは関数 :func:`setup` にキーワード引数 ``package_data`` "
"を与えることで追加できます。この値はパッケージ名から、パッケージへコピーされる相対パス名リストへのマップである必要があります。それぞれのパスは対応するパッケージが含まれるディレクトリ(もし適切なら"
" ``package_dir`` "
"のマッピングが利用されます)からの相対パスとして扱われます。つまり、ファイルはソースディレクトリ中にパッケージの一部として存在すると仮定されています。この値にはグロブパターンを含むことができます。"

#: ../../distutils/setupscript.rst:482
msgid ""
"The path names may contain directory portions; any necessary directories "
"will be created in the installation."
msgstr "パス名にはディレクトリ部分を含むことができます。必要なディレクトリはインストール時に作成されます。"

#: ../../distutils/setupscript.rst:485
msgid ""
"For example, if a package should contain a subdirectory with several data "
"files, the files can be arranged like this in the source tree::"
msgstr "たとえば、パッケージがいくつかのデータファイルを含むサブディレクトリを含んでいる場合、ソースツリーでは以下のように配置できます::"

#: ../../distutils/setupscript.rst:498
msgid "The corresponding call to :func:`setup` might be::"
msgstr "対応する :func:`setup` 呼び出しは以下のようになります::"

#: ../../distutils/setupscript.rst:507
msgid ""
"All the files that match ``package_data`` will be added to the ``MANIFEST`` "
"file if no template is provided.  See :ref:`manifest`."
msgstr ""
"テンプレートが提供されない時、全ての ``package_data`` にマッチするファイルが ``MANIFEST`` "
"ファイルに追加されるようになりました。 :ref:`manifest` を参照してください"

#: ../../distutils/setupscript.rst:515
msgid "Installing Additional Files"
msgstr "追加のファイルをインストールする"

#: ../../distutils/setupscript.rst:517
msgid ""
"The ``data_files`` option can be used to specify additional files needed by "
"the module distribution: configuration files, message catalogs, data files, "
"anything which doesn't fit in the previous categories."
msgstr ""
"``data_files`` オプションを使うと、モジュール配布物で必要な追加のファイル: "
"設定ファイル、メッセージカタログ、データファイル、その他これまで述べてきたカテゴリに収まらない全てのファイルを指定できます。"

#: ../../distutils/setupscript.rst:521
msgid ""
"``data_files`` specifies a sequence of (*directory*, *files*) pairs in the "
"following way::"
msgstr "``data_files`` には、(*directory*, *files*) のペアを以下のように指定します::"

#: ../../distutils/setupscript.rst:530
msgid ""
"Note that you can specify the directory names where the data files will be "
"installed, but you cannot rename the data files themselves."
msgstr "データファイルのインストール先ディレクトリ名は指定できますが、データファイル自体の名前の変更はできないので注意してください。"

#: ../../distutils/setupscript.rst:533
msgid ""
"Each (*directory*, *files*) pair in the sequence specifies the installation "
"directory and the files to install there.  If *directory* is a relative "
"path, it is interpreted relative to the installation prefix (Python's "
"``sys.prefix`` for pure-Python packages, ``sys.exec_prefix`` for packages "
"that contain extension modules).  Each file name in *files* is interpreted "
"relative to the :file:`setup.py` script at the top of the package source "
"distribution.  No directory information from *files* is used to determine "
"the final location of the installed file; only the name of the file is used."
msgstr ""
"各々の (*directory*, *files*) "
"ペアには、インストール先のディレクトリ名と、そのディレクトリにインストールしたいファイルを指定します。 *directory* "
"が相対パスの場合、インストールプレフィクス (installation prefix、 pure Python パッケージなら "
"``sys.prefix`` 、拡張モジュールの入ったパッケージなら ``sys.exec_prefix``) からの相対パスと解釈されます。 "
"*files* 内の各ファイル名は、パッケージソースコード配布物の最上階層の、 :file:`setup.py` "
"のあるディレクトリからの相対パスと解釈されます。 *files* "
"に書かれたディレクトリ情報は、ファイルを最終的にどこにインストールするかを決めるときには使われません; ファイルの名前だけが使われます。"

#: ../../distutils/setupscript.rst:542
msgid ""
"You can specify the ``data_files`` options as a simple sequence of files "
"without specifying a target directory, but this is not recommended, and the "
":command:`install` command will print a warning in this case. To install "
"data files directly in the target directory, an empty string should be given"
" as the directory."
msgstr ""
"``data_files`` "
"オプションは、ターゲットディレクトリを指定せずに、単にファイルの列を指定できます。しかし、このやり方は推奨されておらず、指定すると "
":command:`install` "
"コマンドが警告を出力します。ターゲットディレクトリにデータファイルを直接インストールしたいなら、ディレクトリ名として空文字列を指定してください。"

#: ../../distutils/setupscript.rst:548
msgid ""
"All the files that match ``data_files`` will be added to the ``MANIFEST`` "
"file if no template is provided.  See :ref:`manifest`."
msgstr ""
"テンプレートが提供されない時、全ての ``data_files`` にマッチするファイルが ``MANIFEST`` "
"ファイルに追加されるようになりました。 :ref:`manifest` を参照してください"

#: ../../distutils/setupscript.rst:556
msgid "Additional meta-data"
msgstr "追加のメタデータ"

#: ../../distutils/setupscript.rst:558
msgid ""
"The setup script may include additional meta-data beyond the name and "
"version. This information includes:"
msgstr "setup スクリプトには、名前やバージョンにとどまらず、その他のメタデータを含められます。以下のような情報を含められます:"

#: ../../distutils/setupscript.rst:562
msgid "Meta-Data"
msgstr "メタデータ"

#: ../../distutils/setupscript.rst:562
msgid "Description"
msgstr "説明"

#: ../../distutils/setupscript.rst:562
msgid "Value"
msgstr "値"

#: ../../distutils/setupscript.rst:562
msgid "Notes"
msgstr "注釈"

#: ../../distutils/setupscript.rst:564
msgid "``name``"
msgstr "``name``"

#: ../../distutils/setupscript.rst:564
msgid "name of the package"
msgstr "パッケージ名"

#: ../../distutils/setupscript.rst:564 ../../distutils/setupscript.rst:566
#: ../../distutils/setupscript.rst:568 ../../distutils/setupscript.rst:573
#: ../../distutils/setupscript.rst:580 ../../distutils/setupscript.rst:594
msgid "short string"
msgstr "短い文字列"

#: ../../distutils/setupscript.rst:564 ../../distutils/setupscript.rst:578
msgid "\\(1)"
msgstr "\\(1)"

#: ../../distutils/setupscript.rst:566
msgid "``version``"
msgstr "``version``"

#: ../../distutils/setupscript.rst:566
msgid "version of this release"
msgstr "リリースのバージョン"

#: ../../distutils/setupscript.rst:566
msgid "(1)(2)"
msgstr "(1)(2)"

#: ../../distutils/setupscript.rst:568
msgid "``author``"
msgstr "``author``"

#: ../../distutils/setupscript.rst:568
msgid "package author's name"
msgstr "パッケージ作者名"

#: ../../distutils/setupscript.rst:568 ../../distutils/setupscript.rst:570
#: ../../distutils/setupscript.rst:573 ../../distutils/setupscript.rst:575
msgid "\\(3)"
msgstr "\\(3)"

#: ../../distutils/setupscript.rst:570
msgid "``author_email``"
msgstr "``author_email``"

#: ../../distutils/setupscript.rst:570
msgid "email address of the package author"
msgstr "パッケージ作者の電子メールアドレス"

#: ../../distutils/setupscript.rst:570 ../../distutils/setupscript.rst:575
msgid "email address"
msgstr "電子メールアドレス"

#: ../../distutils/setupscript.rst:573
msgid "``maintainer``"
msgstr "``maintainer``"

#: ../../distutils/setupscript.rst:573
msgid "package maintainer's name"
msgstr "パッケージメンテナンス担当者の名前"

#: ../../distutils/setupscript.rst:575
msgid "``maintainer_email``"
msgstr "``maintainer_email``"

#: ../../distutils/setupscript.rst:575
msgid "email address of the package maintainer"
msgstr "パッケージメンテナンス担当者の電子メールアドレス"

#: ../../distutils/setupscript.rst:578
msgid "``url``"
msgstr "``url``"

#: ../../distutils/setupscript.rst:578
msgid "home page for the package"
msgstr "パッケージのホームページ"

#: ../../distutils/setupscript.rst:578 ../../distutils/setupscript.rst:587
msgid "URL"
msgstr "URL"

#: ../../distutils/setupscript.rst:580
msgid "``description``"
msgstr "``description``"

#: ../../distutils/setupscript.rst:580
msgid "short, summary description of the package"
msgstr "パッケージについての簡潔な概要説明"

#: ../../distutils/setupscript.rst:584
msgid "``long_description``"
msgstr "``long_description``"

#: ../../distutils/setupscript.rst:584
msgid "longer description of the package"
msgstr "パッケージについての詳細な説明"

#: ../../distutils/setupscript.rst:584
msgid "long string"
msgstr "長い文字列"

#: ../../distutils/setupscript.rst:584
msgid "\\(5)"
msgstr "\\(5)"

#: ../../distutils/setupscript.rst:587
msgid "``download_url``"
msgstr "``download_url``"

#: ../../distutils/setupscript.rst:587
msgid "location where the package may be downloaded"
msgstr "パッケージをダウンロードできる場所"

#: ../../distutils/setupscript.rst:587 ../../distutils/setupscript.rst:590
msgid "\\(4)"
msgstr "\\(4)"

#: ../../distutils/setupscript.rst:590
msgid "``classifiers``"
msgstr "``classifiers``"

#: ../../distutils/setupscript.rst:590
msgid "a list of classifiers"
msgstr "分類語のリスト"

#: ../../distutils/setupscript.rst:590 ../../distutils/setupscript.rst:592
msgid "list of strings"
msgstr "文字列からなるリスト"

#: ../../distutils/setupscript.rst:592
msgid "``platforms``"
msgstr "``platforms``"

#: ../../distutils/setupscript.rst:592
msgid "a list of platforms"
msgstr "プラットフォームのリスト"

#: ../../distutils/setupscript.rst:594
msgid "``license``"
msgstr "``license``"

#: ../../distutils/setupscript.rst:594
msgid "license for the package"
msgstr "パッケージのライセンス"

#: ../../distutils/setupscript.rst:594
msgid "\\(6)"
msgstr "\\(6)"

#: ../../distutils/setupscript.rst:597
msgid "Notes:"
msgstr "注釈:"

#: ../../distutils/setupscript.rst:600
msgid "These fields are required."
msgstr "必須のフィールドです。"

#: ../../distutils/setupscript.rst:603
msgid ""
"It is recommended that versions take the form *major.minor[.patch[.sub]]*."
msgstr "バージョン番号は *major.minor[.patch[.sub]]* の形式をとるよう奨めます。"

#: ../../distutils/setupscript.rst:606
msgid ""
"Either the author or the maintainer must be identified. If maintainer is "
"provided, distutils lists it as the author in :file:`PKG-INFO`."
msgstr ""
"作者かメンテナのどちらかは必ず区別してください。メンテナが与えられると、distutils は :file:`PKG-INFO` "
"に作者としてリストします。"

#: ../../distutils/setupscript.rst:610
msgid ""
"These fields should not be used if your package is to be compatible with "
"Python versions prior to 2.2.3 or 2.3.  The list is available from the `PyPI"
" website <https://pypi.python.org/pypi>`_."
msgstr ""
"これらのフィールドは、2.2.3 および 2.3 より以前のバージョンの Python でも互換性を持たせたい場合には指定してはなりません。リストは "
"`PyPI ウェブサイト <https://pypi.python.org/pypi>`_ にあります。"

#: ../../distutils/setupscript.rst:615
msgid ""
"The ``long_description`` field is used by PyPI when you are "
":ref:`registering <package-register>` a package, to :ref:`build its home "
"page <package-display>`."
msgstr ""
"パッケージを PyPI に :ref:`登録 <package-register>` する際、PyPI は ``long_description`` "
"フィールドの値を使って :ref:`パッケージのホームページをビルド <package-display>` します。"

#: ../../distutils/setupscript.rst:620
msgid ""
"The ``license`` field is a text indicating the license covering the package "
"where the license is not a selection from the \"License\" Trove classifiers."
" See the ``Classifier`` field. Notice that there's a ``licence`` "
"distribution option which is deprecated but still acts as an alias for "
"``license``."
msgstr ""
"``license`` フィールドは、ライセンスが \"License\" Trove "
"分類から選ばれたのではない場合にパッケージをカバーするライセンスを示すテキストです。 ``Classifier`` "
"フィールドを参照してください。お気づきの通り、廃止された ``licence`` というオプションがあり、未だに ``license`` "
"のエイリアスとして働いています。"

#: ../../distutils/setupscript.rst:627
msgid "'short string'"
msgstr "「短い文字列」"

#: ../../distutils/setupscript.rst:627
msgid "A single line of text, not more than 200 characters."
msgstr "200 文字以内の一行のテキスト。"

#: ../../distutils/setupscript.rst:631
msgid "'long string'"
msgstr "「長い文字列」"

#: ../../distutils/setupscript.rst:630
msgid ""
"Multiple lines of plain text in reStructuredText format (see "
"http://docutils.sourceforge.net/)."
msgstr ""
"複数行からなり、ReStructuredText 形式で書かれたプレーンテキスト (http://docutils.sourceforge.net/ "
"を参照してください)。"

#: ../../distutils/setupscript.rst:634
msgid "'list of strings'"
msgstr "「文字列のリスト」"

#: ../../distutils/setupscript.rst:634
msgid "See below."
msgstr "下記を参照してください。"

#: ../../distutils/setupscript.rst:636
msgid ""
"Encoding the version information is an art in itself. Python packages "
"generally adhere to the version format *major.minor[.patch][sub]*. The major"
" number is 0 for initial, experimental releases of software. It is "
"incremented for releases that represent major milestones in a package. The "
"minor number is incremented when important new features are added to the "
"package. The patch number increments when bug-fix releases are made. "
"Additional trailing version information is sometimes used to indicate sub-"
"releases.  These are \"a1,a2,...,aN\" (for alpha releases, where "
"functionality and API may change), \"b1,b2,...,bN\" (for beta releases, "
"which only fix bugs) and \"pr1,pr2,...,prN\" (for final pre-release release "
"testing). Some examples:"
msgstr ""
"バージョン情報のコード化は、それ自体が一つのアートです。 Python のパッケージは一般的に、 *major.minor[.patch][sub]* "
"というバージョン表記に従います。メジャー (major) 番号は最初は 0 "
"で、これはソフトウェアが実験的リリースにあることを示します。メジャー番号は、パッケージが主要な開発目標を達成したとき、それを示すために加算されてゆきます。マイナー"
" (minor) 番号は、パッケージに重要な新機能が追加されたときに加算されてゆきます。パッチ (patch) "
"番号は、バグフィクス版のリリースが作成されたときに加算されます。末尾にバージョン情報が追加され、サブリリースを示すこともあります。これは "
"\"a1,a2,...,aN\" (アルファリリースの場合で、機能や API が変更されているとき)、 \"b1,b2,...,bN\" "
"(ベータリリースの場合で、バグフィクスのみのとき) 、そして \"pr1,pr2,...,prN\"  "
"(プレリリースの最終段階で、リリーステストのとき) になります。以下に例を示します:"

#: ../../distutils/setupscript.rst:648
msgid "0.1.0"
msgstr "0.1.0"

#: ../../distutils/setupscript.rst:648
msgid "the first, experimental release of a package"
msgstr "パッケージの最初の実験的なリリース"

#: ../../distutils/setupscript.rst:651
msgid "1.0.1a2"
msgstr "1.0.1a2"

#: ../../distutils/setupscript.rst:651
msgid "the second alpha release of the first patch version of 1.0"
msgstr "1.0 の最初のパッチバージョンに対する、2 回目のアルファリリース"

#: ../../distutils/setupscript.rst:653
msgid "``classifiers`` are specified in a Python list::"
msgstr "``classifiers`` は、Python のリスト型で指定します::"

#: ../../distutils/setupscript.rst:677
msgid "Debugging the setup script"
msgstr "setup スクリプトをデバッグする"

#: ../../distutils/setupscript.rst:679
msgid ""
"Sometimes things go wrong, and the setup script doesn't do what the "
"developer wants."
msgstr "setup スクリプトのどこかがまずいと、開発者の思い通りに動作してくれません。"

#: ../../distutils/setupscript.rst:682
msgid ""
"Distutils catches any exceptions when running the setup script, and print a "
"simple error message before the script is terminated.  The motivation for "
"this behaviour is to not confuse administrators who don't know much about "
"Python and are trying to install a package.  If they get a big long "
"traceback from deep inside the guts of Distutils, they may think the package"
" or the Python installation is broken because they don't read all the way "
"down to the bottom and see that it's a permission problem."
msgstr ""
"Distutils は setup "
"実行時の全ての例外を捉えて、簡単なエラーメッセージを出力してからスクリプトを終了します。このような仕様にしているのは、 Python "
"にあまり詳しくない管理者がパッケージをインストールする際に混乱しなくてすむようにするためです。もし Distutils "
"のはらわた深くからトレースバックした長大なメッセージを見たら、管理者はきっと Python "
"のインストール自体がおかしくなっているのだと勘違いして、トレースバックを最後まで読み進んで実はファイルパーミッションの問題だったと気づいたりはしないでしょう。"

#: ../../distutils/setupscript.rst:690
msgid ""
"On the other hand, this doesn't help the developer to find the cause of the "
"failure. For this purpose, the :envvar:`DISTUTILS_DEBUG` environment "
"variable can be set to anything except an empty string, and distutils will "
"now print detailed information about what it is doing, dump the full "
"traceback when an exception occurs, and print the whole command line when an"
" external program (like a C compiler) fails."
msgstr ""
"しかし逆に、この仕様は開発者にとってはうまくいかない理由を見つける役には立ちません。そこで、 :envvar:`DISTUTILS_DEBUG` "
"環境変数を空文字以外の何らかの値に設定しておけば、 Distutils "
"が何を実行しているか詳しい情報を出力し、例外が発生した場合には完全なトレースバックをダンプし、(C コンパイラのような) "
"外部プログラムが失敗した時はコマンドライン全体を表示するようにできます。"
