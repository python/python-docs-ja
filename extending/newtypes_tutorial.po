# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-04-08 12:59+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../extending/newtypes_tutorial.rst:7
msgid "Defining Extension Types: Tutorial"
msgstr "æ‹¡å¼µã®å‹ã®å®šç¾©: ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«"

#: ../../extending/newtypes_tutorial.rst:14
msgid ""
"Python allows the writer of a C extension module to define new types that "
"can be manipulated from Python code, much like the built-in :class:`str` and"
" :class:`list` types.  The code for all extension types follows a pattern, "
"but there are some details that you need to understand before you can get "
"started.  This document is a gentle introduction to the topic."
msgstr ""
"Python ã§ã¯ã€çµ„ã¿è¾¼ã¿ã® :class:`str` å‹ã‚„ :class:`list` å‹ã®ã‚ˆã†ãª Python ã‚³ãƒ¼ãƒ‰ã‹ã‚‰èµ°æŸ»ã§ãã‚‹æ–°ã—ã„å‹ã‚’ C æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä½œè€…ãŒå®šç¾©ã§ãã¾ã™ã€‚\n"
"å…¨ã¦ã®æ‹¡å¼µã®å‹ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¾“ã†ã®ã§ã™ãŒã€æ›¸ãå§‹ã‚ã‚‹å‰ã«ç†è§£ã—ã¦ãŠãã¹ãç´°ã‹ã„ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚\n"
"ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ãã®è©±é¡Œã«ã¤ã„ã¦ã®ã‚„ã•ã—ã„å…¥é–€ã§ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:24
msgid "The Basics"
msgstr "åŸºæœ¬çš„ãªã“ã¨"

#: ../../extending/newtypes_tutorial.rst:26
msgid ""
"The :term:`CPython` runtime sees all Python objects as variables of type "
":c:type:`PyObject\\*`, which serves as a \"base type\" for all Python "
"objects. The :c:type:`PyObject` structure itself only contains the object's "
":term:`reference count` and a pointer to the object's \"type object\". This "
"is where the action is; the type object determines which (C) functions get "
"called by the interpreter when, for instance, an attribute gets looked up on"
" an object, a method called, or it is multiplied by another object.  These C"
" functions are called \"type methods\"."
msgstr ""
":term:`CPython` ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã¯ Python ã®å…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ :c:type:`PyObject\\*` å‹ã®å¤‰æ•°ã¨è¦‹ãªã—ã¾ã™ã€‚\n"
":c:type:`PyObject\\*` ã¯ Python ã®å…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® \"åŸºåº•å‹ (base type)\" ã¨ãªã£ã¦ã„ã¾ã™ã€‚\n"
":c:type:`PyObject` æ§‹é€ ä½“è‡ªèº«ã¯å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ (:term:`reference count`) ã¨ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® \"å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (type object)\" ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã®ã¿ã‚’æŒã¡ã¾ã™ã€‚\n"
"ã“ã“ã«ã¯å‹•ä½œãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã™; å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ä¾‹ãˆã°ã€ã‚ã‚‹å±æ€§ãŒã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰æ¤œç´¢ã•ã‚ŒãŸã‚Šã€ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚ŒãŸã‚Šã€ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ˆã£ã¦æ“ä½œã•ã‚ŒãŸã‚Šã—ãŸã¨ãã«ã€ã©ã® (C) é–¢æ•°ãŒã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‹ã‚‰å‘¼ã°ã‚Œã‚‹ã®ã‹ã‚’æ±ºå®šã—ã¾ã™ã€‚\n"
"ã“ã‚Œã‚‰ã® C é–¢æ•°ã¯ \"ã‚¿ã‚¤ãƒ—ãƒ¡ã‚½ãƒƒãƒ‰ (type method)\" ã¨å‘¼ã°ã‚Œã¾ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:35
msgid ""
"So, if you want to define a new extension type, you need to create a new "
"type object."
msgstr "ãã‚Œãªã®ã§ã€æ–°ã—ã„æ‹¡å¼µã®å‹ã‚’å®šç¾©ã—ãŸã„ã¨ãã¯ã€æ–°ã—ã„å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚Œã°ã‚ˆã„ã‚ã‘ã§ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:38
msgid ""
"This sort of thing can only be explained by example, so here's a minimal, "
"but complete, module that defines a new type named :class:`Custom` inside a "
"C extension module :mod:`custom`:"
msgstr ""
"ã“ã®æ‰‹ã®ã“ã¨ã¯ä¾‹ã‚’è¦‹ãŸã»ã†ãŒæ—©ã„ã§ã—ã‚‡ã†ã‹ã‚‰ã€ä»¥ä¸‹ã« C æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« :mod:`custom`: ã«ã‚ã‚‹ :class:`Custom` "
"ã¨ã„ã†åå‰ã®æ–°ã—ã„å‹ã‚’å®šç¾©ã™ã‚‹ã€æœ€å°é™ãªãŒã‚‰å®Œå…¨ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚ã’ã¦ãŠãã¾ã™:"

#: ../../extending/newtypes_tutorial.rst:43
msgid ""
"What we're showing here is the traditional way of defining *static* "
"extension types.  It should be adequate for most uses.  The C API also "
"allows defining heap-allocated extension types using the "
":c:func:`PyType_FromSpec` function, which isn't covered in this tutorial."
msgstr ""
"ã“ã“ã§ç´¹ä»‹ã—ã¦ã„ã‚‹ä¾‹ã¯ã€ *é™çš„ãª* æ‹¡å¼µã®å‹ã‚’å®šç¾©ã™ã‚‹ä¼çµ±çš„ãªå®Ÿè£…æ–¹æ³•ã§ã™ã€‚\n"
"ã“ã‚Œã¯ã»ã¨ã‚“ã©ã®å ´é¢ã§ååˆ†ãªã‚‚ã®ãªã®ã§ã™ã€‚\n"
"C API ã§ã¯ã€ :c:func:`PyType_FromSpec` é–¢æ•°ã‚’ä½¿ã„ã€ãƒ’ãƒ¼ãƒ—ä¸Šã«é…ç½®ã•ã‚ŒãŸæ‹¡å¼µã®å‹ã‚‚å®šç¾©ã§ãã¾ã™ãŒã€ã“ã‚Œã«ã¤ã„ã¦ã¯ã“ã®ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã§ã¯æ‰±ã„ã¾ã›ã‚“ã€‚"

#: ../../extending/newtypes_tutorial.rst:50
msgid ""
"Now that's quite a bit to take in at once, but hopefully bits will seem "
"familiar from the previous chapter.  This file defines three things:"
msgstr ""
"ä¸€åº¦ã«æŠŠæ¡ã™ã‚‹ã«ã¯ã¡ã‚‡ã£ã¨é‡ãŒå¤šã„ã§ã™ãŒã€å‰ã®ç« ã‚ˆã‚Šã¯ã¨ã£ã¤ãã‚„ã™ããªã£ã¦ã„ã‚‹ã“ã¨ã¨é‡ã„ã¾ã™ã€‚ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã§ã¯ã€3ã¤ã®è¦ç´ ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã™:"

#: ../../extending/newtypes_tutorial.rst:53
msgid ""
"What a :class:`Custom` **object** contains: this is the ``CustomObject`` "
"struct, which is allocated once for each :class:`Custom` instance."
msgstr ""
":class:`Custom` **ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ** ãŒä½•ã‚’å«ã‚“ã§ã„ã‚‹ã‹: ã“ã‚ŒãŒ ``CustomObject`` æ§‹é€ ä½“ã§ã€ "
":class:`Custom` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã”ã¨ã«1å›ã ã‘ãƒ¡ãƒ¢ãƒªç¢ºä¿ãŒè¡Œã‚ã‚Œã¾ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:55
msgid ""
"How the :class:`Custom` **type** behaves: this is the ``CustomType`` struct,"
" which defines a set of flags and function pointers that the interpreter "
"inspects when specific operations are requested."
msgstr ""
":class:`Custom` **å‹** ãŒã©ã®ã‚ˆã†ã«æŒ¯ã‚‹èˆã†ã‹: ã“ã‚ŒãŒ ``CustomType`` "
"æ§‹é€ ä½“ã§ã€ãƒ•ãƒ©ã‚°ã¨é–¢æ•°ãƒã‚¤ãƒ³ã‚¿ã®é›†ã¾ã‚Šã‚’å®šç¾©ã—ã¦ã„ã¾ã™ã€‚ç‰¹å®šã®æ“ä½œãŒè¦æ±‚ã•ã‚ŒãŸã¨ãã«ã€ã“ã®é–¢æ•°ãƒã‚¤ãƒ³ã‚¿ã‚’ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒè¦‹ã«è¡Œãã¾ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:58
msgid ""
"How to initialize the :mod:`custom` module: this is the ``PyInit_custom`` "
"function and the associated ``custommodule`` struct."
msgstr ""
":mod:`custom` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã©ã†åˆæœŸåŒ–ã™ã‚‹ã‹: ã“ã‚ŒãŒ ``PyInit_custom`` é–¢æ•°ã¨ãã‚Œã«é–¢ä¿‚ã™ã‚‹ "
"``custommodule`` æ§‹é€ ä½“ã§ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:61
msgid "The first bit is::"
msgstr "ã¾ãšæœ€åˆã¯ã“ã‚Œã§ã™::"

#: ../../extending/newtypes_tutorial.rst:67
msgid ""
"This is what a Custom object will contain.  ``PyObject_HEAD`` is mandatory "
"at the start of each object struct and defines a field called ``ob_base`` of"
" type :c:type:`PyObject`, containing a pointer to a type object and a "
"reference count (these can be accessed using the macros :c:macro:`Py_REFCNT`"
" and :c:macro:`Py_TYPE` respectively).  The reason for the macro is to "
"abstract away the layout and to enable additional fields in debug builds."
msgstr ""
"ã“ã‚ŒãŒ Custom ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å†…å®¹ã§ã™ã€‚\n"
"``PyObject_HEAD`` ã¯ãã‚Œãã‚Œã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ ä½“ã®å…ˆé ­ã«å¿…é ˆãªã‚‚ã®ã§ã€ :c:type:`PyObject` å‹ã® ``ob_base`` ã¨ã„ã†åå‰ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å®šç¾©ã—ã¾ã™ã€‚ :c:type:`PyObject` å‹ã«ã¯ (ãã‚Œãã‚Œ :c:macro:`Py_REFCNT` ãƒã‚¯ãƒ­ãŠã‚ˆã³ :c:macro:`Py_TYPE` ãƒã‚¯ãƒ­ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹) å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã¨å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒæ ¼ç´ã•ã‚Œã¦ã„ã¾ã™ã€‚\n"
"ã“ã®ãƒã‚¯ãƒ­ãŒç”¨æ„ã•ã‚Œã¦ã„ã‚‹ç†ç”±ã¯ã€æ§‹é€ ä½“ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’æŠ½è±¡åŒ–ã—ã€ãƒ‡ãƒãƒƒã‚°ãƒ“ãƒ«ãƒ‰ã§ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¿½åŠ ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã§ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:75
msgid ""
"There is no semicolon above after the :c:macro:`PyObject_HEAD` macro. Be "
"wary of adding one by accident: some compilers will complain."
msgstr ""
"ä¸Šã®ä¾‹ã§ã¯ :c:macro:`PyObject_HEAD` ãƒã‚¯ãƒ­ã®å¾Œã«ã‚»ãƒŸã‚³ãƒ­ãƒ³ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚\n"
"ã†ã£ã‹ã‚Šã‚»ãƒŸã‚³ãƒ­ãƒ³ã‚’è¿½åŠ ã—ãªã„ã‚ˆã†ã«æ°—ã‚’ä»˜ã‘ã¦ãã ã•ã„: ã“ã‚Œã‚’è­¦å‘Šã™ã‚‹ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:78
msgid ""
"Of course, objects generally store additional data besides the standard "
"``PyObject_HEAD`` boilerplate; for example, here is the definition for "
"standard Python floats::"
msgstr ""
"ã‚‚ã¡ã‚ã‚“ã€ä¸€èˆ¬çš„ã«ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ¨™æº–çš„ãª ``PyObject_HEAD`` ãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆã®ä»–ã«ã‚‚ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒã—ã¦ã„ã¾ã™; ä¾‹ãˆã°ã€ã“ã‚Œã¯ "
"Python æ¨™æº–ã®æµ®å‹•å°æ•°ç‚¹æ•°ã®å®šç¾©ã§ã™::"

#: ../../extending/newtypes_tutorial.rst:87
msgid "The second bit is the definition of the type object. ::"
msgstr "2ã¤ç›®ã¯æ–¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å®šç¾©ã§ã™ã€‚ ::"

#: ../../extending/newtypes_tutorial.rst:99
msgid ""
"We recommend using C99-style designated initializers as above, to avoid "
"listing all the :c:type:`PyTypeObject` fields that you don't care about and "
"also to avoid caring about the fields' declaration order."
msgstr ""
"ä¸Šã«ã‚ã‚‹ã‚ˆã†ã« C99 ã‚¹ã‚¿ã‚¤ãƒ«ã®æŒ‡ç¤ºä»˜ãåˆæœŸåŒ–å­ã‚’ä½¿ã£ã¦ã€ :c:type:`PyTypeObject` "
"ã®ç‰¹ã«é–¢å¿ƒã®ç„¡ã„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¾ã§å…¨ã¦ä¸¦ã¹ãŸã‚Šã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å®£è¨€ã™ã‚‹é †åºã«æ°—ã‚’ä½¿ã£ãŸã‚Šã›ãšã«æ¸ˆã¾ã›ã‚‹ã®ã‚’ãŠè–¦ã‚ã—ã¾ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:103
msgid ""
"The actual definition of :c:type:`PyTypeObject` in :file:`object.h` has many"
" more :ref:`fields <type-structs>` than the definition above.  The remaining"
" fields will be filled with zeros by the C compiler, and it's common "
"practice to not specify them explicitly unless you need them."
msgstr ""
":file:`object.h` ã«ã‚ã‚‹å®Ÿéš›ã® :c:type:`PyTypeObject` ã®å®šç¾©ã«ã¯ä¸Šã®å®šç¾©ã«ã‚ã‚‹ã‚ˆã‚Šã‚‚ã‚‚ã£ã¨å¤šãã® :ref:`ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ <type-structs>` ãŒã‚ã‚Šã¾ã™ã€‚\n"
"ã“ã“ã«å‡ºã¦ãã¦ã„ãªã„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ C ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«ã‚ˆã£ã¦ã‚¼ãƒ­ã§åŸ‹ã‚ã‚‰ã‚Œã‚‹ã®ã§ã€å¿…è¦ã§ãªã„é™ã‚Šæ˜ç¤ºçš„ã«ã¯å€¤ã®æŒ‡å®šã‚’ã—ãªã„ã®ãŒä¸€èˆ¬çš„ãªä½œæ³•ã«ãªã£ã¦ã„ã¾ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:108
msgid "We're going to pick it apart, one field at a time::"
msgstr "ä¸€åº¦ã«1ã¤ãšã¤ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å–ã‚Šä¸Šã’ã¦ã„ãã¾ã—ã‚‡ã†::"

#: ../../extending/newtypes_tutorial.rst:112
msgid ""
"This line is mandatory boilerplate to initialize the ``ob_base`` field "
"mentioned above. ::"
msgstr "ã“ã®è¡Œã¯ã€ä¸Šã§è§¦ã‚ŒãŸ ``ob_base`` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®åˆæœŸåŒ–ã«å¿…é ˆã®ãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆã§ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:117
msgid ""
"The name of our type.  This will appear in the default textual "
"representation of our objects and in some error messages, for example:"
msgstr ""
"å®Ÿè£…ã—ã¦ã„ã‚‹å‹ã®åå‰ã§ã™ã€‚\n"
"ã“ã‚Œã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æ–‡å­—åˆ—è¡¨ç¾ã‚„ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ç¾ã‚Œã¾ã™ã€‚ä¾‹ãˆã°æ¬¡ã®é€šã‚Šã§ã™:"

#: ../../extending/newtypes_tutorial.rst:127
msgid ""
"Note that the name is a dotted name that includes both the module name and "
"the name of the type within the module. The module in this case is "
":mod:`custom` and the type is :class:`Custom`, so we set the type name to "
":class:`custom.Custom`. Using the real dotted import path is important to "
"make your type compatible with the :mod:`pydoc` and :mod:`pickle` modules. "
"::"
msgstr ""
"å‹ã®åå‰ãŒã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ãŠã‘ã‚‹å‹ã®åå‰ã®ä¸¡æ–¹ã‚’ãƒ‰ãƒƒãƒˆã§ã¤ãªã„ã åå‰ã«ãªã£ã¦ã„ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚\n"
"ã“ã®å ´åˆã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ :mod:`custom` ã§å‹ã¯ :class:`Custom` ãªã®ã§ã€å‹ã®åå‰ã‚’ :class:`custom.Custom` ã«è¨­å®šã—ã¾ã—ãŸã€‚\n"
"å®Ÿéš›ã®ãƒ‰ãƒƒãƒˆä»˜ãã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ‘ã‚¹ã‚’ä½¿ã†ã®ã¯ã€ :mod:`pydoc` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚„ :mod:`pickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨äº’æ›æ€§ã‚’æŒãŸã›ã‚‹ãŸã‚ã«é‡è¦ãªã®ã§ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:136
msgid ""
"This is so that Python knows how much memory to allocate when creating new "
":class:`Custom` instances.  :c:member:`~PyTypeObject.tp_itemsize` is only "
"used for variable-sized objects and should otherwise be zero."
msgstr ""
":c:member:`~PyTypeObject.tp_basicsize` ã¯ã€æ–°ã—ã„ :class:`Custom` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œã‚‹ã¨ã Python ãŒå‰²ã‚Šå½“ã¦ã‚‹ã¹ããƒ¡ãƒ¢ãƒªãŒã©ã®ãã‚‰ã„ãªã®ã‹ã‚’çŸ¥ã‚‹ãŸã‚ã®ã‚‚ã®ã§ã™ã€‚\n"
":c:member:`~PyTypeObject.tp_itemsize` ã¯å¯å¤‰ã‚µã‚¤ã‚ºã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã®ã¿ä½¿ã†ã‚‚ã®ãªã®ã§ã€ã‚µã‚¤ã‚ºãŒå¯å¤‰ã§ãªã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ 0 ã«ã™ã¹ãã§ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:142
msgid ""
"If you want your type to be subclassable from Python, and your type has the "
"same :c:member:`~PyTypeObject.tp_basicsize` as its base type, you may have "
"problems with multiple inheritance.  A Python subclass of your type will "
"have to list your type first in its :attr:`~class.__bases__`, or else it "
"will not be able to call your type's :meth:`__new__` method without getting "
"an error.  You can avoid this problem by ensuring that your type has a "
"larger value for :c:member:`~PyTypeObject.tp_basicsize` than its base type "
"does.  Most of the time, this will be true anyway, because either your base "
"type will be :class:`object`, or else you will be adding data members to "
"your base type, and therefore increasing its size."
msgstr ""
"ã‚ãªãŸã®ã‚¿ã‚¤ãƒ—ã‚’ Python ã§ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–å¯èƒ½ã«ã—ãŸã„å ´åˆã€ãã®ã‚¿ã‚¤ãƒ—ãŒåŸºåº•ã‚¿ã‚¤ãƒ—ã¨åŒã˜ "
":c:member:`~PyTypeObject.tp_basicsize` ã‚’ã‚‚ã£ã¦ã„ã‚‹ã¨å¤šé‡ç¶™æ‰¿ã®ã¨ãã«å•é¡ŒãŒç”Ÿã˜ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ãã®ã‚¿ã‚¤ãƒ—ã‚’ "
"Python ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã«ã—ãŸã¨ãã€ãã® :attr:`~class.__bases__` "
"ãƒªã‚¹ãƒˆã«ã¯ã‚ãªãŸã®ã‚¿ã‚¤ãƒ—ãŒæœ€åˆã«ãã‚‹ã‚ˆã†ã«ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã•ã‚‚ãªã„ã¨ã‚¨ãƒ©ãƒ¼ã®ç™ºç”Ÿãªã—ã«ã‚ãªãŸã®ã‚¿ã‚¤ãƒ—ã® :meth:`__new__` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã“ã¨ã¯ã§ããªããªã‚Šã¾ã™ã€‚ã“ã®å•é¡Œã‚’å›é¿ã™ã‚‹ã«ã¯ã€ã¤ã­ã«ã‚ãªãŸã®ã‚¿ã‚¤ãƒ—ã® "
":c:member:`~PyTypeObject.tp_basicsize` "
"ã‚’ãã®åŸºåº•ã‚¿ã‚¤ãƒ—ã‚ˆã‚Šã‚‚å¤§ããã—ã¦ãŠãã“ã¨ã§ã™ã€‚ã»ã¨ã‚“ã©ã®å ´åˆã€ã‚ãªãŸã®ã‚¿ã‚¤ãƒ—ã¯ :class:`object` "
"ã‹ã€ãã†ã§ãªã‘ã‚Œã°åŸºåº•ã‚¿ã‚¤ãƒ—ã«ãƒ‡ãƒ¼ã‚¿ç”¨ã®ãƒ¡ãƒ³ãƒã‚’è¿½åŠ ã—ãŸã‚‚ã®ã§ã—ã‚‡ã†ã‹ã‚‰ã€ã—ãŸãŒã£ã¦å¤§ãã•ã¯ã¤ã­ã«å¢—åŠ ã™ã‚‹ãŸã‚ã“ã®æ¡ä»¶ã¯æº€ãŸã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:152
msgid "We set the class flags to :const:`Py_TPFLAGS_DEFAULT`. ::"
msgstr ":const:`Py_TPFLAGS_DEFAULT` ã«ã‚¯ãƒ©ã‚¹ãƒ•ãƒ©ã‚°ã‚’è¨­å®šã—ã¾ã™ã€‚ ::"

#: ../../extending/newtypes_tutorial.rst:156
msgid ""
"All types should include this constant in their flags.  It enables all of "
"the members defined until at least Python 3.3.  If you need further members,"
" you will need to OR the corresponding flags."
msgstr ""
"ã™ã¹ã¦ã®å‹ã¯ãƒ•ãƒ©ã‚°ã«ã“ã®å®šæ•°ã‚’å«ã‚ã¦ãŠãå¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯æœ€ä½ã§ã‚‚ Python 3.3 "
"ã¾ã§ã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®ãƒ¡ãƒ³ãƒã‚’è¨±å¯ã—ã¾ã™ã€‚ãã‚Œä»¥ä¸Šã®ãƒ¡ãƒ³ãƒãŒå¿…è¦ãªã‚‰ã€å¯¾å¿œã™ã‚‹ãƒ•ãƒ©ã‚°ã® OR ã‚’ã¨ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:160
msgid ""
"We provide a doc string for the type in :c:member:`~PyTypeObject.tp_doc`. ::"
msgstr "ã“ã®å‹ã® docstring ã¯ :c:member:`~PyTypeObject.tp_doc` ã«å…¥ã‚Œã¾ã™ã€‚ ::"

#: ../../extending/newtypes_tutorial.rst:164
msgid ""
"To enable object creation, we have to provide a "
":c:member:`~PyTypeObject.tp_new` handler.  This is the equivalent of the "
"Python method :meth:`__new__`, but has to be specified explicitly.  In this "
"case, we can just use the default implementation provided by the API "
"function :c:func:`PyType_GenericNew`. ::"
msgstr ""
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç”Ÿæˆã§ãã‚‹ã‚ˆã†ã«ã€ :c:member:`~PyTypeObject.tp_new` ãƒãƒ³ãƒ‰ãƒ©ã‚’æä¾›ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚\n"
"ã“ã‚Œã¯ Python ã®ãƒ¡ã‚½ãƒƒãƒ‰ :meth:`__new__` ã¨åŒç­‰ã®ã‚‚ã®ã§ã™ãŒã€æ˜ç¤ºçš„ã«ä¸ãˆã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚\n"
"ä»Šã®å ´åˆã§ã¯ã€ API é–¢æ•°ã® :c:func:`PyType_GenericNew` ã¨ã—ã¦æä¾›ã•ã‚Œã‚‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’ãã®ã¾ã¾ä½¿ãˆã¾ã™ã€‚ ::"

#: ../../extending/newtypes_tutorial.rst:171
msgid ""
"Everything else in the file should be familiar, except for some code in "
":c:func:`PyInit_custom`::"
msgstr ""
"ãƒ•ã‚¡ã‚¤ãƒ«ã®æ®‹ã‚Šã®éƒ¨åˆ†ã¯ãã£ã¨é¦´æŸ“ã¿ã‚„ã™ã„ã‚‚ã®ã ã¨æ€ã„ã¾ã™ãŒã€ :c:func:`PyInit_custom` ã®ä¸€éƒ¨ã®ã‚³ãƒ¼ãƒ‰ã¯ãã†ã§ã¯ãªã„ã§ã—ã‚‡ã†::"

#: ../../extending/newtypes_tutorial.rst:177
msgid ""
"This initializes the :class:`Custom` type, filling in a number of members to"
" the appropriate default values, including :attr:`ob_type` that we initially"
" set to *NULL*. ::"
msgstr ""
"ã“ã‚Œã¯ã€ *NULL* ã«åˆæœŸåŒ–ã•ã‚ŒãŸ :attr:`ob_type` ã‚‚å«ã‚ã¦ã€ã„ãã¤ã‹ã®ãƒ¡ãƒ³ãƒãƒ¼ã‚’é©åˆ‡ãªãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã§åŸ‹ã‚ã¦ã€ "
":class:`Custom` å‹ã‚’åˆæœŸåŒ–ã—ã¾ã™ã€‚ ::"

#: ../../extending/newtypes_tutorial.rst:183
msgid ""
"This adds the type to the module dictionary.  This allows us to create "
":class:`Custom` instances by calling the :class:`Custom` class:"
msgstr ""
"ã“ã‚Œã¯å‹ã‚’ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®è¾æ›¸ã«è¿½åŠ ã—ã¾ã™ã€‚\n"
"ã“ã†ã™ã‚‹ã“ã¨ã§ :class:`Custom` ã‚¯ãƒ©ã‚¹ã®å‘¼ã³å‡ºã—ã§ :class:`Custom` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒä½œæˆã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™:"

#: ../../extending/newtypes_tutorial.rst:191
msgid ""
"That's it!  All that remains is to build it; put the above code in a file "
"called :file:`custom.c` and:"
msgstr ""
"ä»¥ä¸Šã§ã™!\n"
"æ®‹ã‚Šã®ä½œæ¥­ã¯ãƒ“ãƒ«ãƒ‰ã ã‘ã§ã™; :file:`custom.c` ã¨ã„ã†åå‰ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«ã“ã“ã¾ã§ã®ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãè¾¼ã¿ã€æ¬¡ã®å†…å®¹ã‚’æŒã¤ setup.py ã‚’ç”¨æ„ã—ã¾ã™:"

#: ../../extending/newtypes_tutorial.rst:200
msgid "in a file called :file:`setup.py`; then typing"
msgstr "ãã—ã¦ã€ã‚·ã‚§ãƒ«ã‹ã‚‰ä»¥ä¸‹ã®ã‚ˆã†ã«å…¥åŠ›ã—ã¾ã™"

#: ../../extending/newtypes_tutorial.rst:206
msgid ""
"at a shell should produce a file :file:`custom.so` in a subdirectory; move "
"to that directory and fire up Python --- you should be able to ``import "
"custom`` and play around with Custom objects."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:210
msgid "That wasn't so hard, was it?"
msgstr "ãã‚“ãªã«ã‚€ãšã‹ã—ãã‚ã‚Šã¾ã›ã‚“ã€ã‚ˆã­?"

#: ../../extending/newtypes_tutorial.rst:212
msgid ""
"Of course, the current Custom type is pretty uninteresting. It has no data "
"and doesn't do anything. It can't even be subclassed."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:216
msgid ""
"While this documentation showcases the standard :mod:`distutils` module for "
"building C extensions, it is recommended in real-world use cases to use the "
"newer and better-maintained ``setuptools`` library.  Documentation on how to"
" do this is out of scope for this document and can be found in the `Python "
"Packaging User's Guide <https://packaging.python.org/tutorials/distributing-"
"packages/>`_."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:224
msgid "Adding data and methods to the Basic example"
msgstr "åŸºæœ¬ã®ã‚µãƒ³ãƒ—ãƒ«ã«ãƒ‡ãƒ¼ã‚¿ã¨ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã™ã‚‹"

#: ../../extending/newtypes_tutorial.rst:226
msgid ""
"Let's extend the basic example to add some data and methods.  Let's also "
"make the type usable as a base class. We'll create a new module, "
":mod:`custom2` that adds these capabilities:"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:233
msgid "This version of the module has a number of changes."
msgstr "ã“ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ã€ã„ãã¤ã‚‚ã®å¤‰æ›´ã‚’ãŠã“ãªã„ã¾ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:235
msgid "We've added an extra include::"
msgstr "ä»¥ä¸‹ã® include ã‚’è¿½åŠ ã—ã¾ã™::"

#: ../../extending/newtypes_tutorial.rst:239
msgid ""
"This include provides declarations that we use to handle attributes, as "
"described a bit later."
msgstr "ã™ã“ã—ã‚ã¨ã§ãµã‚Œã¾ã™ãŒã€ã“ã® include ã«ã¯å±æ€§ã‚’æ‰±ã†ãŸã‚ã®å®£è¨€ãŒå…¥ã£ã¦ã„ã¾ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:242
msgid ""
"The  :class:`Custom` type now has three data attributes in its C struct, "
"*first*, *last*, and *number*.  The *first* and *last* variables are Python "
"strings containing first and last names.  The *number* attribute is a C "
"integer."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:246
msgid "The object structure is updated accordingly::"
msgstr "ã“ã‚Œã«ã—ãŸãŒã†ã¨ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ§‹é€ ä½“ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../extending/newtypes_tutorial.rst:255
msgid ""
"Because we now have data to manage, we have to be more careful about object "
"allocation and deallocation.  At a minimum, we need a deallocation method::"
msgstr ""
"ã„ã¾ã‚„ç®¡ç†ã™ã¹ããƒ‡ãƒ¼ã‚¿ãŒã§ããŸã®ã§ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‰²ã‚Šå½“ã¦ã¨è§£æ”¾ã«éš›ã—ã¦ã¯ã‚ˆã‚Šæ…é‡ã«ãªã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚æœ€ä½é™ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è§£æ”¾ãƒ¡ã‚½ãƒƒãƒ‰ãŒå¿…è¦ã§ã™::"

#: ../../extending/newtypes_tutorial.rst:266
msgid "which is assigned to the :c:member:`~PyTypeObject.tp_dealloc` member::"
msgstr "ã“ã®é–¢æ•°ã¯ :c:member:`~PyTypeObject.tp_dealloc` ãƒ¡ãƒ³ãƒã«ä»£å…¥ã•ã‚Œã¾ã™ã€‚ ::"

#: ../../extending/newtypes_tutorial.rst:270
msgid ""
"This method first clears the reference counts of the two Python attributes. "
":c:func:`Py_XDECREF` correctly handles the case where its argument is *NULL*"
" (which might happen here if ``tp_new`` failed midway).  It then calls the "
":c:member:`~PyTypeObject.tp_free` member of the object's type (computed by "
"``Py_TYPE(self)``) to free the object's memory.  Note that the object's type"
" might not be :class:`CustomType`, because the object may be an instance of "
"a subclass."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:279
msgid ""
"The explicit cast to ``destructor`` above is needed because we defined "
"``Custom_dealloc`` to take a ``CustomObject *`` argument, but the "
"``tp_dealloc`` function pointer expects to receive a ``PyObject *`` "
"argument.  Otherwise, the compiler will emit a warning.  This is object-"
"oriented polymorphism, in C!"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:285
msgid ""
"We want to make sure that the first and last names are initialized to empty "
"strings, so we provide a ``tp_new`` implementation::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:309
msgid "and install it in the :c:member:`~PyTypeObject.tp_new` member::"
msgstr "ãã—ã¦ã“ã‚Œã‚’ :c:member:`~PyTypeObject.tp_new` ãƒ¡ãƒ³ãƒã¨ã—ã¦ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã™::"

#: ../../extending/newtypes_tutorial.rst:313
msgid ""
"The ``tp_new`` handler is responsible for creating (as opposed to "
"initializing) objects of the type.  It is exposed in Python as the "
":meth:`__new__` method. It is not required to define a ``tp_new`` member, "
"and indeed many extension types will simply reuse "
":c:func:`PyType_GenericNew` as done in the first version of the ``Custom`` "
"type above.  In this case, we use the ``tp_new`` handler to initialize the "
"``first`` and ``last`` attributes to non-*NULL* default values."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:321
msgid ""
"``tp_new`` is passed the type being instantiated (not necessarily "
"``CustomType``, if a subclass is instantiated) and any arguments passed when"
" the type was called, and is expected to return the instance created.  "
"``tp_new`` handlers always accept positional and keyword arguments, but they"
" often ignore the arguments, leaving the argument handling to initializer "
"(a.k.a. ``tp_init`` in C or ``__init__`` in Python) methods."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:329
msgid ""
"``tp_new`` shouldn't call ``tp_init`` explicitly, as the interpreter will do"
" it itself."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:332
msgid ""
"The ``tp_new`` implementation calls the :c:member:`~PyTypeObject.tp_alloc` "
"slot to allocate memory::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:337
msgid ""
"Since memory allocation may fail, we must check the "
":c:member:`~PyTypeObject.tp_alloc` result against *NULL* before proceeding."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:341
msgid ""
"We didn't fill the :c:member:`~PyTypeObject.tp_alloc` slot ourselves. Rather"
" :c:func:`PyType_Ready` fills it for us by inheriting it from our base "
"class, which is :class:`object` by default.  Most types use the default "
"allocation strategy."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:347
msgid ""
"If you are creating a co-operative :c:member:`~PyTypeObject.tp_new` (one "
"that calls a base type's :c:member:`~PyTypeObject.tp_new` or "
":meth:`__new__`), you must *not* try to determine what method to call using "
"method resolution order at runtime.  Always statically determine what type "
"you are going to call, and call its :c:member:`~PyTypeObject.tp_new` "
"directly, or via ``type->tp_base->tp_new``.  If you do not do this, Python "
"subclasses of your type that also inherit from other Python-defined classes "
"may not work correctly. (Specifically, you may not be able to create "
"instances of such subclasses without getting a :exc:`TypeError`.)"
msgstr ""
"ã‚‚ã—å”åŠ›çš„ãª :c:member:`~PyTypeObject.tp_new` (åŸºåº•ã‚¿ã‚¤ãƒ—ã® "
":c:member:`~PyTypeObject.tp_new` ã¾ãŸã¯ :meth:`__new__` ã‚’å‘¼ã‚“ã§ã„ã‚‹ã‚‚ã®) "
"ã‚’ä½œã‚ŠãŸã„ã®ãªã‚‰ã°ã€å®Ÿè¡Œæ™‚ã®ãƒ¡ã‚½ãƒƒãƒ‰è§£æ±ºé †åºã‚’ã¤ã‹ã£ã¦ã©ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³ã ã™ã‹ã‚’æ±ºå®šã—ã‚ˆã†ã¨ã—ã¦ã¯ *ã„ã‘ã¾ã›ã‚“* "
"ã€‚ã¤ã­ã«å‘¼ã³å‡ºã™å‹ã‚’é™çš„ã«æ±ºã‚ã¦ãŠãã€ç›´æ¥ãã® :c:member:`~PyTypeObject.tp_new` ã‚’å‘¼ã³å‡ºã™ã‹ã€ã‚ã‚‹ã„ã¯ "
"``type->tp_base->tp_new`` ã‚’çµŒç”±ã—ã¦ãã ã•ã„ã€‚ã“ã†ã—ãªã„ã¨ã€ã‚ãªãŸãŒä½œæˆã—ãŸã‚¿ã‚¤ãƒ—ã® Python ã‚µãƒ–ã‚¯ãƒ©ã‚¹ãŒä»–ã® "
"Python ã§å®šç¾©ã•ã‚ŒãŸã‚¯ãƒ©ã‚¹ã‚‚ç¶™æ‰¿ã—ã¦ã„ã‚‹å ´åˆã«ã†ã¾ãå‹•ã‹ãªã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ (ã¨ã‚Šã‚ã‘ã€ãã®ã‚ˆã†ãªã‚µãƒ–ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ "
":exc:`TypeError` ã‚’å‡ºã•ãšã«ä½œã‚‹ã“ã¨ãŒä¸å¯èƒ½ã«ãªã‚Šã¾ã™ã€‚)"

#: ../../extending/newtypes_tutorial.rst:357
msgid ""
"We also define an initialization function which accepts arguments to provide"
" initial values for our instance::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:386
msgid "by filling the :c:member:`~PyTypeObject.tp_init` slot. ::"
msgstr "ã“ã‚Œã¯ :c:member:`~PyTypeObject.tp_init` ãƒ¡ãƒ³ãƒã«ä»£å…¥ã•ã‚Œã¾ã™ã€‚ ::"

#: ../../extending/newtypes_tutorial.rst:390
msgid ""
"The :c:member:`~PyTypeObject.tp_init` slot is exposed in Python as the "
":meth:`__init__` method.  It is used to initialize an object after it's "
"created.  Initializers always accept positional and keyword arguments, and "
"they should return either ``0`` on success or ``-1`` on error."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:395
msgid ""
"Unlike the ``tp_new`` handler, there is no guarantee that ``tp_init`` is "
"called at all (for example, the :mod:`pickle` module by default doesn't call"
" :meth:`__init__` on unpickled instances).  It can also be called multiple "
"times.  Anyone can call the :meth:`__init__` method on our objects.  For "
"this reason, we have to be extra careful when assigning the new attribute "
"values.  We might be tempted, for example to assign the ``first`` member "
"like this::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:409
msgid ""
"But this would be risky.  Our type doesn't restrict the type of the "
"``first`` member, so it could be any kind of object.  It could have a "
"destructor that causes code to be executed that tries to access the "
"``first`` member; or that destructor could release the :term:`Global "
"interpreter Lock` and let arbitrary code run in other threads that accesses "
"and modifies our object."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:416
msgid ""
"To be paranoid and protect ourselves against this possibility, we almost "
"always reassign members before decrementing their reference counts.  When "
"don't we have to do this?"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:420
msgid "when we absolutely know that the reference count is greater than 1;"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:422
msgid ""
"when we know that deallocation of the object [#]_ will neither release the "
":term:`GIL` nor cause any calls back into our type's code;"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:425
msgid ""
"when decrementing a reference count in a "
":c:member:`~PyTypeObject.tp_dealloc` handler on a type which doesn't support"
" cyclic garbage collection [#]_."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:428
msgid ""
"We want to expose our instance variables as attributes. There are a number "
"of ways to do that. The simplest way is to define member definitions::"
msgstr ""
"ã“ã“ã§ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã‚’å±æ€§ã¨ã—ã¦è¦‹ãˆã‚‹ã‚ˆã†ã«ã—ãŸã„ã®ã§ã™ãŒã€ã“ã‚Œã«ã¯ã„ãã¤ã‚‚ã®æ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚ã‚‚ã£ã¨ã‚‚ç°¡å˜ãªæ–¹æ³•ã¯ã€ãƒ¡ãƒ³ãƒã®å®šç¾©ã‚’ä¸ãˆã‚‹ã“ã¨ã§ã™::"

#: ../../extending/newtypes_tutorial.rst:441
msgid ""
"and put the definitions in the :c:member:`~PyTypeObject.tp_members` slot::"
msgstr "ãã—ã¦ã€ã“ã®å®šç¾©ã‚’ :c:member:`~PyTypeObject.tp_members` ã‚¹ãƒ­ãƒƒãƒˆã«å…¥ã‚Œã¾ã—ã‚‡ã†::"

#: ../../extending/newtypes_tutorial.rst:445
msgid ""
"Each member definition has a member name, type, offset, access flags and "
"documentation string.  See the :ref:`Generic-Attribute-Management` section "
"below for details."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:449
msgid ""
"A disadvantage of this approach is that it doesn't provide a way to restrict"
" the types of objects that can be assigned to the Python attributes.  We "
"expect the first and last names to be strings, but any Python objects can be"
" assigned. Further, the attributes can be deleted, setting the C pointers to"
" *NULL*.  Even though we can make sure the members are initialized to "
"non-*NULL* values, the members can be set to *NULL* if the attributes are "
"deleted."
msgstr ""
"ã“ã®æ–¹æ³•ã®æ¬ ç‚¹ã¯ã€Python å±æ€§ã«ä»£å…¥ã§ãã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã‚’åˆ¶é™ã™ã‚‹æ–¹æ³•ãŒãªã„ã“ã¨ã§ã™ã€‚ã“ã“ã§ã¯ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆãƒãƒ¼ãƒ  first ã¨ãƒ©ã‚¹ãƒˆãƒãƒ¼ãƒ  "
"last ã«ã€ã¨ã‚‚ã«æ–‡å­—åˆ—ãŒå…¥ã‚‹ã‚ˆã†æœŸå¾…ã—ã¦ã„ã¾ã™ãŒã€ä»Šã®ã‚„ã‚Šæ–¹ã§ã¯ã©ã‚“ãª Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚ä»£å…¥ã§ãã¦ã—ã¾ã„ã¾ã™ã€‚åŠ ãˆã¦ã“ã®å±æ€§ã¯å‰Šé™¤ "
"(del) ã§ãã¦ã—ã¾ã„ã€ãã®å ´åˆã€ C ã®ãƒã‚¤ãƒ³ã‚¿ã«ã¯ *NULL* ãŒè¨­å®šã•ã‚Œã¾ã™ã€‚ãŸã¨ãˆã‚‚ã—ãƒ¡ãƒ³ãƒãŒ *NULL* "
"ä»¥å¤–ã®å€¤ã«åˆæœŸåŒ–ã•ã‚Œã‚‹ã‚ˆã†ã«ã—ã¦ã‚ã£ãŸã¨ã—ã¦ã‚‚ã€å±æ€§ãŒå‰Šé™¤ã•ã‚Œã‚Œã°ãƒ¡ãƒ³ãƒã¯ *NULL* ã«ãªã£ã¦ã—ã¾ã„ã¾ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:456
msgid ""
"We define a single method, :meth:`Custom.name()`, that outputs the objects "
"name as the concatenation of the first and last names. ::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:473
msgid ""
"The method is implemented as a C function that takes a :class:`Custom` (or "
":class:`Custom` subclass) instance as the first argument.  Methods always "
"take an instance as the first argument. Methods often take positional and "
"keyword arguments as well, but in this case we don't take any and don't need"
" to accept a positional argument tuple or keyword argument dictionary. This "
"method is equivalent to the Python method:"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:485
msgid ""
"Note that we have to check for the possibility that our :attr:`first` and "
":attr:`last` members are *NULL*.  This is because they can be deleted, in "
"which case they are set to *NULL*.  It would be better to prevent deletion "
"of these attributes and to restrict the attribute values to be strings.  "
"We'll see how to do that in the next section."
msgstr ""
":attr:`first` ãƒ¡ãƒ³ãƒã¨ :attr:`last` ãƒ¡ãƒ³ãƒãŒãã‚Œãã‚Œ *NULL* "
"ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã“ã‚Œã‚‰ã¯å‰Šé™¤ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã€ãã®å ´åˆå€¤ã¯ *NULL* "
"ã«ã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚ã“ã®å±æ€§ã®å‰Šé™¤ã‚’ç¦æ­¢ã—ã¦ã€ãã“ã«å…¥ã‚Œã‚‰ã‚Œã‚‹å€¤ã‚’æ–‡å­—åˆ—ã«é™å®šã§ãã‚Œã°ãªãŠã„ã„ã§ã—ã‚‡ã†ã€‚æ¬¡ã®ç¯€ã§ã¯ã“ã‚Œã«ã¤ã„ã¦æ‰±ã„ã¾ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:491
msgid ""
"Now that we've defined the method, we need to create an array of method "
"definitions::"
msgstr "ã•ã¦ã€ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ãŸã®ã§ã€ã“ã“ã§ãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©ç”¨ã®é…åˆ—ã‚’ä½œæˆã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™::"

#: ../../extending/newtypes_tutorial.rst:501
msgid ""
"(note that we used the :const:`METH_NOARGS` flag to indicate that the method"
" is expecting no arguments other than *self*)"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:504
msgid "and assign it to the :c:member:`~PyTypeObject.tp_methods` slot::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:508
msgid ""
"Finally, we'll make our type usable as a base class for subclassing.  We've "
"written our methods carefully so far so that they don't make any assumptions"
" about the type of the object being created or used, so all we need to do is"
" to add the :const:`Py_TPFLAGS_BASETYPE` to our class flag definition::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:515
msgid ""
"We rename :c:func:`PyInit_custom` to :c:func:`PyInit_custom2`, update the "
"module name in the :c:type:`PyModuleDef` struct, and update the full class "
"name in the :c:type:`PyTypeObject` struct."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:519
msgid "Finally, we update our :file:`setup.py` file to build the new module:"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:532
msgid "Providing finer control over data attributes"
msgstr "ãƒ‡ãƒ¼ã‚¿å±æ€§ã‚’ã“ã¾ã‹ãåˆ¶å¾¡ã™ã‚‹"

#: ../../extending/newtypes_tutorial.rst:534
msgid ""
"In this section, we'll provide finer control over how the :attr:`first` and "
":attr:`last` attributes are set in the :class:`Custom` example. In the "
"previous version of our module, the instance variables :attr:`first` and "
":attr:`last` could be set to non-string values or even deleted. We want to "
"make sure that these attributes always contain strings."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:543
msgid ""
"To provide greater control, over the :attr:`first` and :attr:`last` "
"attributes, we'll use custom getter and setter functions.  Here are the "
"functions for getting and setting the :attr:`first` attribute::"
msgstr ""
":attr:`first` å±æ€§ã¨ :attr:`last` å±æ€§ã‚’ã‚ˆã‚Šã“ã¾ã‹ãåˆ¶å¾¡ã™ã‚‹ãŸã‚ã«ã¯ã€ã‚«ã‚¹ã‚¿ãƒ ãƒ¡ã‚¤ãƒ‰ã® getter é–¢æ•°ã¨ setter "
"é–¢æ•°ã‚’ä½¿ã„ã¾ã™ã€‚ä»¥ä¸‹ã¯ :attr:`first` å±æ€§ã‹ã‚‰å€¤ã‚’å–å¾—ã™ã‚‹é–¢æ•° (getter) ã¨ã€ã“ã®å±æ€§ã«å€¤ã‚’æ ¼ç´ã™ã‚‹é–¢æ•° (setter) "
"ã§ã™::"

#: ../../extending/newtypes_tutorial.rst:574
msgid ""
"The getter function is passed a :class:`Custom` object and a \"closure\", "
"which is a void pointer.  In this case, the closure is ignored.  (The "
"closure supports an advanced usage in which definition data is passed to the"
" getter and setter. This could, for example, be used to allow a single set "
"of getter and setter functions that decide the attribute to get or set based"
" on data in the closure.)"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:580
msgid ""
"The setter function is passed the :class:`Custom` object, the new value, and"
" the closure.  The new value may be *NULL*, in which case the attribute is "
"being deleted.  In our setter, we raise an error if the attribute is deleted"
" or if its new value is not a string."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:585
msgid "We create an array of :c:type:`PyGetSetDef` structures::"
msgstr "ã“ã“ã§ã¯ :c:type:`PyGetSetDef` æ§‹é€ ä½“ã®é…åˆ—ã‚’ã¤ãã‚Šã¾ã™::"

#: ../../extending/newtypes_tutorial.rst:595
msgid "and register it in the :c:member:`~PyTypeObject.tp_getset` slot::"
msgstr "ãã—ã¦ã“ã‚Œã‚’ :c:member:`~PyTypeObject.tp_getset` ã‚¹ãƒ­ãƒƒãƒˆã«ç™»éŒ²ã—ã¾ã™::"

#: ../../extending/newtypes_tutorial.rst:599
msgid ""
"The last item in a :c:type:`PyGetSetDef` structure is the \"closure\" "
"mentioned above.  In this case, we aren't using a closure, so we just pass "
"*NULL*."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:602
msgid "We also remove the member definitions for these attributes::"
msgstr "ã¾ãŸã€ãƒ¡ãƒ³ãƒå®šç¾©ã‹ã‚‰ã¯ã“ã‚Œã‚‰ã®å±æ€§ã‚’é™¤ã„ã¦ãŠãã¾ã—ã‚‡ã†::"

#: ../../extending/newtypes_tutorial.rst:610
msgid ""
"We also need to update the :c:member:`~PyTypeObject.tp_init` handler to only"
" allow strings [#]_ to be passed::"
msgstr ""
"ã¾ãŸã€ã“ã“ã§ã¯ :c:member:`~PyTypeObject.tp_init` "
"ãƒãƒ³ãƒ‰ãƒ©ã‚‚æ¸¡ã•ã‚Œã‚‹ã‚‚ã®ã¨ã—ã¦æ–‡å­—åˆ—ã®ã¿ã‚’è¨±å¯ã™ã‚‹ã‚ˆã†ã«ä¿®æ­£ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ [#]_::"

#: ../../extending/newtypes_tutorial.rst:639
msgid ""
"With these changes, we can assure that the ``first`` and ``last`` members "
"are never *NULL* so we can remove checks for *NULL* values in almost all "
"cases. This means that most of the :c:func:`Py_XDECREF` calls can be "
"converted to :c:func:`Py_DECREF` calls.  The only place we can't change "
"these calls is in the ``tp_dealloc`` implementation, where there is the "
"possibility that the initialization of these members failed in ``tp_new``."
msgstr ""
"ã“ã‚Œã‚‰ã®å¤‰æ›´ã«ã‚ˆã£ã¦ã€``first`` ãƒ¡ãƒ³ãƒã¨ ``last`` ãƒ¡ãƒ³ãƒãŒæ±ºã—ã¦ *NULL* "
"ã«ãªã‚‰ãªã„ã¨ä¿è¨¼ã§ãã¾ã—ãŸã€‚ã“ã‚Œã§ã»ã¨ã‚“ã©ã™ã¹ã¦ã®ã‚±ãƒ¼ã‚¹ã‹ã‚‰ *NULL* å€¤ã®ãƒã‚§ãƒƒã‚¯ã‚’é™¤ã‘ã¾ã™ã€‚ã“ã‚Œã¯å¤šãã® "
":c:func:`Py_XDECREF` å‘¼ã³å‡ºã—ã‚’ :c:func:`Py_DECREF` "
"å‘¼ã³å‡ºã—ã«å¤‰ãˆã‚‰ã‚Œã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚å”¯ä¸€ã“ã‚Œã‚’å¤‰ãˆã‚‰ã‚Œãªã„ã®ã¯ ``tp_dealloc`` ã®å®Ÿè£…ä¸­ã§ã€ãªãœãªã‚‰ãã“ã§ã¯ ``tp_new`` "
"ã§ã®ãƒ¡ãƒ³ãƒåˆæœŸåŒ–ãŒå¤±æ•—ã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã‹ã‚‰ã§ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:646
msgid ""
"We also rename the module initialization function and module name in the "
"initialization function, as we did before, and we add an extra definition to"
" the :file:`setup.py` file."
msgstr ""
"ã•ã¦ã€å…ˆã»ã©ã‚‚ã—ãŸã‚ˆã†ã«ã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆæœŸåŒ–é–¢æ•°ã¨åˆæœŸåŒ–é–¢æ•°å†…ã«ã‚ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã‚’å¤‰æ›´ã—ã¾ã—ã‚‡ã†ã€‚ãã—ã¦ :file:`setup.py` "
"ãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½åŠ ã®å®šç¾©ã‚’ãã‚ãˆã¾ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:652
msgid "Supporting cyclic garbage collection"
msgstr "å¾ªç’°ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹"

#: ../../extending/newtypes_tutorial.rst:654
msgid ""
"Python has a :term:`cyclic garbage collector (GC) <garbage collection>` that"
" can identify unneeded objects even when their reference counts are not "
"zero. This can happen when objects are involved in cycles.  For example, "
"consider:"
msgstr ""
"Python ã¯:term:`å¾ªç’°ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚¿(GC)æ©Ÿèƒ½<garbage collection> "
"`ã‚’ã‚‚ã£ã¦ãŠã‚Šã€ã“ã‚Œã¯ä¸è¦ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã€ãŸã¨ãˆå‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒã‚¼ãƒ­ã§ãªãã¦ã‚‚ç™ºè¦‹ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãã®ã‚ˆã†ãªçŠ¶æ³ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‚ç…§ãŒå¾ªç’°ã—ã¦ã„ã‚‹ã¨ãã«èµ·ã“ã‚Šãˆã¾ã™ã€‚ãŸã¨ãˆã°ä»¥ä¸‹ã®ä¾‹ã‚’è€ƒãˆã¦ãã ã•ã„:"

#: ../../extending/newtypes_tutorial.rst:664
msgid ""
"In this example, we create a list that contains itself. When we delete it, "
"it still has a reference from itself. Its reference count doesn't drop to "
"zero. Fortunately, Python's cyclic garbage collector will eventually figure "
"out that the list is garbage and free it."
msgstr ""
"ã“ã®ä¾‹ã§ã¯ã€è‡ªåˆ†è‡ªèº«ã‚’ãµãã‚€ãƒªã‚¹ãƒˆã‚’ä½œã‚Šã¾ã—ãŸã€‚ãŸã¨ãˆã“ã®ãƒªã‚¹ãƒˆã‚’ "
"å‰Šé™¤ã—ã¦ã‚‚ã€ãã‚Œã¯è‡ªåˆ†è‡ªèº«ã¸ã®å‚ç…§ã‚’ã¾ã æŒã¡ã¤ã¥ã‘ã¾ã™ã‹ã‚‰ã€å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã¯ã‚¼ãƒ­ã«ã¯ãªã‚Šã¾ã›ã‚“ã€‚å¬‰ã—ã„ã“ã¨ã« Python "
"ã«ã¯å¾ªç’°ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚¿ã¯æœ€çµ‚çš„ã«ã¯ã“ã®ãƒªã‚¹ãƒˆãŒä¸è¦ã§ã‚ã‚‹ã“ã¨ã‚’æ¤œå‡ºã—ã€è§£æ”¾ã§ãã¾ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:669
msgid ""
"In the second version of the :class:`Custom` example, we allowed any kind of"
" object to be stored in the :attr:`first` or :attr:`last` attributes [#]_. "
"Besides, in the second and third versions, we allowed subclassing "
":class:`Custom`, and subclasses may add arbitrary attributes.  For any of "
"those two reasons, :class:`Custom` objects can participate in cycles:"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:683
msgid ""
"To allow a :class:`Custom` instance participating in a reference cycle to be"
" properly detected and collected by the cyclic GC, our :class:`Custom` type "
"needs to fill two additional slots and to enable a flag that enables these "
"slots:"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:690
msgid ""
"First, the traversal method lets the cyclic GC know about subobjects that "
"could participate in cycles::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:710
msgid ""
"For each subobject that can participate in cycles, we need to call the "
":c:func:`visit` function, which is passed to the traversal method. The "
":c:func:`visit` function takes as arguments the subobject and the extra "
"argument *arg* passed to the traversal method.  It returns an integer value "
"that must be returned if it is non-zero."
msgstr ""
"å¾ªç’°ã—ãŸå‚ç…§ã«å«ã¾ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œãªã„å„å†…éƒ¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ã€ traversal ãƒ¡ã‚½ãƒƒãƒ‰ã«æ¸¡ã•ã‚ŒãŸ :c:func:`visit` é–¢æ•°ã‚’å‘¼ã³ã¾ã™ã€‚"
" :c:func:`visit` é–¢æ•°ã¯å†…éƒ¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã€traversal ãƒ¡ã‚½ãƒƒãƒ‰ã«æ¸¡ã•ã‚ŒãŸè¿½åŠ ã®å¼•æ•° *arg* "
"ã‚’å¼•æ•°ã¨ã—ã¦ã¨ã‚Šã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ã“ã®å€¤ãŒéè² ã®å ´åˆã«è¿”ã•ã‚Œã‚‹æ•´æ•°ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:716
msgid ""
"Python provides a :c:func:`Py_VISIT` macro that automates calling visit "
"functions.  With :c:func:`Py_VISIT`, we can minimize the amount of "
"boilerplate in ``Custom_traverse``::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:729
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` implementation must name its "
"arguments exactly *visit* and *arg* in order to use :c:func:`Py_VISIT`."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:732
msgid ""
"Second, we need to provide a method for clearing any subobjects that can "
"participate in cycles::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:743
msgid ""
"Notice the use of the :c:func:`Py_CLEAR` macro.  It is the recommended and "
"safe way to clear data attributes of arbitrary types while decrementing "
"their reference counts.  If you were to call :c:func:`Py_XDECREF` instead on"
" the attribute before setting it to *NULL*, there is a possibility that the "
"attribute's destructor would call back into code that reads the attribute "
"again (*especially* if there is a reference cycle)."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:751
msgid "You could emulate :c:func:`Py_CLEAR` by writing::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:758
msgid ""
"Nevertheless, it is much easier and less error-prone to always use "
":c:func:`Py_CLEAR` when deleting an attribute.  Don't try to micro-optimize "
"at the expense of robustness!"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:762
msgid ""
"The deallocator ``Custom_dealloc`` may call arbitrary code when clearing "
"attributes.  It means the circular GC can be triggered inside the function. "
"Since the GC assumes reference count is not zero, we need to untrack the "
"object from the GC by calling :c:func:`PyObject_GC_UnTrack` before clearing "
"members. Here is our reimplemented deallocator using "
":c:func:`PyObject_GC_UnTrack` and ``Custom_clear``::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:777
msgid ""
"Finally, we add the :const:`Py_TPFLAGS_HAVE_GC` flag to the class flags::"
msgstr "æœ€å¾Œã«ã€ :const:`Py_TPFLAGS_HAVE_GC` ãƒ•ãƒ©ã‚°ã‚’ã‚¯ãƒ©ã‚¹å®šç¾©ã®ãƒ•ãƒ©ã‚°ã«åŠ ãˆã¾ã™::"

#: ../../extending/newtypes_tutorial.rst:781
msgid ""
"That's pretty much it.  If we had written custom "
":c:member:`~PyTypeObject.tp_alloc` or :c:member:`~PyTypeObject.tp_free` "
"handlers, we'd need to modify them for cyclic garbage collection.  Most "
"extensions will use the versions automatically provided."
msgstr ""
"ã“ã‚Œã§å®Œäº†ã§ã™ã€‚ :c:member:`~PyTypeObject.tp_alloc` ã‚¹ãƒ­ãƒƒãƒˆã¾ãŸã¯ "
":c:member:`~PyTypeObject.tp_free` "
"ãƒãƒ³ãƒ‰ãƒ©ãŒæ›¸ã‹ã‚Œã¦ã„ã‚Œã°ã€ãã‚Œã‚‰ã‚’å¾ªç’°ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«ä½¿ãˆã‚‹ã‚ˆã†ä¿®æ­£ã™ã‚Œã°ã‚ˆã„ã®ã§ã™ã€‚ã»ã¨ã‚“ã©ã®æ‹¡å¼µæ©Ÿèƒ½ã¯è‡ªå‹•çš„ã«æä¾›ã•ã‚Œã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ä½¿ã†ã§ã—ã‚‡ã†ã€‚"

#: ../../extending/newtypes_tutorial.rst:787
msgid "Subclassing other types"
msgstr "ä»–ã®å‹ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’ä½œã‚‹"

#: ../../extending/newtypes_tutorial.rst:789
msgid ""
"It is possible to create new extension types that are derived from existing "
"types. It is easiest to inherit from the built in types, since an extension "
"can easily use the :c:type:`PyTypeObject` it needs. It can be difficult to "
"share these :c:type:`PyTypeObject` structures between extension modules."
msgstr ""
"æ—¢å­˜ã®å‹ã‚’ç¶™æ‰¿ã—ãŸæ–°ã—ã„æ‹¡å¼µå‹ã‚’ä½œæˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚çµ„ã¿è¾¼ã¿å‹ã‹ã‚‰ç¶™æ‰¿ã™ã‚‹ã®ã¯ç‰¹ã«ç°¡å˜ã§ã™ã€‚å¿…è¦ãª :c:type:`PyTypeObject` "
"ã‚’ç°¡å˜ã«åˆ©ç”¨ã§ãã‚‹ã‹ã‚‰ã§ã™ã€‚ãã‚Œã«æ¯”ã¹ã¦ã€ :c:type:`PyTypeObject` æ§‹é€ ä½“ã‚’æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«é–“ã§å…±æœ‰ã™ã‚‹ã®ã¯é›£ã—ã„ã§ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:794
msgid ""
"In this example we will create a :class:`SubList` type that inherits from "
"the built-in :class:`list` type. The new type will be completely compatible "
"with regular lists, but will have an additional :meth:`increment` method "
"that increases an internal counter:"
msgstr ""
"æ¬¡ã®ä¾‹ã§ã¯ã€ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ã® :class:`list` å‹ã‚’ç¶™æ‰¿ã—ãŸ :class:`SubList` "
"å‹ã‚’ä½œæˆã—ã¦ã„ã¾ã™ã€‚æ–°ã—ã„å‹ã¯é€šå¸¸ã®ãƒªã‚¹ãƒˆå‹ã¨å®Œå…¨ã«äº’æ›æ€§ãŒã‚ã‚Šã¾ã™ãŒã€è¿½åŠ ã§å†…éƒ¨ã®ã‚«ã‚¦ãƒ³ã‚¿ã‚’å¢—ã‚„ã™ :meth:`increment` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã¾ã™:"

#: ../../extending/newtypes_tutorial.rst:814
msgid ""
"As you can see, the source code closely resembles the :class:`Custom` "
"examples in previous sections. We will break down the main differences "
"between them. ::"
msgstr "è¦‹ã¦ã‚ã‹ã‚‹ã‚ˆã†ã«ã€ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¯å‰ã®ç¯€ã® :class:`Custom` ã®æ™‚ã¨éå¸¸ã«ä¼¼ã¦ã„ã¾ã™ã€‚é•ã†éƒ¨åˆ†ã‚’ãã‚Œãã‚Œã‚’è¦‹ã¦ã„ãã¾ã™ã€‚ ::"

#: ../../extending/newtypes_tutorial.rst:822
msgid ""
"The primary difference for derived type objects is that the base type's "
"object structure must be the first value.  The base type will already "
"include the :c:func:`PyObject_HEAD` at the beginning of its structure."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:826
msgid ""
"When a Python object is a :class:`SubList` instance, its ``PyObject *`` "
"pointer can be safely cast to both ``PyListObject *`` and ``SubListObject "
"*``::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:838
msgid ""
"We see above how to call through to the :attr:`__init__` method of the base "
"type."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:841
msgid ""
"This pattern is important when writing a type with custom "
":c:member:`~PyTypeObject.tp_new` and :c:member:`~PyTypeObject.tp_dealloc` "
"members.  The :c:member:`~PyTypeObject.tp_new` handler should not actually "
"create the memory for the object with its "
":c:member:`~PyTypeObject.tp_alloc`, but let the base class handle it by "
"calling its own :c:member:`~PyTypeObject.tp_new`."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:847
msgid ""
"The :c:type:`PyTypeObject` struct supports a "
":c:member:`~PyTypeObject.tp_base` specifying the type's concrete base class."
"  Due to cross-platform compiler issues, you can't fill that field directly "
"with a reference to :c:type:`PyList_Type`; it should be done later in the "
"module initialization function::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:870
msgid ""
"Before calling :c:func:`PyType_Ready`, the type structure must have the "
":c:member:`~PyTypeObject.tp_base` slot filled in.  When we are deriving an "
"existing type, it is not necessary to fill out the "
":c:member:`~PyTypeObject.tp_alloc` slot with :c:func:`PyType_GenericNew` -- "
"the allocation function from the base type will be inherited."
msgstr ""
":c:func:`PyType_Read` ã‚’å‘¼ã¶å‰ã«ã€å‹ã®æ§‹é€ ä½“ã® :c:member:`~PyTypeObject.tp_base` "
"ã‚¹ãƒ­ãƒƒãƒˆã¯åŸ‹ã‚ã‚‰ã‚Œã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚æ—¢å­˜ã®å‹ã‚’ç¶™æ‰¿ã™ã‚‹éš›ã«ã¯ã€ :c:member:`~PyTypeObject.tp_alloc` ã‚¹ãƒ­ãƒƒãƒˆã‚’ "
":c:func:`PyType_GenericNew` ã§åŸ‹ã‚ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ -- åŸºåº•å‹ã®ã‚¢ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–¢æ•°ãŒç¶™æ‰¿ã•ã‚Œã¾ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:876
msgid ""
"After that, calling :c:func:`PyType_Ready` and adding the type object to the"
" module is the same as with the basic :class:`Custom` examples."
msgstr ""
"ã“ã®å¾Œã¯ã€ :c:func:`PyType_Ready` é–¢æ•°ã‚’å‘¼ã³ã€ã‚¿ã‚¤ãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¸è¿½åŠ ã™ã‚‹ã®ã¯ã€åŸºæœ¬çš„ãª "
":class:`Custom` ã®ä¾‹ã¨åŒã˜ã§ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:881
msgid "Footnotes"
msgstr "è„šæ³¨"

#: ../../extending/newtypes_tutorial.rst:882
msgid ""
"This is true when we know that the object is a basic type, like a string or "
"a float."
msgstr "ã“ã‚Œã¯ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ–‡å­—åˆ—ã‚„å®Ÿæ•°ãªã©ã®åŸºæœ¬ã‚¿ã‚¤ãƒ—ã§ã‚ã‚‹ã‚ˆã†ãªæ™‚ã«æˆã‚Šç«‹ã¡ã¾ã™ã€‚"

#: ../../extending/newtypes_tutorial.rst:885
msgid ""
"We relied on this in the :c:member:`~PyTypeObject.tp_dealloc` handler in "
"this example, because our type doesn't support garbage collection."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:888
msgid ""
"We now know that the first and last members are strings, so perhaps we could"
" be less careful about decrementing their reference counts, however, we "
"accept instances of string subclasses.  Even though deallocating normal "
"strings won't call back into our objects, we can't guarantee that "
"deallocating an instance of a string subclass won't call back into our "
"objects."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:894
msgid ""
"Also, even with our attributes restricted to strings instances, the user "
"could pass arbitrary :class:`str` subclasses and therefore still create "
"reference cycles."
msgstr ""
