# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-04-10 13:00+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../extending/extending.rst:8
msgid "Extending Python with C or C++"
msgstr "C ã‚„ C++ ã«ã‚ˆã‚‹ Python ã®æ‹¡å¼µ"

#: ../../extending/extending.rst:10
msgid ""
"It is quite easy to add new built-in modules to Python, if you know how to "
"program in C.  Such :dfn:`extension modules` can do two things that can't be"
" done directly in Python: they can implement new built-in object types, and "
"they can call C library functions and system calls."
msgstr ""
"C ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®æ›¸ãæ–¹ã‚’çŸ¥ã£ã¦ã„ã‚‹ãªã‚‰ã€Python ã«æ–°ãŸãªçµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¿½åŠ ã™ã‚‹ã®ã¯ãã‚ã‚ã¦ç°¡å˜ã§ã™ã€‚ã“ã®æ–°ãŸãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã€æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« "
"(:dfn:`extention module`) ã‚’ä½¿ã†ã¨ã€Python ãŒç›´æ¥è¡Œãˆãªã„äºŒã¤ã®ã“ã¨: æ–°ã—ã„çµ„ã¿è¾¼ã¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å®Ÿè£…ã€ãã—ã¦å…¨ã¦ã® "
"C ãƒ©ã‚¤ãƒ–ãƒ©ãƒªé–¢æ•°ã¨ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã«å¯¾ã™ã‚‹å‘¼ã³å‡ºã—ã€ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚"

#: ../../extending/extending.rst:15
msgid ""
"To support extensions, the Python API (Application Programmers Interface) "
"defines a set of functions, macros and variables that provide access to most"
" aspects of the Python run-time system.  The Python API is incorporated in a"
" C source file by including the header ``\"Python.h\"``."
msgstr ""
"æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãŸã‚ã€Python API (Application Programmer's Interface) "
"ã§ã¯ä¸€é€£ã®é–¢æ•°ã€ãƒã‚¯ãƒ­ãŠã‚ˆã³å¤‰æ•°ã‚’æä¾›ã—ã¦ã„ã¦ã€Python ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚·ã‚¹ãƒ†ãƒ ã®ã»ã¨ã‚“ã©ã®å´é¢ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹æ‰‹æ®µã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚ Python API"
" ã¯ã€ãƒ˜ãƒƒãƒ€ ``\"Python.h\"`` ã‚’ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ã—ã¦ C ã‚½ãƒ¼ã‚¹ã«å–ã‚Šè¾¼ã¿ã¾ã™ã€‚"

#: ../../extending/extending.rst:20
msgid ""
"The compilation of an extension module depends on its intended use as well "
"as on your system setup; details are given in later chapters."
msgstr "æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ–¹æ³•ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ç”¨é€”ã‚„ã‚·ã‚¹ãƒ†ãƒ ã®è¨­å®šæ–¹æ³•ã«ä¾å­˜ã—ã¾ã™; è©³ç´°ã¯å¾Œã®ç« ã§èª¬æ˜ã—ã¾ã™ã€‚"

#: ../../extending/extending.rst:25
msgid ""
"The C extension interface is specific to CPython, and extension modules do "
"not work on other Python implementations.  In many cases, it is possible to "
"avoid writing C extensions and preserve portability to other "
"implementations. For example, if your use case is calling C library "
"functions or system calls, you should consider using the :mod:`ctypes` "
"module or the `cffi <https://cffi.readthedocs.org>`_ library rather than "
"writing custom C code. These modules let you write Python code to interface "
"with C code and are more portable between implementations of Python than "
"writing and compiling a C extension module."
msgstr ""
"C æ‹¡å¼µã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã¯ CPython ã«å›ºæœ‰ã®ã‚‚ã®ã§ã‚ã‚Šã€ã“ã‚Œã«ã‚ˆã‚‹æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã»ã‹ã® Python å®Ÿè£…ã§ã¯å‹•ä½œã—ã¾ã›ã‚“ã€‚å¤šãã®å ´åˆã€C "
"æ‹¡å¼µã‚’æ›¸ãã“ã¨ã‚’é¿ã‘ã¦ã»ã‹ã® Python å®Ÿè£…ã®ãŸã‚ã«ç§»æ¤æ€§ã‚’ç¢ºä¿ã™ã‚‹ã“ã¨ã¯å¯èƒ½ã§ã™ã€‚ãŸã¨ãˆã°ã€ã‚ãªãŸãŒã—ãŸã„ã“ã¨ãŒ C "
"ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®é–¢æ•°ã‚„ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã‚ã‚‹å ´åˆã€ :mod:`ctypes` ã‚ã‚‹ã„ã¯ `cffi "
"<https://cffi.readthedocs.org>`_ ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®åˆ©ç”¨ã‚’æ¤œè¨ã™ã¹ãã§ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ C "
"ã‚³ãƒ¼ãƒ‰ã¨ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã—ã€C æ‹¡å¼µã‚’æ›¸ã„ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ã®ã«è¼ƒã¹ã¦ Python å®Ÿè£…é–“ã®ã‚ˆã‚Šé«˜ã„ç§»æ¤æ€§ã‚’ã‚‚ã£ãŸ Python "
"ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã‹ã›ã¦ãã‚Œã¾ã™ã€‚"

#: ../../extending/extending.rst:39
msgid "A Simple Example"
msgstr "ç°¡å˜ãªä¾‹"

#: ../../extending/extending.rst:41
msgid ""
"Let's create an extension module called ``spam`` (the favorite food of Monty"
" Python fans...) and let's say we want to create a Python interface to the C"
" library function :c:func:`system` [#]_. This function takes a null-"
"terminated character string as argument and returns an integer.  We want "
"this function to be callable from Python as follows:"
msgstr ""

#: ../../extending/extending.rst:52
msgid ""
"Begin by creating a file :file:`spammodule.c`.  (Historically, if a module "
"is called ``spam``, the C file containing its implementation is called "
":file:`spammodule.c`; if the module name is very long, like ``spammify``, "
"the module name can be just :file:`spammify.c`.)"
msgstr ""
"ã¾ãšã¯ :file:`spammodule.c` ã‚’ä½œæˆã™ã‚‹ã¨ã“ã‚ã‹ã‚‰å§‹ã‚ã¾ã™ã€‚ (ä¼çµ±ã¨ã—ã¦ã€ ``spam`` "
"ã¨ã„ã†åå‰ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½œæˆã™ã‚‹å ´åˆã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å®Ÿè£…ãŒå…¥ã£ãŸ C ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ :file:`spammodule.c` ã¨å‘¼ã¶ã“ã¨ã«ãªã£ã¦ã„ã¾ã™; "
"``spammify`` ã®ã‚ˆã†ã«é•·ã™ãã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã®å ´åˆã«ã¯ã€å˜ã« :file:`spammify.c` ã«ã‚‚ã§ãã¾ã™ã€‚)"

#: ../../extending/extending.rst:57
msgid "The first line of our file can be::"
msgstr "ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®æœ€åˆã®è¡Œã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¾ã™::"

#: ../../extending/extending.rst:61
msgid ""
"which pulls in the Python API (you can add a comment describing the purpose "
"of the module and a copyright notice if you like)."
msgstr "ã“ã‚Œã§ã€Python API ã‚’å–ã‚Šè¾¼ã¿ã¾ã™ (å¿…è¦ãªã‚‰ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ç”¨é€”ã«é–¢ã™ã‚‹èª¬æ˜ã‚„ã€è‘—ä½œæ¨©è¡¨ç¤ºã‚’è¿½åŠ ã—ã¾ã™)ã€‚"

#: ../../extending/extending.rst:66
msgid ""
"Since Python may define some pre-processor definitions which affect the "
"standard headers on some systems, you *must* include :file:`Python.h` before"
" any standard headers are included."
msgstr ""
"Python ã¯ã€ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã£ã¦ã¯æ¨™æº–ãƒ˜ãƒƒãƒ€ã®å®šç¾©ã«å½±éŸ¿ã™ã‚‹ã‚ˆã†ãªãƒ—ãƒªãƒ—ãƒ­ã‚»ãƒƒã‚µå®šç¾©ã‚’è¡Œã£ã¦ã„ã‚‹ã®ã§ã€ :file:`Python.h` "
"ã‚’ã„ãšã‚Œã®æ¨™æº–ãƒ˜ãƒƒãƒ€ã‚ˆã‚Šã‚‚å‰ã«ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ *ã›ã­ã°ãªã‚Šã¾ã›ã‚“* ã€‚"

#: ../../extending/extending.rst:70
msgid ""
"All user-visible symbols defined by :file:`Python.h` have a prefix of ``Py``"
" or ``PY``, except those defined in standard header files. For convenience, "
"and since they are used extensively by the Python interpreter, "
"``\"Python.h\"`` includes a few standard header files: ``<stdio.h>``, "
"``<string.h>``, ``<errno.h>``, and ``<stdlib.h>``.  If the latter header "
"file does not exist on your system, it declares the functions "
":c:func:`malloc`, :c:func:`free` and :c:func:`realloc` directly."
msgstr ""
":file:`Python.h` ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ãƒ¦ãƒ¼ã‚¶ã‹ã‚‰å¯è¦–ã®ã‚·ãƒ³ãƒœãƒ«ã¯ã€å…¨ã¦æ¥é ­è¾ ``Py`` ã¾ãŸã¯ ``PY`` "
"ãŒä»˜ã„ã¦ã„ã¾ã™ã€‚ãŸã ã—ã€æ¨™æº–ãƒ˜ãƒƒãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å†…ã®å®šç¾©ã¯é™¤ãã¾ã™ã€‚ç°¡å˜ã®ãŸã‚ã¨ã€Python å†…ã§åºƒç¯„ã«ä½¿ã†ã“ã¨ã«ãªã‚‹ã¨ã„ã†ç†ç”±ã‹ã‚‰ã€ "
"``\"Python.h\"`` ã¯ã„ãã¤ã‹ã®æ¨™æº–ãƒ˜ãƒƒãƒ€ãƒ•ã‚¡ã‚¤ãƒ«: ``<stdio.h>`` ã€ ``<string.h>`` ã€ "
"``<errno.h>`` ã€ãŠã‚ˆã³ ``<stdlib.h>`` ã‚’ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ã—ã¦ã„ã¾ã™ã€‚å¾Œè€…ã®ãƒ˜ãƒƒãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚·ã‚¹ãƒ†ãƒ ä¸Šã«ãªã‘ã‚Œã°ã€ "
"``\"Python.h\"`` ãŒé–¢æ•° :c:func:`malloc` ã€ :c:func:`free` ãŠã‚ˆã³ :c:func:`realloc`"
" ã‚’ç›´æ¥å®šç¾©ã—ã¾ã™ã€‚"

#: ../../extending/extending.rst:78
msgid ""
"The next thing we add to our module file is the C function that will be "
"called when the Python expression ``spam.system(string)`` is evaluated "
"(we'll see shortly how it ends up being called)::"
msgstr ""
"æ¬¡ã«ãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½åŠ ã™ã‚‹å†…å®¹ã¯ã€Python å¼ ``spam.system(string)`` ã‚’è©•ä¾¡ã™ã‚‹éš›ã«å‘¼ã³å‡ºã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ C é–¢æ•°ã§ã™ "
"(ã“ã®é–¢æ•°ã‚’æœ€çµ‚çš„ã«ã©ã®ã‚ˆã†ã«å‘¼ã³å‡ºã™ã‹ã¯ã€å¾Œã§ã™ãã‚ã‹ã‚Šã¾ã™)::"

#: ../../extending/extending.rst:94
msgid ""
"There is a straightforward translation from the argument list in Python (for"
" example, the single expression ``\"ls -l\"``) to the arguments passed to "
"the C function.  The C function always has two arguments, conventionally "
"named *self* and *args*."
msgstr ""
"ã“ã“ã§ã¯ã€Python ã®å¼•æ•°ãƒªã‚¹ãƒˆ (ä¾‹ãˆã°ã€å˜ä¸€ã®å¼ ``\"ls -l\"``) ã‹ã‚‰ C é–¢æ•°ã«æ¸¡ã™å¼•æ•°ã«ãã®ã¾ã¾å¤‰æ›ã—ã¦ã„ã¾ã™ã€‚ C "
"é–¢æ•°ã¯å¸¸ã«äºŒã¤ã®å¼•æ•°ã‚’æŒã¡ã€ä¾¿å®œçš„ã« *self* ãŠã‚ˆã³ *args* ã¨å‘¼ã°ã‚Œã¾ã™ã€‚"

#: ../../extending/extending.rst:99
msgid ""
"The *self* argument points to the module object for module-level functions; "
"for a method it would point to the object instance."
msgstr "*self* å¼•æ•°ã«ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«ã®é–¢æ•°ã§ã‚ã‚Œã°ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã€ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒæ¸¡ã•ã‚Œã¾ã™ã€‚"

#: ../../extending/extending.rst:102
msgid ""
"The *args* argument will be a pointer to a Python tuple object containing "
"the arguments.  Each item of the tuple corresponds to an argument in the "
"call's argument list.  The arguments are Python objects --- in order to do "
"anything with them in our C function we have to convert them to C values.  "
"The function :c:func:`PyArg_ParseTuple` in the Python API checks the "
"argument types and converts them to C values.  It uses a template string to "
"determine the required types of the arguments as well as the types of the C "
"variables into which to store the converted values.  More about this later."
msgstr ""
"*args* å¼•æ•°ã¯ã€å¼•æ•°ã®å…¥ã£ãŸ Python "
"ã‚¿ãƒ—ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã«ãªã‚Šã¾ã™ã€‚ã‚¿ãƒ—ãƒ«å†…ã®å„è¦ç´ ã¯ã€å‘¼ã³å‡ºã—ã®éš›ã®å¼•æ•°ãƒªã‚¹ãƒˆã«ãŠã‘ã‚‹å„å¼•æ•°ã«å¯¾å¿œã—ã¾ã™ã€‚å¼•æ•°ã¯ Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™"
" --- C é–¢æ•°ã§å¼•æ•°ã‚’ä½¿ã£ã¦ä½•ã‹ã‚’è¡Œã†ã«ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ C ã®å€¤ã«å¤‰æ›ã›ã­ã°ãªã‚Šã¾ã›ã‚“ã€‚Python API ã®é–¢æ•° "
":c:func:`PyArg_ParseTuple` ã¯å¼•æ•°ã®å‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã€C ã®å€¤ã«å¤‰æ›ã—ã¾ã™ã€‚ "
":c:func:`PyArg_ParseTuple` ã¯ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆæ–‡å­—åˆ—ã‚’ä½¿ã£ã¦ã€å¼•æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã¨ã€å¤‰æ›ã•ã‚ŒãŸå€¤ã‚’å…¥ã‚Œã‚‹ C "
"å¤‰æ•°ã®å‹ã‚’åˆ¤åˆ¥ã—ã¾ã™ã€‚ã“ã‚Œã«ã¤ã„ã¦ã¯å¾Œã§è©³ã—ãèª¬æ˜ã—ã¾ã™ã€‚"

#: ../../extending/extending.rst:111
msgid ""
":c:func:`PyArg_ParseTuple` returns true (nonzero) if all arguments have the "
"right type and its components have been stored in the variables whose "
"addresses are passed.  It returns false (zero) if an invalid argument list "
"was passed.  In the latter case it also raises an appropriate exception so "
"the calling function can return *NULL* immediately (as we saw in the "
"example)."
msgstr ""
":c:func:`PyArg_ParseTuple` ã¯ã€å…¨ã¦ã®å¼•æ•°ãŒæ­£ã—ã„å‹ã‚’æŒã£ã¦ã„ã¦ã€ã‚¢ãƒ‰ãƒ¬ã‚¹æ¸¡ã—ã•ã‚ŒãŸå„å¤‰æ•°ã«å„å¼•æ•°è¦ç´ ã‚’ä¿å­˜ã—ãŸã¨ãã«çœŸ "
"(éã‚¼ãƒ­) ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ä¸æ­£ãªå¼•æ•°ãƒªã‚¹ãƒˆã‚’æ¸¡ã™ã¨å½ (ã‚¼ãƒ­) ã‚’è¿”ã—ã¾ã™ã€‚å¾Œè€…ã®å ´åˆã€é–¢æ•°ã¯é©åˆ‡ãªä¾‹å¤–ã‚’é€å‡ºã™ã‚‹ã®ã§ã€å‘¼ã³å‡ºã—å´ã¯ "
"(ä¾‹ã«ã‚‚ã‚ã‚‹ã‚ˆã†ã«) ã™ãã« *NULL* ã‚’è¿”ã™ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚"

#: ../../extending/extending.rst:121
msgid "Intermezzo: Errors and Exceptions"
msgstr "å¹•é–“å°è©±: ã‚¨ãƒ©ãƒ¼ã¨ä¾‹å¤–"

#: ../../extending/extending.rst:123
msgid ""
"An important convention throughout the Python interpreter is the following: "
"when a function fails, it should set an exception condition and return an "
"error value (usually a *NULL* pointer).  Exceptions are stored in a static "
"global variable inside the interpreter; if this variable is *NULL* no "
"exception has occurred.  A second global variable stores the \"associated "
"value\" of the exception (the second argument to :keyword:`raise`).  A third"
" variable contains the stack traceback in case the error originated in "
"Python code.  These three variables are the C equivalents of the result in "
"Python of :meth:`sys.exc_info` (see the section on module :mod:`sys` in the "
"Python Library Reference).  It is important to know about them to understand"
" how errors are passed around."
msgstr ""
"Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿å…¨ä½“ã‚’é€šã—ã¦ã€ä¸€ã¤ã®é‡è¦ãªå–ã‚Šæ±ºã‚ãŒã‚ã‚Šã¾ã™: ãã‚Œã¯ã€é–¢æ•°ãŒå‡¦ç†ã«å¤±æ•—ã—ãŸå ´åˆã€ä¾‹å¤–çŠ¶æ…‹ã‚’ã‚»ãƒƒãƒˆã—ã¦ã€ã‚¨ãƒ©ãƒ¼ã‚’ç¤ºã™å€¤ "
"(é€šå¸¸ã¯ *NULL* ãƒã‚¤ãƒ³ã‚¿) ã‚’è¿”ã•ã­ã°ãªã‚‰ãªã„ã€ã¨ã„ã†ã“ã¨ã§ã™ã€‚ä¾‹å¤–ã¯ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿å†…ã®é™çš„ãªã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«ä¿å­˜ã•ã‚Œã¾ã™; ã“ã®å€¤ãŒ "
"*NULL* ã®å ´åˆã€ä¾‹å¤–ã¯ä½•ã‚‚èµ·ãã¦ã„ãªã„ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ç¬¬äºŒã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«ã¯ã€ä¾‹å¤–ã® \"ä»˜å±å€¤ (associated value)\" "
"(:keyword:`raise` æ–‡ã®ç¬¬äºŒå¼•æ•°) ãŒå…¥ã‚Šã¾ã™ã€‚ç¬¬ä¸‰ã®å€¤ã«ã¯ã€ã‚¨ãƒ©ãƒ¼ã®ç™ºç”ŸæºãŒ Python ã‚³ãƒ¼ãƒ‰å†…ã ã£ãŸå ´åˆã«ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯"
" (stack traceback) ãŒå…¥ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã®ä¸‰ã¤ã®å¤‰æ•°ã¯ã€ :meth:`sys.exc_info` ã® Python ã§ã®çµæœã¨ç­‰ä¾¡ãª "
"C ã®å¤‰æ•°ã§ã™ (Python ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã® :mod:`sys` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«é–¢ã™ã‚‹ç¯€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚) "
"ã‚¨ãƒ©ãƒ¼ãŒã©ã®ã‚ˆã†ã«å—ã‘æ¸¡ã•ã‚Œã‚‹ã‹ã‚’ç†è§£ã™ã‚‹ã«ã¯ã€ã“ã‚Œã‚‰ã®å¤‰æ•°ã«ã¤ã„ã¦ã‚ˆãçŸ¥ã£ã¦ãŠãã“ã¨ãŒé‡è¦ã§ã™ã€‚"

#: ../../extending/extending.rst:134
msgid ""
"The Python API defines a number of functions to set various types of "
"exceptions."
msgstr "Python API ã§ã¯ã€æ§˜ã€…ãªå‹ã®ä¾‹å¤–ã‚’ã‚»ãƒƒãƒˆã™ã‚‹ãŸã‚ã®é–¢æ•°ã‚’ã„ãã¤ã‹å®šç¾©ã—ã¦ã„ã¾ã™ã€‚"

#: ../../extending/extending.rst:136
msgid ""
"The most common one is :c:func:`PyErr_SetString`.  Its arguments are an "
"exception object and a C string.  The exception object is usually a "
"predefined object like :c:data:`PyExc_ZeroDivisionError`.  The C string "
"indicates the cause of the error and is converted to a Python string object "
"and stored as the \"associated value\" of the exception."
msgstr ""
"ã‚‚ã£ã¨ã‚‚ã‚ˆãç”¨ã„ã‚‰ã‚Œã‚‹ã®ã¯ :c:func:`PyErr_SetString` ã§ã™ã€‚å¼•æ•°ã¯ä¾‹å¤–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ C æ–‡å­—åˆ—ã§ã™ã€‚ä¾‹å¤–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯é€šå¸¸ã€"
" :c:data:`PyExc_ZeroDivisionError` ã®ã‚ˆã†ãªå®šç¾©æ¸ˆã¿ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ C æ–‡å­—åˆ—ã¯ã‚¨ãƒ©ãƒ¼ã®åŸå› ã‚’ç¤ºã—ã€Python"
" æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã•ã‚Œã¦ä¾‹å¤–ã® \"ä»˜å±å€¤\" ã«ä¿å­˜ã•ã‚Œã¾ã™ã€‚"

#: ../../extending/extending.rst:142
msgid ""
"Another useful function is :c:func:`PyErr_SetFromErrno`, which only takes an"
" exception argument and constructs the associated value by inspection of the"
" global variable :c:data:`errno`.  The most general function is "
":c:func:`PyErr_SetObject`, which takes two object arguments, the exception "
"and its associated value.  You don't need to :c:func:`Py_INCREF` the objects"
" passed to any of these functions."
msgstr ""
"ã‚‚ã†ä¸€ã¤æœ‰ç”¨ãªé–¢æ•°ã¨ã—ã¦ :c:func:`PyErr_SetFromErrno` ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®é–¢æ•°ã¯å¼•æ•°ã«ä¾‹å¤–ã ã‘ã‚’ã¨ã‚Šã€ä»˜å±å€¤ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° "
":c:data:`errno` ã‹ã‚‰æ§‹ç¯‰ã—ã¾ã™ã€‚ã‚‚ã£ã¨ã‚‚æ±ç”¨çš„ãªé–¢æ•°ã¯ :c:func:`PyErr_SetObject` "
"ã§ã€äºŒã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ä¾‹å¤–ã¨ä»˜å±å€¤ã‚’å¼•æ•°ã«ã¨ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰é–¢æ•°ã«æ¸¡ã™ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ :c:func:`Py_INCREF` ã‚’ä½¿ã†å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../extending/extending.rst:149
msgid ""
"You can test non-destructively whether an exception has been set with "
":c:func:`PyErr_Occurred`.  This returns the current exception object, or "
"*NULL* if no exception has occurred.  You normally don't need to call "
":c:func:`PyErr_Occurred` to see whether an error occurred in a function "
"call, since you should be able to tell from the return value."
msgstr ""
"ä¾‹å¤–ãŒã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã¯ã€ :c:func:`PyErr_Occurred` "
"ã‚’ä½¿ã£ã¦éç ´å£Šçš„ã«èª¿ã¹ã‚‰ã‚Œã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ç¾åœ¨ã®ä¾‹å¤–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ä¾‹å¤–ãŒç™ºç”Ÿã—ã¦ã„ãªã„å ´åˆã«ã¯ *NULL* "
"ã‚’è¿”ã—ã¾ã™ã€‚é€šå¸¸ã¯ã€é–¢æ•°ã®æˆ»ã‚Šå€¤ã‹ã‚‰ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸã‹ã‚’åˆ¤åˆ¥ã§ãã‚‹ã¯ãšãªã®ã§ã€ :c:func:`PyErr_Occurred` "
"ã‚’å‘¼ã³å‡ºã™å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../extending/extending.rst:155
msgid ""
"When a function *f* that calls another function *g* detects that the latter "
"fails, *f* should itself return an error value (usually *NULL* or ``-1``).  "
"It should *not* call one of the :c:func:`PyErr_\\*` functions --- one has "
"already been called by *g*. *f*'s caller is then supposed to also return an "
"error indication to *its* caller, again *without* calling "
":c:func:`PyErr_\\*`, and so on --- the most detailed cause of the error was "
"already reported by the function that first detected it.  Once the error "
"reaches the Python interpreter's main loop, this aborts the currently "
"executing Python code and tries to find an exception handler specified by "
"the Python programmer."
msgstr ""
"é–¢æ•° *g* ã‚’å‘¼ã³å‡ºã™ *f* ãŒã€å‰è€…ã®é–¢æ•°ã®å‘¼ã³å‡ºã—ã«å¤±æ•—ã—ãŸã“ã¨ã‚’æ¤œå‡ºã™ã‚‹ã¨ã€ *f* è‡ªä½“ã¯ã‚¨ãƒ©ãƒ¼å€¤ (å¤§æŠµã¯ *NULL* ã‚„ "
"``-1``) ã‚’è¿”ã•ã­ã°ãªã‚Šã¾ã›ã‚“ã€‚ã—ã‹ã—ã€ :c:func:`PyErr_\\*` é–¢æ•°ç¾¤ã®ã„ãšã‚Œã‹ã‚’å‘¼ã³å‡ºã™å¿…è¦ã¯ *ã‚ã‚Šã¾ã›ã‚“* --- "
"ãªãœãªã‚‰ã€ *g* ãŒã™ã§ã«å‘¼ã³å‡ºã—ã¦ã„ã‚‹ã‹ã‚‰ã§ã™ã€‚æ¬¡ã„ã§ *f* ã‚’å‘¼ã³å‡ºã—ãŸã‚³ãƒ¼ãƒ‰ã‚‚ã‚¨ãƒ©ãƒ¼ã‚’ç¤ºã™å€¤ã‚’ *è‡ªã‚‰ã‚’å‘¼ã³å‡ºã—ãŸã‚³ãƒ¼ãƒ‰* "
"ã«è¿”ã™ã“ã¨ã«ãªã‚Šã¾ã™ãŒã€åŒæ§˜ã« :c:func:`PyErr_\\*` ã¯ *å‘¼ã³å‡ºã—ã¾ã›ã‚“* ã€‚ä»¥ä¸‹åŒæ§˜ã«ç¶šãã¾ã™ --- "
"ã‚¨ãƒ©ãƒ¼ã®æœ€ã‚‚è©³ã—ã„åŸå› ã¯ã€æœ€åˆã«ã‚¨ãƒ©ãƒ¼ã‚’æ¤œå‡ºã—ãŸé–¢æ•°ãŒã™ã§ã«å ±å‘Šã—ã¦ã„ã‚‹ã‹ã‚‰ã§ã™ã€‚ã‚¨ãƒ©ãƒ¼ãŒ Python "
"ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—ã«åˆ°é”ã™ã‚‹ã¨ã€ç¾åœ¨å®Ÿè¡Œä¸­ã® Python ã‚³ãƒ¼ãƒ‰ã¯ä¸€æ™‚åœæ­¢ã—ã€ Python "
"ãƒ—ãƒ­ã‚°ãƒ©ãƒãŒæŒ‡å®šã—ãŸä¾‹å¤–ãƒãƒ³ãƒ‰ãƒ©ã‚’æ¢ã—å‡ºãã†ã¨ã—ã¾ã™ã€‚"

#: ../../extending/extending.rst:165
msgid ""
"(There are situations where a module can actually give a more detailed error"
" message by calling another :c:func:`PyErr_\\*` function, and in such cases "
"it is fine to do so.  As a general rule, however, this is not necessary, and"
" can cause information about the cause of the error to be lost: most "
"operations can fail for a variety of reasons.)"
msgstr ""
"(ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ :c:func:`PyErr_\\*` "
"é–¢æ•°ã‚’ã‚‚ã†ä¸€åº¦å‘¼ã³å‡ºã—ã¦ã€ã‚ˆã‚Šè©³ç´°ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æä¾›ã™ã‚‹ã‚ˆã†ãªçŠ¶æ³ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ã‚ˆã†ãªçŠ¶æ³ã§ã¯ãã†ã™ã¹ãã§ã™ã€‚ã¨ã¯ã„ãˆã€ä¸€èˆ¬çš„ãªè¦å‰‡ã¨ã—ã¦ã¯ã€ "
":c:func:`PyErr_\\*` ã‚’ä½•åº¦ã‚‚å‘¼ã³å‡ºã™å¿…è¦ã¯ãªãã€ã¨ã‚‚ã™ã‚Œã°ã‚¨ãƒ©ãƒ¼ã®åŸå› ã«é–¢ã™ã‚‹æƒ…å ±ã‚’å¤±ã†çµæœã«ãªã‚ŠãŒã¡ã§ã™: "
"ã“ã‚Œã«ã‚ˆã‚Šã€ã»ã¨ã‚“ã©ã®æ“ä½œãŒæ§˜ã€…ãªç†ç”±ã‹ã‚‰å¤±æ•—ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“)"

#: ../../extending/extending.rst:171
msgid ""
"To ignore an exception set by a function call that failed, the exception "
"condition must be cleared explicitly by calling :c:func:`PyErr_Clear`.  The "
"only time C code should call :c:func:`PyErr_Clear` is if it doesn't want to "
"pass the error on to the interpreter but wants to handle it completely by "
"itself (possibly by trying something else, or pretending nothing went "
"wrong)."
msgstr ""
"ã‚ã‚‹é–¢æ•°å‘¼ã³å‡ºã—ã§ã®å‡¦ç†ã®å¤±æ•—ã«ã‚ˆã£ã¦ã‚»ãƒƒãƒˆã•ã‚ŒãŸä¾‹å¤–ã‚’ç„¡è¦–ã™ã‚‹ã«ã¯ã€ :c:func:`PyErr_Clear` "
"ã‚’å‘¼ã³å‡ºã—ã¦ä¾‹å¤–çŠ¶æ…‹ã‚’æ˜ç¤ºçš„ã«æ¶ˆå»ã—ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ã‚¨ãƒ©ãƒ¼ã‚’ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ã¯æ¸¡ã—ãŸããªãã€è‡ªå‰ã§ "
"(ä½•ã‹ä»–ã®ä½œæ¥­ã‚’è¡Œã£ãŸã‚Šã€ä½•ã‚‚èµ·ã“ã‚‰ãªã‹ã£ãŸã‹ã®ã‚ˆã†ã«è¦‹ã›ã‹ã‘ã‚‹ã‚ˆã†ãª) ã‚¨ãƒ©ãƒ¼å‡¦ç†ã‚’å®Œå…¨ã«è¡Œã†å ´åˆã«ã®ã¿ã€ :c:func:`PyErr_Clear`"
" ã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«ã™ã¹ãã§ã™ã€‚"

#: ../../extending/extending.rst:177
msgid ""
"Every failing :c:func:`malloc` call must be turned into an exception --- the"
" direct caller of :c:func:`malloc` (or :c:func:`realloc`) must call "
":c:func:`PyErr_NoMemory` and return a failure indicator itself.  All the "
"object-creating functions (for example, :c:func:`PyLong_FromLong`) already "
"do this, so this note is only relevant to those who call :c:func:`malloc` "
"directly."
msgstr ""
":c:func:`malloc` ã®å‘¼ã³å‡ºã—å¤±æ•—ã¯ã€å¸¸ã«ä¾‹å¤–ã«ã—ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ --- :c:func:`malloc` (ã¾ãŸã¯ "
":c:func:`realloc`) ã‚’ç›´æ¥å‘¼ã³å‡ºã—ã¦ã„ã‚‹ã‚³ãƒ¼ãƒ‰ã¯ã€ :c:func:`PyErr_NoMemory` "
"ã‚’å‘¼ã³å‡ºã—ã¦ã€å¤±æ•—ã‚’ç¤ºã™å€¤ã‚’è¿”ã•ã­ã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã™ã‚‹å…¨ã¦ã®é–¢æ•° (ä¾‹ãˆã° :c:func:`PyLong_FromLong`) ã¯ "
":c:func:`PyErr_NoMemory` ã®å‘¼ã³å‡ºã—ã‚’æ¸ˆã¾ã›ã¦ã—ã¾ã†ã®ã§ã€ã“ã®è¦å‰‡ãŒé–¢ä¿‚ã™ã‚‹ã®ã¯ç›´æ¥ :c:func:`malloc` "
"ã‚’å‘¼ã³å‡ºã™ã‚³ãƒ¼ãƒ‰ã ã‘ã§ã™ã€‚"

#: ../../extending/extending.rst:183
msgid ""
"Also note that, with the important exception of :c:func:`PyArg_ParseTuple` "
"and friends, functions that return an integer status usually return a "
"positive value or zero for success and ``-1`` for failure, like Unix system "
"calls."
msgstr ""
"ã¾ãŸã€ :c:func:`PyArg_ParseTuple` ã¨ã„ã†é‡è¦ãªä¾‹å¤–ã‚’é™¤ã„ã¦ã€æ•´æ•°ã®çŠ¶æ…‹ã‚³ãƒ¼ãƒ‰ã‚’è¿”ã™é–¢æ•°ã¯ãŸã„ã¦ã„ã€Unix "
"ã®ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã¨åŒã˜ãã€å‡¦ç†ãŒæˆåŠŸã—ãŸéš›ã«ã¯ã‚¼ãƒ­ã¾ãŸã¯æ­£ã®å€¤ã‚’è¿”ã—ã€å¤±æ•—ã—ãŸå ´åˆã«ã¯ ``-1`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../extending/extending.rst:187
msgid ""
"Finally, be careful to clean up garbage (by making :c:func:`Py_XDECREF` or "
":c:func:`Py_DECREF` calls for objects you have already created) when you "
"return an error indicator!"
msgstr ""
"æœ€å¾Œã«ã€ã‚¨ãƒ©ãƒ¼æ¨™ç¤ºå€¤ã‚’è¿”ã™éš›ã«ã€(ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹ã¾ã§ã«æ—¢ã«ç”Ÿæˆã—ã¦ã—ã¾ã£ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ :c:func:`Py_XDECREF` ã‚„ "
":c:func:`Py_DECREF` ã‚’å‘¼ã³å‡ºã—ã¦) ã”ã¿å‡¦ç†ã‚’æ³¨æ„æ·±ãè¡Œã£ã¦ãã ã•ã„!"

#: ../../extending/extending.rst:191
msgid ""
"The choice of which exception to raise is entirely yours.  There are "
"predeclared C objects corresponding to all built-in Python exceptions, such "
"as :c:data:`PyExc_ZeroDivisionError`, which you can use directly. Of course,"
" you should choose exceptions wisely --- don't use :c:data:`PyExc_TypeError`"
" to mean that a file couldn't be opened (that should probably be "
":c:data:`PyExc_IOError`). If something's wrong with the argument list, the "
":c:func:`PyArg_ParseTuple` function usually raises "
":c:data:`PyExc_TypeError`.  If you have an argument whose value must be in a"
" particular range or must satisfy other conditions, "
":c:data:`PyExc_ValueError` is appropriate."
msgstr ""
"ã©ã®ä¾‹å¤–ã‚’è¿”ã™ã‹ã®é¸æŠã¯ã€ãƒ¦ãƒ¼ã‚¶ã«å®Œå…¨ã«ã‚†ã ã­ã‚‰ã‚Œã¾ã™ã€‚ :c:data:`PyExc_ZeroDivisionError` ã®ã‚ˆã†ã«ã€å…¨ã¦ã®çµ„ã¿è¾¼ã¿ã®"
" Python ä¾‹å¤–ã«ã¯å¯¾å¿œã™ã‚‹å®£è¨€æ¸ˆã¿ã® C ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚ã‚Šã€ç›´æ¥åˆ©ç”¨ã§ãã¾ã™ã€‚ã‚‚ã¡ã‚ã‚“ã€ä¾‹å¤–ã®é¸æŠã¯è³¢ãè¡Œã‚ã­ã°ãªã‚Šã¾ã›ã‚“ --- "
"ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ãªã‹ã£ãŸã“ã¨ã‚’è¡¨ã™ã®ã« :c:data:`PyExc_TypeError` ã‚’ä½¿ã£ãŸã‚Šã¯ã—ãªã„ã§ãã ã•ã„ (ã“ã®å ´åˆã¯ãŠãã‚‰ã "
":c:data:`PyExc_IOError` ã®æ–¹ã«ã™ã¹ãã§ã—ã‚‡ã†)ã€‚å¼•æ•°ãƒªã‚¹ãƒˆã«å•é¡ŒãŒã‚ã‚‹å ´åˆã«ã¯ã€ "
":c:func:`PyArg_ParseTuple` ã¯ãŸã„ã¦ã„ :c:data:`PyExc_TypeError` "
"ã‚’é€å‡ºã—ã¾ã™ã€‚å¼•æ•°ã®å€¤ãŒç‰¹å®šã®ç¯„å›²ã‚’è¶…ãˆã¦ã„ãŸã‚Šã€ãã®ä»–ã®æº€ãŸã™ã¹ãæ¡ä»¶ã‚’æº€ãŸã•ãªã‹ã£ãŸå ´åˆã«ã¯ã€ :c:data:`PyExc_ValueError`"
" ãŒé©åˆ‡ã§ã™ã€‚"

#: ../../extending/extending.rst:201
msgid ""
"You can also define a new exception that is unique to your module. For this,"
" you usually declare a static object variable at the beginning of your "
"file::"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å›ºæœ‰ã®æ–°ãŸãªä¾‹å¤–ã‚‚å®šç¾©ã§ãã¾ã™ã€‚å®šç¾©ã™ã‚‹ã«ã¯ã€é€šå¸¸ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã®å…ˆé ­éƒ¨åˆ†ã«é™çš„ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå¤‰æ•°ã®å®£è¨€ã‚’è¡Œã„ã¾ã™::"

#: ../../extending/extending.rst:206
msgid ""
"and initialize it in your module's initialization function "
"(:c:func:`PyInit_spam`) with an exception object (leaving out the error "
"checking for now)::"
msgstr ""
"ãã—ã¦ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åˆæœŸåŒ–é–¢æ•° (:c:func:`PyInit_spam`) ã®ä¸­ã§ã€ä¾‹å¤–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ã£ã¦åˆæœŸåŒ–ã—ã¾ã™ "
"(ã“ã“ã§ã¯ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯ã‚’çœç•¥ã—ã¦ã„ã¾ã™)::"

#: ../../extending/extending.rst:224
msgid ""
"Note that the Python name for the exception object is :exc:`spam.error`.  "
"The :c:func:`PyErr_NewException` function may create a class with the base "
"class being :exc:`Exception` (unless another class is passed in instead of "
"*NULL*), described in :ref:`bltin-exceptions`."
msgstr ""
"Python ãƒ¬ãƒ™ãƒ«ã§ã®ä¾‹å¤–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åå‰ã¯ :exc:`spam.error` ã«ãªã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ "
":c:func:`PyErr_NewException` é–¢æ•°ã¯ã€ :ref:`bltin-exceptions` ã§è¿°ã¹ã‚‰ã‚Œã¦ã„ã‚‹ "
":exc:`Exception` ã‚¯ãƒ©ã‚¹ã‚’åŸºåº•ã‚¯ãƒ©ã‚¹ã«æŒã¤ä¾‹å¤–ã‚¯ãƒ©ã‚¹ã‚‚ä½œæˆã§ãã¾ã™ (*NULL* ã®ä»£ã‚ã‚Šã«ä»–ã®ã‚¯ãƒ©ã‚¹ã‚’æ¸¡ã—ãŸå ´åˆã¯åˆ¥ã§ã™)ã€‚"

#: ../../extending/extending.rst:229
msgid ""
"Note also that the :c:data:`SpamError` variable retains a reference to the "
"newly created exception class; this is intentional!  Since the exception "
"could be removed from the module by external code, an owned reference to the"
" class is needed to ensure that it will not be discarded, causing "
":c:data:`SpamError` to become a dangling pointer. Should it become a "
"dangling pointer, C code which raises the exception could cause a core dump "
"or other unintended side effects."
msgstr ""
":c:data:`SpamError` å¤‰æ•°ã¯ã€æ–°ãŸã«ç”Ÿæˆã•ã‚ŒãŸä¾‹å¤–ã‚¯ãƒ©ã‚¹ã¸ã®å‚ç…§ã‚’ç¶­æŒã™ã‚‹ã“ã¨ã«ã‚‚æ³¨æ„ã—ã¦ãã ã•ã„; ã“ã‚Œã¯æ„å›³çš„ãªä»•æ§˜ã§ã™! "
"å¤–éƒ¨ã®ã‚³ãƒ¼ãƒ‰ãŒä¾‹å¤–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰é™¤å»ã§ãã‚‹ãŸã‚ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰æ–°ãŸã«ä½œæˆã—ãŸä¾‹å¤–ã‚¯ãƒ©ã‚¹ãŒè¦‹ãˆãªããªã‚Šã€ "
":c:data:`SpamError` ãŒã¶ã‚‰ä¸‹ãŒã‚Šãƒã‚¤ãƒ³ã‚¿ (dangling pointer) "
"ã«ãªã£ã¦ã—ã¾ã‚ãªã„ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ã€ã‚¯ãƒ©ã‚¹ã«å¯¾ã™ã‚‹å‚ç…§ã‚’æ‰€æœ‰ã—ã¦ãŠã‹ã­ã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚‚ã— :c:data:`SpamError` "
"ãŒã¶ã‚‰ä¸‹ãŒã‚Šãƒã‚¤ãƒ³ã‚¿ã«ãªã£ã¦ã—ã¾ã†ã¨ã€ C ã‚³ãƒ¼ãƒ‰ãŒä¾‹å¤–ã‚’é€å‡ºã—ã‚ˆã†ã¨ã—ãŸã¨ãã«ã‚³ã‚¢ãƒ€ãƒ³ãƒ—ã‚„æ„å›³ã—ãªã„å‰¯ä½œç”¨ã‚’å¼•ãèµ·ã“ã™ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../extending/extending.rst:236
msgid ""
"We discuss the use of ``PyMODINIT_FUNC`` as a function return type later in "
"this sample."
msgstr "ã“ã®ä¾‹ã«ã‚ã‚‹ã€é–¢æ•°ã®æˆ»ã‚Šå€¤å‹ã« ``PyMODINIT_FUNC`` ã‚’ä½¿ã†æ–¹æ³•ã«ã¤ã„ã¦ã¯å¾Œã§è­°è«–ã—ã¾ã™ã€‚"

#: ../../extending/extending.rst:239
msgid ""
"The :exc:`spam.error` exception can be raised in your extension module using"
" a call to :c:func:`PyErr_SetString` as shown below::"
msgstr ""
":c:func:`PyErr_SetString` ã‚’æ¬¡ã®ã‚ˆã†ã«å‘¼ã³å‡ºã™ã¨ã€æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ä¾‹å¤– :exc:`spam.error` "
"ã‚’é€å‡ºã™ã‚‹ã“ã¨ãŒã§ãã¾ã™::"

#: ../../extending/extending.rst:262
msgid "Back to the Example"
msgstr "ä¾‹ã«æˆ»ã‚‹"

#: ../../extending/extending.rst:264
msgid ""
"Going back to our example function, you should now be able to understand "
"this statement::"
msgstr "å…ˆã»ã©ã®é–¢æ•°ã®ä¾‹ã«æˆ»ã‚‹ã¨ã€ä»Šåº¦ã¯ä»¥ä¸‹ã®å®Ÿè¡Œæ–‡ã‚’ç†è§£ã§ãã‚‹ã¯ãšã§ã™::"

#: ../../extending/extending.rst:270
msgid ""
"It returns *NULL* (the error indicator for functions returning object "
"pointers) if an error is detected in the argument list, relying on the "
"exception set by :c:func:`PyArg_ParseTuple`.  Otherwise the string value of "
"the argument has been copied to the local variable :c:data:`command`.  This "
"is a pointer assignment and you are not supposed to modify the string to "
"which it points (so in Standard C, the variable :c:data:`command` should "
"properly be declared as ``const char *command``)."
msgstr ""
"ã“ã®å®Ÿè¡Œæ–‡ã¯ã€ :c:func:`PyArg_ParseTuple` ãŒã‚»ãƒƒãƒˆã™ã‚‹ä¾‹å¤–ã«ã‚ˆã£ã¦ã€å¼•æ•°ãƒªã‚¹ãƒˆã«ä½•ã‚‰ã‹ã®ã‚¨ãƒ©ãƒ¼ãŒç”Ÿã˜ãŸã¨ãã« *NULL* "
"(ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã™ã‚¿ã‚¤ãƒ—ã®é–¢æ•°ã«ãŠã‘ã‚‹ã‚¨ãƒ©ãƒ¼æ¨™ç¤ºå€¤) ã‚’è¿”ã—ã¾ã™ã€‚ã‚¨ãƒ©ãƒ¼ã§ãªã‘ã‚Œã°ã€å¼•æ•°ã¨ã—ã¦ä¸ãˆãŸæ–‡å­—åˆ—å€¤ã¯ãƒ­ãƒ¼ã‚«ãƒ«ãªå¤‰æ•° "
":c:data:`command` "
"ã«ã‚³ãƒ”ãƒ¼ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®æ“ä½œã¯ãƒã‚¤ãƒ³ã‚¿ä»£å…¥ã§ã‚ã‚Šã€ãƒã‚¤ãƒ³ã‚¿ãŒæŒ‡ã—ã¦ã„ã‚‹æ–‡å­—åˆ—ã«å¯¾ã—ã¦å¤‰æ›´ãŒè¡Œã‚ã‚Œã‚‹ã¨ã¯æƒ³å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ (å¾“ã£ã¦ã€æ¨™æº– C "
"ã§ã¯ã€å¤‰æ•° :c:data:`command` ã¯ ``const char* command`` ã¨ã—ã¦é©åˆ‡ã«å®šç¾©ã›ã­ã°ãªã‚Šã¾ã›ã‚“)ã€‚"

#: ../../extending/extending.rst:278
msgid ""
"The next statement is a call to the Unix function :c:func:`system`, passing "
"it the string we just got from :c:func:`PyArg_ParseTuple`::"
msgstr ""
"æ¬¡ã®æ–‡ã§ã¯ã€ :c:func:`PyArg_ParseTuple` ã§å¾—ãŸæ–‡å­—åˆ—ã‚’æ¸¡ã—ã¦ Unix é–¢æ•° :c:func:`system` "
"ã‚’å‘¼ã³å‡ºã—ã¦ã„ã¾ã™::"

#: ../../extending/extending.rst:283
msgid ""
"Our :func:`spam.system` function must return the value of :c:data:`sts` as a"
" Python object.  This is done using the function :c:func:`PyLong_FromLong`. "
"::"
msgstr ""
":func:`spam.system` ã¯ :c:data:`sts` ã‚’ Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦è¿”ã•ã­ã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã«ã¯ã€ "
":c:func:`PyLong_FromLong` ã‚’ä½¿ã„ã¾ã™ã€‚ ::"

#: ../../extending/extending.rst:288
msgid ""
"In this case, it will return an integer object.  (Yes, even integers are "
"objects on the heap in Python!)"
msgstr ""
"ä¸Šã®å ´åˆã§ã¯ã€ :c:func:`Py_BuildValue` ã¯æ•´æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚(ãã†ã€æ•´æ•°ã§ã™ã‚‰ã€ Python "
"ã«ãŠã„ã¦ã¯ãƒ’ãƒ¼ãƒ—ä¸Šã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãªã®ã§ã™! )"

#: ../../extending/extending.rst:291
msgid ""
"If you have a C function that returns no useful argument (a function "
"returning :c:type:`void`), the corresponding Python function must return "
"``None``.   You need this idiom to do so (which is implemented by the "
":c:macro:`Py_RETURN_NONE` macro)::"
msgstr ""
"ä½•ã‚‰æœ‰ç”¨ãªå€¤ã‚’è¿”ã•ãªã„é–¢æ•° (:c:type:`void` ã‚’è¿”ã™é–¢æ•°) ã«å¯¾å¿œã™ã‚‹ Python ã®é–¢æ•°ã¯ ``None`` "
"ã‚’è¿”ã•ã­ã°ãªã‚Šã¾ã›ã‚“ã€‚é–¢æ•°ã« ``None`` ã‚’è¿”ã•ã›ã‚‹ã«ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ãªæ…£ç”¨å¥ã‚’ä½¿ã„ã¾ã™ (ã“ã®æ…£ç”¨å¥ã¯ "
":c:macro:`Py_RETURN_NONE` ãƒã‚¯ãƒ­ã«å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™)::"

#: ../../extending/extending.rst:299
msgid ""
":c:data:`Py_None` is the C name for the special Python object ``None``.  It "
"is a genuine Python object rather than a *NULL* pointer, which means "
"\"error\" in most contexts, as we have seen."
msgstr ""
":c:data:`Py_None` ã¯ç‰¹æ®Šãª Pyhton ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹ ``None`` ã«å¯¾å¿œã™ã‚‹ C "
"ã§ã®åå‰ã§ã™ã€‚ã“ã‚Œã¾ã§è¦‹ã¦ããŸã‚ˆã†ã«ã»ã¨ã‚“ã©ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ \"ã‚¨ãƒ©ãƒ¼\" ã‚’æ„å‘³ã™ã‚‹ *NULL* ãƒã‚¤ãƒ³ã‚¿ã¨ã¯é•ã„ã€ ``None`` ã¯ç´”ç²‹ãª "
"Python ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚"

#: ../../extending/extending.rst:307
msgid "The Module's Method Table and Initialization Function"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ¡ã‚½ãƒƒãƒ‰ãƒ†ãƒ¼ãƒ–ãƒ«ã¨åˆæœŸåŒ–é–¢æ•°"

#: ../../extending/extending.rst:309
msgid ""
"I promised to show how :c:func:`spam_system` is called from Python programs."
" First, we need to list its name and address in a \"method table\"::"
msgstr ""
"ã•ã¦ã€å‰ã«ç´„æŸã—ãŸã‚ˆã†ã«ã€ :c:func:`spam_system` ã‚’ Python "
"ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‹ã‚‰ã©ã†ã‚„ã£ã¦å‘¼ã³å‡ºã™ã‹ã‚’ã“ã‚Œã‹ã‚‰ç¤ºã—ã¾ã™ã€‚ã¾ãšã¯ã€é–¢æ•°åã¨ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ \"ãƒ¡ã‚½ãƒƒãƒ‰ãƒ†ãƒ¼ãƒ–ãƒ« (method table)\" "
"ã«åˆ—æŒ™ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™::"

#: ../../extending/extending.rst:320
msgid ""
"Note the third entry (``METH_VARARGS``).  This is a flag telling the "
"interpreter the calling convention to be used for the C function.  It should"
" normally always be ``METH_VARARGS`` or ``METH_VARARGS | METH_KEYWORDS``; a "
"value of ``0`` means that an obsolete variant of :c:func:`PyArg_ParseTuple` "
"is used."
msgstr ""
"ãƒªã‚¹ãƒˆè¦ç´ ã®ä¸‰ã¤ç›®ã®ã‚¨ãƒ³ãƒˆãƒª (``METH_VARARGS``) ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã“ã®ã‚¨ãƒ³ãƒˆãƒªã¯ã€C "
"é–¢æ•°ãŒä½¿ã†å‘¼ã³å‡ºã—è¦ç´„ã‚’ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«æ•™ãˆã‚‹ãŸã‚ã®ãƒ•ãƒ©ã‚°ã§ã™ã€‚é€šå¸¸ã“ã®å€¤ã¯ ``METH_VARARGS`` ã‹ ``METH_VARARGS | "
"METH_KEYWORDS`` ã®ã¯ãšã§ã™; ``0`` ã¯æ—§å¼ã® :c:func:`PyArg_ParseTuple` "
"ã®å¤‰åŒ–å½¢ãŒä½¿ã‚ã‚Œã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚"

#: ../../extending/extending.rst:325
msgid ""
"When using only ``METH_VARARGS``, the function should expect the Python-"
"level parameters to be passed in as a tuple acceptable for parsing via "
":c:func:`PyArg_ParseTuple`; more information on this function is provided "
"below."
msgstr ""
"``METH_VARARGS`` ã ã‘ã‚’ä½¿ã†å ´åˆã€C é–¢æ•°ã¯ã€Python ãƒ¬ãƒ™ãƒ«ã§ã®å¼•æ•°ãŒ :c:func:`PyArg_ParseTuple` "
"ãŒå—ç†ã§ãã‚‹ã‚¿ãƒ—ãƒ«ã®å½¢å¼ã§æ¸¡ã•ã‚Œã‚‹ã‚‚ã®ã¨æƒ³å®šã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“; ã“ã®é–¢æ•°ã«ã¤ã„ã¦ã®è©³ç´°ã¯ä¸‹ã§èª¬æ˜ã—ã¾ã™ã€‚"

#: ../../extending/extending.rst:329
msgid ""
"The :const:`METH_KEYWORDS` bit may be set in the third field if keyword "
"arguments should be passed to the function.  In this case, the C function "
"should accept a third ``PyObject *`` parameter which will be a dictionary of"
" keywords. Use :c:func:`PyArg_ParseTupleAndKeywords` to parse the arguments "
"to such a function."
msgstr ""
"é–¢æ•°ã«ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ãŒæ¸¡ã•ã‚Œã‚‹ã“ã¨ã«ãªã£ã¦ã„ã‚‹ã®ãªã‚‰ã€ç¬¬ä¸‰ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã« :const:`METH_KEYWORDS` "
"ãƒ“ãƒƒãƒˆã‚’ã‚»ãƒƒãƒˆã§ãã¾ã™ã€‚ã“ã®å ´åˆã€C é–¢æ•°ã¯ç¬¬ä¸‰å¼•æ•°ã« ``PyObject *`` "
"ã‚’å—ç†ã™ã‚‹ã‚ˆã†ã«ã›ã­ã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã®è¾æ›¸ã«ãªã‚Šã¾ã™ã€‚ã“ã†ã—ãŸé–¢æ•°ã§å¼•æ•°ã‚’è§£é‡ˆã™ã‚‹ã«ã¯ã€ "
":c:func:`PyArg_ParseTupleAndKeywords` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚"

#: ../../extending/extending.rst:335
msgid ""
"The method table must be referenced in the module definition structure::"
msgstr "ãƒ¡ã‚½ãƒƒãƒ‰ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®šç¾©ã®æ§‹é€ ä½“ã‹ã‚‰å‚ç…§ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“::"

#: ../../extending/extending.rst:346
msgid ""
"This structure, in turn, must be passed to the interpreter in the module's "
"initialization function.  The initialization function must be named "
":c:func:`PyInit_name`, where *name* is the name of the module, and should be"
" the only non-\\ ``static`` item defined in the module file::"
msgstr ""
"åŒæ§˜ã«ã€ã“ã®æ§‹é€ ä½“ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åˆæœŸåŒ–é–¢æ•°å†…ã§ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«æ¸¡ã•ã­ã°ãªã‚Šã¾ã›ã‚“ã€‚åˆæœŸåŒ–é–¢æ•°ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ã‚’ *name* ã¨ã—ãŸã¨ãã« "
":c:func:`PyInit_name` ã¨ã„ã†åå‰ã§ãªã‘ã‚Œã°ãªã‚‰ãšã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«å†…ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã®ã†ã¡ã€å”¯ä¸€ã®é ``static`` "
"è¦ç´ ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“::"

#: ../../extending/extending.rst:357
msgid ""
"Note that PyMODINIT_FUNC declares the function as ``PyObject *`` return "
"type, declares any special linkage declarations required by the platform, "
"and for C++ declares the function as ``extern \"C\"``."
msgstr ""
"PyMODINIT_FUNC ã¯é–¢æ•°ã®æˆ»ã‚Šå€¤ã‚’ ``PyObject *`` ã«ãªã‚‹ã‚ˆã†ã«å®£è¨€ã—ã€ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ æ¯ã«å¿…è¦ã¨ã•ã‚Œã‚‹ã€ç‰¹æœ‰ã®ãƒªãƒ³ã‚¯å®£è¨€ "
"(linkage declaration) ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã€ã•ã‚‰ã« C++ ã®å ´åˆã«ã¯é–¢æ•°ã‚’ ``extern \"C\"`` "
"ã«å®£è¨€ã™ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../extending/extending.rst:361
msgid ""
"When the Python program imports module :mod:`spam` for the first time, "
":c:func:`PyInit_spam` is called. (See below for comments about embedding "
"Python.) It calls :c:func:`PyModule_Create`, which returns a module object, "
"and inserts built-in function objects into the newly created module based "
"upon the table (an array of :c:type:`PyMethodDef` structures) found in the "
"module definition. :c:func:`PyModule_Create` returns a pointer to the module"
" object that it creates.  It may abort with a fatal error for certain "
"errors, or return *NULL* if the module could not be initialized "
"satisfactorily. The init function must return the module object to its "
"caller, so that it then gets inserted into ``sys.modules``."
msgstr ""
"Python ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒåˆã‚ã¦ :mod:`spam` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ import ã™ã‚‹ã¨ãã«ã€ :c:func:`PyInit_spam` "
"ãŒå‘¼ã°ã‚Œã¾ã™ã€‚ (ä»¥ä¸‹ã«ã‚ã‚‹ Python ã¸ã®åŸ‹ã‚è¾¼ã¿ã«é–¢ã™ã‚‹ã‚³ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚) ãã“ã‹ã‚‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ "
":c:func:`PyModule_Create` ãŒå‘¼ã°ã‚Œã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®šç¾©ã«ã‚ã‚‹ãƒ†ãƒ¼ãƒ–ãƒ« (:c:type:`PyMethodDef` æ§‹é€ ä½“ã®é…åˆ—)"
" ã«åŸºã„ã¦æ–°ãŸã«ä½œã‚‰ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã€çµ„ã¿è¾¼ã¿é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæŒ¿å…¥ã•ã‚Œã¾ã™ã€‚ :c:func:`PyModule_Create` "
"ã¯ä½œæˆã—ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚ã‚ã‚‹ã‚¨ãƒ©ãƒ¼ã«ã‚ˆã£ã¦ç•°å¸¸çµ‚äº†ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã—ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå•é¡Œç„¡ãåˆæœŸåŒ–ã§ããªã‹ã£ãŸå ´åˆã«ã¯ "
"*NULL* ã‚’è¿”ã™ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ init é–¢æ•°ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‘¼ã³å‡ºã—å…ƒã«è¿”ã—ã€ãã‚ŒãŒ ``sys.modules`` "
"ã«æŒ¿å…¥ã•ã‚Œã‚‹ã‚ˆã†ã«ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../extending/extending.rst:372
msgid ""
"When embedding Python, the :c:func:`PyInit_spam` function is not called "
"automatically unless there's an entry in the :c:data:`PyImport_Inittab` "
"table. To add the module to the initialization table, use "
":c:func:`PyImport_AppendInittab`, optionally followed by an import of the "
"module::"
msgstr ""
"Python ã¸åŸ‹ã‚è¾¼ã‚€ã¨ãã«ã€ :c:data:`PyImport_Inittab` ãƒ†ãƒ¼ãƒ–ãƒ«ã«å­˜åœ¨ã—ã¦ã„ã¦ã‚‚ "
":c:func:`PyInit_spam` é–¢æ•°ã¯è‡ªå‹•çš„ã«ã¯å‘¼ã°ã‚Œã¾ã›ã‚“ã€‚åˆæœŸåŒ–ãƒ†ãƒ¼ãƒ–ãƒ«ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¿½åŠ ã™ã‚‹ã«ã¯ã€ "
":c:func:`PyImport_AppendInittab` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚ãã®å¾Œã«ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ import ã—ã¾ã™::"

#: ../../extending/extending.rst:408
msgid ""
"Removing entries from ``sys.modules`` or importing compiled modules into "
"multiple interpreters within a process (or following a :c:func:`fork` "
"without an intervening :c:func:`exec`) can create problems for some "
"extension modules. Extension module authors should exercise caution when "
"initializing internal data structures."
msgstr ""
"å˜ä¸€ã®ãƒ—ãƒ­ã‚»ã‚¹å†… (ã¾ãŸã¯ :c:func:`fork` å¾Œã® :c:func:`exec` ãŒä»‹å…¥ã—ã¦ã„ãªã„çŠ¶æ…‹) "
"ã«ãŠã‘ã‚‹è¤‡æ•°ã®ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ãŠã„ã¦ã€ ``sys.modules`` ã‹ã‚‰ã‚¨ãƒ³ãƒˆãƒªã‚’é™¤å»ã—ãŸã‚Šæ–°ãŸãªã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ import "
"ã—ãŸã‚Šã™ã‚‹ã¨ã€æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚ˆã£ã¦ã¯å•é¡Œã‚’ç”Ÿã˜ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä½œè€…ã¯ã€å†…éƒ¨ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’åˆæœŸåŒ–ã™ã‚‹éš›ã«ã¯ã‚ˆãã‚ˆãç”¨å¿ƒã™ã¹ãã§ã™ã€‚"

#: ../../extending/extending.rst:414
msgid ""
"A more substantial example module is included in the Python source "
"distribution as :file:`Modules/xxmodule.c`.  This file may be used as a  "
"template or simply read as an example."
msgstr ""
"ã‚ˆã‚Šå®Ÿè³ªçš„ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä¾‹ã¯ã€Python ã‚½ãƒ¼ã‚¹é…å¸ƒç‰©ã« :file:`Modules/xxmodule.c` "
"ã¨ã„ã†åå‰ã§å…¥ã£ã¦ã„ã¾ã™ã€‚ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã¨ã—ã¦ã‚‚åˆ©ç”¨ã§ãã¾ã™ã—ã€å˜ã«ä¾‹ã¨ã—ã¦ã‚‚èª­ã‚ã¾ã™ã€‚"

#: ../../extending/extending.rst:420
msgid ""
"Unlike our ``spam`` example, ``xxmodule`` uses *multi-phase initialization* "
"(new in Python 3.5), where a PyModuleDef structure is returned from "
"``PyInit_spam``, and creation of the module is left to the import machinery."
" For details on multi-phase initialization, see :PEP:`489`."
msgstr ""
"``xmodule`` ã¯ ``spam`` ã¨ç•°ãªã‚Šã€ *å¤šæ®µéšåˆæœŸåŒ– (multi-phase initialization* (Python "
"3.5 ã®æ–°æ©Ÿèƒ½) ã‚’ä½¿ã£ã¦ã„ã¾ã™ã€‚ ``PyInit_spam`` ãŒ PyModuleDef ã‚’è¿”ã—ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ç”Ÿæˆã¯å¾Œã« import "
"æ©Ÿæ§‹ãŒè¡Œã„ã¾ã™ã€‚å¤šæ®µéšåˆæœŸåŒ–ã«ã¤ã„ã¦ã®è©³ç´°ã¯ :PEP:`489` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../extending/extending.rst:429
msgid "Compilation and Linkage"
msgstr "ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã¨ãƒªãƒ³ã‚¯"

#: ../../extending/extending.rst:431
msgid ""
"There are two more things to do before you can use your new extension: "
"compiling and linking it with the Python system.  If you use dynamic "
"loading, the details may depend on the style of dynamic loading your system "
"uses; see the chapters about building extension modules (chapter "
":ref:`building`) and additional information that pertains only to building "
"on Windows (chapter :ref:`building-on-windows`) for more information about "
"this."
msgstr ""
"æ–°ã—ã„æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ãˆã‚‹ã‚ˆã†ã«ãªã‚‹ã¾ã§ã€ã¾ã äºŒã¤ã®ä½œæ¥­: ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã¨ã€Python ã‚·ã‚¹ãƒ†ãƒ ã¸ã®ãƒªãƒ³ã‚¯ã€ãŒæ®‹ã£ã¦ã„ã¾ã™ã€‚å‹•çš„èª­ã¿è¾¼ã¿ "
"(dynamic loading) ã‚’ä½¿ã£ã¦ã„ã‚‹ã®ãªã‚‰ã€ä½œæ¥­ã®è©³ç´°ã¯è‡ªåˆ†ã®ã‚·ã‚¹ãƒ†ãƒ ãŒä½¿ã£ã¦ã„ã‚‹å‹•çš„èª­ã¿è¾¼ã¿ã®å½¢å¼ã«ã‚ˆã£ã¦å¤‰ã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“; "
"è©³ã—ãã¯ã€æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ“ãƒ«ãƒ‰ã«é–¢ã™ã‚‹ç«  (:ref:`building` ç« ) ã‚„ã€Windows ã«ãŠã‘ã‚‹ãƒ“ãƒ«ãƒ‰ã«é–¢ä¿‚ã™ã‚‹è¿½åŠ æƒ…å ±ã®ç«  (:ref"
":`building-on-windows` ç« ) ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../extending/extending.rst:438
msgid ""
"If you can't use dynamic loading, or if you want to make your module a "
"permanent part of the Python interpreter, you will have to change the "
"configuration setup and rebuild the interpreter.  Luckily, this is very "
"simple on Unix: just place your file (:file:`spammodule.c` for example) in "
"the :file:`Modules/` directory of an unpacked source distribution, add a "
"line to the file :file:`Modules/Setup.local` describing your file:"
msgstr ""

#: ../../extending/extending.rst:449
msgid ""
"and rebuild the interpreter by running :program:`make` in the toplevel "
"directory.  You can also run :program:`make` in the :file:`Modules/` "
"subdirectory, but then you must first rebuild :file:`Makefile` there by "
"running ':program:`make` Makefile'.  (This is necessary each time you change"
" the :file:`Setup` file.)"
msgstr ""
"ã‚’è¿½åŠ ã—ã¦ã€ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ :program:`make` ã‚’å®Ÿè¡Œã—ã¦ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’å†ãƒ“ãƒ«ãƒ‰ã™ã‚‹ã ã‘ã§ã™ã€‚ "
":file:`Modules/` ã‚µãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ã‚‚ :program:`make` ã‚’å®Ÿè¡Œã§ãã¾ã™ãŒã€å‰ã‚‚ã£ã¦ ':program:`make` "
"Makefile' ã‚’å®Ÿè¡Œã—ã¦ :file:`Makefile` ã‚’å†ãƒ“ãƒ«ãƒ‰ã—ã¦ãŠã‹ãªã‘ã‚Œã°ãªã‚‰ã‚Šã¾ã›ã‚“ã€‚(ã“ã®ä½œæ¥­ã¯ :file:`Setup` "
"ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¤‰æ›´ã™ã‚‹ãŸã³ã«å¿…è¦ã§ã™ã€‚)"

#: ../../extending/extending.rst:455
msgid ""
"If your module requires additional libraries to link with, these can be "
"listed on the line in the configuration file as well, for instance:"
msgstr ""

#: ../../extending/extending.rst:466
msgid "Calling Python Functions from C"
msgstr "C ã‹ã‚‰ Python é–¢æ•°ã‚’å‘¼ã³å‡ºã™"

#: ../../extending/extending.rst:468
msgid ""
"So far we have concentrated on making C functions callable from Python.  The"
" reverse is also useful: calling Python functions from C. This is especially"
" the case for libraries that support so-called \"callback\" functions.  If a"
" C interface makes use of callbacks, the equivalent Python often needs to "
"provide a callback mechanism to the Python programmer; the implementation "
"will require calling the Python callback functions from a C callback.  Other"
" uses are also imaginable."
msgstr ""
"ã“ã‚Œã¾ã§ã¯ã€Python ã‹ã‚‰ã® C é–¢æ•°ã®å‘¼ã³å‡ºã—ã«é‡ç‚¹ã‚’ç½®ã„ã¦è¿°ã¹ã¦ãã¾ã—ãŸã€‚ã¨ã“ã‚ã§ã“ã®é€†: C ã‹ã‚‰ã® Python "
"é–¢æ•°ã®å‘¼ã³å‡ºã—ã‚‚ã¾ãŸæœ‰ç”¨ã§ã™ã€‚ã¨ã‚Šã‚ã‘ã€ã„ã‚ã‚†ã‚‹ \"ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯\" é–¢æ•°ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ãªãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½œæˆã™ã‚‹éš›ã«ã¯ã“ã®æ©Ÿèƒ½ãŒä¾¿åˆ©ã§ã™ã€‚ã‚ã‚‹ C "
"ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ãŒã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’åˆ©ç”¨ã—ã¦ã„ã‚‹å ´åˆã€åŒç­‰ã®æ©Ÿèƒ½ã‚’æä¾›ã™ã‚‹ Python ã‚³ãƒ¼ãƒ‰ã§ã¯ã€ã—ã°ã—ã° Python "
"ãƒ—ãƒ­ã‚°ãƒ©ãƒã«ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿæ§‹ã‚’æä¾›ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™; ã“ã®ã¨ãå®Ÿè£…ã§ã¯ã€ C ã§æ›¸ã‹ã‚ŒãŸã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‹ã‚‰ Python "
"ã§æ›¸ã‹ã‚ŒãŸã‚³ãƒ¼ãƒ«ãƒ‘ãƒƒã‚¯é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã§ã—ã‚‡ã†ã€‚ã‚‚ã¡ã‚ã‚“ã€ä»–ã®ç”¨é€”ã‚‚è€ƒãˆã‚‰ã‚Œã¾ã™ã€‚"

#: ../../extending/extending.rst:476
msgid ""
"Fortunately, the Python interpreter is easily called recursively, and there "
"is a standard interface to call a Python function.  (I won't dwell on how to"
" call the Python parser with a particular string as input --- if you're "
"interested, have a look at the implementation of the :option:`-c` command "
"line option in :file:`Modules/main.c` from the Python source code.)"
msgstr ""
"å¹¸é‹ãªã“ã¨ã«ã€Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ç°¡å˜ã«å†å¸°å‘¼ã³å‡ºã—ã§ãã€ Python é–¢æ•°ã‚’å‘¼ã³å‡ºã™ãŸã‚ã®æ¨™æº–ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚‚ã‚ã‚Šã¾ã™ã€‚ (Python "
"ãƒ‘ãƒ¼ã‚¶ã‚’ç‰¹å®šã®å…¥åŠ›æ–‡å­—ã‚’ä½¿ã£ã¦å‘¼ã³å‡ºã™æ–¹æ³•ã«ã¤ã„ã¦è©³èª¬ã™ã‚‹ã¤ã‚‚ã‚Šã¯ã‚ã‚Šã¾ã›ã‚“ --- ã“ã®æ–¹æ³•ã«èˆˆå‘³ãŒã‚ã‚‹ãªã‚‰ã€ Python ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã® "
":file:`Modules/main.c` ã«ã‚ã‚‹ã€ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã‚ªãƒ—ã‚·ãƒ§ãƒ³ :option:`-c` ã®å®Ÿè£…ã‚’è¦‹ã¦ãã ã•ã„)"

#: ../../extending/extending.rst:482
msgid ""
"Calling a Python function is easy.  First, the Python program must somehow "
"pass you the Python function object.  You should provide a function (or some"
" other interface) to do this.  When this function is called, save a pointer "
"to the Python function object (be careful to :c:func:`Py_INCREF` it!) in a "
"global variable --- or wherever you see fit. For example, the following "
"function might be part of a module definition::"
msgstr ""
"Python é–¢æ•°ã®å‘¼ã³å‡ºã—ã¯ç°¡å˜ã§ã™ã€‚ã¾ãšã€C ã®ã‚³ãƒ¼ãƒ‰ã«å¯¾ã—ã¦ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ç™»éŒ²ã—ã‚ˆã†ã¨ã™ã‚‹ Python ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€ä½•ã‚‰ã‹ã®æ–¹æ³•ã§ "
"Python ã®é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¸¡ã•ã­ã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®ãŸã‚ã«ã€ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ç™»éŒ²é–¢æ•° (ã¾ãŸã¯ãã®ä»–ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹) "
"ã‚’æä¾›ã›ã­ã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ç™»éŒ²é–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚ŒãŸéš›ã«ã€å¼•ãæ¸¡ã•ã‚ŒãŸ Python é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã« --- "
"ã‚ã‚‹ã„ã¯ã€ã©ã“ã‹é©åˆ‡ãªå ´æ‰€ã« --- ä¿å­˜ã—ã¾ã™ (é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ :c:func:`Py_INCREF` "
"ã™ã‚‹ã‚ˆã†ã‚ˆãæ³¨æ„ã—ã¦ãã ã•ã„!)ã€‚ä¾‹ãˆã°ã€ä»¥ä¸‹ã®ã‚ˆã†ãªé–¢æ•°ãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä¸€éƒ¨ã«ãªã£ã¦ã„ã‚‹ã“ã¨ã§ã—ã‚‡ã†::"

#: ../../extending/extending.rst:512
msgid ""
"This function must be registered with the interpreter using the "
":const:`METH_VARARGS` flag; this is described in section :ref:`methodtable`."
"  The :c:func:`PyArg_ParseTuple` function and its arguments are documented "
"in section :ref:`parsetuple`."
msgstr ""
"ã“ã®é–¢æ•°ã¯ :const:`METH_VARARGS` ãƒ•ãƒ©ã‚°ã‚’ä½¿ã£ã¦ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ç™»éŒ²ã›ã­ã°ãªã‚Šã¾ã›ã‚“; :const:`METH_VARARGS` "
"ãƒ•ãƒ©ã‚°ã«ã¤ã„ã¦ã¯ã€ :ref:`methodtable` ã§èª¬æ˜ã—ã¦ã„ã¾ã™ã€‚ :c:func:`PyArg_ParseTuple` "
"é–¢æ•°ã¨ãã®å¼•æ•°ã«ã¤ã„ã¦ã¯ã€ :ref:`parsetuple` ã«è¨˜è¿°ã—ã¦ã„ã¾ã™ã€‚"

#: ../../extending/extending.rst:517
msgid ""
"The macros :c:func:`Py_XINCREF` and :c:func:`Py_XDECREF` increment/decrement"
" the reference count of an object and are safe in the presence of *NULL* "
"pointers (but note that *temp* will not be  *NULL* in this context).  More "
"info on them in section :ref:`refcounts`."
msgstr ""
":c:func:`Py_XINCREF` ãŠã‚ˆã³ :c:func:`Py_XDECREF` "
"ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ/ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã™ã‚‹ãŸã‚ã®ãƒã‚¯ãƒ­ã§ã€ *NULL* ãƒã‚¤ãƒ³ã‚¿ãŒæ¸¡ã•ã‚Œã¦ã‚‚å®‰å…¨ã«æ“ä½œã§ãã‚‹å½¢å¼ã§ã™ "
"(ã¨ã¯ã„ãˆã€ä¸Šã®æµã‚Œã§ã¯ *temp* ãŒ *NULL* ã«ãªã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“)ã€‚ã“ã‚Œã‚‰ã®ãƒã‚¯ãƒ­ã¨å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã«ã¤ã„ã¦ã¯ã€ "
":ref:`refcounts` ã§èª¬æ˜ã—ã¦ã„ã¾ã™ã€‚"

#: ../../extending/extending.rst:524
msgid ""
"Later, when it is time to call the function, you call the C function "
":c:func:`PyObject_CallObject`.  This function has two arguments, both "
"pointers to arbitrary Python objects: the Python function, and the argument "
"list.  The argument list must always be a tuple object, whose length is the "
"number of arguments.  To call the Python function with no arguments, pass in"
" NULL, or an empty tuple; to call it with one argument, pass a singleton "
"tuple. :c:func:`Py_BuildValue` returns a tuple when its format string "
"consists of zero or more format codes between parentheses.  For example::"
msgstr ""
"ãã®å¾Œã€ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’å‘¼ã³å‡ºã™æ™‚ãŒæ¥ãŸã‚‰ã€C é–¢æ•° :c:func:`PyObject_CallObject` "
"ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã«ã¯äºŒã¤ã®å¼•æ•°: Python é–¢æ•°ã¨ Python é–¢æ•°ã®å¼•æ•°ãƒªã‚¹ãƒˆãŒã‚ã‚Šã€ã„ãšã‚Œã‚‚ä»»æ„ã® Python "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¡¨ã™ãƒã‚¤ãƒ³ã‚¿å‹ã§ã™ã€‚å¼•æ•°ãƒªã‚¹ãƒˆã¯å¸¸ã«ã‚¿ãƒ—ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚‰ãšã€ãã®é•·ã•ã¯å¼•æ•°ã®æ•°ã«ãªã‚Šã¾ã™ã€‚Python "
"é–¢æ•°ã‚’å¼•æ•°ãªã—ã§å‘¼ã³å‡ºã™ã®ãªã‚‰ã€ NULL ã‹ç©ºã®ã‚¿ãƒ—ãƒ«ã‚’æ¸¡ã—ã¾ã™; å˜ä¸€ã®å¼•æ•°ã§é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã®ãªã‚‰ã€å˜è¦ç´  (singleton) "
"ã®ã‚¿ãƒ—ãƒ«ã‚’æ¸¡ã—ã¾ã™ã€‚ :c:func:`Py_BuildValue` "
"ã®æ›¸å¼æ–‡å­—åˆ—ä¸­ã«ã€ã‚¼ãƒ­å€‹ã¾ãŸã¯ä¸€å€‹ä»¥ä¸Šã®æ›¸å¼åŒ–ã‚³ãƒ¼ãƒ‰ãŒå…¥ã£ãŸä¸¸æ‹¬å¼§ãŒã‚ã‚‹å ´åˆã€ã“ã®é–¢æ•°ã¯ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚ä»¥ä¸‹ã«ä¾‹ã‚’ç¤ºã—ã¾ã™::"

#: ../../extending/extending.rst:544
msgid ""
":c:func:`PyObject_CallObject` returns a Python object pointer: this is the "
"return value of the Python function.  :c:func:`PyObject_CallObject` is "
"\"reference-count-neutral\" with respect to its arguments.  In the example a"
" new tuple was created to serve as the argument list, which is "
":c:func:`Py_DECREF`\\ -ed immediately after the "
":c:func:`PyObject_CallObject` call."
msgstr ""
":c:func:`PyObject_CallObject` ã¯ Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã—ã¾ã™: ã“ã‚Œã¯ Python "
"é–¢æ•°ã‹ã‚‰ã®æˆ»ã‚Šå€¤ã«ãªã‚Šã¾ã™ã€‚ :c:func:`PyObject_CallObject` ã¯ã€å¼•æ•°ã«å¯¾ã—ã¦ \"å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆä¸­ç«‹ (reference-"
"count- neutral)\" ã§ã™ã€‚ä¸Šã®ä¾‹ã§ã¯ã‚¿ãƒ—ãƒ«ã‚’ç”Ÿæˆã—ã¦å¼•æ•°ãƒªã‚¹ãƒˆã¨ã—ã¦æä¾›ã—ã¦ãŠã‚Šã€ã“ã®ã‚¿ãƒ—ãƒ«ã¯ "
":c:func:`PyObject_CallObject` ã®å‘¼ã³å‡ºã—ç›´å¾Œã« :c:func:`Py_DECREF` ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../extending/extending.rst:550
msgid ""
"The return value of :c:func:`PyObject_CallObject` is \"new\": either it is a"
" brand new object, or it is an existing object whose reference count has "
"been incremented.  So, unless you want to save it in a global variable, you "
"should somehow :c:func:`Py_DECREF` the result, even (especially!) if you are"
" not interested in its value."
msgstr ""
":c:func:`PyObject_CallObject` ã¯æˆ»ã‚Šå€¤ã¨ã—ã¦ \"æ–°ã—ã„\" ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ: "
"æ–°è¦ã«ä½œæˆã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã€æ—¢å­˜ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ãŸã‚‚ã®ã‚’è¿”ã—ã¾ã™ã€‚å¾“ã£ã¦ã€ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«ä¿å­˜ã—ãŸã„ã®ã§ãªã„ã‹ãã‚Šã€ãŸã¨ãˆã“ã®æˆ»ã‚Šå€¤ã«èˆˆå‘³ãŒãªãã¦ã‚‚"
" (ã‚€ã—ã‚ã€ãã†ã§ã‚ã‚Œã°ãªãŠã•ã‚‰!) ä½•ãŒã—ã‹ã®æ–¹æ³•ã§æˆ»ã‚Šå€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ :c:func:`Py_DECREF` ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../extending/extending.rst:556
msgid ""
"Before you do this, however, it is important to check that the return value "
"isn't *NULL*.  If it is, the Python function terminated by raising an "
"exception. If the C code that called :c:func:`PyObject_CallObject` is called"
" from Python, it should now return an error indication to its Python caller,"
" so the interpreter can print a stack trace, or the calling Python code can "
"handle the exception. If this is not possible or desirable, the exception "
"should be cleared by calling :c:func:`PyErr_Clear`.  For example::"
msgstr ""
"ã¨ã¯ã„ãˆã€æˆ»ã‚Šå€¤ã‚’ :c:func:`Py_DECREF` ã™ã‚‹å‰ã«ã¯ã€å€¤ãŒ *NULL* ã§ãªã„ã‹ãƒã‚§ãƒƒã‚¯ã—ã¦ãŠãã“ã¨ãŒé‡è¦ã§ã™ã€‚ã‚‚ã— *NULL* "
"ãªã‚‰ã€å‘¼ã³å‡ºã—ãŸ Python é–¢æ•°ã¯ä¾‹å¤–ã‚’é€å‡ºã—ã¦çµ‚äº†ã•ã›ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚ :c:func:`PyObject_CallObject` "
"ã‚’å‘¼ã³å‡ºã—ã¦ã„ã‚‹ã‚³ãƒ¼ãƒ‰è‡ªä½“ã‚‚ã¾ãŸ Python ã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã¦ã„ã‚‹ã®ã§ã‚ã‚Œã°ã€ä»Šåº¦ã¯ C ã‚³ãƒ¼ãƒ‰ãŒè‡ªåˆ†ã‚’å‘¼ã³å‡ºã—ã¦ã„ã‚‹ Python "
"ã‚³ãƒ¼ãƒ‰ã«ã‚¨ãƒ©ãƒ¼æ¨™ç¤ºå€¤ã‚’è¿”ã•ã­ã°ãªã‚Šã¾ã›ã‚“ã€‚ãã‚Œã«ã‚ˆã‚Šã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã‚’å‡ºåŠ›ã—ãŸã‚Šã€ä¾‹å¤–ã‚’å‡¦ç†ã™ã‚‹ãŸã‚ã® Python "
"ã‚³ãƒ¼ãƒ‰ã‚’å‘¼ã³å‡ºã—ãŸã‚Šã§ãã¾ã™ã€‚ä¾‹å¤–ã®é€å‡ºãŒä¸å¯èƒ½ã ã£ãŸã‚Šã€ã—ãŸããªã„ã®ãªã‚‰ã€ :c:func:`PyErr_Clear` "
"ã‚’å‘¼ã‚“ã§ä¾‹å¤–ã‚’æ¶ˆå»ã—ã¦ãŠã‹ã­ã°ãªã‚Šã¾ã›ã‚“ã€‚ä¾‹ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¾ã™::"

#: ../../extending/extending.rst:569
msgid ""
"Depending on the desired interface to the Python callback function, you may "
"also have to provide an argument list to :c:func:`PyObject_CallObject`.  In "
"some cases the argument list is also provided by the Python program, through"
" the same interface that specified the callback function.  It can then be "
"saved and used in the same manner as the function object.  In other cases, "
"you may have to construct a new tuple to pass as the argument list.  The "
"simplest way to do this is to call :c:func:`Py_BuildValue`.  For example, if"
" you want to pass an integral event code, you might use the following code::"
msgstr ""
"Python ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’ã©ã‚“ãªã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã«ã—ãŸã„ã‹ã«ã‚ˆã£ã¦ã¯ã€å¼•æ•°ãƒªã‚¹ãƒˆã‚’ :c:func:`PyObject_CallObject` "
"ã«ä¸ãˆãªã‘ã‚Œã°ãªã‚‰ãªã„å ´åˆã‚‚ã‚ã‚Šã¾ã™ã€‚ã‚ã‚‹ã‚±ãƒ¼ã‚¹ã§ã¯ã€ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’æŒ‡å®šã—ãŸã®ã¨åŒã˜ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ä»‹ã—ã¦ã€å¼•æ•°ãƒªã‚¹ãƒˆã‚‚æ¸¡ã•ã‚Œã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã¾ãŸåˆ¥ã®ã‚±ãƒ¼ã‚¹ã§ã¯ã€æ–°ã—ã„ã‚¿ãƒ—ãƒ«ã‚’æ§‹ç¯‰ã—ã¦å¼•æ•°ãƒªã‚¹ãƒˆã‚’æ¸¡ã•ã­ã°ãªã‚‰ãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã“ã®å ´åˆæœ€ã‚‚ç°¡å˜ãªã®ã¯"
" :c:func:`Py_BuildValue` "
"ã‚’å‘¼ã¶ã‚„ã‚Šæ–¹ã§ã™ã€‚ä¾‹ãˆã°ã€æ•´æ•°ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚³ãƒ¼ãƒ‰ã‚’æ¸¡ã—ãŸã‘ã‚Œã°ã€ä»¥ä¸‹ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚’ä½¿ã†ã“ã¨ã«ãªã‚‹ã§ã—ã‚‡ã†::"

#: ../../extending/extending.rst:588
msgid ""
"Note the placement of ``Py_DECREF(arglist)`` immediately after the call, "
"before the error check!  Also note that strictly speaking this code is not "
"complete: :c:func:`Py_BuildValue` may run out of memory, and this should be "
"checked."
msgstr ""
"``Py_DECREF(arglist)`` ãŒå‘¼ã³å‡ºã—ã®ç›´å¾Œã€ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯ã‚ˆã‚Šã‚‚å‰ã«ç½®ã‹ã‚Œã¦ã„ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„! "
"ã¾ãŸã€å³å¯†ã«è¨€ãˆã°ã€ã“ã®ã‚³ãƒ¼ãƒ‰ã¯å®Œå…¨ã§ã¯ã‚ã‚Šã¾ã›ã‚“: :c:func:`Py_BuildValue` "
"ã¯ãƒ¡ãƒ¢ãƒªä¸è¶³ã«ãŠã¡ã„ã‚‹ã‹ã‚‚ã—ã‚Œãšã€ãƒã‚§ãƒƒã‚¯ã—ã¦ãŠãã¹ãã§ã™ã€‚"

#: ../../extending/extending.rst:592
msgid ""
"You may also call a function with keyword arguments by using "
":c:func:`PyObject_Call`, which supports arguments and keyword arguments.  As"
" in the above example, we use :c:func:`Py_BuildValue` to construct the "
"dictionary. ::"
msgstr ""
"é€šå¸¸ã®å¼•æ•°ã¨ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ :c:func:`PyObject_Call` "
"ã‚’ä½¿ã£ã¦ã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’ä¼´ã†é–¢æ•°å‘¼ã³å‡ºã—ã‚’ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä¸Šã®ä¾‹ã¨åŒã˜ã‚ˆã†ã«ã€ :c:func:`Py_BuildValue` "
"ã‚’ä½œã£ã¦è¾æ›¸ã‚’ä½œã‚Šã¾ã™ã€‚ ::"

#: ../../extending/extending.rst:610
msgid "Extracting Parameters in Extension Functions"
msgstr "æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«é–¢æ•°ã§ã®ãƒ‘ãƒ©ãƒ¡ã‚¿å±•é–‹"

#: ../../extending/extending.rst:614
msgid "The :c:func:`PyArg_ParseTuple` function is declared as follows::"
msgstr ":c:func:`PyArg_ParseTuple` é–¢æ•°ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å®£è¨€ã•ã‚Œã¦ã„ã¾ã™::"

#: ../../extending/extending.rst:618
msgid ""
"The *arg* argument must be a tuple object containing an argument list passed"
" from Python to a C function.  The *format* argument must be a format "
"string, whose syntax is explained in :ref:`arg-parsing` in the Python/C API "
"Reference Manual.  The remaining arguments must be addresses of variables "
"whose type is determined by the format string."
msgstr ""
"å¼•æ•° *arg* ã¯ C é–¢æ•°ã‹ã‚‰ Python ã«æ¸¡ã•ã‚Œã‚‹å¼•æ•°ãƒªã‚¹ãƒˆãŒå…¥ã£ãŸã‚¿ãƒ—ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ *format* "
"å¼•æ•°ã¯æ›¸å¼æ–‡å­—åˆ—ã§ã€ Python/C API ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã® :ref:`arg-parsing` "
"ã§è§£èª¬ã•ã‚Œã¦ã„ã‚‹æ›¸æ³•ã«å¾“ã‚ã­ã°ãªã‚Šã¾ã›ã‚“ã€‚æ®‹ã‚Šã®å¼•æ•°ã¯ã€ãã‚Œãã‚Œã®å¤‰æ•°ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã€æ›¸å¼åŒ–æ–‡å­—åˆ—ã‹ã‚‰æ±ºã¾ã‚‹å‹ã«ãªã£ã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../extending/extending.rst:624
msgid ""
"Note that while :c:func:`PyArg_ParseTuple` checks that the Python arguments "
"have the required types, it cannot check the validity of the addresses of C "
"variables passed to the call: if you make mistakes there, your code will "
"probably crash or at least overwrite random bits in memory.  So be careful!"
msgstr ""
":c:func:`PyArg_ParseTuple` ã¯ Python å´ã‹ã‚‰ä¸ãˆã‚‰ã‚ŒãŸå¼•æ•°ãŒå¿…è¦ãªå‹ã«ãªã£ã¦ã„ã‚‹ã‹èª¿ã¹ã‚‹ã®ã«å¯¾ã—ã€ "
":c:func:`PyArg_ParseTuple` ã¯å‘¼ã³å‡ºã—ã®éš›ã«æ¸¡ã•ã‚ŒãŸ C å¤‰æ•°ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒæœ‰åŠ¹ãªå€¤ã‚’æŒã¤ã‹èª¿ã¹ã‚‰ã‚Œãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„:"
" ã“ã“ã§é–“é•ã„ã‚’çŠ¯ã™ã¨ã€ã‚³ãƒ¼ãƒ‰ãŒã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã—ã€å°‘ãªãã¨ã‚‚ã§ãŸã‚‰ã‚ãªãƒ“ãƒƒãƒˆã‚’ãƒ¡ãƒ¢ãƒªã«ä¸Šæ›¸ãã—ã¦ã—ã¾ã„ã¾ã™ã€‚æ…é‡ã«!"

#: ../../extending/extending.rst:629
msgid ""
"Note that any Python object references which are provided to the caller are "
"*borrowed* references; do not decrement their reference count!"
msgstr ""
"å‘¼ã³å‡ºã—å´ã«æä¾›ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã¯ã™ã¹ã¦ *å€Ÿç”¨* å‚ç…§ (borrowed reference) ã«ãªã‚Šã¾ã™; "
"ã“ã‚Œã‚‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã¦ã¯ãªã‚Šã¾ã›ã‚“!"

#: ../../extending/extending.rst:632
msgid "Some example calls::"
msgstr "ä»¥ä¸‹ã«ã„ãã¤ã‹ã®å‘¼ã³å‡ºã—ä¾‹ã‚’ç¤ºã—ã¾ã™::"

#: ../../extending/extending.rst:702
msgid "Keyword Parameters for Extension Functions"
msgstr "æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«é–¢æ•°ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒ‘ãƒ©ãƒ¡ã‚¿"

#: ../../extending/extending.rst:706
msgid ""
"The :c:func:`PyArg_ParseTupleAndKeywords` function is declared as follows::"
msgstr ":c:func:`PyArg_ParseTupleAndKeywords` ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«å®£è¨€ã•ã‚Œã¦ã„ã¾ã™::"

#: ../../extending/extending.rst:711
msgid ""
"The *arg* and *format* parameters are identical to those of the "
":c:func:`PyArg_ParseTuple` function.  The *kwdict* parameter is the "
"dictionary of keywords received as the third parameter from the Python "
"runtime.  The *kwlist* parameter is a *NULL*-terminated list of strings "
"which identify the parameters; the names are matched with the type "
"information from *format* from left to right.  On success, "
":c:func:`PyArg_ParseTupleAndKeywords` returns true, otherwise it returns "
"false and raises an appropriate exception."
msgstr ""
"*arg* ã¨ *format* ãƒ‘ãƒ©ãƒ¡ã‚¿ã¯ :c:func:`PyArg_ParseTuple` ã®ã‚‚ã®ã¨åŒã˜ã§ã™ã€‚ *kwdict* "
"ãƒ‘ãƒ©ãƒ¡ã‚¿ã¯ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã®å…¥ã£ãŸè¾æ›¸ã§ã€ Python ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚·ã‚¹ãƒ†ãƒ ã‹ã‚‰ç¬¬ä¸‰ãƒ‘ãƒ©ãƒ¡ã‚¿ã¨ã—ã¦å—ã‘å–ã‚Šã¾ã™ã€‚ *kwlist* "
"ãƒ‘ãƒ©ãƒ¡ã‚¿ã¯å„ãƒ‘ãƒ©ãƒ¡ã‚¿ã‚’è­˜åˆ¥ã™ã‚‹ãŸã‚ã®æ–‡å­—åˆ—ã‹ã‚‰ãªã‚‹ã€ *NULL* çµ‚ç«¯ã•ã‚ŒãŸãƒªã‚¹ãƒˆã§ã™; å„ãƒ‘ãƒ©ãƒ¡ã‚¿åã¯ *format* "
"ä¸­ã®å‹æƒ…å ±ã«å¯¾ã—ã¦å·¦ã‹ã‚‰å³ã®é †ã«ç…§åˆã•ã‚Œã¾ã™ã€‚æˆåŠŸã™ã‚‹ã¨ :c:func:`PyArg_ParseTupleAndKeywords` "
"ã¯çœŸã‚’è¿”ã—ã€ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯é©åˆ‡ãªä¾‹å¤–ã‚’é€å‡ºã—ã¦å½ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../extending/extending.rst:721
msgid ""
"Nested tuples cannot be parsed when using keyword arguments!  Keyword "
"parameters passed in which are not present in the *kwlist* will cause "
":exc:`TypeError` to be raised."
msgstr ""
"ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’ä½¿ã£ã¦ã„ã‚‹å ´åˆã€ã‚¿ãƒ—ãƒ«ã¯å…¥ã‚Œå­ã«ã—ã¦ä½¿ãˆã¾ã›ã‚“! *kwlist* å†…ã«å­˜åœ¨ã—ãªã„ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒ‘ãƒ©ãƒ¡ã‚¿ãŒæ¸¡ã•ã‚ŒãŸå ´åˆã€ "
":exc:`TypeError` ã®é€å‡ºã‚’å¼•ãèµ·ã“ã—ã¾ã™ã€‚"

#: ../../extending/extending.rst:727
msgid ""
"Here is an example module which uses keywords, based on an example by Geoff "
"Philbrick (philbrick@hks.com)::"
msgstr ""
"ä»¥ä¸‹ã«ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ã£ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚ã“ã‚Œã¯ Geoff Philbrick (philbrick@hks.com) "
"ã«ã‚ˆã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ä¾‹ã‚’ã‚‚ã¨ã«ã—ã¦ã„ã¾ã™::"

#: ../../extending/extending.rst:781
msgid "Building Arbitrary Values"
msgstr "ä»»æ„ã®å€¤ã‚’æ§‹ç¯‰ã™ã‚‹"

#: ../../extending/extending.rst:783
msgid ""
"This function is the counterpart to :c:func:`PyArg_ParseTuple`.  It is "
"declared as follows::"
msgstr ""
":c:func:`Py_BuildValue` ã¯ :c:func:`PyArg_ParseTuple` "
"ã®å¯¾æ¥µã«ä½ç½®ã™ã‚‹ã‚‚ã®ã§ã™ã€‚ã“ã®é–¢æ•°ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™::"

#: ../../extending/extending.rst:788
msgid ""
"It recognizes a set of format units similar to the ones recognized by "
":c:func:`PyArg_ParseTuple`, but the arguments (which are input to the "
"function, not output) must not be pointers, just values.  It returns a new "
"Python object, suitable for returning from a C function called from Python."
msgstr ""
":c:func:`Py_BuildValue` ã¯ã€ :c:func:`PyArg_ParseTuple` "
"ã®èªè­˜ã™ã‚‹ä¸€é€£ã®æ›¸å¼å˜ä½ã«ä¼¼ãŸæ›¸å¼å˜ä½ã‚’èªè­˜ã—ã¾ã™ã€‚ãŸã ã— (é–¢æ•°ã¸ã®å‡ºåŠ›ã§ã¯ãªãã€å…¥åŠ›ã«ä½¿ã‚ã‚Œã‚‹) "
"å¼•æ•°ã¯ãƒã‚¤ãƒ³ã‚¿ã§ã¯ãªãã€ãŸã ã®å€¤ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ Python ã‹ã‚‰å‘¼ã³å‡ºã•ã‚ŒãŸ C é–¢æ•°ãŒè¿”ã™å€¤ã¨ã—ã¦é©åˆ‡ãªã€æ–°ãŸãª Python "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../extending/extending.rst:793
msgid ""
"One difference with :c:func:`PyArg_ParseTuple`: while the latter requires "
"its first argument to be a tuple (since Python argument lists are always "
"represented as tuples internally), :c:func:`Py_BuildValue` does not always "
"build a tuple.  It builds a tuple only if its format string contains two or "
"more format units. If the format string is empty, it returns ``None``; if it"
" contains exactly one format unit, it returns whatever object is described "
"by that format unit.  To force it to return a tuple of size 0 or one, "
"parenthesize the format string."
msgstr ""
":c:func:`PyArg_ParseTuple` ã¨ã¯ä¸€ã¤é•ã†ç‚¹ãŒã‚ã‚Šã¾ã™: :c:func:`PyArg_ParseTuple` "
"ã¯ç¬¬ä¸€å¼•æ•°ã‚’ã‚¿ãƒ—ãƒ«ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ (Python ã®å¼•æ•°ãƒªã‚¹ãƒˆã¯å†…éƒ¨çš„ã«ã¯å¸¸ã«ã‚¿ãƒ—ãƒ«ã¨ã—ã¦è¡¨ç¾ã•ã‚Œã‚‹ã‹ã‚‰ã§ã™) ãŒã€ "
":c:func:`Py_BuildValue` ã¯ã‚¿ãƒ—ãƒ«ã‚’ç”Ÿæˆã™ã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚ :c:func:`Py_BuildValue` "
"ã¯æ›¸å¼æ–‡å­—åˆ—ä¸­ã«æ›¸å¼å˜ä½ãŒäºŒã¤ã‹ãã‚Œä»¥ä¸Šå…¥ã£ã¦ã„ã‚‹å ´åˆã«ã®ã¿ã‚¿ãƒ—ãƒ«ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚æ›¸å¼æ–‡å­—åˆ—ãŒç©ºãªã‚‰ã€ ``None`` "
"ã‚’è¿”ã—ã¾ã™ã€‚ãã£ã‹ã‚Šä¸€ã¤ã®æ›¸å¼å˜ä½ãªã‚‰ã€ãã®æ›¸å¼å˜ä½ãŒè¨˜è¿°ã—ã¦ã„ã‚‹ä½•ã‚‰ã‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãªã‚Šã¾ã™ã€‚ã‚µã‚¤ã‚ºãŒ 0 ã‚„ 1 "
"ã®ã‚¿ãƒ—ãƒ«è¿”ã•ã›ãŸã„ã®ãªã‚‰ã€æ›¸å¼æ–‡å­—åˆ—ã‚’ä¸¸æ‹¬å¼§ã§å›²ã„ã¾ã™ã€‚"

#: ../../extending/extending.rst:801
msgid ""
"Examples (to the left the call, to the right the resulting Python value):"
msgstr "ä»¥ä¸‹ã«ä¾‹ã‚’ç¤ºã—ã¾ã™ (å·¦ã«å‘¼ã³å‡ºã—ä¾‹ã‚’ã€å³ã«æ§‹ç¯‰ã•ã‚Œã‚‹ Python å€¤ã‚’ç¤ºã—ã¾ã™):"

#: ../../extending/extending.rst:827
msgid "Reference Counts"
msgstr "å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆæ³•"

#: ../../extending/extending.rst:829
msgid ""
"In languages like C or C++, the programmer is responsible for dynamic "
"allocation and deallocation of memory on the heap.  In C, this is done using"
" the functions :c:func:`malloc` and :c:func:`free`.  In C++, the operators "
"``new`` and ``delete`` are used with essentially the same meaning and we'll "
"restrict the following discussion to the C case."
msgstr ""
"C ã‚„ C++ã®ã‚ˆã†ãªè¨€èªã§ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒã¯ãƒ’ãƒ¼ãƒ—ä¸Šã®ãƒ¡ãƒ¢ãƒªã‚’å‹•çš„ã«ç¢ºä¿ã—ãŸã‚Šè§£æ”¾ã—ãŸã‚Šã™ã‚‹è²¬ä»»ãŒã‚ã‚Šã¾ã™ã€‚ã“ã†ã—ãŸä½œæ¥­ã¯ C ã§ã¯é–¢æ•° "
":c:func:`malloc` ã‚„ :c:func:`free` ã§è¡Œã„ã¾ã™ã€‚C++ã§ã¯æœ¬è³ªçš„ã«åŒã˜æ„å‘³ã§æ¼”ç®—å­ ``new`` ã‚„ "
"``delete`` ãŒä½¿ã‚ã‚Œã¾ã™ã€‚ãã“ã§ã€ä»¥ä¸‹ã®è­°è«–ã¯ C ã®å ´åˆã«é™å®šã—ã¦è¡Œã„ã¾ã™ã€‚"

#: ../../extending/extending.rst:835
msgid ""
"Every block of memory allocated with :c:func:`malloc` should eventually be "
"returned to the pool of available memory by exactly one call to "
":c:func:`free`. It is important to call :c:func:`free` at the right time.  "
"If a block's address is forgotten but :c:func:`free` is not called for it, "
"the memory it occupies cannot be reused until the program terminates.  This "
"is called a :dfn:`memory leak`.  On the other hand, if a program calls "
":c:func:`free` for a block and then continues to use the block, it creates a"
" conflict with re-use of the block through another :c:func:`malloc` call.  "
"This is called :dfn:`using freed memory`. It has the same bad consequences "
"as referencing uninitialized data --- core dumps, wrong results, mysterious "
"crashes."
msgstr ""
":c:func:`malloc` ãŒç¢ºä¿ã™ã‚‹å…¨ã¦ã®ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã¯ã€æœ€çµ‚çš„ã«ã¯ :c:func:`free` "
"ã‚’å³å¯†ã«ä¸€åº¦ã ã‘å‘¼ã³å‡ºã—ã¦åˆ©ç”¨å¯èƒ½ãƒ¡ãƒ¢ãƒªã®ãƒ—ãƒ¼ãƒ«ã«æˆ»ã•ã­ã°ãªã‚Šã¾ã›ã‚“ã€‚ãã“ã§ã€é©åˆ‡ãªæ™‚ã« :c:func:`free` "
"ã‚’å‘¼ã³å‡ºã™ã“ã¨ãŒé‡è¦ã«ãªã‚Šã¾ã™ã€‚ã‚ã‚‹ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã«å¯¾ã—ã¦ã€ :c:func:`free` "
"ã‚’å‘¼ã°ãªã‹ã£ãŸã«ã‚‚ã‹ã‹ã‚ã‚‰ãšãã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å¿˜å´ã—ã¦ã—ã¾ã†ã¨ã€ãƒ–ãƒ­ãƒƒã‚¯ãŒå æœ‰ã—ã¦ã„ã‚‹ãƒ¡ãƒ¢ãƒªã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒçµ‚äº†ã™ã‚‹ã¾ã§å†åˆ©ç”¨ã§ããªããªã‚Šã¾ã™ã€‚ã“ã‚Œã¯ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯(:dfn:`memory"
" leak`) ã¨å‘¼ã°ã‚Œã¦ã„ã¾ã™ã€‚é€†ã«ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã‚ã‚‹ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã«å¯¾ã—ã¦ :c:func:`free` "
"ã‚’å‘¼ã‚“ã§ãŠããªãŒã‚‰ã€ãã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä½¿ã„ç¶šã‘ã‚ˆã†ã¨ã™ã‚‹ã¨ã€åˆ¥ã® :c:func:`malloc` "
"å‘¼ã³å‡ºã—ã«ã‚ˆã£ã¦è¡Œã‚ã‚Œã‚‹ãƒ–ãƒ­ãƒƒã‚¯ã®å†åˆ©ç”¨ã¨è¡çªã‚’èµ·ã“ã—ã¾ã™ã€‚ã“ã‚Œã¯è§£æ”¾æ¸ˆã¿ãƒ¡ãƒ¢ãƒªã®ä½¿ç”¨ (:dfn:`using freed memory`) "
"ã¨å‘¼ã°ã‚Œã¾ã™ã€‚ã“ã‚Œã¯åˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã™ã‚‹å‚ç…§ã¨åŒæ§˜ã®ã‚ˆããªã„çµæœ --- ã‚³ã‚¢ãƒ€ãƒ³ãƒ—ã€èª¤ã£ãŸå‚ç…§ã€ä¸å¯è§£ãªã‚¯ãƒ©ãƒƒã‚·ãƒ¥ --- "
"ã‚’å¼•ãèµ·ã“ã—ã¾ã™ã€‚"

#: ../../extending/extending.rst:846
msgid ""
"Common causes of memory leaks are unusual paths through the code.  For "
"instance, a function may allocate a block of memory, do some calculation, "
"and then free the block again.  Now a change in the requirements for the "
"function may add a test to the calculation that detects an error condition "
"and can return prematurely from the function.  It's easy to forget to free "
"the allocated memory block when taking this premature exit, especially when "
"it is added later to the code.  Such leaks, once introduced, often go "
"undetected for a long time: the error exit is taken only in a small fraction"
" of all calls, and most modern machines have plenty of virtual memory, so "
"the leak only becomes apparent in a long-running process that uses the "
"leaking function frequently.  Therefore, it's important to prevent leaks "
"from happening by having a coding convention or strategy that minimizes this"
" kind of errors."
msgstr ""
"ã‚ˆãã‚ã‚‹ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã®åŸå› ã¯ã‚³ãƒ¼ãƒ‰ä¸­ã®æ™®é€šã§ãªã„å‡¦ç†çµŒè·¯ã§ã™ã€‚ä¾‹ãˆã°ã€ã‚ã‚‹é–¢æ•°ãŒã‚ã‚‹ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‚’ç¢ºä¿ã—ã€ä½•ã‚‰ã‹ã®è¨ˆç®—ã‚’è¡Œã£ã¦ã€å†åº¦ãƒ–ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã™ã‚‹ã¨ã—ã¾ã™ã€‚ã•ã¦ã€é–¢æ•°ã®è¦æ±‚ä»•æ§˜ã‚’å¤‰æ›´ã—ã¦ã€è¨ˆç®—ã«å¯¾ã™ã‚‹ãƒ†ã‚¹ãƒˆã‚’è¿½åŠ ã™ã‚‹ã¨ã€ã‚¨ãƒ©ãƒ¼æ¡ä»¶ã‚’æ¤œå‡ºã—ã€é–¢æ•°ã®é€”ä¸­ã§å‡¦ç†ã‚’æˆ»ã™ã‚ˆã†ã«ãªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã“ã®é€”ä¸­ã§ã®çµ‚äº†ãŒèµ·ãã‚‹ã¨ãã€ç¢ºä¿ã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã¯è§£æ”¾ã—å¿˜ã‚Œã‚„ã™ã„ã®ã§ã™ã€‚ã‚³ãƒ¼ãƒ‰ãŒå¾Œã§è¿½åŠ ã•ã‚ŒãŸå ´åˆã«ã¯ç‰¹ã«ãã†ã§ã™ã€‚ã“ã®ã‚ˆã†ãªãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ãŒä¸€æ—¦ç´›ã‚Œè¾¼ã‚“ã§ã—ã¾ã†ã¨ã€é•·ã„é–“æ¤œå‡ºã•ã‚Œãªã„ã¾ã¾ã«ãªã‚‹ã“ã¨ãŒã‚ˆãã‚ã‚Šã¾ã™:"
" "
"ã‚¨ãƒ©ãƒ¼ã«ã‚ˆã‚‹é–¢æ•°ã®çµ‚äº†ã¯ã€å…¨ã¦ã®é–¢æ•°å‘¼ã³å‡ºã—ã®ã«å¯¾ã—ã¦ã»ã‚“ã®ã‚ãšã‹ãªå‰²åˆã—ã‹èµ·ããšã€ãã®ä¸€æ–¹ã§ã»ã¨ã‚“ã©ã®è¿‘ä»£çš„ãªè¨ˆç®—æ©Ÿã¯ç›¸å½“é‡ã®ä»®æƒ³è¨˜æ†¶ã‚’æŒã£ã¦ã„ã‚‹ãŸã‚ã€ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ãŒæ˜ã‚‰ã‹ã«ãªã‚‹ã®ã¯ã€é•·ã„é–“å‹•ä½œã—ã¦ã„ãŸãƒ—ãƒ­ã‚»ã‚¹ãŒãƒªãƒ¼ã‚¯ã‚’èµ·ã“ã™é–¢æ•°ã‚’ä½•åº¦ã‚‚ä½¿ã£ãŸå ´åˆã«é™ã‚‰ã‚Œã‚‹ã‹ã‚‰ã§ã™ã€‚å¾“ã£ã¦ã€ã“ã®ç¨®ã®ã‚¨ãƒ©ãƒ¼ã‚’æœ€å°é™ã«ã¨ã©ã‚ã‚‹ã‚ˆã†ãªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¦ç´„ã‚„æˆ¦ç•¥ã‚’è¨­ã‘ã¦ã€ä¸æ…®ã®ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã‚’é¿ã‘ã‚‹ã“ã¨ãŒé‡è¦ãªã®ã§ã™ã€‚"

#: ../../extending/extending.rst:859
msgid ""
"Since Python makes heavy use of :c:func:`malloc` and :c:func:`free`, it "
"needs a strategy to avoid memory leaks as well as the use of freed memory.  "
"The chosen method is called :dfn:`reference counting`.  The principle is "
"simple: every object contains a counter, which is incremented when a "
"reference to the object is stored somewhere, and which is decremented when a"
" reference to it is deleted. When the counter reaches zero, the last "
"reference to the object has been deleted and the object is freed."
msgstr ""
"Python ã¯ :c:func:`malloc` ã‚„ :c:func:`free` "
"ã‚’éå¸¸ã«ã‚ˆãåˆ©ç”¨ã™ã‚‹ãŸã‚ã€ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã®é˜²æ­¢ã«åŠ ãˆã€è§£æ”¾ã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªã®ä½¿ç”¨ã‚’é˜²æ­¢ã™ã‚‹æˆ¦ç•¥ãŒå¿…è¦ã§ã™ã€‚ã“ã®ãŸã‚ã«é¸ã°ã‚ŒãŸã®ãŒå‚ç…§ã‚«ã‚¦ãƒ³ãƒˆæ³• "
"(:dfn:`reference counting`) ã¨å‘¼ã°ã‚Œã‚‹æ‰‹æ³•ã§ã™ã€‚å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆæ³•ã®åŸç†ã¯ç°¡å˜ã§ã™: "
"å…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ã‚«ã‚¦ãƒ³ã‚¿ãŒã‚ã‚Šã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹å‚ç…§ãŒã©ã“ã‹ã«ä¿å­˜ã•ã‚ŒãŸã‚‰ã‚«ã‚¦ãƒ³ã‚¿ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹å‚ç…§ãŒå‰Šé™¤ã•ã‚ŒãŸã‚‰ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã¾ã™ã€‚ã‚«ã‚¦ãƒ³ã‚¿ãŒã‚¼ãƒ­ã«ãªã£ãŸã‚‰ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®æœ€å¾Œã®å‚ç…§ãŒå‰Šé™¤ã•ã‚ŒãŸã“ã¨ã«ãªã‚Šã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯è§£æ”¾ã•ã‚Œã¾ã™ã€‚"

#: ../../extending/extending.rst:867
msgid ""
"An alternative strategy is called :dfn:`automatic garbage collection`. "
"(Sometimes, reference counting is also referred to as a garbage collection "
"strategy, hence my use of \"automatic\" to distinguish the two.)  The big "
"advantage of automatic garbage collection is that the user doesn't need to "
"call :c:func:`free` explicitly.  (Another claimed advantage is an "
"improvement in speed or memory usage --- this is no hard fact however.)  The"
" disadvantage is that for C, there is no truly portable automatic garbage "
"collector, while reference counting can be implemented portably (as long as "
"the functions :c:func:`malloc` and :c:func:`free` are available --- which "
"the C Standard guarantees). Maybe some day a sufficiently portable automatic"
" garbage collector will be available for C. Until then, we'll have to live "
"with reference counts."
msgstr ""
"ã‚‚ã†ä¸€ã¤ã®æˆ¦ç•¥ã¯è‡ªå‹•ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ (:dfn:`automatic garbage collection`) ã¨å‘¼ã°ã‚Œã¦ã„ã¾ã™ã€‚ "
"(å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆæ³•ã¯ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³æˆ¦ç•¥ã®ä¸€ã¤ã¨ã—ã¦æŒ™ã’ã‚‰ã‚Œã‚‹ã“ã¨ã‚‚ã‚ã‚‹ã®ã§ã€äºŒã¤ã‚’åŒºåˆ¥ã™ã‚‹ãŸã‚ã«ç­†è€…ã¯ \"è‡ªå‹• (automatic)\" "
"ã‚’ä½¿ã£ã¦ã„ã¾ã™ã€‚) è‡ªå‹•ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®å¤§ããªåˆ©ç‚¹ã¯ã€ãƒ¦ãƒ¼ã‚¶ãŒ :c:func:`free` ã‚’æ˜ç¤ºçš„ã«ã‚ˆã°ãªãã¦ã‚ˆã„ã“ã¨ã«ã‚ã‚Šã¾ã™ã€‚ "
"(é€Ÿåº¦ã‚„ãƒ¡ãƒ¢ãƒªã®æœ‰åŠ¹åˆ©ç”¨æ€§ã‚‚åˆ©ç‚¹ã¨ã—ã¦ä¸»å¼µã•ã‚Œã¦ã„ã¾ã™ --- ãŒã€ã“ã‚Œã¯ç¢ºãŸã‚‹äº‹å®Ÿã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚) C "
"ã«ãŠã‘ã‚‹è‡ªå‹•ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®æ¬ ç‚¹ã¯ã€çœŸã«å¯æ¬æ€§ã®ã‚ã‚‹ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚¿ãŒå­˜åœ¨ã—ãªã„ã¨ã„ã†ã“ã¨ã§ã™ã€‚ãã‚Œã«å¯¾ã—ã€å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆæ³•ã¯å¯æ¬æ€§ã®ã‚ã‚‹å®Ÿè£…ãŒã§ãã¾ã™"
" (:c:func:`malloc` ã‚„ :c:func:`free` ã‚’åˆ©ç”¨ã§ãã‚‹ã®ãŒå‰æã§ã™ --- C "
"æ¨™æº–ã¯ã“ã‚Œã‚’ä¿è¨¼ã—ã¦ã„ã¾ã™)ã€‚ã„ã¤ã®æ—¥ã‹ã€ååˆ†å¯æ¬æ€§ã®ã‚ã‚‹ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚¿ãŒ C "
"ã§ä½¿ãˆã‚‹ã‚ˆã†ã«ãªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€ãã‚Œã¾ã§ã¯å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆæ³•ã§ã‚„ã£ã¦ã„ãä»¥å¤–ã«ã¯ãªã„ã®ã§ã™ã€‚"

#: ../../extending/extending.rst:879
msgid ""
"While Python uses the traditional reference counting implementation, it also"
" offers a cycle detector that works to detect reference cycles.  This allows"
" applications to not worry about creating direct or indirect circular "
"references; these are the weakness of garbage collection implemented using "
"only reference counting.  Reference cycles consist of objects which contain "
"(possibly indirect) references to themselves, so that each object in the "
"cycle has a reference count which is non-zero.  Typical reference counting "
"implementations are not able to reclaim the memory belonging to any objects "
"in a reference cycle, or referenced from the objects in the cycle, even "
"though there are no further references to the cycle itself."
msgstr ""
"Python ã§ã¯ã€ä¼çµ±çš„ãªå‚ç…§ã‚«ã‚¦ãƒ³ãƒˆæ³•ã®å®Ÿè£…ã‚’è¡Œã£ã¦ã„ã‚‹ä¸€æ–¹ã§ã€å‚ç…§ã®å¾ªç’°ã‚’æ¤œå‡ºã™ã‚‹ãŸã‚ã«åƒãå¾ªç’°å‚ç…§æ¤œå‡ºæ©Ÿæ§‹ (cycle detector) "
"ã‚‚æä¾›ã—ã¦ã„ã¾ã™ã€‚å¾ªç’°å‚ç…§æ¤œå‡ºæ©Ÿæ§‹ã®ãŠã‹ã’ã§ã€ç›´æ¥ã€é–“æ¥ã«ã‹ã‹ã‚ã‚‰ãšå¾ªç’°å‚ç…§ã®ç”Ÿæˆã‚’æ°—ã«ã›ãšã«ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ§‹ç¯‰ã§ãã¾ã™; "
"ã¨ã„ã†ã®ã‚‚ã€å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆæ³•ã ã‘ã‚’ä½¿ã£ãŸã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè£…ã«ã¨ã£ã¦å¾ªç’°å‚ç…§ã¯å¼±ç‚¹ã ã‹ã‚‰ã§ã™ã€‚å¾ªç’°å‚ç…§ã¯ã€(é–“æ¥å‚ç…§ã®å ´åˆã‚‚å«ã‚ã¦) "
"ç›¸äº’ã¸ã®å‚ç…§ãŒå…¥ã£ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰å½¢æˆã•ã‚Œã‚‹ãŸã‚ã€å¾ªç’°å†…ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å„ã€…éã‚¼ãƒ­ã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’æŒã¡ã¾ã™ã€‚å…¸å‹çš„ãªå‚ç…§ã‚«ã‚¦ãƒ³ãƒˆæ³•ã®å®Ÿè£…ã§ã¯ã€ãŸã¨ãˆå¾ªç’°å‚ç…§ã‚’å½¢æˆã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ä»–ã«å…¨ãå‚ç…§ãŒãªã„ã¨ã—ã¦ã‚‚ã€å¾ªç’°å‚ç…§å†…ã®ã©ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å±ã™ã‚‹ãƒ¡ãƒ¢ãƒªã‚‚å†åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚"

#: ../../extending/extending.rst:890
msgid ""
"The cycle detector is able to detect garbage cycles and can reclaim them. "
"The :mod:`gc` module exposes a way to run the detector (the "
":func:`~gc.collect` function), as well as configuration interfaces and the "
"ability to disable the detector at runtime.  The cycle detector is "
"considered an optional component; though it is included by default, it can "
"be disabled at build time using the :option:`!--without-cycle-gc` option to "
"the :program:`configure` script on Unix platforms (including Mac OS X).  If "
"the cycle detector is disabled in this way, the :mod:`gc` module will not be"
" available."
msgstr ""
"å¾ªç’°å‚ç…§æ¤œå‡ºå™¨ã¯å¾ªç’°å‚ç…§ã‚’å½¢æˆã—ã¦ã„ã‚‹ã‚´ãƒŸã‚’è¦‹ä»˜ã‘å›åã™ã‚‹ã“ã¨ã§ãã¾ã™ã€‚\n"
":mod:`gc` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€å®Ÿè¡Œæ™‚ã«æ¤œå‡ºå™¨ã‚’ç„¡åŠ¹ã«ã™ã‚‹è¨­å®šã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã ã‘ã§ãªãã€æ¤œå‡ºå™¨ã‚’èµ°ã‚‰ã›ã‚‹æ‰‹æ®µ (:func:`~gc.collect` é–¢æ•°) ã‚‚æä¾›ã—ã¾ã™ã€‚\n"
"å¾ªç’°å‚ç…§æ¤œå‡ºå™¨ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã ã¨è¦‹ãªã•ã‚Œã¾ã™;\n"
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯å«ã¾ã‚Œã¦ã„ã¾ã™ãŒã€ (Mac OS X ã‚’å«ã‚€) Unix ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã® :program:`configure` ã‚¹ã‚¯ãƒªãƒ—ãƒˆã§ :option:`!--without-cycle-gc` ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’ä½¿ã†ã“ã¨ã§ã€ãƒ“ãƒ«ãƒ‰æ™‚ã«ç„¡åŠ¹åŒ–ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚\n"
"å¾ªç’°å‚ç…§æ¤œå‡ºå™¨ãŒã“ã®æ–¹æ³•ã§ç„¡åŠ¹åŒ–ã•ã‚ŒãŸå ´åˆã€ :mod:`gc` ã¯åˆ©ç”¨ã§ããªããªã‚Šã¾ã™ã€‚"

#: ../../extending/extending.rst:904
msgid "Reference Counting in Python"
msgstr "Python ã«ãŠã‘ã‚‹å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆæ³•"

#: ../../extending/extending.rst:906
msgid ""
"There are two macros, ``Py_INCREF(x)`` and ``Py_DECREF(x)``, which handle "
"the incrementing and decrementing of the reference count. "
":c:func:`Py_DECREF` also frees the object when the count reaches zero. For "
"flexibility, it doesn't call :c:func:`free` directly --- rather, it makes a "
"call through a function pointer in the object's :dfn:`type object`.  For "
"this purpose (and others), every object also contains a pointer to its type "
"object."
msgstr ""
"Python ã«ã¯ã€å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã®ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã‚„ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã‚’å‡¦ç†ã™ã‚‹äºŒã¤ã®ãƒã‚¯ãƒ­ã€ ``Py_INCREF(x)`` ã¨ "
"``Py_DECREF(x)`` ãŒã‚ã‚Šã¾ã™ã€‚ :c:func:`Py_DECREF` "
"ã¯ã€å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒã‚¼ãƒ­ã«åˆ°é”ã—ãŸéš›ã«ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ãƒ¢ãƒªè§£æ”¾ã‚‚è¡Œã„ã¾ã™ã€‚æŸ”è»Ÿæ€§ã‚’æŒãŸã›ã‚‹ãŸã‚ã«ã€ :c:func:`free` ã‚’ç›´æ¥å‘¼ã³å‡ºã—ã¾ã›ã‚“ "
"--- ãã®ä»£ã‚ã‚Šã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (:dfn:`type object`) ã‚’ä»‹ã—ã¾ã™ã€‚ã“ã®ãŸã‚ã« "
"(ä»–ã®ç›®çš„ã‚‚ã‚ã‚Šã¾ã™ãŒ)ã€å…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯è‡ªèº«ã®å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹ãƒã‚¤ãƒ³ã‚¿ãŒå…¥ã£ã¦ã„ã¾ã™ã€‚"

#: ../../extending/extending.rst:913
msgid ""
"The big question now remains: when to use ``Py_INCREF(x)`` and "
"``Py_DECREF(x)``? Let's first introduce some terms.  Nobody \"owns\" an "
"object; however, you can :dfn:`own a reference` to an object.  An object's "
"reference count is now defined as the number of owned references to it.  The"
" owner of a reference is responsible for calling :c:func:`Py_DECREF` when "
"the reference is no longer needed.  Ownership of a reference can be "
"transferred.  There are three ways to dispose of an owned reference: pass it"
" on, store it, or call :c:func:`Py_DECREF`. Forgetting to dispose of an "
"owned reference creates a memory leak."
msgstr ""
"ã•ã¦ã€ã¾ã é‡å¤§ãªç–‘å•ãŒæ®‹ã£ã¦ã„ã¾ã™: ã„ã¤ ``Py_INCREF(x)`` ã‚„ ``Py_DECREF(x)`` ã‚’ä½¿ãˆã°ã‚ˆã„ã®ã§ã—ã‚‡ã†ã‹? "
"ã¾ãšã€ã„ãã¤ã‹ã®ç”¨èªèª¬æ˜ã‹ã‚‰å§‹ã‚ã•ã›ã¦ãã ã•ã„ã€‚ã¾ãšã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ \"å æœ‰ (own)\" ã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“; "
"ã—ã‹ã—ã€ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹å‚ç…§ã®æ‰€æœ‰ :dfn:`own a reference` "
"ã¯ã§ãã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã¯ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå‚ç…§ã®æ‰€æœ‰ã‚’å—ã‘ã¦ã„ã‚‹å›æ•°ã¨å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚å‚ç…§ã®æ‰€æœ‰è€…ã¯ã€å‚ç…§ãŒå¿…è¦ãªããªã£ãŸéš›ã« "
":c:func:`Py_DECREF` ã‚’å‘¼ã³å‡ºã™å½¹å‰²ã‚’æ‹…ã„ã¾ã™ã€‚å‚ç…§ã®æ‰€æœ‰æ¨©ã¯å§”è­² (transfer) ã§ãã¾ã™ã€‚æ‰€æœ‰å‚ç…§ (owned "
"reference) ã®æ”¾æ£„ã«ã¯ã€æ¸¡ã™ã€ä¿å­˜ã™ã‚‹ã€ :c:func:`Py_DECREF` "
"ã‚’å‘¼ã³å‡ºã™ã€ã¨ã„ã†ä¸‰ã¤ã®æ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚æ‰€æœ‰å‚ç…§ã‚’å‡¦ç†ã—å¿˜ã‚Œã‚‹ã¨ã€ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã‚’å¼•ãèµ·ã“ã—ã¾ã™ã€‚"

#: ../../extending/extending.rst:922
msgid ""
"It is also possible to :dfn:`borrow` [#]_ a reference to an object.  The "
"borrower of a reference should not call :c:func:`Py_DECREF`.  The borrower "
"must not hold on to the object longer than the owner from which it was "
"borrowed. Using a borrowed reference after the owner has disposed of it "
"risks using freed memory and should be avoided completely [#]_."
msgstr ""

#: ../../extending/extending.rst:928
msgid ""
"The advantage of borrowing over owning a reference is that you don't need to"
" take care of disposing of the reference on all possible paths through the "
"code --- in other words, with a borrowed reference you don't run the risk of"
" leaking when a premature exit is taken.  The disadvantage of borrowing over"
" owning is that there are some subtle situations where in seemingly correct "
"code a borrowed reference can be used after the owner from which it was "
"borrowed has in fact disposed of it."
msgstr ""
"å‚ç…§ã®å€Ÿç”¨ãŒå‚ç…§ã®æ‰€æœ‰ã‚ˆã‚Šã‚‚å„ªã‚Œã¦ã„ã‚‹ç‚¹ã¯ã€ã‚³ãƒ¼ãƒ‰ãŒã¨ã‚Šã†ã‚‹ã‚ã‚‰ã‚†ã‚‹å‡¦ç†çµŒè·¯ã§å‚ç…§ã‚’å»ƒæ£„ã—ã¦ãŠãã‚ˆã†æ³¨æ„ã—ãªãã¦æ¸ˆã‚€ã“ã¨ã§ã™ --- "
"åˆ¥ã®è¨€ã„æ–¹ã‚’ã™ã‚Œã°ã€å€Ÿç”¨å‚ç…§ã®å ´åˆã«ã¯ã€å‡¦ç†ã®é€”ä¸­ã§é–¢æ•°ã‚’çµ‚äº†ã—ã¦ã‚‚ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã®å±é™ºã‚’å†’ã™ã“ã¨ãŒãªã„ã€ã¨ã„ã†ã“ã¨ã§ã™ã€‚é€†ã«ã€æ‰€æœ‰ã‚ˆã‚Šã‚‚ä¸åˆ©ãªç‚¹ã¯ã€ã”ãã¾ã¨ã‚‚ã«è¦‹ãˆã‚‹ã‚³ãƒ¼ãƒ‰ãŒã€å®Ÿéš›ã«ã¯å‚ç…§ã®å€Ÿç”¨å…ƒã§æ”¾æ£„ã•ã‚Œã¦ã—ã¾ã£ãŸå¾Œã«ãã®å‚ç…§ã‚’ä½¿ã†ã‹ã‚‚ã—ã‚Œãªã„ã‚ˆã†ãªå¾®å¦™ãªçŠ¶æ³ãŒã‚ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚"

#: ../../extending/extending.rst:936
msgid ""
"A borrowed reference can be changed into an owned reference by calling "
":c:func:`Py_INCREF`.  This does not affect the status of the owner from "
"which the reference was borrowed --- it creates a new owned reference, and "
"gives full owner responsibilities (the new owner must dispose of the "
"reference properly, as well as the previous owner)."
msgstr ""
":c:func:`Py_INCREF` ã‚’å‘¼ã³å‡ºã™ã¨ã€å€Ÿç”¨å‚ç…§ã‚’æ‰€æœ‰å‚ç…§ã«å¤‰æ›´ã§ãã¾ã™ã€‚ã“ã®æ“ä½œã¯å‚ç…§ã®å€Ÿç”¨å…ƒã®çŠ¶æ…‹ã«ã¯å½±éŸ¿ã—ã¾ã›ã‚“ --- "
":c:func:`Py_INCREF` ã¯æ–°ãŸãªæ‰€æœ‰å‚ç…§ã‚’ç”Ÿæˆã—ã€å‚ç…§ã®æ‰€æœ‰è€…ãŒæ‹…ã†ã¹ãå…¨ã¦ã®è²¬ä»»ã‚’èª²ã—ã¾ã™ "
"(ã¤ã¾ã‚Šã€æ–°ãŸãªå‚ç…§ã®æ‰€æœ‰è€…ã¯ã€ä»¥å‰ã®æ‰€æœ‰è€…ã¨åŒæ§˜ã€å‚ç…§ã®æ”¾æ£„ã‚’é©åˆ‡ã«è¡Œã‚ã­ã°ãªã‚Šã¾ã›ã‚“)ã€‚"

#: ../../extending/extending.rst:946
msgid "Ownership Rules"
msgstr "æ‰€æœ‰æ¨©ã«ã¾ã¤ã‚ã‚‹è¦å‰‡"

#: ../../extending/extending.rst:948
msgid ""
"Whenever an object reference is passed into or out of a function, it is part"
" of the function's interface specification whether ownership is transferred "
"with the reference or not."
msgstr ""
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’é–¢æ•°ã®å†…å¤–ã«æ¸¡ã™å ´åˆã«ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ‰€æœ‰æ¨©ãŒå‚ç…§ã¨å…±ã«æ¸¡ã•ã‚Œã‚‹ã‹å¦ã‹ãŒå¸¸ã«é–¢æ•°ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ä»•æ§˜ã®ä¸€éƒ¨ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../extending/extending.rst:952
msgid ""
"Most functions that return a reference to an object pass on ownership with "
"the reference.  In particular, all functions whose function it is to create "
"a new object, such as :c:func:`PyLong_FromLong` and :c:func:`Py_BuildValue`,"
" pass ownership to the receiver.  Even if the object is not actually new, "
"you still receive ownership of a new reference to that object.  For "
"instance, :c:func:`PyLong_FromLong` maintains a cache of popular values and "
"can return a reference to a cached item."
msgstr ""
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’è¿”ã™ã»ã¨ã‚“ã©ã®é–¢æ•°ã¯ã€å‚ç…§ã¨ã¨ã‚‚ã«æ‰€æœ‰æ¨©ã‚‚æ¸¡ã—ã¾ã™ã€‚ç‰¹ã«ã€ :c:func:`PyLong_FromLong` ã‚„ "
":c:func:`Py_BuildValue` "
"ã®ã‚ˆã†ã«ã€æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°ã¯å…¨ã¦æ‰€æœ‰æ¨©ã‚’ç›¸æ‰‹ã«æ¸¡ã—ã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå®Ÿéš›ã«ã¯æ–°ãŸãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªãã¦ã‚‚ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹æ–°ãŸãªå‚ç…§ã®æ‰€æœ‰æ¨©ã‚’å¾—ã¾ã™ã€‚ä¾‹ãˆã°ã€"
" :c:func:`PyLong_FromLong` ã¯ã‚ˆãä½¿ã†å€¤ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ã¦ãŠã‚Šã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸå€¤ã¸ã®å‚ç…§ã‚’è¿”ã™ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../extending/extending.rst:960
msgid ""
"Many functions that extract objects from other objects also transfer "
"ownership with the reference, for instance :c:func:`PyObject_GetAttrString`."
"  The picture is less clear, here, however, since a few common routines are "
"exceptions: :c:func:`PyTuple_GetItem`, :c:func:`PyList_GetItem`, "
":c:func:`PyDict_GetItem`, and :c:func:`PyDict_GetItemString` all return "
"references that you borrow from the tuple, list or dictionary."
msgstr ""
":c:func:`PyObject_GetAttrString` "
"ã®ã‚ˆã†ã«ã€ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰åˆ¥ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŠ½å‡ºã™ã‚‹ã‚ˆã†ãªé–¢æ•°ã‚‚ã¾ãŸã€å‚ç…§ã¨ã¨ã‚‚ã«æ‰€æœ‰æ¨©ã‚’å§”è­²ã—ã¾ã™ã€‚ã“ã¡ã‚‰ã®æ–¹ã¯ã‚„ã‚„ç†è§£ã—ã«ãã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã¨ã„ã†ã®ã¯ã‚ˆãä½¿ã‚ã‚Œã‚‹ãƒ«ãƒ¼ãƒãƒ³ã®ã„ãã¤ã‹ãŒä¾‹å¤–ã¨ãªã£ã¦ã„ã‚‹ã‹ã‚‰ã§ã™:"
" :c:func:`PyTuple_GetItem` ã€ :c:func:`PyList_GetItem` ã€ "
":c:func:`PyDict_GetItem` ã€ãŠã‚ˆã³ :c:func:`PyDict_GetItemString` "
"ã¯å…¨ã¦ã€ã‚¿ãƒ—ãƒ«ã€ãƒªã‚¹ãƒˆã€ã¾ãŸã¯è¾æ›¸ã‹ã‚‰å€Ÿç”¨å‚ç…§ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../extending/extending.rst:967
msgid ""
"The function :c:func:`PyImport_AddModule` also returns a borrowed reference,"
" even though it may actually create the object it returns: this is possible "
"because an owned reference to the object is stored in ``sys.modules``."
msgstr ""
":c:func:`PyImport_AddModule` ã¯ã€å®Ÿéš›ã«ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã—ã¦è¿”ã™ã“ã¨ãŒã‚ã‚‹ã«ã‚‚ã‹ã‹ã‚ã‚‰ãšã€å€Ÿç”¨å‚ç…§ã‚’è¿”ã—ã¾ã™: "
"ã“ã‚ŒãŒå¯èƒ½ãªã®ã¯ã€ç”Ÿæˆã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹æ‰€æœ‰å‚ç…§ã¯ ``sys.modules`` ã«ä¿æŒã•ã‚Œã‚‹ã‹ã‚‰ã§ã™ã€‚"

#: ../../extending/extending.rst:971
msgid ""
"When you pass an object reference into another function, in general, the "
"function borrows the reference from you --- if it needs to store it, it will"
" use :c:func:`Py_INCREF` to become an independent owner.  There are exactly "
"two important exceptions to this rule: :c:func:`PyTuple_SetItem` and "
":c:func:`PyList_SetItem`.  These functions take over ownership of the item "
"passed to them --- even if they fail!  (Note that :c:func:`PyDict_SetItem` "
"and friends don't take over ownership --- they are \"normal.\")"
msgstr ""
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’åˆ¥ã®é–¢æ•°ã«æ¸¡ã™å ´åˆã€ä¸€èˆ¬çš„ã«ã¯ã€é–¢æ•°å´ã¯å‘¼ã³å‡ºã—æ‰‹ã‹ã‚‰å‚ç…§ã‚’å€Ÿç”¨ã—ã¾ã™ --- å‚ç…§ã‚’ä¿å­˜ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãªã‚‰ã€é–¢æ•°å´ã¯ "
":c:func:`Py_INCREF` ã‚’å‘¼ã³å‡ºã—ã¦ç‹¬ç«‹ã—ãŸæ‰€æœ‰è€…ã«ãªã‚Šã¾ã™ã€‚ã¨ã¯ã„ãˆã€ã“ã®è¦å‰‡ã«ã¯äºŒã¤ã®é‡è¦ãªä¾‹å¤–: "
":c:func:`PyTuple_SetItem` ã¨ :c:func:`PyList_SetItem` "
"ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã®é–¢æ•°ã¯ã€æ¸¡ã•ã‚ŒãŸå¼•æ•°è¦ç´ ã«å¯¾ã—ã¦æ‰€æœ‰æ¨©ã‚’ä¹—ã£å–ã‚Š (take over) ã¾ã™ --- ãŸã¨ãˆå¤±æ•—ã—ã¦ã‚‚ã§ã™! "
"(:c:func:`PyDict_SetItem` ã¨ãã®ä»²é–“ã¯æ‰€æœ‰æ¨©ã‚’ä¹—ã£å–ã‚Šã¾ã›ã‚“ --- ã“ã‚Œã‚‰ã¯ã„ã‚ã° \"æ™®é€šã®\" é–¢æ•°ã§ã™ã€‚)"

#: ../../extending/extending.rst:979
msgid ""
"When a C function is called from Python, it borrows references to its "
"arguments from the caller.  The caller owns a reference to the object, so "
"the borrowed reference's lifetime is guaranteed until the function returns."
"  Only when such a borrowed reference must be stored or passed on, it must "
"be turned into an owned reference by calling :c:func:`Py_INCREF`."
msgstr ""
"Python ã‹ã‚‰ C é–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹éš›ã«ã¯ã€C é–¢æ•°ã¯å‘¼ã³å‡ºã—å´ã‹ã‚‰å¼•æ•°ã¸ã®å‚ç…§ã‚’å€Ÿç”¨ã—ã¾ã™ã€‚C "
"é–¢æ•°ã®å‘¼ã³å‡ºã—å´ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’æ‰€æœ‰ã—ã¦ã„ã‚‹ã®ã§ã€å€Ÿç”¨å‚ç…§ã®ç”Ÿå­˜æœŸé–“ãŒä¿è¨¼ã•ã‚Œã‚‹ã®ã¯é–¢æ•°ãŒå‡¦ç†ã‚’è¿”ã™ã¾ã§ã§ã™ã€‚ã“ã®ã‚ˆã†ã«ã—ã¦å€Ÿç”¨å‚ç…§ã‚’ä¿å­˜ã—ãŸã‚Šä»–ã«æ¸¡ã—ãŸã‚Šã—ãŸã„å ´åˆã«ã®ã¿ã€"
" :c:func:`Py_INCREF` ã‚’ä½¿ã£ã¦æ‰€æœ‰å‚ç…§ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../extending/extending.rst:985
msgid ""
"The object reference returned from a C function that is called from Python "
"must be an owned reference --- ownership is transferred from the function to"
" its caller."
msgstr "Python ã‹ã‚‰å‘¼ã³å‡ºã•ã‚ŒãŸ C é–¢æ•°ãŒè¿”ã™å‚ç…§ã¯æ‰€æœ‰å‚ç…§ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ --- æ‰€æœ‰æ¨©ã¯é–¢æ•°ã‹ã‚‰å‘¼ã³å‡ºã—å´ã¸ã¨å§”è­²ã•ã‚Œã¾ã™ã€‚"

#: ../../extending/extending.rst:993
msgid "Thin Ice"
msgstr "è–„æ°·"

#: ../../extending/extending.rst:995
msgid ""
"There are a few situations where seemingly harmless use of a borrowed "
"reference can lead to problems.  These all have to do with implicit "
"invocations of the interpreter, which can cause the owner of a reference to "
"dispose of it."
msgstr ""
"æ•°å°‘ãªã„çŠ¶æ³ã«ãŠã„ã¦ã€ä¸€è¦‹ç„¡å®³ã«è¦‹ãˆã‚‹å€Ÿç”¨å‚ç…§ã®åˆ©ç”¨ãŒå•é¡Œã‚’ã²ããŠã“ã™ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®å•é¡Œã¯ã™ã¹ã¦ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒéæ˜ç¤ºçš„ã«å‘¼ã³å‡ºã•ã‚Œã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒå‚ç…§ã®æ‰€æœ‰è€…ã«å‚ç…§ã‚’æ”¾æ£„ã•ã›ã¦ã—ã¾ã†çŠ¶æ³ã¨é–¢ä¿‚ã—ã¦ã„ã¾ã™ã€‚"

#: ../../extending/extending.rst:999
msgid ""
"The first and most important case to know about is using :c:func:`Py_DECREF`"
" on an unrelated object while borrowing a reference to a list item.  For "
"instance::"
msgstr ""
"çŸ¥ã£ã¦ãŠãã¹ãã‚±ãƒ¼ã‚¹ã®ã†ã¡æœ€åˆã®ã€ãã—ã¦æœ€ã‚‚é‡è¦ãªã‚‚ã®ã¯ã€ãƒªã‚¹ãƒˆè¦ç´ ã«å¯¾ã™ã‚‹å‚ç…§ã‚’å€Ÿã‚Šã¦ã„ã‚‹éš›ã«èµ·ãã‚‹ã€é–¢ä¿‚ãªã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹ "
":c:func:`Py_DECREF` ã®ä½¿ç”¨ã§ã™ã€‚ä¾‹ãˆã°::"

#: ../../extending/extending.rst:1011
msgid ""
"This function first borrows a reference to ``list[0]``, then replaces "
"``list[1]`` with the value ``0``, and finally prints the borrowed reference."
" Looks harmless, right?  But it's not!"
msgstr ""
"ä¸Šã®é–¢æ•°ã¯ã¾ãšã€ ``list[0]`` ã¸ã®å‚ç…§ã‚’å€Ÿç”¨ã—ã€æ¬¡ã« ``list[1]`` ã‚’å€¤ ``0`` "
"ã§ç½®ãæ›ãˆã€æœ€å¾Œã«ã•ãã»ã©å€Ÿç”¨ã—ãŸå‚ç…§ã‚’å‡ºåŠ›ã—ã¦ã„ã¾ã™ã€‚ä½•ã‚‚å•é¡Œãªã„ã‚ˆã†ã«è¦‹ãˆã¾ã™ã­? ã§ã‚‚ãã†ã§ã¯ãªã„ã®ã§ã™!"

#: ../../extending/extending.rst:1015
msgid ""
"Let's follow the control flow into :c:func:`PyList_SetItem`.  The list owns "
"references to all its items, so when item 1 is replaced, it has to dispose "
"of the original item 1.  Now let's suppose the original item 1 was an "
"instance of a user-defined class, and let's further suppose that the class "
"defined a :meth:`__del__` method.  If this class instance has a reference "
"count of 1, disposing of it will call its :meth:`__del__` method."
msgstr ""
":c:func:`PyList_SetItem` ã®å‡¦ç†ã®æµã‚Œã‚’è¿½è·¡ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚ãƒªã‚¹ãƒˆã¯å…¨ã¦ã®è¦ç´ ã«å¯¾ã—ã¦å‚ç…§ã‚’æ‰€æœ‰ã—ã¦ã„ã‚‹ã®ã§ã€è¦ç´  1 "
"ã‚’ç½®ãæ›ãˆã‚‹ã¨ã€ä»¥å‰ã®è¦ç´  1 ã‚’æ”¾æ£„ã—ã¾ã™ã€‚ã“ã“ã§ã€ä»¥å‰ã®è¦ç´  1 ãŒãƒ¦ãƒ¼ã‚¶å®šç¾©ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚Šã€ã•ã‚‰ã«ã“ã®ã‚¯ãƒ©ã‚¹ãŒ "
":meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã„ã‚‹ã¨ä»®å®šã—ã¾ã—ã‚‡ã†ã€‚ã“ã®ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒ 1 "
"ã ã£ãŸå ´åˆã€ãƒªã‚¹ãƒˆãŒå‚ç…§ã‚’æ”¾æ£„ã™ã‚‹ã¨ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã® :meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../extending/extending.rst:1022
msgid ""
"Since it is written in Python, the :meth:`__del__` method can execute "
"arbitrary Python code.  Could it perhaps do something to invalidate the "
"reference to ``item`` in :c:func:`bug`?  You bet!  Assuming that the list "
"passed into :c:func:`bug` is accessible to the :meth:`__del__` method, it "
"could execute a statement to the effect of ``del list[0]``, and assuming "
"this was the last reference to that object, it would free the memory "
"associated with it, thereby invalidating ``item``."
msgstr ""
"ã‚¯ãƒ©ã‚¹ã¯ Python ã§æ›¸ã‹ã‚Œã¦ã„ã‚‹ã®ã§ã€ :meth:`__del__` ã¯ä»»æ„ã® Python ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã§ãã¾ã™ã€‚ã“ã® "
":meth:`__del__` ãŒ :c:func:`bug` ã«ãŠã‘ã‚‹ ``item`` ã«ä½•ã‹ä¸æ­£ãªã“ã¨ã‚’ã—ã¦ã„ã‚‹ã®ã§ã—ã‚‡ã†ã‹? ãã®é€šã‚Š! "
":c:func:`bug` ã«æ¸¡ã—ãŸãƒªã‚¹ãƒˆãŒ :meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰æ“ä½œã§ãã‚‹ã¨ã™ã‚‹ã¨ã€ ``del list[0]`` "
"ã®åŠ¹æœã‚’æŒã¤ã‚ˆã†ãªæ–‡ã‚’å®Ÿè¡Œã§ãã¦ã—ã¾ã„ã¾ã™ã€‚ã‚‚ã—ã“ã®æ“ä½œã§ ``list[0]`` ã«å¯¾ã™ã‚‹æœ€å¾Œã®å‚ç…§ãŒæ”¾æ£„ã•ã‚Œã¦ã—ã¾ã†ã¨ã€ ``list[0]`` "
"ã«é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ãŸãƒ¡ãƒ¢ãƒªã¯è§£æ”¾ã•ã‚Œã€çµæœçš„ã« ``item`` ã¯ç„¡åŠ¹ãªå€¤ã«ãªã£ã¦ã—ã¾ã„ã¾ã™ã€‚"

#: ../../extending/extending.rst:1030
msgid ""
"The solution, once you know the source of the problem, is easy: temporarily "
"increment the reference count.  The correct version of the function reads::"
msgstr "å•é¡Œã®åŸå› ãŒåˆ†ã‹ã‚Œã°ã€è§£æ±ºã¯ç°¡å˜ã§ã™ã€‚ä¸€æ™‚çš„ã«å‚ç…§å›æ•°ã‚’å¢—ã‚„ã›ã°ã‚ˆã„ã®ã§ã™ã€‚æ­£ã—ãå‹•ä½œã™ã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../extending/extending.rst:1044
msgid ""
"This is a true story.  An older version of Python contained variants of this"
" bug and someone spent a considerable amount of time in a C debugger to "
"figure out why his :meth:`__del__` methods would fail..."
msgstr ""
"ã“ã‚Œã¯å®Ÿéš›ã«ã‚ã£ãŸè©±ã§ã™ã€‚ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® Python ã«ã¯ã€ã“ã®ãƒã‚°ã®ä¸€ç¨®ãŒæ½œã‚“ã§ã„ã¦ã€ :meth:`__del__` "
"ãƒ¡ã‚½ãƒƒãƒ‰ãŒã©ã†ã—ã¦ã†ã¾ãå‹•ã‹ãªã„ã®ã‹ã‚’èª¿ã¹ã‚‹ãŸã‚ã« C ãƒ‡ãƒãƒƒã‚¬ã§ç›¸å½“æ™‚é–“ã‚’è²»ã‚„ã—ãŸäººãŒã„ã¾ã—ãŸ..."

#: ../../extending/extending.rst:1048
msgid ""
"The second case of problems with a borrowed reference is a variant involving"
" threads.  Normally, multiple threads in the Python interpreter can't get in"
" each other's way, because there is a global lock protecting Python's entire"
" object space.  However, it is possible to temporarily release this lock "
"using the macro :c:macro:`Py_BEGIN_ALLOW_THREADS`, and to re-acquire it "
"using :c:macro:`Py_END_ALLOW_THREADS`.  This is common around blocking I/O "
"calls, to let other threads use the processor while waiting for the I/O to "
"complete. Obviously, the following function has the same problem as the "
"previous one::"
msgstr ""
"äºŒã¤ç›®ã¯ã€å€Ÿç”¨å‚ç…§ãŒã‚¹ãƒ¬ãƒƒãƒ‰ã«é–¢ä¿‚ã—ã¦ã„ã‚‹ã‚±ãƒ¼ã‚¹ã§ã™ã€‚é€šå¸¸ã¯ã€ Python "
"ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ãŠã‘ã‚‹è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãƒ­ãƒƒã‚¯ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç©ºé–“å…¨ä½“ã‚’ä¿è­·ã—ã¦ã„ã‚‹ãŸã‚ã€äº’ã„ã«é‚ªé­”ã—åˆã†ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã¨ã¯ã„ãˆã€ãƒ­ãƒƒã‚¯ã¯"
" :c:macro:`Py_BEGIN_ALLOW_THREADS` ãƒã‚¯ãƒ­ã§ä¸€æ™‚çš„ã«è§£é™¤ã—ãŸã‚Šã€ "
":c:macro:`Py_END_ALLOW_THREADS` ã§å†ç²å¾—ã—ãŸã‚Šã§ãã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒã‚¯ãƒ­ã¯ãƒ–ãƒ­ãƒƒã‚¯ã®èµ·ã“ã‚‹ I/O "
"å‘¼ã³å‡ºã—ã®å‘¨å›²ã«ã‚ˆãç½®ã‹ã‚Œã€ I/O "
"ãŒå®Œäº†ã™ã‚‹ã¾ã§ã®é–“ã«ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ—ãƒ­ã‚»ãƒƒã‚µã‚’åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚æ˜ã‚‰ã‹ã«ã€ä»¥ä¸‹ã®é–¢æ•°ã¯ä¸Šã®ä¾‹ã¨ä¼¼ãŸå•é¡Œã‚’ã¯ã‚‰ã‚“ã§ã„ã¾ã™::"

#: ../../extending/extending.rst:1071
msgid "NULL Pointers"
msgstr "NULL ãƒã‚¤ãƒ³ã‚¿"

#: ../../extending/extending.rst:1073
msgid ""
"In general, functions that take object references as arguments do not expect"
" you to pass them *NULL* pointers, and will dump core (or cause later core "
"dumps) if you do so.  Functions that return object references generally "
"return *NULL* only to indicate that an exception occurred.  The reason for "
"not testing for *NULL* arguments is that functions often pass the objects "
"they receive on to other function --- if each function were to test for "
"*NULL*, there would be a lot of redundant tests and the code would run more "
"slowly."
msgstr ""
"ä¸€èˆ¬è«–ã¨ã—ã¦ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’å¼•æ•°ã«ã¨ã‚‹é–¢æ•°ã¯ãƒ¦ãƒ¼ã‚¶ãŒ *NULL* ãƒã‚¤ãƒ³ã‚¿ã‚’æ¸¡ã™ã¨ã¯äºˆæƒ³ã—ã¦ãŠã‚‰ãšã€æ¸¡ãã†ã¨ã™ã‚‹ã¨ã‚³ã‚¢ãƒ€ãƒ³ãƒ—ã«ãªã‚‹ "
"(ã‹ã€ã‚ã¨ã§ã‚³ã‚¢ãƒ€ãƒ³ãƒ—ã‚’å¼•ãèµ·ã“ã™) ã“ã¨ã§ã—ã‚‡ã†ã€‚ä¸€æ–¹ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’è¿”ã™ã‚ˆã†ãªé–¢æ•°ã¯ä¸€èˆ¬ã«ã€ä¾‹å¤–ã®ç™ºç”Ÿã‚’ç¤ºã™å ´åˆã«ã®ã¿ *NULL* "
"ã‚’è¿”ã—ã¾ã™ã€‚å¼•æ•°ã«å¯¾ã—ã¦ *NULL* ãƒ†ã‚¹ãƒˆã‚’è¡Œã‚ãªã„ç†ç”±ã¯ã€é–¢æ•°ã¯ã—ã°ã—ã°å—ã‘å–ã£ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä»–ã®é–¢æ•°ã¸ã¨å¼•ãæ¸¡ã™ã‹ã‚‰ã§ã™ --- å„ã€…ã®é–¢æ•°ãŒ"
" *NULL* ãƒ†ã‚¹ãƒˆã‚’è¡Œãˆã°ã€å†—é•·ãªãƒ†ã‚¹ãƒˆãŒå¤§é‡ã«è¡Œã‚ã‚Œã€ã‚³ãƒ¼ãƒ‰ã¯ã‚ˆã‚Šä½é€Ÿã«å‹•ãã“ã¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../extending/extending.rst:1081
msgid ""
"It is better to test for *NULL* only at the \"source:\" when a pointer that "
"may be *NULL* is received, for example, from :c:func:`malloc` or from a "
"function that may raise an exception."
msgstr ""
"å¾“ã£ã¦ã€ *NULL* ã®ãƒ†ã‚¹ãƒˆã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® \"ç™ºç”Ÿæº\"ã€ã™ãªã‚ã¡å€¤ãŒ *NULL* "
"ã«ãªã‚‹ã‹ã‚‚ã—ã‚Œãªã„ãƒã‚¤ãƒ³ã‚¿ã‚’å—ã‘å–ã£ãŸã¨ãã ã‘ã«ã—ã¾ã—ã‚‡ã†ã€‚ :c:func:`malloc` ã‚„ã€ä¾‹å¤–ã‚’é€å‡ºã™ã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹é–¢æ•°ãŒãã®ä¾‹ã§ã™ã€‚"

#: ../../extending/extending.rst:1085
msgid ""
"The macros :c:func:`Py_INCREF` and :c:func:`Py_DECREF` do not check for "
"*NULL* pointers --- however, their variants :c:func:`Py_XINCREF` and "
":c:func:`Py_XDECREF` do."
msgstr ""
"ãƒã‚¯ãƒ­ :c:func:`Py_INCREF` ãŠã‚ˆã³ :c:func:`Py_DECREF` ã¯ *NULL* ãƒã‚¤ãƒ³ã‚¿ã®ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã„ã¾ã›ã‚“ ---"
" ã—ã‹ã—ã€ã“ã‚Œã‚‰ã®ãƒã‚¯ãƒ­ã®å¤‰åŒ–å½¢ã§ã‚ã‚‹ :c:func:`Py_XINCREF` ãŠã‚ˆã³ :c:func:`Py_XDECREF` "
"ã¯ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã„ã¾ã™ã€‚"

#: ../../extending/extending.rst:1089
msgid ""
"The macros for checking for a particular object type (``Pytype_Check()``) "
"don't check for *NULL* pointers --- again, there is much code that calls "
"several of these in a row to test an object against various different "
"expected types, and this would generate redundant tests.  There are no "
"variants with *NULL* checking."
msgstr ""
"ç‰¹å®šã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã«ã¤ã„ã¦èª¿ã¹ã‚‹ãƒã‚¯ãƒ­ (``Pytype_Check()``) ã¯ *NULL* ãƒã‚¤ãƒ³ã‚¿ã®ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã„ã¾ã›ã‚“ --- "
"ç¹°ã‚Šè¿”ã—ã¾ã™ãŒã€æ§˜ã€…ãªç•°ãªã‚‹å‹ã‚’æƒ³å®šã—ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã‚’èª¿ã¹ã‚‹éš›ã«ã¯ã€ã“ã†ã—ãŸãƒã‚¯ãƒ­ã‚’ç¶šã‘ã¦å‘¼ã³å‡ºã™å¿…è¦ãŒã‚ã‚‹ã®ã§ã€å€‹åˆ¥ã« *NULL* "
"ãƒã‚¤ãƒ³ã‚¿ã®ãƒã‚§ãƒƒã‚¯ã‚’ã™ã‚‹ã¨å†—é•·ãªãƒ†ã‚¹ãƒˆã«ãªã£ã¦ã—ã¾ã†ã®ã§ã™ã€‚å‹ã‚’èª¿ã¹ã‚‹ãƒã‚¯ãƒ­ã«ã¯ã€ *NULL* ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã†å¤‰åŒ–å½¢ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../extending/extending.rst:1095
msgid ""
"The C function calling mechanism guarantees that the argument list passed to"
" C functions (``args`` in the examples) is never *NULL* --- in fact it "
"guarantees that it is always a tuple [#]_."
msgstr ""

#: ../../extending/extending.rst:1099
msgid ""
"It is a severe error to ever let a *NULL* pointer \"escape\" to the Python "
"user."
msgstr "*NULL* ãƒã‚¤ãƒ³ã‚¿ã‚’ Python ãƒ¦ãƒ¼ã‚¶ãƒ¬ãƒ™ãƒ«ã« \"é€ƒãŒã—\" ã¦ã—ã¾ã†ã¨ã€æ·±åˆ»ãªã‚¨ãƒ©ãƒ¼ã‚’å¼•ãèµ·ã“ã—ã¾ã™ã€‚"

#: ../../extending/extending.rst:1110
msgid "Writing Extensions in C++"
msgstr "C++ã§ã®æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä½œæˆ"

#: ../../extending/extending.rst:1112
msgid ""
"It is possible to write extension modules in C++.  Some restrictions apply."
"  If the main program (the Python interpreter) is compiled and linked by the"
" C compiler, global or static objects with constructors cannot be used.  "
"This is not a problem if the main program is linked by the C++ compiler.  "
"Functions that will be called by the Python interpreter (in particular, "
"module initialization functions) have to be declared using ``extern \"C\"``."
" It is unnecessary to enclose the Python header files in ``extern \"C\" "
"{...}`` --- they use this form already if the symbol ``__cplusplus`` is "
"defined (all recent C++ compilers define this symbol)."
msgstr ""
"C++ã§ã‚‚æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ä½œæˆã§ãã¾ã™ã€‚ãŸã ã—ã„ãã¤ã‹åˆ¶é™ãŒã‚ã‚Šã¾ã™ã€‚ãƒ¡ã‚¤ãƒ³ãƒ—ãƒ­ã‚°ãƒ©ãƒ  (Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿) ã¯ C "
"ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œãƒªãƒ³ã‚¯ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚„é™çš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ä½œæˆã§ãã¾ã›ã‚“ã€‚ãƒ¡ã‚¤ãƒ³ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒ C++ "
"ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã§ãƒªãƒ³ã‚¯ã•ã‚Œã¦ã„ã‚‹ãªã‚‰ã“ã‚Œã¯å•é¡Œã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã‚‹é–¢æ•° (ç‰¹ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆæœŸåŒ–é–¢æ•°) ã¯ã€ "
"``extern \"C\"`` ã‚’ä½¿ã£ã¦å®£è¨€ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã¾ãŸã€Python ãƒ˜ãƒƒãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ ``extern \"C\" {...}`` "
"ã«å…¥ã‚Œã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“--- ã‚·ãƒ³ãƒœãƒ« ``__cplusplus`` (æœ€è¿‘ã® C++ ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯å…¨ã¦ã“ã®ã‚·ãƒ³ãƒœãƒ«ã‚’å®šç¾©ã—ã¦ã„ã¾ã™) "
"ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã¨ãã« ``extern \"C\" {...}`` ãŒè¡Œã‚ã‚Œã‚‹ã‚ˆã†ã«ã€ãƒ˜ãƒƒãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å†…ã«ã™ã§ã«æ›¸ã‹ã‚Œã¦ã„ã‚‹ã‹ã‚‰ã§ã™ã€‚"

#: ../../extending/extending.rst:1126
msgid "Providing a C API for an Extension Module"
msgstr "æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã« C API ã‚’æä¾›ã™ã‚‹"

#: ../../extending/extending.rst:1131
msgid ""
"Many extension modules just provide new functions and types to be used from "
"Python, but sometimes the code in an extension module can be useful for "
"other extension modules. For example, an extension module could implement a "
"type \"collection\" which works like lists without order. Just like the "
"standard Python list type has a C API which permits extension modules to "
"create and manipulate lists, this new collection type should have a set of C"
" functions for direct manipulation from other extension modules."
msgstr ""
"å¤šãã®æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯å˜ã« Python "
"ã‹ã‚‰ä½¿ãˆã‚‹æ–°ãŸãªé–¢æ•°ã‚„å‹ã‚’æä¾›ã™ã‚‹ã ã‘ã§ã™ãŒã€æ™‚ã«æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã®ã‚³ãƒ¼ãƒ‰ãŒä»–ã®æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã‚‚ä¾¿åˆ©ãªã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€ã‚ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯é †åºæ¦‚å¿µã®ãªã„ãƒªã‚¹ãƒˆã®ã‚ˆã†ã«å‹•ä½œã™ã‚‹"
" \"ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ (collection)\" ã‚¯ãƒ©ã‚¹ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã¡ã‚‡ã†ã©ãƒªã‚¹ãƒˆã‚’ç”Ÿæˆã—ãŸã‚Šæ“ä½œã—ãŸã‚Šã§ãã‚‹ C API "
"ã‚’å‚™ãˆãŸæ¨™æº–ã® Python ãƒªã‚¹ãƒˆå‹ã®ã‚ˆã†ã«ã€ã“ã®æ–°ãŸãªã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å‹ã‚‚ä»–ã®æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰ç›´æ¥æ“ä½œã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã«ã¯ä¸€é€£ã® C "
"é–¢æ•°ã‚’æŒã£ã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../extending/extending.rst:1139
msgid ""
"At first sight this seems easy: just write the functions (without declaring "
"them ``static``, of course), provide an appropriate header file, and "
"document the C API. And in fact this would work if all extension modules "
"were always linked statically with the Python interpreter. When modules are "
"used as shared libraries, however, the symbols defined in one module may not"
" be visible to another module. The details of visibility depend on the "
"operating system; some systems use one global namespace for the Python "
"interpreter and all extension modules (Windows, for example), whereas others"
" require an explicit list of imported symbols at module link time (AIX is "
"one example), or offer a choice of different strategies (most Unices). And "
"even if symbols are globally visible, the module whose functions one wishes "
"to call might not have been loaded yet!"
msgstr ""
"ä¸€è¦‹ã™ã‚‹ã¨ã“ã‚Œã¯ç°¡å˜ãªã“ã¨: å˜ã«é–¢æ•°ã‚’ (ã‚‚ã¡ã‚ã‚“ ``static`` ãªã©ã¨ã¯å®£è¨€ã›ãšã«) æ›¸ã„ã¦ã€é©åˆ‡ãªãƒ˜ãƒƒãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æä¾›ã—ã€C API "
"ã‚’æ›¸ã‘ã°ã‚ˆã„ã ã‘ã€ã«æ€ãˆã¾ã™ã€‚ãã—ã¦å®Ÿéš›ã®ã¨ã“ã‚ã€å…¨ã¦ã®æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ Python "
"ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«å¸¸ã«é™çš„ã«ãƒªãƒ³ã‚¯ã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã¯ã†ã¾ãå‹•ä½œã—ã¾ã™ã€‚ã¨ã“ã‚ãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å ´åˆã«ã¯ã€ä¸€ã¤ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚·ãƒ³ãƒœãƒ«ãŒä»–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰ä¸å¯è¦–ãªã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚å¯è¦–æ€§ã®è©³ç´°ã¯ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã‚Šã¾ã™;"
" ã‚ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã¯ Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¨å…¨ã¦ã®æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ç”¨ã«å˜ä¸€ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªåå‰ç©ºé–“ã‚’ç”¨æ„ã—ã¦ã„ã¾ã™ (ä¾‹ãˆã° "
"Windows)ã€‚åˆ¥ã®ã‚·ã‚¹ãƒ†ãƒ ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒªãƒ³ã‚¯æ™‚ã«å–ã‚Šè¾¼ã¾ã‚Œã‚‹ã‚·ãƒ³ãƒœãƒ«ã‚’æ˜ç¤ºçš„ã«æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ (AIX ãŒãã®ä¸€ä¾‹ã§ã™)ã€ã¾ãŸåˆ¥ã®ã‚·ã‚¹ãƒ†ãƒ "
" (ã»ã¨ã‚“ã©ã® Unix) "
"ã§ã¯ã€é•ã£ãŸæˆ¦ç•¥ã‚’é¸æŠè‚¢ã¨ã—ã¦æä¾›ã—ã¦ã„ã¾ã™ã€‚ãã—ã¦ã€ãŸã¨ãˆã‚·ãƒ³ãƒœãƒ«ãŒã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨ã—ã¦å¯è¦–ã§ã‚ã£ã¦ã‚‚ã€å‘¼ã³å‡ºã—ãŸã„é–¢æ•°ã®å…¥ã£ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã¾ã ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ãªã„ã“ã¨ã ã£ã¦ã‚ã‚Šã¾ã™!"

#: ../../extending/extending.rst:1151
msgid ""
"Portability therefore requires not to make any assumptions about symbol "
"visibility. This means that all symbols in extension modules should be "
"declared ``static``, except for the module's initialization function, in "
"order to avoid name clashes with other extension modules (as discussed in "
"section :ref:`methodtable`). And it means that symbols that *should* be "
"accessible from other extension modules must be exported in a different way."
msgstr ""
"å¾“ã£ã¦ã€å¯æ¬æ€§ã®ç‚¹ã‹ã‚‰ã‚·ãƒ³ãƒœãƒ«ã®å¯è¦–æ€§ã«ã¯ä½•ã‚‰ä»®å®šã‚’ã—ã¦ã¯ãªã‚‰ãªã„ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ã¤ã¾ã‚Šæ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä¸­ã®å…¨ã¦ã®ã‚·ãƒ³ãƒœãƒ«ã¯ ``static`` "
"ã¨å®£è¨€ã›ã­ã°ãªã‚Šã¾ã›ã‚“ã€‚ä¾‹å¤–ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åˆæœŸåŒ–é–¢æ•°ã§ã€ã“ã‚Œã¯ (:ref:`methodtable` ã§è¿°ã¹ãŸã‚ˆã†ã«) "
"ä»–ã®æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã®é–“ã§åå‰ãŒè¡çªã™ã‚‹ã®ã‚’é¿ã‘ã‚‹ãŸã‚ã§ã™ã€‚ã¾ãŸã€ä»–ã®æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã‚’ *å—ã‘ã‚‹ã¹ãã§ã¯ãªã„* "
"ã‚·ãƒ³ãƒœãƒ«ã¯åˆ¥ã®ã‚„ã‚Šæ–¹ã§å…¬é–‹ã›ã­ã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../extending/extending.rst:1158
msgid ""
"Python provides a special mechanism to pass C-level information (pointers) "
"from one extension module to another one: Capsules. A Capsule is a Python "
"data type which stores a pointer (:c:type:`void \\*`).  Capsules can only be"
" created and accessed via their C API, but they can be passed around like "
"any other Python object. In particular,  they can be assigned to a name in "
"an extension module's namespace. Other extension modules can then import "
"this module, retrieve the value of this name, and then retrieve the pointer "
"from the Capsule."
msgstr ""
"Python ã¯ã‚ã‚‹æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® C ãƒ¬ãƒ™ãƒ«ã®æƒ…å ± (ãƒã‚¤ãƒ³ã‚¿) ã‚’åˆ¥ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«æ¸¡ã™ãŸã‚ã®ç‰¹æ®Šãªæ©Ÿæ§‹: Capsule "
"(ã‚«ãƒ—ã‚»ãƒ«)ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚ Capsule ã¯ãƒã‚¤ãƒ³ã‚¿ (:c:type:`void \\*`) ã‚’è¨˜æ†¶ã™ã‚‹ Python ã®ãƒ‡ãƒ¼ã‚¿å‹ã§ã™ã€‚ "
"Capsule ã¯ C API ã‚’ä»‹ã—ã¦ã®ã¿ç”Ÿæˆã—ãŸã‚Šã‚¢ã‚¯ã‚»ã‚¹ã—ãŸã‚Šã§ãã¾ã™ãŒã€ä»–ã® Python "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨åŒã˜ã‚ˆã†ã«å—ã‘æ¸¡ã—ã§ãã¾ã™ã€‚ã¨ã‚Šã‚ã‘ã€Capsule "
"ã¯æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ç©ºé–“å†…ã«ã‚ã‚‹åå‰ã«ä»£å…¥ã§ãã¾ã™ã€‚ä»–ã®æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ import ã§ãã€æ¬¡ã«åå‰ã‚’å–å¾—ã—ã€æœ€å¾Œã«Capsule "
"ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’å–å¾—ã—ã¾ã™ã€‚"

#: ../../extending/extending.rst:1166
msgid ""
"There are many ways in which Capsules can be used to export the C API of an "
"extension module. Each function could get its own Capsule, or all C API "
"pointers could be stored in an array whose address is published in a "
"Capsule. And the various tasks of storing and retrieving the pointers can be"
" distributed in different ways between the module providing the code and the"
" client modules."
msgstr ""
"æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® C API ã‚’å…¬é–‹ã™ã‚‹ãŸã‚ã«ã€æ§˜ã€…ãªæ–¹æ³•ã§ Capsule ãŒä½¿ã‚ã‚Œã¾ã™ã€‚å„é–¢æ•°ã‚’1ã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å…¥ã‚ŒãŸã‚Šã€å…¨ã¦ã® C API "
"ã®ãƒã‚¤ãƒ³ã‚¿é…åˆ—ã‚’ Capsule "
"ã«å…¥ã‚Œã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãã—ã¦ã€ãƒã‚¤ãƒ³ã‚¿ã«å¯¾ã™ã‚‹ä¿å­˜ã‚„å–å¾—ã¨ã„ã£ãŸæ§˜ã€…ãªä½œæ¥­ã¯ã€ã‚³ãƒ¼ãƒ‰ã‚’æä¾›ã—ã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã®é–“ã§ã¯ç•°ãªã‚‹æ–¹æ³•ã§åˆ†æ•£ã§ãã¾ã™ã€‚"

#: ../../extending/extending.rst:1172
msgid ""
"Whichever method you choose, it's important to name your Capsules properly. "
"The function :c:func:`PyCapsule_New` takes a name parameter (:c:type:`const "
"char \\*`); you're permitted to pass in a *NULL* name, but we strongly "
"encourage you to specify a name.  Properly named Capsules provide a degree "
"of runtime type-safety; there is no feasible way to tell one unnamed Capsule"
" from another."
msgstr ""
"ã©ã®æ–¹æ³•ã‚’é¸ã¶ã«ã—ã¦ã‚‚ã€ Capsule ã® name ã‚’æ­£ã—ãè¨­å®šã™ã‚‹ã“ã¨ã¯é‡è¦ã§ã™ã€‚ :c:func:`PyCapsule_New` ã¯ name "
"å¼•æ•° (:c:type:`const char \\*`) ã‚’å–ã‚Šã¾ã™ã€‚ *NULL* ã‚’ name ã«æ¸¡ã™ã“ã¨ã‚‚è¨±å¯ã•ã‚Œã¦ã„ã¾ã™ãŒã€ name "
"ã‚’è¨­å®šã™ã‚‹ã“ã¨ã‚’å¼·ãæ¨å¥¨ã—ã¾ã™ã€‚æ­£ã—ãåå‰ã‚’ä»˜ã‘ã‚‰ã‚ŒãŸ Capsule ã¯ã‚ã‚‹ç¨‹åº¦ã®å®Ÿè¡Œæ™‚å‹å®‰å…¨æ€§ã‚’æŒã¡ã¾ã™ã€‚åå‰ã‚’ä»˜ã‘ã‚‰ã‚Œã¦ã„ãªã„ Capsule "
"ã‚’ä»–ã® Capsule ã¨åŒºåˆ¥ã™ã‚‹ç¾å®Ÿçš„ãªæ–¹æ³•ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../extending/extending.rst:1179
msgid ""
"In particular, Capsules used to expose C APIs should be given a name "
"following this convention::"
msgstr "ç‰¹ã«ã€ C API ã‚’å…¬é–‹ã™ã‚‹ãŸã‚ã® Capsule ã«ã¯æ¬¡ã®ãƒ«ãƒ¼ãƒ«ã«å¾“ã£ãŸåå‰ã‚’ä»˜ã‘ã‚‹ã¹ãã§ã™::"

#: ../../extending/extending.rst:1184
msgid ""
"The convenience function :c:func:`PyCapsule_Import` makes it easy to load a "
"C API provided via a Capsule, but only if the Capsule's name matches this "
"convention.  This behavior gives C API users a high degree of certainty that"
" the Capsule they load contains the correct C API."
msgstr ""
":c:func:`PyCapsule_Import` ã¨ã„ã†ä¾¿åˆ©é–¢æ•°ã¯ã€ Capsule ã®åå‰ãŒã“ã®ãƒ«ãƒ¼ãƒ«ã«ä¸€è‡´ã—ã¦ã„ã‚‹ã¨ãã«ã®ã¿ã€ç°¡å˜ã« "
"Capsule çµŒç”±ã§å…¬é–‹ã•ã‚Œã¦ã„ã‚‹ C API ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®æŒ™å‹•ã«ã‚ˆã‚Šã€ C API ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã€ç¢ºå®Ÿã«æ­£ã—ã„ C API "
"ã‚’æ ¼ç´ã—ã¦ã„ã‚‹ Capsule ã‚’ãƒ­ãƒ¼ãƒ‰ã§ããŸã“ã¨ã‚’ç¢ºã‹ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../extending/extending.rst:1189
msgid ""
"The following example demonstrates an approach that puts most of the burden "
"on the writer of the exporting module, which is appropriate for commonly "
"used library modules. It stores all C API pointers (just one in the "
"example!) in an array of :c:type:`void` pointers which becomes the value of "
"a Capsule. The header file corresponding to the module provides a macro that"
" takes care of importing the module and retrieving its C API pointers; "
"client modules only have to call this macro before accessing the C API."
msgstr ""
"ä»¥ä¸‹ã®ä¾‹ã§ã¯ã€åå‰ã‚’å…¬é–‹ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä½œè€…ã«ã»ã¨ã‚“ã©ã®è² è·ãŒæ›ã‹ã‚Šã¾ã™ãŒã€ã‚ˆãä½¿ã‚ã‚Œã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½œã‚‹éš›ã«é©åˆ‡ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’å®Ÿæ¼”ã—ã¾ã™ã€‚ã“ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§ã¯ã€å…¨ã¦ã®"
" C API ãƒã‚¤ãƒ³ã‚¿ (ä¾‹ä¸­ã§ã¯ä¸€ã¤ã ã‘ã§ã™ãŒ!) ã‚’ã€ Capsule ã®å€¤ã¨ãªã‚‹ :c:type:`void` "
"ãƒã‚¤ãƒ³ã‚¿ã®é…åˆ—ã«ä¿å­˜ã—ã¾ã™ã€‚æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å¯¾å¿œã™ã‚‹ãƒ˜ãƒƒãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® import ã¨ C API "
"ãƒã‚¤ãƒ³ã‚¿ã‚’å–å¾—ã™ã‚‹ã‚ˆã†æ‰‹é…ã™ã‚‹ãƒã‚¯ãƒ­ã‚’æä¾›ã—ã¾ã™; ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€C API ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹å‰ã«ã“ã®ãƒã‚¯ãƒ­ã‚’å‘¼ã¶ã ã‘ã§ã™ã€‚"

#: ../../extending/extending.rst:1197
msgid ""
"The exporting module is a modification of the :mod:`spam` module from "
"section :ref:`extending-simpleexample`. The function :func:`spam.system` "
"does not call the C library function :c:func:`system` directly, but a "
"function :c:func:`PySpam_System`, which would of course do something more "
"complicated in reality (such as adding \"spam\" to every command). This "
"function :c:func:`PySpam_System` is also exported to other extension "
"modules."
msgstr ""
"åå‰ã‚’å…¬é–‹ã™ã‚‹å´ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€ :ref:`extending-simpleexample` ç¯€ã® :mod:`spam` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä¿®æ­£ã—ãŸã‚‚ã®ã§ã™ã€‚é–¢æ•° :func:`spam.system` ã¯ C ãƒ©ã‚¤ãƒ–ãƒ©ãƒªé–¢æ•° :c:func:`system` ã‚’ç›´æ¥å‘¼ã³å‡ºã•ãšã€"
" :c:func:`PySpam_System` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ã‚‚ã¡ã‚ã‚“ã€å®Ÿéš›ã«ã¯ (å…¨ã¦ã®ã‚³ãƒãƒ³ãƒ‰ã« \"spam\" "
"ã‚’ä»˜ã‘ã‚‹ã¨ã„ã£ãŸã‚ˆã†ãª) ã‚ˆã‚Šè¾¼ã¿å…¥ã£ãŸå‡¦ç†ã‚’è¡Œã„ã¾ã™ã€‚ã“ã®é–¢æ•° :c:func:`PySpam_System` "
"ã¯ã¾ãŸã€ä»–ã®æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚‚å…¬é–‹ã•ã‚Œã¾ã™ã€‚"

#: ../../extending/extending.rst:1204
msgid ""
"The function :c:func:`PySpam_System` is a plain C function, declared "
"``static`` like everything else::"
msgstr ""
"é–¢æ•° :c:func:`PySpam_System` ã¯ã€ä»–ã®å…¨ã¦ã®é–¢æ•°ã¨åŒæ§˜ã« ``static`` ã§å®£è¨€ã•ã‚ŒãŸé€šå¸¸ã® C é–¢æ•°ã§ã™::"

#: ../../extending/extending.rst:1213
msgid "The function :c:func:`spam_system` is modified in a trivial way::"
msgstr ":c:func:`spam_system` ã«ã¯å–ã‚‹ã«è¶³ã‚‰ãªã„å¤‰æ›´ãŒæ–½ã•ã‚Œã¦ã„ã¾ã™::"

#: ../../extending/extending.rst:1227
msgid "In the beginning of the module, right after the line ::"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å…ˆé ­ã«ã‚ã‚‹ä»¥ä¸‹ã®è¡Œ ::"

#: ../../extending/extending.rst:1231
msgid "two more lines must be added::"
msgstr "ã®ç›´å¾Œã«ã€ä»¥ä¸‹ã®äºŒè¡Œã‚’å¿…ãšè¿½åŠ ã—ã¦ãã ã•ã„::"

#: ../../extending/extending.rst:1236
msgid ""
"The ``#define`` is used to tell the header file that it is being included in"
" the exporting module, not a client module. Finally, the module's "
"initialization function must take care of initializing the C API pointer "
"array::"
msgstr ""
"``#define`` ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ« :file:`spammodule.h` "
"ã‚’ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ã—ã¦ã„ã‚‹ã®ãŒåå‰ã‚’å…¬é–‹ã™ã‚‹å´ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã‚ã£ã¦ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ãªã„ã“ã¨ã‚’ãƒ˜ãƒƒãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã«æ•™ãˆã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™ã€‚æœ€å¾Œã«ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åˆæœŸåŒ–é–¢æ•°ã¯"
" C API ã®ãƒã‚¤ãƒ³ã‚¿é…åˆ—ã‚’åˆæœŸåŒ–ã™ã‚‹ã‚ˆã†æ‰‹é…ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“::"

#: ../../extending/extending.rst:1262
msgid ""
"Note that ``PySpam_API`` is declared ``static``; otherwise the pointer array"
" would disappear when :func:`PyInit_spam` terminates!"
msgstr ""
"``PySpam_API`` ãŒ ``static`` ã¨å®£è¨€ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„; ãã†ã—ãªã‘ã‚Œã°ã€ "
":func:`PyInit_spam` ãŒçµ‚äº†ã—ãŸã¨ãã«ãƒã‚¤ãƒ³ã‚¿ã‚¢ãƒ¬ã‚¤ã¯æ¶ˆæ»…ã—ã¦ã—ã¾ã„ã¾ã™!"

#: ../../extending/extending.rst:1265
msgid ""
"The bulk of the work is in the header file :file:`spammodule.h`, which looks"
" like this::"
msgstr "ã‹ã‚‰ãã‚Šã®å¤§éƒ¨åˆ†ã¯ãƒ˜ãƒƒãƒ€ãƒ•ã‚¡ã‚¤ãƒ« :file:`spammodule.h` å†…ã«ã‚ã‚Šã€ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™::"

#: ../../extending/extending.rst:1316
msgid ""
"All that a client module must do in order to have access to the function "
":c:func:`PySpam_System` is to call the function (or rather macro) "
":c:func:`import_spam` in its initialization function::"
msgstr ""
":c:func:`PySpam_System` ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹æ‰‹æ®µã‚’å¾—ã‚‹ãŸã‚ã«ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å´ãŒã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã“ã¨ã¯ã€åˆæœŸåŒ–é–¢æ•°å†…ã§ã® "
":c:func:`import_spam` é–¢æ•° (ã¾ãŸã¯ãƒã‚¯ãƒ­) ã®å‘¼ã³å‡ºã—ã§ã™::"

#: ../../extending/extending.rst:1334
msgid ""
"The main disadvantage of this approach is that the file :file:`spammodule.h`"
" is rather complicated. However, the basic structure is the same for each "
"function that is exported, so it has to be learned only once."
msgstr ""
"ã“ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã®ä¸»è¦ãªæ¬ ç‚¹ã¯ã€ :file:`spammodule.h` "
"ãŒã‚„ã‚„é›£è§£ã«ãªã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚ã¨ã¯ã„ãˆã€å„é–¢æ•°ã®åŸºæœ¬çš„ãªæ§‹æˆã¯å…¬é–‹ã•ã‚Œã‚‹ã‚‚ã®ã¨åŒã˜ãªã®ã§ã€æ›¸ãæ–¹ã‚’ä¸€åº¦ã ã‘å­¦ã¹ã°ã™ã¿ã¾ã™ã€‚"

#: ../../extending/extending.rst:1338
msgid ""
"Finally it should be mentioned that Capsules offer additional functionality,"
" which is especially useful for memory allocation and deallocation of the "
"pointer stored in a Capsule. The details are described in the Python/C API "
"Reference Manual in the section :ref:`capsules` and in the implementation of"
" Capsules (files :file:`Include/pycapsule.h` and :file:`Objects/pycapsule.c`"
" in the Python source code distribution)."
msgstr ""
"æœ€å¾Œã«ã€Capsule "
"ã¯ã€è‡ªèº«ã«ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ãƒã‚¤ãƒ³ã‚¿ã‚’ãƒ¡ãƒ¢ãƒªç¢ºä¿ã—ãŸã‚Šè§£æ”¾ã—ãŸã‚Šã™ã‚‹éš›ã«ç‰¹ã«ä¾¿åˆ©ãªã€ã‚‚ã†ä¸€ã¤ã®æ©Ÿèƒ½ã‚’æä¾›ã—ã¦ã„ã‚‹ã¨ã„ã†ã“ã¨ã«è§¦ã‚Œã¦ãŠã‹ã­ã°ãªã‚Šã¾ã›ã‚“ã€‚è©³ç´°ã¯"
" Python/C API ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã® :ref:`capsules`, ãŠã‚ˆã³ Capsule ã®å®Ÿè£…éƒ¨åˆ† (Python "
"ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰é…å¸ƒç‰©ä¸­ã®ãƒ•ã‚¡ã‚¤ãƒ« :file:`Include/pycapsule.h` ãŠã‚ˆã³ :file:`Objects/pycapsule.c` "
"ã«è¿°ã¹ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../extending/extending.rst:1346
msgid "Footnotes"
msgstr "è„šæ³¨"

#: ../../extending/extending.rst:1347
msgid ""
"An interface for this function already exists in the standard module "
":mod:`os` --- it was chosen as a simple and straightforward example."
msgstr ""
"ã“ã®é–¢æ•°ã¸ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã¯ã™ã§ã«æ¨™æº–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« :mod:`os` ã«ã‚ã‚Šã¾ã™ --- ã“ã®é–¢æ•°ã‚’é¸ã‚“ã ã®ã¯ã€å˜ç´”ã§ç›´æ¥çš„ãªä¾‹ã‚’ç¤ºã—ãŸã„ã‹ã‚‰ã§ã™ã€‚"

#: ../../extending/extending.rst:1350
msgid ""
"The metaphor of \"borrowing\" a reference is not completely correct: the "
"owner still has a copy of the reference."
msgstr "å‚ç…§ã‚’ \"å€Ÿç”¨ã™ã‚‹\" ã¨ã„ã†ãƒ¡ã‚¿ãƒ•ã‚¡ã¯å³å¯†ã«ã¯æ­£ã—ãã‚ã‚Šã¾ã›ã‚“: ãªãœãªã‚‰ã€å‚ç…§ã®æ‰€æœ‰è€…ã¯ä¾ç„¶ã¨ã—ã¦å‚ç…§ã®ã‚³ãƒ”ãƒ¼ã‚’æŒã£ã¦ã„ã‚‹ã‹ã‚‰ã§ã™ã€‚"

#: ../../extending/extending.rst:1353
msgid ""
"Checking that the reference count is at least 1 **does not work** --- the "
"reference count itself could be in freed memory and may thus be reused for "
"another object!"
msgstr ""
"å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒ 1 ä»¥ä¸Šã‹ã©ã†ã‹èª¿ã¹ã‚‹æ–¹æ³•ã¯ **ã†ã¾ãã„ãã¾ã›ã‚“** --- "
"å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆè‡ªä½“ã‚‚è§£æ”¾ã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªä¸Šã«ã‚ã‚‹ãŸã‚ã€ãã®é ˜åŸŸãŒä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ä½¿ã‚ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™!"

#: ../../extending/extending.rst:1357
msgid ""
"These guarantees don't hold when you use the \"old\" style calling "
"convention --- this is still found in much existing code."
msgstr "\"æ—§å¼ã®\" å‘¼ã³å‡ºã—è¦ç´„ã‚’ä½¿ã£ã¦ã„ã‚‹å ´åˆã«ã¯ã€ã“ã®ä¿è¨¼ã¯é©ç”¨ã•ã‚Œã¾ã›ã‚“ --- æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ã«ã¯ã„ã¾ã ã«æ—§å¼ã®å‘¼ã³å‡ºã—è¦ç´„ãŒå¤šã€…ã‚ã‚Šã¾ã™ã€‚"
