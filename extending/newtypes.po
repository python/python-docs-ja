# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2017
# Arihiro TAKASE, 2017
# tomoğŸ§, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-30 05:56+0900\n"
"PO-Revision-Date: 2017-02-16 17:42+0000\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../extending/newtypes.rst:5
msgid "Defining Extension Types: Assorted Topics"
msgstr ""

#: ../../extending/newtypes.rst:9
msgid ""
"This section aims to give a quick fly-by on the various type methods you can"
" implement and what they do."
msgstr "ã“ã®ç¯€ã§ã¯ã•ã¾ã–ã¾ãªå®Ÿè£…å¯èƒ½ãªã‚¿ã‚¤ãƒ—ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã€ãã‚Œã‚‰ãŒä½•ã‚’ã™ã‚‹ã‚‚ã®ã§ã‚ã‚‹ã‹ã«ã¤ã„ã¦ã€ã–ã£ã¨èª¬æ˜ã—ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:12
msgid ""
"Here is the definition of :c:type:`PyTypeObject`, with some fields only used"
" in debug builds omitted:"
msgstr "ä»¥ä¸‹ã¯ :c:type:`PyTypeObject` ã®å®šç¾©ã§ã™ã€‚ãƒ‡ãƒãƒƒã‚°ãƒ“ãƒ«ãƒ‰ã§ã—ã‹ä½¿ã‚ã‚Œãªã„ã„ãã¤ã‹ã®ãƒ¡ãƒ³ãƒã¯çœã„ã¦ã‚ã‚Šã¾ã™:"

#: ../../extending/newtypes.rst:18
msgid ""
"Now that's a *lot* of methods.  Don't worry too much though -- if you have a"
" type you want to define, the chances are very good that you will only "
"implement a handful of these."
msgstr ""
"*ãŸãã•ã‚“ã®* "
"ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã­ã€‚ã§ã‚‚ãã‚“ãªã«å¿ƒé…ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚å®šç¾©ã—ãŸã„å‹ãŒã‚ã‚‹ãªã‚‰ã€å®Ÿè£…ã™ã‚‹ã®ã¯ã“ã®ã†ã¡ã®ã”ãã‚ãšã‹ã§ã™ã‚€ã“ã¨ãŒã»ã¨ã‚“ã©ã§ã™ã€‚"

#: ../../extending/newtypes.rst:22
msgid ""
"As you probably expect by now, we're going to go over this and give more "
"information about the various handlers.  We won't go in the order they are "
"defined in the structure, because there is a lot of historical baggage that "
"impacts the ordering of the fields.  It's often easiest to find an example "
"that includes the fields you need and then change the values to suit your "
"new type. ::"
msgstr ""
"ã™ã§ã«äºˆæƒ³ã•ã‚Œã¦ã„ã‚‹ã§ã—ã‚‡ã†ãŒã€ã“ã®æ§‹é€ ä½“ã«ã¤ã„ã¦å…¥å¿µã«è¦‹ã¦ã„ãã€æ§˜ã€…ãªãƒãƒ³ãƒ‰ãƒ©ã«ã¤ã„ã¦ã‚ˆã‚Šè©³ã—ã„æƒ…å ±ã‚’æä¾›ã—ã¾ã™ã€‚\n"
"ã—ã‹ã—ã“ã‚Œã‚‰ã®ãƒ¡ãƒ³ãƒãŒæ§‹é€ ä½“ä¸­ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹é †ç•ªã¯ç„¡è¦–ã—ã¾ã™ã€‚ã¨ã„ã†ã®ã¯ã€ã“ã‚Œã‚‰ã®ãƒ¡ãƒ³ãƒã®ç¾ã‚Œã‚‹é †åºã¯æ­´å²çš„ãªéºç”£ã«ã‚ˆã‚‹ã‚‚ã®ã ã‹ã‚‰ã§ã™ã€‚\n"
"å¤šãã®å ´åˆã„ã¡ã°ã‚“ç°¡å˜ãªã®ã¯ã€å¿…è¦ã¨ã™ã‚‹ãƒ¡ãƒ³ãƒãŒã™ã¹ã¦å«ã¾ã‚Œã¦ã„ã‚‹ä¾‹ã‚’ã¨ã£ã¦ãã¦ã€æ–°ã—ãä½œã‚‹å‹ã«åˆã‚ã›ã¦å€¤ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã§ã™ã€‚ ::"

#: ../../extending/newtypes.rst:31
msgid ""
"The name of the type -- as mentioned in the previous chapter, this will "
"appear in various places, almost entirely for diagnostic purposes. Try to "
"choose something that will be helpful in such a situation! ::"
msgstr ""
"ã“ã‚Œã¯å‹ã®åå‰ã§ã™ã€‚å‰ã®ç« ã§èª¬æ˜ã—ãŸã‚ˆã†ã«ã€ã“ã‚Œã¯è‰²ã€…ãªå ´é¢ã§ç¾ã‚Œã€ã»ã¨ã‚“ã©ã¯è¨ºæ–­ç›®çš„ã§ä½¿ã‚ã‚Œã‚‹ã‚‚ã®ã§ã™ã€‚\n"
"ãã‚Œãªã®ã§ã€ãã®ã‚ˆã†ãªå ´é¢ã§å½¹ã«ç«‹ã¤ã§ã‚ã‚ã†åå‰ã‚’é¸ã‚“ã§ãã ã•ã„! ::"

#: ../../extending/newtypes.rst:37
msgid ""
"These fields tell the runtime how much memory to allocate when new objects "
"of this type are created.  Python has some built-in support for variable "
"length structures (think: strings, tuples) which is where the "
":c:member:`~PyTypeObject.tp_itemsize` field comes in.  This will be dealt "
"with later. ::"
msgstr ""
"ã“ã‚Œã‚‰ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ã€ã“ã®å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ–°ã—ãä½œæˆã•ã‚Œã‚‹ã¨ãã«ã©ã‚Œã ã‘ã®ãƒ¡ãƒ¢ãƒªã‚’å‰²ã‚Šå½“ã¦ã‚Œã°ã‚ˆã„ã®ã‹ã‚’ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã«æŒ‡ç¤ºã—ã¾ã™ã€‚Python "
"ã«ã¯å¯å¤‰é•·ã®æ§‹é€ ä½“ (æ–‡å­—åˆ—ã‚„ã‚¿ãƒ—ãƒ«ãªã©ã‚’æƒ³åƒã—ã¦ãã ã•ã„) ã«å¯¾ã™ã‚‹çµ„ã¿è¾¼ã¿ã®ã‚µãƒãƒ¼ãƒˆãŒã‚ã‚‹ç¨‹åº¦ã‚ã‚Šã€ã“ã“ã§ "
":c:member:`~PyTypeObject.tp_itemsize` ãƒ¡ãƒ³ãƒãŒä½¿ã‚ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‰ã«ã¤ã„ã¦ã¯ã‚ã¨ã§ãµã‚Œã¾ã™ã€‚ ::"

#: ../../extending/newtypes.rst:44
msgid ""
"Here you can put a string (or its address) that you want returned when the "
"Python script references ``obj.__doc__`` to retrieve the doc string."
msgstr ""
"ã“ã“ã«ã¯ Python ã‚¹ã‚¯ãƒªãƒ—ãƒˆãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ ``obj.__doc__`` ãŒ doc string ã‚’è¿”ã™ã¨ãã®æ–‡å­—åˆ— (ã‚ã‚‹ã„ã¯ãã®ã‚¢ãƒ‰ãƒ¬ã‚¹) "
"ã‚’å…¥ã‚Œã¾ã™ã€‚"

#: ../../extending/newtypes.rst:47
msgid ""
"Now we come to the basic type methods -- the ones most extension types will "
"implement."
msgstr "ã§ã¯æ¬¡ã«ã€å‹ã®åŸºæœ¬çš„ãªãƒ¡ã‚½ãƒƒãƒ‰ã«é€²ã¿ã¾ã™ã€‚ã»ã¨ã‚“ã©ã®æ‹¡å¼µã®å‹ãŒã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:52
msgid "Finalization and De-allocation"
msgstr "ãƒ•ã‚¡ã‚¤ãƒŠãƒ©ã‚¤ã‚ºã¨ãƒ¡ãƒ¢ãƒªè§£æ”¾"

#: ../../extending/newtypes.rst:64
msgid ""
"This function is called when the reference count of the instance of your "
"type is reduced to zero and the Python interpreter wants to reclaim it.  If "
"your type has memory to free or other clean-up to perform, you can put it "
"here.  The object itself needs to be freed here as well.  Here is an example"
" of this function::"
msgstr ""
"å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒã‚¼ãƒ­ã«ãªã‚Šã€Python "
"ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒãã‚Œã‚’æ½°ã—ã¦å†åˆ©ç”¨ã—ãŸããªã‚‹ã¨ã€ã“ã®é–¢æ•°ãŒå‘¼ã°ã‚Œã¾ã™ã€‚è§£æ”¾ã™ã¹ããƒ¡ãƒ¢ãƒªã‚’ãã®å‹ãŒä¿æŒã—ã¦ã„ãŸã‚Šã€ãã‚Œä»¥å¤–ã«ã‚‚å®Ÿè¡Œã™ã¹ãå¾Œå‡¦ç†ãŒã‚ã‚‹å ´åˆã¯ã€ãã‚Œã‚‰ã‚’ã“ã“ã«å…¥ã‚Œã‚‰ã‚Œã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãã‚Œè‡ªä½“ã‚‚ã“ã“ã§è§£æ”¾ã•ã‚Œã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®é–¢æ•°ã®ä¾‹ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ãªã‚‚ã®ã§ã™::"

#: ../../extending/newtypes.rst:81
msgid ""
"One important requirement of the deallocator function is that it leaves any "
"pending exceptions alone.  This is important since deallocators are "
"frequently called as the interpreter unwinds the Python stack; when the "
"stack is unwound due to an exception (rather than normal returns), nothing "
"is done to protect the deallocators from seeing that an exception has "
"already been set.  Any actions which a deallocator performs which may cause "
"additional Python code to be executed may detect that an exception has been "
"set.  This can lead to misleading errors from the interpreter.  The proper "
"way to protect against this is to save a pending exception before performing"
" the unsafe action, and restoring it when done.  This can be done using the "
":c:func:`PyErr_Fetch` and :c:func:`PyErr_Restore` functions::"
msgstr ""
"ãƒ¡ãƒ¢ãƒªè§£æ”¾é–¢æ•°ã§ã²ã¨ã¤é‡è¦ãªã®ã¯ã€å‡¦ç†å¾…ã¡ã®ä¾‹å¤–ã«ã„ã£ã•ã„æ‰‹ã‚’ã¤ã‘ãªã„ã“ã¨ã§ã™ã€‚ãªãœãªã‚‰ã€è§£æ”¾ç”¨ã®é–¢æ•°ã¯ Python "
"ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒã‚¹ã‚¿ãƒƒã‚¯ã‚’å…ƒã®çŠ¶æ…‹ã«æˆ»ã™ã¨ãã«å‘¼ã°ã‚Œã‚‹ã“ã¨ãŒå¤šã„ã‹ã‚‰ã§ã™ã€‚ãã—ã¦ (é€šå¸¸ã®é–¢æ•°ã‹ã‚‰ã®å¾©å¸°ã§ãªã) "
"ä¾‹å¤–ã®ãŸã‚ã«ã‚¹ã‚¿ãƒƒã‚¯ãŒå·»ãæˆ»ã•ã‚Œã‚‹ã¨ãã¯ã€ã™ã§ã«ç™ºç”Ÿã—ã¦ã„ã‚‹ä¾‹å¤–ã‹ã‚‰ãƒ¡ãƒ¢ãƒªè§£æ”¾é–¢æ•°ã‚’å®ˆã‚‹ã‚‚ã®ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚è§£æ”¾ç”¨ã®é–¢æ•°ãŒãŠã“ãªã†å‹•ä½œãŒè¿½åŠ ã® "
"Python "
"ã®ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã—ã¦ã—ã¾ã†ã¨ã€ãã‚Œã‚‰ã¯ä¾‹å¤–ãŒç™ºç”Ÿã—ã¦ã„ã‚‹ã“ã¨ã‚’æ¤œçŸ¥ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒèª¤è§£ã•ã›ã‚‹ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿã•ã›ã‚‹ã“ã¨ã«ã¤ãªãŒã‚Šã¾ã™ã€‚ã“ã‚Œã‚’é˜²ãæ­£ã—ã„æ–¹æ³•ã¯ã€å®‰å…¨ã§ãªã„æ“ä½œã‚’å®Ÿè¡Œã™ã‚‹å‰ã«å‡¦ç†å¾…ã¡ã®ä¾‹å¤–ã‚’ä¿å­˜ã—ã¦ãŠãã€çµ‚ã‚ã£ãŸã‚‰ãã‚Œã‚’å…ƒã«æˆ»ã™ã“ã¨ã§ã™ã€‚ã“ã‚Œã¯"
" :c:func:`PyErr_Fetch` ãŠã‚ˆã³ :c:func:`PyErr_Restore` é–¢æ•°ã‚’ä½¿ã†ã“ã¨ã«ã‚ˆã£ã¦å¯èƒ½ã«ãªã‚Šã¾ã™::"

#: ../../extending/newtypes.rst:120
msgid ""
"There are limitations to what you can safely do in a deallocator function. "
"First, if your type supports garbage collection (using "
":c:member:`~PyTypeObject.tp_traverse` and/or "
":c:member:`~PyTypeObject.tp_clear`), some of the object's members can have "
"been cleared or finalized by the time :c:member:`~PyTypeObject.tp_dealloc` "
"is called.  Second, in :c:member:`~PyTypeObject.tp_dealloc`, your object is "
"in an unstable state: its reference count is equal to zero.  Any call to a "
"non-trivial object or API (as in the example above) might end up calling "
":c:member:`~PyTypeObject.tp_dealloc` again, causing a double free and a "
"crash."
msgstr ""
"ãƒ¡ãƒ¢ãƒªè§£æ”¾é–¢æ•°ã®ä¸­ã§å®‰å…¨ã«è¡Œãˆã‚‹ã“ã¨ã«ã¯ã„ãã¤ã‹åˆ¶é™ãŒã‚ã‚Šã¾ã™ã€‚\n"
"1ã¤ç›®ã¯ã€ãã®å‹ãŒ (:c:member:`~PyTypeObject.tp_traverse` ãŠã‚ˆã³ :c:member:`~PyTypeObject.tp_clear` ã‚’ä½¿ã£ã¦) ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹å ´åˆã€ :c:member:`~PyTypeObject.tp_dealloc` ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã¾ã§ã«ã€æ¶ˆå»ã•ã‚Œãƒ•ã‚¡ã‚¤ãƒŠãƒ©ã‚¤ã‚ºã•ã‚Œã¦ã—ã¾ã†ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ãƒ³ãƒãƒ¼ãŒæœ‰ã‚Šå¾—ã‚‹ã“ã¨ã§ã™ã€‚\n"
"2ã¤ç›®ã¯ã€ :c:member:`~PyTypeObject.tp_dealloc` ã®ä¸­ã§ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä¸å®‰å®šãªçŠ¶æ…‹ã«ã‚ã‚‹ã“ã¨ã§ã™: ã¤ã¾ã‚Šå‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒ0ã§ã‚ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚\n"
"(ä¸Šã®ä¾‹ã«ã‚ã‚‹ã‚ˆã†ãª) è¤‡é›‘ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚„ API ã®å‘¼ã³å‡ºã—ã§ã¯ã€ :c:member:`~PyTypeObject.tp_dealloc` ã‚’å†åº¦å‘¼ã³å‡ºã—ã€äºŒé‡è§£æ”¾ã‹ã‚‰ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã™ã‚‹ã“ã¨ã«ãªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../extending/newtypes.rst:129
msgid ""
"Starting with Python 3.4, it is recommended not to put any complex "
"finalization code in :c:member:`~PyTypeObject.tp_dealloc`, and instead use "
"the new :c:member:`~PyTypeObject.tp_finalize` type method."
msgstr ""
"Python 3.4 ã‹ã‚‰ã¯ã€è¤‡é›‘ãªãƒ•ã‚¡ã‚¤ãƒŠãƒ©ã‚¤ã‚ºã®ã‚³ãƒ¼ãƒ‰ã¯ :c:member:`~PyTypeObject.tp_dealloc` "
"ã«ç½®ã‹ãšã€ä»£ã‚ã‚Šã«æ–°ã—ãå°å…¥ã•ã‚ŒãŸ :c:member:`~PyTypeObject.tp_finalize` "
"ã¨ã„ã†å‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã†ã“ã¨ãŒæ¨å¥¨ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:134
msgid ":pep:`442` explains the new finalization scheme."
msgstr ":pep:`442` ã§æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒŠãƒ©ã‚¤ã‚ºã®ä»•çµ„ã¿ãŒèª¬æ˜ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:141
msgid "Object Presentation"
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¡¨ç¾"

#: ../../extending/newtypes.rst:143
msgid ""
"In Python, there are two ways to generate a textual representation of an "
"object: the :func:`repr` function, and the :func:`str` function.  (The "
":func:`print` function just calls :func:`str`.)  These handlers are both "
"optional."
msgstr ""
"Python ã§ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ–‡å­—åˆ—è¡¨ç¾ã‚’ç”Ÿæˆã™ã‚‹ã®ã« 2ã¤ã®ã‚„ã‚Šæ–¹ãŒã‚ã‚Šã¾ã™: :func:`repr` é–¢æ•°ã‚’ä½¿ã†æ–¹æ³•ã¨ã€ "
":func:`str`  é–¢æ•°ã‚’ä½¿ã†æ–¹æ³•ã§ã™ã€‚ (:func:`print` é–¢æ•°ã¯å˜ã« :func:`str` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚) "
"ã“ã‚Œã‚‰ã®ãƒãƒ³ãƒ‰ãƒ©ã¯ã©ã¡ã‚‰ã‚‚çœç•¥ã§ãã¾ã™ã€‚"

#: ../../extending/newtypes.rst:152
msgid ""
"The :c:member:`~PyTypeObject.tp_repr` handler should return a string object "
"containing a representation of the instance for which it is called.  Here is"
" a simple example::"
msgstr ""
":c:member:`~PyTypeObject.tp_repr` "
"ãƒãƒ³ãƒ‰ãƒ©ã¯å‘¼ã³å‡ºã•ã‚ŒãŸã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®æ–‡å­—åˆ—è¡¨ç¾ã‚’æ ¼ç´ã—ãŸæ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ç°¡å˜ãªä¾‹ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªã‚‚ã®ã§ã™::"

#: ../../extending/newtypes.rst:163
msgid ""
"If no :c:member:`~PyTypeObject.tp_repr` handler is specified, the "
"interpreter will supply a representation that uses the type's "
":c:member:`~PyTypeObject.tp_name` and a uniquely-identifying value for the "
"object."
msgstr ""
":c:member:`~PyTypeObject.tp_repr` ãƒãƒ³ãƒ‰ãƒ©ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ãã®å‹ã® "
":c:member:`~PyTypeObject.tp_name` ã¨ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸€æ„ãªè­˜åˆ¥å€¤ã‚’ã‚‚ã¡ã„ã¦æ–‡å­—åˆ—è¡¨ç¾ã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:167
msgid ""
"The :c:member:`~PyTypeObject.tp_str` handler is to :func:`str` what the "
":c:member:`~PyTypeObject.tp_repr` handler described above is to "
":func:`repr`; that is, it is called when Python code calls :func:`str` on an"
" instance of your object.  Its implementation is very similar to the "
":c:member:`~PyTypeObject.tp_repr` function, but the resulting string is "
"intended for human consumption.  If :c:member:`~PyTypeObject.tp_str` is not "
"specified, the :c:member:`~PyTypeObject.tp_repr` handler is used instead."
msgstr ""
":c:member:`~PyTypeObject.tp_str` ãƒãƒ³ãƒ‰ãƒ©ã¨ :func:`str` ã®é–¢ä¿‚ã¯ã€ä¸Šã® "
":c:member:`~PyTypeObject.tp_repr` ãƒãƒ³ãƒ‰ãƒ©ã¨ :func:`repr` ã®é–¢ä¿‚ã«ç›¸å½“ã—ã¾ã™ã€‚ã¤ã¾ã‚Šã€ã“ã‚Œã¯ "
"Python ã®ã‚³ãƒ¼ãƒ‰ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å¯¾ã—ã¦ :func:`str` ã‚’å‘¼ã³å‡ºã—ãŸã¨ãã«å‘¼ã°ã‚Œã¾ã™ã€‚ã“ã®é–¢æ•°ã®å®Ÿè£…ã¯ "
":c:member:`~PyTypeObject.tp_repr` "
"ãƒãƒ³ãƒ‰ãƒ©ã®ãã‚Œã¨éå¸¸ã«ä¼¼ã¦ã„ã¾ã™ãŒã€å¾—ã‚‰ã‚Œã‚‹æ–‡å­—åˆ—è¡¨ç¾ã¯äººé–“ãŒèª­ã‚€ã“ã¨ã‚’æ„å›³ã•ã‚Œã¦ã„ã¾ã™ã€‚ "
":c:member:`~PyTypeObject.tp_str` ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã€ã‹ã‚ã‚Šã« "
":c:member:`~PyTypeObject.tp_repr` ãƒãƒ³ãƒ‰ãƒ©ãŒä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../extending/newtypes.rst:174
msgid "Here is a simple example::"
msgstr "ä»¥ä¸‹ã¯ç°¡å˜ãªä¾‹ã§ã™::"

#: ../../extending/newtypes.rst:186
msgid "Attribute Management"
msgstr "å±æ€§ã‚’ç®¡ç†ã™ã‚‹"

#: ../../extending/newtypes.rst:188
msgid ""
"For every object which can support attributes, the corresponding type must "
"provide the functions that control how the attributes are resolved.  There "
"needs to be a function which can retrieve attributes (if any are defined), "
"and another to set attributes (if setting attributes is allowed).  Removing "
"an attribute is a special case, for which the new value passed to the "
"handler is *NULL*."
msgstr ""
"å±æ€§ã‚’ã‚‚ã¤ã©ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ã‚‚ã€ãã®å‹ã¯ã€ãã‚Œã‚‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å±æ€§ã‚’ã©ã®ã‚ˆã†ã«è§£æ±ºã™ã‚‹ã‹åˆ¶å¾¡ã™ã‚‹é–¢æ•°ã‚’æä¾›ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚å¿…è¦ãªé–¢æ•°ã¨ã—ã¦ã¯ã€å±æ€§ã‚’"
" (ãã‚ŒãŒå®šç¾©ã•ã‚Œã¦ã„ã‚Œã°) å–ã‚Šå‡ºã™ã‚‚ã®ã¨ã€ã‚‚ã†ã²ã¨ã¤ã¯å±æ€§ã« (ãã‚ŒãŒè¨±å¯ã•ã‚Œã¦ã„ã‚Œã°) "
"å€¤ã‚’è¨­å®šã™ã‚‹ã‚‚ã®ã§ã™ã€‚å±æ€§ã‚’å‰Šé™¤ã™ã‚‹ã®ã¯ç‰¹æ®Šãªã‚±ãƒ¼ã‚¹ã§ã€ã“ã®å ´åˆã¯æ–°ã—ã„å€¤ã¨ã—ã¦ãƒãƒ³ãƒ‰ãƒ©ã« *NULL* ãŒæ¸¡ã•ã‚Œã¾ã™ã€‚"

#: ../../extending/newtypes.rst:194
msgid ""
"Python supports two pairs of attribute handlers; a type that supports "
"attributes only needs to implement the functions for one pair.  The "
"difference is that one pair takes the name of the attribute as a "
":c:type:`char\\*`, while the other accepts a :c:type:`PyObject\\*`.  Each "
"type can use whichever pair makes more sense for the implementation's "
"convenience. ::"
msgstr ""
"Python ã¯ 2ã¤ã®å±æ€§ãƒãƒ³ãƒ‰ãƒ©ã®çµ„ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚å±æ€§ã‚’ã‚‚ã¤å‹ã¯ã©ã¡ã‚‰ã‹ä¸€çµ„ã‚’å®Ÿè£…ã™ã‚‹ã ã‘ã§ã‚ˆãã€ãã‚Œã‚‰ã®é•ã„ã¯ä¸€æ–¹ã®çµ„ãŒå±æ€§ã®åå‰ã‚’ "
":c:type:`char\\*` ã¨ã—ã¦å—ã‘å–ã‚‹ã®ã«å¯¾ã—ã¦ã‚‚ã†ä¸€æ–¹ã®çµ„ã¯å±æ€§ã®åå‰ã‚’ :c:type:`PyObject\\*` "
"ã¨ã—ã¦å—ã‘å–ã‚‹ã€ã¨ã„ã†ã‚‚ã®ã§ã™ã€‚ãã‚Œãã‚Œã®å‹ã¯ãã®å®Ÿè£…ã«ã¨ã£ã¦éƒ½åˆãŒã‚ˆã„æ–¹ã‚’ä½¿ãˆã¾ã™ã€‚ ::"

#: ../../extending/newtypes.rst:206
msgid ""
"If accessing attributes of an object is always a simple operation (this will"
" be explained shortly), there are generic implementations which can be used "
"to provide the :c:type:`PyObject\\*` version of the attribute management "
"functions. The actual need for type-specific attribute handlers almost "
"completely disappeared starting with Python 2.2, though there are many "
"examples which have not been updated to use some of the new generic "
"mechanism that is available."
msgstr ""
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å±æ€§ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒã¤ã­ã« (ã™ãã‚ã¨ã§èª¬æ˜ã™ã‚‹) å˜ç´”ãªæ“ä½œã ã‘ãªã‚‰ã°ã€ :c:type:`PyObject\\*` "
"ã‚’ä½¿ã£ã¦å±æ€§ã‚’ç®¡ç†ã™ã‚‹é–¢æ•°ã¨ã—ã¦ã€ç·ç§°çš„ (generic) ãªå®Ÿè£…ã‚’ä½¿ãˆã¾ã™ã€‚ç‰¹å®šã®å‹ã«ç‰¹åŒ–ã—ãŸå±æ€§ãƒãƒ³ãƒ‰ãƒ©ã®å¿…è¦æ€§ã¯ Python 2.2 "
"ã‹ã‚‰ã»ã¨ã‚“ã©å®Œå…¨ã«ãªããªã‚Šã¾ã—ãŸã€‚ã—ã‹ã—ã€å¤šãã®ä¾‹ã¯ã¾ã ã€ã“ã®æ–°ã—ãä½¿ãˆã‚‹ã‚ˆã†ã«ãªã£ãŸç·ç§°çš„ãªãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã‚’ä½¿ã†ã‚ˆã†æ›´æ–°ã•ã‚Œã¦ã¯ã„ã¾ã›ã‚“ã€‚"

#: ../../extending/newtypes.rst:217
msgid "Generic Attribute Management"
msgstr "ç·ç§°çš„ãªå±æ€§ã‚’ç®¡ç†ã™ã‚‹"

#: ../../extending/newtypes.rst:219
msgid ""
"Most extension types only use *simple* attributes.  So, what makes the "
"attributes simple?  There are only a couple of conditions that must be met:"
msgstr "ã»ã¨ã‚“ã©ã®å‹ã¯ *å˜ç´”ãª* å±æ€§ã‚’ä½¿ã†ã ã‘ã§ã™ã€‚ã§ã¯ã€ã©ã®ã‚ˆã†ãªå±æ€§ãŒå˜ç´”ã ã¨ã„ãˆã‚‹ã®ã§ã—ã‚‡ã†ã‹? ãã‚ŒãŒæº€ãŸã™ã¹ãæ¡ä»¶ã¯ã”ãã‚ãšã‹ã§ã™:"

#: ../../extending/newtypes.rst:222
msgid ""
"The name of the attributes must be known when :c:func:`PyType_Ready` is "
"called."
msgstr ":c:func:`PyType_Ready` ãŒå‘¼ã°ã‚ŒãŸã¨ãã€ã™ã§ã«å±æ€§ã®åå‰ãŒã‚ã‹ã£ã¦ã„ã‚‹ã“ã¨ã€‚"

#: ../../extending/newtypes.rst:225
msgid ""
"No special processing is needed to record that an attribute was looked up or"
" set, nor do actions need to be taken based on the value."
msgstr ""
"å±æ€§ã‚’å‚ç…§ã—ãŸã‚Šè¨­å®šã—ãŸã‚Šã™ã‚‹ã¨ãã«ã€ç‰¹åˆ¥ãªè¨˜éŒ²ã®ãŸã‚ã®å‡¦ç†ãŒå¿…è¦ã§ãªãã€ã¾ãŸå‚ç…§ã—ãŸã‚Šè¨­å®šã—ãŸå€¤ã«å¯¾ã—ã¦ã©ã‚“ãªæ“ä½œã‚‚å®Ÿè¡Œã™ã‚‹å¿…è¦ãŒãªã„ã“ã¨ã€‚"

#: ../../extending/newtypes.rst:228
msgid ""
"Note that this list does not place any restrictions on the values of the "
"attributes, when the values are computed, or how relevant data is stored."
msgstr ""
"ã“ã‚Œã‚‰ã®æ¡ä»¶ã¯ã€å±æ€§ã®å€¤ã‚„ã€å€¤ãŒè¨ˆç®—ã•ã‚Œã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã€ã¾ãŸã¯æ ¼ç´ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ãŒã©ã®ç¨‹åº¦å¦¥å½“ãªã‚‚ã®ã§ã‚ã‚‹ã‹ã¨ã„ã£ãŸã“ã¨ã«ãªã‚“ã‚‰åˆ¶ç´„ã‚’èª²ã™ã‚‚ã®ã§ã¯ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../extending/newtypes.rst:231
msgid ""
"When :c:func:`PyType_Ready` is called, it uses three tables referenced by "
"the type object to create :term:`descriptor`\\s which are placed in the "
"dictionary of the type object.  Each descriptor controls access to one "
"attribute of the instance object.  Each of the tables is optional; if all "
"three are *NULL*, instances of the type will only have attributes that are "
"inherited from their base type, and should leave the "
":c:member:`~PyTypeObject.tp_getattro` and "
":c:member:`~PyTypeObject.tp_setattro` fields *NULL* as well, allowing the "
"base type to handle attributes."
msgstr ""
":c:func:`PyType_Ready` ãŒå‘¼ã°ã‚Œã‚‹ã¨ã€ã“ã‚Œã¯ãã®ã‚¿ã‚¤ãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å‚ç…§ã•ã‚Œã¦ã„ã‚‹ "
"3ã¤ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ä½¿ã£ã¦ã€ãã®ã‚¿ã‚¤ãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è¾æ›¸ä¸­ã«ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿(:term:`descriptor`) "
"ã‚’ä½œæˆã—ã¾ã™ã€‚å„ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å±æ€§ã«å¯¾ã™ã‚‹ã‚¢ã‚¯ã‚»ã‚¹ã‚’åˆ¶å¾¡ã—ã¾ã™ã€‚ãã‚Œãã‚Œã®ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ãªãã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚ã‚‚ã—ã“ã‚Œã‚‰ "
"3ã¤ãŒã™ã¹ã¦ *NULL* ã ã¨ã€ãã®å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ãã®åŸºåº•å‹ã‹ã‚‰ç¶™æ‰¿ã—ãŸå±æ€§ã ã‘ã‚’æŒã¤ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ã¾ãŸã€ "
":c:member:`~PyTypeObject.tp_getattro` ãŠã‚ˆã³ "
":c:member:`~PyTypeObject.tp_setattro` ãŒ *NULL* "
"ã®ã¾ã¾ã ã£ãŸå ´åˆã‚‚ã€åŸºåº•å‹ã«ã“ã‚Œã‚‰ã®å±æ€§ã®æ“ä½œãŒã¾ã‹ã›ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../extending/newtypes.rst:239
msgid "The tables are declared as three fields of the type object::"
msgstr "ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ã‚¿ã‚¤ãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä¸­ã® 3ã¤ã®ãƒ¡ãƒ³ãƒã¨ã—ã¦å®£è¨€ã•ã‚Œã¦ã„ã¾ã™::"

#: ../../extending/newtypes.rst:245
msgid ""
"If :c:member:`~PyTypeObject.tp_methods` is not *NULL*, it must refer to an "
"array of :c:type:`PyMethodDef` structures.  Each entry in the table is an "
"instance of this structure::"
msgstr ""
":c:member:`~PyTypeObject.tp_methods` ãŒ *NULL* ã§ãªã„å ´åˆã€ã“ã‚Œã¯ "
":c:type:`PyMethodDef` æ§‹é€ ä½“ã¸ã®é…åˆ—ã‚’æŒ‡ã—ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãƒ†ãƒ¼ãƒ–ãƒ«ä¸­ã®å„ã‚¨ãƒ³ãƒˆãƒªã¯ã€ã¤ãã®ã‚ˆã†ãªæ§‹é€ ä½“ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã™::"

#: ../../extending/newtypes.rst:256
msgid ""
"One entry should be defined for each method provided by the type; no entries"
" are needed for methods inherited from a base type.  One additional entry is"
" needed at the end; it is a sentinel that marks the end of the array.  The "
":attr:`ml_name` field of the sentinel must be *NULL*."
msgstr ""
"ãã®å‹ãŒæä¾›ã™ã‚‹å„ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¤ã„ã¦ã²ã¨ã¤ã®ã‚¨ãƒ³ãƒˆãƒªã‚’å®šç¾©ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚åŸºåº•å‹ã‹ã‚‰ç¶™æ‰¿ã—ã¦ããŸãƒ¡ã‚½ãƒƒãƒ‰ã«ã¤ã„ã¦ã¯ã‚¨ãƒ³ãƒˆãƒªã¯å¿…è¦ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã®æœ€å¾Œã«ã¯ã€é…åˆ—ã®çµ‚ã‚ã‚Šã‚’ç¤ºã™ãŸã‚ã®è¦‹å¼µã‚Šç•ª"
" (sentinel) ã¨ã—ã¦è¿½åŠ ã®ã‚¨ãƒ³ãƒˆãƒªãŒã²ã¨ã¤å¿…è¦ã§ã™ã€‚ã“ã®å ´åˆã€ :attr:`ml_name` ãƒ¡ãƒ³ãƒãŒ sentinel "
"ã¨ã—ã¦ä½¿ã‚ã‚Œã€ãã®å€¤ã¯ *NULL* ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../extending/newtypes.rst:261
msgid ""
"The second table is used to define attributes which map directly to data "
"stored in the instance.  A variety of primitive C types are supported, and "
"access may be read-only or read-write.  The structures in the table are "
"defined as::"
msgstr ""
"2ç•ªç›®ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä¸­ã«æ ¼ç´ã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ã¨ç›´æ¥å¯¾å¿œã¥ã‘ã‚‰ã‚ŒãŸå±æ€§ã‚’å®šç¾©ã™ã‚‹ã®ã«ä½¿ã„ã¾ã™ã€‚ã„ãã¤ã‚‚ã® C "
"ã®åŸå§‹çš„ãªå‹ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ãŠã‚Šã€ã‚¢ã‚¯ã‚»ã‚¹ã‚’èª­ã¿å‡ºã—å°‚ç”¨ã«ã‚‚èª­ã¿æ›¸ãå¯èƒ½ã«ã‚‚ã§ãã¾ã™ã€‚ã“ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã§ä½¿ã‚ã‚Œã‚‹æ§‹é€ ä½“ã¯æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™::"

#: ../../extending/newtypes.rst:273
msgid ""
"For each entry in the table, a :term:`descriptor` will be constructed and "
"added to the type which will be able to extract a value from the instance "
"structure.  The :attr:`type` field should contain one of the type codes "
"defined in the :file:`structmember.h` header; the value will be used to "
"determine how to convert Python values to and from C values.  The "
":attr:`flags` field is used to store flags which control how the attribute "
"can be accessed."
msgstr ""
"ã“ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã®å„ã‚¨ãƒ³ãƒˆãƒªã«å¯¾ã—ã¦ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿(:term:`descriptor`)ãŒä½œæˆã•ã‚Œã€å€¤ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®æ§‹é€ ä½“ã‹ã‚‰æŠ½å‡ºã—ã†ã‚‹å‹ã«å¯¾ã—ã¦ãã‚Œã‚‰ãŒè¿½åŠ ã•ã‚Œã¾ã™ã€‚"
" :attr:`type` ãƒ¡ãƒ³ãƒã¯ :file:`structmember.h` "
"ãƒ˜ãƒƒãƒ€ã§å®šç¾©ã•ã‚ŒãŸå‹ã®ã‚³ãƒ¼ãƒ‰ã‚’ã²ã¨ã¤å«ã‚“ã§ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®å€¤ã¯ Python ã«ãŠã‘ã‚‹å€¤ã¨ C "
"ã«ãŠã‘ã‚‹å€¤ã‚’ã©ã®ã‚ˆã†ã«å¤‰æ›ã—ã‚ã†ã‹ã‚’å®šã‚ã‚‹ã‚‚ã®ã§ã™ã€‚ :attr:`flags` "
"ãƒ¡ãƒ³ãƒã¯ã“ã®å±æ€§ãŒã©ã®ã‚ˆã†ã«ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã‚‹ã‹ã‚’åˆ¶å¾¡ã™ã‚‹ãƒ•ãƒ©ã‚°ã‚’æ ¼ç´ã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../extending/newtypes.rst:280
msgid ""
"The following flag constants are defined in :file:`structmember.h`; they may"
" be combined using bitwise-OR."
msgstr ""
"ä»¥ä¸‹ã®ãƒ•ãƒ©ã‚°ç”¨å®šæ•°ã¯ :file:`structmember.h` ã§å®šç¾©ã•ã‚Œã¦ãŠã‚Šã€ã“ã‚Œã‚‰ã¯ãƒ“ãƒƒãƒˆã”ã¨ã® OR ã‚’å–ã£ã¦çµ„ã¿åˆã‚ã›ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../extending/newtypes.rst:284
msgid "Constant"
msgstr "å®šæ•°"

#: ../../extending/newtypes.rst:284
msgid "Meaning"
msgstr "æ„å‘³"

#: ../../extending/newtypes.rst:286
msgid ":const:`READONLY`"
msgstr ":const:`READONLY`"

#: ../../extending/newtypes.rst:286
msgid "Never writable."
msgstr "çµ¶å¯¾ã«å¤‰æ›´ã§ããªã„ã€‚"

#: ../../extending/newtypes.rst:288
msgid ":const:`READ_RESTRICTED`"
msgstr ":const:`READ_RESTRICTED`"

#: ../../extending/newtypes.rst:288
msgid "Not readable in restricted mode."
msgstr "åˆ¶é™ãƒ¢ãƒ¼ãƒ‰ (restricted mode) ã§ã¯å‚ç…§ã§ããªã„ã€‚"

#: ../../extending/newtypes.rst:290
msgid ":const:`WRITE_RESTRICTED`"
msgstr ":const:`WRITE_RESTRICTED`"

#: ../../extending/newtypes.rst:290
msgid "Not writable in restricted mode."
msgstr "åˆ¶é™ãƒ¢ãƒ¼ãƒ‰ (restricted mode) ã§ã¯å¤‰æ›´ã§ããªã„ã€‚"

#: ../../extending/newtypes.rst:292
msgid ":const:`RESTRICTED`"
msgstr ":const:`RESTRICTED`"

#: ../../extending/newtypes.rst:292
msgid "Not readable or writable in restricted mode."
msgstr "åˆ¶é™ãƒ¢ãƒ¼ãƒ‰ (restricted mode) ã§ã¯å‚ç…§ã‚‚å¤‰æ›´ã‚‚ã§ããªã„ã€‚"

#: ../../extending/newtypes.rst:301
msgid ""
"An interesting advantage of using the :c:member:`~PyTypeObject.tp_members` "
"table to build descriptors that are used at runtime is that any attribute "
"defined this way can have an associated doc string simply by providing the "
"text in the table.  An application can use the introspection API to retrieve"
" the descriptor from the class object, and get the doc string using its "
":attr:`__doc__` attribute."
msgstr ""
":c:member:`~PyTypeObject.tp_members` "
"ã‚’ä½¿ã£ãŸã²ã¨ã¤ã®é¢ç™½ã„åˆ©ç”¨æ³•ã¯ã€å®Ÿè¡Œæ™‚ã«ä½¿ã‚ã‚Œã‚‹ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’ä½œæˆã—ã¦ãŠãã€å˜ã«ãƒ†ãƒ¼ãƒ–ãƒ«ä¸­ã«ãƒ†ã‚­ã‚¹ãƒˆã‚’ç½®ã„ã¦ãŠãã“ã¨ã«ã‚ˆã£ã¦ã€ã“ã®æ–¹æ³•ã§å®šç¾©ã•ã‚ŒãŸã™ã¹ã¦ã®å±æ€§ã«"
" doc string ã‚’é–¢é€£ä»˜ã‘ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã§ã™ã€‚ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã“ã®ã‚¤ãƒ³ãƒˆãƒ­ã‚¹ãƒšã‚¯ã‚·ãƒ§ãƒ³ç”¨ API "
"ã‚’ä½¿ã£ã¦ã€ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’å–ã‚Šå‡ºã—ã€ãã® :attr:`__doc__` å±æ€§ã‚’ä½¿ã£ã¦ doc string ã‚’å¾—ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../extending/newtypes.rst:307
msgid ""
"As with the :c:member:`~PyTypeObject.tp_methods` table, a sentinel entry "
"with a :attr:`name` value of *NULL* is required."
msgstr ""
":c:member:`~PyTypeObject.tp_methods` ãƒ†ãƒ¼ãƒ–ãƒ«ã¨åŒã˜ã‚ˆã†ã«ã€ã“ã“ã§ã‚‚ :attr:`name` ãƒ¡ãƒ³ãƒã®å€¤ã‚’ "
"*NULL* ã«ã—ãŸè¦‹å¼µã‚Šç”¨ã‚¨ãƒ³ãƒˆãƒªãŒå¿…è¦ã§ã™ã€‚"

#: ../../extending/newtypes.rst:321
msgid "Type-specific Attribute Management"
msgstr "ç‰¹å®šã®å‹ã«ç‰¹åŒ–ã—ãŸå±æ€§ã®ç®¡ç†"

#: ../../extending/newtypes.rst:323
msgid ""
"For simplicity, only the :c:type:`char\\*` version will be demonstrated "
"here; the type of the name parameter is the only difference between the "
":c:type:`char\\*` and :c:type:`PyObject\\*` flavors of the interface. This "
"example effectively does the same thing as the generic example above, but "
"does not use the generic support added in Python 2.2.  It explains how the "
"handler functions are called, so that if you do need to extend their "
"functionality, you'll understand what needs to be done."
msgstr ""
"è©±ã‚’å˜ç´”ã«ã™ã‚‹ãŸã‚ã€ã“ã“ã§ã¯ :c:type:`char\\*` ã‚’ä½¿ã£ãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ã¿ã‚’ç¤ºã—ã¾ã™ã€‚name ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å‹ã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã¨ã—ã¦ "
":c:type:`char\\*` ã‚’ä½¿ã†ã‹ :c:type:`PyObject\\*` "
"ã‚’ä½¿ã†ã‹ã®é•ã„ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®ä¾‹ã§ã¯ã€ä¸Šã®ç·ç§°çš„ãªä¾‹ã¨åŒã˜ã“ã¨ã‚’åŠ¹ç‡çš„ã«ã‚„ã‚Šã¾ã™ãŒã€ Python 2.2 "
"ã§è¿½åŠ ã•ã‚ŒãŸç·ç§°çš„ãªå‹ã®ã‚µãƒãƒ¼ãƒˆã‚’ä½¿ã‚ãšã«ã‚„ã‚Šã¾ã™ã€‚ã“ã‚Œã¯ãƒãƒ³ãƒ‰ãƒ©ã®é–¢æ•°ãŒã©ã®ã‚ˆã†ã«ã—ã¦å‘¼ã°ã‚Œã‚‹ã®ã‹ã‚’èª¬æ˜ã—ã¾ã™ã€‚ã“ã‚Œã§ã€ãŸã¨ãˆãã®æ©Ÿèƒ½ã‚’æ‹¡å¼µã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã¨ãã€ä½•ã‚’ã©ã†ã™ã‚Œã°ã„ã„ã‹ã‚ã‹ã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../extending/newtypes.rst:331
msgid ""
"The :c:member:`~PyTypeObject.tp_getattr` handler is called when the object "
"requires an attribute look-up.  It is called in the same situations where "
"the :meth:`__getattr__` method of a class would be called."
msgstr ""
":c:member:`~PyTypeObject.tp_getattr` "
"ãƒãƒ³ãƒ‰ãƒ©ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå±æ€§ã¸ã®å‚ç…§ã‚’è¦æ±‚ã™ã‚‹ã¨ãã«å‘¼ã°ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã€ãã®ã‚¯ãƒ©ã‚¹ã® :meth:`__getattr__` "
"ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚Œã‚‹ã§ã‚ã‚ã†çŠ¶æ³ã¨åŒã˜çŠ¶æ³ä¸‹ã§å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../extending/newtypes.rst:335
msgid "Here is an example::"
msgstr "ä»¥ä¸‹ã«ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚::"

#: ../../extending/newtypes.rst:351
msgid ""
"The :c:member:`~PyTypeObject.tp_setattr` handler is called when the "
":meth:`__setattr__` or :meth:`__delattr__` method of a class instance would "
"be called.  When an attribute should be deleted, the third parameter will be"
" *NULL*.  Here is an example that simply raises an exception; if this were "
"really all you wanted, the :c:member:`~PyTypeObject.tp_setattr` handler "
"should be set to *NULL*. ::"
msgstr ""
":c:member:`~PyTypeObject.tp_setattr` ãƒãƒ³ãƒ‰ãƒ©ã¯ã€ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã® :meth:`__setattr__` "
"ã¾ãŸã¯ :meth:`__delattr__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚Œã‚‹ã§ã‚ã‚ã†çŠ¶æ³ã§å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã‚ã‚‹å±æ€§ãŒå‰Šé™¤ã•ã‚Œã‚‹ã¨ãã€3ç•ªç›®ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯ "
"*NULL* ã«ãªã‚Šã¾ã™ã€‚ä»¥ä¸‹ã®ä¾‹ã¯ãŸã‚“ã«ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã‚‹ã‚‚ã®ã§ã™ãŒã€ã‚‚ã—æœ¬å½“ã«ã“ã‚Œã¨åŒã˜ã“ã¨ã‚’ã—ãŸã„ãªã‚‰ã€ "
":c:member:`~PyTypeObject.tp_setattr` ãƒãƒ³ãƒ‰ãƒ©ã‚’ *NULL* ã«è¨­å®šã™ã¹ãã§ã™ã€‚ ::"

#: ../../extending/newtypes.rst:365
msgid "Object Comparison"
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ¯”è¼ƒ"

#: ../../extending/newtypes.rst:371
msgid ""
"The :c:member:`~PyTypeObject.tp_richcompare` handler is called when "
"comparisons are needed.  It is analogous to the :ref:`rich comparison "
"methods <richcmpfuncs>`, like :meth:`__lt__`, and also called by "
":c:func:`PyObject_RichCompare` and :c:func:`PyObject_RichCompareBool`."
msgstr ""
":c:member:`~PyTypeObject.tp_richcompare` ãƒãƒ³ãƒ‰ãƒ©ã¯æ¯”è¼ƒå‡¦ç†ãŒè¦æ±‚ã•ã‚ŒãŸã¨ãã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚\n"
":meth:`__lt__` ã®ã‚ˆã†ãª :ref:`æ‹¡å¼µæ¯”è¼ƒãƒ¡ã‚½ãƒƒãƒ‰ <richcmpfuncs>` ã«é¡ä¼¼ã—ã¦ãŠã‚Šã€ :c:func:`PyObject_RichCompare` ã¨ :c:func:`PyObject_RichCompareBool` ã‹ã‚‰ã‚‚å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../extending/newtypes.rst:376
msgid ""
"This function is called with two Python objects and the operator as "
"arguments, where the operator is one of ``Py_EQ``, ``Py_NE``, ``Py_LE``, "
"``Py_GT``, ``Py_LT`` or ``Py_GT``.  It should compare the two objects with "
"respect to the specified operator and return ``Py_True`` or ``Py_False`` if "
"the comparison is successful, ``Py_NotImplemented`` to indicate that "
"comparison is not implemented and the other object's comparison method "
"should be tried, or *NULL* if an exception was set."
msgstr ""
"ã“ã®é–¢æ•°ã¯ 2 ã¤ã® Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨æ¼”ç®—å­ã‚’å¼•æ•°ã«å–ã‚Šã€æ¼”ç®—å­ã¯ ``Py_EQ``, ``Py_NE``, ``Py_LE``, "
"``Py_GT``, ``Py_LT``, ``Py_GT`` ã®ã©ã‚Œã‹ 1 ã¤ã§ã™ã€‚é–¢æ•°ã¯æŒ‡å®šã•ã‚ŒãŸæ¼”ç®—å­ã«å¾“ã£ã¦ 2 "
"ã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¯”è¼ƒã—ã€æ¯”è¼ƒã«æˆåŠŸã—ãŸå ´åˆã® ``Py_True`` ãŠã‚ˆã³ ``Py_False`` "
"ã‹ã€æ¯”è¼ƒå‡¦ç†ãŒå®Ÿè£…ã•ã‚Œã¦ãŠã‚‰ãšã€ã‚‚ã†ä¸€æ–¹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ¯”è¼ƒå‡¦ç†ã‚’è©¦è¡Œã™ã‚‹ã“ã¨ã‚’ç¤ºã™ ``Py_NotImplemented`` "
"ã‹ã€ä¾‹å¤–ãŒè¨­å®šã•ã‚ŒãŸå ´åˆã® *NULL* ã®ã„ã¥ã‚Œã‹ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:384
msgid ""
"Here is a sample implementation, for a datatype that is considered equal if "
"the size of an internal pointer is equal::"
msgstr "ã“ã‚Œã¯å†…éƒ¨ãƒã‚¤ãƒ³ã‚¿ã®ã‚µã‚¤ã‚ºãŒç­‰ã—ã‘ã‚Œã°ç­‰ã—ã„ã¨è¦‹ãªã™ãƒ‡ãƒ¼ã‚¿å‹ã®ã‚µãƒ³ãƒ—ãƒ«å®Ÿè£…ã§ã™::"

#: ../../extending/newtypes.rst:414
msgid "Abstract Protocol Support"
msgstr "æŠ½è±¡çš„ãªãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ã‚µãƒãƒ¼ãƒˆ"

#: ../../extending/newtypes.rst:416
msgid ""
"Python supports a variety of *abstract* 'protocols;' the specific interfaces"
" provided to use these interfaces are documented in :ref:`abstract`."
msgstr ""
"Python ã¯ã„ãã¤ã‚‚ã® *æŠ½è±¡çš„ãª* â€œãƒ—ãƒ­ãƒˆã‚³ãƒ«â€ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã‚’ä½¿ç”¨ã™ã‚‹ç‰¹å®šã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã«ã¤ã„ã¦ã¯ "
":ref:`abstract` ã§è§£èª¬ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:420
msgid ""
"A number of these abstract interfaces were defined early in the development "
"of the Python implementation.  In particular, the number, mapping, and "
"sequence protocols have been part of Python since the beginning.  Other "
"protocols have been added over time.  For protocols which depend on several "
"handler routines from the type implementation, the older protocols have been"
" defined as optional blocks of handlers referenced by the type object.  For "
"newer protocols there are additional slots in the main type object, with a "
"flag bit being set to indicate that the slots are present and should be "
"checked by the interpreter.  (The flag bit does not indicate that the slot "
"values are non-*NULL*. The flag may be set to indicate the presence of a "
"slot, but a slot may still be unfilled.) ::"
msgstr ""
"ã“ã‚Œã‚‰å¤šæ•°ã®æŠ½è±¡çš„ãªã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã¯ã€Python "
"ã®å®Ÿè£…ãŒé–‹ç™ºã•ã‚Œã‚‹åˆæœŸã®æ®µéšã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã—ãŸã€‚ã¨ã‚Šã‚ã‘æ•°å€¤ã‚„è¾æ›¸ã€ãã—ã¦ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãªã©ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯æœ€åˆã‹ã‚‰ Python "
"ã®ä¸€éƒ¨ã ã£ãŸã®ã§ã™ã€‚ãã‚Œä»¥å¤–ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯ãã®å¾Œè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚å‹ã®å®Ÿè£…ã«ã‚ã‚‹ã„ãã¤ã‹ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ«ãƒ¼ãƒãƒ³ã«ä¾å­˜ã™ã‚‹ã‚ˆã†ãªãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ãŸã‚ã«ã€å¤ã„ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯ãƒãƒ³ãƒ‰ãƒ©ã®å…¥ã£ãŸã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ãƒ–ãƒ­ãƒƒã‚¯ã¨ã—ã¦å®šç¾©ã—ã€å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰å‚ç…§ã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ã‚¿ã‚¤ãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸»éƒ¨ã«è¿½åŠ ã®ã‚¹ãƒ­ãƒƒãƒˆã‚’ã‚‚ã¤æ–°ã—ã„ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã«ã¤ã„ã¦ã¯ã€ãƒ•ãƒ©ã‚°ç”¨ã®ãƒ“ãƒƒãƒˆã‚’ç«‹ã¦ã‚‹ã“ã¨ã§ãã‚Œã‚‰ã®ã‚¹ãƒ­ãƒƒãƒˆãŒå­˜åœ¨ã—ã¦ãŠã‚Šã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒãƒã‚§ãƒƒã‚¯ã™ã¹ãã§ã‚ã‚‹ã“ã¨ã‚’æŒ‡ç¤ºã§ãã¾ã™ã€‚(ã“ã®ãƒ•ãƒ©ã‚°ç”¨ã®ãƒ“ãƒƒãƒˆã¯ã€ãã®ã‚¹ãƒ­ãƒƒãƒˆã®å€¤ãŒé"
" *NULL* "
"ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ•ãƒ©ã‚°ã¯ã‚¹ãƒ­ãƒƒãƒˆã®å­˜åœ¨ã‚’ç¤ºã™ã®ã«ä½¿ãˆã¾ã™ãŒã€ãã®ã‚¹ãƒ­ãƒƒãƒˆã¯ã¾ã åŸ‹ã¾ã£ã¦ã„ãªã„ã‹ã‚‚ã—ã‚Œãªã„ã®ã§ã™ã€‚) ::"

#: ../../extending/newtypes.rst:435
msgid ""
"If you wish your object to be able to act like a number, a sequence, or a "
"mapping object, then you place the address of a structure that implements "
"the C type :c:type:`PyNumberMethods`, :c:type:`PySequenceMethods`, or "
":c:type:`PyMappingMethods`, respectively. It is up to you to fill in this "
"structure with appropriate values. You can find examples of the use of each "
"of these in the :file:`Objects` directory of the Python source distribution."
" ::"
msgstr ""
"ãŠä½¿ã„ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ•°å€¤ã‚„ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã€ã‚ã‚‹ã„ã¯è¾æ›¸ã®ã‚ˆã†ã«ãµã‚‹ã¾ã†ã‚ˆã†ã«ã—ãŸã„ãªã‚‰ã°ã€ãã‚Œãã‚Œã« C ã® "
":c:type:`PyNumberMethods` æ§‹é€ ä½“ã€ :c:type:`PySequenceMethods` æ§‹é€ ä½“ã€ã¾ãŸã¯ "
":c:type:`PyMappingMethods` æ§‹é€ ä½“ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‰ã«é©åˆ‡ãªå€¤ã‚’å…¥ã‚Œã¦ã‚‚å…¥ã‚Œãªãã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚ã“ã‚Œã‚‰ã‚’ä½¿ã£ãŸä¾‹ã¯"
" Python ã®é…å¸ƒã‚½ãƒ¼ã‚¹ã«ã‚ã‚‹ :file:`Objects` ã§ã¿ã¤ã‘ã‚‹ã“ã¨ãŒã§ãã‚‹ã§ã—ã‚‡ã†ã€‚ ::"

#: ../../extending/newtypes.rst:444
msgid ""
"This function, if you choose to provide it, should return a hash number for "
"an instance of your data type. Here is a simple example::"
msgstr "ã“ã®é–¢æ•°ã¯ã€ã‚‚ã—ä½¿ã†ã“ã¨ã«ã—ãŸãªã‚‰ã°ã€ãƒ‡ãƒ¼ã‚¿å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒãƒƒã‚·ãƒ¥ç•ªå·ã‚’è¿”ã™ã‚ˆã†ã«ã—ã¾ã™ã€‚æ¬¡ã®ã¯å˜ç´”ãªä¾‹ã§ã™::"

#: ../../extending/newtypes.rst:457
msgid ""
":c:type:`Py_hash_t` is a signed integer type with a platform-varying width. "
"Returning ``-1`` from :c:member:`~PyTypeObject.tp_hash` indicates an error, "
"which is why you should be careful to avoid returning it when hash "
"computation is successful, as seen above."
msgstr ""

#: ../../extending/newtypes.rst:466
msgid ""
"This function is called when an instance of your data type is \"called\", "
"for example, if ``obj1`` is an instance of your data type and the Python "
"script contains ``obj1('hello')``, the :c:member:`~PyTypeObject.tp_call` "
"handler is invoked."
msgstr ""
"ã“ã®é–¢æ•°ã¯ã€ãã®å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒã€Œé–¢æ•°ã¨ã—ã¦å‘¼ã³å‡ºã•ã‚Œã‚‹ã€ã¨ãã«å‘¼ã°ã‚Œã¾ã™ã€‚ãŸã¨ãˆã°ã‚‚ã— ``obj1`` "
"ã«ãã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒå…¥ã£ã¦ã„ã¦ã€Python ã‚¹ã‚¯ãƒªãƒ—ãƒˆã§ ``obj1('hello')`` ã‚’å®Ÿè¡Œã—ãŸã¨ã™ã‚‹ã¨ã€ "
":c:member:`~PyTypeObject.tp_call` ãƒãƒ³ãƒ‰ãƒ©ãŒå‘¼ã°ã‚Œã¾ã™ã€‚"

#: ../../extending/newtypes.rst:470
msgid "This function takes three arguments:"
msgstr "ã“ã®é–¢æ•°ã¯ 3ã¤ã®å¼•æ•°ã‚’ã¨ã‚Šã¾ã™:"

#: ../../extending/newtypes.rst:472
msgid ""
"*self* is the instance of the data type which is the subject of the call. If"
" the call is ``obj1('hello')``, then *self* is ``obj1``."
msgstr ""
"*self* ã¯å‘¼ã³å‡ºã—ã®å¯¾è±¡ã¨ãªã‚‹ãƒ‡ãƒ¼ã‚¿å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã™ã€‚\n"
"ãŸã¨ãˆã°å‘¼ã³å‡ºã—ãŒ ``obj1('hello')`` ã®å ´åˆã€*self* ã¯ ``obj1`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../extending/newtypes.rst:475
msgid ""
"*args* is a tuple containing the arguments to the call.  You can use "
":c:func:`PyArg_ParseTuple` to extract the arguments."
msgstr ""
"*args* ã¯å‘¼ã³å‡ºã—ã®å¼•æ•°ã‚’æ ¼ç´ã—ã¦ã„ã‚‹ã‚¿ãƒ—ãƒ«ã§ã™ã€‚ã“ã“ã‹ã‚‰å¼•æ•°ã‚’å–ã‚Šå‡ºã™ã«ã¯ :c:func:`PyArg_ParseTuple` ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:478
msgid ""
"*kwds* is a dictionary of keyword arguments that were passed. If this is "
"non-*NULL* and you support keyword arguments, use "
":c:func:`PyArg_ParseTupleAndKeywords` to extract the arguments.  If you do "
"not want to support keyword arguments and this is non-*NULL*, raise a "
":exc:`TypeError` with a message saying that keyword arguments are not "
"supported."
msgstr ""
"*kwds* ã¯ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã®ãŸã‚ã®è¾æ›¸ã§ã™ã€‚ã“ã‚ŒãŒ *NULL* ã§ãªãã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹å ´åˆã¯ã€ "
":c:func:`PyArg_ParseTupleAndKeywords` ã‚’ã¤ã‹ã£ã¦å¼•æ•°ã‚’å–ã‚Šå‡ºã›ã¾ã™ã€‚ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„ã®ã«ã“ã‚ŒãŒ "
"*NULL* ã§ãªã„å ´åˆã¯ã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã¯ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„æ—¨ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ã¨ã‚‚ã« :exc:`TypeError` ã‚’ç™ºç”Ÿã•ã›ã¦ãã ã•ã„ã€‚"

#: ../../extending/newtypes.rst:484
msgid "Here is a toy ``tp_call`` implementation::"
msgstr "ä»¥ä¸‹ã¯ ``tp_call`` ã®ç°¡æ˜“ãªå®Ÿè£…ã§ã™::"

#: ../../extending/newtypes.rst:510
msgid ""
"These functions provide support for the iterator protocol.  Both handlers "
"take exactly one parameter, the instance for which they are being called, "
"and return a new reference.  In the case of an error, they should set an "
"exception and return *NULL*.  :c:member:`~PyTypeObject.tp_iter` corresponds "
"to the Python :meth:`__iter__` method, while "
":c:member:`~PyTypeObject.tp_iternext` corresponds to the Python "
":meth:`~iterator.__next__` method."
msgstr ""

#: ../../extending/newtypes.rst:517
msgid ""
"Any :term:`iterable` object must implement the "
":c:member:`~PyTypeObject.tp_iter` handler, which must return an "
":term:`iterator` object.  Here the same guidelines apply as for Python "
"classes:"
msgstr ""

#: ../../extending/newtypes.rst:521
msgid ""
"For collections (such as lists and tuples) which can support multiple "
"independent iterators, a new iterator should be created and returned by each"
" call to :c:member:`~PyTypeObject.tp_iter`."
msgstr ""

#: ../../extending/newtypes.rst:524
msgid ""
"Objects which can only be iterated over once (usually due to side effects of"
" iteration, such as file objects) can implement "
":c:member:`~PyTypeObject.tp_iter` by returning a new reference to themselves"
" -- and should also therefore implement the "
":c:member:`~PyTypeObject.tp_iternext`  handler."
msgstr ""

#: ../../extending/newtypes.rst:529
msgid ""
"Any :term:`iterator` object should implement both "
":c:member:`~PyTypeObject.tp_iter` and :c:member:`~PyTypeObject.tp_iternext`."
"  An iterator's :c:member:`~PyTypeObject.tp_iter` handler should return a "
"new reference to the iterator.  Its :c:member:`~PyTypeObject.tp_iternext` "
"handler should return a new reference to the next object in the iteration, "
"if there is one. If the iteration has reached the end, "
":c:member:`~PyTypeObject.tp_iternext` may return *NULL* without setting an "
"exception, or it may set :exc:`StopIteration` *in addition* to returning "
"*NULL*; avoiding the exception can yield slightly better performance.  If an"
" actual error occurs, :c:member:`~PyTypeObject.tp_iternext` should always "
"set an exception and return *NULL*."
msgstr ""

#: ../../extending/newtypes.rst:545
msgid "Weak Reference Support"
msgstr "å¼±å‚ç…§(Weak Reference)ã®ã‚µãƒãƒ¼ãƒˆ"

#: ../../extending/newtypes.rst:547
msgid ""
"One of the goals of Python's weak reference implementation is to allow any "
"type to participate in the weak reference mechanism without incurring the "
"overhead on performance-critical objects (such as numbers)."
msgstr ""

#: ../../extending/newtypes.rst:552
msgid "Documentation for the :mod:`weakref` module."
msgstr ""

#: ../../extending/newtypes.rst:554
msgid ""
"For an object to be weakly referencable, the extension type must do two "
"things:"
msgstr ""

#: ../../extending/newtypes.rst:556
msgid ""
"Include a :c:type:`PyObject\\*` field in the C object structure dedicated to"
" the weak reference mechanism.  The object's constructor should leave it "
"*NULL* (which is automatic when using the default "
":c:member:`~PyTypeObject.tp_alloc`)."
msgstr ""

#: ../../extending/newtypes.rst:561
msgid ""
"Set the :c:member:`~PyTypeObject.tp_weaklistoffset` type member to the "
"offset of the aforementioned field in the C object structure, so that the "
"interpreter knows how to access and modify that field."
msgstr ""

#: ../../extending/newtypes.rst:565
msgid ""
"Concretely, here is how a trivial object structure would be augmented with "
"the required field::"
msgstr ""

#: ../../extending/newtypes.rst:573
msgid "And the corresponding member in the statically-declared type object::"
msgstr ""

#: ../../extending/newtypes.rst:581
msgid ""
"The only further addition is that ``tp_dealloc`` needs to clear any weak "
"references (by calling :c:func:`PyObject_ClearWeakRefs`) if the field is "
"non-*NULL*::"
msgstr ""

#: ../../extending/newtypes.rst:597
msgid "More Suggestions"
msgstr "ãã®ä»–ã„ã‚ã„ã‚"

#: ../../extending/newtypes.rst:599
msgid ""
"In order to learn how to implement any specific method for your new data "
"type, get the :term:`CPython` source code.  Go to the :file:`Objects` "
"directory, then search the C source files for ``tp_`` plus the function you "
"want (for example, ``tp_richcompare``).  You will find examples of the "
"function you want to implement."
msgstr ""

#: ../../extending/newtypes.rst:605
msgid ""
"When you need to verify that an object is a concrete instance of the type "
"you are implementing, use the :c:func:`PyObject_TypeCheck` function.  A "
"sample of its use might be something like the following::"
msgstr ""

#: ../../extending/newtypes.rst:616
msgid "Download CPython source releases."
msgstr ""

#: ../../extending/newtypes.rst:616
msgid "https://www.python.org/downloads/source/"
msgstr ""

#: ../../extending/newtypes.rst:618
msgid ""
"The CPython project on GitHub, where the CPython source code is developed."
msgstr ""

#: ../../extending/newtypes.rst:619
msgid "https://github.com/python/cpython"
msgstr ""
