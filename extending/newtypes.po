# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2015
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-21 01:52+0900\n"
"PO-Revision-Date: 2018-03-13 18:03+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../extending/newtypes.rst:8
msgid "Defining New Types"
msgstr "æ–°ã—ã„å‹ã‚’å®šç¾©ã™ã‚‹"

#: ../../extending/newtypes.rst:15
msgid ""
"As mentioned in the last chapter, Python allows the writer of an extension "
"module to define new types that can be manipulated from Python code, much "
"like strings and lists in core Python."
msgstr "å‰ã®ç« ã§ãµã‚ŒãŸã‚ˆã†ã«ã€Python ã§ã¯æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ›¸ããƒ—ãƒ­ã‚°ãƒ©ãƒãŒ Python ã®ã‚³ãƒ¼ãƒ‰ã‹ã‚‰æ“ä½œã§ãã‚‹ã€æ–°ã—ã„å‹ã‚’å®šç¾©ã§ãã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚ã¡ã‚‡ã†ã© Python ã®ä¸­æ ¸ã«ã‚ã‚‹æ–‡å­—åˆ—ã‚„ãƒªã‚¹ãƒˆã‚’ã¤ãã‚Œã‚‹ã‚ˆã†ãªã‚‚ã®ã§ã™ã€‚"

#: ../../extending/newtypes.rst:19
msgid ""
"This is not hard; the code for all extension types follows a pattern, but "
"there are some details that you need to understand before you can get "
"started."
msgstr "ã“ã‚Œã¯ãã‚“ãªã«ã‚€ãšã‹ã—ãã¯ã‚ã‚Šã¾ã›ã‚“ã€‚æ‹¡å¼µå‹ã®ãŸã‚ã®ã‚³ãƒ¼ãƒ‰ã«ã¯ã™ã¹ã¦ã€ä¸€å®šã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒå­˜åœ¨ã—ã¦ã„ã¾ã™ã€‚ã—ã‹ã—å§‹ã‚ã‚‹å‰ã«ã€ã„ãã¤ã‹ç´°ã‹ã„ã“ã¨ã‚’ç†è§£ã—ã¦ãŠãå¿…è¦ãŒã‚ã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../extending/newtypes.rst:24
msgid ""
"The way new types are defined changed dramatically (and for the better) in "
"Python 2.2.  This document documents how to define new types for Python 2.2 "
"and later.  If you need to support older versions of Python, you will need "
"to refer to `older versions of this documentation "
"<https://www.python.org/doc/versions/>`_."
msgstr "Python 2.2 ã‹ã‚‰ã€æ–°ã—ã„å‹ã‚’å®šç¾©ã™ã‚‹æ–¹æ³•ãŒã‹ãªã‚Šå¤‰ã‚ã£ã¦ (è‰¯ããªã£ã¦) ã„ã¾ã™ã€‚ã“ã®æ–‡æ›¸ã¯ Python 2.2 ãŠã‚ˆã³ãã‚Œä»¥é™ã§æ–°ã—ã„å‹ã‚’ã©ã†ã‚„ã£ã¦å®šç¾©ã™ã‚‹ã‹ã«ã¤ã„ã¦è¿°ã¹ã¦ã„ã¾ã™ã€‚å¤ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® Python ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã¯ã€ `ã“ã®æ–‡æ›¸ã®å¤ã„ç‰ˆ <https://www.python.org/doc/versions/>`_ ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../extending/newtypes.rst:34
msgid "The Basics"
msgstr "åŸºæœ¬çš„ãªã“ã¨"

#: ../../extending/newtypes.rst:36
msgid ""
"The Python runtime sees all Python objects as variables of type "
":c:type:`PyObject\\*`.  A :c:type:`PyObject` is not a very magnificent "
"object - it just contains the refcount and a pointer to the object's \"type "
"object\".  This is where the action is; the type object determines which (C)"
" functions get called when, for instance, an attribute gets looked up on an "
"object or it is multiplied by another object.  These C functions are called "
"\"type methods\"."
msgstr "Python ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã§ã¯ã€ã™ã¹ã¦ã® Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ :c:type:`PyObject\\*` å‹ã®å¤‰æ•°ã¨ã—ã¦æ‰±ã„ã¾ã™ã€‚ :c:type:`PyObject` ã¯ã•ã»ã©å¤§ä»°ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ãªãã€å˜ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹å‚ç…§å›æ•°ã¨ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã€Œã‚¿ã‚¤ãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (type object)ã€ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’æ ¼ç´ã—ã¦ã„ã‚‹ã ã‘ã§ã™ã€‚é‡è¦ãªå½¹å‰²ã‚’æœãŸã—ã¦ã„ã‚‹ã®ã¯ã“ã®ã‚¿ã‚¤ãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ã¤ã¾ã‚Šã‚¿ã‚¤ãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ä¾‹ãˆã°ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚ã‚‹å±æ€§ãŒå‚ç…§ã•ã‚Œã‚‹ã¨ã‹ã€ã‚ã‚‹ã„ã¯åˆ¥ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã®é–“ã§ä¹—ç®—ã‚’è¡Œã†ã¨ã„ã£ãŸã¨ãã«ã€ã©ã® (C ã®) é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã‹ã‚’æ±ºå®šã—ã¦ã„ã‚‹ã®ã§ã™ã€‚ã“ã‚Œã‚‰ã® C é–¢æ•°ã¯ã€Œã‚¿ã‚¤ãƒ—ãƒ¡ã‚½ãƒƒãƒ‰ (type method)ã€ã¨å‘¼ã°ã‚Œã€ ``[].append`` ã®ã‚ˆã†ãªã‚‚ã® (ã„ã‚ã‚†ã‚‹ã€Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ¡ã‚½ãƒƒãƒ‰ (object method)ã€) ã¨ã¯åŒºåˆ¥ã—ã¦ã„ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:43
msgid ""
"So, if you want to define a new object type, you need to create a new type "
"object."
msgstr "ãªã®ã§ã€æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã‚’å®šç¾©ã—ãŸã„ã¨ãã¯ã€æ–°ã—ã„ã‚¿ã‚¤ãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚Œã°ã‚ˆã„ã‚ã‘ã§ã™ã€‚"

#: ../../extending/newtypes.rst:46
msgid ""
"This sort of thing can only be explained by example, so here's a minimal, "
"but complete, module that defines a new type:"
msgstr "ã“ã®æ‰‹ã®ã“ã¨ã¯ä¾‹ã‚’è¦‹ãŸã»ã†ãŒæ—©ã„ã§ã—ã‚‡ã†ã‹ã‚‰ã€ã“ã“ã«æœ€å°é™ã®ã€ã—ã‹ã—å®Œå…¨ãªã€æ–°ã—ã„å‹ã‚’å®šç¾©ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚ã’ã¦ãŠãã¾ã™:"

#: ../../extending/newtypes.rst:52
msgid ""
"Now that's quite a bit to take in at once, but hopefully bits will seem "
"familiar from the last chapter."
msgstr "ã•ã—ã‚ãŸã£ã¦è¦šãˆã¦ãŠãã“ã¨ã¯ä»¥ä¸Šã§ã™ãŒã€ã“ã‚Œã§å‰ã®ç« ã‹ã‚‰ã™ã“ã—ã¯èª¬æ˜ãŒã‚ã‹ã‚Šã‚„ã™ããªã£ã¦ã„ã‚‹ã“ã¨ã¨æ€ã„ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:55
msgid "The first bit that will be new is::"
msgstr "æœ€åˆã«ç¿’ã†ã®ã¯ã€ã¤ãã®ã‚ˆã†ãªã‚‚ã®ã§ã™::"

#: ../../extending/newtypes.rst:61
msgid ""
"This is what a Noddy object will contain---in this case, nothing more than "
"every Python object contains, namely a refcount and a pointer to a type "
"object.  These are the fields the ``PyObject_HEAD`` macro brings in.  The "
"reason for the macro is to standardize the layout and to enable special "
"debugging fields in debug builds.  Note that there is no semicolon after the"
" ``PyObject_HEAD`` macro; one is included in the macro definition.  Be wary "
"of adding one by accident; it's easy to do from habit, and your compiler "
"might not complain, but someone else's probably will!  (On Windows, MSVC is "
"known to call this an error and refuse to compile the code.)"
msgstr "ã“ã‚ŒãŒ Noddy ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å†…å®¹ã§ã™ --- ã“ã®ã‚±ãƒ¼ã‚¹ã§ã¯ã€ã»ã‹ã® Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæŒã£ã¦ã„ã‚‹ã‚‚ã®ã¨ä½•ã‚‰å¤‰ã‚ã‚Šã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã¤ã¾ã‚Šå‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã¨å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã§ã™ã­ã€‚ã“ã‚Œã‚‰ã¯ ``PyObject_HEAD`` ãƒã‚¯ãƒ­ã«ã‚ˆã£ã¦å±•é–‹ã•ã‚Œã‚‹ãƒ¡ãƒ³ãƒã§ã™ã€‚ãƒã‚¯ãƒ­ã‚’ä½¿ã†ç†ç”±ã¯ã€ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’æ¨™æº–åŒ–ã™ã‚‹ãŸã‚ã¨ã€ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ“ãƒ«ãƒ‰æ™‚ã«ç‰¹åˆ¥ãªãƒ‡ãƒãƒƒã‚°ç”¨ã®ãƒ¡ãƒ³ãƒã‚’å®šç¾©ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã§ã™ã€‚ã“ã® ``PyObject_HEAD`` ãƒã‚¯ãƒ­ã®å¾Œã«ã¯ã‚»ãƒŸã‚³ãƒ­ãƒ³ãŒãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã‚»ãƒŸã‚³ãƒ­ãƒ³ã¯ã™ã§ã«ãƒã‚¯ãƒ­å†…ã«å«ã¾ã‚Œã¦ã„ã¾ã™ã€‚ã†ã£ã‹ã‚Šå¾Œã«ã‚»ãƒŸã‚³ãƒ­ãƒ³ã‚’ã¤ã‘ã¦ã—ã¾ã‚ãªã„ã‚ˆã†ã«æ°—ã‚’ã¤ã‘ã¦ã€‚ã“ã‚Œã¯ãŠä½¿ã„ã®æ©Ÿç¨®ã§ã¯ä½•ã®å•é¡Œã‚‚èµ·ã“ã‚‰ãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€æ©Ÿç¨®ã«ã‚ˆã£ã¦ã¯ã€ãŠãã‚‰ãå•é¡Œã«ãªã‚‹ã®ã§ã™! (Windows ä¸Šã§ã¯ã€MS Visual C ãŒã“ã®æ‰‹ã®ã‚¨ãƒ©ãƒ¼ã‚’å‡ºã—ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ããªã„ã“ã¨ãŒçŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™)"

#: ../../extending/newtypes.rst:71
msgid ""
"For contrast, let's take a look at the corresponding definition for standard"
" Python integers::"
msgstr "æ¯”è¼ƒã®ãŸã‚ã€ä»¥ä¸‹ã«æ¨™æº–çš„ãª Python ã®æ•´æ•°å‹ã®å®šç¾©ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†::"

#: ../../extending/newtypes.rst:79
msgid "Moving on, we come to the crunch --- the type object. ::"
msgstr "ã§ã¯æ¬¡ã«ã„ã£ã¦ã¿ã¾ã™ã€‚ã‹ãªã‚ã®éƒ¨åˆ†ã€ã‚¿ã‚¤ãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ ::"

#: ../../extending/newtypes.rst:105
msgid ""
"Now if you go and look up the definition of :c:type:`PyTypeObject` in "
":file:`object.h` you'll see that it has many more fields that the definition"
" above.  The remaining fields will be filled with zeros by the C compiler, "
"and it's common practice to not specify them explicitly unless you need "
"them."
msgstr ":file:`object.h` ã®ä¸­ã«ã‚ã‚‹ :c:type:`PyTypeObject` ã®å®šç¾©ã‚’è¦‹ã‚‹ã¨ã€å®Ÿéš›ã«ã¯ã“ã“ã«æŒ™ã’ãŸä»¥ä¸Šã®æ•°ã®ãƒ¡ãƒ³ãƒãŒã‚ã‚‹ã¨ã‚ã‹ã‚‹ã§ã—ã‚‡ã†ã€‚ã“ã‚Œä»¥å¤–ã®ãƒ¡ãƒ³ãƒã¯ C ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«ã‚ˆã£ã¦ã‚¼ãƒ­ã«åˆæœŸåŒ–ã•ã‚Œã‚‹ã®ã§ã€å¿…è¦ãªæ™‚ã‚’é™¤ã„ã¦ãµã¤ã†ã¯ãã‚Œã‚‰ã®å€¤ã‚’æ˜ç¤ºçš„ã«ã¯æŒ‡å®šã›ãšã«ãŠãã¾ã™ã€‚"

#: ../../extending/newtypes.rst:110
msgid ""
"This is so important that we're going to pick the top of it apart still "
"further::"
msgstr "æ¬¡ã®ã‚‚ã®ã¯éå¸¸ã«é‡è¦ãªã®ã§ã€ã¨ãã«æœ€åˆã®æœ€åˆã«è¦‹ã¦ãŠãã¾ã—ã‚‡ã†::"

#: ../../extending/newtypes.rst:115
msgid "This line is a bit of a wart; what we'd like to write is::"
msgstr "ã“ã‚Œã¯ã¡ã‚‡ã£ã¨ã¶ã£ãã‚‰ã¼ã†ã§ã™ã­ã€‚å®Ÿéš›ã«æ›¸ããŸã‹ã£ãŸã®ã¯ã“ã†ã§ã™::"

#: ../../extending/newtypes.rst:119
msgid ""
"as the type of a type object is \"type\", but this isn't strictly conforming"
" C and some compilers complain.  Fortunately, this member will be filled in "
"for us by :c:func:`PyType_Ready`. ::"
msgstr "ã“ã®å ´åˆã€ã‚¿ã‚¤ãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã¯ã€Œtypeã€ã¨ã„ã†åå‰ã«ãªã‚Šã¾ã™ãŒã€ã“ã‚Œã¯å³å¯†ã«ã¯ C ã®åŸºæº–ã«å¾“ã£ã¦ãŠã‚‰ãšã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«ã‚ˆã£ã¦ã¯æ–‡å¥ã‚’è¨€ã‚ã‚Œã¾ã™ã€‚å¹¸ã„ã«ã‚‚ã€ã“ã®ãƒ¡ãƒ³ãƒã¯ :c:func:`PyType_Ready` ãŒåŸ‹ã‚ã¦ãã‚Œã¾ã™ã€‚ ::"

#: ../../extending/newtypes.rst:125
msgid ""
"The name of our type.  This will appear in the default textual "
"representation of our objects and in some error messages, for example::"
msgstr "ã“ã‚Œã¯å‹ã®åå‰ã§ã™ã€‚ã“ã®åå‰ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®è¡¨ç¾å½¢å¼ã¨ã€ã„ãã¤ã‹ã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä¸­ã§ä½¿ã‚ã‚Œã¾ã™ã€‚ãŸã¨ãˆã°::"

#: ../../extending/newtypes.rst:133
msgid ""
"Note that the name is a dotted name that includes both the module name and "
"the name of the type within the module. The module in this case is "
":mod:`noddy` and the type is :class:`Noddy`, so we set the type name to "
":class:`noddy.Noddy`. One side effect of using an undotted name is that the "
"pydoc documentation tool will not list the new type in the module "
"documentation. ::"
msgstr "æ³¨æ„: ã“ã®åå‰ã¯ãƒ‰ãƒƒãƒˆã§åŒºåˆ‡ã‚‰ã‚ŒãŸåå‰ã§ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã¨ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã§ã®å‹åã®ä¸¡æ–¹ã‚’å«ã‚“ã§ã„ã¾ã™ã€‚\nã“ã®å ´åˆã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ :mod:`noddy` ã§å‹ã¯ :class:`Noddy` ã§ã™ã‹ã‚‰ã€ã“ã“ã§ã®å‹åã¨ã—ã¦ã¯ :class:`noddy.Noddy` ã‚’æŒ‡å®šã™ã‚‹ã‚ã‘ã§ã™ã€‚\nãƒ‰ãƒƒãƒˆã§åŒºåˆ‡ã‚‰ã‚Œã¦ã„ãªã„åå‰ã‚’ä½¿ã†ã¨ã€æ–‡æ›¸ãƒ„ãƒ¼ãƒ«ã® pydoc ãŒãã®æ–°ã—ã„å‹ã‚’ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æ–‡æ›¸ã«è¼‰ã›ãªããªã‚‹ã¨ã„ã†å‰¯ä½œç”¨ãŒã‚ã‚Šã¾ã™ã€‚ ::"

#: ../../extending/newtypes.rst:141
msgid ""
"This is so that Python knows how much memory to allocate when you call "
":c:func:`PyObject_New`."
msgstr "ã“ã‚Œã«ã‚ˆã£ã¦ Python ã¯ :c:func:`PyObject_New` ãŒå‘¼ã°ã‚ŒãŸã¨ãã«ã©ã‚Œãã‚‰ã„ã®é‡ã®ãƒ¡ãƒ¢ãƒªã‚’å‰²ã‚Šå½“ã¦ã‚Œã°ã‚ˆã„ã®ã‹çŸ¥ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../extending/newtypes.rst:146
msgid ""
"If you want your type to be subclassable from Python, and your type has the "
"same :c:member:`~PyTypeObject.tp_basicsize` as its base type, you may have "
"problems with multiple inheritance.  A Python subclass of your type will "
"have to list your type first in its :attr:`~class.__bases__`, or else it "
"will not be able to call your type's :meth:`__new__` method without getting "
"an error.  You can avoid this problem by ensuring that your type has a "
"larger value for :c:member:`~PyTypeObject.tp_basicsize` than its base type "
"does.  Most of the time, this will be true anyway, because either your base "
"type will be :class:`object`, or else you will be adding data members to "
"your base type, and therefore increasing its size."
msgstr "ã‚ãªãŸã®ã‚¿ã‚¤ãƒ—ã‚’ Python ã§ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–å¯èƒ½ã«ã—ãŸã„å ´åˆã€ãã®ã‚¿ã‚¤ãƒ—ãŒåŸºåº•ã‚¿ã‚¤ãƒ—ã¨åŒã˜ :c:member:`~PyTypeObject.tp_basicsize` ã‚’ã‚‚ã£ã¦ã„ã‚‹ã¨å¤šé‡ç¶™æ‰¿ã®ã¨ãã«å•é¡ŒãŒç”Ÿã˜ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ãã®ã‚¿ã‚¤ãƒ—ã‚’ Python ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã«ã—ãŸã¨ãã€ãã® :attr:`~class.__bases__` ãƒªã‚¹ãƒˆã«ã¯ã‚ãªãŸã®ã‚¿ã‚¤ãƒ—ãŒæœ€åˆã«ãã‚‹ã‚ˆã†ã«ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã•ã‚‚ãªã„ã¨ã‚¨ãƒ©ãƒ¼ã®ç™ºç”Ÿãªã—ã«ã‚ãªãŸã®ã‚¿ã‚¤ãƒ—ã® :meth:`__new__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã“ã¨ã¯ã§ããªããªã‚Šã¾ã™ã€‚ã“ã®å•é¡Œã‚’å›é¿ã™ã‚‹ã«ã¯ã€ã¤ã­ã«ã‚ãªãŸã®ã‚¿ã‚¤ãƒ—ã® :c:member:`~PyTypeObject.tp_basicsize` ã‚’ãã®åŸºåº•ã‚¿ã‚¤ãƒ—ã‚ˆã‚Šã‚‚å¤§ããã—ã¦ãŠãã“ã¨ã§ã™ã€‚ã»ã¨ã‚“ã©ã®å ´åˆã€ã‚ãªãŸã®ã‚¿ã‚¤ãƒ—ã¯ :class:`object` ã‹ã€ãã†ã§ãªã‘ã‚Œã°åŸºåº•ã‚¿ã‚¤ãƒ—ã«ãƒ‡ãƒ¼ã‚¿ç”¨ã®ãƒ¡ãƒ³ãƒã‚’è¿½åŠ ã—ãŸã‚‚ã®ã§ã—ã‚‡ã†ã‹ã‚‰ã€ã—ãŸãŒã£ã¦å¤§ãã•ã¯ã¤ã­ã«å¢—åŠ ã™ã‚‹ãŸã‚ã“ã®æ¡ä»¶ã¯æº€ãŸã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:160
msgid ""
"This has to do with variable length objects like lists and strings. Ignore "
"this for now."
msgstr "ã“ã‚Œã¯ãƒªã‚¹ãƒˆã‚„æ–‡å­—åˆ—ãªã©ã®å¯å¤‰é•·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãŸã‚ã®ã‚‚ã®ã§ã™ã€‚ä»Šã®ã¨ã“ã‚ç„¡è¦–ã—ã¾ã—ã‚‡ã†ã€‚"

#: ../../extending/newtypes.rst:163
msgid ""
"Skipping a number of type methods that we don't provide, we set the class "
"flags to :const:`Py_TPFLAGS_DEFAULT`. ::"
msgstr "ã“ã®ã‚ã¨ã®ã„ãã¤ã‹ã®ã‚¿ã‚¤ãƒ—ãƒ¡ã‚½ãƒƒãƒ‰ã¯ä½¿ã‚ãªã„ã®ã§ã¨ã°ã—ã¦ã€ã‚¯ãƒ©ã‚¹ã®ãƒ•ãƒ©ã‚° (flags) ã«ã¯ :const:`Py_TPFLAGS_DEFAULT` ã‚’å…¥ã‚Œã¾ã™ã€‚ ::"

#: ../../extending/newtypes.rst:168
msgid ""
"All types should include this constant in their flags.  It enables all of "
"the members defined by the current version of Python."
msgstr "ã™ã¹ã¦ã®å‹ã¯ãƒ•ãƒ©ã‚°ã«ã“ã®å®šæ•°ã‚’å«ã‚ã¦ãŠãå¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯ç¾åœ¨ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® Python ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®ãƒ¡ãƒ³ãƒã‚’è¨±å¯ã—ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:171
msgid ""
"We provide a doc string for the type in :c:member:`~PyTypeObject.tp_doc`. ::"
msgstr "ã“ã®å‹ã® docstring ã¯ :c:member:`~PyTypeObject.tp_doc` ã«å…¥ã‚Œã¾ã™ã€‚ ::"

#: ../../extending/newtypes.rst:175
msgid ""
"Now we get into the type methods, the things that make your objects "
"different from the others.  We aren't going to implement any of these in "
"this version of the module.  We'll expand this example later to have more "
"interesting behavior."
msgstr "ã“ã“ã‹ã‚‰ã‚¿ã‚¤ãƒ—ãƒ¡ã‚½ãƒƒãƒ‰ã«å…¥ã‚‹ã‚ã‘ã§ã™ãŒã€‚ã“ã“ãŒã‚ãªãŸã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä»–ã¨é•ã†ã¨ã“ã‚ã§ã™ã€‚ã§ã‚‚ä»Šå›ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ã€ã“ã‚Œã‚‰ã¯ã©ã‚Œã‚‚å®Ÿè£…ã—ãªã„ã§ãŠãã€ã‚ã¨ã§ã“ã®ä¾‹ã‚’ã‚ˆã‚Šé¢ç™½ã„ã‚‚ã®ã«æ”¹é€ ã™ã‚‹ã“ã¨ã«ã—ã¾ã—ã‚‡ã†ã€‚"

#: ../../extending/newtypes.rst:179
msgid ""
"For now, all we want to be able to do is to create new :class:`Noddy` "
"objects. To enable object creation, we have to provide a "
":c:member:`~PyTypeObject.tp_new` implementation. In this case, we can just "
"use the default implementation provided by the API function "
":c:func:`PyType_GenericNew`.  We'd like to just assign this to the "
":c:member:`~PyTypeObject.tp_new` slot, but we can't, for portability sake, "
"On some platforms or compilers, we can't statically initialize a structure "
"member with a function defined in another C module, so, instead, we'll "
"assign the :c:member:`~PyTypeObject.tp_new` slot in the module "
"initialization function just before calling :c:func:`PyType_Ready`::"
msgstr "ã¨ã‚Šã‚ãˆãšã‚„ã‚ŠãŸã„ã®ã¯ã€ã“ã® :class:`Noddy` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ–°ã—ãä½œã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã§ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½œæˆã‚’è¨±å¯ã™ã‚‹ã«ã¯ã€ :c:member:`~PyTypeObject.tp_new` ã®å®Ÿè£…ã‚’æä¾›ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ä»Šå›ã¯ã€ API é–¢æ•°ã«ã‚ˆã£ã¦æä¾›ã•ã‚Œã‚‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å®Ÿè£… :c:func:`PyType_GenericNew` ã‚’ä½¿ã†ã ã‘ã«ã—ã¾ã—ã‚‡ã†ã€‚ã“ã‚Œã‚’å˜ã« :c:member:`~PyTypeObject.tp_new` ã‚¹ãƒ­ãƒƒãƒˆã«ä»£å…¥ã™ã‚Œã°ã‚ˆã„ã®ã§ã™ãŒã€ã“ã‚Œã¯äº’æ›ä¸Šã®ç†ç”±ã‹ã‚‰ã§ãã¾ã›ã‚“ã€‚ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã‚„ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«ã‚ˆã£ã¦ã¯ã€æ§‹é€ ä½“ãƒ¡ãƒ³ãƒã®åˆæœŸåŒ–ã«åˆ¥ã®å ´æ‰€ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ C ã®é–¢æ•°ã‚’ä»£å…¥ã™ã‚‹ã“ã¨ã¯ã§ããªã„ã®ã§ã™ã€‚ãªã®ã§ã€ã“ã® :c:member:`~PyTypeObject.tp_new` ã®å€¤ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆæœŸåŒ–ç”¨ã®é–¢æ•°ã§ä»£å…¥ã—ã¾ã™ã€‚ :c:func:`PyType_Ready` ã‚’å‘¼ã¶ç›´å‰ã§ã™::"

#: ../../extending/newtypes.rst:193
msgid ""
"All the other type methods are *NULL*, so we'll go over them later --- "
"that's for a later section!"
msgstr "ã“ã‚Œä»¥å¤–ã®ã‚¿ã‚¤ãƒ—ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã™ã¹ã¦ *NULL* ã§ã™ã€‚ã“ã‚Œã‚‰ã«ã¤ã„ã¦ã¯å¾Œã»ã©ãµã‚Œã¾ã™!"

#: ../../extending/newtypes.rst:196
msgid ""
"Everything else in the file should be familiar, except for some code in "
":c:func:`initnoddy`::"
msgstr "ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ä¸­ã«ã‚ã‚‹ä»–ã®ã‚‚ã®ã¯ã€ã©ã‚Œã‚‚ãŠãªã˜ã¿ã§ã—ã‚‡ã†ã€‚ :c:func:`initnoddy` ã®ã“ã‚Œã‚’é™¤ã„ã¦::"

#: ../../extending/newtypes.rst:202
msgid ""
"This initializes the :class:`Noddy` type, filing in a number of members, "
"including :attr:`ob_type` that we initially set to *NULL*. ::"
msgstr "ã“ã®é–¢æ•°ã¯ã€ä¸Šã§ *NULL* ã«æŒ‡å®šã—ã¦ã„ãŸ :attr:`ob_type` ãªã©ã®ã„ãã¤ã‚‚ã®ãƒ¡ãƒ³ãƒã‚’åŸ‹ã‚ã¦ã€ :class:`Noddy` å‹ã‚’åˆæœŸåŒ–ã—ã¾ã™ã€‚ ::"

#: ../../extending/newtypes.rst:207
msgid ""
"This adds the type to the module dictionary.  This allows us to create "
":class:`Noddy` instances by calling the :class:`Noddy` class::"
msgstr "ã“ã‚Œã¯ã“ã®å‹ã‚’ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä¸­ã®è¾æ›¸ã«åŸ‹ã‚è¾¼ã¿ã¾ã™ã€‚ã“ã‚Œã§ã€ :class:`Noddy` ã‚¯ãƒ©ã‚¹ã‚’å‘¼ã¹ã° :class:`Noddy` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸ::"

#: ../../extending/newtypes.rst:213
msgid ""
"That's it!  All that remains is to build it; put the above code in a file "
"called :file:`noddy.c` and ::"
msgstr "ã“ã‚Œã ã‘ã§ã™! æ®‹ã‚‹ã¯ã“ã‚Œã‚’ã©ã†ã‚„ã£ã¦ãƒ“ãƒ«ãƒ‰ã™ã‚‹ã‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚ä¸Šã®ã‚³ãƒ¼ãƒ‰ã‚’ :file:`noddy.c` ã¨ã„ã†ãƒ•ã‚¡ã‚¤ãƒ«ã«å…¥ã‚Œã¦ã€ä»¥ä¸‹ã®ã‚‚ã®ã‚’ :file:`setup.py` ã¨ã„ã†ãƒ•ã‚¡ã‚¤ãƒ«ã«å…¥ã‚Œã¾ã—ã‚‡ã† ::"

#: ../../extending/newtypes.rst:220
msgid "in a file called :file:`setup.py`; then typing"
msgstr "ãã—ã¦ã€ã‚·ã‚§ãƒ«ã‹ã‚‰ä»¥ä¸‹ã®ã‚ˆã†ã«å…¥åŠ›ã—ã¾ã™"

#: ../../extending/newtypes.rst:226
msgid ""
"at a shell should produce a file :file:`noddy.so` in a subdirectory; move to"
" that directory and fire up Python --- you should be able to ``import "
"noddy`` and play around with Noddy objects."
msgstr "ã“ã‚Œã§ã‚µãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ä¸‹ã«ãƒ•ã‚¡ã‚¤ãƒ« :file:`noddy.so` ãŒä½œæˆã•ã‚Œã¾ã™ã€‚ã“ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ç§»å‹•ã—ã¦ Python ã‚’èµ·å‹•ã—ã¾ã—ã‚‡ã†ã€‚ ``import noddy`` ã—ã¦ Noddy ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§éŠã¹ã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã‚‹ã¯ãšã§ã™ã€‚"

#: ../../extending/newtypes.rst:230
msgid "That wasn't so hard, was it?"
msgstr "ãã‚“ãªã«ã‚€ãšã‹ã—ãã‚ã‚Šã¾ã›ã‚“ã€ã‚ˆã­?"

#: ../../extending/newtypes.rst:232
msgid ""
"Of course, the current Noddy type is pretty uninteresting. It has no data "
"and doesn't do anything. It can't even be subclassed."
msgstr "ã‚‚ã¡ã‚ã‚“ã€ç¾åœ¨ã® Noddy å‹ã¯ã¾ã ãŠã‚‚ã—ã‚ã¿ã«æ¬ ã‘ã¦ã„ã¾ã™ã€‚ä½•ã‚‚ãƒ‡ãƒ¼ã‚¿ã‚’æŒã£ã¦ãªã„ã—ã€ä½•ã‚‚ã—ã¦ã¯ãã‚Œã¾ã›ã‚“ã€‚ç¶™æ‰¿ã—ã¦ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’ä½œã‚‹ã“ã¨ã•ãˆã§ããªã„ã®ã§ã™ã€‚"

#: ../../extending/newtypes.rst:237
msgid "Adding data and methods to the Basic example"
msgstr "åŸºæœ¬ã®ã‚µãƒ³ãƒ—ãƒ«ã«ãƒ‡ãƒ¼ã‚¿ã¨ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã™ã‚‹"

#: ../../extending/newtypes.rst:239
msgid ""
"Let's extend the basic example to add some data and methods.  Let's also "
"make the type usable as a base class. We'll create a new module, "
":mod:`noddy2` that adds these capabilities:"
msgstr "ã“ã®åŸºæœ¬ã®ã‚µãƒ³ãƒ—ãƒ«ã«ãƒ‡ãƒ¼ã‚¿ã¨ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚ã¤ã„ã§ã«ã€ã“ã®å‹ã‚’åŸºåº•ã‚¯ãƒ©ã‚¹ã¨ã—ã¦ã‚‚åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã“ã§ã¯æ–°ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« :mod:`noddy2` ã‚’ã¤ãã‚Šã€ä»¥ä¸‹ã®æ©Ÿèƒ½ã‚’è¿½åŠ ã—ã¾ã™:"

#: ../../extending/newtypes.rst:246
msgid "This version of the module has a number of changes."
msgstr "ã“ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ã€ã„ãã¤ã‚‚ã®å¤‰æ›´ã‚’ãŠã“ãªã„ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:248
msgid "We've added an extra include::"
msgstr "ä»¥ä¸‹ã® include ã‚’è¿½åŠ ã—ã¾ã™::"

#: ../../extending/newtypes.rst:252
msgid ""
"This include provides declarations that we use to handle attributes, as "
"described a bit later."
msgstr "ã™ã“ã—ã‚ã¨ã§ãµã‚Œã¾ã™ãŒã€ã“ã® include ã«ã¯å±æ€§ã‚’æ‰±ã†ãŸã‚ã®å®£è¨€ãŒå…¥ã£ã¦ã„ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:255
msgid ""
"The name of the :class:`Noddy` object structure has been shortened to "
":class:`Noddy`.  The type object name has been shortened to "
":class:`NoddyType`."
msgstr ":class:`Noddy` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ§‹é€ ä½“ã®åå‰ã¯ :class:`Noddy` ã«ç¸®ã‚ã‚‹ã“ã¨ã«ã—ã¾ã™ã€‚ã‚¿ã‚¤ãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆåã¯ :class:`NoddyType` ã«ç¸®ã‚ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:258
msgid ""
"The  :class:`Noddy` type now has three data attributes, *first*, *last*, and"
" *number*.  The *first* and *last* variables are Python strings containing "
"first and last names. The *number* attribute is an integer."
msgstr "ã“ã‚Œã‹ã‚‰ :class:`Noddy` å‹ã¯ 3ã¤ã®ãƒ‡ãƒ¼ã‚¿å±æ€§ã‚’ã‚‚ã¤ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ *first* ã€ *last* ã€ãŠã‚ˆã³ *number* ã§ã™ã€‚ *first* ã¨ *last* å±æ€§ã¯ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆãƒãƒ¼ãƒ ã¨ãƒ©ã‚¹ãƒˆãƒãƒ¼ãƒ ã‚’æ ¼ç´ã—ãŸ Python æ–‡å­—åˆ—ã§ã€ *number* å±æ€§ã¯æ•´æ•°ã®å€¤ã§ã™ã€‚"

#: ../../extending/newtypes.rst:262
msgid "The object structure is updated accordingly::"
msgstr "ã“ã‚Œã«ã—ãŸãŒã†ã¨ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ§‹é€ ä½“ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../extending/newtypes.rst:271
msgid ""
"Because we now have data to manage, we have to be more careful about object "
"allocation and deallocation.  At a minimum, we need a deallocation method::"
msgstr "ã„ã¾ã‚„ç®¡ç†ã™ã¹ããƒ‡ãƒ¼ã‚¿ãŒã§ããŸã®ã§ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‰²ã‚Šå½“ã¦ã¨è§£æ”¾ã«éš›ã—ã¦ã¯ã‚ˆã‚Šæ…é‡ã«ãªã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚æœ€ä½é™ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è§£æ”¾ãƒ¡ã‚½ãƒƒãƒ‰ãŒå¿…è¦ã§ã™::"

#: ../../extending/newtypes.rst:282
msgid "which is assigned to the :c:member:`~PyTypeObject.tp_dealloc` member::"
msgstr "ã“ã®é–¢æ•°ã¯ :c:member:`~PyTypeObject.tp_dealloc` ãƒ¡ãƒ³ãƒã«ä»£å…¥ã•ã‚Œã¾ã™ã€‚ ::"

#: ../../extending/newtypes.rst:286
msgid ""
"This method decrements the reference counts of the two Python attributes. We"
" use :c:func:`Py_XDECREF` here because the :attr:`first` and :attr:`last` "
"members could be *NULL*.  It then calls the "
":c:member:`~PyTypeObject.tp_free` member of the object's type to free the "
"object's memory.  Note that the object's type might not be "
":class:`NoddyType`, because the object may be an instance of a subclass."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚„ã£ã¦ã„ã‚‹ã®ã¯ã€ãµãŸã¤ã® Python å±æ€§ã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’æ¸›ã‚‰ã™ã“ã¨ã§ã™ã€‚ :attr:`first` ãƒ¡ãƒ³ãƒã¨ :attr:`last` ãƒ¡ãƒ³ãƒãŒ *NULL* ã‹ã‚‚ã—ã‚Œãªã„ãŸã‚ã€ã“ã“ã§ã¯ :c:func:`Py_XDECREF` ã‚’ä½¿ã„ã¾ã—ãŸã€‚ã“ã®ã‚ã¨ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¿ã‚¤ãƒ—ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚ã‚‹ :c:member:`~PyTypeObject.tp_free` ãƒ¡ãƒ³ãƒã‚’å‘¼ã³å‡ºã—ã¦ã„ã¾ã™ã€‚ã“ã“ã§ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ãŒ :class:`NoddyType` ã¨ã¯é™ã‚‰ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ãªãœãªã‚‰ã€ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–ã—ãŸã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‹ã‚‚ã—ã‚Œãªã„ã‹ã‚‰ã§ã™ã€‚"

#: ../../extending/newtypes.rst:292
msgid ""
"We want to make sure that the first and last names are initialized to empty "
"strings, so we provide a new method::"
msgstr "ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆãƒãƒ¼ãƒ ã¨ãƒ©ã‚¹ãƒˆãƒãƒ¼ãƒ ã‚’ç©ºæ–‡å­—åˆ—ã«åˆæœŸåŒ–ã—ã¦ãŠããŸã„ã®ã§ã€æ–°ã—ã„ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã«ã—ã¾ã—ã‚‡ã†::"

#: ../../extending/newtypes.rst:322
msgid "and install it in the :c:member:`~PyTypeObject.tp_new` member::"
msgstr "ãã—ã¦ã“ã‚Œã‚’ :c:member:`~PyTypeObject.tp_new` ãƒ¡ãƒ³ãƒã¨ã—ã¦ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã™::"

#: ../../extending/newtypes.rst:326
msgid ""
"The new member is responsible for creating (as opposed to initializing) "
"objects of the type.  It is exposed in Python as the :meth:`__new__` method."
"  See the paper titled \"Unifying types and classes in Python\" for a "
"detailed discussion of the :meth:`__new__` method.  One reason to implement "
"a new method is to assure the initial values of instance variables.  In this"
" case, we use the new method to make sure that the initial values of the "
"members :attr:`first` and :attr:`last` are not *NULL*. If we didn't care "
"whether the initial values were *NULL*, we could have used "
":c:func:`PyType_GenericNew` as our new method, as we did before.  "
":c:func:`PyType_GenericNew` initializes all of the instance variable members"
" to *NULL*."
msgstr "ã“ã®æ–°ã—ã„ãƒ¡ãƒ³ãƒã¯ãã®å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ (åˆæœŸåŒ–ã™ã‚‹ã®ã§ã¯ãªã) ä½œæˆã™ã‚‹è²¬ä»»ã‚’è² ã£ã¦ã„ã¾ã™ã€‚Python ã§ã¯ã“ã®ãƒ¡ãƒ³ãƒã¯ :meth:`__new__` ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã—ã¦è¦‹ãˆã¦ã„ã¾ã™ã€‚ :meth:`__new__` ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¤ã„ã¦ã®è©³ã—ã„è­°è«–ã¯ \"Unifying types and classes in Python\" ã¨ã„ã†é¡Œåã®è«–æ–‡ã‚’è¦‹ã¦ãã ã•ã„ã€‚ new ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã™ã‚‹ç†ç”±ã®ã²ã¨ã¤ã¯ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã®åˆæœŸå€¤ã‚’ä¿è¨¼ã™ã‚‹ãŸã‚ã§ã™ã€‚ã“ã®ä¾‹ã§ã‚„ã‚ŠãŸã„ã®ã¯ new ãƒ¡ã‚½ãƒƒãƒ‰ãŒ :attr:`first` ãƒ¡ãƒ³ãƒã¨  :attr:`last` ãƒ¡ãƒ³ãƒã®å€¤ã‚’ *NULL* ã§ãªã„ã‚ˆã†ã«ã™ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚ã‚‚ã—ã“ã‚Œã‚‰ã®åˆæœŸå€¤ãŒ *NULL* ã§ã‚‚ã‚ˆã„ã®ã§ã‚ã‚Œã°ã€å…ˆã®ä¾‹ã§ã‚„ã£ãŸã‚ˆã†ã«ã€new ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã—ã¦ :c:func:`PyType_GenericNew` ã‚’ä½¿ã†ã“ã¨ã‚‚ã§ããŸã§ã—ã‚‡ã†ã€‚ :c:func:`PyType_GenericNew` ã¯ã™ã¹ã¦ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã®ãƒ¡ãƒ³ãƒã‚’ *NULL* ã«ã—ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:337
msgid ""
"The new method is a static method that is passed the type being instantiated"
" and any arguments passed when the type was called, and that returns the new"
" object created. New methods always accept positional and keyword arguments,"
" but they often ignore the arguments, leaving the argument handling to "
"initializer methods. Note that if the type supports subclassing, the type "
"passed may not be the type being defined.  The new method calls the tp_alloc"
" slot to allocate memory. We don't fill the "
":c:member:`~PyTypeObject.tp_alloc` slot ourselves. Rather "
":c:func:`PyType_Ready` fills it for us by inheriting it from our base class,"
" which is :class:`object` by default.  Most types use the default "
"allocation."
msgstr "ã“ã® new ãƒ¡ã‚½ãƒƒãƒ‰ã¯é™çš„ãªãƒ¡ã‚½ãƒƒãƒ‰ã§ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã™ã‚‹ã¨ãã«ãã®å‹ã¨ã€å‹ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã®å¼•æ•°ãŒæ¸¡ã•ã‚Œã€æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦è¿”ã—ã¾ã™ã€‚new ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã¤ã­ã«ã€ã‚ã‚‰ã‹ã˜ã‚å›ºå®šå¼•æ•° (positional argument) ã¨ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’å–ã‚Šã¾ã™ãŒã€ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã—ã°ã—ã°ãã‚Œã‚‰ã®å¼•æ•°ã¯ç„¡è¦–ã—ã¦åˆæœŸåŒ–ãƒ¡ã‚½ãƒƒãƒ‰ã«ãã®ã¾ã¾æ¸¡ã—ã¾ã™ã€‚new ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒ¡ãƒ¢ãƒªå‰²ã‚Šå½“ã¦ã®ãŸã‚ã« :c:member:`~PyTypeObject.tp_alloc` ãƒ¡ãƒ³ãƒã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ :c:member:`~PyTypeObject.tp_alloc` ã‚’ã“ã¡ã‚‰ã§åˆæœŸåŒ–ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã¯ :c:func:`PyType_Ready` ãŒåŸºåº•ã‚¯ãƒ©ã‚¹ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ :class:`object`) ã‚’ã‚‚ã¨ã«åŸ‹ã‚ã‚‹ã‚‚ã®ã§ã™ã€‚ã»ã¨ã‚“ã©ã®å‹ã§ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ¡ãƒ¢ãƒªå‰²ã‚Šå½“ã¦ã‚’ä½¿ã£ã¦ã„ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:349
msgid ""
"If you are creating a co-operative :c:member:`~PyTypeObject.tp_new` (one "
"that calls a base type's :c:member:`~PyTypeObject.tp_new` or "
":meth:`__new__`), you must *not* try to determine what method to call using "
"method resolution order at runtime.  Always statically determine what type "
"you are going to call, and call its :c:member:`~PyTypeObject.tp_new` "
"directly, or via ``type->tp_base->tp_new``.  If you do not do this, Python "
"subclasses of your type that also inherit from other Python-defined classes "
"may not work correctly. (Specifically, you may not be able to create "
"instances of such subclasses without getting a :exc:`TypeError`.)"
msgstr "ã‚‚ã—å”åŠ›çš„ãª :c:member:`~PyTypeObject.tp_new` (åŸºåº•ã‚¿ã‚¤ãƒ—ã® :c:member:`~PyTypeObject.tp_new` ã¾ãŸã¯ :meth:`__new__` ã‚’å‘¼ã‚“ã§ã„ã‚‹ã‚‚ã®) ã‚’ä½œã‚ŠãŸã„ã®ãªã‚‰ã°ã€å®Ÿè¡Œæ™‚ã®ãƒ¡ã‚½ãƒƒãƒ‰è§£æ±ºé †åºã‚’ã¤ã‹ã£ã¦ã©ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³ã ã™ã‹ã‚’æ±ºå®šã—ã‚ˆã†ã¨ã—ã¦ã¯ *ã„ã‘ã¾ã›ã‚“* ã€‚ã¤ã­ã«å‘¼ã³å‡ºã™å‹ã‚’é™çš„ã«æ±ºã‚ã¦ãŠãã€ç›´æ¥ãã® :c:member:`~PyTypeObject.tp_new` ã‚’å‘¼ã³å‡ºã™ã‹ã€ã‚ã‚‹ã„ã¯ ``type->tp_base->tp_new`` ã‚’çµŒç”±ã—ã¦ãã ã•ã„ã€‚ã“ã†ã—ãªã„ã¨ã€ã‚ãªãŸãŒä½œæˆã—ãŸã‚¿ã‚¤ãƒ—ã® Python ã‚µãƒ–ã‚¯ãƒ©ã‚¹ãŒä»–ã® Python ã§å®šç¾©ã•ã‚ŒãŸã‚¯ãƒ©ã‚¹ã‚‚ç¶™æ‰¿ã—ã¦ã„ã‚‹å ´åˆã«ã†ã¾ãå‹•ã‹ãªã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ (ã¨ã‚Šã‚ã‘ã€ãã®ã‚ˆã†ãªã‚µãƒ–ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ :exc:`TypeError` ã‚’å‡ºã•ãšã«ä½œã‚‹ã“ã¨ãŒä¸å¯èƒ½ã«ãªã‚Šã¾ã™ã€‚)"

#: ../../extending/newtypes.rst:358
msgid "We provide an initialization function::"
msgstr "ã¤ãã«åˆæœŸåŒ–ç”¨ã®é–¢æ•°ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†::"

#: ../../extending/newtypes.rst:389
msgid "by filling the :c:member:`~PyTypeObject.tp_init` slot. ::"
msgstr "ã“ã‚Œã¯ :c:member:`~PyTypeObject.tp_init` ãƒ¡ãƒ³ãƒã«ä»£å…¥ã•ã‚Œã¾ã™ã€‚ ::"

#: ../../extending/newtypes.rst:393
msgid ""
"The :c:member:`~PyTypeObject.tp_init` slot is exposed in Python as the "
":meth:`__init__` method. It is used to initialize an object after it's "
"created. Unlike the new method, we can't guarantee that the initializer is "
"called.  The initializer isn't called when unpickling objects and it can be "
"overridden.  Our initializer accepts arguments to provide initial values for"
" our instance. Initializers always accept positional and keyword arguments."
msgstr "Python ã§ã¯ã€ :c:member:`~PyTypeObject.tp_init` ãƒ¡ãƒ³ãƒã¯ :meth:`__init__` ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã—ã¦è¦‹ãˆã¦ã„ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä½œæˆã•ã‚ŒãŸã‚ã¨ã«ã€ãã‚Œã‚’åˆæœŸåŒ–ã™ã‚‹ç›®çš„ã§ä½¿ã‚ã‚Œã¾ã™ã€‚ new ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã¯ã¡ãŒã£ã¦ã€åˆæœŸåŒ–ç”¨ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯å¿…ãšå‘¼ã°ã‚Œã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚åˆæœŸåŒ–ç”¨ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®åˆæœŸå€¤ã‚’æä¾›ã™ã‚‹ã®ã«å¿…è¦ãªå¼•æ•°ã‚’å—ã‘ã¨ã‚Šã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã¤ã­ã«å›ºå®šå¼•æ•°ã¨ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’å—ã‘ã¨ã‚Šã¾ã™ã€‚"

#: ../../extending/newtypes.rst:400
msgid ""
"Initializers can be called multiple times.  Anyone can call the "
":meth:`__init__` method on our objects.  For this reason, we have to be "
"extra careful when assigning the new values.  We might be tempted, for "
"example to assign the :attr:`first` member like this::"
msgstr "åˆæœŸåŒ–ãƒ¡ã‚½ãƒƒãƒ‰ã¯è¤‡æ•°å›å‘¼ã³å‡ºã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ã‚ãªãŸã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`__init__` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€èª°ã«ã§ã‚‚å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã‚‹ã‹ã‚‰ã§ã™ã€‚ã“ã®ãŸã‚ã€æ–°ã—ã„å€¤ã‚’ä»£å…¥ã™ã‚‹ã•ã„ã«ã¯ç‰¹åˆ¥ãªæ³¨æ„ã‚’æ‰•ã†å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãŸã¨ãˆã°ã€ :attr:`first` ãƒ¡ãƒ³ãƒã«ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ä»£å…¥ã—ãŸããªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“::"

#: ../../extending/newtypes.rst:411
msgid ""
"But this would be risky.  Our type doesn't restrict the type of the "
":attr:`first` member, so it could be any kind of object.  It could have a "
"destructor that causes code to be executed that tries to access the "
":attr:`first` member.  To be paranoid and protect ourselves against this "
"possibility, we almost always reassign members before decrementing their "
"reference counts.  When don't we have to do this?"
msgstr "ã—ã‹ã—ã“ã®ã‚„ã‚Šæ–¹ã¯å±é™ºã§ã™ã€‚ã“ã®ã‚¿ã‚¤ãƒ—ã§ã¯ :attr:`first` ãƒ¡ãƒ³ãƒã«å…¥ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãªã«ã‚‚é™å®šã—ã¦ã„ãªã„ã®ã§ã€ã©ã‚“ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚‚ã¨ã‚Šå¾—ã¦ã—ã¾ã†ã‹ã‚‰ã§ã™ã€‚ãã‚Œã¯ã“ã®ã‚³ãƒ¼ãƒ‰ãŒ :attr:`first` ãƒ¡ãƒ³ãƒã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã‚ˆã†ã¨ã™ã‚‹å‰ã«ã€ãã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒå‘¼ã³å‡ºã•ã‚Œã¦ã—ã¾ã†ã‹ã‚‚ã—ã‚Œãªã„ã®ã§ã™ã€‚ã“ã®ã‚ˆã†ãªå¯èƒ½æ€§ã‹ã‚‰ãƒ‘ãƒ©ãƒã‚¤ã‚¢çš„ã«èº«ã‚’ã¾ã‚‚ã‚‹ãŸã‚ã€ã»ã¨ã‚“ã©ã®å ´åˆãƒ¡ãƒ³ãƒã¸ã®ä»£å…¥ã¯,ãã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’æ¸›ã‚‰ã™å‰ã«ãŠã“ãªã£ã¦ãã ã•ã„ã€‚ã“ã†ã™ã‚‹å¿…è¦ãŒãªã„ã®ã¯ã©ã‚“ãªå ´åˆã§ã—ã‚‡ã†ã‹?"

#: ../../extending/newtypes.rst:418
msgid "when we absolutely know that the reference count is greater than 1"
msgstr "ãã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒ 1 ã‚ˆã‚Šå¤§ãã„ã¨ç¢ºä¿¡ã§ãã‚‹å ´åˆã€‚"

#: ../../extending/newtypes.rst:420
msgid ""
"when we know that deallocation of the object [#]_ will not cause any calls "
"back into our type's code"
msgstr "ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è§£æ”¾ãŒã‚ãªãŸã®ã‚¿ã‚¤ãƒ—ã®ã‚³ãƒ¼ãƒ‰ã«ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã™ã‚‹ã‚ˆã†ãªã“ã¨ãŒæ±ºã—ã¦ãªã„å ´åˆ [#]_ ã€‚"

#: ../../extending/newtypes.rst:423
msgid ""
"when decrementing a reference count in a "
":c:member:`~PyTypeObject.tp_dealloc` handler when garbage-collections is not"
" supported [#]_"
msgstr "ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„å ´åˆã« :c:member:`~PyTypeObject.tp_dealloc` ãƒãƒ³ãƒ‰ãƒ©ã§å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’æ¸›ã‚‰ã™ã¨ã [#]_ ã€‚"

#: ../../extending/newtypes.rst:426
msgid ""
"We want to expose our instance variables as attributes. There are a number "
"of ways to do that. The simplest way is to define member definitions::"
msgstr "ã“ã“ã§ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã‚’å±æ€§ã¨ã—ã¦è¦‹ãˆã‚‹ã‚ˆã†ã«ã—ãŸã„ã®ã§ã™ãŒã€ã“ã‚Œã«ã¯ã„ãã¤ã‚‚ã®æ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚ã‚‚ã£ã¨ã‚‚ç°¡å˜ãªæ–¹æ³•ã¯ã€ãƒ¡ãƒ³ãƒã®å®šç¾©ã‚’ä¸ãˆã‚‹ã“ã¨ã§ã™::"

#: ../../extending/newtypes.rst:439
msgid ""
"and put the definitions in the :c:member:`~PyTypeObject.tp_members` slot::"
msgstr "ãã—ã¦ã€ã“ã®å®šç¾©ã‚’ :c:member:`~PyTypeObject.tp_members` ã‚¹ãƒ­ãƒƒãƒˆã«å…¥ã‚Œã¾ã—ã‚‡ã†::"

#: ../../extending/newtypes.rst:443
msgid ""
"Each member definition has a member name, type, offset, access flags and "
"documentation string. See the :ref:`Generic-Attribute-Management` section "
"below for details."
msgstr "å„ãƒ¡ãƒ³ãƒã®å®šç¾©ã¯ãã‚Œãã‚Œã€ãƒ¡ãƒ³ãƒã®åå‰ã€å‹ã€ã‚ªãƒ•ã‚»ãƒƒãƒˆã€ã‚¢ã‚¯ã‚»ã‚¹ãƒ•ãƒ©ã‚°ãŠã‚ˆã³ docstring ã§ã™ã€‚è©³ã—ãã¯å¾Œã® \"ç·ç§°çš„ãªå±æ€§ã‚’ç®¡ç†ã™ã‚‹\" (:ref:`Generic-Attribute-Management`) ã®ç¯€ã‚’ã”è¦§ãã ã•ã„ã€‚"

#: ../../extending/newtypes.rst:447
msgid ""
"A disadvantage of this approach is that it doesn't provide a way to restrict"
" the types of objects that can be assigned to the Python attributes.  We "
"expect the first and last names to be strings, but any Python objects can be"
" assigned. Further, the attributes can be deleted, setting the C pointers to"
" *NULL*.  Even though we can make sure the members are initialized to "
"non-*NULL* values, the members can be set to *NULL* if the attributes are "
"deleted."
msgstr "ã“ã®æ–¹æ³•ã®æ¬ ç‚¹ã¯ã€Python å±æ€§ã«ä»£å…¥ã§ãã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã‚’åˆ¶é™ã™ã‚‹æ–¹æ³•ãŒãªã„ã“ã¨ã§ã™ã€‚ã“ã“ã§ã¯ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆãƒãƒ¼ãƒ  first ã¨ãƒ©ã‚¹ãƒˆãƒãƒ¼ãƒ  last ã«ã€ã¨ã‚‚ã«æ–‡å­—åˆ—ãŒå…¥ã‚‹ã‚ˆã†æœŸå¾…ã—ã¦ã„ã¾ã™ãŒã€ä»Šã®ã‚„ã‚Šæ–¹ã§ã¯ã©ã‚“ãª Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚ä»£å…¥ã§ãã¦ã—ã¾ã„ã¾ã™ã€‚åŠ ãˆã¦ã“ã®å±æ€§ã¯å‰Šé™¤ (del) ã§ãã¦ã—ã¾ã„ã€ãã®å ´åˆã€ C ã®ãƒã‚¤ãƒ³ã‚¿ã«ã¯ *NULL* ãŒè¨­å®šã•ã‚Œã¾ã™ã€‚ãŸã¨ãˆã‚‚ã—ãƒ¡ãƒ³ãƒãŒ *NULL* ä»¥å¤–ã®å€¤ã«åˆæœŸåŒ–ã•ã‚Œã‚‹ã‚ˆã†ã«ã—ã¦ã‚ã£ãŸã¨ã—ã¦ã‚‚ã€å±æ€§ãŒå‰Šé™¤ã•ã‚Œã‚Œã°ãƒ¡ãƒ³ãƒã¯ *NULL* ã«ãªã£ã¦ã—ã¾ã„ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:454
msgid ""
"We define a single method, :meth:`name`, that outputs the objects name as "
"the concatenation of the first and last names. ::"
msgstr "ã“ã“ã§ã¯ :meth:`name` ã¨å‘¼ã°ã‚Œã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¾ã—ã‚‡ã†ã€‚ã“ã‚Œã¯ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆãƒãƒ¼ãƒ  first ã¨ãƒ©ã‚¹ãƒˆãƒãƒ¼ãƒ  last ã‚’é€£çµã—ãŸæ–‡å­—åˆ—ã‚’ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åå‰ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚ ::"

#: ../../extending/newtypes.rst:489
msgid ""
"The method is implemented as a C function that takes a :class:`Noddy` (or "
":class:`Noddy` subclass) instance as the first argument.  Methods always "
"take an instance as the first argument. Methods often take positional and "
"keyword arguments as well, but in this case we don't take any and don't need"
" to accept a positional argument tuple or keyword argument dictionary. This "
"method is equivalent to the Python method::"
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ C é–¢æ•°ã¨ã—ã¦å®Ÿè£…ã•ã‚Œã€ :class:`Noddy` (ã‚ã‚‹ã„ã¯   :class:`Noddy` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹) ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç¬¬ä¸€å¼•æ•°ã¨ã—ã¦å—ã‘ã¨ã‚Šã¾ã™ã€‚ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã¤ã­ã«ãã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æœ€åˆã®å¼•æ•°ã¨ã—ã¦å—ã‘ã¨ã‚‰ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã—ã°ã—ã°å›ºå®šå¼•æ•°ã¨ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚‚å—ã‘ã¨ã‚Šã¾ã™ãŒã€ä»Šå›ã¯ãªã«ã‚‚å¿…è¦ãªã„ã®ã§ã€å›ºå®šå¼•æ•°ã®ã‚¿ãƒ—ãƒ«ã‚‚ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã®è¾æ›¸ã‚‚å–ã‚‰ãªã„ã“ã¨ã«ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ Python ã®ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨ç­‰ä¾¡ã§ã™::"

#: ../../extending/newtypes.rst:499
msgid ""
"Note that we have to check for the possibility that our :attr:`first` and "
":attr:`last` members are *NULL*.  This is because they can be deleted, in "
"which case they are set to *NULL*.  It would be better to prevent deletion "
"of these attributes and to restrict the attribute values to be strings.  "
"We'll see how to do that in the next section."
msgstr ":attr:`first` ãƒ¡ãƒ³ãƒã¨ :attr:`last` ãƒ¡ãƒ³ãƒãŒãã‚Œãã‚Œ *NULL* ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã“ã‚Œã‚‰ã¯å‰Šé™¤ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã€ãã®å ´åˆå€¤ã¯ *NULL* ã«ã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚ã“ã®å±æ€§ã®å‰Šé™¤ã‚’ç¦æ­¢ã—ã¦ã€ãã“ã«å…¥ã‚Œã‚‰ã‚Œã‚‹å€¤ã‚’æ–‡å­—åˆ—ã«é™å®šã§ãã‚Œã°ãªãŠã„ã„ã§ã—ã‚‡ã†ã€‚æ¬¡ã®ç¯€ã§ã¯ã“ã‚Œã«ã¤ã„ã¦æ‰±ã„ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:505
msgid ""
"Now that we've defined the method, we need to create an array of method "
"definitions::"
msgstr "ã•ã¦ã€ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ãŸã®ã§ã€ã“ã“ã§ãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©ç”¨ã®é…åˆ—ã‚’ä½œæˆã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™::"

#: ../../extending/newtypes.rst:515
msgid "and assign them to the :c:member:`~PyTypeObject.tp_methods` slot::"
msgstr "ã“ã‚Œã‚’ :c:member:`~PyTypeObject.tp_methods` ã‚¹ãƒ­ãƒƒãƒˆã«å…¥ã‚Œã¾ã—ã‚‡ã†::"

#: ../../extending/newtypes.rst:519
msgid ""
"Note that we used the :const:`METH_NOARGS` flag to indicate that the method "
"is passed no arguments."
msgstr "ã“ã“ã§ã® :const:`METH_NOARGS` ãƒ•ãƒ©ã‚°ã¯ã€ãã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå¼•æ•°ã‚’å–ã‚‰ãªã„ã“ã¨ã‚’å®£è¨€ã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:522
msgid ""
"Finally, we'll make our type usable as a base class.  We've written our "
"methods carefully so far so that they don't make any assumptions about the "
"type of the object being created or used, so all we need to do is to add the"
" :const:`Py_TPFLAGS_BASETYPE` to our class flag definition::"
msgstr "æœ€å¾Œã«ã€ã“ã®å‹ã‚’åŸºåº•ã‚¯ãƒ©ã‚¹ã¨ã—ã¦åˆ©ç”¨å¯èƒ½ã«ã—ã¾ã—ã‚‡ã†ã€‚ä¸Šã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯æ³¨æ„ã¶ã‹ãæ›¸ã‹ã‚Œã¦ã„ã‚‹ã®ã§ã€ã“ã‚Œã¯ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ãŒä½œæˆã•ã‚ŒãŸã‚Šåˆ©ç”¨ã•ã‚Œã‚‹å ´åˆã«ã¤ã„ã¦ã©ã‚“ãªä»®å®šã‚‚ç½®ã„ã¦ã„ã¾ã›ã‚“ã€‚ãªã®ã§ã€ã“ã“ã§ã™ã¹ãã“ã¨ã¯ :const:`Py_TPFLAGS_BASETYPE` ã‚’ã‚¯ãƒ©ã‚¹å®šç¾©ã®ãƒ•ãƒ©ã‚°ã«åŠ ãˆã‚‹ã ã‘ã§ã™::"

#: ../../extending/newtypes.rst:529
msgid ""
"We rename :c:func:`initnoddy` to :c:func:`initnoddy2` and update the module "
"name passed to :c:func:`Py_InitModule3`."
msgstr ":c:func:`initnoddy` ã®åå‰ã‚’ :c:func:`initnoddy2` ã«å¤‰æ›´ã—ã€ :c:func:`Py_InitModule3` ã«æ¸¡ã•ã‚Œã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã‚’æ›´æ–°ã—ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:532
msgid "Finally, we update our :file:`setup.py` file to build the new module::"
msgstr "ã•ã„ã”ã« :file:`setup.py` ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›´æ–°ã—ã¦æ–°ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ“ãƒ«ãƒ‰ã—ã¾ã™::"

#: ../../extending/newtypes.rst:543
msgid "Providing finer control over data attributes"
msgstr "ãƒ‡ãƒ¼ã‚¿å±æ€§ã‚’ã“ã¾ã‹ãåˆ¶å¾¡ã™ã‚‹"

#: ../../extending/newtypes.rst:545
msgid ""
"In this section, we'll provide finer control over how the :attr:`first` and "
":attr:`last` attributes are set in the :class:`Noddy` example. In the "
"previous version of our module, the instance variables :attr:`first` and "
":attr:`last` could be set to non-string values or even deleted. We want to "
"make sure that these attributes always contain strings."
msgstr "ã“ã®ç¯€ã§ã¯ã€ :class:`Noddy` ã‚¯ãƒ©ã‚¹ã®ä¾‹ã«ã‚ã£ãŸ :attr:`first` ã¨ :attr:`last` ã®å„å±æ€§ã«ãŸã„ã—ã¦ã€ã‚ˆã‚Šç²¾å¯†ãªåˆ¶å¾¡ã‚’æä¾›ã—ã¾ã™ã€‚ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã® :attr:`first` ã¨ :attr:`last` ã«ã¯æ–‡å­—åˆ—ä»¥å¤–ã®ã‚‚ã®ã‚‚ä»£å…¥ã§ãã¦ã—ã¾ã„ã€ã‚ã¾ã¤ã•ãˆå‰Šé™¤ã¾ã§å¯èƒ½ã§ã—ãŸã€‚ã“ã“ã§ã¯ã“ã‚Œã‚‰ã®å±æ€§ãŒå¿…ãšæ–‡å­—åˆ—ã‚’ä¿æŒã—ã¦ã„ã‚‹ã‚ˆã†ã«ã—ã¾ã—ã‚‡ã†ã€‚"

#: ../../extending/newtypes.rst:554
msgid ""
"To provide greater control, over the :attr:`first` and :attr:`last` "
"attributes, we'll use custom getter and setter functions.  Here are the "
"functions for getting and setting the :attr:`first` attribute::"
msgstr ":attr:`first` å±æ€§ã¨ :attr:`last` å±æ€§ã‚’ã‚ˆã‚Šã“ã¾ã‹ãåˆ¶å¾¡ã™ã‚‹ãŸã‚ã«ã¯ã€ã‚«ã‚¹ã‚¿ãƒ ãƒ¡ã‚¤ãƒ‰ã® getter é–¢æ•°ã¨ setter é–¢æ•°ã‚’ä½¿ã„ã¾ã™ã€‚ä»¥ä¸‹ã¯ :attr:`first` å±æ€§ã‹ã‚‰å€¤ã‚’å–å¾—ã™ã‚‹é–¢æ•° (getter) ã¨ã€ã“ã®å±æ€§ã«å€¤ã‚’æ ¼ç´ã™ã‚‹é–¢æ•° (setter) ã§ã™::"

#: ../../extending/newtypes.rst:585
msgid ""
"The getter function is passed a :class:`Noddy` object and a \"closure\", "
"which is void pointer. In this case, the closure is ignored. (The closure "
"supports an advanced usage in which definition data is passed to the getter "
"and setter. This could, for example, be used to allow a single set of getter"
" and setter functions that decide the attribute to get or set based on data "
"in the closure.)"
msgstr "getter é–¢æ•°ã«ã¯ :class:`Noddy` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã€Œé–‰åŒ… (closure)ã€ (ã“ã‚Œã¯ voidå‹ã®ãƒã‚¤ãƒ³ã‚¿ã§ã™) ãŒæ¸¡ã•ã‚Œã¾ã™ã€‚ä»Šå›ã®ã‚±ãƒ¼ã‚¹ã§ã¯é–‰åŒ…ã¯ç„¡è¦–ã—ã¾ã™ã€‚ (é–‰åŒ…ã¨ã¯å®šç¾©ãƒ‡ãƒ¼ã‚¿ãŒæ¸¡ã•ã‚Œã‚‹ setter ã‚„ getter ã®é«˜åº¦ãªåˆ©ç”¨ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãŸã‚ã®ã‚‚ã®ã§ã€ã“ã‚Œã‚’ä½¿ã†ã¨ãŸã¨ãˆã° getter ã¨ setter ã‚’ã²ã¨ã¾ã¨ã‚ã«ã—ãŸé–¢æ•°ã«ã€é–‰åŒ…ã®ãƒ‡ãƒ¼ã‚¿ã«ã‚‚ã¨ã¥ã„ã¦å±æ€§ã‚’ get ã™ã‚‹ã‹ set ã™ã‚‹ã‹æ±ºã‚ã•ã›ã‚‹ã€ã¨ã„ã£ãŸã“ã¨ãŒã§ãã¾ã™ã€‚)"

#: ../../extending/newtypes.rst:591
msgid ""
"The setter function is passed the :class:`Noddy` object, the new value, and "
"the closure. The new value may be *NULL*, in which case the attribute is "
"being deleted.  In our setter, we raise an error if the attribute is deleted"
" or if the attribute value is not a string."
msgstr "setter é–¢æ•°ã«ã¯ :class:`Noddy` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨æ–°ã—ã„å€¤ã€ãã—ã¦é–‰åŒ…ãŒæ¸¡ã•ã‚Œã¾ã™ã€‚æ–°ã—ã„å€¤ã¯ *NULL* ã‹ã‚‚ã—ã‚Œãšã€ãã®å ´åˆã¯ã“ã®å±æ€§ãŒå‰Šé™¤ã•ã‚Œã¾ã™ã€‚ã“ã“ã§ã¯å±æ€§ãŒå‰Šé™¤ã•ã‚ŒãŸã‚Šã€ãã®å€¤ãŒæ–‡å­—åˆ—ã§ãªã„ã¨ãã«ã¯ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿã•ã›ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:596
msgid "We create an array of :c:type:`PyGetSetDef` structures::"
msgstr "ã“ã“ã§ã¯ :c:type:`PyGetSetDef` æ§‹é€ ä½“ã®é…åˆ—ã‚’ã¤ãã‚Šã¾ã™::"

#: ../../extending/newtypes.rst:610
msgid "and register it in the :c:member:`~PyTypeObject.tp_getset` slot::"
msgstr "ãã—ã¦ã“ã‚Œã‚’ :c:member:`~PyTypeObject.tp_getset` ã‚¹ãƒ­ãƒƒãƒˆã«ç™»éŒ²ã—ã¾ã™::"

#: ../../extending/newtypes.rst:614
msgid "to register our attribute getters and setters."
msgstr "ã“ã‚Œã§å±æ€§ã® getter ã¨ setter ãŒç™»éŒ²ã§ãã¾ã—ãŸã€‚"

#: ../../extending/newtypes.rst:616
msgid ""
"The last item in a :c:type:`PyGetSetDef` structure is the closure mentioned "
"above. In this case, we aren't using the closure, so we just pass *NULL*."
msgstr ":c:type:`PyGetSetDef` æ§‹é€ ä½“ã®æœ€å¾Œã®è¦ç´ ãŒä¸Šã§èª¬æ˜ã—ãŸé–‰åŒ…ã§ã™ã€‚ä»Šå›ã¯é–‰åŒ…ã¯ä½¿ã‚ãªã„ã®ã§ *NULL* ã‚’æ¸¡ã—ã¦ã„ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:619
msgid "We also remove the member definitions for these attributes::"
msgstr "ã¾ãŸã€ãƒ¡ãƒ³ãƒå®šç¾©ã‹ã‚‰ã¯ã“ã‚Œã‚‰ã®å±æ€§ã‚’é™¤ã„ã¦ãŠãã¾ã—ã‚‡ã†::"

#: ../../extending/newtypes.rst:627
msgid ""
"We also need to update the :c:member:`~PyTypeObject.tp_init` handler to only"
" allow strings [#]_ to be passed::"
msgstr "ã¾ãŸã€ã“ã“ã§ã¯ :c:member:`~PyTypeObject.tp_init` ãƒãƒ³ãƒ‰ãƒ©ã‚‚æ¸¡ã•ã‚Œã‚‹ã‚‚ã®ã¨ã—ã¦æ–‡å­—åˆ—ã®ã¿ã‚’è¨±å¯ã™ã‚‹ã‚ˆã†ã«ä¿®æ­£ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ [#]_::"

#: ../../extending/newtypes.rst:659
msgid ""
"With these changes, we can assure that the :attr:`first` and :attr:`last` "
"members are never *NULL* so we can remove checks for *NULL* values in almost"
" all cases. This means that most of the :c:func:`Py_XDECREF` calls can be "
"converted to :c:func:`Py_DECREF` calls. The only place we can't change these"
" calls is in the deallocator, where there is the possibility that the "
"initialization of these members failed in the constructor."
msgstr "ã“ã‚Œã‚‰ã®å¤‰æ›´ã«ã‚ˆã£ã¦ã€ :attr:`first` ãƒ¡ãƒ³ãƒã¨ :attr:`last` ãƒ¡ãƒ³ãƒãŒæ±ºã—ã¦ *NULL* ã«ãªã‚‰ãªã„ã¨ä¿è¨¼ã§ãã¾ã—ãŸã€‚ã“ã‚Œã§ã»ã¨ã‚“ã©ã™ã¹ã¦ã®ã‚±ãƒ¼ã‚¹ã‹ã‚‰ *NULL* å€¤ã®ãƒã‚§ãƒƒã‚¯ã‚’é™¤ã‘ã¾ã™ã€‚ã“ã‚Œã¯ :c:func:`Py_XDECREF` å‘¼ã³å‡ºã—ã‚’ :c:func:`Py_DECREF` å‘¼ã³å‡ºã—ã«å¤‰ãˆã‚‰ã‚Œã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚å”¯ä¸€ã“ã‚Œã‚’å¤‰ãˆã‚‰ã‚Œãªã„ã®ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè§£æ”¾ãƒ¡ã‚½ãƒƒãƒ‰ (deallocator) ã§ã€ãªãœãªã‚‰ã“ã“ã§ã¯ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«ã‚ˆã‚‹ãƒ¡ãƒ³ãƒåˆæœŸåŒ–ãŒå¤±æ•—ã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã‹ã‚‰ã§ã™ã€‚"

#: ../../extending/newtypes.rst:666
msgid ""
"We also rename the module initialization function and module name in the "
"initialization function, as we did before, and we add an extra definition to"
" the :file:`setup.py` file."
msgstr "ã•ã¦ã€å…ˆã»ã©ã‚‚ã—ãŸã‚ˆã†ã«ã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆæœŸåŒ–é–¢æ•°ã¨åˆæœŸåŒ–é–¢æ•°å†…ã«ã‚ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã‚’å¤‰æ›´ã—ã¾ã—ã‚‡ã†ã€‚ãã—ã¦ :file:`setup.py` ãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½åŠ ã®å®šç¾©ã‚’ãã‚ãˆã¾ã™ã€‚"

#: ../../extending/newtypes.rst:672
msgid "Supporting cyclic garbage collection"
msgstr "å¾ªç’°ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹"

#: ../../extending/newtypes.rst:674
msgid ""
"Python has a cyclic-garbage collector that can identify unneeded objects "
"even when their reference counts are not zero. This can happen when objects "
"are involved in cycles.  For example, consider::"
msgstr "Python ã¯å¾ªç’°ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ã‚’ã‚‚ã£ã¦ãŠã‚Šã€ã“ã‚Œã¯ä¸è¦ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã€ãŸã¨ãˆå‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒã‚¼ãƒ­ã§ãªãã¦ã‚‚ã€ç™ºè¦‹ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‚ç…§ãŒå¾ªç’°ã—ã¦ã„ã‚‹ã¨ãã«èµ·ã“ã‚Šãˆã¾ã™ã€‚ãŸã¨ãˆã°ä»¥ä¸‹ã®ä¾‹ã‚’è€ƒãˆã¦ãã ã•ã„::"

#: ../../extending/newtypes.rst:682
msgid ""
"In this example, we create a list that contains itself. When we delete it, "
"it still has a reference from itself. Its reference count doesn't drop to "
"zero. Fortunately, Python's cyclic-garbage collector will eventually figure "
"out that the list is garbage and free it."
msgstr "ã“ã®ä¾‹ã§ã¯ã€è‡ªåˆ†è‡ªèº«ã‚’ãµãã‚€ãƒªã‚¹ãƒˆã‚’ã¤ãã‚Šã¾ã—ãŸã€‚ãŸã¨ãˆã“ã®ãƒªã‚¹ãƒˆã‚’ del ã—ã¦ã‚‚ã€ãã‚Œã¯è‡ªåˆ†è‡ªèº«ã¸ã®å‚ç…§ã‚’ã¾ã æŒã¡ã¤ã¥ã‘ã¾ã™ã‹ã‚‰ã€å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã¯ã‚¼ãƒ­ã«ã¯ãªã‚Šã¾ã›ã‚“ã€‚å¬‰ã—ã„ã“ã¨ã« Python ã«ã¯å¾ªç’°ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ãŒã‚ã‚Šã¾ã™ã‹ã‚‰ã€æœ€çµ‚çš„ã«ã¯ã“ã®ãƒªã‚¹ãƒˆãŒä¸è¦ã§ã‚ã‚‹ã“ã¨ã‚’æ¤œå‡ºã—ã€è§£æ”¾ã§ãã¾ã™ã€‚"

#: ../../extending/newtypes.rst:687
msgid ""
"In the second version of the :class:`Noddy` example, we allowed any kind of "
"object to be stored in the :attr:`first` or :attr:`last` attributes [#]_. "
"This means that :class:`Noddy` objects can participate in cycles::"
msgstr ""

#: ../../extending/newtypes.rst:696
msgid ""
"This is pretty silly, but it gives us an excuse to add support for the "
"cyclic-garbage collector to the :class:`Noddy` example.  To support cyclic "
"garbage collection, types need to fill two slots and set a class flag that "
"enables these slots:"
msgstr "ã“ã‚Œã¯å®Ÿã«ã°ã‹ã’ãŸä¾‹ã§ã™ãŒã€ã™ããªãã¨ã‚‚ :class:`Noddy` ã‚¯ãƒ©ã‚¹ã«å¾ªç’°ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ã®ã‚µãƒãƒ¼ãƒˆã‚’åŠ ãˆã‚‹å£å®Ÿã‚’ä¸ãˆã¦ãã‚Œã¾ã™ã€‚å¾ªç’°ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã«ã¯ 2ã¤ã®ã‚¿ã‚¤ãƒ—ã‚¹ãƒ­ãƒƒãƒˆã‚’åŸ‹ã‚ã€ã“ã‚Œã‚‰ã®ã‚¹ãƒ­ãƒƒãƒˆã‚’è¨±å¯ã™ã‚‹ã‚ˆã†ã«ã‚¯ãƒ©ã‚¹å®šç¾©ã®ãƒ•ãƒ©ã‚°ã‚’è¨­å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™:"

#: ../../extending/newtypes.rst:704
msgid ""
"The traversal method provides access to subobjects that could participate in"
" cycles::"
msgstr "traversal ãƒ¡ã‚½ãƒƒãƒ‰ã¯å¾ªç’°ã—ãŸå‚ç…§ã«å«ã¾ã‚Œã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹å†…éƒ¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’æä¾›ã—ã¾ã™::"

#: ../../extending/newtypes.rst:726
msgid ""
"For each subobject that can participate in cycles, we need to call the "
":c:func:`visit` function, which is passed to the traversal method. The "
":c:func:`visit` function takes as arguments the subobject and the extra "
"argument *arg* passed to the traversal method.  It returns an integer value "
"that must be returned if it is non-zero."
msgstr "å¾ªç’°ã—ãŸå‚ç…§ã«å«ã¾ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œãªã„å„å†…éƒ¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ã€ traversal ãƒ¡ã‚½ãƒƒãƒ‰ã«æ¸¡ã•ã‚ŒãŸ :c:func:`visit` é–¢æ•°ã‚’å‘¼ã³ã¾ã™ã€‚ :c:func:`visit` é–¢æ•°ã¯å†…éƒ¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã€traversal ãƒ¡ã‚½ãƒƒãƒ‰ã«æ¸¡ã•ã‚ŒãŸè¿½åŠ ã®å¼•æ•° *arg* ã‚’å¼•æ•°ã¨ã—ã¦ã¨ã‚Šã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ã“ã®å€¤ãŒéè² ã®å ´åˆã«è¿”ã•ã‚Œã‚‹æ•´æ•°ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:732
msgid ""
"Python 2.4 and higher provide a :c:func:`Py_VISIT` macro that automates "
"calling visit functions.  With :c:func:`Py_VISIT`, :c:func:`Noddy_traverse` "
"can be simplified::"
msgstr "Python 2.4 ä»¥é™ã§ã¯ã€visit é–¢æ•°ã®å‘¼ã³å‡ºã—ã‚’è‡ªå‹•åŒ–ã™ã‚‹ :c:func:`Py_VISIT` ãƒã‚¯ãƒ­ãŒç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ã€‚ :c:func:`Py_VISIT` ã‚’ä½¿ãˆã°ã€ :c:func:`Noddy_traverse` ã¯æ¬¡ã®ã‚ˆã†ã«ç°¡ç•¥åŒ–ã§ãã¾ã™::"

#: ../../extending/newtypes.rst:746
msgid ""
"Note that the :c:member:`~PyTypeObject.tp_traverse` implementation must name"
" its arguments exactly *visit* and *arg* in order to use :c:func:`Py_VISIT`."
"  This is to encourage uniformity across these boring implementations."
msgstr "æ³¨æ„: :c:member:`~PyTypeObject.tp_traverse` ã®å®Ÿè£…ã§ :c:func:`Py_VISIT` ã‚’ä½¿ã†ã«ã¯ã€ãã®å¼•æ•°ã«æ­£ç¢ºã« *visit* ãŠã‚ˆã³ *arg* ã¨ã„ã†åå‰ã‚’ã¤ã‘ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯ã€ã“ã®é€€å±ˆãªå®Ÿè£…ã«çµ±ä¸€æ€§ã‚’å°å…¥ã™ã‚‹ã“ã¨ã‚’ä¿ƒé€²ã—ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:750
msgid ""
"We also need to provide a method for clearing any subobjects that can "
"participate in cycles."
msgstr ""

#: ../../extending/newtypes.rst:771
msgid ""
"Notice the use of a temporary variable in :c:func:`Noddy_clear`. We use the "
"temporary variable so that we can set each member to *NULL* before "
"decrementing its reference count.  We do this because, as was discussed "
"earlier, if the reference count drops to zero, we might cause code to run "
"that calls back into the object.  In addition, because we now support "
"garbage collection, we also have to worry about code being run that triggers"
" garbage collection.  If garbage collection is run, our "
":c:member:`~PyTypeObject.tp_traverse` handler could get called. We can't "
"take a chance of having :c:func:`Noddy_traverse` called when a member's "
"reference count has dropped to zero and its value hasn't been set to *NULL*."
msgstr ":c:func:`Noddy_clear` ä¸­ã§ã®ä¸€æ™‚å¤‰æ•°ã®ä½¿ã„æ–¹ã«æ³¨ç›®ã—ã¦ãã ã•ã„ã€‚ã“ã“ã§ã¯ã€ä¸€æ™‚å¤‰æ•°ã‚’ã¤ã‹ã£ã¦å„ãƒ¡ãƒ³ãƒã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’æ¸›ã‚‰ã™å‰ã«ãã‚Œã‚‰ã« *NULL* ã‚’ä»£å…¥ã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯æ¬¡ã®ã‚ˆã†ãªç†ç”±ã«ã‚ˆã‚Šã¾ã™ã€‚ã™ã§ã«ãŠè©±ã—ã—ãŸã‚ˆã†ã«ã€ã‚‚ã—å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒã‚¼ãƒ­ã«ãªã‚‹ã¨ã€ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã•ã‚Œã‚‹ã‚ˆã†ã«ãªã£ã¦ã—ã¾ã„ã¾ã™ã€‚ã•ã‚‰ã«ã€ã„ã¾ã‚„ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ãŸã‚ã€ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³æ™‚ã«å®Ÿè¡Œã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ‰ã«ã¤ã„ã¦ã‚‚å¿ƒé…ã—ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ã‚‚ã—ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãŒèµ°ã£ã¦ã„ã‚‹ã¨ã€ã‚ãªãŸã® :c:member:`~PyTypeObject.tp_traverse` ãƒãƒ³ãƒ‰ãƒ©ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ãƒ¡ãƒ³ãƒã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒã‚¼ãƒ­ã«ãªã£ãŸå ´åˆã«ã€ãã®å€¤ãŒ *NULL* ã«è¨­å®šã•ã‚Œã¦ã„ãªã„ã¨ :c:func:`Noddy_traverse` ãŒå‘¼ã°ã‚Œã‚‹æ©Ÿä¼šã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../extending/newtypes.rst:781
msgid ""
"Python 2.4 and higher provide a :c:func:`Py_CLEAR` that automates the "
"careful decrementing of reference counts.  With :c:func:`Py_CLEAR`, the "
":c:func:`Noddy_clear` function can be simplified::"
msgstr "Python 2.4 ä»¥é™ã§ã¯ã€æ³¨æ„ã¶ã‹ãå‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’æ¸›ã‚‰ã™ãŸã‚ã®ãƒã‚¯ãƒ­ :c:func:`Py_CLEAR` ãŒç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ã€‚ :c:func:`Py_CLEAR` ã‚’ä½¿ãˆã°ã€ :c:func:`Noddy_clear` ã¯æ¬¡ã®ã‚ˆã†ã«ç°¡ç•¥åŒ–ã§ãã¾ã™::"

#: ../../extending/newtypes.rst:793
msgid ""
"Note that :c:func:`Noddy_dealloc` may call arbitrary functions through "
"``__del__`` method or weakref callback. It means circular GC can be "
"triggered inside the function.  Since GC assumes reference count is not "
"zero, we need to untrack the object from GC by calling "
":c:func:`PyObject_GC_UnTrack` before clearing members. Here is reimplemented"
" deallocator which uses :c:func:`PyObject_GC_UnTrack` and "
":c:func:`Noddy_clear`."
msgstr ""

#: ../../extending/newtypes.rst:810
msgid ""
"Finally, we add the :const:`Py_TPFLAGS_HAVE_GC` flag to the class flags::"
msgstr "æœ€å¾Œã«ã€ :const:`Py_TPFLAGS_HAVE_GC` ãƒ•ãƒ©ã‚°ã‚’ã‚¯ãƒ©ã‚¹å®šç¾©ã®ãƒ•ãƒ©ã‚°ã«åŠ ãˆã¾ã™::"

#: ../../extending/newtypes.rst:814
msgid ""
"That's pretty much it.  If we had written custom "
":c:member:`~PyTypeObject.tp_alloc` or :c:member:`~PyTypeObject.tp_free` "
"slots, we'd need to modify them for cyclic-garbage collection. Most "
"extensions will use the versions automatically provided."
msgstr "ã“ã‚Œã§å®Œäº†ã§ã™ã€‚ :c:member:`~PyTypeObject.tp_alloc` ã‚¹ãƒ­ãƒƒãƒˆã¾ãŸã¯ :c:member:`~PyTypeObject.tp_free` ã‚¹ãƒ­ãƒƒãƒˆãŒæ›¸ã‹ã‚Œã¦ã„ã‚Œã°ã€ãã‚Œã‚‰ã‚’å¾ªç’°ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«ä½¿ãˆã‚‹ã‚ˆã†ä¿®æ­£ã™ã‚Œã°ã‚ˆã„ã®ã§ã™ã€‚ã»ã¨ã‚“ã©ã®æ‹¡å¼µæ©Ÿèƒ½ã¯è‡ªå‹•çš„ã«æä¾›ã•ã‚Œã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ä½¿ã†ã§ã—ã‚‡ã†ã€‚"

#: ../../extending/newtypes.rst:820
msgid "Subclassing other types"
msgstr "ä»–ã®å‹ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’ä½œã‚‹"

#: ../../extending/newtypes.rst:822
msgid ""
"It is possible to create new extension types that are derived from existing "
"types. It is easiest to inherit from the built in types, since an extension "
"can easily use the :class:`PyTypeObject` it needs. It can be difficult to "
"share these :class:`PyTypeObject` structures between extension modules."
msgstr "æ—¢å­˜ã®å‹ã‚’ç¶™æ‰¿ã—ãŸæ–°ã—ã„æ‹¡å¼µå‹ã‚’ä½œæˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚çµ„ã¿è¾¼ã¿å‹ã‹ã‚‰ç¶™æ‰¿ã™ã‚‹ã®ã¯ç‰¹ã«ç°¡å˜ã§ã™ã€‚å¿…è¦ãª :class:`PyTypeObject` ã‚’ç°¡å˜ã«åˆ©ç”¨ã§ãã‚‹ã‹ã‚‰ã§ã™ã€‚ãã‚Œã«æ¯”ã¹ã¦ã€ :class:`PyTypeObject` æ§‹é€ ä½“ã‚’æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«é–“ã§å…±æœ‰ã™ã‚‹ã®ã¯é›£ã—ã„ã§ã™ã€‚"

#: ../../extending/newtypes.rst:827
msgid ""
"In this example we will create a :class:`Shoddy` type that inherits from the"
" built-in :class:`list` type. The new type will be completely compatible "
"with regular lists, but will have an additional :meth:`increment` method "
"that increases an internal counter. ::"
msgstr "æ¬¡ã®ä¾‹ã§ã¯ã€ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ã® :class:`list` å‹ã‚’ç¶™æ‰¿ã—ãŸ :class:`Shoddy` å‹ã‚’ä½œæˆã—ã¦ã„ã¾ã™ã€‚æ–°ã—ã„å‹ã¯é€šå¸¸ã®ãƒªã‚¹ãƒˆå‹ã¨å®Œå…¨ã«äº’æ›æ€§ãŒã‚ã‚Šã¾ã™ãŒã€è¿½åŠ ã§å†…éƒ¨ã®ã‚«ã‚¦ãƒ³ã‚¿ã‚’å¢—ã‚„ã™ :meth:`increment` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ ::"

#: ../../extending/newtypes.rst:845
msgid ""
"As you can see, the source code closely resembles the :class:`Noddy` "
"examples in previous sections. We will break down the main differences "
"between them. ::"
msgstr "è¦‹ã¦ã‚ã‹ã‚‹ã‚ˆã†ã«ã€ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¯å‰ã®ç¯€ã® :class:`Noddy` ã®æ™‚ã¨éå¸¸ã«ä¼¼ã¦ã„ã¾ã™ã€‚é•ã†éƒ¨åˆ†ã‚’ãã‚Œãã‚Œã‚’è¦‹ã¦ã„ãã¾ã™ã€‚ ::"

#: ../../extending/newtypes.rst:853
msgid ""
"The primary difference for derived type objects is that the base type's "
"object structure must be the first value. The base type will already include"
" the :c:func:`PyObject_HEAD` at the beginning of its structure."
msgstr "ç¶™æ‰¿ã—ãŸå‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æœ€åˆã®é•ã„ã¯ã€è¦ªã‚¯ãƒ©ã‚¹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ ãŒæœ€åˆã«å¿…è¦ãªã“ã¨ã§ã™ã€‚åŸºåº•å‹ãŒæ—¢ã« :c:func:`PyObject_HEAD` ã‚’æ§‹é€ ä½“ã®å…ˆé ­ã«æŒã£ã¦ã„ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:857
msgid ""
"When a Python object is a :class:`Shoddy` instance, its *PyObject\\** "
"pointer can be safely cast to both *PyListObject\\** and *Shoddy\\**. ::"
msgstr "Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ :class:`Shoddy` å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã ã£ãŸå ´åˆã€ãã® *PyObject\\** ãƒã‚¤ãƒ³ã‚¿ã¯ *PyListObject\\** ã«ã‚‚ *Shoddy\\** ã«ã‚‚å®‰å…¨ã«ã‚­ãƒ£ã‚¹ãƒˆã§ãã¾ã™ã€‚ ::"

#: ../../extending/newtypes.rst:869
msgid ""
"In the :attr:`__init__` method for our type, we can see how to call through "
"to the :attr:`__init__` method of the base type."
msgstr "ã“ã®æ–°ã—ã„å‹ã® :attr:`__init__` ãƒ¡ã‚½ãƒƒãƒ‰ã§ã€åŸºåº•å‹ã® :attr:`__init__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¦ã„ã‚‹æ§˜å­ã‚’è¦‹ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../extending/newtypes.rst:872
msgid ""
"This pattern is important when writing a type with custom :attr:`new` and "
":attr:`dealloc` methods. The :attr:`new` method should not actually create "
"the memory for the object with :c:member:`~PyTypeObject.tp_alloc`, that will"
" be handled by the base class when calling its "
":c:member:`~PyTypeObject.tp_new`."
msgstr "ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€ã‚«ã‚¹ã‚¿ãƒ ã® :attr:`new` ã¨ :attr:`dealloc` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã™ã‚‹ã¨ãã«ã¯é‡è¦ã§ã™ã€‚ç¶™æ‰¿ã—ãŸå‹ã® :attr:`new` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ :c:member:`~PyTypeObject.tp_alloc` ã‚’ä½¿ã£ã¦ãƒ¡ãƒ¢ãƒªã‚’å‰²ã‚Šå½“ã¦ã‚‹ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãã‚Œã¯åŸºåº•å‹ã® :c:member:`~PyTypeObject.tp_new` ã‚’å‘¼å‡ºãŸã¨ãã«å‡¦ç†ã•ã‚Œã‚‹ã‹ã‚‰ã§ã™ã€‚"

#: ../../extending/newtypes.rst:877
msgid ""
"When filling out the :c:func:`PyTypeObject` for the :class:`Shoddy` type, "
"you see a slot for :c:func:`tp_base`. Due to cross platform compiler issues,"
" you can't fill that field directly with the :c:func:`PyList_Type`; it can "
"be done later in the module's :c:func:`init` function. ::"
msgstr ":class:`Shoddy` å‹ã®ãŸã‚ã« :c:func:`PyTypeObject` ã‚’åŸ‹ã‚ã‚‹ã¨ãã€ :c:func:`tp_base` ã‚¹ãƒ­ãƒƒãƒˆã‚’è¦‹ã¤ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«å¯¾å¿œã™ã‚‹ãŸã‚ã«ã€ç›´æ¥ãã®ã‚¹ãƒ­ãƒƒãƒˆã‚’ :c:func:`PyList_Type` ã§åŸ‹ã‚ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚ä»£ã‚ã‚Šã«ã€å¾Œã§ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® :c:func:`init` é–¢æ•°ã®ä¸­ã§è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚ ::"

#: ../../extending/newtypes.rst:899
msgid ""
"Before calling :c:func:`PyType_Ready`, the type structure must have the "
":c:member:`~PyTypeObject.tp_base` slot filled in. When we are deriving a new"
" type, it is not necessary to fill out the "
":c:member:`~PyTypeObject.tp_alloc` slot with :c:func:`PyType_GenericNew` -- "
"the allocate function from the base type will be inherited."
msgstr ":c:func:`PyType_Read` ã‚’å‘¼ã¶å‰ã«ã€å‹ã®æ§‹é€ ã¯ :c:member:`~PyTypeObject.tp_base` ã‚¹ãƒ­ãƒƒãƒˆã¯åŸ‹ã‚ã‚‰ã‚Œã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ç¶™æ‰¿ã—ã¦ã„ã‚‹æ–°ã—ã„å‹ã‚’ä½œã‚‹ã¨ãã€ :c:member:`~PyTypeObject.tp_alloc` ã‚¹ãƒ­ãƒƒãƒˆã‚’ :c:func:`PyType_GenericNew` ã§åŸ‹ã‚ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ -- åŸºåº•å‹ã®ã‚¢ãƒ­ã‚±ãƒ¼ãƒˆé–¢æ•°ãŒç¶™æ‰¿ã•ã‚Œã¾ã™ã€‚"

#: ../../extending/newtypes.rst:904
msgid ""
"After that, calling :c:func:`PyType_Ready` and adding the type object to the"
" module is the same as with the basic :class:`Noddy` examples."
msgstr "ã“ã®å¾Œã¯ã€ :c:func:`PyType_Ready` é–¢æ•°ã‚’å‘¼ã³ã€ã‚¿ã‚¤ãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¸è¿½åŠ ã™ã‚‹ã®ã¯ã€åŸºæœ¬çš„ãª :class:`Noddy` ã®ä¾‹ã¨åŒã˜ã§ã™ã€‚"

#: ../../extending/newtypes.rst:911
msgid "Type Methods"
msgstr "ã‚¿ã‚¤ãƒ—ãƒ¡ã‚½ãƒƒãƒ‰"

#: ../../extending/newtypes.rst:913
msgid ""
"This section aims to give a quick fly-by on the various type methods you can"
" implement and what they do."
msgstr "ã“ã®ç¯€ã§ã¯ã•ã¾ã–ã¾ãªå®Ÿè£…å¯èƒ½ãªã‚¿ã‚¤ãƒ—ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã€ãã‚Œã‚‰ãŒä½•ã‚’ã™ã‚‹ã‚‚ã®ã§ã‚ã‚‹ã‹ã«ã¤ã„ã¦ã€ã–ã£ã¨èª¬æ˜ã—ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:916
msgid ""
"Here is the definition of :c:type:`PyTypeObject`, with some fields only used"
" in debug builds omitted:"
msgstr "ä»¥ä¸‹ã¯ :c:type:`PyTypeObject` ã®å®šç¾©ã§ã™ã€‚ãƒ‡ãƒãƒƒã‚°ãƒ“ãƒ«ãƒ‰ã§ã—ã‹ä½¿ã‚ã‚Œãªã„ã„ãã¤ã‹ã®ãƒ¡ãƒ³ãƒã¯çœã„ã¦ã‚ã‚Šã¾ã™:"

#: ../../extending/newtypes.rst:922
msgid ""
"Now that's a *lot* of methods.  Don't worry too much though - if you have a "
"type you want to define, the chances are very good that you will only "
"implement a handful of these."
msgstr "*ãŸãã•ã‚“ã®* ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã­ã€‚ã§ã‚‚ãã‚“ãªã«å¿ƒé…ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚å®šç¾©ã—ãŸã„å‹ãŒã‚ã‚‹ãªã‚‰ã€å®Ÿè£…ã™ã‚‹ã®ã¯ã“ã®ã†ã¡ã®ã”ãã‚ãšã‹ã§ã™ã‚€ã“ã¨ãŒã»ã¨ã‚“ã©ã§ã™ã€‚"

#: ../../extending/newtypes.rst:926
msgid ""
"As you probably expect by now, we're going to go over this and give more "
"information about the various handlers.  We won't go in the order they are "
"defined in the structure, because there is a lot of historical baggage that "
"impacts the ordering of the fields; be sure your type initialization keeps "
"the fields in the right order!  It's often easiest to find an example that "
"includes all the fields you need (even if they're initialized to ``0``) and "
"then change the values to suit your new type. ::"
msgstr "ã™ã§ã«äºˆæƒ³ã•ã‚Œã¦ã„ã‚‹ã§ã—ã‚‡ã†ãŒã€ã“ã‚Œã‚‰ã®å¤šæ§˜ãªãƒãƒ³ãƒ‰ãƒ©ã«ã¤ã„ã¦ã€ã“ã‚Œã‹ã‚‰ã‚ˆã‚Šè©³ã—ã„æƒ…å ±ã‚’æä¾›ã—ã¾ã™ã€‚ã—ã‹ã—ã“ã‚Œã‚‰ã®ãƒ¡ãƒ³ãƒãŒæ§‹é€ ä½“ä¸­ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹é †ç•ªã¯ç„¡è¦–ã—ã¾ã™ã€‚ã¨ã„ã†ã®ã¯ã€ã“ã‚Œã‚‰ã®ãƒ¡ãƒ³ãƒã®ç¾ã‚Œã‚‹é †åºã¯æ­´å²çš„ãªéºç”£ã«ã‚ˆã‚‹ã‚‚ã®ã ã‹ã‚‰ã§ã™ã€‚å‹ã‚’åˆæœŸåŒ–ã™ã‚‹ã•ã„ã«ã€ã“ã‚Œã‚‰ã®ãƒ¡ãƒ³ãƒã‚’æ­£ã—ã„é †åºã§ä¸¦ã¹ã‚‹ã‚ˆã†ã€ãã‚Œãã‚Œã‚‚æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ãµã¤ã†ã„ã¡ã°ã‚“ç°¡å˜ãªã®ã¯ã€å¿…è¦ãªãƒ¡ãƒ³ãƒãŒã™ã¹ã¦å«ã¾ã‚Œã¦ã„ã‚‹ (ãŸã¨ãˆãã‚Œã‚‰ãŒ ``0`` ã«åˆæœŸåŒ–ã•ã‚Œã¦ã„ã¦ã‚‚) ä¾‹ã‚’ã¨ã£ã¦ãã¦ã€è‡ªåˆ†ã®å‹ã«åˆã‚ã›ã‚‹ã‚ˆã†å¤‰æ›´ã‚’ãã‚ãˆã‚‹ã“ã¨ã§ã™ã€‚ ::"

#: ../../extending/newtypes.rst:936
msgid ""
"The name of the type - as mentioned in the last section, this will appear in"
" various places, almost entirely for diagnostic purposes. Try to choose "
"something that will be helpful in such a situation! ::"
msgstr "ã“ã‚Œã¯å‹ã®åå‰ã§ã™ã€‚å‰ç¯€ã§èª¬æ˜ã—ãŸã‚ˆã†ã«ã€ã“ã‚Œã¯ã„ã‚ã„ã‚ãªå ´é¢ã§ç¾ã‚Œã€ã»ã¨ã‚“ã©ã¯è¨ºæ–­ç”¨ã®ç›®çš„ã§ä½¿ã‚ã‚Œã‚‹ã‚‚ã®ã§ã™ã€‚ãªã®ã§ã€ãã®ã‚ˆã†ãªå ´é¢ã§å½¹ã«ç«‹ã¤ã§ã‚ã‚ã†åå‰ã‚’é¸ã‚“ã§ãã ã•ã„! ::"

#: ../../extending/newtypes.rst:942
msgid ""
"These fields tell the runtime how much memory to allocate when new objects "
"of this type are created.  Python has some built-in support for variable "
"length structures (think: strings, lists) which is where the "
":c:member:`~PyTypeObject.tp_itemsize` field comes in.  This will be dealt "
"with later. ::"
msgstr "ã“ã‚Œã‚‰ã®ãƒ¡ãƒ³ãƒã¯ã€ã“ã®å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä½œæˆã•ã‚Œã‚‹ã¨ãã«ã©ã‚Œã ã‘ã®ãƒ¡ãƒ¢ãƒªã‚’å‰²ã‚Šå½“ã¦ã‚Œã°ã‚ˆã„ã®ã‹ã‚’ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã«æŒ‡ç¤ºã—ã¾ã™ã€‚Python ã«ã¯å¯å¤‰é•·ã®æ§‹é€ ä½“ (æ–‡å­—åˆ—ã‚„ãƒªã‚¹ãƒˆãªã©ã‚’æƒ³åƒã—ã¦ãã ã•ã„) ã«å¯¾ã™ã‚‹çµ„ã¿è¾¼ã¿ã®ã‚µãƒãƒ¼ãƒˆãŒã‚ã‚‹ç¨‹åº¦ã‚ã‚Šã€ã“ã“ã§ :c:member:`~PyTypeObject.tp_itemsize` ãƒ¡ãƒ³ãƒãŒä½¿ã‚ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‰ã«ã¤ã„ã¦ã¯ã‚ã¨ã§ãµã‚Œã¾ã™ã€‚ ::"

#: ../../extending/newtypes.rst:949
msgid ""
"Here you can put a string (or its address) that you want returned when the "
"Python script references ``obj.__doc__`` to retrieve the doc string."
msgstr "ã“ã“ã«ã¯ Python ã‚¹ã‚¯ãƒªãƒ—ãƒˆãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ ``obj.__doc__`` ãŒ doc string ã‚’è¿”ã™ã¨ãã®æ–‡å­—åˆ— (ã‚ã‚‹ã„ã¯ãã®ã‚¢ãƒ‰ãƒ¬ã‚¹) ã‚’å…¥ã‚Œã¾ã™ã€‚"

#: ../../extending/newtypes.rst:952
msgid ""
"Now we come to the basic type methods---the ones most extension types will "
"implement."
msgstr "ã§ã¯æ¬¡ã«ã€ã»ã¨ã‚“ã©ã®æ‹¡å¼µå‹ãŒå®Ÿè£…ã™ã‚‹ã§ã‚ã‚ã†åŸºæœ¬çš„ãªã‚¿ã‚¤ãƒ—ãƒ¡ã‚½ãƒƒãƒ‰ã«å…¥ã£ã¦ã„ãã¾ã™ã€‚"

#: ../../extending/newtypes.rst:957
msgid "Finalization and De-allocation"
msgstr "ãƒ•ã‚¡ã‚¤ãƒŠãƒ©ã‚¤ã‚ºã¨ãƒ¡ãƒ¢ãƒªè§£æ”¾"

#: ../../extending/newtypes.rst:969
msgid ""
"This function is called when the reference count of the instance of your "
"type is reduced to zero and the Python interpreter wants to reclaim it.  If "
"your type has memory to free or other clean-up to perform, you can put it "
"here.  The object itself needs to be freed here as well.  Here is an example"
" of this function::"
msgstr "å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒã‚¼ãƒ­ã«ãªã‚Šã€Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒãã‚Œã‚’æ½°ã—ã¦å†åˆ©ç”¨ã—ãŸããªã‚‹ã¨ã€ã“ã®é–¢æ•°ãŒå‘¼ã°ã‚Œã¾ã™ã€‚è§£æ”¾ã™ã¹ããƒ¡ãƒ¢ãƒªã‚’ãã®å‹ãŒä¿æŒã—ã¦ã„ãŸã‚Šã€ãã‚Œä»¥å¤–ã«ã‚‚å®Ÿè¡Œã™ã¹ãå¾Œå‡¦ç†ãŒã‚ã‚‹å ´åˆã¯ã€ãã‚Œã‚‰ã‚’ã“ã“ã«å…¥ã‚Œã‚‰ã‚Œã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãã‚Œè‡ªä½“ã‚‚ã“ã“ã§è§£æ”¾ã•ã‚Œã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®é–¢æ•°ã®ä¾‹ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ãªã‚‚ã®ã§ã™::"

#: ../../extending/newtypes.rst:986
msgid ""
"One important requirement of the deallocator function is that it leaves any "
"pending exceptions alone.  This is important since deallocators are "
"frequently called as the interpreter unwinds the Python stack; when the "
"stack is unwound due to an exception (rather than normal returns), nothing "
"is done to protect the deallocators from seeing that an exception has "
"already been set.  Any actions which a deallocator performs which may cause "
"additional Python code to be executed may detect that an exception has been "
"set.  This can lead to misleading errors from the interpreter.  The proper "
"way to protect against this is to save a pending exception before performing"
" the unsafe action, and restoring it when done.  This can be done using the "
":c:func:`PyErr_Fetch` and :c:func:`PyErr_Restore` functions::"
msgstr "è§£æ”¾ç”¨é–¢æ•°ã§ã²ã¨ã¤é‡è¦ãªã®ã¯ã€å‡¦ç†å¾…ã¡ã®ä¾‹å¤–ã«ã„ã£ã•ã„æ‰‹ã‚’ã¤ã‘ãªã„ã“ã¨ã§ã™ã€‚ãªãœãªã‚‰ã€è§£æ”¾ç”¨ã®é–¢æ•°ã¯ Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒã‚¹ã‚¿ãƒƒã‚¯ã‚’å…ƒã®çŠ¶æ…‹ã«æˆ»ã™ã¨ãã«å‘¼ã°ã‚Œã‚‹ã“ã¨ãŒå¤šã„ã‹ã‚‰ã§ã™ã€‚ãã—ã¦ (é€šå¸¸ã®é–¢æ•°ã‹ã‚‰ã®å¾©å¸°ã§ãªã) ä¾‹å¤–ã®ãŸã‚ã«ã‚¹ã‚¿ãƒƒã‚¯ãŒå·»ãæˆ»ã•ã‚Œã‚‹ã¨ãã¯ã€ã™ã§ã«ç™ºç”Ÿã—ã¦ã„ã‚‹ä¾‹å¤–ã‹ã‚‰è§£æ”¾ç”¨é–¢æ•°ã‚’å®ˆã‚‹ã‚‚ã®ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚è§£æ”¾ç”¨ã®é–¢æ•°ãŒãŠã“ãªã†å‹•ä½œãŒè¿½åŠ ã® Python ã®ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã—ã¦ã—ã¾ã†ã¨ã€ãã‚Œã‚‰ã¯ä¾‹å¤–ãŒç™ºç”Ÿã—ã¦ã„ã‚‹ã“ã¨ã‚’æ¤œçŸ¥ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒèª¤è§£ã•ã›ã‚‹ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿã•ã›ã‚‹ã“ã¨ã«ã¤ãªãŒã‚Šã¾ã™ã€‚ã“ã‚Œã‚’é˜²ãæ­£ã—ã„æ–¹æ³•ã¯ã€å®‰å…¨ã§ãªã„æ“ä½œã‚’å®Ÿè¡Œã™ã‚‹å‰ã«å‡¦ç†å¾…ã¡ã®ä¾‹å¤–ã‚’ä¿å­˜ã—ã¦ãŠãã€çµ‚ã‚ã£ãŸã‚‰ãã‚Œã‚’å…ƒã«æˆ»ã™ã“ã¨ã§ã™ã€‚ã“ã‚Œã¯ :c:func:`PyErr_Fetch` ãŠã‚ˆã³ :c:func:`PyErr_Restore` é–¢æ•°ã‚’ä½¿ã†ã“ã¨ã«ã‚ˆã£ã¦å¯èƒ½ã«ãªã‚Šã¾ã™::"

#: ../../extending/newtypes.rst:1027
msgid "Object Presentation"
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¡¨ç¾"

#: ../../extending/newtypes.rst:1033
msgid ""
"In Python, there are three ways to generate a textual representation of an "
"object: the :func:`repr` function (or equivalent back-tick syntax), the "
":func:`str` function, and the :keyword:`print` statement.  For most objects,"
" the :keyword:`print` statement is equivalent to the :func:`str` function, "
"but it is possible to special-case printing to a :c:type:`FILE\\*` if "
"necessary; this should only be done if efficiency is identified as a problem"
" and profiling suggests that creating a temporary string object to be "
"written to a file is too expensive."
msgstr "Python ã§ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ–‡å­—åˆ—è¡¨ç¾ã‚’ç”Ÿæˆã™ã‚‹ã®ã« 3ã¤ã®ã‚„ã‚Šæ–¹ãŒã‚ã‚Šã¾ã™: :func:`repr` é–¢æ•° (ã‚ã‚‹ã„ã¯ãã‚Œã¨ç­‰ä¾¡ãªãƒãƒƒã‚¯ã‚¯ã‚©ãƒ¼ãƒˆã‚’ç”¨ã„ãŸè¡¨ç¾) ã‚’ä½¿ã†æ–¹æ³•ã€ :func:`str` é–¢æ•°ã‚’ä½¿ã†æ–¹æ³•ã€ãã—ã¦ :keyword:`print` æ–‡ã‚’ä½¿ã†æ–¹æ³•ã§ã™ã€‚ã»ã¨ã‚“ã©ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ :keyword:`print` æ–‡ã¯ :func:`str` é–¢æ•°ã¨åŒã˜ã§ã™ãŒã€å¿…è¦ãªå ´åˆã«ã¯ç‰¹æ®Šãªã‚±ãƒ¼ã‚¹ã¨ã—ã¦ :c:type:`FILE\\*` ã«ã‚‚è¡¨ç¤ºã§ãã¾ã™ã€‚ :c:type:`FILE\\*` ã¸ã®è¡¨ç¤ºã¯ã€åŠ¹ç‡ãŒå•é¡Œã¨ãªã£ã¦ã„ã‚‹å ´åˆã§ã€ä¸€æ™‚çš„ãªæ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã‚€ã®ã§ã¯åŠ¹ç‡ãŒæ‚ªã™ãã‚‹ã“ã¨ãŒãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°ã‹ã‚‰ã‚‚æ˜ã‚‰ã‹ãªå ´åˆã«ã®ã¿ä½¿ã†ã¹ãã§ã™ã€‚"

#: ../../extending/newtypes.rst:1042
msgid ""
"These handlers are all optional, and most types at most need to implement "
"the :c:member:`~PyTypeObject.tp_str` and :c:member:`~PyTypeObject.tp_repr` "
"handlers. ::"
msgstr "ã“ã‚Œã‚‰ã®ãƒãƒ³ãƒ‰ãƒ©ã¯ã©ã‚Œã‚‚å¿…é ˆã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã»ã¨ã‚“ã©ã®å‹ã§ã¯ã›ã„ãœã„ :c:member:`~PyTypeObject.tp_str` ãƒãƒ³ãƒ‰ãƒ©ã¨ :c:member:`~PyTypeObject.tp_repr` ãƒãƒ³ãƒ‰ãƒ©ã‚’å®Ÿè£…ã™ã‚‹ã ã‘ã§ã™ã¿ã¾ã™ã€‚ ::"

#: ../../extending/newtypes.rst:1049
msgid ""
"The :c:member:`~PyTypeObject.tp_repr` handler should return a string object "
"containing a representation of the instance for which it is called.  Here is"
" a simple example::"
msgstr ":c:member:`~PyTypeObject.tp_repr` ãƒãƒ³ãƒ‰ãƒ©ã¯å‘¼ã³å‡ºã•ã‚ŒãŸã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®æ–‡å­—åˆ—è¡¨ç¾ã‚’æ ¼ç´ã—ãŸæ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ç°¡å˜ãªä¾‹ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªã‚‚ã®ã§ã™::"

#: ../../extending/newtypes.rst:1060
msgid ""
"If no :c:member:`~PyTypeObject.tp_repr` handler is specified, the "
"interpreter will supply a representation that uses the type's "
":c:member:`~PyTypeObject.tp_name` and a uniquely-identifying value for the "
"object."
msgstr ":c:member:`~PyTypeObject.tp_repr` ãƒãƒ³ãƒ‰ãƒ©ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ãã®å‹ã® :c:member:`~PyTypeObject.tp_name` ã¨ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸€æ„ãªè­˜åˆ¥å€¤ã‚’ã‚‚ã¡ã„ã¦æ–‡å­—åˆ—è¡¨ç¾ã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:1064
msgid ""
"The :c:member:`~PyTypeObject.tp_str` handler is to :func:`str` what the "
":c:member:`~PyTypeObject.tp_repr` handler described above is to "
":func:`repr`; that is, it is called when Python code calls :func:`str` on an"
" instance of your object.  Its implementation is very similar to the "
":c:member:`~PyTypeObject.tp_repr` function, but the resulting string is "
"intended for human consumption.  If :c:member:`~PyTypeObject.tp_str` is not "
"specified, the :c:member:`~PyTypeObject.tp_repr` handler is used instead."
msgstr ":c:member:`~PyTypeObject.tp_str` ãƒãƒ³ãƒ‰ãƒ©ã¨ :func:`str` ã®é–¢ä¿‚ã¯ã€ä¸Šã® :c:member:`~PyTypeObject.tp_repr` ãƒãƒ³ãƒ‰ãƒ©ã¨ :func:`repr` ã®é–¢ä¿‚ã«ç›¸å½“ã—ã¾ã™ã€‚ã¤ã¾ã‚Šã€ã“ã‚Œã¯ Python ã®ã‚³ãƒ¼ãƒ‰ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å¯¾ã—ã¦ :func:`str` ã‚’å‘¼ã³å‡ºã—ãŸã¨ãã«å‘¼ã°ã‚Œã¾ã™ã€‚ã“ã®é–¢æ•°ã®å®Ÿè£…ã¯ :c:member:`~PyTypeObject.tp_repr` ãƒãƒ³ãƒ‰ãƒ©ã®ãã‚Œã¨éå¸¸ã«ä¼¼ã¦ã„ã¾ã™ãŒã€å¾—ã‚‰ã‚Œã‚‹æ–‡å­—åˆ—è¡¨ç¾ã¯äººé–“ãŒèª­ã‚€ã“ã¨ã‚’æ„å›³ã•ã‚Œã¦ã„ã¾ã™ã€‚ :c:member:`~PyTypeObject.tp_str` ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã€ã‹ã‚ã‚Šã« :c:member:`~PyTypeObject.tp_repr` ãƒãƒ³ãƒ‰ãƒ©ãŒä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../extending/newtypes.rst:1071
msgid "Here is a simple example::"
msgstr "ä»¥ä¸‹ã¯ç°¡å˜ãªä¾‹ã§ã™::"

#: ../../extending/newtypes.rst:1080
msgid ""
"The print function will be called whenever Python needs to \"print\" an "
"instance of the type.  For example, if 'node' is an instance of type "
"TreeNode, then the print function is called when Python code calls::"
msgstr "print ãƒãƒ³ãƒ‰ãƒ©ã¯ Python ãŒãã®å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ã€Œprint ã™ã‚‹ã€å¿…è¦ã®ã‚ã‚‹ã¨ãã«æ¯å›å‘¼ã°ã‚Œã¾ã™ã€‚ãŸã¨ãˆã° 'node' ãŒ TreeNode å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã ã¨ã™ã‚‹ã¨ã€print ãƒãƒ³ãƒ‰ãƒ©ã¯ Python ãŒä»¥ä¸‹ã‚’å®Ÿè¡Œã—ãŸã¨ãã«å‘¼ã°ã‚Œã¾ã™::"

#: ../../extending/newtypes.rst:1086
msgid ""
"There is a flags argument and one flag, :const:`Py_PRINT_RAW`, and it "
"suggests that you print without string quotes and possibly without "
"interpreting escape sequences."
msgstr "flags å¼•æ•°ã«ã¯ :const:`Py_PRINT_RAW` ã¨ã„ã†ãƒ•ãƒ©ã‚°ãŒã‚ã‚Šã€ã“ã‚Œã¯ãã®æ–‡å­—åˆ—ã‚’ã‚¯ã‚©ãƒ¼ãƒˆã‚„ãŠãã‚‰ãã¯ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®è§£é‡ˆã‚‚ãªã—ã§è¡¨ç¤ºã™ã‚‹ã“ã¨ã‚’æŒ‡ç¤ºã—ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:1090
msgid ""
"The print function receives a file object as an argument. You will likely "
"want to write to that file object."
msgstr "ã“ã® print é–¢æ•°ã¯ :c:type:`FILE\\*` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¼•æ•°ã¨ã—ã¦ã¨ã‚Šã¾ã™ã€‚ãŸã¶ã‚“ã€ã“ã“ã«å‡ºåŠ›ã™ã‚‹ã“ã¨ã«ãªã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../extending/newtypes.rst:1093
msgid "Here is a sample print function::"
msgstr "print é–¢æ•°ã®ä¾‹ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../extending/newtypes.rst:1111
msgid "Attribute Management"
msgstr "å±æ€§ã‚’ç®¡ç†ã™ã‚‹"

#: ../../extending/newtypes.rst:1113
msgid ""
"For every object which can support attributes, the corresponding type must "
"provide the functions that control how the attributes are resolved.  There "
"needs to be a function which can retrieve attributes (if any are defined), "
"and another to set attributes (if setting attributes is allowed).  Removing "
"an attribute is a special case, for which the new value passed to the "
"handler is *NULL*."
msgstr "å±æ€§ã‚’ã‚‚ã¤ã©ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ã‚‚ã€ãã®å‹ã¯ã€ãã‚Œã‚‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å±æ€§ã‚’ã©ã®ã‚ˆã†ã«è§£æ±ºã™ã‚‹ã‹åˆ¶å¾¡ã™ã‚‹é–¢æ•°ã‚’æä¾›ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚å¿…è¦ãªé–¢æ•°ã¨ã—ã¦ã¯ã€å±æ€§ã‚’ (ãã‚ŒãŒå®šç¾©ã•ã‚Œã¦ã„ã‚Œã°) å–ã‚Šå‡ºã™ã‚‚ã®ã¨ã€ã‚‚ã†ã²ã¨ã¤ã¯å±æ€§ã« (ãã‚ŒãŒè¨±å¯ã•ã‚Œã¦ã„ã‚Œã°) å€¤ã‚’è¨­å®šã™ã‚‹ã‚‚ã®ã§ã™ã€‚å±æ€§ã‚’å‰Šé™¤ã™ã‚‹ã®ã¯ç‰¹æ®Šãªã‚±ãƒ¼ã‚¹ã§ã€ã“ã®å ´åˆã¯æ–°ã—ã„å€¤ã¨ã—ã¦ãƒãƒ³ãƒ‰ãƒ©ã« *NULL* ãŒæ¸¡ã•ã‚Œã¾ã™ã€‚"

#: ../../extending/newtypes.rst:1119
msgid ""
"Python supports two pairs of attribute handlers; a type that supports "
"attributes only needs to implement the functions for one pair.  The "
"difference is that one pair takes the name of the attribute as a "
":c:type:`char\\*`, while the other accepts a :c:type:`PyObject\\*`.  Each "
"type can use whichever pair makes more sense for the implementation's "
"convenience. ::"
msgstr "Python ã¯ 2ã¤ã®å±æ€§ãƒãƒ³ãƒ‰ãƒ©ã®çµ„ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚å±æ€§ã‚’ã‚‚ã¤å‹ã¯ã©ã¡ã‚‰ã‹ä¸€çµ„ã‚’å®Ÿè£…ã™ã‚‹ã ã‘ã§ã‚ˆãã€ãã‚Œã‚‰ã®é•ã„ã¯ä¸€æ–¹ã®çµ„ãŒå±æ€§ã®åå‰ã‚’ :c:type:`char\\*` ã¨ã—ã¦å—ã‘å–ã‚‹ã®ã«å¯¾ã—ã¦ã‚‚ã†ä¸€æ–¹ã®çµ„ã¯å±æ€§ã®åå‰ã‚’ :c:type:`PyObject\\*` ã¨ã—ã¦å—ã‘å–ã‚‹ã€ã¨ã„ã†ã‚‚ã®ã§ã™ã€‚ãã‚Œãã‚Œã®å‹ã¯ãã®å®Ÿè£…ã«ã¨ã£ã¦éƒ½åˆãŒã‚ˆã„æ–¹ã‚’ä½¿ãˆã¾ã™ã€‚ ::"

#: ../../extending/newtypes.rst:1131
msgid ""
"If accessing attributes of an object is always a simple operation (this will"
" be explained shortly), there are generic implementations which can be used "
"to provide the :c:type:`PyObject\\*` version of the attribute management "
"functions. The actual need for type-specific attribute handlers almost "
"completely disappeared starting with Python 2.2, though there are many "
"examples which have not been updated to use some of the new generic "
"mechanism that is available."
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å±æ€§ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒã¤ã­ã« (ã™ãã‚ã¨ã§èª¬æ˜ã™ã‚‹) å˜ç´”ãªæ“ä½œã ã‘ãªã‚‰ã°ã€ :c:type:`PyObject\\*` ã‚’ä½¿ã£ã¦å±æ€§ã‚’ç®¡ç†ã™ã‚‹é–¢æ•°ã¨ã—ã¦ã€ç·ç§°çš„ (generic) ãªå®Ÿè£…ã‚’ä½¿ãˆã¾ã™ã€‚ç‰¹å®šã®å‹ã«ç‰¹åŒ–ã—ãŸå±æ€§ãƒãƒ³ãƒ‰ãƒ©ã®å¿…è¦æ€§ã¯ Python 2.2 ã‹ã‚‰ã»ã¨ã‚“ã©å®Œå…¨ã«ãªããªã‚Šã¾ã—ãŸã€‚ã—ã‹ã—ã€å¤šãã®ä¾‹ã¯ã¾ã ã€ã“ã®æ–°ã—ãä½¿ãˆã‚‹ã‚ˆã†ã«ãªã£ãŸç·ç§°çš„ãªãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã‚’ä½¿ã†ã‚ˆã†æ›´æ–°ã•ã‚Œã¦ã¯ã„ã¾ã›ã‚“ã€‚"

#: ../../extending/newtypes.rst:1142
msgid "Generic Attribute Management"
msgstr "ç·ç§°çš„ãªå±æ€§ã‚’ç®¡ç†ã™ã‚‹"

#: ../../extending/newtypes.rst:1146
msgid ""
"Most extension types only use *simple* attributes.  So, what makes the "
"attributes simple?  There are only a couple of conditions that must be met:"
msgstr "ã»ã¨ã‚“ã©ã®å‹ã¯ *å˜ç´”ãª* å±æ€§ã‚’ä½¿ã†ã ã‘ã§ã™ã€‚ã§ã¯ã€ã©ã®ã‚ˆã†ãªå±æ€§ãŒå˜ç´”ã ã¨ã„ãˆã‚‹ã®ã§ã—ã‚‡ã†ã‹? ãã‚ŒãŒæº€ãŸã™ã¹ãæ¡ä»¶ã¯ã”ãã‚ãšã‹ã§ã™:"

#: ../../extending/newtypes.rst:1149
msgid ""
"The name of the attributes must be known when :c:func:`PyType_Ready` is "
"called."
msgstr ":c:func:`PyType_Ready` ãŒå‘¼ã°ã‚ŒãŸã¨ãã€ã™ã§ã«å±æ€§ã®åå‰ãŒã‚ã‹ã£ã¦ã„ã‚‹ã“ã¨ã€‚"

#: ../../extending/newtypes.rst:1152
msgid ""
"No special processing is needed to record that an attribute was looked up or"
" set, nor do actions need to be taken based on the value."
msgstr "å±æ€§ã‚’å‚ç…§ã—ãŸã‚Šè¨­å®šã—ãŸã‚Šã™ã‚‹ã¨ãã«ã€ç‰¹åˆ¥ãªè¨˜éŒ²ã®ãŸã‚ã®å‡¦ç†ãŒå¿…è¦ã§ãªãã€ã¾ãŸå‚ç…§ã—ãŸã‚Šè¨­å®šã—ãŸå€¤ã«å¯¾ã—ã¦ã©ã‚“ãªæ“ä½œã‚‚å®Ÿè¡Œã™ã‚‹å¿…è¦ãŒãªã„ã“ã¨ã€‚"

#: ../../extending/newtypes.rst:1155
msgid ""
"Note that this list does not place any restrictions on the values of the "
"attributes, when the values are computed, or how relevant data is stored."
msgstr "ã“ã‚Œã‚‰ã®æ¡ä»¶ã¯ã€å±æ€§ã®å€¤ã‚„ã€å€¤ãŒè¨ˆç®—ã•ã‚Œã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã€ã¾ãŸã¯æ ¼ç´ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ãŒã©ã®ç¨‹åº¦å¦¥å½“ãªã‚‚ã®ã§ã‚ã‚‹ã‹ã¨ã„ã£ãŸã“ã¨ã«ãªã‚“ã‚‰åˆ¶ç´„ã‚’èª²ã™ã‚‚ã®ã§ã¯ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../extending/newtypes.rst:1158
msgid ""
"When :c:func:`PyType_Ready` is called, it uses three tables referenced by "
"the type object to create :term:`descriptor`\\s which are placed in the "
"dictionary of the type object.  Each descriptor controls access to one "
"attribute of the instance object.  Each of the tables is optional; if all "
"three are *NULL*, instances of the type will only have attributes that are "
"inherited from their base type, and should leave the "
":c:member:`~PyTypeObject.tp_getattro` and "
":c:member:`~PyTypeObject.tp_setattro` fields *NULL* as well, allowing the "
"base type to handle attributes."
msgstr ":c:func:`PyType_Ready` ãŒå‘¼ã°ã‚Œã‚‹ã¨ã€ã“ã‚Œã¯ãã®ã‚¿ã‚¤ãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å‚ç…§ã•ã‚Œã¦ã„ã‚‹ 3ã¤ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ä½¿ã£ã¦ã€ãã®ã‚¿ã‚¤ãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è¾æ›¸ä¸­ã«ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿(:term:`descriptor`) ã‚’ä½œæˆã—ã¾ã™ã€‚å„ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å±æ€§ã«å¯¾ã™ã‚‹ã‚¢ã‚¯ã‚»ã‚¹ã‚’åˆ¶å¾¡ã—ã¾ã™ã€‚ãã‚Œãã‚Œã®ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ãªãã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚ã‚‚ã—ã“ã‚Œã‚‰ 3ã¤ãŒã™ã¹ã¦ *NULL* ã ã¨ã€ãã®å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ãã®åŸºåº•å‹ã‹ã‚‰ç¶™æ‰¿ã—ãŸå±æ€§ã ã‘ã‚’æŒã¤ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ã¾ãŸã€ :c:member:`~PyTypeObject.tp_getattro` ãŠã‚ˆã³ :c:member:`~PyTypeObject.tp_setattro` ãŒ *NULL* ã®ã¾ã¾ã ã£ãŸå ´åˆã‚‚ã€åŸºåº•å‹ã«ã“ã‚Œã‚‰ã®å±æ€§ã®æ“ä½œãŒã¾ã‹ã›ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../extending/newtypes.rst:1166
msgid "The tables are declared as three fields of the type object::"
msgstr "ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ã‚¿ã‚¤ãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä¸­ã® 3ã¤ã®ãƒ¡ãƒ³ãƒã¨ã—ã¦å®£è¨€ã•ã‚Œã¦ã„ã¾ã™::"

#: ../../extending/newtypes.rst:1172
msgid ""
"If :c:member:`~PyTypeObject.tp_methods` is not *NULL*, it must refer to an "
"array of :c:type:`PyMethodDef` structures.  Each entry in the table is an "
"instance of this structure::"
msgstr ":c:member:`~PyTypeObject.tp_methods` ãŒ *NULL* ã§ãªã„å ´åˆã€ã“ã‚Œã¯ :c:type:`PyMethodDef` æ§‹é€ ä½“ã¸ã®é…åˆ—ã‚’æŒ‡ã—ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãƒ†ãƒ¼ãƒ–ãƒ«ä¸­ã®å„ã‚¨ãƒ³ãƒˆãƒªã¯ã€ã¤ãã®ã‚ˆã†ãªæ§‹é€ ä½“ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã™::"

#: ../../extending/newtypes.rst:1183
msgid ""
"One entry should be defined for each method provided by the type; no entries"
" are needed for methods inherited from a base type.  One additional entry is"
" needed at the end; it is a sentinel that marks the end of the array.  The "
":attr:`ml_name` field of the sentinel must be *NULL*."
msgstr "ãã®å‹ãŒæä¾›ã™ã‚‹å„ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¤ã„ã¦ã²ã¨ã¤ã®ã‚¨ãƒ³ãƒˆãƒªã‚’å®šç¾©ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚åŸºåº•å‹ã‹ã‚‰ç¶™æ‰¿ã—ã¦ããŸãƒ¡ã‚½ãƒƒãƒ‰ã«ã¤ã„ã¦ã¯ã‚¨ãƒ³ãƒˆãƒªã¯å¿…è¦ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã®æœ€å¾Œã«ã¯ã€é…åˆ—ã®çµ‚ã‚ã‚Šã‚’ç¤ºã™ãŸã‚ã®è¦‹å¼µã‚Šç•ª (sentinel) ã¨ã—ã¦è¿½åŠ ã®ã‚¨ãƒ³ãƒˆãƒªãŒã²ã¨ã¤å¿…è¦ã§ã™ã€‚ã“ã®å ´åˆã€ :attr:`ml_name` ãƒ¡ãƒ³ãƒãŒ sentinel ã¨ã—ã¦ä½¿ã‚ã‚Œã€ãã®å€¤ã¯ *NULL* ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../extending/newtypes.rst:1188
msgid ""
"XXX Need to refer to some unified discussion of the structure fields, shared"
" with the next section."
msgstr "XXX Need to refer to some unified discussion of the structure fields, shared with the next section."

#: ../../extending/newtypes.rst:1191
msgid ""
"The second table is used to define attributes which map directly to data "
"stored in the instance.  A variety of primitive C types are supported, and "
"access may be read-only or read-write.  The structures in the table are "
"defined as::"
msgstr "2ç•ªç›®ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä¸­ã«æ ¼ç´ã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ã¨ç›´æ¥å¯¾å¿œã¥ã‘ã‚‰ã‚ŒãŸå±æ€§ã‚’å®šç¾©ã™ã‚‹ã®ã«ä½¿ã„ã¾ã™ã€‚ã„ãã¤ã‚‚ã® C ã®åŸå§‹çš„ãªå‹ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ãŠã‚Šã€ã‚¢ã‚¯ã‚»ã‚¹ã‚’èª­ã¿è¾¼ã¿å°‚ç”¨ã«ã‚‚èª­ã¿æ›¸ãå¯èƒ½ã«ã‚‚ã§ãã¾ã™ã€‚ã“ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã§ä½¿ã‚ã‚Œã‚‹æ§‹é€ ä½“ã¯æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™::"

#: ../../extending/newtypes.rst:1203
msgid ""
"For each entry in the table, a :term:`descriptor` will be constructed and "
"added to the type which will be able to extract a value from the instance "
"structure.  The :attr:`type` field should contain one of the type codes "
"defined in the :file:`structmember.h` header; the value will be used to "
"determine how to convert Python values to and from C values.  The "
":attr:`flags` field is used to store flags which control how the attribute "
"can be accessed."
msgstr "ã“ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã®å„ã‚¨ãƒ³ãƒˆãƒªã«å¯¾ã—ã¦ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿(:term:`descriptor`)ãŒä½œæˆã•ã‚Œã€å€¤ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®æ§‹é€ ä½“ã‹ã‚‰æŠ½å‡ºã—ã†ã‚‹å‹ã«å¯¾ã—ã¦ãã‚Œã‚‰ãŒè¿½åŠ ã•ã‚Œã¾ã™ã€‚ :attr:`type` ãƒ¡ãƒ³ãƒã¯ :file:`structmember.h` ãƒ˜ãƒƒãƒ€ã§å®šç¾©ã•ã‚ŒãŸå‹ã®ã‚³ãƒ¼ãƒ‰ã‚’ã²ã¨ã¤å«ã‚“ã§ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®å€¤ã¯ Python ã«ãŠã‘ã‚‹å€¤ã¨ C ã«ãŠã‘ã‚‹å€¤ã‚’ã©ã®ã‚ˆã†ã«å¤‰æ›ã—ã‚ã†ã‹ã‚’å®šã‚ã‚‹ã‚‚ã®ã§ã™ã€‚ :attr:`flags` ãƒ¡ãƒ³ãƒã¯ã“ã®å±æ€§ãŒã©ã®ã‚ˆã†ã«ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã‚‹ã‹ã‚’åˆ¶å¾¡ã™ã‚‹ãƒ•ãƒ©ã‚°ã‚’æ ¼ç´ã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../extending/newtypes.rst:1210
msgid "XXX Need to move some of this to a shared section!"
msgstr "XXX Need to move some of this to a shared section!"

#: ../../extending/newtypes.rst:1212
msgid ""
"The following flag constants are defined in :file:`structmember.h`; they may"
" be combined using bitwise-OR."
msgstr "ä»¥ä¸‹ã®ãƒ•ãƒ©ã‚°ç”¨å®šæ•°ã¯ :file:`structmember.h` ã§å®šç¾©ã•ã‚Œã¦ãŠã‚Šã€ã“ã‚Œã‚‰ã¯ãƒ“ãƒƒãƒˆã”ã¨ã® OR ã‚’å–ã£ã¦çµ„ã¿åˆã‚ã›ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../extending/newtypes.rst:1216
msgid "Constant"
msgstr "å®šæ•°"

#: ../../extending/newtypes.rst:1216
msgid "Meaning"
msgstr "æ„å‘³"

#: ../../extending/newtypes.rst:1218
msgid ":const:`READONLY`"
msgstr ":const:`READONLY`"

#: ../../extending/newtypes.rst:1218
msgid "Never writable."
msgstr "çµ¶å¯¾ã«å¤‰æ›´ã§ããªã„ã€‚"

#: ../../extending/newtypes.rst:1220
msgid ":const:`RO`"
msgstr ":const:`RO`"

#: ../../extending/newtypes.rst:1220
msgid "Shorthand for :const:`READONLY`."
msgstr ":const:`READONLY` ã®çŸ­ç¸®å½¢ã€‚"

#: ../../extending/newtypes.rst:1222
msgid ":const:`READ_RESTRICTED`"
msgstr ":const:`READ_RESTRICTED`"

#: ../../extending/newtypes.rst:1222
msgid "Not readable in restricted mode."
msgstr "åˆ¶é™ãƒ¢ãƒ¼ãƒ‰ (restricted mode) ã§ã¯å‚ç…§ã§ããªã„ã€‚"

#: ../../extending/newtypes.rst:1224
msgid ":const:`WRITE_RESTRICTED`"
msgstr ":const:`WRITE_RESTRICTED`"

#: ../../extending/newtypes.rst:1224
msgid "Not writable in restricted mode."
msgstr "åˆ¶é™ãƒ¢ãƒ¼ãƒ‰ (restricted mode) ã§ã¯å¤‰æ›´ã§ããªã„ã€‚"

#: ../../extending/newtypes.rst:1226
msgid ":const:`RESTRICTED`"
msgstr ":const:`RESTRICTED`"

#: ../../extending/newtypes.rst:1226
msgid "Not readable or writable in restricted mode."
msgstr "åˆ¶é™ãƒ¢ãƒ¼ãƒ‰ (restricted mode) ã§ã¯å‚ç…§ã‚‚å¤‰æ›´ã‚‚ã§ããªã„ã€‚"

#: ../../extending/newtypes.rst:1236
msgid ""
"An interesting advantage of using the :c:member:`~PyTypeObject.tp_members` "
"table to build descriptors that are used at runtime is that any attribute "
"defined this way can have an associated doc string simply by providing the "
"text in the table.  An application can use the introspection API to retrieve"
" the descriptor from the class object, and get the doc string using its "
":attr:`__doc__` attribute."
msgstr ":c:member:`~PyTypeObject.tp_members` ã‚’ä½¿ã£ãŸã²ã¨ã¤ã®é¢ç™½ã„åˆ©ç”¨æ³•ã¯ã€å®Ÿè¡Œæ™‚ã«ä½¿ã‚ã‚Œã‚‹ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’ä½œæˆã—ã¦ãŠãã€å˜ã«ãƒ†ãƒ¼ãƒ–ãƒ«ä¸­ã«ãƒ†ã‚­ã‚¹ãƒˆã‚’ç½®ã„ã¦ãŠãã“ã¨ã«ã‚ˆã£ã¦ã€ã“ã®æ–¹æ³•ã§å®šç¾©ã•ã‚ŒãŸã™ã¹ã¦ã®å±æ€§ã« doc string ã‚’é–¢é€£ä»˜ã‘ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã§ã™ã€‚ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã“ã®ã‚¤ãƒ³ãƒˆãƒ­ã‚¹ãƒšã‚¯ã‚·ãƒ§ãƒ³ç”¨ API ã‚’ä½¿ã£ã¦ã€ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’å–ã‚Šå‡ºã—ã€ãã® :attr:`__doc__` å±æ€§ã‚’ä½¿ã£ã¦ doc string ã‚’å¾—ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../extending/newtypes.rst:1242
msgid ""
"As with the :c:member:`~PyTypeObject.tp_methods` table, a sentinel entry "
"with a :attr:`name` value of *NULL* is required."
msgstr ":c:member:`~PyTypeObject.tp_methods` ãƒ†ãƒ¼ãƒ–ãƒ«ã¨åŒã˜ã‚ˆã†ã«ã€ã“ã“ã§ã‚‚ :attr:`name` ãƒ¡ãƒ³ãƒã®å€¤ã‚’ *NULL* ã«ã—ãŸè¦‹å¼µã‚Šç”¨ã‚¨ãƒ³ãƒˆãƒªãŒå¿…è¦ã§ã™ã€‚"

#: ../../extending/newtypes.rst:1256
msgid "Type-specific Attribute Management"
msgstr "ç‰¹å®šã®å‹ã«ç‰¹åŒ–ã—ãŸå±æ€§ã®ç®¡ç†"

#: ../../extending/newtypes.rst:1258
msgid ""
"For simplicity, only the :c:type:`char\\*` version will be demonstrated "
"here; the type of the name parameter is the only difference between the "
":c:type:`char\\*` and :c:type:`PyObject\\*` flavors of the interface. This "
"example effectively does the same thing as the generic example above, but "
"does not use the generic support added in Python 2.2.  The value in showing "
"this is two-fold: it demonstrates how basic attribute management can be done"
" in a way that is portable to older versions of Python, and explains how the"
" handler functions are called, so that if you do need to extend their "
"functionality, you'll understand what needs to be done."
msgstr "è©±ã‚’å˜ç´”ã«ã™ã‚‹ãŸã‚ã€ã“ã“ã§ã¯ :c:type:`char\\*` ã‚’ä½¿ã£ãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ã¿ã‚’ç¤ºã—ã¾ã™ã€‚name ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å‹ã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã¨ã—ã¦ :c:type:`char\\*` ã‚’ä½¿ã†ã‹ :c:type:`PyObject\\*` ã‚’ä½¿ã†ã‹ã®é•ã„ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®ä¾‹ã§ã¯ã€ä¸Šã®ç·ç§°çš„ãªä¾‹ã¨åŒã˜ã“ã¨ã‚’åŠ¹ç‡çš„ã«ã‚„ã‚Šã¾ã™ãŒã€ Python 2.2 ã§è¿½åŠ ã•ã‚ŒãŸç·ç§°çš„ãªå‹ã®ã‚µãƒãƒ¼ãƒˆã‚’ä½¿ã‚ãšã«ã‚„ã‚Šã¾ã™ã€‚ã“ã‚Œã‚’ç´¹ä»‹ã™ã‚‹ã“ã¨ã¯ 2ã¤ã®æ„å‘³ã‚’ã‚‚ã£ã¦ã„ã¾ã™ã€‚ã²ã¨ã¤ã¯ã©ã†ã‚„ã£ã¦ã€å¤ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® Python ã¨äº’æ›æ€§ã®ã‚ã‚‹ã‚„ã‚Šæ–¹ã§ã€åŸºæœ¬çš„ãªå±æ€§ç®¡ç†ã‚’ãŠã“ãªã†ã‹ã€‚ãã—ã¦ã‚‚ã†ã²ã¨ã¤ã¯ãƒãƒ³ãƒ‰ãƒ©ã®é–¢æ•°ãŒã©ã®ã‚ˆã†ã«ã—ã¦å‘¼ã°ã‚Œã‚‹ã®ã‹ã€‚ã“ã‚Œã§ã€ãŸã¨ãˆãã®æ©Ÿèƒ½ã‚’æ‹¡å¼µã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã¨ãã€ä½•ã‚’ã©ã†ã™ã‚Œã°ã„ã„ã‹ã‚ã‹ã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../extending/newtypes.rst:1268
msgid ""
"The :c:member:`~PyTypeObject.tp_getattr` handler is called when the object "
"requires an attribute look-up.  It is called in the same situations where "
"the :meth:`__getattr__` method of a class would be called."
msgstr ":c:member:`~PyTypeObject.tp_getattr` ãƒãƒ³ãƒ‰ãƒ©ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå±æ€§ã¸ã®å‚ç…§ã‚’è¦æ±‚ã™ã‚‹ã¨ãã«å‘¼ã°ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã€ãã®ã‚¯ãƒ©ã‚¹ã® :meth:`__getattr__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚Œã‚‹ã§ã‚ã‚ã†çŠ¶æ³ã¨åŒã˜çŠ¶æ³ä¸‹ã§å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../extending/newtypes.rst:1272
msgid ""
"A likely way to handle this is (1) to implement a set of functions (such as "
":c:func:`newdatatype_getSize` and :c:func:`newdatatype_setSize` in the "
"example below), (2) provide a method table listing these functions, and (3) "
"provide a getattr function that returns the result of a lookup in that "
"table.  The method table uses the same structure as the "
":c:member:`~PyTypeObject.tp_methods` field of the type object."
msgstr "ã“ã‚Œã‚’å‡¦ç†ã™ã‚‹ã‚ã‚ŠãŒã¡ãªæ–¹æ³•ã¯ã€(1) ä¸€é€£ã®é–¢æ•° (ä¸‹ã®ä¾‹ã® :c:func:`newdatatype_getSize` ã‚„ :c:func:`newdatatype_setSize`) ã‚’å®Ÿè£…ã™ã‚‹ã€(2) ã“ã‚Œã‚‰ã®é–¢æ•°ã‚’è¨˜éŒ²ã—ãŸãƒ¡ã‚½ãƒƒãƒ‰ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’æä¾›ã™ã‚‹ã€ãã—ã¦ (3) ãã®ãƒ†ãƒ¼ãƒ–ãƒ«ã®å‚ç…§çµæœã‚’è¿”ã™ getattr é–¢æ•°ã‚’æä¾›ã™ã‚‹ã“ã¨ã§ã™ã€‚ãƒ¡ã‚½ãƒƒãƒ‰ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ã‚¿ã‚¤ãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :c:member:`~PyTypeObject.tp_methods` ãƒ¡ãƒ³ãƒã¨åŒã˜æ§‹é€ ã‚’æŒã£ã¦ã„ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:1279
msgid "Here is an example::"
msgstr "ä»¥ä¸‹ã«ä¾‹ã‚’ç¤ºã—ã¾ã™::"

#: ../../extending/newtypes.rst:1295
msgid ""
"The :c:member:`~PyTypeObject.tp_setattr` handler is called when the "
":meth:`__setattr__` or :meth:`__delattr__` method of a class instance would "
"be called.  When an attribute should be deleted, the third parameter will be"
" *NULL*.  Here is an example that simply raises an exception; if this were "
"really all you wanted, the :c:member:`~PyTypeObject.tp_setattr` handler "
"should be set to *NULL*. ::"
msgstr ":c:member:`~PyTypeObject.tp_setattr` ãƒãƒ³ãƒ‰ãƒ©ã¯ã€ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã® :meth:`__setattr__` ã¾ãŸã¯ :meth:`__delattr__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚Œã‚‹ã§ã‚ã‚ã†çŠ¶æ³ã§å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã‚ã‚‹å±æ€§ãŒå‰Šé™¤ã•ã‚Œã‚‹ã¨ãã€3ç•ªç›®ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯ *NULL* ã«ãªã‚Šã¾ã™ã€‚ä»¥ä¸‹ã®ä¾‹ã¯ãŸã‚“ã«ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã‚‹ã‚‚ã®ã§ã™ãŒã€ã‚‚ã—æœ¬å½“ã«ã“ã‚Œã¨åŒã˜ã“ã¨ã‚’ã—ãŸã„ãªã‚‰ã€ :c:member:`~PyTypeObject.tp_setattr` ãƒãƒ³ãƒ‰ãƒ©ã‚’ *NULL* ã«è¨­å®šã™ã¹ãã§ã™ã€‚ ::"

#: ../../extending/newtypes.rst:1310
msgid "Object Comparison"
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ¯”è¼ƒ"

#: ../../extending/newtypes.rst:1316
msgid ""
"The :c:member:`~PyTypeObject.tp_compare` handler is called when comparisons "
"are needed and the object does not implement the specific rich comparison "
"method which matches the requested comparison.  (It is always used if "
"defined and the :c:func:`PyObject_Compare` or :c:func:`PyObject_Cmp` "
"functions are used, or if :func:`cmp` is used from Python.) It is analogous "
"to the :meth:`__cmp__` method. This function should return ``-1`` if *obj1* "
"is less than *obj2*, ``0`` if they are equal, and ``1`` if *obj1* is greater"
" than *obj2*. (It was previously allowed to return arbitrary negative or "
"positive integers for less than and greater than, respectively; as of Python"
" 2.2, this is no longer allowed.  In the future, other return values may be "
"assigned a different meaning.)"
msgstr ":c:member:`~PyTypeObject.tp_compare` ãƒãƒ³ãƒ‰ãƒ©ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã©ã†ã—ã®æ¯”è¼ƒãŒå¿…è¦ã§ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«è¦æ±‚ã•ã‚ŒãŸæ¯”è¼ƒã‚’ãŠã“ãªã†ã®ã«é©ã—ãŸç‰¹å®šã®æ‹¡å¼µæ¯”è¼ƒãƒ¡ã‚½ãƒƒãƒ‰ãŒå®Ÿè£…ã•ã‚Œã¦ã„ãªã„ã¨ãã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚(ã“ã‚ŒãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã¨ãã€ :c:func:`PyObject_Compare` ã¾ãŸã¯ :c:func:`PyObject_Cmp` ãŒä½¿ã‚ã‚Œã‚‹ã¨ã“ã‚Œã¯ã¤ã­ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€ã¾ãŸ Python ã§ :func:`cmp` ãŒä½¿ã‚ã‚ŒãŸã¨ãã«ã‚‚å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚) ã“ã‚Œã¯ :meth:`__cmp__` ãƒ¡ã‚½ãƒƒãƒ‰ã«ä¼¼ã¦ã„ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ã‚‚ã— *obj1* ãŒ *obj2* ã‚ˆã‚Šã€Œå°ã•ã„ã€å ´åˆã¯ ``-1`` ã‚’è¿”ã—ã€ãã‚Œã‚‰ãŒç­‰ã—ã‘ã‚Œã° ``0`` ã€ãã—ã¦ã‚‚ã— *obj1* ãŒ *obj2* ã‚ˆã‚Šã€Œå¤§ãã„ã€å ´åˆã¯ ``1`` ã‚’è¿”ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ (ä»¥å‰ã¯å¤§å°æ¯”è¼ƒã®çµæœã¨ã—ã¦ã€ä»»æ„ã®å¤§ãã•ã®è² ã¾ãŸã¯æ­£ã®æ•´æ•°ã‚’è¿”ã›ã¾ã—ãŸãŒã€ Python 2.2 ä»¥é™ã§ã¯ã“ã‚Œã¯ã‚‚ã†è¨±ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚å°†æ¥çš„ã«ã¯ã€ä¸Šã«ã‚ã’ãŸä»¥å¤–ã®è¿”ã‚Šå€¤ã¯åˆ¥ã®æ„å‘³ã‚’ã‚‚ã¤å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚)"

#: ../../extending/newtypes.rst:1327
msgid ""
"A :c:member:`~PyTypeObject.tp_compare` handler may raise an exception.  In "
"this case it should return a negative value.  The caller has to test for the"
" exception using :c:func:`PyErr_Occurred`."
msgstr ":c:member:`~PyTypeObject.tp_compare` ãƒãƒ³ãƒ‰ãƒ©ã¯ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã‚‰ã‚Œã¾ã™ã€‚ã“ã®å ´åˆã€ã“ã®é–¢æ•°ã¯è² ã®å€¤ã‚’è¿”ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚å‘¼ã³å‡ºã—ãŸå´ã¯ :c:func:`PyErr_Occurred` ã‚’ä½¿ã£ã¦ä¾‹å¤–ã‚’æ¤œæŸ»ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../extending/newtypes.rst:1331
msgid "Here is a sample implementation::"
msgstr "ä»¥ä¸‹ã¯ã‚µãƒ³ãƒ—ãƒ«å®Ÿè£…ã§ã™::"

#: ../../extending/newtypes.rst:1354
msgid "Abstract Protocol Support"
msgstr "æŠ½è±¡çš„ãªãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ã‚µãƒãƒ¼ãƒˆ"

#: ../../extending/newtypes.rst:1356
msgid ""
"Python supports a variety of *abstract* 'protocols;' the specific interfaces"
" provided to use these interfaces are documented in :ref:`abstract`."
msgstr "Python ã¯ã„ãã¤ã‚‚ã® *æŠ½è±¡çš„ãª* â€œãƒ—ãƒ­ãƒˆã‚³ãƒ«â€ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã‚’ä½¿ç”¨ã™ã‚‹ç‰¹å®šã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã«ã¤ã„ã¦ã¯ :ref:`abstract` ã§è§£èª¬ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:1360
msgid ""
"A number of these abstract interfaces were defined early in the development "
"of the Python implementation.  In particular, the number, mapping, and "
"sequence protocols have been part of Python since the beginning.  Other "
"protocols have been added over time.  For protocols which depend on several "
"handler routines from the type implementation, the older protocols have been"
" defined as optional blocks of handlers referenced by the type object.  For "
"newer protocols there are additional slots in the main type object, with a "
"flag bit being set to indicate that the slots are present and should be "
"checked by the interpreter.  (The flag bit does not indicate that the slot "
"values are non-*NULL*. The flag may be set to indicate the presence of a "
"slot, but a slot may still be unfilled.) ::"
msgstr "ã“ã‚Œã‚‰å¤šæ•°ã®æŠ½è±¡çš„ãªã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã¯ã€Python ã®å®Ÿè£…ãŒé–‹ç™ºã•ã‚Œã‚‹åˆæœŸã®æ®µéšã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã—ãŸã€‚ã¨ã‚Šã‚ã‘æ•°å€¤ã‚„è¾æ›¸ã€ãã—ã¦ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãªã©ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯æœ€åˆã‹ã‚‰ Python ã®ä¸€éƒ¨ã ã£ãŸã®ã§ã™ã€‚ãã‚Œä»¥å¤–ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯ãã®å¾Œè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚å‹ã®å®Ÿè£…ã«ã‚ã‚‹ã„ãã¤ã‹ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ«ãƒ¼ãƒãƒ³ã«ä¾å­˜ã™ã‚‹ã‚ˆã†ãªãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ãŸã‚ã«ã€å¤ã„ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯ãƒãƒ³ãƒ‰ãƒ©ã®å…¥ã£ãŸã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ãƒ–ãƒ­ãƒƒã‚¯ã¨ã—ã¦å®šç¾©ã—ã€å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰å‚ç…§ã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ã‚¿ã‚¤ãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸»éƒ¨ã«è¿½åŠ ã®ã‚¹ãƒ­ãƒƒãƒˆã‚’ã‚‚ã¤æ–°ã—ã„ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã«ã¤ã„ã¦ã¯ã€ãƒ•ãƒ©ã‚°ç”¨ã®ãƒ“ãƒƒãƒˆã‚’ç«‹ã¦ã‚‹ã“ã¨ã§ãã‚Œã‚‰ã®ã‚¹ãƒ­ãƒƒãƒˆãŒå­˜åœ¨ã—ã¦ãŠã‚Šã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒãƒã‚§ãƒƒã‚¯ã™ã¹ãã§ã‚ã‚‹ã“ã¨ã‚’æŒ‡ç¤ºã§ãã¾ã™ã€‚(ã“ã®ãƒ•ãƒ©ã‚°ç”¨ã®ãƒ“ãƒƒãƒˆã¯ã€ãã®ã‚¹ãƒ­ãƒƒãƒˆã®å€¤ãŒé *NULL* ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ•ãƒ©ã‚°ã¯ã‚¹ãƒ­ãƒƒãƒˆã®å­˜åœ¨ã‚’ç¤ºã™ã®ã«ä½¿ãˆã¾ã™ãŒã€ãã®ã‚¹ãƒ­ãƒƒãƒˆã¯ã¾ã åŸ‹ã¾ã£ã¦ã„ãªã„ã‹ã‚‚ã—ã‚Œãªã„ã®ã§ã™ã€‚) ::"

#: ../../extending/newtypes.rst:1375
msgid ""
"If you wish your object to be able to act like a number, a sequence, or a "
"mapping object, then you place the address of a structure that implements "
"the C type :c:type:`PyNumberMethods`, :c:type:`PySequenceMethods`, or "
":c:type:`PyMappingMethods`, respectively. It is up to you to fill in this "
"structure with appropriate values. You can find examples of the use of each "
"of these in the :file:`Objects` directory of the Python source distribution."
" ::"
msgstr "ãŠä½¿ã„ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ•°å€¤ã‚„ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã€ã‚ã‚‹ã„ã¯è¾æ›¸ã®ã‚ˆã†ã«ãµã‚‹ã¾ã†ã‚ˆã†ã«ã—ãŸã„ãªã‚‰ã°ã€ãã‚Œãã‚Œã« C ã® :c:type:`PyNumberMethods` æ§‹é€ ä½“ã€ :c:type:`PySequenceMethods` æ§‹é€ ä½“ã€ã¾ãŸã¯ :c:type:`PyMappingMethods` æ§‹é€ ä½“ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‰ã«é©åˆ‡ãªå€¤ã‚’å…¥ã‚Œã¦ã‚‚å…¥ã‚Œãªãã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚ã“ã‚Œã‚‰ã‚’ä½¿ã£ãŸä¾‹ã¯ Python ã®é…å¸ƒã‚½ãƒ¼ã‚¹ã«ã‚ã‚‹ :file:`Objects` ã§ã¿ã¤ã‘ã‚‹ã“ã¨ãŒã§ãã‚‹ã§ã—ã‚‡ã†ã€‚ ::"

#: ../../extending/newtypes.rst:1384
msgid ""
"This function, if you choose to provide it, should return a hash number for "
"an instance of your data type. Here is a moderately pointless example::"
msgstr "ã“ã®é–¢æ•°ã¯ã€ã‚‚ã—ä½¿ã†ã®ãªã‚‰ã°ã€ã“ã‚Œã¯ãŠä½¿ã„ã®å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒãƒƒã‚·ãƒ¥ç•ªå·ã‚’è¿”ã™ã‚ˆã†ã«ã—ã¾ã™ã€‚ä»¥ä¸‹ã¯ã‚„ã‚„çš„ã¯ãšã‚Œãªä¾‹ã§ã™ãŒ ::"

#: ../../extending/newtypes.rst:1400
msgid ""
"This function is called when an instance of your data type is \"called\", "
"for example, if ``obj1`` is an instance of your data type and the Python "
"script contains ``obj1('hello')``, the :c:member:`~PyTypeObject.tp_call` "
"handler is invoked."
msgstr "ã“ã®é–¢æ•°ã¯ã€ãã®å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒã€Œé–¢æ•°ã¨ã—ã¦å‘¼ã³å‡ºã•ã‚Œã‚‹ã€ã¨ãã«å‘¼ã°ã‚Œã¾ã™ã€‚ãŸã¨ãˆã°ã‚‚ã— ``obj1`` ã«ãã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒå…¥ã£ã¦ã„ã¦ã€Python ã‚¹ã‚¯ãƒªãƒ—ãƒˆã§ ``obj1('hello')`` ã‚’å®Ÿè¡Œã—ãŸã¨ã™ã‚‹ã¨ã€ :c:member:`~PyTypeObject.tp_call` ãƒãƒ³ãƒ‰ãƒ©ãŒå‘¼ã°ã‚Œã¾ã™ã€‚"

#: ../../extending/newtypes.rst:1404
msgid "This function takes three arguments:"
msgstr "ã“ã®é–¢æ•°ã¯ 3ã¤ã®å¼•æ•°ã‚’ã¨ã‚Šã¾ã™:"

#: ../../extending/newtypes.rst:1406
msgid ""
"*arg1* is the instance of the data type which is the subject of the call. If"
" the call is ``obj1('hello')``, then *arg1* is ``obj1``."
msgstr "*arg1* ã«ã¯ãã®å‘¼ã³å‡ºã—ã®å¯¾è±¡ã¨ãªã‚‹ã€ãã®ãƒ‡ãƒ¼ã‚¿å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒå…¥ã‚Šã¾ã™ã€‚ãŸã¨ãˆã°å‘¼ã³å‡ºã—ãŒ ``obj1('hello')`` ã®å ´åˆã€ *arg1* ã¯ ``obj1`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../extending/newtypes.rst:1409
msgid ""
"*arg2* is a tuple containing the arguments to the call.  You can use "
":c:func:`PyArg_ParseTuple` to extract the arguments."
msgstr "*arg2* ã¯å‘¼ã³å‡ºã—ã®å¼•æ•°ã‚’æ ¼ç´ã—ã¦ã„ã‚‹ã‚¿ãƒ—ãƒ«ã§ã™ã€‚ã“ã“ã‹ã‚‰å¼•æ•°ã‚’å–ã‚Šå‡ºã™ã«ã¯ :c:func:`PyArg_ParseTuple` ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:1412
msgid ""
"*arg3* is a dictionary of keyword arguments that were passed. If this is "
"non-*NULL* and you support keyword arguments, use "
":c:func:`PyArg_ParseTupleAndKeywords` to extract the arguments.  If you do "
"not want to support keyword arguments and this is non-*NULL*, raise a "
":exc:`TypeError` with a message saying that keyword arguments are not "
"supported."
msgstr "*arg3* ã¯ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã®ãŸã‚ã®è¾æ›¸ã§ã™ã€‚ã“ã‚ŒãŒ *NULL* ä»¥å¤–ã§ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ãªã‚‰ã€ :c:func:`PyArg_ParseTupleAndKeywords` ã‚’ã¤ã‹ã£ã¦å¼•æ•°ã‚’å–ã‚Šå‡ºã›ã¾ã™ã€‚ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„ã®ã«ã“ã‚ŒãŒ *NULL* ä»¥å¤–ã®å ´åˆã¯ã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã¯ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„æ—¨ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ã¨ã‚‚ã« :exc:`TypeError` ã‚’ç™ºç”Ÿã•ã›ã¦ãã ã•ã„ã€‚"

#: ../../extending/newtypes.rst:1418
msgid ""
"Here is a desultory example of the implementation of the call function. ::"
msgstr "ä»¥ä¸‹ã¯ã“ã® call é–¢æ•°ã‚’ã¦ãã¨ã†ã«ä½¿ã£ãŸä¾‹ã§ã™ã€‚ ::"

#: ../../extending/newtypes.rst:1444
msgid "XXX some fields need to be added here... ::"
msgstr "XXX some fields need to be added here... ::"

#: ../../extending/newtypes.rst:1451
msgid ""
"These functions provide support for the iterator protocol.  Any object which"
" wishes to support iteration over its contents (which may be generated "
"during iteration) must implement the ``tp_iter`` handler.  Objects which are"
" returned by a ``tp_iter`` handler must implement both the ``tp_iter`` and "
"``tp_iternext`` handlers. Both handlers take exactly one parameter, the "
"instance for which they are being called, and return a new reference.  In "
"the case of an error, they should set an exception and return *NULL*."
msgstr "ã“ã‚Œã‚‰ã®é–¢æ•°ã¯ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ç”¨ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã€ãã® (ãƒ«ãƒ¼ãƒ—ä¸­ã«é †ã«ç”Ÿæˆã•ã‚Œã¦ã„ãã‹ã‚‚ã—ã‚Œãªã„) å†…å®¹ã‚’å·¡å› (è¨³æ³¨: ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã§ã²ã¨ã¤ãšã¤è¦ç´ ã‚’ãŸã©ã£ã¦ã„ãã“ã¨) ã™ã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ã‚µãƒãƒ¼ãƒˆã—ãŸã„å ´åˆã¯ã€ ``tp_iter`` ãƒãƒ³ãƒ‰ãƒ©ã‚’å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ ``tp_iter`` ãƒãƒ³ãƒ‰ãƒ©ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ ``tp_iter`` ã¨ ``tp_iternext`` ã®ä¸¡æ–¹ã‚’å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã©ã¡ã‚‰ã®ãƒãƒ³ãƒ‰ãƒ©ã‚‚ã€ãã‚ŒãŒå‘¼ã°ã‚ŒãŸã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ã²ã¨ã¤ã ã‘å¼•æ•°ã¨ã—ã¦ã¨ã‚Šã€æ–°ã—ã„å‚ç…§ã‚’è¿”ã—ã¾ã™ã€‚ã‚¨ãƒ©ãƒ¼ãŒèµ·ããŸå ´åˆã«ã¯ä¾‹å¤–ã‚’è¨­å®šã—ã¦ã‹ã‚‰ *NULL* ã‚’è¿”ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../extending/newtypes.rst:1459
msgid ""
"For an object which represents an iterable collection, the ``tp_iter`` "
"handler must return an iterator object.  The iterator object is responsible "
"for maintaining the state of the iteration.  For collections which can "
"support multiple iterators which do not interfere with each other (as lists "
"and tuples do), a new iterator should be created and returned.  Objects "
"which can only be iterated over once (usually due to side effects of "
"iteration) should implement this handler by returning a new reference to "
"themselves, and should also implement the ``tp_iternext`` handler.  File "
"objects are an example of such an iterator."
msgstr "å·¡å›å¯èƒ½ãªè¦ç´ ã‚’è¡¨ç¾ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ã¯ã€ ``tp_iter`` ãƒãƒ³ãƒ‰ãƒ©ãŒã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å·¡å›ä¸­ã®çŠ¶æ…‹ã‚’ä¿æŒã™ã‚‹è²¬ä»»ã‚’ã‚‚ã£ã¦ã„ã¾ã™ã€‚ãŠäº’ã„ã«å¹²æ¸‰ã—ãªã„è¤‡æ•°ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®å­˜åœ¨ã‚’è¨±ã™ã‚ˆã†ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (ãƒªã‚¹ãƒˆã‚„ã‚¿ãƒ—ãƒ«ãŒãã†ã§ã™) ã®å ´åˆã¯ã€æ–°ã—ã„ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œæˆã—ã¦è¿”ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ (å·¡å›ã®çµæœç”Ÿã˜ã‚‹å‰¯ä½œç”¨ã®ãŸã‚ã«) ä¸€å›ã ã‘ã—ã‹å·¡å›ã§ããªã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã¯ã€ãã‚Œè‡ªèº«ã¸ã®å‚ç…§ã‚’è¿”ã™ã‚ˆã†ãªãƒãƒ³ãƒ‰ãƒ©ã¨ã€ ``tp_iternext`` ãƒãƒ³ãƒ‰ãƒ©ã‚‚å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãã®ã‚ˆã†ãªã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®ä¾‹ã§ã™ã€‚"

#: ../../extending/newtypes.rst:1469
msgid ""
"Iterator objects should implement both handlers.  The ``tp_iter`` handler "
"should return a new reference to the iterator (this is the same as the "
"``tp_iter`` handler for objects which can only be iterated over "
"destructively).  The ``tp_iternext`` handler should return a new reference "
"to the next object in the iteration if there is one.  If the iteration has "
"reached the end, it may return *NULL* without setting an exception or it may"
" set :exc:`StopIteration`; avoiding the exception can yield slightly better "
"performance.  If an actual error occurs, it should set an exception and "
"return *NULL*."
msgstr "ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä¸¡æ–¹ã®ãƒãƒ³ãƒ‰ãƒ©ã‚’å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ ``tp_iter`` ãƒãƒ³ãƒ‰ãƒ©ã¯ãã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¸ã®æ–°ã—ã„å‚ç…§ã‚’è¿”ã—ã¾ã™ (ã“ã‚Œã¯ç ´å£Šçš„ã«ã—ã‹å·¡å›ã§ããªã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹ ``tp_iter`` ãƒãƒ³ãƒ‰ãƒ©ã¨åŒã˜ã§ã™)ã€‚ ``tp_iternext`` ãƒãƒ³ãƒ‰ãƒ©ã¯ãã®æ¬¡ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚ã‚‹å ´åˆã€ãã‚Œã¸ã®æ–°ã—ã„å‚ç…§ã‚’è¿”ã—ã¾ã™ã€‚å·¡å›ãŒçµ‚ç«¯ã«é”ã—ãŸã¨ãã¯ä¾‹å¤–ã‚’å‡ºã•ãšã« *NULL* ã‚’è¿”ã—ã¦ã‚‚ã„ã„ã§ã™ã—ã€ :exc:`StopIteration` ã‚’æ”¾å‡ºã—ã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚ä¾‹å¤–ã‚’ä½¿ã‚ãªã„ã»ã†ãŒã‚„ã‚„é€Ÿåº¦ãŒä¸ŠãŒã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚å®Ÿéš›ã®ã‚¨ãƒ©ãƒ¼ãŒèµ·ã“ã£ãŸã¨ãã«ã¯ã€ä¾‹å¤–ã‚’æ”¾å‡ºã—ã¦ *NULL* ã‚’è¿”ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../extending/newtypes.rst:1482
msgid "Weak Reference Support"
msgstr "å¼±å‚ç…§(Weak Reference)ã®ã‚µãƒãƒ¼ãƒˆ"

#: ../../extending/newtypes.rst:1484
msgid ""
"One of the goals of Python's weak-reference implementation is to allow any "
"type to participate in the weak reference mechanism without incurring the "
"overhead on those objects which do not benefit by weak referencing (such as "
"numbers)."
msgstr "Pythonã®å¼±å‚ç…§å®Ÿè£…ã®ã²ã¨ã¤ã®ã‚´ãƒ¼ãƒ«ã¯ã€ã©ã®ã‚ˆã†ãªï¼ˆæ•°å€¤ã®ã‚ˆã†ãªå¼±å‚ç…§ã«ã‚ˆã‚‹åˆ©ç›Šã‚’å¾—ãªã„ï¼‰ã‚¿ã‚¤ãƒ—ã§ã‚‚ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ãªã—ã§å¼±å‚ç…§ã®ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã«çµ„ã¿è¾¼ã‚ã‚‹ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã§ã™ã€‚"

#: ../../extending/newtypes.rst:1488
msgid ""
"For an object to be weakly referencable, the extension must include a "
":c:type:`PyObject\\*` field in the instance structure for the use of the "
"weak reference mechanism; it must be initialized to *NULL* by the object's "
"constructor.  It must also set the "
":c:member:`~PyTypeObject.tp_weaklistoffset` field of the corresponding type "
"object to the offset of the field. For example, the instance type is defined"
" with the following structure::"
msgstr "å¼±å‚ç…§å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ‹¡å¼µã§ã¯ã€å¼±å‚ç…§ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã®ãŸã‚ã« :c:type:`PyObject\\*` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ§‹é€ ä½“ã«å«ã‚€å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ *NULL* ã«åˆæœŸåŒ–ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯å¯¾å¿œã™ã‚‹ã‚¿ã‚¤ãƒ—ã® :c:member:`~PyTypeObject.tp_weaklistoffset` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã«è¨­å®šã—ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€‚ãŸã¨ãˆã°ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚¿ã‚¤ãƒ—ã¯ä»¥ä¸‹ã®æ§‹é€ ä½“ã§å®šç¾©ã•ã‚Œã¾ã™::"

#: ../../extending/newtypes.rst:1502
msgid ""
"The statically-declared type object for instances is defined this way::"
msgstr "ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”¨ã«é™çš„ã«å®£è¨€ã•ã‚ŒãŸã‚¿ã‚¤ãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã“ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã¾ã™::"

#: ../../extending/newtypes.rst:1519
msgid ""
"The type constructor is responsible for initializing the weak reference list"
" to *NULL*::"
msgstr "ã‚¿ã‚¤ãƒ—ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯å¼±å‚ç…§ã‚’ *NULL* ã«åˆæœŸåŒ–ã™ã‚‹è²¬ä»»ãŒã‚ã‚Šã¾ã™::"

#: ../../extending/newtypes.rst:1531
msgid ""
"The only further addition is that the destructor needs to call the weak "
"reference manager to clear any weak references.  This is only required if "
"the weak reference list is non-*NULL*::"
msgstr "ã»ã‹ã«è¿½è¨˜ã™ã¹ãã“ã¨ã¯ã€ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯å¼±å‚ç…§ã‚’æ¶ˆã™ãŸã‚ã«å¼±å‚ç…§ã®ãƒãƒãƒ¼ã‚¸ãƒ£ã‚’å‘¼ã¶å¿…è¦ãŒã‚ã‚‹ã“ã¨ãã‚‰ã„ã§ã™ã€‚ã“ã‚Œã¯å¼±å‚ç…§ãƒªã‚¹ãƒˆãŒ *NULL* ã§ãªã„å ´åˆã«ã ã‘å¿…è¦ã§ã™::"

#: ../../extending/newtypes.rst:1550
msgid "More Suggestions"
msgstr "ãã®ä»–ã„ã‚ã„ã‚"

#: ../../extending/newtypes.rst:1552
msgid ""
"Remember that you can omit most of these functions, in which case you "
"provide ``0`` as a value.  There are type definitions for each of the "
"functions you must provide.  They are in :file:`object.h` in the Python "
"include directory that comes with the source distribution of Python."
msgstr "ä¸Šã«ã‚ã’ãŸã»ã¨ã‚“ã©ã®é–¢æ•°ã¯ã€ãã®å€¤ã¨ã—ã¦ ``0`` ã‚’ä¸ãˆã‚Œã°çœç•¥ã§ãã‚‹ã“ã¨ã‚’å¿˜ã‚Œãªã„ã§ãã ã•ã„ã€‚ãã‚Œãã‚Œã®é–¢æ•°ã§æä¾›ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„å‹ã®å®šç¾©ãŒã‚ã‚Šã€ã“ã‚Œã‚‰ã¯ Python ã® include ç”¨ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã® :file:`object.h` ã¨ã„ã†ãƒ•ã‚¡ã‚¤ãƒ«ã«ãŠã•ã‚ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯ Python ã®é…å¸ƒã‚½ãƒ¼ã‚¹ã«å«ã¾ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:1557
msgid ""
"In order to learn how to implement any specific method for your new data "
"type, do the following: Download and unpack the Python source distribution."
"  Go the :file:`Objects` directory, then search the C source files for "
"``tp_`` plus the function you want (for example, ``tp_print`` or "
"``tp_compare``).  You will find examples of the function you want to "
"implement."
msgstr "æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿å‹ã«ä½•ã‚‰ã‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã™ã‚‹ã‚„ã‚Šã‹ãŸã‚’å­¦ã¶ã«ã¯ã€ä»¥ä¸‹ã®æ–¹æ³•ãŒãŠã™ã™ã‚ã§ã™: Python ã®é…å¸ƒã•ã‚Œã¦ã„ã‚‹ã‚½ãƒ¼ã‚¹ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦å±•é–‹ã™ã‚‹ã€‚ :file:`Objects` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¸è¡Œãã€C ã®ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã€Œ ``tp_`` æ¬²ã—ã„åå‰ã€ã®æ–‡å­—åˆ—ã§æ¤œç´¢ã™ã‚‹ (ãŸã¨ãˆã° ``tp_print`` ã¨ã‹ ``tp_compare`` ã®ã‚ˆã†ã«)ã€‚ã“ã†ã™ã‚Œã°å®Ÿè£…ã—ãŸã„ä¾‹ãŒã¿ã¤ã‹ã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../extending/newtypes.rst:1563
msgid ""
"When you need to verify that an object is an instance of the type you are "
"implementing, use the :c:func:`PyObject_TypeCheck` function. A sample of its"
" use might be something like the following::"
msgstr "ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã€ã„ã¾å®Ÿè£…ã—ã¦ã„ã‚‹å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºã‹ã‚ãŸã„å ´åˆã«ã¯ã€ :c:func:`PyObject_TypeCheck` é–¢æ•°ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚ä½¿ç”¨ä¾‹ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªã‹ã‚“ã˜ã§ã™::"

#: ../../extending/newtypes.rst:1573
msgid "Footnotes"
msgstr "æ³¨è¨˜"

#: ../../extending/newtypes.rst:1574
msgid ""
"This is true when we know that the object is a basic type, like a string or "
"a float."
msgstr "ã“ã‚Œã¯ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ–‡å­—åˆ—ã‚„å®Ÿæ•°ãªã©ã®åŸºæœ¬ã‚¿ã‚¤ãƒ—ã§ã‚ã‚‹ã‚ˆã†ãªæ™‚ã«æˆã‚Šç«‹ã¡ã¾ã™ã€‚"

#: ../../extending/newtypes.rst:1577
msgid ""
"We relied on this in the :c:member:`~PyTypeObject.tp_dealloc` handler in "
"this example, because our type doesn't support garbage collection. Even if a"
" type supports garbage collection, there are calls that can be made to "
"\"untrack\" the object from garbage collection, however, these calls are "
"advanced and not covered here."
msgstr "ã“ã“ã§å‡ºã¦ããŸã‚¿ã‚¤ãƒ—ã§ã¯ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„ã®ã§ã€ã“ã®ä¾‹ã§ã¯ :c:member:`~PyTypeObject.tp_dealloc` ãƒãƒ³ãƒ‰ãƒ©ã«ä¾å­˜ã—ã¦ã„ã¾ã™ã€‚ã“ã®ãƒãƒ³ãƒ‰ãƒ©ã¯ãã®ã‚¿ã‚¤ãƒ—ãŒãŸã¨ãˆã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹å ´åˆã§ã‚‚ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã€Œè¿½è·¡ã‚’è§£é™¤ã™ã‚‹ã€ãŸã‚ã«å‘¼ã°ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ãŒã€ã“ã‚Œã¯é«˜åº¦ãªè©±é¡Œã§ã‚ã‚Šã“ã“ã§ã¯æ‰±ã„ã¾ã›ã‚“ã€‚"

#: ../../extending/newtypes.rst:1582
msgid ""
"We now know that the first and last members are strings, so perhaps we could"
" be less careful about decrementing their reference counts, however, we "
"accept instances of string subclasses. Even though deallocating normal "
"strings won't call back into our objects, we can't guarantee that "
"deallocating an instance of a string subclass won't call back into our "
"objects."
msgstr "first ãŠã‚ˆã³ last ãƒ¡ãƒ³ãƒãŒæ–‡å­—åˆ—ã§ã‚ã‚‹ã¨ã„ã†ã“ã¨ã¯ã‚ã‹ã£ã¦ã„ã‚‹ã®ã§ã€ã„ã¾ã‚„ãã‚Œã‚‰ã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’æ¸›ã‚‰ã™ã¨ãã«ã¯ãã‚Œã»ã©æ³¨æ„ã™ã‚‹å¿…è¦ã¯ãªã„ã‚ˆã†ã«æ€ãˆã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã—ã‹ã—æ–‡å­—åˆ—å‹ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã¯ä¾ç„¶ã¨ã—ã¦å—ã‘ã¤ã‘ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚é€šå¸¸ã®æ–‡å­—åˆ—å‹ãªã‚‰ã°ã€è§£æ”¾æ™‚ã«ã‚ãªãŸã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€æ–‡å­—åˆ—å‹ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ãŒãã†ã—ãªã„ã¨ã„ã†ä¿è¨¼ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../extending/newtypes.rst:1588
msgid ""
"Even in the third version, we aren't guaranteed to avoid cycles.  Instances "
"of string subclasses are allowed and string subclasses could allow cycles "
"even if normal strings don't."
msgstr "3ç•ªç›®ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã•ãˆã€å¾ªç’°ã‚’å›é¿ã§ãã‚‹ã¨ã„ã†ä¿è¨¼ã¯ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ãŸã¨ãˆé€šå¸¸ã®æ–‡å­—åˆ—å‹ãªã‚‰å¾ªç’°ã—ãªã„å ´åˆã§ã‚‚ã€æ–‡å­—åˆ—å‹ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’ã¨ã‚‹ã“ã¨ãŒè¨±ã•ã‚Œã¦ã„ã‚Œã°ã€ãã®ã‚¿ã‚¤ãƒ—ã§ã¯å¾ªç’°ãŒç™ºç”Ÿã—ã†ã‚‹ã‹ã‚‰ã§ã™ã€‚"
