# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# 秘湯 <xwhhsprings@gmail.com>, 2015
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 01:01+0900\n"
"PO-Revision-Date: 2019-09-01 05:18+0000\n"
"Last-Translator: tomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/"
"language/ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../extending/newtypes.rst:8
msgid "Defining New Types"
msgstr "新しい型を定義する"

#: ../../extending/newtypes.rst:15
msgid ""
"As mentioned in the last chapter, Python allows the writer of an extension "
"module to define new types that can be manipulated from Python code, much "
"like strings and lists in core Python."
msgstr ""
"前の章でふれたように、Python では拡張モジュールを書くプログラマが Python の"
"コードから操作できる、新しい型を定義できるようになっています。ちょうど "
"Python の中核にある文字列やリストをつくれるようなものです。"

#: ../../extending/newtypes.rst:19
msgid ""
"This is not hard; the code for all extension types follows a pattern, but "
"there are some details that you need to understand before you can get "
"started."
msgstr ""
"これはそんなにむずかしくはありません。拡張型のためのコードにはすべて、一定の"
"パターンが存在しています。しかし始める前に、いくつか細かいことを理解しておく"
"必要があるでしょう。"

#: ../../extending/newtypes.rst:24
msgid ""
"The way new types are defined changed dramatically (and for the better) in "
"Python 2.2.  This document documents how to define new types for Python 2.2 "
"and later.  If you need to support older versions of Python, you will need "
"to refer to `older versions of this documentation <https://www.python.org/"
"doc/versions/>`_."
msgstr ""
"Python 2.2 から、新しい型を定義する方法がかなり変わって (良くなって) います。"
"この文書は Python 2.2 およびそれ以降で新しい型をどうやって定義するかについて"
"述べています。古いバージョンの Python をサポートする必要がある場合は、 `この"
"文書の古い版 <https://www.python.org/doc/versions/>`_ を参照してください。"

#: ../../extending/newtypes.rst:34
msgid "The Basics"
msgstr "基本的なこと"

#: ../../extending/newtypes.rst:36
msgid ""
"The Python runtime sees all Python objects as variables of type :c:type:"
"`PyObject\\*`.  A :c:type:`PyObject` is not a very magnificent object - it "
"just contains the refcount and a pointer to the object's \"type object\".  "
"This is where the action is; the type object determines which (C) functions "
"get called when, for instance, an attribute gets looked up on an object or "
"it is multiplied by another object.  These C functions are called \"type "
"methods\"."
msgstr ""
"Python ランタイムでは、すべての Python オブジェクトは :c:type:`PyObject\\*` "
"型の変数として扱います。 :c:type:`PyObject` はさほど大仰なオブジェクトではな"
"く、単にオブジェクトに対する参照回数と、そのオブジェクトの「タイプオブジェク"
"ト (type object)」へのポインタを格納しているだけです。重要な役割を果たしてい"
"るのはこのタイプオブジェクトです。つまりタイプオブジェクトは、例えばあるオブ"
"ジェクトのある属性が参照されるとか、あるいは別のオブジェクトとの間で乗算を行"
"うといったときに、どの (C の) 関数を呼び出すかを決定しているのです。これらの "
"C 関数は「タイプメソッド (type method)」と呼ばれ、 ``[].append`` のようなも"
"の (いわゆる「オブジェクトメソッド (object method)」) とは区別しています。"

#: ../../extending/newtypes.rst:43
msgid ""
"So, if you want to define a new object type, you need to create a new type "
"object."
msgstr ""
"なので、新しいオブジェクトの型を定義したいときは、新しいタイプオブジェクトを"
"作成すればよいわけです。"

#: ../../extending/newtypes.rst:46
msgid ""
"This sort of thing can only be explained by example, so here's a minimal, "
"but complete, module that defines a new type:"
msgstr ""
"この手のことは例を見たほうが早いでしょうから、ここに最小限の、しかし完全な、"
"新しい型を定義するモジュールをあげておきます:"

#: ../../extending/newtypes.rst:52
msgid ""
"Now that's quite a bit to take in at once, but hopefully bits will seem "
"familiar from the last chapter."
msgstr ""
"さしあたって覚えておくことは以上ですが、これで前の章からすこしは説明がわかり"
"やすくなっていることと思います。"

#: ../../extending/newtypes.rst:55
msgid "The first bit that will be new is::"
msgstr "最初に習うのは、つぎのようなものです::"

#: ../../extending/newtypes.rst:61
msgid ""
"This is what a Noddy object will contain---in this case, nothing more than "
"every Python object contains, namely a refcount and a pointer to a type "
"object.  These are the fields the ``PyObject_HEAD`` macro brings in.  The "
"reason for the macro is to standardize the layout and to enable special "
"debugging fields in debug builds.  Note that there is no semicolon after the "
"``PyObject_HEAD`` macro; one is included in the macro definition.  Be wary "
"of adding one by accident; it's easy to do from habit, and your compiler "
"might not complain, but someone else's probably will!  (On Windows, MSVC is "
"known to call this an error and refuse to compile the code.)"
msgstr ""
"これが Noddy オブジェクトの内容です --- このケースでは、ほかの Python オブ"
"ジェクトが持っているものと何ら変わりはありません。つまり参照カウントと型オブ"
"ジェクトへのポインタですね。これらは ``PyObject_HEAD`` マクロによって展開され"
"るメンバです。マクロを使う理由は、レイアウトを標準化するためと、デバッグ用ビ"
"ルド時に特別なデバッグ用のメンバを定義できるようにするためです。この "
"``PyObject_HEAD`` マクロの後にはセミコロンがないことに注意してください。セミ"
"コロンはすでにマクロ内に含まれています。うっかり後にセミコロンをつけてしまわ"
"ないように気をつけて。これはお使いの機種では何の問題も起こらないかもしれませ"
"んが、機種によっては、おそらく問題になるのです! (Windows 上では、MS Visual C "
"がこの手のエラーを出し、コンパイルできないことが知られています)"

#: ../../extending/newtypes.rst:71
msgid ""
"For contrast, let's take a look at the corresponding definition for standard "
"Python integers::"
msgstr "比較のため、以下に標準的な Python の整数型の定義を見てみましょう::"

#: ../../extending/newtypes.rst:79
msgid "Moving on, we come to the crunch --- the type object. ::"
msgstr "では次にいってみます。かなめの部分、タイプオブジェクトです。 ::"

#: ../../extending/newtypes.rst:105
msgid ""
"Now if you go and look up the definition of :c:type:`PyTypeObject` in :file:"
"`object.h` you'll see that it has many more fields that the definition "
"above.  The remaining fields will be filled with zeros by the C compiler, "
"and it's common practice to not specify them explicitly unless you need them."
msgstr ""
":file:`object.h` の中にある :c:type:`PyTypeObject` の定義を見ると、実際にはこ"
"こに挙げた以上の数のメンバがあるとわかるでしょう。これ以外のメンバは C コンパ"
"イラによってゼロに初期化されるので、必要な時を除いてふつうはそれらの値を明示"
"的には指定せずにおきます。"

#: ../../extending/newtypes.rst:110
msgid ""
"This is so important that we're going to pick the top of it apart still "
"further::"
msgstr "次のものは非常に重要なので、とくに最初の最初に見ておきましょう::"

#: ../../extending/newtypes.rst:115
msgid "This line is a bit of a wart; what we'd like to write is::"
msgstr "これはちょっとぶっきらぼうですね。実際に書きたかったのはこうです::"

#: ../../extending/newtypes.rst:119
msgid ""
"as the type of a type object is \"type\", but this isn't strictly conforming "
"C and some compilers complain.  Fortunately, this member will be filled in "
"for us by :c:func:`PyType_Ready`. ::"
msgstr ""
"この場合、タイプオブジェクトの型は「type」という名前になりますが、これは厳密"
"には C の基準に従っておらず、コンパイラによっては文句を言われます。幸いにも、"
"このメンバは :c:func:`PyType_Ready` が埋めてくれます。 ::"

#: ../../extending/newtypes.rst:125
msgid ""
"The name of our type.  This will appear in the default textual "
"representation of our objects and in some error messages, for example::"
msgstr ""
"これは型の名前です。この名前はオブジェクトのデフォルトの表現形式と、いくつか"
"のエラーメッセージ中で使われます。たとえば::"

#: ../../extending/newtypes.rst:133
msgid ""
"Note that the name is a dotted name that includes both the module name and "
"the name of the type within the module. The module in this case is :mod:"
"`noddy` and the type is :class:`Noddy`, so we set the type name to :class:"
"`noddy.Noddy`. One side effect of using an undotted name is that the pydoc "
"documentation tool will not list the new type in the module documentation. ::"
msgstr ""
"注意: この名前はドットで区切られた名前で、モジュール名とそのモジュール内での"
"型名の両方を含んでいます。\n"
"この場合のモジュールは :mod:`noddy` で型は :class:`Noddy` ですから、ここでの"
"型名としては :class:`noddy.Noddy` を指定するわけです。\n"
"ドットで区切られていない名前を使うと、文書ツールの pydoc がその新しい型をモ"
"ジュールの文書に載せなくなるという副作用があります。 ::"

#: ../../extending/newtypes.rst:141
msgid ""
"This is so that Python knows how much memory to allocate when you call :c:"
"func:`PyObject_New`."
msgstr ""
"これによって Python は :c:func:`PyObject_New` が呼ばれたときにどれくらいの量"
"のメモリを割り当てればよいのか知ることができます。"

#: ../../extending/newtypes.rst:146
msgid ""
"If you want your type to be subclassable from Python, and your type has the "
"same :c:member:`~PyTypeObject.tp_basicsize` as its base type, you may have "
"problems with multiple inheritance.  A Python subclass of your type will "
"have to list your type first in its :attr:`~class.__bases__`, or else it "
"will not be able to call your type's :meth:`__new__` method without getting "
"an error.  You can avoid this problem by ensuring that your type has a "
"larger value for :c:member:`~PyTypeObject.tp_basicsize` than its base type "
"does.  Most of the time, this will be true anyway, because either your base "
"type will be :class:`object`, or else you will be adding data members to "
"your base type, and therefore increasing its size."
msgstr ""
"あなたのタイプを Python でサブクラス化可能にしたい場合、そのタイプが基底タイ"
"プと同じ :c:member:`~PyTypeObject.tp_basicsize` をもっていると多重継承のとき"
"に問題が生じることがあります。そのタイプを Python のサブクラスにしたとき、そ"
"の :attr:`~class.__bases__` リストにはあなたのタイプが最初にくるようにしなけ"
"ればなりません。さもないとエラーの発生なしにあなたのタイプの :meth:`__new__` "
"メソッドを呼び出すことはできなくなります。この問題を回避するには、つねにあな"
"たのタイプの :c:member:`~PyTypeObject.tp_basicsize` をその基底タイプよりも大"
"きくしておくことです。ほとんどの場合、あなたのタイプは :class:`object` か、そ"
"うでなければ基底タイプにデータ用のメンバを追加したものでしょうから、したがっ"
"て大きさはつねに増加するためこの条件は満たされています。"

#: ../../extending/newtypes.rst:160
msgid ""
"This has to do with variable length objects like lists and strings. Ignore "
"this for now."
msgstr ""
"これはリストや文字列などの可変長オブジェクトのためのものです。今のところ無視"
"しましょう。"

#: ../../extending/newtypes.rst:163
msgid ""
"Skipping a number of type methods that we don't provide, we set the class "
"flags to :const:`Py_TPFLAGS_DEFAULT`. ::"
msgstr ""
"このあとのいくつかのタイプメソッドは使わないのでとばして、クラスのフラグ "
"(flags) には :const:`Py_TPFLAGS_DEFAULT` を入れます。 ::"

#: ../../extending/newtypes.rst:168
msgid ""
"All types should include this constant in their flags.  It enables all of "
"the members defined by the current version of Python."
msgstr ""
"すべての型はフラグにこの定数を含めておく必要があります。これは現在のバージョ"
"ンの Python で定義されているすべてのメンバを許可します。"

#: ../../extending/newtypes.rst:171
msgid ""
"We provide a doc string for the type in :c:member:`~PyTypeObject.tp_doc`. ::"
msgstr "この型の docstring は :c:member:`~PyTypeObject.tp_doc` に入れます。 ::"

#: ../../extending/newtypes.rst:175
msgid ""
"Now we get into the type methods, the things that make your objects "
"different from the others.  We aren't going to implement any of these in "
"this version of the module.  We'll expand this example later to have more "
"interesting behavior."
msgstr ""
"ここからタイプメソッドに入るわけですが。ここがあなたのオブジェクトが他と違う"
"ところです。でも今回のバージョンでは、これらはどれも実装しないでおき、あとで"
"この例をより面白いものに改造することにしましょう。"

#: ../../extending/newtypes.rst:179
msgid ""
"For now, all we want to be able to do is to create new :class:`Noddy` "
"objects. To enable object creation, we have to provide a :c:member:"
"`~PyTypeObject.tp_new` implementation. In this case, we can just use the "
"default implementation provided by the API function :c:func:"
"`PyType_GenericNew`.  We'd like to just assign this to the :c:member:"
"`~PyTypeObject.tp_new` slot, but we can't, for portability sake, On some "
"platforms or compilers, we can't statically initialize a structure member "
"with a function defined in another C module, so, instead, we'll assign the :"
"c:member:`~PyTypeObject.tp_new` slot in the module initialization function "
"just before calling :c:func:`PyType_Ready`::"
msgstr ""
"とりあえずやりたいのは、この :class:`Noddy` オブジェクトを新しく作れるように"
"することです。オブジェクトの作成を許可するには、 :c:member:`~PyTypeObject."
"tp_new` の実装を提供する必要があります。今回は、 API 関数によって提供されるデ"
"フォルトの実装 :c:func:`PyType_GenericNew` を使うだけにしましょう。これを単"
"に :c:member:`~PyTypeObject.tp_new` スロットに代入すればよいのですが、これは"
"互換上の理由からできません。プラットフォームやコンパイラによっては、構造体メ"
"ンバの初期化に別の場所で定義されている C の関数を代入することはできないので"
"す。なので、この :c:member:`~PyTypeObject.tp_new` の値はモジュール初期化用の"
"関数で代入します。 :c:func:`PyType_Ready` を呼ぶ直前です::"

#: ../../extending/newtypes.rst:193
msgid ""
"All the other type methods are *NULL*, so we'll go over them later --- "
"that's for a later section!"
msgstr ""
"これ以外のタイプメソッドはすべて *NULL* です。これらについては後ほどふれます!"

#: ../../extending/newtypes.rst:196
msgid ""
"Everything else in the file should be familiar, except for some code in :c:"
"func:`initnoddy`::"
msgstr ""
"このファイル中にある他のものは、どれもおなじみでしょう。 :c:func:`initnoddy` "
"のこれを除いて::"

#: ../../extending/newtypes.rst:202
msgid ""
"This initializes the :class:`Noddy` type, filing in a number of members, "
"including :attr:`ob_type` that we initially set to *NULL*. ::"
msgstr ""
"この関数は、上で *NULL* に指定していた :attr:`ob_type` などのいくつものメンバ"
"を埋めて、 :class:`Noddy` 型を初期化します。 ::"

#: ../../extending/newtypes.rst:207
msgid ""
"This adds the type to the module dictionary.  This allows us to create :"
"class:`Noddy` instances by calling the :class:`Noddy` class::"
msgstr ""
"これはこの型をモジュール中の辞書に埋め込みます。これで、 :class:`Noddy` クラ"
"スを呼べば :class:`Noddy` インスタンスを作れるようになりました::"

#: ../../extending/newtypes.rst:213
msgid ""
"That's it!  All that remains is to build it; put the above code in a file "
"called :file:`noddy.c` and ::"
msgstr ""
"これだけです! 残るはこれをどうやってビルドするかということです。上のコード"
"を :file:`noddy.c` というファイルに入れて、以下のものを :file:`setup.py` とい"
"うファイルに入れましょう ::"

#: ../../extending/newtypes.rst:220
msgid "in a file called :file:`setup.py`; then typing"
msgstr "そして、シェルから以下のように入力します"

#: ../../extending/newtypes.rst:226
msgid ""
"at a shell should produce a file :file:`noddy.so` in a subdirectory; move to "
"that directory and fire up Python --- you should be able to ``import noddy`` "
"and play around with Noddy objects."
msgstr ""
"これでサブディレクトリの下にファイル :file:`noddy.so` が作成されます。この"
"ディレクトリに移動して Python を起動しましょう。 ``import noddy`` して Noddy "
"オブジェクトで遊べるようになっているはずです。"

#: ../../extending/newtypes.rst:230
msgid "That wasn't so hard, was it?"
msgstr "そんなにむずかしくありません、よね?"

#: ../../extending/newtypes.rst:232
msgid ""
"Of course, the current Noddy type is pretty uninteresting. It has no data "
"and doesn't do anything. It can't even be subclassed."
msgstr ""
"もちろん、現在の Noddy 型はまだおもしろみに欠けています。何もデータを持ってな"
"いし、何もしてはくれません。継承してサブクラスを作ることさえできないのです。"

#: ../../extending/newtypes.rst:237
msgid "Adding data and methods to the Basic example"
msgstr "基本のサンプルにデータとメソッドを追加する"

#: ../../extending/newtypes.rst:239
msgid ""
"Let's extend the basic example to add some data and methods.  Let's also "
"make the type usable as a base class. We'll create a new module, :mod:"
"`noddy2` that adds these capabilities:"
msgstr ""
"この基本のサンプルにデータとメソッドを追加してみましょう。ついでに、この型を"
"基底クラスとしても利用できるようにします。ここでは新しいモジュール :mod:"
"`noddy2` をつくり、以下の機能を追加します:"

#: ../../extending/newtypes.rst:246
msgid "This version of the module has a number of changes."
msgstr "このバージョンでは、いくつもの変更をおこないます。"

#: ../../extending/newtypes.rst:248
msgid "We've added an extra include::"
msgstr "以下の include を追加します::"

#: ../../extending/newtypes.rst:252
msgid ""
"This include provides declarations that we use to handle attributes, as "
"described a bit later."
msgstr ""
"すこしあとでふれますが、この include には属性を扱うための宣言が入っています。"

#: ../../extending/newtypes.rst:255
msgid ""
"The name of the :class:`Noddy` object structure has been shortened to :class:"
"`Noddy`.  The type object name has been shortened to :class:`NoddyType`."
msgstr ""
":class:`Noddy` オブジェクトの構造体の名前は :class:`Noddy` に縮めることにしま"
"す。タイプオブジェクト名は :class:`NoddyType` に縮めます。"

#: ../../extending/newtypes.rst:258
msgid ""
"The  :class:`Noddy` type now has three data attributes, *first*, *last*, and "
"*number*.  The *first* and *last* variables are Python strings containing "
"first and last names. The *number* attribute is an integer."
msgstr ""
"これから :class:`Noddy` 型は 3つのデータ属性をもつようになります。 "
"*first* 、 *last* 、および *number* です。 *first* と *last* 属性はファースト"
"ネームとラストネームを格納した Python 文字列で、 *number* 属性は整数の値で"
"す。"

#: ../../extending/newtypes.rst:262
msgid "The object structure is updated accordingly::"
msgstr "これにしたがうと、オブジェクトの構造体は次のようになります::"

#: ../../extending/newtypes.rst:271
msgid ""
"Because we now have data to manage, we have to be more careful about object "
"allocation and deallocation.  At a minimum, we need a deallocation method::"
msgstr ""
"いまや管理すべきデータができたので、オブジェクトの割り当てと解放に際してはよ"
"り慎重になる必要があります。最低限、オブジェクトの解放メソッドが必要です::"

#: ../../extending/newtypes.rst:282
msgid "which is assigned to the :c:member:`~PyTypeObject.tp_dealloc` member::"
msgstr ""
"この関数は :c:member:`~PyTypeObject.tp_dealloc` メンバに代入されます。 ::"

#: ../../extending/newtypes.rst:286
msgid ""
"This method decrements the reference counts of the two Python attributes. We "
"use :c:func:`Py_XDECREF` here because the :attr:`first` and :attr:`last` "
"members could be *NULL*.  It then calls the :c:member:`~PyTypeObject."
"tp_free` member of the object's type to free the object's memory.  Note that "
"the object's type might not be :class:`NoddyType`, because the object may be "
"an instance of a subclass."
msgstr ""
"このメソッドでやっているのは、ふたつの Python 属性の参照カウントを減らすこと"
"です。 :attr:`first` メンバと :attr:`last` メンバが *NULL* かもしれないため、"
"ここでは :c:func:`Py_XDECREF` を使いました。このあとそのオブジェクトのタイプ"
"メソッドである :c:member:`~PyTypeObject.tp_free` メンバを呼び出しています。こ"
"こではオブジェクトの型が :class:`NoddyType` とは限らないことに注意してくださ"
"い。なぜなら、このオブジェクトはサブクラス化したインスタンスかもしれないから"
"です。"

#: ../../extending/newtypes.rst:292
msgid ""
"We want to make sure that the first and last names are initialized to empty "
"strings, so we provide a new method::"
msgstr ""
"ファーストネームとラストネームを空文字列に初期化しておきたいので、新しいメ"
"ソッドを追加することにしましょう::"

#: ../../extending/newtypes.rst:322
msgid "and install it in the :c:member:`~PyTypeObject.tp_new` member::"
msgstr ""
"そしてこれを :c:member:`~PyTypeObject.tp_new` メンバとしてインストールしま"
"す::"

#: ../../extending/newtypes.rst:326
msgid ""
"The new member is responsible for creating (as opposed to initializing) "
"objects of the type.  It is exposed in Python as the :meth:`__new__` "
"method.  See the paper titled \"Unifying types and classes in Python\" for a "
"detailed discussion of the :meth:`__new__` method.  One reason to implement "
"a new method is to assure the initial values of instance variables.  In this "
"case, we use the new method to make sure that the initial values of the "
"members :attr:`first` and :attr:`last` are not *NULL*. If we didn't care "
"whether the initial values were *NULL*, we could have used :c:func:"
"`PyType_GenericNew` as our new method, as we did before.  :c:func:"
"`PyType_GenericNew` initializes all of the instance variable members to "
"*NULL*."
msgstr ""
"この新しいメンバはその型のオブジェクトを (初期化するのではなく) 作成する責任"
"を負っています。Python ではこのメンバは :meth:`__new__` メソッドとして見えて"
"います。 :meth:`__new__` メソッドについての詳しい議論は \"Unifying types and "
"classes in Python\" という題名の論文を見てください。 new メソッドを実装する理"
"由のひとつは、インスタンス変数の初期値を保証するためです。この例でやりたいの"
"は new メソッドが :attr:`first` メンバと  :attr:`last` メンバの値を *NULL* で"
"ないようにするということです。もしこれらの初期値が *NULL* でもよいのであれ"
"ば、先の例でやったように、new メソッドとして :c:func:`PyType_GenericNew` を使"
"うこともできたでしょう。 :c:func:`PyType_GenericNew` はすべてのインスタンス変"
"数のメンバを *NULL* にします。"

#: ../../extending/newtypes.rst:337
msgid ""
"The new method is a static method that is passed the type being instantiated "
"and any arguments passed when the type was called, and that returns the new "
"object created. New methods always accept positional and keyword arguments, "
"but they often ignore the arguments, leaving the argument handling to "
"initializer methods. Note that if the type supports subclassing, the type "
"passed may not be the type being defined.  The new method calls the tp_alloc "
"slot to allocate memory. We don't fill the :c:member:`~PyTypeObject."
"tp_alloc` slot ourselves. Rather :c:func:`PyType_Ready` fills it for us by "
"inheriting it from our base class, which is :class:`object` by default.  "
"Most types use the default allocation."
msgstr ""
"この new メソッドは静的なメソッドで、インスタンスを生成するときにその型と、型"
"が呼び出されたときの引数が渡され、新しいオブジェクトを作成して返します。new "
"メソッドはつねに、あらかじめ固定引数 (positional argument) とキーワード引数を"
"取りますが、これらのメソッドはしばしばそれらの引数は無視して初期化メソッドに"
"そのまま渡します。new メソッドはメモリ割り当てのために :c:member:"
"`~PyTypeObject.tp_alloc` メンバを呼び出します。 :c:member:`~PyTypeObject."
"tp_alloc` をこちらで初期化する必要はありません。これは :c:func:"
"`PyType_Ready` が基底クラス (デフォルトでは :class:`object`) をもとに埋めるも"
"のです。ほとんどの型ではデフォルトのメモリ割り当てを使っています。"

#: ../../extending/newtypes.rst:349
msgid ""
"If you are creating a co-operative :c:member:`~PyTypeObject.tp_new` (one "
"that calls a base type's :c:member:`~PyTypeObject.tp_new` or :meth:"
"`__new__`), you must *not* try to determine what method to call using method "
"resolution order at runtime.  Always statically determine what type you are "
"going to call, and call its :c:member:`~PyTypeObject.tp_new` directly, or "
"via ``type->tp_base->tp_new``.  If you do not do this, Python subclasses of "
"your type that also inherit from other Python-defined classes may not work "
"correctly. (Specifically, you may not be able to create instances of such "
"subclasses without getting a :exc:`TypeError`.)"
msgstr ""
"もし協力的な :c:member:`~PyTypeObject.tp_new` (基底タイプの :c:member:"
"`~PyTypeObject.tp_new` または :meth:`__new__` を呼んでいるもの) を作りたいの"
"ならば、実行時のメソッド解決順序をつかってどのメソッドを呼びだすかを決定しよ"
"うとしては *いけません* 。つねに呼び出す型を静的に決めておき、直接その :c:"
"member:`~PyTypeObject.tp_new` を呼び出すか、あるいは ``type->tp_base-"
">tp_new`` を経由してください。こうしないと、あなたが作成したタイプの Python "
"サブクラスが他の Python で定義されたクラスも継承している場合にうまく動かない"
"場合があります。 (とりわけ、そのようなサブクラスのインスタンスを :exc:"
"`TypeError` を出さずに作ることが不可能になります。)"

#: ../../extending/newtypes.rst:358
msgid "We provide an initialization function::"
msgstr "つぎに初期化用の関数を見てみましょう::"

#: ../../extending/newtypes.rst:389
msgid "by filling the :c:member:`~PyTypeObject.tp_init` slot. ::"
msgstr "これは :c:member:`~PyTypeObject.tp_init` メンバに代入されます。 ::"

#: ../../extending/newtypes.rst:393
msgid ""
"The :c:member:`~PyTypeObject.tp_init` slot is exposed in Python as the :meth:"
"`__init__` method. It is used to initialize an object after it's created. "
"Unlike the new method, we can't guarantee that the initializer is called.  "
"The initializer isn't called when unpickling objects and it can be "
"overridden.  Our initializer accepts arguments to provide initial values for "
"our instance. Initializers always accept positional and keyword arguments."
msgstr ""
"Python では、 :c:member:`~PyTypeObject.tp_init` メンバは :meth:`__init__` メ"
"ソッドとして見えています。このメソッドは、オブジェクトが作成されたあとに、そ"
"れを初期化する目的で使われます。 new メソッドとはちがって、初期化用のメソッド"
"は必ず呼ばれるとは限りません。初期化用のメソッドは、インスタンスの初期値を提"
"供するのに必要な引数を受けとります。このメソッドはつねに固定引数とキーワード"
"引数を受けとります。"

#: ../../extending/newtypes.rst:400
msgid ""
"Initializers can be called multiple times.  Anyone can call the :meth:"
"`__init__` method on our objects.  For this reason, we have to be extra "
"careful when assigning the new values.  We might be tempted, for example to "
"assign the :attr:`first` member like this::"
msgstr ""
"初期化メソッドは複数回呼び出される可能性があります。あなたのオブジェクトの :"
"meth:`__init__` メソッドは、誰にでも呼び出すことができるからです。このため、"
"新しい値を代入するさいには特別な注意を払う必要があります。たとえば、 :attr:"
"`first` メンバには以下のように代入したくなるかもしれません::"

#: ../../extending/newtypes.rst:411
msgid ""
"But this would be risky.  Our type doesn't restrict the type of the :attr:"
"`first` member, so it could be any kind of object.  It could have a "
"destructor that causes code to be executed that tries to access the :attr:"
"`first` member.  To be paranoid and protect ourselves against this "
"possibility, we almost always reassign members before decrementing their "
"reference counts.  When don't we have to do this?"
msgstr ""
"しかしこのやり方は危険です。このタイプでは :attr:`first` メンバに入るオブジェ"
"クトをなにも限定していないので、どんなオブジェクトでもとり得てしまうからで"
"す。それはこのコードが :attr:`first` メンバにアクセスしようとする前に、そのデ"
"ストラクタが呼び出されてしまうかもしれないのです。このような可能性からパラノ"
"イア的に身をまもるため、ほとんどの場合メンバへの代入は,その参照カウントを減ら"
"す前におこなってください。こうする必要がないのはどんな場合でしょうか?"

#: ../../extending/newtypes.rst:418
msgid "when we absolutely know that the reference count is greater than 1"
msgstr "その参照カウントが 1 より大きいと確信できる場合。"

#: ../../extending/newtypes.rst:420
msgid ""
"when we know that deallocation of the object [#]_ will not cause any calls "
"back into our type's code"
msgstr ""
"そのオブジェクトの解放があなたのタイプのコードにコールバックするようなことが"
"決してない場合 [#]_ 。"

#: ../../extending/newtypes.rst:423
msgid ""
"when decrementing a reference count in a :c:member:`~PyTypeObject."
"tp_dealloc` handler when garbage-collections is not supported [#]_"
msgstr ""
"ガベージコレクションがサポートされていない場合に :c:member:`~PyTypeObject."
"tp_dealloc` ハンドラで参照カウントを減らすとき [#]_ 。"

#: ../../extending/newtypes.rst:426
msgid ""
"We want to expose our instance variables as attributes. There are a number "
"of ways to do that. The simplest way is to define member definitions::"
msgstr ""
"ここではインスタンス変数を属性として見えるようにしたいのですが、これにはいく"
"つもの方法があります。もっとも簡単な方法は、メンバの定義を与えることです::"

#: ../../extending/newtypes.rst:439
msgid ""
"and put the definitions in the :c:member:`~PyTypeObject.tp_members` slot::"
msgstr ""
"そして、この定義を :c:member:`~PyTypeObject.tp_members` スロットに入れましょ"
"う::"

#: ../../extending/newtypes.rst:443
msgid ""
"Each member definition has a member name, type, offset, access flags and "
"documentation string. See the :ref:`Generic-Attribute-Management` section "
"below for details."
msgstr ""
"各メンバの定義はそれぞれ、メンバの名前、型、オフセット、アクセスフラグおよび "
"docstring です。詳しくは後の \"総称的な属性を管理する\" (:ref:`Generic-"
"Attribute-Management`) の節をご覧ください。"

#: ../../extending/newtypes.rst:447
msgid ""
"A disadvantage of this approach is that it doesn't provide a way to restrict "
"the types of objects that can be assigned to the Python attributes.  We "
"expect the first and last names to be strings, but any Python objects can be "
"assigned. Further, the attributes can be deleted, setting the C pointers to "
"*NULL*.  Even though we can make sure the members are initialized to non-"
"*NULL* values, the members can be set to *NULL* if the attributes are "
"deleted."
msgstr ""
"この方法の欠点は、Python 属性に代入できるオブジェクトの型を制限する方法がない"
"ことです。ここではファーストネーム first とラストネーム last に、ともに文字列"
"が入るよう期待していますが、今のやり方ではどんな Python オブジェクトも代入で"
"きてしまいます。加えてこの属性は削除 (del) できてしまい、その場合、 C のポイ"
"ンタには *NULL* が設定されます。たとえもしメンバが *NULL* 以外の値に初期化さ"
"れるようにしてあったとしても、属性が削除されればメンバは *NULL* になってしま"
"います。"

#: ../../extending/newtypes.rst:454
msgid ""
"We define a single method, :meth:`name`, that outputs the objects name as "
"the concatenation of the first and last names. ::"
msgstr ""
"ここでは :meth:`name` と呼ばれるメソッドを定義しましょう。これはファースト"
"ネーム first とラストネーム last を連結した文字列をそのオブジェクトの名前とし"
"て返します。 ::"

#: ../../extending/newtypes.rst:489
msgid ""
"The method is implemented as a C function that takes a :class:`Noddy` (or :"
"class:`Noddy` subclass) instance as the first argument.  Methods always take "
"an instance as the first argument. Methods often take positional and keyword "
"arguments as well, but in this case we don't take any and don't need to "
"accept a positional argument tuple or keyword argument dictionary. This "
"method is equivalent to the Python method::"
msgstr ""
"このメソッドは C 関数として実装され、 :class:`Noddy` (あるいは   :class:"
"`Noddy` のサブクラス) のインスタンスを第一引数として受けとります。メソッドは"
"つねにそのインスタンスを最初の引数として受けとらなければなりません。しばしば"
"固定引数とキーワード引数も受けとりますが、今回はなにも必要ないので、固定引数"
"のタプルもキーワード引数の辞書も取らないことにします。このメソッドは Python "
"の以下のメソッドと等価です::"

#: ../../extending/newtypes.rst:499
msgid ""
"Note that we have to check for the possibility that our :attr:`first` and :"
"attr:`last` members are *NULL*.  This is because they can be deleted, in "
"which case they are set to *NULL*.  It would be better to prevent deletion "
"of these attributes and to restrict the attribute values to be strings.  "
"We'll see how to do that in the next section."
msgstr ""
":attr:`first` メンバと :attr:`last` メンバがそれぞれ *NULL* かどうかチェック"
"しなければならないことに注意してください。これらは削除される可能性があり、そ"
"の場合値は *NULL* にセットされます。この属性の削除を禁止して、そこに入れられ"
"る値を文字列に限定できればなおいいでしょう。次の節ではこれについて扱います。"

#: ../../extending/newtypes.rst:505
msgid ""
"Now that we've defined the method, we need to create an array of method "
"definitions::"
msgstr ""
"さて、メソッドを定義したので、ここでメソッド定義用の配列を作成する必要があり"
"ます::"

#: ../../extending/newtypes.rst:515
msgid "and assign them to the :c:member:`~PyTypeObject.tp_methods` slot::"
msgstr "これを :c:member:`~PyTypeObject.tp_methods` スロットに入れましょう::"

#: ../../extending/newtypes.rst:519
msgid ""
"Note that we used the :const:`METH_NOARGS` flag to indicate that the method "
"is passed no arguments."
msgstr ""
"ここでの :const:`METH_NOARGS` フラグは、そのメソッドが引数を取らないことを宣"
"言するのに使われています。"

#: ../../extending/newtypes.rst:522
msgid ""
"Finally, we'll make our type usable as a base class.  We've written our "
"methods carefully so far so that they don't make any assumptions about the "
"type of the object being created or used, so all we need to do is to add "
"the :const:`Py_TPFLAGS_BASETYPE` to our class flag definition::"
msgstr ""
"最後に、この型を基底クラスとして利用可能にしましょう。上のメソッドは注意ぶか"
"く書かれているので、これはそのオブジェクトの型が作成されたり利用される場合に"
"ついてどんな仮定も置いていません。なので、ここですべきことは :const:"
"`Py_TPFLAGS_BASETYPE` をクラス定義のフラグに加えるだけです::"

#: ../../extending/newtypes.rst:529
msgid ""
"We rename :c:func:`initnoddy` to :c:func:`initnoddy2` and update the module "
"name passed to :c:func:`Py_InitModule3`."
msgstr ""
":c:func:`initnoddy` の名前を :c:func:`initnoddy2` に変更し、 :c:func:"
"`Py_InitModule3` に渡されるモジュール名を更新します。"

#: ../../extending/newtypes.rst:532
msgid "Finally, we update our :file:`setup.py` file to build the new module::"
msgstr ""
"さいごに :file:`setup.py` ファイルを更新して新しいモジュールをビルドします::"

#: ../../extending/newtypes.rst:543
msgid "Providing finer control over data attributes"
msgstr "データ属性をこまかく制御する"

#: ../../extending/newtypes.rst:545
msgid ""
"In this section, we'll provide finer control over how the :attr:`first` and :"
"attr:`last` attributes are set in the :class:`Noddy` example. In the "
"previous version of our module, the instance variables :attr:`first` and :"
"attr:`last` could be set to non-string values or even deleted. We want to "
"make sure that these attributes always contain strings."
msgstr ""
"この節では、 :class:`Noddy` クラスの例にあった :attr:`first` と :attr:`last` "
"の各属性にたいして、より精密な制御を提供します。以前のバージョンのモジュール"
"では、インスタンス変数の :attr:`first` と :attr:`last` には文字列以外のものも"
"代入できてしまい、あまつさえ削除まで可能でした。ここではこれらの属性が必ず文"
"字列を保持しているようにしましょう。"

#: ../../extending/newtypes.rst:554
msgid ""
"To provide greater control, over the :attr:`first` and :attr:`last` "
"attributes, we'll use custom getter and setter functions.  Here are the "
"functions for getting and setting the :attr:`first` attribute::"
msgstr ""
":attr:`first` 属性と :attr:`last` 属性をよりこまかく制御するためには、カスタ"
"ムメイドの getter 関数と setter 関数を使います。以下は :attr:`first` 属性から"
"値を取得する関数 (getter) と、この属性に値を格納する関数 (setter) です::"

#: ../../extending/newtypes.rst:585
msgid ""
"The getter function is passed a :class:`Noddy` object and a \"closure\", "
"which is void pointer. In this case, the closure is ignored. (The closure "
"supports an advanced usage in which definition data is passed to the getter "
"and setter. This could, for example, be used to allow a single set of getter "
"and setter functions that decide the attribute to get or set based on data "
"in the closure.)"
msgstr ""
"getter 関数には :class:`Noddy` オブジェクトと「閉包 (closure)」 (これは void"
"型のポインタです) が渡されます。今回のケースでは閉包は無視します。 (閉包とは"
"定義データが渡される setter や getter の高度な利用をサポートするためのもの"
"で、これを使うとたとえば getter と setter をひとまとめにした関数に、閉包の"
"データにもとづいて属性を get するか set するか決めさせる、といったことができ"
"ます。)"

#: ../../extending/newtypes.rst:591
msgid ""
"The setter function is passed the :class:`Noddy` object, the new value, and "
"the closure. The new value may be *NULL*, in which case the attribute is "
"being deleted.  In our setter, we raise an error if the attribute is deleted "
"or if the attribute value is not a string."
msgstr ""
"setter 関数には :class:`Noddy` オブジェクトと新しい値、そして閉包が渡されま"
"す。新しい値は *NULL* かもしれず、その場合はこの属性が削除されます。ここでは"
"属性が削除されたり、その値が文字列でないときにはエラーを発生させるようにしま"
"す。"

#: ../../extending/newtypes.rst:596
msgid "We create an array of :c:type:`PyGetSetDef` structures::"
msgstr "ここでは :c:type:`PyGetSetDef` 構造体の配列をつくります::"

#: ../../extending/newtypes.rst:610
msgid "and register it in the :c:member:`~PyTypeObject.tp_getset` slot::"
msgstr ""
"そしてこれを :c:member:`~PyTypeObject.tp_getset` スロットに登録します::"

#: ../../extending/newtypes.rst:614
msgid "to register our attribute getters and setters."
msgstr "これで属性の getter と setter が登録できました。"

#: ../../extending/newtypes.rst:616
msgid ""
"The last item in a :c:type:`PyGetSetDef` structure is the closure mentioned "
"above. In this case, we aren't using the closure, so we just pass *NULL*."
msgstr ""
":c:type:`PyGetSetDef` 構造体の最後の要素が上で説明した閉包です。今回は閉包は"
"使わないので *NULL* を渡しています。"

#: ../../extending/newtypes.rst:619
msgid "We also remove the member definitions for these attributes::"
msgstr "また、メンバ定義からはこれらの属性を除いておきましょう::"

#: ../../extending/newtypes.rst:627
msgid ""
"We also need to update the :c:member:`~PyTypeObject.tp_init` handler to only "
"allow strings [#]_ to be passed::"
msgstr ""
"また、ここでは :c:member:`~PyTypeObject.tp_init` ハンドラも渡されるものとして"
"文字列のみを許可するように修正する必要があります [#]_::"

#: ../../extending/newtypes.rst:659
msgid ""
"With these changes, we can assure that the :attr:`first` and :attr:`last` "
"members are never *NULL* so we can remove checks for *NULL* values in almost "
"all cases. This means that most of the :c:func:`Py_XDECREF` calls can be "
"converted to :c:func:`Py_DECREF` calls. The only place we can't change these "
"calls is in the deallocator, where there is the possibility that the "
"initialization of these members failed in the constructor."
msgstr ""
"これらの変更によって、 :attr:`first` メンバと :attr:`last` メンバが決して "
"*NULL* にならないと保証できました。これでほとんどすべてのケースから *NULL* 値"
"のチェックを除けます。これは :c:func:`Py_XDECREF` 呼び出しを :c:func:"
"`Py_DECREF` 呼び出しに変えられることを意味します。唯一これを変えられないのは"
"オブジェクト解放メソッド (deallocator) で、なぜならここではコンストラクタによ"
"るメンバ初期化が失敗している可能性があるからです。"

#: ../../extending/newtypes.rst:666
msgid ""
"We also rename the module initialization function and module name in the "
"initialization function, as we did before, and we add an extra definition to "
"the :file:`setup.py` file."
msgstr ""
"さて、先ほどもしたように、このモジュール初期化関数と初期化関数内にあるモ"
"ジュール名を変更しましょう。そして :file:`setup.py` ファイルに追加の定義をく"
"わえます。"

#: ../../extending/newtypes.rst:672
msgid "Supporting cyclic garbage collection"
msgstr "循環ガベージコレクションをサポートする"

#: ../../extending/newtypes.rst:674
msgid ""
"Python has a cyclic-garbage collector that can identify unneeded objects "
"even when their reference counts are not zero. This can happen when objects "
"are involved in cycles.  For example, consider::"
msgstr ""
"Python は循環ガベージコレクション機能をもっており、これは不要なオブジェクト"
"を、たとえ参照カウントがゼロでなくても、発見することができます。これはオブ"
"ジェクトの参照が循環しているときに起こりえます。たとえば以下の例を考えてくだ"
"さい::"

#: ../../extending/newtypes.rst:682
msgid ""
"In this example, we create a list that contains itself. When we delete it, "
"it still has a reference from itself. Its reference count doesn't drop to "
"zero. Fortunately, Python's cyclic-garbage collector will eventually figure "
"out that the list is garbage and free it."
msgstr ""
"この例では、自分自身をふくむリストをつくりました。たとえこのリストを del して"
"も、それは自分自身への参照をまだ持ちつづけますから、参照カウントはゼロにはな"
"りません。嬉しいことに Python には循環ガベージコレクション機能がありますか"
"ら、最終的にはこのリストが不要であることを検出し、解放できます。"

#: ../../extending/newtypes.rst:687
msgid ""
"In the second version of the :class:`Noddy` example, we allowed any kind of "
"object to be stored in the :attr:`first` or :attr:`last` attributes [#]_. "
"This means that :class:`Noddy` objects can participate in cycles::"
msgstr ""

#: ../../extending/newtypes.rst:696
msgid ""
"This is pretty silly, but it gives us an excuse to add support for the "
"cyclic-garbage collector to the :class:`Noddy` example.  To support cyclic "
"garbage collection, types need to fill two slots and set a class flag that "
"enables these slots:"
msgstr ""
"これは実にばかげた例ですが、すくなくとも :class:`Noddy` クラスに循環ガベージ"
"コレクション機能のサポートを加える口実を与えてくれます。循環ガベージコレク"
"ションをサポートするには 2つのタイプスロットを埋め、これらのスロットを許可す"
"るようにクラス定義のフラグを設定する必要があります:"

#: ../../extending/newtypes.rst:704
msgid ""
"The traversal method provides access to subobjects that could participate in "
"cycles::"
msgstr ""
"traversal メソッドは循環した参照に含まれる可能性のある内部オブジェクトへのア"
"クセスを提供します::"

#: ../../extending/newtypes.rst:726
msgid ""
"For each subobject that can participate in cycles, we need to call the :c:"
"func:`visit` function, which is passed to the traversal method. The :c:func:"
"`visit` function takes as arguments the subobject and the extra argument "
"*arg* passed to the traversal method.  It returns an integer value that must "
"be returned if it is non-zero."
msgstr ""
"循環した参照に含まれるかもしれない各内部オブジェクトに対して、 traversal メ"
"ソッドに渡された :c:func:`visit` 関数を呼びます。 :c:func:`visit` 関数は内部"
"オブジェクトと、traversal メソッドに渡された追加の引数 *arg* を引数としてとり"
"ます。この関数はこの値が非負の場合に返される整数の値を返します。"

#: ../../extending/newtypes.rst:732
msgid ""
"Python 2.4 and higher provide a :c:func:`Py_VISIT` macro that automates "
"calling visit functions.  With :c:func:`Py_VISIT`, :c:func:`Noddy_traverse` "
"can be simplified::"
msgstr ""
"Python 2.4 以降では、visit 関数の呼び出しを自動化する :c:func:`Py_VISIT` マク"
"ロが用意されています。 :c:func:`Py_VISIT` を使えば、 :c:func:"
"`Noddy_traverse` は次のように簡略化できます::"

#: ../../extending/newtypes.rst:746
msgid ""
"Note that the :c:member:`~PyTypeObject.tp_traverse` implementation must name "
"its arguments exactly *visit* and *arg* in order to use :c:func:`Py_VISIT`.  "
"This is to encourage uniformity across these boring implementations."
msgstr ""
"注意: :c:member:`~PyTypeObject.tp_traverse` の実装で :c:func:`Py_VISIT` を使"
"うには、その引数に正確に *visit* および *arg* という名前をつける必要がありま"
"す。これは、この退屈な実装に統一性を導入することを促進します。"

#: ../../extending/newtypes.rst:750
msgid ""
"We also need to provide a method for clearing any subobjects that can "
"participate in cycles."
msgstr ""

#: ../../extending/newtypes.rst:771
msgid ""
"Notice the use of a temporary variable in :c:func:`Noddy_clear`. We use the "
"temporary variable so that we can set each member to *NULL* before "
"decrementing its reference count.  We do this because, as was discussed "
"earlier, if the reference count drops to zero, we might cause code to run "
"that calls back into the object.  In addition, because we now support "
"garbage collection, we also have to worry about code being run that triggers "
"garbage collection.  If garbage collection is run, our :c:member:"
"`~PyTypeObject.tp_traverse` handler could get called. We can't take a chance "
"of having :c:func:`Noddy_traverse` called when a member's reference count "
"has dropped to zero and its value hasn't been set to *NULL*."
msgstr ""
":c:func:`Noddy_clear` 中での一時変数の使い方に注目してください。ここでは、一"
"時変数をつかって各メンバの参照カウントを減らす前にそれらに *NULL* を代入して"
"います。これは次のような理由によります。すでにお話ししたように、もし参照カウ"
"ントがゼロになると、このオブジェクトがコールバックされるようになってしまいま"
"す。さらに、いまやガベージコレクションをサポートしているため、ガベージコレク"
"ション時に実行されるコードについても心配しなくてはなりません。もしガベージコ"
"レクションが走っていると、あなたの :c:member:`~PyTypeObject.tp_traverse` ハン"
"ドラが呼び出される可能性があります。メンバの参照カウントがゼロになった場合"
"に、その値が *NULL* に設定されていないと :c:func:`Noddy_traverse` が呼ばれる"
"機会はありません。"

#: ../../extending/newtypes.rst:781
msgid ""
"Python 2.4 and higher provide a :c:func:`Py_CLEAR` that automates the "
"careful decrementing of reference counts.  With :c:func:`Py_CLEAR`, the :c:"
"func:`Noddy_clear` function can be simplified::"
msgstr ""
"Python 2.4 以降では、注意ぶかく参照カウントを減らすためのマクロ :c:func:"
"`Py_CLEAR` が用意されています。 :c:func:`Py_CLEAR` を使えば、 :c:func:"
"`Noddy_clear` は次のように簡略化できます::"

#: ../../extending/newtypes.rst:793
msgid ""
"Note that :c:func:`Noddy_dealloc` may call arbitrary functions through "
"``__del__`` method or weakref callback. It means circular GC can be "
"triggered inside the function.  Since GC assumes reference count is not "
"zero, we need to untrack the object from GC by calling :c:func:"
"`PyObject_GC_UnTrack` before clearing members. Here is reimplemented "
"deallocator which uses :c:func:`PyObject_GC_UnTrack` and :c:func:"
"`Noddy_clear`."
msgstr ""

#: ../../extending/newtypes.rst:810
msgid ""
"Finally, we add the :const:`Py_TPFLAGS_HAVE_GC` flag to the class flags::"
msgstr ""
"最後に、 :const:`Py_TPFLAGS_HAVE_GC` フラグをクラス定義のフラグに加えます::"

#: ../../extending/newtypes.rst:814
msgid ""
"That's pretty much it.  If we had written custom :c:member:`~PyTypeObject."
"tp_alloc` or :c:member:`~PyTypeObject.tp_free` slots, we'd need to modify "
"them for cyclic-garbage collection. Most extensions will use the versions "
"automatically provided."
msgstr ""
"これで完了です。 :c:member:`~PyTypeObject.tp_alloc` スロットまたは :c:member:"
"`~PyTypeObject.tp_free` スロットが書かれていれば、それらを循環ガベージコレク"
"ションに使えるよう修正すればよいのです。ほとんどの拡張機能は自動的に提供され"
"るバージョンを使うでしょう。"

#: ../../extending/newtypes.rst:820
msgid "Subclassing other types"
msgstr "他の型のサブクラスを作る"

#: ../../extending/newtypes.rst:822
msgid ""
"It is possible to create new extension types that are derived from existing "
"types. It is easiest to inherit from the built in types, since an extension "
"can easily use the :class:`PyTypeObject` it needs. It can be difficult to "
"share these :class:`PyTypeObject` structures between extension modules."
msgstr ""
"既存の型を継承した新しい拡張型を作成することができます。組み込み型から継承す"
"るのは特に簡単です。必要な :class:`PyTypeObject` を簡単に利用できるからです。"
"それに比べて、 :class:`PyTypeObject` 構造体を拡張モジュール間で共有するのは難"
"しいです。"

#: ../../extending/newtypes.rst:827
msgid ""
"In this example we will create a :class:`Shoddy` type that inherits from the "
"built-in :class:`list` type. The new type will be completely compatible with "
"regular lists, but will have an additional :meth:`increment` method that "
"increases an internal counter. ::"
msgstr ""
"次の例では、ビルトインの :class:`list` 型を継承した :class:`Shoddy` 型を作成"
"しています。新しい型は通常のリスト型と完全に互換性がありますが、追加で内部の"
"カウンタを増やす :meth:`increment` メソッドを持っています。 ::"

#: ../../extending/newtypes.rst:845
msgid ""
"As you can see, the source code closely resembles the :class:`Noddy` "
"examples in previous sections. We will break down the main differences "
"between them. ::"
msgstr ""
"見てわかるように、ソースコードは前の節の :class:`Noddy` の時と非常に似ていま"
"す。違う部分をそれぞれを見ていきます。 ::"

#: ../../extending/newtypes.rst:853
msgid ""
"The primary difference for derived type objects is that the base type's "
"object structure must be the first value. The base type will already include "
"the :c:func:`PyObject_HEAD` at the beginning of its structure."
msgstr ""
"継承した型のオブジェクトの最初の違いは、親クラスのオブジェクト構造が最初に必"
"要なことです。基底型が既に :c:func:`PyObject_HEAD` を構造体の先頭に持っていま"
"す。"

#: ../../extending/newtypes.rst:857
msgid ""
"When a Python object is a :class:`Shoddy` instance, its *PyObject\\** "
"pointer can be safely cast to both *PyListObject\\** and *Shoddy\\**. ::"
msgstr ""
"Python オブジェクトが :class:`Shoddy` 型のインスタンスだった場合、その "
"*PyObject\\** ポインタは *PyListObject\\** にも *Shoddy\\** にも安全にキャス"
"トできます。 ::"

#: ../../extending/newtypes.rst:869
msgid ""
"In the :attr:`__init__` method for our type, we can see how to call through "
"to the :attr:`__init__` method of the base type."
msgstr ""
"この新しい型の :attr:`__init__` メソッドで、基底型の :attr:`__init__` メソッ"
"ドを呼び出している様子を見ることができます。"

#: ../../extending/newtypes.rst:872
msgid ""
"This pattern is important when writing a type with custom :attr:`new` and :"
"attr:`dealloc` methods. The :attr:`new` method should not actually create "
"the memory for the object with :c:member:`~PyTypeObject.tp_alloc`, that will "
"be handled by the base class when calling its :c:member:`~PyTypeObject."
"tp_new`."
msgstr ""
"このパターンは、カスタムの :attr:`new` と :attr:`dealloc` メソッドを実装する"
"ときには重要です。継承した型の :attr:`new` メソッドは、 :c:member:"
"`~PyTypeObject.tp_alloc` を使ってメモリを割り当てるべきではありません。それは"
"基底型の :c:member:`~PyTypeObject.tp_new` を呼出たときに処理されるからです。"

#: ../../extending/newtypes.rst:877
msgid ""
"When filling out the :c:func:`PyTypeObject` for the :class:`Shoddy` type, "
"you see a slot for :c:func:`tp_base`. Due to cross platform compiler issues, "
"you can't fill that field directly with the :c:func:`PyList_Type`; it can be "
"done later in the module's :c:func:`init` function. ::"
msgstr ""
":class:`Shoddy` 型のために :c:func:`PyTypeObject` を埋めるとき、 :c:func:"
"`tp_base` スロットを見つけることができます。クロスプラットフォームのコンパイ"
"ラに対応するために、直接そのスロットを :c:func:`PyList_Type` で埋めてはいけま"
"せん。代わりに、後でモジュールの :c:func:`init` 関数の中で行うことができま"
"す。 ::"

#: ../../extending/newtypes.rst:899
msgid ""
"Before calling :c:func:`PyType_Ready`, the type structure must have the :c:"
"member:`~PyTypeObject.tp_base` slot filled in. When we are deriving a new "
"type, it is not necessary to fill out the :c:member:`~PyTypeObject.tp_alloc` "
"slot with :c:func:`PyType_GenericNew` -- the allocate function from the base "
"type will be inherited."
msgstr ""
":c:func:`PyType_Read` を呼ぶ前に、型の構造は :c:member:`~PyTypeObject."
"tp_base` スロットは埋められていなければなりません。継承している新しい型を作る"
"とき、 :c:member:`~PyTypeObject.tp_alloc` スロットを :c:func:"
"`PyType_GenericNew` で埋める必要はありません。 -- 基底型のアロケート関数が継"
"承されます。"

#: ../../extending/newtypes.rst:904
msgid ""
"After that, calling :c:func:`PyType_Ready` and adding the type object to the "
"module is the same as with the basic :class:`Noddy` examples."
msgstr ""
"この後は、 :c:func:`PyType_Ready` 関数を呼び、タイプオブジェクトをモジュール"
"へ追加するのは、基本的な :class:`Noddy` の例と同じです。"

#: ../../extending/newtypes.rst:911
msgid "Type Methods"
msgstr "タイプメソッド"

#: ../../extending/newtypes.rst:913
msgid ""
"This section aims to give a quick fly-by on the various type methods you can "
"implement and what they do."
msgstr ""
"この節ではさまざまな実装可能なタイプメソッドと、それらが何をするものであるか"
"について、ざっと説明します。"

#: ../../extending/newtypes.rst:916
msgid ""
"Here is the definition of :c:type:`PyTypeObject`, with some fields only used "
"in debug builds omitted:"
msgstr ""
"以下は :c:type:`PyTypeObject` の定義です。デバッグビルドでしか使われないいく"
"つかのメンバは省いてあります:"

#: ../../extending/newtypes.rst:922
msgid ""
"Now that's a *lot* of methods.  Don't worry too much though - if you have a "
"type you want to define, the chances are very good that you will only "
"implement a handful of these."
msgstr ""
"*たくさんの* メソッドがありますね。でもそんなに心配する必要はありません。定義"
"したい型があるなら、実装するのはこのうちのごくわずかですむことがほとんどで"
"す。"

#: ../../extending/newtypes.rst:926
msgid ""
"As you probably expect by now, we're going to go over this and give more "
"information about the various handlers.  We won't go in the order they are "
"defined in the structure, because there is a lot of historical baggage that "
"impacts the ordering of the fields; be sure your type initialization keeps "
"the fields in the right order!  It's often easiest to find an example that "
"includes all the fields you need (even if they're initialized to ``0``) and "
"then change the values to suit your new type. ::"
msgstr ""
"すでに予想されているでしょうが、これらの多様なハンドラについて、これからより"
"詳しい情報を提供します。しかしこれらのメンバが構造体中で定義されている順番は"
"無視します。というのは、これらのメンバの現れる順序は歴史的な遺産によるものだ"
"からです。型を初期化するさいに、これらのメンバを正しい順序で並べるよう、くれ"
"ぐれも注意してください。ふつういちばん簡単なのは、必要なメンバがすべて含まれ"
"ている (たとえそれらが ``0`` に初期化されていても) 例をとってきて、自分の型に"
"合わせるよう変更をくわえることです。 ::"

#: ../../extending/newtypes.rst:936
msgid ""
"The name of the type - as mentioned in the last section, this will appear in "
"various places, almost entirely for diagnostic purposes. Try to choose "
"something that will be helpful in such a situation! ::"
msgstr ""
"これは型の名前です。前節で説明したように、これはいろいろな場面で現れ、ほとん"
"どは診断用の目的で使われるものです。なので、そのような場面で役に立つであろう"
"名前を選んでください! ::"

#: ../../extending/newtypes.rst:942
msgid ""
"These fields tell the runtime how much memory to allocate when new objects "
"of this type are created.  Python has some built-in support for variable "
"length structures (think: strings, lists) which is where the :c:member:"
"`~PyTypeObject.tp_itemsize` field comes in.  This will be dealt with "
"later. ::"
msgstr ""
"これらのメンバは、この型のオブジェクトが作成されるときにどれだけのメモリを割"
"り当てればよいのかをランタイムに指示します。Python には可変長の構造体 (文字列"
"やリストなどを想像してください) に対する組み込みのサポートがある程度あり、こ"
"こで :c:member:`~PyTypeObject.tp_itemsize` メンバが使われます。これらについて"
"はあとでふれます。 ::"

#: ../../extending/newtypes.rst:949
msgid ""
"Here you can put a string (or its address) that you want returned when the "
"Python script references ``obj.__doc__`` to retrieve the doc string."
msgstr ""
"ここには Python スクリプトリファレンス ``obj.__doc__`` が doc string を返すと"
"きの文字列 (あるいはそのアドレス) を入れます。"

#: ../../extending/newtypes.rst:952
msgid ""
"Now we come to the basic type methods---the ones most extension types will "
"implement."
msgstr ""
"では次に、ほとんどの拡張型が実装するであろう基本的なタイプメソッドに入ってい"
"きます。"

#: ../../extending/newtypes.rst:957
msgid "Finalization and De-allocation"
msgstr "ファイナライズとメモリ解放"

#: ../../extending/newtypes.rst:969
msgid ""
"This function is called when the reference count of the instance of your "
"type is reduced to zero and the Python interpreter wants to reclaim it.  If "
"your type has memory to free or other clean-up to perform, you can put it "
"here.  The object itself needs to be freed here as well.  Here is an example "
"of this function::"
msgstr ""
"型のインスタンスの参照カウントがゼロになり、Python インタプリタがそれを潰して"
"再利用したくなると、この関数が呼ばれます。解放すべきメモリをその型が保持して"
"いたり、それ以外にも実行すべき後処理がある場合は、それらをここに入れられま"
"す。オブジェクトそれ自体もここで解放される必要があります。この関数の例は、以"
"下のようなものです::"

#: ../../extending/newtypes.rst:986
msgid ""
"One important requirement of the deallocator function is that it leaves any "
"pending exceptions alone.  This is important since deallocators are "
"frequently called as the interpreter unwinds the Python stack; when the "
"stack is unwound due to an exception (rather than normal returns), nothing "
"is done to protect the deallocators from seeing that an exception has "
"already been set.  Any actions which a deallocator performs which may cause "
"additional Python code to be executed may detect that an exception has been "
"set.  This can lead to misleading errors from the interpreter.  The proper "
"way to protect against this is to save a pending exception before performing "
"the unsafe action, and restoring it when done.  This can be done using the :"
"c:func:`PyErr_Fetch` and :c:func:`PyErr_Restore` functions::"
msgstr ""
"解放用関数でひとつ重要なのは、処理待ちの例外にいっさい手をつけないことです。"
"なぜなら、解放用の関数は Python インタプリタがスタックを元の状態に戻すときに"
"呼ばれることが多いからです。そして (通常の関数からの復帰でなく) 例外のために"
"スタックが巻き戻されるときは、すでに発生している例外から解放用関数を守るもの"
"はありません。解放用の関数がおこなう動作が追加の Python のコードを実行してし"
"まうと、それらは例外が発生していることを検知するかもしれません。これはインタ"
"プリタが誤解させるエラーを発生させることにつながります。これを防ぐ正しい方法"
"は、安全でない操作を実行する前に処理待ちの例外を保存しておき、終わったらそれ"
"を元に戻すことです。これは :c:func:`PyErr_Fetch` および :c:func:"
"`PyErr_Restore` 関数を使うことによって可能になります::"

#: ../../extending/newtypes.rst:1027
msgid "Object Presentation"
msgstr "オブジェクト表現"

#: ../../extending/newtypes.rst:1033
msgid ""
"In Python, there are three ways to generate a textual representation of an "
"object: the :func:`repr` function (or equivalent back-tick syntax), the :"
"func:`str` function, and the :keyword:`print` statement.  For most objects, "
"the :keyword:`print` statement is equivalent to the :func:`str` function, "
"but it is possible to special-case printing to a :c:type:`FILE\\*` if "
"necessary; this should only be done if efficiency is identified as a problem "
"and profiling suggests that creating a temporary string object to be written "
"to a file is too expensive."
msgstr ""
"Python では、オブジェクトの文字列表現を生成するのに 3つのやり方があります: :"
"func:`repr` 関数 (あるいはそれと等価なバッククォートを用いた表現) を使う方"
"法、 :func:`str` 関数を使う方法、そして :keyword:`print` 文を使う方法です。ほ"
"とんどのオブジェクトで :keyword:`print` 文は :func:`str` 関数と同じですが、必"
"要な場合には特殊なケースとして :c:type:`FILE\\*` にも表示できます。 :c:type:"
"`FILE\\*` への表示は、効率が問題となっている場合で、一時的な文字列オブジェク"
"トを作成してファイルに書き込むのでは効率が悪すぎることがプロファイリングから"
"も明らかな場合にのみ使うべきです。"

#: ../../extending/newtypes.rst:1042
msgid ""
"These handlers are all optional, and most types at most need to implement "
"the :c:member:`~PyTypeObject.tp_str` and :c:member:`~PyTypeObject.tp_repr` "
"handlers. ::"
msgstr ""
"これらのハンドラはどれも必須ではありません。ほとんどの型ではせいぜい :c:"
"member:`~PyTypeObject.tp_str` ハンドラと :c:member:`~PyTypeObject.tp_repr` ハ"
"ンドラを実装するだけですみます。 ::"

#: ../../extending/newtypes.rst:1049
msgid ""
"The :c:member:`~PyTypeObject.tp_repr` handler should return a string object "
"containing a representation of the instance for which it is called.  Here is "
"a simple example::"
msgstr ""
":c:member:`~PyTypeObject.tp_repr` ハンドラは呼び出されたインスタンスの文字列"
"表現を格納した文字列オブジェクトを返す必要があります。簡単な例は以下のような"
"ものです::"

#: ../../extending/newtypes.rst:1060
msgid ""
"If no :c:member:`~PyTypeObject.tp_repr` handler is specified, the "
"interpreter will supply a representation that uses the type's :c:member:"
"`~PyTypeObject.tp_name` and a uniquely-identifying value for the object."
msgstr ""
":c:member:`~PyTypeObject.tp_repr` ハンドラが指定されていなければ、インタプリ"
"タはその型の :c:member:`~PyTypeObject.tp_name` とそのオブジェクトの一意な識別"
"値をもちいて文字列表現を作成します。"

#: ../../extending/newtypes.rst:1064
msgid ""
"The :c:member:`~PyTypeObject.tp_str` handler is to :func:`str` what the :c:"
"member:`~PyTypeObject.tp_repr` handler described above is to :func:`repr`; "
"that is, it is called when Python code calls :func:`str` on an instance of "
"your object.  Its implementation is very similar to the :c:member:"
"`~PyTypeObject.tp_repr` function, but the resulting string is intended for "
"human consumption.  If :c:member:`~PyTypeObject.tp_str` is not specified, "
"the :c:member:`~PyTypeObject.tp_repr` handler is used instead."
msgstr ""
":c:member:`~PyTypeObject.tp_str` ハンドラと :func:`str` の関係は、上の :c:"
"member:`~PyTypeObject.tp_repr` ハンドラと :func:`repr` の関係に相当します。つ"
"まり、これは Python のコードがオブジェクトのインスタンスに対して :func:`str` "
"を呼び出したときに呼ばれます。この関数の実装は :c:member:`~PyTypeObject."
"tp_repr` ハンドラのそれと非常に似ていますが、得られる文字列表現は人間が読むこ"
"とを意図されています。 :c:member:`~PyTypeObject.tp_str` が指定されていない場"
"合、かわりに :c:member:`~PyTypeObject.tp_repr` ハンドラが使われます。"

#: ../../extending/newtypes.rst:1071
msgid "Here is a simple example::"
msgstr "以下は簡単な例です::"

#: ../../extending/newtypes.rst:1080
msgid ""
"The print function will be called whenever Python needs to \"print\" an "
"instance of the type.  For example, if 'node' is an instance of type "
"TreeNode, then the print function is called when Python code calls::"
msgstr ""
"print ハンドラは Python がその型のインスタンスを「print する」必要のあるとき"
"に毎回呼ばれます。たとえば 'node' が TreeNode 型のインスタンスだとすると、"
"print ハンドラは Python が以下を実行したときに呼ばれます::"

#: ../../extending/newtypes.rst:1086
msgid ""
"There is a flags argument and one flag, :const:`Py_PRINT_RAW`, and it "
"suggests that you print without string quotes and possibly without "
"interpreting escape sequences."
msgstr ""
"flags 引数には :const:`Py_PRINT_RAW` というフラグがあり、これはその文字列を"
"クォートやおそらくはエスケープシーケンスの解釈もなしで表示することを指示しま"
"す。"

#: ../../extending/newtypes.rst:1090
msgid ""
"The print function receives a file object as an argument. You will likely "
"want to write to that file object."
msgstr ""
"この print 関数は :c:type:`FILE\\*` オブジェクトを引数としてとります。たぶ"
"ん、ここに出力することになるでしょう。"

#: ../../extending/newtypes.rst:1093
msgid "Here is a sample print function::"
msgstr "print 関数の例は以下のようになります::"

#: ../../extending/newtypes.rst:1111
msgid "Attribute Management"
msgstr "属性を管理する"

#: ../../extending/newtypes.rst:1113
msgid ""
"For every object which can support attributes, the corresponding type must "
"provide the functions that control how the attributes are resolved.  There "
"needs to be a function which can retrieve attributes (if any are defined), "
"and another to set attributes (if setting attributes is allowed).  Removing "
"an attribute is a special case, for which the new value passed to the "
"handler is *NULL*."
msgstr ""
"属性をもつどのオブジェクトに対しても、その型は、それらオブジェクトの属性をど"
"のように解決するか制御する関数を提供する必要があります。必要な関数としては、"
"属性を (それが定義されていれば) 取り出すものと、もうひとつは属性に (それが許"
"可されていれば) 値を設定するものです。属性を削除するのは特殊なケースで、この"
"場合は新しい値としてハンドラに *NULL* が渡されます。"

#: ../../extending/newtypes.rst:1119
msgid ""
"Python supports two pairs of attribute handlers; a type that supports "
"attributes only needs to implement the functions for one pair.  The "
"difference is that one pair takes the name of the attribute as a :c:type:"
"`char\\*`, while the other accepts a :c:type:`PyObject\\*`.  Each type can "
"use whichever pair makes more sense for the implementation's convenience. ::"
msgstr ""
"Python は 2つの属性ハンドラの組をサポートしています。属性をもつ型はどちらか一"
"組を実装するだけでよく、それらの違いは一方の組が属性の名前を :c:type:"
"`char\\*` として受け取るのに対してもう一方の組は属性の名前を :c:type:"
"`PyObject\\*` として受け取る、というものです。それぞれの型はその実装にとって"
"都合がよい方を使えます。 ::"

#: ../../extending/newtypes.rst:1131
msgid ""
"If accessing attributes of an object is always a simple operation (this will "
"be explained shortly), there are generic implementations which can be used "
"to provide the :c:type:`PyObject\\*` version of the attribute management "
"functions. The actual need for type-specific attribute handlers almost "
"completely disappeared starting with Python 2.2, though there are many "
"examples which have not been updated to use some of the new generic "
"mechanism that is available."
msgstr ""
"オブジェクトの属性へのアクセスがつねに (すぐあとで説明する) 単純な操作だけな"
"らば、 :c:type:`PyObject\\*` を使って属性を管理する関数として、総称的 "
"(generic) な実装を使えます。特定の型に特化した属性ハンドラの必要性は Python "
"2.2 からほとんど完全になくなりました。しかし、多くの例はまだ、この新しく使え"
"るようになった総称的なメカニズムを使うよう更新されてはいません。"

#: ../../extending/newtypes.rst:1142
msgid "Generic Attribute Management"
msgstr "総称的な属性を管理する"

#: ../../extending/newtypes.rst:1146
msgid ""
"Most extension types only use *simple* attributes.  So, what makes the "
"attributes simple?  There are only a couple of conditions that must be met:"
msgstr ""
"ほとんどの型は *単純な* 属性を使うだけです。では、どのような属性が単純だとい"
"えるのでしょうか? それが満たすべき条件はごくわずかです:"

#: ../../extending/newtypes.rst:1149
msgid ""
"The name of the attributes must be known when :c:func:`PyType_Ready` is "
"called."
msgstr ""
":c:func:`PyType_Ready` が呼ばれたとき、すでに属性の名前がわかっていること。"

#: ../../extending/newtypes.rst:1152
msgid ""
"No special processing is needed to record that an attribute was looked up or "
"set, nor do actions need to be taken based on the value."
msgstr ""
"属性を参照したり設定したりするときに、特別な記録のための処理が必要でなく、ま"
"た参照したり設定した値に対してどんな操作も実行する必要がないこと。"

#: ../../extending/newtypes.rst:1155
msgid ""
"Note that this list does not place any restrictions on the values of the "
"attributes, when the values are computed, or how relevant data is stored."
msgstr ""
"これらの条件は、属性の値や、値が計算されるタイミング、または格納されたデータ"
"がどの程度妥当なものであるかといったことになんら制約を課すものではないことに"
"注意してください。"

#: ../../extending/newtypes.rst:1158
msgid ""
"When :c:func:`PyType_Ready` is called, it uses three tables referenced by "
"the type object to create :term:`descriptor`\\s which are placed in the "
"dictionary of the type object.  Each descriptor controls access to one "
"attribute of the instance object.  Each of the tables is optional; if all "
"three are *NULL*, instances of the type will only have attributes that are "
"inherited from their base type, and should leave the :c:member:"
"`~PyTypeObject.tp_getattro` and :c:member:`~PyTypeObject.tp_setattro` fields "
"*NULL* as well, allowing the base type to handle attributes."
msgstr ""
":c:func:`PyType_Ready` が呼ばれると、これはそのタイプオブジェクトに参照されて"
"いる 3つのテーブルを使って、そのタイプオブジェクトの辞書中にデスクリプタ(:"
"term:`descriptor`) を作成します。各デスクリプタは、インスタンスオブジェクトの"
"属性に対するアクセスを制御します。それぞれのテーブルはなくてもかまいません。"
"もしこれら 3つがすべて *NULL* だと、その型のインスタンスはその基底型から継承"
"した属性だけを持つことになります。また、 :c:member:`~PyTypeObject."
"tp_getattro` および :c:member:`~PyTypeObject.tp_setattro` が *NULL* のまま"
"だった場合も、基底型にこれらの属性の操作がまかせられます。"

#: ../../extending/newtypes.rst:1166
msgid "The tables are declared as three fields of the type object::"
msgstr "テーブルはタイプオブジェクト中の 3つのメンバとして宣言されています::"

#: ../../extending/newtypes.rst:1172
msgid ""
"If :c:member:`~PyTypeObject.tp_methods` is not *NULL*, it must refer to an "
"array of :c:type:`PyMethodDef` structures.  Each entry in the table is an "
"instance of this structure::"
msgstr ""
":c:member:`~PyTypeObject.tp_methods` が *NULL* でない場合、これは :c:type:"
"`PyMethodDef` 構造体への配列を指している必要があります。テーブル中の各エント"
"リは、つぎのような構造体のインスタンスです::"

#: ../../extending/newtypes.rst:1183
msgid ""
"One entry should be defined for each method provided by the type; no entries "
"are needed for methods inherited from a base type.  One additional entry is "
"needed at the end; it is a sentinel that marks the end of the array.  The :"
"attr:`ml_name` field of the sentinel must be *NULL*."
msgstr ""
"その型が提供する各メソッドについてひとつのエントリを定義する必要があります。"
"基底型から継承してきたメソッドについてはエントリは必要ありません。これの最後"
"には、配列の終わりを示すための見張り番 (sentinel) として追加のエントリがひと"
"つ必要です。この場合、 :attr:`ml_name` メンバが sentinel として使われ、その値"
"は *NULL* でなければなりません。"

#: ../../extending/newtypes.rst:1188
msgid ""
"XXX Need to refer to some unified discussion of the structure fields, shared "
"with the next section."
msgstr ""
"XXX Need to refer to some unified discussion of the structure fields, shared "
"with the next section."

#: ../../extending/newtypes.rst:1191
msgid ""
"The second table is used to define attributes which map directly to data "
"stored in the instance.  A variety of primitive C types are supported, and "
"access may be read-only or read-write.  The structures in the table are "
"defined as::"
msgstr ""
"2番目のテーブルは、インスタンス中に格納されるデータと直接対応づけられた属性を"
"定義するのに使います。いくつもの C の原始的な型がサポートされており、アクセス"
"を読み込み専用にも読み書き可能にもできます。このテーブルで使われる構造体は次"
"のように定義されています::"

#: ../../extending/newtypes.rst:1203
msgid ""
"For each entry in the table, a :term:`descriptor` will be constructed and "
"added to the type which will be able to extract a value from the instance "
"structure.  The :attr:`type` field should contain one of the type codes "
"defined in the :file:`structmember.h` header; the value will be used to "
"determine how to convert Python values to and from C values.  The :attr:"
"`flags` field is used to store flags which control how the attribute can be "
"accessed."
msgstr ""
"このテーブルの各エントリに対してデスクリプタ(:term:`descriptor`)が作成され、"
"値をインスタンスの構造体から抽出しうる型に対してそれらが追加されます。 :attr:"
"`type` メンバは :file:`structmember.h` ヘッダで定義された型のコードをひとつ含"
"んでいる必要があります。この値は Python における値と C における値をどのように"
"変換しあうかを定めるものです。 :attr:`flags` メンバはこの属性がどのようにアク"
"セスされるかを制御するフラグを格納するのに使われます。"

#: ../../extending/newtypes.rst:1210
msgid "XXX Need to move some of this to a shared section!"
msgstr "XXX Need to move some of this to a shared section!"

#: ../../extending/newtypes.rst:1212
msgid ""
"The following flag constants are defined in :file:`structmember.h`; they may "
"be combined using bitwise-OR."
msgstr ""
"以下のフラグ用定数は :file:`structmember.h` で定義されており、これらはビット"
"ごとの OR を取って組み合わせられます。"

#: ../../extending/newtypes.rst:1216
msgid "Constant"
msgstr "定数"

#: ../../extending/newtypes.rst:1216
msgid "Meaning"
msgstr "意味"

#: ../../extending/newtypes.rst:1218
msgid ":const:`READONLY`"
msgstr ":const:`READONLY`"

#: ../../extending/newtypes.rst:1218
msgid "Never writable."
msgstr "絶対に変更できない。"

#: ../../extending/newtypes.rst:1220
msgid ":const:`RO`"
msgstr ":const:`RO`"

#: ../../extending/newtypes.rst:1220
msgid "Shorthand for :const:`READONLY`."
msgstr ":const:`READONLY` の短縮形。"

#: ../../extending/newtypes.rst:1222
msgid ":const:`READ_RESTRICTED`"
msgstr ":const:`READ_RESTRICTED`"

#: ../../extending/newtypes.rst:1222
msgid "Not readable in restricted mode."
msgstr "制限モード (restricted mode) では参照できない。"

#: ../../extending/newtypes.rst:1224
msgid ":const:`WRITE_RESTRICTED`"
msgstr ":const:`WRITE_RESTRICTED`"

#: ../../extending/newtypes.rst:1224
msgid "Not writable in restricted mode."
msgstr "制限モード (restricted mode) では変更できない。"

#: ../../extending/newtypes.rst:1226
msgid ":const:`RESTRICTED`"
msgstr ":const:`RESTRICTED`"

#: ../../extending/newtypes.rst:1226
msgid "Not readable or writable in restricted mode."
msgstr "制限モード (restricted mode) では参照も変更もできない。"

#: ../../extending/newtypes.rst:1236
msgid ""
"An interesting advantage of using the :c:member:`~PyTypeObject.tp_members` "
"table to build descriptors that are used at runtime is that any attribute "
"defined this way can have an associated doc string simply by providing the "
"text in the table.  An application can use the introspection API to retrieve "
"the descriptor from the class object, and get the doc string using its :attr:"
"`__doc__` attribute."
msgstr ""
":c:member:`~PyTypeObject.tp_members` を使ったひとつの面白い利用法は、実行時に"
"使われるデスクリプタを作成しておき、単にテーブル中にテキストを置いておくこと"
"によって、この方法で定義されたすべての属性に doc string を関連付けられるよう"
"にすることです。アプリケーションはこのイントロスペクション用 API を使って、ク"
"ラスオブジェクトからデスクリプタを取り出し、その :attr:`__doc__` 属性を使っ"
"て doc string を得られます。"

#: ../../extending/newtypes.rst:1242
msgid ""
"As with the :c:member:`~PyTypeObject.tp_methods` table, a sentinel entry "
"with a :attr:`name` value of *NULL* is required."
msgstr ""
":c:member:`~PyTypeObject.tp_methods` テーブルと同じように、ここでも :attr:"
"`name` メンバの値を *NULL* にした見張り用エントリが必要です。"

#: ../../extending/newtypes.rst:1256
msgid "Type-specific Attribute Management"
msgstr "特定の型に特化した属性の管理"

#: ../../extending/newtypes.rst:1258
msgid ""
"For simplicity, only the :c:type:`char\\*` version will be demonstrated "
"here; the type of the name parameter is the only difference between the :c:"
"type:`char\\*` and :c:type:`PyObject\\*` flavors of the interface. This "
"example effectively does the same thing as the generic example above, but "
"does not use the generic support added in Python 2.2.  The value in showing "
"this is two-fold: it demonstrates how basic attribute management can be done "
"in a way that is portable to older versions of Python, and explains how the "
"handler functions are called, so that if you do need to extend their "
"functionality, you'll understand what needs to be done."
msgstr ""
"話を単純にするため、ここでは :c:type:`char\\*` を使ったバージョンのみを示しま"
"す。name パラメータの型はインターフェイスとして :c:type:`char\\*` を使うか :"
"c:type:`PyObject\\*` を使うかの違いしかありません。この例では、上の総称的な例"
"と同じことを効率的にやりますが、 Python 2.2 で追加された総称的な型のサポート"
"を使わずにやります。これを紹介することは 2つの意味をもっています。ひとつはど"
"うやって、古いバージョンの Python と互換性のあるやり方で、基本的な属性管理を"
"おこなうか。そしてもうひとつはハンドラの関数がどのようにして呼ばれるのか。こ"
"れで、たとえその機能を拡張する必要があるとき、何をどうすればいいかわかるで"
"しょう。"

#: ../../extending/newtypes.rst:1268
msgid ""
"The :c:member:`~PyTypeObject.tp_getattr` handler is called when the object "
"requires an attribute look-up.  It is called in the same situations where "
"the :meth:`__getattr__` method of a class would be called."
msgstr ""
":c:member:`~PyTypeObject.tp_getattr` ハンドラはオブジェクトが属性への参照を要"
"求するときに呼ばれます。これは、そのクラスの :meth:`__getattr__` メソッドが呼"
"ばれるであろう状況と同じ状況下で呼び出されます。"

#: ../../extending/newtypes.rst:1272
msgid ""
"A likely way to handle this is (1) to implement a set of functions (such as :"
"c:func:`newdatatype_getSize` and :c:func:`newdatatype_setSize` in the "
"example below), (2) provide a method table listing these functions, and (3) "
"provide a getattr function that returns the result of a lookup in that "
"table.  The method table uses the same structure as the :c:member:"
"`~PyTypeObject.tp_methods` field of the type object."
msgstr ""
"これを処理するありがちな方法は、(1) 一連の関数 (下の例の :c:func:"
"`newdatatype_getSize` や :c:func:`newdatatype_setSize`) を実装する、(2) これ"
"らの関数を記録したメソッドテーブルを提供する、そして (3) そのテーブルの参照結"
"果を返す getattr 関数を提供することです。メソッドテーブルはタイプオブジェクト"
"の :c:member:`~PyTypeObject.tp_methods` メンバと同じ構造を持っています。"

#: ../../extending/newtypes.rst:1279
msgid "Here is an example::"
msgstr "以下に例を示します::"

#: ../../extending/newtypes.rst:1295
msgid ""
"The :c:member:`~PyTypeObject.tp_setattr` handler is called when the :meth:"
"`__setattr__` or :meth:`__delattr__` method of a class instance would be "
"called.  When an attribute should be deleted, the third parameter will be "
"*NULL*.  Here is an example that simply raises an exception; if this were "
"really all you wanted, the :c:member:`~PyTypeObject.tp_setattr` handler "
"should be set to *NULL*. ::"
msgstr ""
":c:member:`~PyTypeObject.tp_setattr` ハンドラは、クラスのインスタンスの :"
"meth:`__setattr__` または :meth:`__delattr__` メソッドが呼ばれるであろう状況"
"で呼び出されます。ある属性が削除されるとき、3番目のパラメータは *NULL* になり"
"ます。以下の例はたんに例外を発生させるものですが、もし本当にこれと同じことを"
"したいなら、 :c:member:`~PyTypeObject.tp_setattr` ハンドラを *NULL* に設定す"
"べきです。 ::"

#: ../../extending/newtypes.rst:1310
msgid "Object Comparison"
msgstr "オブジェクトの比較"

#: ../../extending/newtypes.rst:1316
msgid ""
"The :c:member:`~PyTypeObject.tp_compare` handler is called when comparisons "
"are needed and the object does not implement the specific rich comparison "
"method which matches the requested comparison.  (It is always used if "
"defined and the :c:func:`PyObject_Compare` or :c:func:`PyObject_Cmp` "
"functions are used, or if :func:`cmp` is used from Python.) It is analogous "
"to the :meth:`__cmp__` method. This function should return ``-1`` if *obj1* "
"is less than *obj2*, ``0`` if they are equal, and ``1`` if *obj1* is greater "
"than *obj2*. (It was previously allowed to return arbitrary negative or "
"positive integers for less than and greater than, respectively; as of Python "
"2.2, this is no longer allowed.  In the future, other return values may be "
"assigned a different meaning.)"
msgstr ""
":c:member:`~PyTypeObject.tp_compare` ハンドラは、オブジェクトどうしの比較が必"
"要で、そのオブジェクトに要求された比較をおこなうのに適した特定の拡張比較メ"
"ソッドが実装されていないときに呼び出されます。(これが定義されているとき、 :c:"
"func:`PyObject_Compare` または :c:func:`PyObject_Cmp` が使われるとこれはつね"
"に呼び出されます、また Python で :func:`cmp` が使われたときにも呼び出されま"
"す。) これは :meth:`__cmp__` メソッドに似ています。この関数はもし *obj1* が "
"*obj2* より「小さい」場合は ``-1`` を返し、それらが等しければ ``0`` 、そして"
"もし *obj1* が *obj2* より「大きい」場合は ``1`` を返す必要があります。 (以前"
"は大小比較の結果として、任意の大きさの負または正の整数を返せましたが、 "
"Python 2.2 以降ではこれはもう許されていません。将来的には、上にあげた以外の返"
"り値は別の意味をもつ可能性があります。)"

#: ../../extending/newtypes.rst:1327
msgid ""
"A :c:member:`~PyTypeObject.tp_compare` handler may raise an exception.  In "
"this case it should return a negative value.  The caller has to test for the "
"exception using :c:func:`PyErr_Occurred`."
msgstr ""
":c:member:`~PyTypeObject.tp_compare` ハンドラは例外を発生させられます。この場"
"合、この関数は負の値を返す必要があります。呼び出した側は :c:func:"
"`PyErr_Occurred` を使って例外を検査しなければなりません。"

#: ../../extending/newtypes.rst:1331
msgid "Here is a sample implementation::"
msgstr "以下はサンプル実装です::"

#: ../../extending/newtypes.rst:1354
msgid "Abstract Protocol Support"
msgstr "抽象的なプロトコルのサポート"

#: ../../extending/newtypes.rst:1356
msgid ""
"Python supports a variety of *abstract* 'protocols;' the specific interfaces "
"provided to use these interfaces are documented in :ref:`abstract`."
msgstr ""
"Python はいくつもの *抽象的な* “プロトコル”をサポートしています。これらを使用"
"する特定のインターフェイスについては :ref:`abstract` で解説されています。"

#: ../../extending/newtypes.rst:1360
msgid ""
"A number of these abstract interfaces were defined early in the development "
"of the Python implementation.  In particular, the number, mapping, and "
"sequence protocols have been part of Python since the beginning.  Other "
"protocols have been added over time.  For protocols which depend on several "
"handler routines from the type implementation, the older protocols have been "
"defined as optional blocks of handlers referenced by the type object.  For "
"newer protocols there are additional slots in the main type object, with a "
"flag bit being set to indicate that the slots are present and should be "
"checked by the interpreter.  (The flag bit does not indicate that the slot "
"values are non-*NULL*. The flag may be set to indicate the presence of a "
"slot, but a slot may still be unfilled.) ::"
msgstr ""
"これら多数の抽象的なインターフェイスは、Python の実装が開発される初期の段階で"
"定義されていました。とりわけ数値や辞書、そしてシーケンスなどのプロトコルは最"
"初から Python の一部だったのです。それ以外のプロトコルはその後追加されまし"
"た。型の実装にあるいくつかのハンドラルーチンに依存するようなプロトコルのため"
"に、古いプロトコルはハンドラの入ったオプションのブロックとして定義し、型オブ"
"ジェクトから参照するようになりました。タイプオブジェクトの主部に追加のスロッ"
"トをもつ新しいプロトコルについては、フラグ用のビットを立てることでそれらのス"
"ロットが存在しており、インタプリタがチェックすべきであることを指示できます。"
"(このフラグ用のビットは、そのスロットの値が非 *NULL* であることを示しているわ"
"けではありません。フラグはスロットの存在を示すのに使えますが、そのスロットは"
"まだ埋まっていないかもしれないのです。) ::"

#: ../../extending/newtypes.rst:1375
msgid ""
"If you wish your object to be able to act like a number, a sequence, or a "
"mapping object, then you place the address of a structure that implements "
"the C type :c:type:`PyNumberMethods`, :c:type:`PySequenceMethods`, or :c:"
"type:`PyMappingMethods`, respectively. It is up to you to fill in this "
"structure with appropriate values. You can find examples of the use of each "
"of these in the :file:`Objects` directory of the Python source "
"distribution. ::"
msgstr ""
"お使いのオブジェクトを数値やシーケンス、あるいは辞書のようにふるまうようにし"
"たいならば、それぞれに C の :c:type:`PyNumberMethods` 構造体、 :c:type:"
"`PySequenceMethods` 構造体、または :c:type:`PyMappingMethods` 構造体のアドレ"
"スを入れます。これらに適切な値を入れても入れなくてもかまいません。これらを"
"使った例は Python の配布ソースにある :file:`Objects` でみつけることができるで"
"しょう。 ::"

#: ../../extending/newtypes.rst:1384
msgid ""
"This function, if you choose to provide it, should return a hash number for "
"an instance of your data type. Here is a moderately pointless example::"
msgstr ""
"この関数は、もし使うのならば、これはお使いの型のインスタンスのハッシュ番号を"
"返すようにします。以下はやや的はずれな例ですが ::"

#: ../../extending/newtypes.rst:1400
msgid ""
"This function is called when an instance of your data type is \"called\", "
"for example, if ``obj1`` is an instance of your data type and the Python "
"script contains ``obj1('hello')``, the :c:member:`~PyTypeObject.tp_call` "
"handler is invoked."
msgstr ""
"この関数は、その型のインスタンスが「関数として呼び出される」ときに呼ばれま"
"す。たとえばもし ``obj1`` にそのインスタンスが入っていて、Python スクリプト"
"で ``obj1('hello')`` を実行したとすると、 :c:member:`~PyTypeObject.tp_call` "
"ハンドラが呼ばれます。"

#: ../../extending/newtypes.rst:1404
msgid "This function takes three arguments:"
msgstr "この関数は 3つの引数をとります:"

#: ../../extending/newtypes.rst:1406
msgid ""
"*arg1* is the instance of the data type which is the subject of the call. If "
"the call is ``obj1('hello')``, then *arg1* is ``obj1``."
msgstr ""
"*arg1* にはその呼び出しの対象となる、そのデータ型のインスタンスが入ります。た"
"とえば呼び出しが ``obj1('hello')`` の場合、 *arg1* は ``obj1`` になります。"

#: ../../extending/newtypes.rst:1409
msgid ""
"*arg2* is a tuple containing the arguments to the call.  You can use :c:func:"
"`PyArg_ParseTuple` to extract the arguments."
msgstr ""
"*arg2* は呼び出しの引数を格納しているタプルです。ここから引数を取り出すには :"
"c:func:`PyArg_ParseTuple` を使います。"

#: ../../extending/newtypes.rst:1412
msgid ""
"*arg3* is a dictionary of keyword arguments that were passed. If this is non-"
"*NULL* and you support keyword arguments, use :c:func:"
"`PyArg_ParseTupleAndKeywords` to extract the arguments.  If you do not want "
"to support keyword arguments and this is non-*NULL*, raise a :exc:"
"`TypeError` with a message saying that keyword arguments are not supported."
msgstr ""
"*arg3* はキーワード引数のための辞書です。これが *NULL* 以外でキーワード引数を"
"サポートしているなら、 :c:func:`PyArg_ParseTupleAndKeywords` をつかって引数を"
"取り出せます。キーワード引数をサポートしていないのにこれが *NULL* 以外の場合"
"は、キーワード引数はサポートしていない旨のメッセージとともに :exc:"
"`TypeError` を発生させてください。"

#: ../../extending/newtypes.rst:1418
msgid ""
"Here is a desultory example of the implementation of the call function. ::"
msgstr "以下はこの call 関数をてきとうに使った例です。 ::"

#: ../../extending/newtypes.rst:1444
msgid "XXX some fields need to be added here... ::"
msgstr "XXX some fields need to be added here... ::"

#: ../../extending/newtypes.rst:1451
msgid ""
"These functions provide support for the iterator protocol.  Any object which "
"wishes to support iteration over its contents (which may be generated during "
"iteration) must implement the ``tp_iter`` handler.  Objects which are "
"returned by a ``tp_iter`` handler must implement both the ``tp_iter`` and "
"``tp_iternext`` handlers. Both handlers take exactly one parameter, the "
"instance for which they are being called, and return a new reference.  In "
"the case of an error, they should set an exception and return *NULL*."
msgstr ""
"これらの関数はイテレータ用プロトコルをサポートします。オブジェクトが、その "
"(ループ中に順に生成されていくかもしれない) 内容を巡回 (訳注: イテレータでひと"
"つずつ要素をたどっていくこと) するイテレータをサポートしたい場合は、 "
"``tp_iter`` ハンドラを実装する必要があります。 ``tp_iter`` ハンドラによって返"
"されるオブジェクトは ``tp_iter`` と ``tp_iternext`` の両方を実装する必要があ"
"ります。どちらのハンドラも、それが呼ばれたインスタンスをひとつだけ引数として"
"とり、新しい参照を返します。エラーが起きた場合には例外を設定してから *NULL* "
"を返す必要があります。"

#: ../../extending/newtypes.rst:1459
msgid ""
"For an object which represents an iterable collection, the ``tp_iter`` "
"handler must return an iterator object.  The iterator object is responsible "
"for maintaining the state of the iteration.  For collections which can "
"support multiple iterators which do not interfere with each other (as lists "
"and tuples do), a new iterator should be created and returned.  Objects "
"which can only be iterated over once (usually due to side effects of "
"iteration) should implement this handler by returning a new reference to "
"themselves, and should also implement the ``tp_iternext`` handler.  File "
"objects are an example of such an iterator."
msgstr ""
"巡回可能な要素を表現するオブジェクトに対しては、 ``tp_iter`` ハンドラがイテ"
"レータオブジェクトを返す必要があります。イテレータオブジェクトは巡回中の状態"
"を保持する責任をもっています。お互いに干渉しない複数のイテレータの存在を許す"
"ようなオブジェクト (リストやタプルがそうです) の場合は、新しいイテレータを作"
"成して返す必要があります。 (巡回の結果生じる副作用のために) 一回だけしか巡回"
"できないオブジェクトの場合は、それ自身への参照を返すようなハンドラと、 "
"``tp_iternext`` ハンドラも実装する必要があります。ファイルオブジェクトはその"
"ようなイテレータの例です。"

#: ../../extending/newtypes.rst:1469
msgid ""
"Iterator objects should implement both handlers.  The ``tp_iter`` handler "
"should return a new reference to the iterator (this is the same as the "
"``tp_iter`` handler for objects which can only be iterated over "
"destructively).  The ``tp_iternext`` handler should return a new reference "
"to the next object in the iteration if there is one.  If the iteration has "
"reached the end, it may return *NULL* without setting an exception or it may "
"set :exc:`StopIteration`; avoiding the exception can yield slightly better "
"performance.  If an actual error occurs, it should set an exception and "
"return *NULL*."
msgstr ""
"イテレータオブジェクトは両方のハンドラを実装する必要があります。 ``tp_iter`` "
"ハンドラはそのイテレータへの新しい参照を返します (これは破壊的にしか巡回でき"
"ないオブジェクトに対する ``tp_iter`` ハンドラと同じです)。 ``tp_iternext`` ハ"
"ンドラはその次のオブジェクトがある場合、それへの新しい参照を返します。巡回が"
"終端に達したときは例外を出さずに *NULL* を返してもいいですし、 :exc:"
"`StopIteration` を放出してもかまいません。例外を使わないほうがやや速度が上が"
"るかもしれません。実際のエラーが起こったときには、例外を放出して *NULL* を返"
"す必要があります。"

#: ../../extending/newtypes.rst:1482
msgid "Weak Reference Support"
msgstr "弱参照(Weak Reference)のサポート"

#: ../../extending/newtypes.rst:1484
msgid ""
"One of the goals of Python's weak-reference implementation is to allow any "
"type to participate in the weak reference mechanism without incurring the "
"overhead on those objects which do not benefit by weak referencing (such as "
"numbers)."
msgstr ""
"Pythonの弱参照実装のひとつのゴールは、どのような（数値のような弱参照による利"
"益を得ない）タイプでもオーバーヘッドなしで弱参照のメカニズムに組み込めるよう"
"にすることです。"

#: ../../extending/newtypes.rst:1488
msgid ""
"For an object to be weakly referencable, the extension must include a :c:"
"type:`PyObject\\*` field in the instance structure for the use of the weak "
"reference mechanism; it must be initialized to *NULL* by the object's "
"constructor.  It must also set the :c:member:`~PyTypeObject."
"tp_weaklistoffset` field of the corresponding type object to the offset of "
"the field. For example, the instance type is defined with the following "
"structure::"
msgstr ""
"弱参照可能なオブジェクトの拡張では、弱参照メカニズムのために :c:type:"
"`PyObject\\*` フィールドをインスタンス構造体に含む必要があります。これはオブ"
"ジェクトのコンストラクタで *NULL* に初期化する必要があります。これは対応する"
"タイプの :c:member:`~PyTypeObject.tp_weaklistoffset` フィールドをフィールドの"
"オフセットに設定しなければいけません。たとえば、インスタンスタイプは以下の構"
"造体で定義されます::"

#: ../../extending/newtypes.rst:1502
msgid "The statically-declared type object for instances is defined this way::"
msgstr ""
"インスタンス用に静的に宣言されたタイプオブジェクトはこのように定義されます::"

#: ../../extending/newtypes.rst:1519
msgid ""
"The type constructor is responsible for initializing the weak reference list "
"to *NULL*::"
msgstr "タイプのコンストラクタは弱参照を *NULL* に初期化する責任があります::"

#: ../../extending/newtypes.rst:1531
msgid ""
"The only further addition is that the destructor needs to call the weak "
"reference manager to clear any weak references.  This is only required if "
"the weak reference list is non-*NULL*::"
msgstr ""
"ほかに追記すべきことは、デストラクタは弱参照を消すために弱参照のマネージャを"
"呼ぶ必要があることくらいです。これは弱参照リストが *NULL* でない場合にだけ必"
"要です::"

#: ../../extending/newtypes.rst:1550
msgid "More Suggestions"
msgstr "その他いろいろ"

#: ../../extending/newtypes.rst:1552
msgid ""
"Remember that you can omit most of these functions, in which case you "
"provide ``0`` as a value.  There are type definitions for each of the "
"functions you must provide.  They are in :file:`object.h` in the Python "
"include directory that comes with the source distribution of Python."
msgstr ""
"上にあげたほとんどの関数は、その値として ``0`` を与えれば省略できることを忘れ"
"ないでください。それぞれの関数で提供しなければならない型の定義があり、これら"
"は Python の include 用ディレクトリの :file:`object.h` というファイルにおさめ"
"られています。これは Python の配布ソースに含まれています。"

#: ../../extending/newtypes.rst:1557
msgid ""
"In order to learn how to implement any specific method for your new data "
"type, do the following: Download and unpack the Python source distribution.  "
"Go the :file:`Objects` directory, then search the C source files for ``tp_`` "
"plus the function you want (for example, ``tp_print`` or ``tp_compare``).  "
"You will find examples of the function you want to implement."
msgstr ""
"新しいデータ型に何らかのメソッドを実装するやりかたを学ぶには、以下の方法がお"
"すすめです: Python の配布されているソースをダウンロードして展開する。 :file:"
"`Objects` ディレクトリへ行き、C のソースファイルから「 ``tp_`` 欲しい名前」の"
"文字列で検索する (たとえば ``tp_print`` とか ``tp_compare`` のように)。こうす"
"れば実装したい例がみつかるでしょう。"

#: ../../extending/newtypes.rst:1563
msgid ""
"When you need to verify that an object is an instance of the type you are "
"implementing, use the :c:func:`PyObject_TypeCheck` function. A sample of its "
"use might be something like the following::"
msgstr ""
"あるオブジェクトが、いま実装している型のインスタンスであるかどうかを確かめた"
"い場合には、 :c:func:`PyObject_TypeCheck` 関数を使ってください。使用例は以下"
"のようなかんじです::"

#: ../../extending/newtypes.rst:1573
msgid "Footnotes"
msgstr "注記"

#: ../../extending/newtypes.rst:1574
msgid ""
"This is true when we know that the object is a basic type, like a string or "
"a float."
msgstr ""
"これはそのオブジェクトが文字列や実数などの基本タイプであるような時に成り立ち"
"ます。"

#: ../../extending/newtypes.rst:1577
msgid ""
"We relied on this in the :c:member:`~PyTypeObject.tp_dealloc` handler in "
"this example, because our type doesn't support garbage collection. Even if a "
"type supports garbage collection, there are calls that can be made to "
"\"untrack\" the object from garbage collection, however, these calls are "
"advanced and not covered here."
msgstr ""
"ここで出てきたタイプではガベージコレクションをサポートしていないので、この例"
"では :c:member:`~PyTypeObject.tp_dealloc` ハンドラに依存しています。このハン"
"ドラはそのタイプがたとえガベージコレクションをサポートしている場合でも、その"
"オブジェクトの「追跡を解除する」ために呼ばれることがありますが、これは高度な"
"話題でありここでは扱いません。"

#: ../../extending/newtypes.rst:1582
msgid ""
"We now know that the first and last members are strings, so perhaps we could "
"be less careful about decrementing their reference counts, however, we "
"accept instances of string subclasses. Even though deallocating normal "
"strings won't call back into our objects, we can't guarantee that "
"deallocating an instance of a string subclass won't call back into our "
"objects."
msgstr ""
"first および last メンバが文字列であるということはわかっているので、いまやそ"
"れらの参照カウントを減らすときにはそれほど注意する必要はないように思えるかも"
"しれません。しかし文字列型のサブクラスは依然として受けつけられています。通常"
"の文字列型ならば、解放時にあなたのオブジェクトがコールバックされることはあり"
"ませんが、文字列型のサブクラスがそうしないという保証はありません。"

#: ../../extending/newtypes.rst:1588
msgid ""
"Even in the third version, we aren't guaranteed to avoid cycles.  Instances "
"of string subclasses are allowed and string subclasses could allow cycles "
"even if normal strings don't."
msgstr ""
"3番目のバージョンでさえ、循環を回避できるという保証はされていません。たとえ通"
"常の文字列型なら循環しない場合でも、文字列型のサブクラスをとることが許されて"
"いれば、そのタイプでは循環が発生しうるからです。"
