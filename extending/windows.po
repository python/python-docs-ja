# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-05 15:01+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../extending/windows.rst:8
msgid "Building C and C++ Extensions on Windows"
msgstr "Windows ä¸Šã§ã® C ãŠã‚ˆã³ C++ æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ“ãƒ«ãƒ‰"

#: ../../extending/windows.rst:10
msgid ""
"This chapter briefly explains how to create a Windows extension module for "
"Python using Microsoft Visual C++, and follows with more detailed background"
" information on how it works.  The explanatory material is useful for both "
"the Windows programmer learning to build Python extensions and the Unix "
"programmer interested in producing software which can be successfully built "
"on both Unix and Windows."
msgstr ""
"ã“ã®ç« ã§ã¯ Windows å‘ã‘ã® Python æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ Microsoft Visual C++ "
"ã‚’ä½¿ã£ã¦ä½œæˆã™ã‚‹æ–¹æ³•ã«ã¤ã„ã¦ç°¡å˜ã«è¿°ã¹ã€ãã®å¾Œã«æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ“ãƒ«ãƒ‰ãŒã©ã®ã‚ˆã†ã«å‹•ä½œã™ã‚‹ã®ã‹ã«ã¤ã„ã¦è©³ã—ã„èƒŒæ™¯ã‚’è¿°ã¹ã¾ã™ã€‚ã“ã®èª¬æ˜ã¯ã€Python "
"æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½œæˆã™ã‚‹ Windows ãƒ—ãƒ­ã‚°ãƒ©ãƒã¨ã€Unix ã¨ Windows ã®åŒæ–¹ã§ã†ã¾ããƒ“ãƒ«ãƒ‰ã§ãã‚‹ã‚ˆã†ãªã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã®ä½œæˆã«èˆˆå‘³ãŒã‚ã‚‹ "
"Unix ãƒ—ãƒ­ã‚°ãƒ©ãƒã®åŒæ–¹ã«ã¨ã£ã¦æœ‰ç”¨ã§ã™ã€‚"

#: ../../extending/windows.rst:17
msgid ""
"Module authors are encouraged to use the distutils approach for building "
"extension modules, instead of the one described in this section. You will "
"still need the C compiler that was used to build Python; typically Microsoft"
" Visual C++."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä½œè€…ã«ã¯ã€ã“ã®ç¯€ã§èª¬æ˜ã—ã¦ã„ã‚‹æ–¹æ³•ã‚ˆã‚Šã‚‚ã€distutils ã«ã‚ˆã‚‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ“ãƒ«ãƒ‰ã™ã‚‹ã‚ˆã†å‹§ã‚ã¾ã™ã€‚ã¾ãŸã€Python "
"ã‚’ãƒ“ãƒ«ãƒ‰ã—ãŸéš›ã«ä½¿ã‚ã‚ŒãŸ C ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒå¿…è¦ã§ã™; é€šå¸¸ã¯ Microsoft Visual C++ã§ã™ã€‚"

#: ../../extending/windows.rst:24
msgid ""
"This chapter mentions a number of filenames that include an encoded Python "
"version number.  These filenames are represented with the version number "
"shown as ``XY``; in practice, ``'X'`` will be the major version number and "
"``'Y'`` will be the minor version number of the Python release you're "
"working with.  For example, if you are using Python 2.2.1, ``XY`` will "
"actually be ``22``."
msgstr ""
"ã“ã®ç« ã§ã¯ã€Python ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·ãŒç¬¦å·åŒ–ã•ã‚Œã¦å…¥ã£ã¦ã„ã‚‹ãŸãã•ã‚“ã®ãƒ•ã‚¡ã‚¤ãƒ«åã«ã¤ã„ã¦è§¦ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ•ã‚¡ã‚¤ãƒ«åã¯ ``XY`` "
"ã§è¡¨ã•ã‚Œã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³åä»˜ãã§è¡¨ç¾ã•ã‚Œã¾ã™; ``'X'`` ã¯ä½¿ã£ã¦ã„ã‚‹ Python ãƒªãƒªãƒ¼ã‚¹ã®ãƒ¡ã‚¸ãƒ£ãƒ¼ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·ã€``'Y'`` "
"ã¯ãƒã‚¤ãƒŠãƒ¼ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·ã§ã™ã€‚ä¾‹ãˆã°ã€Python 2.2.1 ã‚’ä½¿ã£ã¦ã„ã‚‹ãªã‚‰ã€``XY`` ã¯å®Ÿéš›ã«ã¯ ``22`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../extending/windows.rst:34
msgid "A Cookbook Approach"
msgstr "å‹ã©ãŠã‚Šã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ"

#: ../../extending/windows.rst:36
msgid ""
"There are two approaches to building extension modules on Windows, just as "
"there are on Unix: use the :mod:`distutils` package to control the build "
"process, or do things manually.  The distutils approach works well for most "
"extensions; documentation on using :mod:`distutils` to build and package "
"extension modules is available in :ref:`distutils-index`.  If you find you "
"really need to do things manually, it may be instructive to study the "
"project file for the :source:`winsound <PCbuild/winsound.vcxproj>` standard "
"library module."
msgstr ""
"Windows ã§ã®æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ“ãƒ«ãƒ‰ã«ã¯ã€Unix ã¨åŒã˜ã‚ˆã†ã«ã€ :mod:`distutils` "
"ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ä½¿ã£ãŸãƒ“ãƒ«ãƒ‰ä½œæ¥­ã®åˆ¶å¾¡ã¨æ‰‹å‹•ã®äºŒé€šã‚Šã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒãŒã‚ã‚Šã¾ã™ã€‚ distutils "
"ã«ã‚ˆã‚‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯ã»ã¨ã‚“ã©ã®æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã†ã¾ãã„ãã¾ã™; :mod:`distutils` ã‚’ä½¿ã£ãŸæ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ“ãƒ«ãƒ‰ã¨ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åŒ–ã«ã¤ã„ã¦ã¯ã€"
" :ref:`distutils-index` ã«ã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã‚’æœ¬å½“ã«æ‰‹å‹•ã§è¡Œã‚ãªã‘ã‚Œã°ãªã‚‰ãªã„ã¨ã‚ã‹ã£ãŸå ´åˆã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® "
":source:`winsound <PCbuild/winsound.vcxproj>` ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ãŒå­¦ç¿’ã«æœ‰ç›Šã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../extending/windows.rst:48
msgid "Differences Between Unix and Windows"
msgstr "Unix ã¨ Windows ã®ç›¸é•ç‚¹"

#: ../../extending/windows.rst:53
msgid ""
"Unix and Windows use completely different paradigms for run-time loading of "
"code.  Before you try to build a module that can be dynamically loaded, be "
"aware of how your system works."
msgstr ""
"Unix ã¨ Windows "
"ã§ã¯ã€ã‚³ãƒ¼ãƒ‰ã®å®Ÿè¡Œæ™‚èª­ã¿è¾¼ã¿ã«å…¨ãç•°ãªã‚‹ãƒ‘ãƒ©ãƒ€ã‚¤ãƒ ã‚’ç”¨ã„ã¦ã„ã¾ã™ã€‚å‹•çš„ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã‚‹ã‚ˆã†ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ“ãƒ«ãƒ‰ã—ã‚ˆã†ã¨ã™ã‚‹å‰ã«ã€è‡ªåˆ†ã®ã‚·ã‚¹ãƒ†ãƒ ãŒã©ã®ã‚ˆã†ã«å‹•ä½œã™ã‚‹ã‹çŸ¥ã£ã¦ãŠã„ã¦ãã ã•ã„ã€‚"

#: ../../extending/windows.rst:57
msgid ""
"In Unix, a shared object (:file:`.so`) file contains code to be used by the "
"program, and also the names of functions and data that it expects to find in"
" the program.  When the file is joined to the program, all references to "
"those functions and data in the file's code are changed to point to the "
"actual locations in the program where the functions and data are placed in "
"memory. This is basically a link operation."
msgstr ""
"Unix ã§ã¯ã€å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (:file:`.so`) "
"ãƒ•ã‚¡ã‚¤ãƒ«ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒä½¿ã†ã‚³ãƒ¼ãƒ‰ã€ãã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ å†…ã§ä½¿ã†é–¢æ•°åã‚„ãƒ‡ãƒ¼ã‚¿ãŒå…¥ã£ã¦ã„ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«çµåˆã•ã‚Œã‚‹ã¨ã€ã“ã‚Œã‚‰ã®é–¢æ•°ã‚„ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚³ãƒ¼ãƒ‰å†…ã®å…¨ã¦ã®å‚ç…§ã¯ã€ãƒ¡ãƒ¢ãƒªå†…ã§é–¢æ•°ã‚„ãƒ‡ãƒ¼ã‚¿ãŒé…ç½®ã•ã‚Œã¦ã„ã‚‹ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ä¸­ã®å®Ÿéš›ã®å ´æ‰€ã‚’æŒ‡ã™ã‚ˆã†ã«å¤‰æ›´ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯åŸºæœ¬çš„ã«ã¯ãƒªãƒ³ã‚¯æ“ä½œã«ã‚ãŸã‚Šã¾ã™ã€‚"

#: ../../extending/windows.rst:64
msgid ""
"In Windows, a dynamic-link library (:file:`.dll`) file has no dangling "
"references.  Instead, an access to functions or data goes through a lookup "
"table.  So the DLL code does not have to be fixed up at runtime to refer to "
"the program's memory; instead, the code already uses the DLL's lookup table,"
" and the lookup table is modified at runtime to point to the functions and "
"data."
msgstr ""
"Windows ã§ã¯ã€å‹•çš„ãƒªãƒ³ã‚¯ãƒ©ã‚¤ãƒ–ãƒ©ãƒª (:file:`.dll`) ãƒ•ã‚¡ã‚¤ãƒ«ã«ã¯ã¶ã‚‰ä¸‹ãŒã‚Šå‚ç…§ (dangling reference) "
"ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãã®ä»£ã‚ã‚Šã€é–¢æ•°ã‚„ãƒ‡ãƒ¼ã‚¿ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã¯ãƒ«ãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ä»‹ã—ã¾ã™ã€‚å¾“ã£ã¦ DLL "
"ã‚³ãƒ¼ãƒ‰ã®å ´åˆã€å®Ÿè¡Œæ™‚ã«ãƒã‚¤ãƒ³ã‚¿ãŒãƒ—ãƒ­ã‚°ãƒ©ãƒ ãƒ¡ãƒ¢ãƒªä¸Šã®æ­£ã—ã„å ´æ‰€ã‚’æŒ‡ã™ã‚ˆã†ã«ä¿®æ­£ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“; ãã®ä»£ã‚ã‚Šã€ã‚³ãƒ¼ãƒ‰ã¯å¸¸ã« DLL "
"ã®ãƒ«ãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ä½¿ã„ã€ãƒ«ãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ†ãƒ¼ãƒ–ãƒ«è‡ªä½“ã¯å®Ÿè¡Œæ™‚ã«å®Ÿéš›ã®é–¢æ•°ã‚„ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ã‚ˆã†ã«ä¿®æ­£ã•ã‚Œã¾ã™ã€‚"

#: ../../extending/windows.rst:70
msgid ""
"In Unix, there is only one type of library file (:file:`.a`) which contains "
"code from several object files (:file:`.o`).  During the link step to create"
" a shared object file (:file:`.so`), the linker may find that it doesn't "
"know where an identifier is defined.  The linker will look for it in the "
"object files in the libraries; if it finds it, it will include all the code "
"from that object file."
msgstr ""
"Unix ã«ã¯ã€å”¯ä¸€ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ (:file:`.a`) ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚ :file:`.a` ãƒ•ã‚¡ã‚¤ãƒ«ã«ã¯è¤‡æ•°ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ« "
"(:file:`.o`) ç”±æ¥ã®ã‚³ãƒ¼ãƒ‰ãŒå…¥ã£ã¦ã„ã¾ã™ã€‚å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ« (:file:`.so`) "
"ã‚’ä½œæˆã™ã‚‹ãƒªãƒ³ã‚¯å‡¦ç†ã®æ®µéšä¸­ã«ã€ãƒªãƒ³ã‚«ã¯å®šç¾©å ´æ‰€ã®ä¸æ˜ãªè­˜åˆ¥å­ã«é­é‡ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ã¨ããƒªãƒ³ã‚«ã¯ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå†…ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œç´¢ã—ã¾ã™;"
" ã‚‚ã—è­˜åˆ¥å­ãŒè¦‹ã¤ã‹ã‚‹ã¨ã€ãƒªãƒ³ã‚«ã¯ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å…¨ã¦ã®ã‚³ãƒ¼ãƒ‰ã‚’å–ã‚Šè¾¼ã¿ã¾ã™ã€‚"

#: ../../extending/windows.rst:76
msgid ""
"In Windows, there are two types of library, a static library and an import "
"library (both called :file:`.lib`).  A static library is like a Unix "
":file:`.a` file; it contains code to be included as necessary. An import "
"library is basically used only to reassure the linker that a certain "
"identifier is legal, and will be present in the program when the DLL is "
"loaded.  So the linker uses the information from the import library to build"
" the lookup table for using identifiers that are not included in the DLL.  "
"When an application or a DLL is linked, an import library may be generated, "
"which will need to be used for all future DLLs that depend on the symbols in"
" the application or DLL."
msgstr ""
"Windows ã§ã¯ã€äºŒã¤ã®å½¢å¼ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã€é™çš„ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¨ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã‚ã‚Šã¾ã™ (ã©ã¡ã‚‰ã‚‚ :file:`.lib` "
"ã¨å‘¼ã°ã‚Œã¦ã„ã¾ã™)ã€‚é™çš„ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ Unix ã«ãŠã‘ã‚‹ :file:`.a` ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¼¼ã¦ã„ã¾ã™; "
"ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«ã¯ã€å¿…è¦ã«å¿œã˜ã¦å–ã‚Šè¾¼ã¾ã‚Œã‚‹ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ãŒå…¥ã£ã¦ã„ã¾ã™ã€‚ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã€åŸºæœ¬çš„ã«ã¯ç‰¹å®šã®è­˜åˆ¥å­ãŒä¸æ­£ã§ã¯ãªãã€ DLL "
"ãŒãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸæ™‚ç‚¹ã§å­˜åœ¨ã™ã‚‹ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ãŸã‚ã«ã ã‘ä½¿ã‚ã‚Œã¾ã™ã€‚ãƒªãƒ³ã‚«ã¯ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‹ã‚‰ã®æƒ…å ±ã‚’ä½¿ã£ã¦ãƒ«ãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ä½œæˆã—ã€DLL "
"ã«å…¥ã£ã¦ã„ãªã„è­˜åˆ¥å­ã‚’ä½¿ãˆã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚„ DLL "
"ãŒãƒªãƒ³ã‚¯ã•ã‚Œã‚‹ã•ã„ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒç”Ÿæˆã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚„ DLL "
"å†…ã®ã‚·ãƒ³ãƒœãƒ«ã«ä¾å­˜ã™ã‚‹ã‚ˆã†ãªã€å°†æ¥ä½œæˆã•ã‚Œã‚‹å…¨ã¦ã® DLL ã§ä½¿ã†ãŸã‚ã«å¿…è¦ã«ãªã‚Šã¾ã™ã€‚"

#: ../../extending/windows.rst:86
msgid ""
"Suppose you are building two dynamic-load modules, B and C, which should "
"share another block of code A.  On Unix, you would *not* pass :file:`A.a` to"
" the linker for :file:`B.so` and :file:`C.so`; that would cause it to be "
"included twice, so that B and C would each have their own copy.  In Windows,"
" building :file:`A.dll` will also build :file:`A.lib`.  You *do* pass "
":file:`A.lib` to the linker for B and C.  :file:`A.lib` does not contain "
"code; it just contains information which will be used at runtime to access "
"A's code."
msgstr ""
"äºŒã¤ã®å‹•çš„ãƒ­ãƒ¼ãƒ‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã€B ã¨ C ã‚’ä½œæˆã—ã€åˆ¥ã®ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ A ã‚’å…±æœ‰ã™ã‚‹ã¨ã—ã¾ã™ã€‚Unix ã§ã¯ã€ :file:`A.a` ã‚’ "
":file:`B.so` ã‚„ :file:`C.so`  ã‚’ãƒ“ãƒ«ãƒ‰ã™ã‚‹ã¨ãã®ãƒªãƒ³ã‚«ã«æ¸¡ã—ãŸã‚Šã¯ *ã—ã¾ã›ã‚“* ; "
"ãã‚“ãªã“ã¨ã‚’ã™ã‚Œã°ã€ã‚³ãƒ¼ãƒ‰ã¯äºŒåº¦å–ã‚Šè¾¼ã¾ã‚Œã€B ã¨ C ã®ãã‚Œãã‚ŒãŒè‡ªåˆ†ç”¨ã®ã‚³ãƒ”ãƒ¼ã‚’æŒã£ã¦ã—ã¾ã„ã¾ã™ã€‚ Windows ã§ã¯ã€ "
":file:`A.dll` ã‚’ãƒ“ãƒ«ãƒ‰ã™ã‚‹ã¨ :file:`A.lib` ã‚‚ãƒ“ãƒ«ãƒ‰ã•ã‚Œã¾ã™ã€‚ B ã‚„ C ã®ãƒªãƒ³ã‚¯ã«ã¯ :file:`A.lib` "
"ã‚’æ¸¡ã—ã¾ã™ã€‚ :file:`A.lib` ã«ã¯ã‚³ãƒ¼ãƒ‰ã¯å…¥ã£ã¦ã„ã¾ã›ã‚“; å˜ã« A "
"ã®ã‚³ãƒ¼ãƒ‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã™ã‚‹ãŸã‚ã«å®Ÿè¡Œæ™‚ã«ç”¨ã„ã‚‰ã‚Œã‚‹æƒ…å ±ãŒå…¥ã£ã¦ã„ã‚‹ã ã‘ã§ã™ã€‚"

#: ../../extending/windows.rst:94
msgid ""
"In Windows, using an import library is sort of like using ``import spam``; "
"it gives you access to spam's names, but does not create a separate copy.  "
"On Unix, linking with a library is more like ``from spam import *``; it does"
" create a separate copy."
msgstr ""
"Windows ã§ã¯ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ä½¿ç”¨ã¯ ``import spam`` ã¨ã™ã‚‹ã‚ˆã†ãªã‚‚ã®ã§ã™; ã“ã®æ“ä½œã«ã‚ˆã£ã¦ spam "
"ã®åå‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ãŒã€ã‚³ãƒ¼ãƒ‰ã®ã‚³ãƒ”ãƒ¼ã‚’å€‹åˆ¥ã«ä½œæˆã—ãŸã‚Šã¯ã—ã¾ã›ã‚“ã€‚Unix ã§ã¯ã€ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¨ã®ãƒªãƒ³ã‚¯ã¯ã‚€ã—ã‚ ``from spam "
"import *`` ã«ä¼¼ã¦ã„ã¾ã™;  ã“ã®æ“ä½œã§ã¯å€‹åˆ¥ã«ã‚³ãƒ¼ãƒ‰ã®ã‚³ãƒ”ãƒ¼ã‚’ç”Ÿæˆã—ã¾ã™ã€‚"

#: ../../extending/windows.rst:103
msgid "Using DLLs in Practice"
msgstr "DLL ä½¿ç”¨ã®å®Ÿéš›"

#: ../../extending/windows.rst:108
msgid ""
"Windows Python is built in Microsoft Visual C++; using other compilers may "
"or may not work (though Borland seems to).  The rest of this section is "
"MSVC++ specific."
msgstr ""
"Windows ç‰ˆã® Python ã¯ Microsoft Visual C++ã§ãƒ“ãƒ«ãƒ‰ã•ã‚Œã¦ã„ã¾ã™; "
"ä»–ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã‚’ä½¿ã†ã¨ã€ã†ã¾ãå‹•ä½œã—ãŸã‚Šã€ã—ãªã‹ã£ãŸã‚Šã—ã¾ã™ (Borland ã‚‚ä¸€è¦‹ã†ã¾ãå‹•ä½œã—ã¾ã›ã‚“)ã€‚ã“ã®ç¯€ã®æ®‹ã‚Šã®éƒ¨åˆ†ã¯ MSVC++ "
"å‘ã‘ã®èª¬æ˜ã§ã™ã€‚"

#: ../../extending/windows.rst:112
msgid ""
"When creating DLLs in Windows, you must pass :file:`pythonXY.lib` to the "
"linker. To build two DLLs, spam and ni (which uses C functions found in "
"spam), you could use these commands::"
msgstr ""
"Windows ã§ DLL ã‚’ä½œæˆã™ã‚‹éš›ã¯ã€ :file:`pythonXY.lib` ã‚’ãƒªãƒ³ã‚«ã«æ¸¡ã•ã­ã°ãªã‚Šã¾ã›ã‚“ã€‚ä¾‹ãˆã°äºŒã¤ã® DLL ã€spam "
"ã¨ ni (spam ã®ä¸­ã«ã¯ C é–¢æ•°ãŒå…¥ã£ã¦ã„ã‚‹ã¨ã—ã¾ã™) ã‚’ãƒ“ãƒ«ãƒ‰ã™ã‚‹ã«ã¯ã€ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¾ã™::"

#: ../../extending/windows.rst:119
msgid ""
"The first command created three files: :file:`spam.obj`, :file:`spam.dll` "
"and :file:`spam.lib`.  :file:`Spam.dll` does not contain any Python "
"functions (such as :c:func:`PyArg_ParseTuple`), but it does know how to find"
" the Python code thanks to :file:`pythonXY.lib`."
msgstr ""
"æœ€åˆã®ã‚³ãƒãƒ³ãƒ‰ã§ã€ä¸‰ã¤ã®ãƒ•ã‚¡ã‚¤ãƒ«: :file:`spam.obj` ã€ :file:`spam.dll`  ãŠã‚ˆã³ :file:`spam.lib` "
"ãŒã§ãã¾ã™ã€‚ :file:`Spam.dll` ã«ã¯ (:c:func:`PyArg_ParseTuple` ã®ã‚ˆã†ãª) Python "
"é–¢æ•°ã¯å…¨ãå…¥ã£ã¦ã„ã¾ã›ã‚“ãŒã€ :file:`pythonXY.lib` ã®ãŠã‹ã’ã§ Python ã‚³ãƒ¼ãƒ‰ã‚’è¦‹ã¤ã‘ã‚‹ã“ã¨ã¯ã§ãã¾ã™ã€‚"

#: ../../extending/windows.rst:124
msgid ""
"The second command created :file:`ni.dll` (and :file:`.obj` and "
":file:`.lib`), which knows how to find the necessary functions from spam, "
"and also from the Python executable."
msgstr ""
"äºŒã¤ç›®ã®ã‚³ãƒãƒ³ãƒ‰ã§ã¯ã€ :file:`ni.dll` (ãŠã‚ˆã³ :file:`.obj` ã¨ :file:`.lib`) ãŒã§ãã€ã“ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ "
"spam ã¨ Python å®Ÿè¡Œå½¢å¼ä¸­ã®å¿…è¦ãªé–¢æ•°ã‚’ã©ã†ã‚„ã£ã¦è¦‹ã¤ã‘ã‚Œã°ã‚ˆã„ã‹çŸ¥ã£ã¦ã„ã¾ã™ã€‚"

#: ../../extending/windows.rst:128
msgid ""
"Not every identifier is exported to the lookup table.  If you want any other"
" modules (including Python) to be able to see your identifiers, you have to "
"say ``_declspec(dllexport)``, as in ``void _declspec(dllexport) "
"initspam(void)`` or ``PyObject _declspec(dllexport) *NiGetSpamData(void)``."
msgstr ""
"å…¨ã¦ã®è­˜åˆ¥å­ãŒãƒ«ãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ†ãƒ¼ãƒ–ãƒ«ä¸Šã«å…¬é–‹ã•ã‚Œã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä»–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« (Python è‡ªä½“ã‚’å«ã¿ã¾ã™) "
"ã‹ã‚‰ã€è‡ªä½œã®è­˜åˆ¥å­ãŒè¦‹ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ã«ã¯ã€``void _declspec(dllexport) initspam(void)`` ã‚„ "
"``PyObject _declspec(dllexport) *NiGetSpamData(void)`` "
"ã®ã‚ˆã†ã«ã€``_declspec(dllexport)`` ã§å®£è¨€ã›ã­ã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../extending/windows.rst:133
msgid ""
"Developer Studio will throw in a lot of import libraries that you do not "
"really need, adding about 100K to your executable.  To get rid of them, use "
"the Project Settings dialog, Link tab, to specify *ignore default "
"libraries*.  Add the correct :file:`msvcrtxx.lib` to the list of libraries."
msgstr ""
"Developer Studio ã¯å¿…è¦ã‚‚ãªãå¤§é‡ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ DLL ã«çªã£è¾¼ã‚“ã§ã€å®Ÿè¡Œå½¢å¼ã®ã‚µã‚¤ã‚ºã‚’ 100K "
"ã‚‚å¤§ããã—ã¦ã—ã¾ã„ã¾ã™ã€‚ä¸ç”¨ãªãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’è¿½ã„å‡ºã—ãŸã‘ã‚Œã°ã€ã€Œãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã€ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é¸ã³ã€ã€Œãƒªãƒ³ã‚«ã€ã‚¿ãƒ–ã«ç§»å‹•ã—ã¦ã€ "
"*ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ç„¡è¦–* ã‚’æŒ‡å®šã—ã¾ã™ã€‚ãã®å¾Œã€é©åˆ‡ãª :file:`msvcrtxx.lib` ã‚’ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒªã‚¹ãƒˆã«è¿½åŠ ã—ã¦ãã ã•ã„ã€‚"
