
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>3. データモデル &#8212; Python 3.8.3rc1 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.8.3rc1 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="next" title="4. 実行モデル" href="executionmodel.html" />
    <link rel="prev" title="2. 字句解析" href="lexical_analysis.html" />
    <link rel="canonical" href="https://docs.python.org/3/reference/datamodel.html" />
    
      
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. 実行モデル"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="lexical_analysis.html" title="2. 字句解析"
             accesskey="P">前へ</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.3rc1 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python 言語リファレンス</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" type="text" name="q" />
          <input type="submit" value="検索" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="data-model">
<span id="datamodel"></span><h1>3. データモデル<a class="headerlink" href="#data-model" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="section" id="objects-values-and-types">
<span id="objects"></span><h2>3.1. オブジェクト、値、および型<a class="headerlink" href="#objects-values-and-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-0"><em class="dfn">Objects</em> are Python's abstraction for data.  All data in a Python program
is represented by objects or by relations between objects. (In a sense, and in
conformance to Von Neumann's model of a &quot;stored program computer&quot;, code is also
represented by objects.)</p>
<span class="target" id="index-1"></span><p>すべての属性は、同一性 (identity)、型、値をもっています。 <em>同一性</em> は生成されたあとは変更されません。これはオブジェクトのアドレスのようなものだと考えられるかもしれません。 '<a class="reference internal" href="expressions.html#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a>' 演算子は2つのオブジェクトの同一性を比較します。 <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> 関数は同一性を表す整数を返します。</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> CPython では、<code class="docutils literal notranslate"><span class="pre">id(x)</span></code> は <code class="docutils literal notranslate"><span class="pre">x</span></code> が格納されているメモリ上のアドレスを返します。</p>
</div>
<p>オブジェクトの型はオブジェクトがサポートする操作 (例: <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> をサポートするか) と、オブジェクトが取りうる値を決定します。 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 関数はオブジェクトの型 (型自体もオブジェクトです) を返します。同一性と同じく、オブジェクトの型(<em class="dfn">type</em>) も変更不可能です。 <a class="footnote-reference" href="#id8" id="id1">[1]</a></p>
<p>オブジェクトによっては <em>値</em> を変更することが可能です。値を変更できるオブジェクトのことを <em>mutable</em> と呼びます。生成後に値を変更できないオブジェクトのことを <em>immutable</em> と呼びます。(mutable なオブジェクトへの参照を格納している immutableなコンテナオブジェクトの値は、その格納しているオブジェクトの値が変化した時に変化しますが、コンテナがどのオブジェクトを格納しているのかが変化しないのであれば immutable だと考えることができます。したがって、immutable かどうかは値が変更可能かどうかと完全に一致するわけではありません) オブジェクトが mutable かどうかはその型によって決まります。例えば、数値型、文字列型とタプル型のインスタンスは immutable で、dict や list は mutable です。</p>
<p id="index-2">オブジェクトを明示的に破壊することはできません; しかし、オブジェクトに到達不能 (unreachable) になると、ガベージコレクション (garbage-collection) によって処理されます。実装では、ごみ収集を遅らせたり、全く行わないようにすることができます --- 到達可能なオブジェクトをごみ収集処理してしまわないかぎり、どう実装するかは実装品質の問題です。</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> 現在の CPython 実装では参照カウント(reference-counting) 方式を使っており、(オプションとして) 循環参照を行っているごみオブジェクトを遅延検出します。この実装ではほとんどのオブジェクトを到達不能になると同時に処理することができますが、循環参照を含むごみオブジェクトの収集が確実に行われるよう保証しているわけではありません。循環参照を持つごみオブジェクト収集の制御については、 <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> モジュールを参照してください。 CPython以外の実装は別の方式を使っており、CPythonも将来は別の方式を使うかもしれません。オブジェクトが到達不能になったときに即座に終了処理されることに頼らないでください (ですからファイルは必ず明示的に閉じてください)。</p>
</div>
<p>実装のトレース機能やデバッグ機能を使えば、通常は収集されてしまうようなオブジェクトを生存させることがあるので注意してください。また、 '<a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>...<a class="reference internal" href="compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a>' 文を使って例外を捕捉できるようにすると、オブジェクトを生存させることがあります。</p>
<p>オブジェクトには、開かれたファイルやウィンドウといった、 &quot;外部 (external) の&quot; リソースへの参照を含むものがあります。これらのリソースは、オブジェクトがごみ収集された際に解放されるものと理解されていますが、ごみ収集が行われる保証はないので、こうしたオブジェクトは外部リソースを明示的に解放する方法、大抵は <code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code> メソッドも提供しています。こうしたオブジェクトは明示的に close するよう強く奨めます。この操作をする際には、'<a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>...<a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a>' 文や、 '<a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>' 文を使うと便利です。</p>
<p id="index-3">他のオブジェクトに対する参照をもつオブジェクトもあります; これらは <em>コンテナ (container)</em> と呼ばれます。コンテナオブジェクトの例として、タプル、リスト、および辞書が挙げられます。オブジェクトへの参照自体がコンテナの値の一部です。ほとんどの場合、コンテナの値というと、コンテナに入っているオブジェクトの値のことを指し、それらオブジェクトのアイデンティティではありません; しかしながら、コンテナの変更可能性について述べる場合、今まさにコンテナに入っているオブジェクトのアイデンティティのことを指します。したがって、 (タプルのように) 変更不能なオブジェクトが変更可能なオブジェクトへの参照を含む場合、その値が変化するのは変更可能なオブジェクトが変更された時、ということになります。</p>
<p>型はオブジェクトの動作のほとんど全てに影響します。オブジェクトのアイデンティティが重要かどうかでさえ、ある意味では型に左右されます: 変更不能な型では、新たな値を計算するような操作を行うと、実際には同じ型と値を持った既存のオブジェクトへの参照を返すことがありますが、変更可能なオブジェクトではそのような動作は起こりえません。例えば、 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">1;</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">1</span></code> とすると、 <code class="docutils literal notranslate"><span class="pre">a</span></code> と <code class="docutils literal notranslate"><span class="pre">b</span></code> は値 1 を持つ同じオブジェクトを参照するときもあるし、そうでないときもあります。これは実装に依存します。しかし、 <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">[];</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">[]</span></code> とすると、 <code class="docutils literal notranslate"><span class="pre">c</span></code> と <code class="docutils literal notranslate"><span class="pre">d</span></code> はそれぞれ二つの異なった、互いに一意な、新たに作成された空のリストを参照することが保証されています。 (<code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">[]</span></code> とすると、 <code class="docutils literal notranslate"><span class="pre">c</span></code> と <code class="docutils literal notranslate"><span class="pre">d</span></code> の両方に同じオブジェクトを代入します)</p>
</div>
<div class="section" id="the-standard-type-hierarchy">
<span id="types"></span><h2>3.2. 標準型の階層<a class="headerlink" href="#the-standard-type-hierarchy" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-4">以下は Python に組み込まれている型のリストです。(実装によって、C、Java、またはその他の言語で書かれた) 拡張モジュールで、その他の型が定義されていることがあります。新たな型 (有理数や、整数を効率的に記憶する配列、など) の追加は、たいてい標準ライブラリを通して提供されますが、将来のバージョンの Python では、型の階層構造にこのような追加がなされるかもしれません。</p>
<p id="index-5">以下に説明する型のいくつかには、 '特殊属性 (special attribute)' を列挙した段落があります。これらの属性は実装へのアクセス手段を提供するもので、一般的な用途に利用するためのものではありません。特殊属性の定義は将来変更される可能性があります。</p>
<dl class="docutils">
<dt>None</dt>
<dd><p class="first last" id="index-6">この型には単一の値しかありません。この値を持つオブジェクトはただ一つしか存在しません。このオブジェクトは組み込み名 <code class="docutils literal notranslate"><span class="pre">None</span></code> でアクセスされます。このオブジェクトは、様々な状況で値が存在しないことをしめします。例えば、明示的に値を返さない関数は <code class="docutils literal notranslate"><span class="pre">None</span></code> を返します。 <code class="docutils literal notranslate"><span class="pre">None</span></code> の真値 (truth value) は偽 (false) です。</p>
</dd>
<dt>NotImplemented</dt>
<dd><p class="first" id="index-7">この型には単一の値しかありません。この値を持つオブジェクトはただ一つしか存在しません。このオブジェクトは組み込み名 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> でアクセスされます。数値演算に関するメソッドや拡張比較 (rich comparison) メソッドは、被演算子が該当する演算を行うための実装をもたない場合、この値を返すべきです。(演算子によっては、インタプリタが関連のある演算を試したり、他の代替操作を行います。) 真値は真 (true) です。</p>
<p class="last">詳細は <a class="reference internal" href="../library/numbers.html#implementing-the-arithmetic-operations"><span class="std std-ref">算術演算の実装</span></a> を参照してください。</p>
</dd>
<dt>Ellipsis</dt>
<dd><p class="first last" id="index-8">この型には単一の値しかありません。この値を持つオブジェクトはただ一つしか存在しません。このオブジェクトはリテラル <code class="docutils literal notranslate"><span class="pre">...</span></code> または組み込み名 <code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code> でアクセスされます。真理値は真 (true)です。</p>
</dd>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Number" title="numbers.Number"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Number</span></code></a></dt>
<dd><p class="first" id="index-9">数値リテラルによって作成されたり、算術演算や組み込みの算術関数によって返されるオブジェクトです。数値オブジェクトは変更不能です; 一度値が生成されると、二度と変更されることはありません。Python の数値オブジェクトはいうまでもなく数学で言うところの数値と強く関係していますが、コンピュータ内で数値を表現する際に伴う制限を受けています。</p>
<p>Python は整数、浮動小数点数、複素数の間で区別を行っています:</p>
<dl class="last docutils">
<dt><a class="reference internal" href="../library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Integral</span></code></a> (整数)</dt>
<dd><p class="first" id="index-10">整数型は、整数(正の数および負の数)を表す数学的集合内における要素を表現する型です。</p>
<p>整数には 2 種類あります:</p>
<p>整数 (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>)</p>
<blockquote>
<div>無制限の範囲の数を表現しますが、利用可能な (仮想) メモリサイズの制限のみを受けます。シフト演算やマスク演算のために2進数表現を持つと想定されます。負の数は符号ビットが左に無限に延びているような錯覚を与える 2 の補数表現の変型で表されます。</div></blockquote>
<dl class="docutils">
<dt>ブール値 (<a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>)</dt>
<dd><p class="first last" id="index-11">真偽値の False と True を表します。<code class="docutils literal notranslate"><span class="pre">False</span></code> と <code class="docutils literal notranslate"><span class="pre">True</span></code> を表す 2 つのオブジェクトのみがブール値オブジェクトです。ブール型は整数型の派生型であり、ほとんどの状況でそれぞれ 0 と 1 のように振る舞いますが、例外として文字列に変換されたときはそれぞれ <code class="docutils literal notranslate"><span class="pre">&quot;False&quot;</span></code> および <code class="docutils literal notranslate"><span class="pre">&quot;True&quot;</span></code> という文字列が返されます。</p>
</dd>
</dl>
<p class="last" id="index-12">整数表現に関する規則は、負の整数を含むシフト演算やマスク演算において、最も有意義な解釈ができるように意図されています。</p>
</dd>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Real</span></code></a> (<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>) (実数)</dt>
<dd><p class="first last" id="index-13">この型は計算機レベルの倍精度浮動小数点数を表現します。表現可能な値の範囲やオーバーフローの扱いは計算機のアーキテクチャ（および、CやJavaによる実装）に従います。Pythonは単精度浮動小数点数をサポートしません。一般的に単精度浮動小数点数を使う理由はプロセッサーとメモリの使用を節約するためと説明されます。しかし、こうした節約はPythonでオブジェクトを扱う際のオーバーヘッドに比べれば微々たるものです。また、2種類の浮動小数点数型を持つことで複雑になる理由はありません。</p>
</dd>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Complex" title="numbers.Complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Complex</span></code></a> (<a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>)</dt>
<dd><p class="first last" id="index-14">この型は、計算機レベルで倍精度とされている浮動小数点を 2 つ一組にして複素数を表現します。浮動小数点について述べたのと同じ性質が当てはまります。複素数 <code class="docutils literal notranslate"><span class="pre">z</span></code> の実数部および虚数部は、それぞれ読み出し専用属性 <code class="docutils literal notranslate"><span class="pre">z.real</span></code> および <code class="docutils literal notranslate"><span class="pre">z.imag</span></code> で取り出すことができます。</p>
</dd>
</dl>
</dd>
<dt>シーケンス型 (sequence)</dt>
<dd><p class="first" id="index-15">この型は、有限の順序集合 (ordered set) を表現します。要素は非負の整数でインデクス化されています。組み込み関数 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> を使うと、シーケンスの要素数を返します。シーケンスの長さが <em>n</em> の場合、インデクスは 0, 1, ..., <em>n</em> -1 からなる集合です。シーケンス <em>a</em> の要素 <em>i</em> は <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> で選択します。</p>
<p id="index-16">シーケンスはスライス操作 (slice) もサポートしています: <code class="docutils literal notranslate"><span class="pre">a[i:j]</span></code> とすると、 <em>i</em> <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> <em>k</em> <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> <em>j</em> であるインデクス <em>k</em> をもつ全ての要素を選択します。式表現としてスライスを用いた場合、スライスは同じ型をもつ新たなシーケンスを表します。新たなシーケンス内では、インデクス集合が 0 から始まるようにインデクスの値を振りなおします。</p>
<p>シーケンスによっては、第三の &quot;ステップ (step)&quot; パラメタを持つ &quot;拡張スライス (extended slice)&quot; もサポートしています: <code class="docutils literal notranslate"><span class="pre">a[i:j:k]</span></code> は、 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">n*k</span></code>, <em>n</em> <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> <code class="docutils literal notranslate"><span class="pre">0</span></code> かつ <em>i</em> <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> <em>x</em> <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> <em>j</em> であるようなインデクス <em>x</em> を持つような <em>a</em> 全ての要素を選択します。</p>
<p>シーケンスは、変更可能なものか、そうでないかで区別されています:</p>
<dl class="last docutils">
<dt>変更不能なシーケンス (immutable sequence)</dt>
<dd><p class="first" id="index-17">変更不能なシーケンス型のオブジェクトは、一度生成されるとその値を変更することができません。 (オブジェクトに他のオブジェクトへの参照が入っている場合、参照されているオブジェクトは変更可能なオブジェクトでもよく、その値は変更される可能性があります; しかし、変更不能なオブジェクトが直接参照しているオブジェクトの集合自体は、変更することができません。)</p>
<p>以下の型は変更不能なシーケンス型です:</p>
<dl class="last docutils" id="index-18">
<dt>文字列型 (string)</dt>
<dd><p class="first last" id="index-19">文字列はUnicodeコードポイントを表現する値の配列です。文字列中のどのコードポイントも <code class="docutils literal notranslate"><span class="pre">U+0000</span> <span class="pre">-</span> <span class="pre">U+10FFFF</span></code> の範囲で表現されることができます。Pythonは <code class="xref c c-type docutils literal notranslate"><span class="pre">char</span></code> 型を持ちません。代わりに、文字列中のどのコードポイントも長さ ''1'' の文字列オブジェクトとして表現することができます。組み込み関数 <a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a> は文字列形式を0 - 10FFFFの範囲の整数に変換します。また、組み込み関数 <a class="reference internal" href="../library/functions.html#chr" title="chr"><code class="xref py py-func docutils literal notranslate"><span class="pre">chr()</span></code></a> は <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">-</span> <span class="pre">10FFFF</span></code> の範囲の整数を対応する長さ <code class="docutils literal notranslate"><span class="pre">1</span></code> の文字列に変換します。<a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a> はテキストエンコーディングを使うことで <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> を <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> に変換するために使うことができます。また、<a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> によりその逆が実行することができます。</p>
</dd>
<dt>タプル型 (tuple)</dt>
<dd><p class="first last" id="index-20">タプルの要素は任意の Python オブジェクトです。二つ以上の要素からなるタプルは、個々の要素を表現する式をカンマで区切って構成します。単一の要素からなるタプル (単集合 'singleton') を作るには、要素を表現する式の直後にカンマをつけます (単一の式だけではタプルを形成しません。これは、式をグループ化するのに丸括弧を使えるようにしなければならないからです)。要素の全くない丸括弧の対を作ると空のタプルになります。</p>
</dd>
<dt>bytes</dt>
<dd><p class="first last" id="index-21">bytes オブジェクトは不変な配列です。要素は 8-bit バイトで、 0 &lt;= x &lt; 256 の範囲の整数で表現されます。 (<code class="docutils literal notranslate"><span class="pre">b'abc'</span></code> のような) bytes リテラルや組み込みの <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes()</span></code></a> コンストラクタを使って bytes オブジェクトを作成できます。また、 bytes オブジェクトは <a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a> メソッドを通して文字列にデコードできます。</p>
</dd>
</dl>
</dd>
<dt>変更可能なシーケンス型 (mutable sequence)</dt>
<dd><p class="first" id="index-22">変更可能なシーケンスは、作成した後で変更することができます。変更可能なシーケンスでは、添字表記やスライス表記を使って指定された要素に代入を行うことができ、 <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> (delete) 文を使って要素を削除することができます。</p>
<p>Python に最初から組み込まれている変更可能なシーケンス型は、今のところ二つです:</p>
<dl class="docutils">
<dt>リスト型 (list)</dt>
<dd><p class="first last" id="index-23">リストの要素は任意の Python オブジェクトにできます。リストは、角括弧の中にカンマで区切られた式を並べて作ります。 (長さが 0 や 1 のシーケンスを作るために特殊な場合分けは必要ないことに注意してください。)</p>
</dd>
<dt>バイト配列</dt>
<dd><p class="first last" id="index-24">bytearray オブジェクトは変更可能な配列です。組み込みの <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytearray()</span></code></a> コンストラクタによって作成されます。変更可能なことを除けば (つまりハッシュ化できない)、 byte array は変更不能な <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> オブジェクトと同じインターフェースと機能を提供します。</p>
</dd>
</dl>
<p class="last" id="index-25">拡張モジュール <a class="reference internal" href="../library/array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a> や、 <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> モジュールには、さらなるミュータブルなシーケンス型の例があります。</p>
</dd>
</dl>
</dd>
<dt>集合型</dt>
<dd><p class="first" id="index-26">集合型は、順序のない、ユニークで不変なオブジェクトの有限集合を表現します。そのため、(配列の)添字を使ったインデックスアクセスはできません。ただし、イテレートは可能で、組み込み関数 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> は集合の要素数を返します。集合型の一般的な使い方は、集合に属しているかの高速なテスト、シーケンスからの重複の排除、共通集合・和集合・差・対称差といった数学的な演算の計算です。</p>
<p>集合の要素には、辞書のキーと同じ普遍性に関するルールが適用されます。数値型は通常の数値比較のルールに従うことに注意してください。もし2つの数値の比較結果が同値である(例えば、 <code class="docutils literal notranslate"><span class="pre">1</span></code> と <code class="docutils literal notranslate"><span class="pre">1.0</span></code>)なら、そのうちの1つのみを集合に含めることができます。</p>
<p>現在、2つの組み込み集合型があります:</p>
<dl class="last docutils">
<dt>集合型</dt>
<dd><p class="first last" id="index-27">可変な集合型です。組み込みの <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-func docutils literal notranslate"><span class="pre">set()</span></code></a> コンストラクタで作成され、後から <code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code> などのいくつかのメソッドで更新できます。</p>
</dd>
<dt>Frozen set 型</dt>
<dd><p class="first last" id="index-28">不変な集合型です。組み込みの <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-func docutils literal notranslate"><span class="pre">frozenset()</span></code></a> コンストラクタによって作成されます。 frozenset は不変で <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">ハッシュ可能</span></a> なので、別の集合型の要素になったり、辞書のキーにすることができます。</p>
</dd>
</dl>
</dd>
<dt>マッピング型 (mapping)</dt>
<dd><p class="first" id="index-29">任意のインデクス集合でインデクス化された、オブジェクトからなる有限の集合を表現します。添字表記 <code class="docutils literal notranslate"><span class="pre">a[k]</span></code> は、 <code class="docutils literal notranslate"><span class="pre">k</span></code> でインデクス指定された要素を <code class="docutils literal notranslate"><span class="pre">a</span></code> から選択します; 選択された要素は式の中で使うことができ、代入や <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> 文の対象にすることができます。組み込み関数 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> は、マッピング内の要素数を返します。</p>
<p>Python に最初から組み込まれているマッピング型は、今のところ一つだけです:</p>
<dl class="last docutils">
<dt>辞書型 (dictionary)</dt>
<dd><p class="first" id="index-30">ほぼ任意の値でインデクスされたオブジェクトからなる有限の集合を表します。
キー (key) として使えない値の唯一の型は、リストや辞書、そしてオブジェクトの同一性でなく値で比較されるその他の変更可能な型です。
これは、辞書型を効率的に実装する上で、キーのハッシュ値が不変である必要があるためです。
数値型をキーに使う場合、キー値は通常の数値比較における規則に従います: 二つの値が等しくなる場合 (例えば <code class="docutils literal notranslate"><span class="pre">1</span></code> と <code class="docutils literal notranslate"><span class="pre">1.0</span></code>)、互いに同じ辞書のエントリを表すインデクスとして使うことができます。</p>
<p>辞書は挿入の順序を保持します。つまり、キーは辞書に追加された順番に生成されていきます。既存のキーを置き換えても、キーの順序は変わりません。キーを削除したのちに再挿入すると、元の場所ではなく辞書の最後に追加されます。</p>
<p>辞書は変更可能な型です; 辞書は <code class="docutils literal notranslate"><span class="pre">{...}</span></code> 表記で生成します (<a class="reference internal" href="expressions.html#dict"><span class="std std-ref">辞書表示</span></a> を参照してください)。</p>
<p id="index-31">拡張モジュール <a class="reference internal" href="../library/dbm.html#module-dbm.ndbm" title="dbm.ndbm: The standard &quot;database&quot; interface, based on ndbm. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm.ndbm</span></code></a> 、 <a class="reference internal" href="../library/dbm.html#module-dbm.gnu" title="dbm.gnu: GNU's reinterpretation of dbm. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm.gnu</span></code></a> は、 <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> モジュールのように、別のマッピング型の例を提供しています。</p>
<div class="last versionchanged">
<p><span class="versionmodified">バージョン 3.7 で変更: </span>Pythonのバージョン3.6では、辞書は挿入順序を保持しませんでした。CPython 3.6では挿入順序は保持されましたが、それは策定された言語の仕様というより、その当時の実装の細部とみなされていました。</p>
</div>
</dd>
</dl>
</dd>
<dt>呼び出し可能型 (callable type)</dt>
<dd><p class="first" id="index-32">関数呼び出し操作 (<a class="reference internal" href="expressions.html#calls"><span class="std std-ref">呼び出し (call)</span></a> 参照) を行うことができる型です:</p>
<dl class="last docutils">
<dt>ユーザ定義関数 (user-defined function)</dt>
<dd><p class="first" id="index-33">ユーザ定義関数オブジェクトは、関数定義を行うことで生成されます (<a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">関数定義</span></a> 参照)。関数は、仮引数 (formal parameter) リストと同じ数の要素が入った引数リストとともに呼び出されます。</p>
<p>特殊属性:</p>
<table border="1" class="docutils" id="index-34">
<colgroup>
<col width="37%" />
<col width="46%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">属性</th>
<th class="head">意味</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code></td>
<td>関数のドキュメンテーション文字列で、ドキュメンテーションがない場合は <code class="docutils literal notranslate"><span class="pre">None</span></code> になります。サブクラスに継承されません。</td>
<td>書き込み可能</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a></td>
<td>関数の名前です。</td>
<td>書き込み可能</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../library/stdtypes.html#definition.__qualname__" title="definition.__qualname__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__qualname__</span></code></a></td>
<td><p class="first">関数の <a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">qualified name</span></a> です。</p>
<div class="last versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</td>
<td>書き込み可能</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code></td>
<td>関数が定義されているモジュールの名前です。モジュール名がない場合は <code class="docutils literal notranslate"><span class="pre">None</span></code> になります。</td>
<td>書き込み可能</td>
</tr>
<tr class="row-even"><td><code class="xref py py-attr docutils literal notranslate"><span class="pre">__defaults__</span></code></td>
<td>デフォルト値を持つ引数に対するデフォルト値が収められたタプルで、デフォルト値を持つ引数がない場合には <code class="docutils literal notranslate"><span class="pre">None</span></code> になります</td>
<td>書き込み可能</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-attr docutils literal notranslate"><span class="pre">__code__</span></code></td>
<td>コンパイルされた関数本体を表現するコードオブジェクトです。</td>
<td>書き込み可能</td>
</tr>
<tr class="row-even"><td><code class="xref py py-attr docutils literal notranslate"><span class="pre">__globals__</span></code></td>
<td>関数のグローバル変数の入った辞書 (への参照) です --- この辞書は、関数が定義されているモジュールのグローバルな名前空間を決定します。</td>
<td>読み出し専用</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a></td>
<td>任意の関数属性をサポートするための名前空間が収められています。</td>
<td>書き込み可能</td>
</tr>
<tr class="row-even"><td><code class="xref py py-attr docutils literal notranslate"><span class="pre">__closure__</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">None</span></code> または関数の個々の自由変数 (引数以外の変数) に対して値を束縛しているセル (cell) 群からなるタプルになります。
<code class="docutils literal notranslate"><span class="pre">cell_contents</span></code> 属性についての情報は下を参照してください。</td>
<td>読み出し専用</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code></td>
<td>パラメータの注釈が入った辞書です。辞書のキーはパラメータ名で、返り値の注釈がある場合は、<code class="docutils literal notranslate"><span class="pre">'return'</span></code> がそのキーとなります。</td>
<td>書き込み可能</td>
</tr>
<tr class="row-even"><td><code class="xref py py-attr docutils literal notranslate"><span class="pre">__kwdefaults__</span></code></td>
<td>キーワード専用パラメータのデフォルト値を含む辞書です。</td>
<td>書き込み可能</td>
</tr>
</tbody>
</table>
<p>「書き込み可能」とラベルされている属性のほとんどは、代入された値の型をチェックします。</p>
<p>関数オブジェクトはまた、任意の属性を設定したり取得したりできます。この機能は、例えば関数にメタデータを付与したい場合などに使えます。関数の get や set には、通常のドット表記を使います。 <em>現在の実装では、ユーザ定義の関数でのみ属性をサポートしているので注意して下さい。組み込み関数の属性は将来サポートする予定です。</em></p>
<p>セルオブジェクトは属性 <code class="docutils literal notranslate"><span class="pre">cell_contents</span></code> を持っています。
これはセルの値を設定するのに加えて、セルの値を得るのにも使えます。</p>
<p class="last">関数定義に関するその他の情報は関数のコードオブジェクトから得られます。後述の内部型 (internal type) に関する説明を参照してください。
<a class="reference internal" href="../library/types.html#types.CellType" title="types.CellType"><code class="xref py py-data docutils literal notranslate"><span class="pre">cell</span></code></a> 型には <a class="reference internal" href="../library/types.html#module-types" title="types: Names for built-in types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">types</span></code></a> モジュールからアクセスできます。</p>
</dd>
<dt>インスタンスメソッド</dt>
<dd><p class="first" id="index-35">インスタンスメソッドオブジェクトは、クラス、クラスインスタンスと任意の呼び出し可能オブジェクト (通常はユーザ定義関数) を結びつけます。</p>
<p id="index-36">読み出し専用の特殊属性: <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> はクラスインスタンスオブジェクトで、 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code> は関数オブジェクトです;
<code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> はメソッドのドキュメンテーション文字列 (<code class="docutils literal notranslate"><span class="pre">__func__.__doc__</span></code> と同じ) です;
<a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> はメソッドの名前 (<code class="docutils literal notranslate"><span class="pre">__func__.__name__</span></code> と同じ) です;
<code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> はメソッドが定義されたモジュールの名前か、モジュール名がない場合は <code class="docutils literal notranslate"><span class="pre">None</span></code> になります。</p>
<p>メソッドもまた、根底にある関数オブジェクトの任意の関数属性に (値の設定はできませんが) アクセスできます。</p>
<p>クラスの属性を (場合によってはそのクラスのインスタンスを介して) 取得するとき、その属性がユーザ定義の関数オブジェクトまたはクラスメソッドオブジェクトであれば、ユーザ定義メソッドオブジェクトが生成されることがあります。</p>
<p>クラスからインスタンスを経由してユーザ定義関数オブジェクトを取得することによってインスタンスメソッドオブジェクトが生成されたとき、 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 属性はそのインスタンスで、このメソッドオブジェクトは束縛されている (bound) といいます。新しいメソッドの <code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code> 属性はもとの関数オブジェクトです。</p>
<p>クラスやインスタンスからクラスメソッドオブジェクトを取得することによってインスタンスメソッドオブジェクトが生成されたとき、 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 属性はクラスそのもので、 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code> 属性はクラスメソッドの根底にある関数オブジェクトです。</p>
<p>インスタンスメソッドオブジェクトが呼び出される際、根底にある関数 (<code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code>) が呼び出されます。このとき、クラスインスタンス (<code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code>) が引数リストの先頭に挿入されます。例えば、 <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> を関数 <code class="xref py py-meth docutils literal notranslate"><span class="pre">f()</span></code> の定義を含むクラス、 <code class="docutils literal notranslate"><span class="pre">x</span></code> を <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> のインスタンスとすると、 <code class="docutils literal notranslate"><span class="pre">x.f(1)</span></code> の呼び出しは <code class="docutils literal notranslate"><span class="pre">C.f(x,</span> <span class="pre">1)</span></code> の呼び出しと同じです。</p>
<p>クラスメソッドオブジェクトからインスタンスメソッドオブジェクトが導出される際、 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> に記憶されている &quot;クラスインスタンス&quot; は実際はクラスそのものなので、 <code class="docutils literal notranslate"><span class="pre">x.f(1)</span></code> や <code class="docutils literal notranslate"><span class="pre">C.f(1)</span></code> の呼び出しは、根底にある関数を <code class="docutils literal notranslate"><span class="pre">f</span></code> として <code class="docutils literal notranslate"><span class="pre">f(C,1)</span></code> の呼び出しと等価です。</p>
<p class="last">なお、関数オブジェクトからインスタンスメソッドオブジェクトへの変換は、インスタンスから属性が取り出されるたびに行われます。場合によっては、属性をローカル変数に代入しておき、そのローカル変数を呼び出すようにするのが効果的な最適化になります。また、上記の変換はユーザ定義関数に対してのみ行われます; その他の呼び出し可能オブジェクト (および呼び出し可能でない全てのオブジェクト) は、変換されずに取り出されます。それから、クラスインスタンスの属性になっているユーザ定義関数は、束縛メソッドに変換されません; 変換されるのは、関数がクラスの属性である場合 <em>だけ</em> です。</p>
</dd>
<dt>ジェネレータ関数 (generator function)</dt>
<dd><p class="first last" id="index-37"><a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 文 (<a class="reference internal" href="simple_stmts.html#yield"><span class="std std-ref">yield 文</span></a> の節を参照) を使う関数もしくはメソッドは <em class="dfn">ジェネレータ関数</em> と呼ばれます。
そのような関数が呼び出されたときは常に、関数の本体を実行するのに使えるイテレータオブジェクトを返します:
イテレータの <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iterator.__next__()</span></code></a> メソッドを呼び出すと、 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 文を使って値が提供されるまで関数を実行します。
関数の <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 文を実行するか終端に達したときは、 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 例外が送出され、イテレータが返すべき値の最後まで到達しています。</p>
</dd>
<dt>コルーチン関数 (coroutine function)</dt>
<dd><p class="first last" id="index-38"><a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> を使用して定義された関数やメソッドを <em class="dfn">コルーチン関数 (coroutine function)</em> と呼びます。
呼び出された時、そのような関数は <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a> オブジェクトを返します。
コルーチン関数は <a class="reference internal" href="compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> や <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 文だけでなく <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 式を持つことが出来ます。
<a class="reference internal" href="#coroutine-objects"><span class="std std-ref">コルーチンオブジェクト</span></a> を参照してください。</p>
</dd>
<dt>非同期ジェネレータ関数 (asynchronous generator function)</dt>
<dd><p class="first" id="index-39"><a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> を使って定義され、 <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 文を使用している関数やメソッドを <em class="dfn">asynchronous generator function</em> と呼びます。
そのような関数は、呼び出されたとき、非同期イテレータオブジェクトを返します。
このオブジェクトは <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 文で関数の本体を実行するのに使えます。</p>
<p class="last">非同期イテレータの <code class="xref py py-meth docutils literal notranslate"><span class="pre">aiterator.__anext__()</span></code> メソッドを呼び出すと、他の処理が待たされているときに、 <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 式を使い値を提供するところまで処理を進める <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> を返します。
その関数が空の <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 文を実行する、もしくは処理の終わりに到達したときは、 <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> 例外が送出され、非同期イテレータは出力すべき値の最後に到達したことになります。</p>
</dd>
<dt>組み込み関数 (built-in function)</dt>
<dd><p class="first last" id="index-40">組み込み関数オブジェクトはC関数へのラッパーです。
組み込み関数の例は <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> や <a class="reference internal" href="../library/math.html#math.sin" title="math.sin"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.sin()</span></code></a> (<a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> は標準の組み込みモジュール) です。
引数の数や型は C 関数で決定されています。
読み出し専用の特殊属性: <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> は関数のドキュメンテーション文字列です。
ドキュメンテーションがない場合は <code class="docutils literal notranslate"><span class="pre">None</span></code> になります;
<a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> は関数の名前です;
<code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> は <code class="docutils literal notranslate"><span class="pre">None</span></code> に設定されています (組み込みメソッドの節も参照してください);
<code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> は、関数が定義されているモジュールの名前です。
モジュール名がない場合は <code class="docutils literal notranslate"><span class="pre">None</span></code> になります。</p>
</dd>
<dt>組み込みメソッド (built-in method)</dt>
<dd><p class="first last" id="index-41">実際には組み込み関数を別の形で隠蔽したもので、こちらの場合には C 関数に渡される何らかのオブジェクトを非明示的な外部引数として持っています。組み込みメソッドの例は、 <em>alist</em> をリストオブジェクトとしたときの <code class="docutils literal notranslate"><span class="pre">alist.append()</span></code> です。この場合には、読み出し専用の属性 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> は <em>alist</em> で表されるオブジェクトになります。</p>
</dd>
<dt>クラス</dt>
<dd>クラスは呼び出し可能です。そのオブジェクトは通常、そのクラスの新たなインスタンスのファクトリとして振舞いますが、 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> をオーバーライドして、バリエーションを持たせることもできます。呼び出しに使われた引数は、 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> と、典型的な場合では <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> に渡され、新たなインスタンスの初期化に使われます。</dd>
<dt>クラスのインスタンス</dt>
<dd>任意のクラスのインスタンスは、クラスで <a class="reference internal" href="#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> メソッドを定義することで呼び出し可能になります。</dd>
</dl>
</dd>
<dt>モジュール (module)</dt>
<dd><p class="first" id="index-42">モジュールは Python コードの基礎的な構成単位で、 <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 文あるいは <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> や組み込みの <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> のような関数を呼び出すことで起動される <a class="reference internal" href="import.html#importsystem"><span class="std std-ref">import system</span></a> によって作成されます。モジュールオブジェクトは、辞書オブジェクト (これは、モジュール内で定義された関数の <code class="docutils literal notranslate"><span class="pre">__globals__</span></code> 属性から参照される辞書です) で実装された名前空間を持っています。属性の参照は、この辞書の検索に翻訳されます。例えば、 <code class="docutils literal notranslate"><span class="pre">m.x</span></code> は <code class="docutils literal notranslate"><span class="pre">m.__dict__[&quot;x&quot;]</span></code> と等価です。モジュールオブジェクトは、モジュールの初期化に使われるコードオブジェクトを含んでいません (初期化が終わればもう必要ないからです)。</p>
<p>属性の代入を行うと、モジュールの名前空間辞書の内容を更新します。例えば、 <code class="docutils literal notranslate"><span class="pre">m.x</span> <span class="pre">=</span> <span class="pre">1</span></code> は <code class="docutils literal notranslate"><span class="pre">m.__dict__[&quot;x&quot;]</span> <span class="pre">=</span> <span class="pre">1</span></code> と同じです。</p>
<p id="index-43">定義済みの (書き込み可能な) 属性: <a class="reference internal" href="import.html#__name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> はモジュールの名前です;  <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> は関数のドキュメンテーション文字列です。ドキュメンテーションがない場合は <code class="docutils literal notranslate"><span class="pre">None</span></code> になります; <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> (オプショナル) はモジュールの本体を実行しているときに収集した <a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">変数アノテーション</span></a> が入った辞書です; モジュールがファイルからロードされた場合、 <a class="reference internal" href="import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> はロードされたモジュールファイルのパス名です。インタプリタに静的にリンクされている C モジュールのような特定の種類のモジュールでは、 <a class="reference internal" href="import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> 属性は存在しないかもしれません; 共有ライブラリから動的にロードされた拡張モジュールの場合、この属性は 共有ライブラリファイルのパス名になります。</p>
<p id="index-44">読み出し専用の特殊属性: <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> はモジュールの名前空間で、辞書オブジェクトです。</p>
<div class="impl-detail last compound">
<p><strong>CPython implementation detail:</strong> CPython がモジュール辞書を削除する方法により、モジュール辞書が生きた参照を持っていたとしてもその辞書はモジュールがスコープから外れた時に削除されます。これを避けるには、辞書をコピーするか、辞書を直接使っている間モジュールを保持してください。</p>
</div>
</dd>
<dt>カスタムクラス型</dt>
<dd><p class="first">カスタムクラス型は通常、クラス定義 (<a class="reference internal" href="compound_stmts.html#class"><span class="std std-ref">クラス定義</span></a> 参照) で生成されます。クラスは辞書オブジェクトで実装された名前空間を持っています。クラス属性の参照は、この辞書に対する探索 (lookup) に翻訳されます。例えば、 <code class="docutils literal notranslate"><span class="pre">C.x</span></code> は <code class="docutils literal notranslate"><span class="pre">C.__dict__[&quot;x&quot;]</span></code> に翻訳されます (ただし、属性参照の意味を変えられる幾つかのフックがあります)。属性がこの探索で見つからないとき、その基底クラスで探索が続けられます。基底クラスのこの探索は、C3 メソッド解決順序 (MRO=method resolution order) を利用していて、複数の継承経路が共通の祖先につながる「ダイアモンド」継承構造があっても正しく動作します。 C3 MRO についてのより詳細な情報は、 2.3リリースに付属するドキュメント <a class="reference external" href="https://www.python.org/download/releases/2.3/mro/">https://www.python.org/download/releases/2.3/mro/</a> にあります。</p>
<p id="index-45">クラス (<code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> とします) 属性参照がクラスメソッドオブジェクトを返そうとするときには、 そのオブジェクトは <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 属性が <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> であるようなインスタンスメソッドオブジェクトに変換されます。
静的メソッドオブジェクトを返そうとするときには、静的メソッドオブジェクトでラップされたオブジェクトに変換されます。
<a class="reference internal" href="#descriptors"><span class="std std-ref">デスクリプタ (descriptor) の実装</span></a> 節を参照すると、また別の理由でクラスから取り出した属性と実際に <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> に保存されているものが異なることがあるのが分かります。</p>
<p id="index-46">クラス属性を代入すると、そのクラスの辞書だけが更新され、基底クラスの辞書は更新しません。</p>
<p id="index-47">クラスオブジェクトを呼び出す (上記を参照) と、クラスインスタンスを生成します (下記を参照)。</p>
<p class="last" id="index-48">特殊属性: <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> はクラス名です;
<code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> はクラスが定義されたモジュール名です;
<a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> はクラスが持つ名前空間が入った辞書です;
<a class="reference internal" href="../library/stdtypes.html#class.__bases__" title="class.__bases__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__bases__</span></code></a> は基底クラスからなるタプルで、基底クラスのリストに表れる順序で並んでいます;
<code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> はクラスのドキュメント文字列で、未定義の場合は None です;
<code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> (オプショナル) はクラスの本体を実行しているときに収集した <a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">変数アノテーション</span></a> が入った辞書です。</p>
</dd>
<dt>クラスインスタンス (class instance)</dt>
<dd><p class="first" id="index-49">クラスインスタンスは、クラスオブジェクト (上記参照) を呼び出して生成します。
クラスインスタンスは辞書で実装された名前空間を持っており、属性参照の時にはまずこの辞書が探索されます。
ここで属性が見つからず、インスタンスのクラスにその名前の属性があるときは、続けてクラス属性を検索します。
見つかったクラス属性がユーザ定義関数オブジェクトだった場合、クラスインスタンスを <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 属性とするインスタンスメソッドオブジェクトに変換します。
静的メソッドオブジェクトやクラスメソッドオブジェクトも同様に変換されます;
上記の &quot;クラス&quot; を参照してください。
<a class="reference internal" href="#descriptors"><span class="std std-ref">デスクリプタ (descriptor) の実装</span></a> 節を参照すると、また別の理由でインスタンスを通してクラスから取り出した属性と実際に <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> に保存されているものが異なることがあるのが分かります。
クラス属性が見つからず、かつオブジェクトのクラスが <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> メソッドを持っている場合は、探索の義務を果たすためにこのメソッドが呼び出されます。</p>
<p id="index-50">属性の代入や削除を行うと、インスタンスの辞書を更新しますが、クラスの辞書を更新することはありません。クラスで <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> や <a class="reference internal" href="#object.__delattr__" title="object.__delattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delattr__()</span></code></a> メソッドが定義されている場合、直接インスタンスの辞書を更新する代わりにこれらのメソッドが呼び出されます。</p>
<p id="index-51">クラスインスタンスは、ある特定の名前のメソッドを持っている場合、数値型やシーケンス型、あるいはマップ型のように振舞うことができます。 <a class="reference internal" href="#specialnames"><span class="std std-ref">特殊メソッド名</span></a> を参照してください。</p>
<p class="last" id="index-52">特殊属性: <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> は属性の辞書です; <a class="reference internal" href="../library/stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> はインスタンスのクラスです。</p>
</dd>
<dt>I/O オブジェクト (ファイルオブジェクトの別名)</dt>
<dd><p class="first" id="index-53"><a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a> は開かれたファイルを表します。ファイルオブジェクトを作るための様々なショートカットがあります: <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 組み込み関数、 <a class="reference internal" href="../library/os.html#os.popen" title="os.popen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.popen()</span></code></a> 、 <a class="reference internal" href="../library/os.html#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fdopen()</span></code></a> 、ソケットオブジェクトの <a class="reference internal" href="../library/socket.html#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code></a> メソッド (あるいは拡張モジュールから提供される他の関数やメソッド) 。</p>
<p class="last">オブジェクト <code class="docutils literal notranslate"><span class="pre">sys.stdin</span></code> 、 <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> および <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> は、インタプリタの標準入力、標準出力、および標準エラー出力ストリームに対応するファイルオブジェクトに初期化されます。これらはすべてテキストモードで開かれ、 <a class="reference internal" href="../library/io.html#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOBase</span></code></a> 抽象クラスによって定義されたインタフェースに従います。</p>
</dd>
<dt>内部型 (internal type)</dt>
<dd><p class="first" id="index-54">インタプリタが内部的に使っているいくつかの型は、ユーザに公開されています。これらの定義は将来のインタプリタのバージョンでは変更される可能性がありますが、ここでは記述の完全性のために触れておきます。</p>
<dl class="docutils" id="index-55">
<dt>コードオブジェクト</dt>
<dd><p class="first">コードオブジェクトは <em>バイトコンパイルされた (byte-compiled)</em> 実行可能な Python コード、別名 <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">バイトコード</span></a> を表現します。コードオブジェクトと関数オブジェクトの違いは、関数オブジェクトが関数のグローバル変数 (関数を定義しているモジュールのグローバル) に対して明示的な参照を持っているのに対し、コードオブジェクトにはコンテキストがないということです; また、関数オブジェクトではデフォルト引数値を記憶できますが、コードオブジェクトではできません (実行時に計算される値を表現するため)。関数オブジェクトと違い、コードオブジェクトは変更不可能で、変更可能なオブジェクトへの参照を (直接、間接に関わらず) 含みません。</p>
<p id="index-56">Special read-only attributes: <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_name</span></code> gives the function name;
<code class="xref py py-attr docutils literal notranslate"><span class="pre">co_argcount</span></code> is the total number of positional arguments
(including positional-only arguments and arguments with default values);
<code class="xref py py-attr docutils literal notranslate"><span class="pre">co_posonlyargcount</span></code> is the number of positional-only arguments
(including arguments with default values); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_kwonlyargcount</span></code> is
the number of keyword-only arguments (including arguments with default
values); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_nlocals</span></code> is the number of local variables used by the
function (including arguments); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_varnames</span></code> is a tuple containing
the names of the local variables (starting with the argument names);
<code class="xref py py-attr docutils literal notranslate"><span class="pre">co_cellvars</span></code> is a tuple containing the names of local variables
that are referenced by nested functions; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_freevars</span></code> is a tuple
containing the names of free variables; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_code</span></code> is a string
representing the sequence of bytecode instructions; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_consts</span></code> is
a tuple containing the literals used by the bytecode; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_names</span></code> is
a tuple containing the names used by the bytecode; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_filename</span></code> is
the filename from which the code was compiled; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_firstlineno</span></code> is
the first line number of the function; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_lnotab</span></code> is a string
encoding the mapping from bytecode offsets to line numbers (for details
see the source code of the interpreter); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_stacksize</span></code> is the
required stack size; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> is an integer encoding a number
of flags for the interpreter.</p>
<p id="index-57">以下のフラグビットが <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> で定義されています: <code class="docutils literal notranslate"><span class="pre">0x04</span></code> ビットは、関数が <code class="docutils literal notranslate"><span class="pre">*arguments</span></code> 構文を使って任意の数の位置引数を受理できる場合に立てられます; <code class="docutils literal notranslate"><span class="pre">0x08</span></code> ビットは、関数が <code class="docutils literal notranslate"><span class="pre">**keywords</span></code> 構文を使ってキーワード引数を受理できる場合に立てられます; <code class="docutils literal notranslate"><span class="pre">0x20</span></code> ビットは、関数がジェネレータである場合に立てられます。</p>
<p>将来機能 (future feature) 宣言 (<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">division</span></code>) もまた、 <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> のビットを立てることで、コードオブジェクトが特定の機能を有効にしてコンパイルされていることを示します: <code class="docutils literal notranslate"><span class="pre">0x2000</span></code> ビットは、関数が将来機能を有効にしてコンパイルされている場合に立てられます; 以前のバージョンの Python では、 <code class="docutils literal notranslate"><span class="pre">0x10</span></code> および <code class="docutils literal notranslate"><span class="pre">0x1000</span></code> ビットが使われていました。</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> のその他のビットは将来に内部的に利用するために予約されています。</p>
<p class="last" id="index-58">コードオブジェクトが関数を表現している場合、 <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_consts</span></code> の最初の要素は関数のドキュメンテーション文字列になります。ドキュメンテーション文字列が定義されていない場合には <code class="docutils literal notranslate"><span class="pre">None</span></code> になります。</p>
</dd>
</dl>
<dl class="docutils" id="frame-objects">
<dt>フレーム (frame) オブジェクト</dt>
<dd><p class="first" id="index-59">フレームオブジェクトは実行フレーム (execution frame) を表します。
実行フレームはトレースバックオブジェクト (下記参照) 内に出現し、登録されたトレース関数に渡されます。</p>
<p id="index-60">読み出し専用の特殊属性: <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_back</span></code> は直前のスタックフレーム (呼び出し側の方向) で、それがスタックフレームの最下段なら <code class="docutils literal notranslate"><span class="pre">None</span></code> です; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_code</span></code> はそのフレームで実行されているコードオブジェクトです; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_locals</span></code> はローカル変数の探索に使われる辞書です; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_globals</span></code> はグローバル変数に使われます; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_builtins</span></code> は組み込みの (Python 固有の) 名前に使われます; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_lasti</span></code> は厳密な命令コード (コードオブジェクトのバイトコード文字列へのインデックス) です。</p>
<p id="index-61">特別な書き込み可能な属性: <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace</span></code> は <code class="docutils literal notranslate"><span class="pre">None</span></code> でない場合は、コードの実行中に様々なイベントで呼び出される関数です (デバッガが利用します)。
通常は、ソースの新しい行ごとにイベントが発行されますが、 <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace_lines</span></code> を <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> に設定することでイベントの発行を無効化できます。</p>
<p>実装は <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace_opcodes</span></code> を <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> に設定して、命令コードごとのイベントの要求を許可している <em>かもしれません</em> 。
これは、トレース関数によって送出された例外がトレースされている関数に漏れ出た場合、未定義なインタープリタの振る舞いにつながるかもしれないことに注意してください。</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">f_lineno</span></code> はフレーム中における現在の行番号です --- トレース関数 (trace function) 側でこの値に書き込みを行うと、指定した行にジャンプします (最下段の実行フレームにいるときのみ)。デバッガでは、 f_fileno を書き込むことで、ジャンプ命令 (Set Next Statement 命令とも) を実装できます。</p>
<p>フレームオブジェクトはメソッドを一つサポートします:</p>
<dl class="last method">
<dt id="frame.clear">
<code class="descclassname">frame.</code><code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frame.clear" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドはフレームが保持しているローカル変数への参照を全て削除します。
また、フレームがジェネレータに属していた場合は、ジェネレータにも終了処理が行われます。
これによってフレームオブジェクトを含んだ循環参照が解消されるようになります (例えば、例外を捕捉し、後で使うためにトレースバックを保存する場合)。</p>
<p>フレームが現在実行中の場合 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> が送出されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

</dd>
</dl>
<dl class="last docutils" id="traceback-objects">
<dt>トレースバック (traceback) オブジェクト</dt>
<dd><p class="first" id="index-62">トレースバックオブジェクトは例外のスタックトレースを表現します。
トレースバックオブジェクトは例外が起きたときに暗黙的に作成されたり、 <a class="reference internal" href="../library/types.html#types.TracebackType" title="types.TracebackType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.TracebackType</span></code></a> を呼び出して明示的にも作成されたりします。</p>
<p>暗黙的に作成されたトレースバックでは、例外ハンドラの検索が実行スタックを戻っていく際、戻ったレベル毎に、トレースバックオブジェクトが現在のトレースバックの前に挿入されます。
例外ハンドラに入ると、スタックトレースをプログラム側で利用できるようになります。(<a class="reference internal" href="compound_stmts.html#try"><span class="std std-ref">try 文</span></a> を参照。)
トレースバックは、 <code class="docutils literal notranslate"><span class="pre">sys.exc_info()</span></code> が返すタプルの三番目の要素や、捕捉した例外の <code class="docutils literal notranslate"><span class="pre">__traceback__</span></code> 属性として得られます。</p>
<p>プログラムに適切なハンドラがないとき、スタックトレースは (うまく書式化されて) 標準エラーストリームに書き出されます; インタプリタが対話的に実行されている場合、 <code class="docutils literal notranslate"><span class="pre">sys.last_traceback</span></code> として得ることもできます。</p>
<p>明示的に作成されたトレースバックでは、 <code class="docutils literal notranslate"><span class="pre">tb_next</span></code> 属性がリンクされスタックトレース全体を形成する方法の決定は、トレースバックの作成者に任されます。</p>
<p id="index-63">読み出し専用の特殊属性: <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_frame</span></code> は現在のレベルにおける実行フレームを指します; <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_lineno</span></code> は例外の発生した行番号です; <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_lasti</span></code> は厳密な命令コードです。トレースバック内の行番号や最後に実行された命令は、 <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 文内で例外が発生し、かつ対応する <a class="reference internal" href="compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 節や <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 節がない場合には、フレームオブジェクト内の行番号とは異なるかもしれません。</p>
<p id="index-64">書き込み可能な特殊属性: <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_next</span></code> はスタックトレースの次のレベル (例外が発生したフレームの方向) か、あるいは次のレベルが無い場合は <code class="docutils literal notranslate"><span class="pre">None</span></code> です。</p>
<div class="last versionchanged">
<p><span class="versionmodified">バージョン 3.7 で変更: </span>トレースバックオブジェクトは Python コードから明示的にインスタンス化できるようになり、既存のインスタンスの <code class="docutils literal notranslate"><span class="pre">tb_next</span></code> 属性は更新できるようになりました。</p>
</div>
</dd>
<dt>スライス (slice) オブジェクト</dt>
<dd><p class="first" id="index-65">スライスオブジェクトは、 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> メソッドのためのスライスを表すのに使われます。スライスオブジェクトは組み込みの <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-func docutils literal notranslate"><span class="pre">slice()</span></code></a> 関数でも生成されます。</p>
<p id="index-66">読み出し専用の特殊属性: <code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code> は下限です; <code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code> は上限です; <code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code> はステップの値です; それぞれ省略された場合は <code class="docutils literal notranslate"><span class="pre">None</span></code> となっています。これらの属性は任意の型を持てます。</p>
<p>スライスオブジェクトはメソッドを一つサポートします:</p>
<dl class="last method">
<dt id="slice.indices">
<code class="descclassname">slice.</code><code class="descname">indices</code><span class="sig-paren">(</span><em>self</em>, <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#slice.indices" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは単一の整数引数 <em>length</em> を取り、スライスオブジェクトが <em>length</em> 要素のシーケンスに適用されたときに表現する、スライスに関する情報を計算します。このメソッドは 3 つの整数からなるタプルを返します; それぞれ <em>start</em> および <em>stop</em> のインデックスと、<em>step</em> すなわちスライスのまたぎ幅です。インデックス値がないか、範囲外の値であれば、通常のスライスと変わらないやりかたで扱われます。</p>
</dd></dl>

</dd>
<dt>静的メソッド (static method) オブジェクト</dt>
<dd>静的メソッドは、上で説明したような関数オブジェクトからメソッドオブジェクトへの変換を阻止するための方法を提供します。静的メソッドオブジェクトは他の何らかのオブジェクト、通常はユーザ定義メソッドオブジェクトを包むラッパです。静的メソッドをクラスやクラスインスタンスから取得すると、実際に返されるオブジェクトはラップされたオブジェクトになり、それ以上は変換の対象にはなりません。静的メソッドオブジェクトは通常呼び出し可能なオブジェクトをラップしますが、静的オブジェクト自体は呼び出すことができません。静的オブジェクトは組み込みコンストラクタ <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a> で生成されます。</dd>
<dt>クラスメソッドオブジェクト</dt>
<dd>クラスメソッドオブジェクトは、静的メソッドオブジェクトに似て、別のオブジェクトを包むラッパであり、そのオブジェクトをクラスやクラスインスタンスから取り出す方法を代替します。このようにして取得したクラスメソッドオブジェクトの動作については、上の &quot;ユーザ定義メソッド (user-defined method)&quot; で説明されています。クラスメソッドオブジェクトは組み込みのコンストラクタ <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> で生成されます。</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="special-method-names">
<span id="specialnames"></span><h2>3.3. 特殊メソッド名<a class="headerlink" href="#special-method-names" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-67">クラスは、特殊な名前のメソッドを定義して、特殊な構文 (算術演算や添え字表記、スライス表記など) による特定の演算を実装できます。これは、Python の演算子オーバロード (<em class="dfn">operator overloading</em>) へのアプローチです。これにより、クラスは言語の演算子に対する独自の振る舞いを定義できます。例えば、あるクラスが <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> という名前のメソッドを定義しており、 <code class="docutils literal notranslate"><span class="pre">x</span></code> がこのクラスのインスタンスであるとすると、 <code class="docutils literal notranslate"><span class="pre">x[i]</span></code> は <code class="docutils literal notranslate"><span class="pre">type(x).__getitem__(x,</span> <span class="pre">i)</span></code> とほぼ等価です。特に注釈のない限り、適切なメソッドが定義されていないとき、このような演算を試みると例外 (たいていは <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> か <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>) が送出されます。</p>
<p>特殊メソッドに <code class="docutils literal notranslate"><span class="pre">None</span></code> を設定することは、それに対応する演算が利用できないことを意味します。
例えば、クラスの <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> を <code class="docutils literal notranslate"><span class="pre">None</span></code> に設定した場合、そのクラスはイテラブルにはならず、そのインスタンスに対し <a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> を呼び出すと (<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> に処理が戻されずに) <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> を送出します。 <a class="footnote-reference" href="#id9" id="id2">[2]</a></p>
<p>組み込み型をエミュレートするクラスを実装するときは、模範とされるオブジェクトにとって意味がある範囲に実装をとどめるのが重要です。例えば、あるシーケンスは個々の要素の取得はきちんと動くかもしれませんが、スライスの展開が意味をなさないかもしれません。 (W3C のドキュメントオブジェクトモデルにある <code class="xref py py-class docutils literal notranslate"><span class="pre">NodeList</span></code> インターフェースがその一例です。)</p>
<div class="section" id="basic-customization">
<span id="customization"></span><h3>3.3.1. 基本的なカスタマイズ<a class="headerlink" href="#basic-customization" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="method">
<dt id="object.__new__">
<code class="descclassname">object.</code><code class="descname">__new__</code><span class="sig-paren">(</span><em>cls</em><span class="optional">[</span>, <em>...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__new__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-68">クラス <em>cls</em> の新しいインスタンスを作るために呼び出されます。 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> は静的メソッドで (このメソッドは特別扱いされているので、明示的に静的メソッドと宣言する必要はありません)、インスタンスを生成するよう要求されているクラスを第一引数にとります。残りの引数はオブジェクトのコンストラクタの式 (クラスの呼び出し文) に渡されます。 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> の戻り値は新しいオブジェクトのインスタンス (通常は <em>cls</em> のインスタンス) でなければなりません。</p>
<p>典型的な実装では、クラスの新たなインスタンスを生成するときには <code class="docutils literal notranslate"><span class="pre">super().__new__(cls[,</span> <span class="pre">...])</span></code> に適切な引数を指定してスーパクラスの <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> メソッドを呼び出し、新たに生成されたインスタンスに必要な変更を加えてから返します。</p>
<p>If <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> is invoked during object construction and it returns an
instance or subclass of <em>cls</em>, then the new instance’s <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> method
will be invoked like <code class="docutils literal notranslate"><span class="pre">__init__(self[,</span> <span class="pre">...])</span></code>, where <em>self</em> is the new instance
and the remaining arguments are the same as were passed to the object constructor.</p>
<p><a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> が <em>cls</em> のインスタンスを返さない場合、インスタンスの <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> メソッドは呼び出されません。</p>
<p><a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> の主な目的は、変更不能な型 (int, str, tuple など) のサブクラスでインスタンス生成をカスタマイズすることにあります。また、クラス生成をカスタマイズするために、カスタムのメタクラスでよくオーバーライドされます。</p>
</dd></dl>

<dl class="method">
<dt id="object.__init__">
<code class="descclassname">object.</code><code class="descname">__init__</code><span class="sig-paren">(</span><em>self</em><span class="optional">[</span>, <em>...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-69">インスタンスが (<a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> によって) 生成された後、それが呼び出し元に返される前に呼び出されます。引数はクラスのコンストラクタ式に渡したものです。基底クラスとその派生クラスがともに <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> メソッドを持つ場合、派生クラスの <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> メソッドは基底クラスの <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> メソッドを明示的に呼び出して、インスタンスの基底クラス部分が適切に初期化されること保証しなければなりません。例えば、 <code class="docutils literal notranslate"><span class="pre">super().__init__([args...])</span></code> 。</p>
<p><a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> と <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> は連携してオブジェクトを構成する (<a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> が作成し、 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> がそれをカスタマイズする) ので、 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> から非 <code class="docutils literal notranslate"><span class="pre">None</span></code> 値を返してはいけません; そうしてしまうと、実行時に <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> が送出されてしまいます。</p>
</dd></dl>

<dl class="method">
<dt id="object.__del__">
<code class="descclassname">object.</code><code class="descname">__del__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__del__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-70">インスタンスが破棄されるときに呼び出されます。
これはファイナライザや (適切ではありませんが) デストラクタとも呼ばれます。
基底クラスが <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> メソッドを持っている場合は、派生クラスの <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> メソッドは何であれ、基底クラスの <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a>  メソッドを明示的に呼び出して、インスタンスの基底クラス部分をきちんと確実に削除しなければなりません。</p>
<p><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> メソッドが破棄しようとしているインスタンスへの新しい参照を作り、破棄を送らせることは (推奨されないものの) 可能です。
これはオブジェクトの <em>復活</em> と呼ばれます。
復活したオブジェクトが再度破棄される直前に <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> が呼び出されるかどうかは実装依存です;
現在の <a class="reference internal" href="../glossary.html#term-cpython"><span class="xref std std-term">CPython</span></a> の実装では最初の一回しか呼び出されません。</p>
<p>インタプリタが終了したときに、残存しているオブジェクトの <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> メソッドが呼び出される保証はありません。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">x</span></code> は直接 <code class="docutils literal notranslate"><span class="pre">x.__del__()</span></code> を呼び出しません --- 前者は <code class="docutils literal notranslate"><span class="pre">x</span></code> の参照カウントを 1 つ減らし、後者は <code class="docutils literal notranslate"><span class="pre">x</span></code> の参照カウントが 0 まで落ちたときのみ呼び出されます。</p>
</div>
<div class="impl-detail compound">
<p class="compound-first"><strong>CPython implementation detail:</strong> It is possible for a reference cycle to prevent the reference count
of an object from going to zero.  In this case, the cycle will be
later detected and deleted by the <a class="reference internal" href="../glossary.html#term-garbage-collection"><span class="xref std std-term">cyclic garbage collector</span></a>.  A common cause of reference cycles is when
an exception has been caught in a local variable.  The frame's
locals then reference the exception, which references its own
traceback, which references the locals of all frames caught in the
traceback.</p>
<div class="compound-last admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> モジュールのドキュメント。</p>
</div>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>メソッド <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> は不安定な状況で呼び出されるため、実行中に発生した例外は無視され、代わりに <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> に警告が表示されます。特に:</p>
<ul class="last simple">
<li><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> は、任意のコードが実行されているときに、任意のスレッドから呼び出せます。
<a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> で、ロックを取ったり、ブロックするリソースを呼び出したりする必要がある場合、 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> の実行により中断されたコードにより、そのリソースが既に取得されていて、デッドロックが起きるかもしれません。</li>
<li><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> は、インタプリタのシャットダウン中に実行できます。
従って、(他のモジュールも含めた) アクセスする必要があるグローバル変数はすでに削除されているか、 <code class="docutils literal notranslate"><span class="pre">None</span></code> に設定されているかもしれません。
Python は、単一のアンダースコアで始まる名前のグローバルオブジェクトは、他のグローバル変数が削除される前にモジュールから削除されることを保証します; そのようなグローバル変数への他からの参照が存在しない場合、<a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> メソッドが呼ばれた時点で、インポートされたモジュールがまだ利用可能であることを保証するのに役立つかもしれません。</li>
</ul>
</div>
<span class="target" id="index-71"></span></dd></dl>

<dl class="method">
<dt id="object.__repr__">
<code class="descclassname">object.</code><code class="descname">__repr__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__repr__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 組み込み関数によって呼び出され、オブジェクトを表す「公式の (official)」文字列を計算します。可能なら、これは (適切な環境が与えられれば) 同じ値のオブジェクトを再生成するのに使える、有効な Python 式のようなものであるべきです。できないなら、 <code class="docutils literal notranslate"><span class="pre">&lt;...some</span> <span class="pre">useful</span> <span class="pre">description...&gt;</span></code> 形式の文字列が返されるべきです。戻り値は文字列オブジェクトでなければなりません。クラスが <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> を定義していて <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a> は定義していなければ、そのクラスのインスタンスの「非公式の (informal)」文字列表現が要求されたときにも <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> が使われます。</p>
<p>この関数はデバッグの際によく用いられるので、たくさんの情報を含み、あいまいでないような表記にすることが重要です。</p>
<span class="target" id="index-72"></span></dd></dl>

<dl class="method">
<dt id="object.__str__">
<code class="descclassname">object.</code><code class="descname">__str__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__str__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オブジェクトの「非公式の (informal)」あるいは表示に適した文字列表現を計算するために、 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str(object)</span></code></a> と組み込み関数 <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a>, <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> によって呼ばれます。戻り値は <a class="reference internal" href="../library/stdtypes.html#textseq"><span class="std std-ref">string</span></a> オブジェクトでなければなりません。</p>
<p><a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a> が有効な Python 表現を返すことが期待されないという点で、このメソッドは <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__repr__()</span></code></a> とは異なります: より便利な、または簡潔な表現を使用することができます。</p>
<p>組み込み型 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> によって定義されたデフォルト実装は、 <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__repr__()</span></code></a> を呼び出します。</p>
</dd></dl>

<dl class="method">
<dt id="object.__bytes__">
<code class="descclassname">object.</code><code class="descname">__bytes__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__bytes__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-73"><a class="reference internal" href="../library/functions.html#func-bytes"><span class="std std-ref">bytes</span></a> によって呼び出され、オブジェクトのバイト文字列表現を計算します。これは <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> オブジェクトを返すべきです。</p>
<span class="target" id="index-74"></span></dd></dl>

<dl class="method">
<dt id="object.__format__">
<code class="descclassname">object.</code><code class="descname">__format__</code><span class="sig-paren">(</span><em>self</em>, <em>format_spec</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__format__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 組み込み関数、さらには <a class="reference internal" href="lexical_analysis.html#f-strings"><span class="std std-ref">フォーマット済み文字列リテラル</span></a> の評価、 <a class="reference internal" href="../library/stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> メソッドによって呼び出され、オブジェクトの &quot;フォーマット化された (formatted)&quot; 文字列表現を作ります。 <em>format_spec</em> 引数は、 必要なフォーマット化オプションの記述を含む文字列です。 <em>format_spec</em> 引数の解釈は、 <a class="reference internal" href="#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__format__()</span></code></a> を実装する型によりますが、 ほとんどのクラスは組み込み型のいずれかにフォーマット化を委譲したり、 同じようなフォーマット化オプション構文を使います。</p>
<p>標準のフォーマット構文の解説は、 <a class="reference internal" href="../library/string.html#formatspec"><span class="std std-ref">書式指定ミニ言語仕様</span></a> を参照してください。</p>
<p>戻り値は文字列オブジェクトでなければなりません。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>空でない文字列が渡された場合 <code class="docutils literal notranslate"><span class="pre">object</span></code> 自身の __format__ メソッドは <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> を送出します。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.7 で変更: </span><code class="docutils literal notranslate"><span class="pre">object.__format__(x,</span> <span class="pre">'')</span></code> は <code class="docutils literal notranslate"><span class="pre">format(str(self),</span> <span class="pre">'')</span></code> ではなく <code class="docutils literal notranslate"><span class="pre">str(x)</span></code> と等価になりました。</p>
</div>
</dd></dl>

<span class="target" id="richcmpfuncs"></span><dl class="method">
<dt id="object.__lt__">
<code class="descclassname">object.</code><code class="descname">__lt__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__lt__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__le__">
<code class="descclassname">object.</code><code class="descname">__le__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__le__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__eq__">
<code class="descclassname">object.</code><code class="descname">__eq__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__eq__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ne__">
<code class="descclassname">object.</code><code class="descname">__ne__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ne__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__gt__">
<code class="descclassname">object.</code><code class="descname">__gt__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__gt__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ge__">
<code class="descclassname">object.</code><code class="descname">__ge__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ge__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-75">これらはいわゆる &quot;拡張比較 (rich comparison)&quot; メソッドです。演算子シンボルとメソッド名の対応は以下の通りです: <code class="docutils literal notranslate"><span class="pre">x&lt;y</span></code> は <code class="docutils literal notranslate"><span class="pre">x.__lt__(y)</span></code> を呼び出します; <code class="docutils literal notranslate"><span class="pre">x&lt;=y</span></code> は <code class="docutils literal notranslate"><span class="pre">x.__le__(y)</span></code> を呼び出します; <code class="docutils literal notranslate"><span class="pre">x==y</span></code> は <code class="docutils literal notranslate"><span class="pre">x.__eq__(y)</span></code> を呼び出します; <code class="docutils literal notranslate"><span class="pre">x!=y</span></code> は <code class="docutils literal notranslate"><span class="pre">x.__ne__(y)</span></code> を呼び出します; <code class="docutils literal notranslate"><span class="pre">x&gt;y</span></code> は <code class="docutils literal notranslate"><span class="pre">x.__gt__(y)</span></code> を呼び出します; <code class="docutils literal notranslate"><span class="pre">x&gt;=y</span></code> は <code class="docutils literal notranslate"><span class="pre">x.__ge__(y)</span></code> を呼び出します。</p>
<p>拡張比較メソッドは与えられた引数のペアに対する演算を実装していないときに、 シングルトン <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> を返すかもしれません。
慣例として、正常に比較が行われたときには <code class="docutils literal notranslate"><span class="pre">False</span></code> か <code class="docutils literal notranslate"><span class="pre">True</span></code> を返します。
しかし、これらのメソッドは任意の値を返すことができるので、比較演算子がブール値のコンテキスト (たとえば <code class="docutils literal notranslate"><span class="pre">if</span></code> 文の条件部分) で使われた場合、 Python はその値に対して <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code></a> を呼び出して結果の真偽を判断します。</p>
<p>デフォルトでは <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a> は <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> でない限り <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> に委譲して結果を反転させます。比較演算の間には他に暗黙の関係はありません。例えば <code class="docutils literal notranslate"><span class="pre">(x&lt;y</span> <span class="pre">or</span> <span class="pre">x==y)</span></code> が真であることは暗黙的に <code class="docutils literal notranslate"><span class="pre">x&lt;=y</span></code> ではありません。元となる一つの演算から自動的に順序の演算を生成するには <a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.total_ordering()</span></code></a> を参照してください。</p>
<p>カスタムの比較演算をサポートしていて、辞書のキーに使うことができる <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">ハッシュ可能</span></a> オブジェクトを作るときの重要な注意点について、 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> のドキュメント内に書かれているので参照してください。</p>
<p>これらのメソッドには (左引数が演算をサポートしないが、右引数はサポートする場合に用いられるような) 引数を入れ替えたバージョンは存在しません。
むしろ、 <a class="reference internal" href="#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a> と <a class="reference internal" href="#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a> は互いの反射、 <a class="reference internal" href="#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code></a> と <a class="reference internal" href="#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code></a> は互いの反射、および <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> と <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a> はそれら自身の反射です。
被演算子が異なる型で右の被演算子の型が左の被演算子の直接的または間接的サブクラスの場合、右被演算子の反射されたメソッドが優先されます。
そうでない場合左の被演算子のメソッドが優先されます。
仮想サブクラス化は考慮されません。</p>
</dd></dl>

<dl class="method">
<dt id="object.__hash__">
<code class="descclassname">object.</code><code class="descname">__hash__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__hash__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-76">組み込みの <a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> 関数や、 <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> のようなハッシュを使ったコレクション型の要素に対する操作から呼び出されます。
<a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> は整数を返さなければなりません。
このメソッドに必要な性質は、比較結果が等しいオブジェクトは同じハッシュ値を持つということです;
オブジェクトを比較するときでも利用される要素をタプルに詰めてハッシュ値を計算することで、それぞれの要素のハッシュ値を混合することをおすすめします。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nick</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> はオブジェクト独自の <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>  メソッドが返す値を <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code> のサイズに切り詰めます。
これは 64-bit でビルドされていると 8 バイトで、 32-bit でビルドされていると 4 バイトです。
オブジェクトの <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> が異なる bit サイズのビルドでも可搬性が必要である場合は、必ず全てのサポートするビルドの bit 幅をチェックしてください。
そうする簡単な方法は <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-c</span> <span class="pre">&quot;import</span> <span class="pre">sys;</span> <span class="pre">print(sys.hash_info.width)&quot;</span></code> を実行することです。</p>
</div>
<p>クラスが <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> メソッドを定義していないなら、 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> メソッドも定義してはなりません; クラスが <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> を定義していても <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> を定義していないなら、そのインスタンスはハッシュ可能コレクションの要素として使えません。クラスがミュータブルなオブジェクトを定義しており、 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> メソッドを実装しているなら、 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> を定義してはなりません。これは、ハッシュ可能コレクションの実装においてキーのハッシュ値がイミュータブルであることが要求されているからです (オブジェクトのハッシュ値が変化すると、誤ったハッシュバケツ: hash bucket に入ってしまいます)。</p>
<p>ユーザー定義クラスはデフォルトで <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> と <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> メソッドを持っています。 このとき、(同一でない) すべてのオブジェクトは比較して異なり、 <code class="docutils literal notranslate"><span class="pre">x.__hash__()</span></code> は <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> が <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> と <code class="docutils literal notranslate"><span class="pre">hash(x)</span> <span class="pre">==</span> <span class="pre">hash(y)</span></code> の両方を意味するような適切な値を返します。</p>
<p><a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> をオーバーライドしていて <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> を定義していないクラスでは、 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> は暗黙的に <code class="docutils literal notranslate"><span class="pre">None</span></code> に設定されます。
クラスの <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> メソッドが <code class="docutils literal notranslate"><span class="pre">None</span></code> の場合、そのクラスのインスタンスのハッシュ値を取得しようとすると適切な <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> が送出され、 <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">collections.abc.Hashable)</span></code> でチェックするとハッシュ不能なものとして正しく認識されます。</p>
<p><a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> をオーバーライドしたクラスが親クラスからの <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> の 実装を保持したいなら、明示的に <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">&lt;ParentClass&gt;.__hash__</span></code> を設定することで、それをインタプリタに伝えなければなりません。</p>
<p><a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> をオーバーライドしていないクラスがハッシュサポートを抑制したい場合、クラス定義に <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> を含めてください。クラス自身で明示的に <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> を送出する <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> を定義すると、 <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">collections.abc.Hashable)</span></code> 呼び出しで誤ってハッシュ可能と識別されるでしょう。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>By default, the <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> values of str and bytes objects are
&quot;salted&quot; with an unpredictable random value.  Although they
remain constant within an individual Python process, they are not
predictable between repeated invocations of Python.</p>
<p>この目的は、慎重に選ばれた入力で辞書挿入の最悪性能 O(n^2) 計算量を悪用することで引き起こされるサービス妨害 (denial-of-service, DoS) に対する保護です。
詳細は <a class="reference external" href="http://www.ocert.org/advisories/ocert-2011-003.html">http://www.ocert.org/advisories/ocert-2011-003.html</a> を参照してください。</p>
<p>ハッシュ値の変更は、集合のイテレーション順序に影響します。Python はこの順序付けを保証していません (そして通常 32-bit と 64-bit の間でも異なります)。</p>
<p class="last"><span class="target" id="index-114"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHASHSEED"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHASHSEED</span></code></a> も参照してください。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>ハッシュのランダム化がデフォルトで有効になりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__bool__">
<code class="descclassname">object.</code><code class="descname">__bool__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__bool__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-78">真理値テストや組み込み演算 <code class="docutils literal notranslate"><span class="pre">bool()</span></code> を実装するために呼び出されます; <code class="docutils literal notranslate"><span class="pre">False</span></code> または <code class="docutils literal notranslate"><span class="pre">True</span></code> を返さなければなりません。このメソッドが定義されていないとき、 <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> が定義されていれば呼び出され、その結果が非 0 であれば真とみなされます。クラスが <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> も <a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a> も定義していないければ、そのクラスのインスタンスはすべて真とみなされます。</p>
</dd></dl>

</div>
<div class="section" id="customizing-attribute-access">
<span id="attribute-access"></span><h3>3.3.2. 属性値アクセスをカスタマイズする<a class="headerlink" href="#customizing-attribute-access" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下のメソッドを定義して、クラスインスタンスへの属性値アクセス ( 属性値の使用、属性値への代入、 <code class="docutils literal notranslate"><span class="pre">x.name</span></code> の削除) の意味をカスタマイズすることができます。</p>
<dl class="method">
<dt id="object.__getattr__">
<code class="descclassname">object.</code><code class="descname">__getattr__</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getattr__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>デフォルトの属性アクセスが <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> で失敗したとき (<em>name</em> がインスタンスの属性または <code class="docutils literal notranslate"><span class="pre">self</span></code> のクラスツリーの属性でないために <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> が <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> を送出したか、 <em>name</em> プロパティの <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> が <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> を送出したとき) に呼び出されます。
このメソッドは (計算された) 属性値を返すか、 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 例外を送出しなければなりません。</p>
<p>なお、通常の過程で属性が見つかれば、 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> は呼び出されません。(これは、 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a>  と <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> が意図的に非対称にされている点です。) これは、効率のためと、こうしないと <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> がインスタンスの他の属性値にアクセスする方法がなくなるためです。また、少なくともインスタンス変数に対しては、値をインスタンスの属性値辞書に挿入しないことで (代わりに他のオブジェクトに挿入することで)、属性値を完全に制御しているふりができます。実際に属性アクセスを完全に制御する方法は、以下の <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> メソッドを参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="object.__getattribute__">
<code class="descclassname">object.</code><code class="descname">__getattribute__</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getattribute__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クラスのインスタンスに対する属性アクセスを実装するために、無条件に呼び出されます。クラスが <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> も定義している場合、 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> は、 <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> で明示的に呼び出すか、 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 例外を送出しない限り呼ばれません。このメソッドは (計算された) 属性値を返すか、 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 例外を送出します。このメソッドが再帰的に際限なく呼び出されてしまうのを防ぐため、実装の際には常に、必要な属性全てへのアクセスで、例えば <code class="docutils literal notranslate"><span class="pre">object.__getattribute__(self,</span> <span class="pre">name)</span></code> のように基底クラスのメソッドを同じ属性名を使って呼び出さなければなりません。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">言語構文や組み込み関数から暗黙に呼び出された特殊メソッドの検索では、このメソッドも回避されることがあります。 <a class="reference internal" href="#special-lookup"><span class="std std-ref">特殊メソッド検索</span></a> を参照してください。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__setattr__">
<code class="descclassname">object.</code><code class="descname">__setattr__</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setattr__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>属性の代入が試みられた際に呼び出されます。これは通常の代入の過程 (すなわち、インスタンス辞書への値の代入) の代わりに呼び出されます。<em>name</em> は属性名で、<em>value</em> はその属性に代入する値です。</p>
<p><a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> の中でインスタンス属性への代入が必要なら、基底クラスのこれと同じ名前のメソッドを呼び出さなければなりません。例えば、 <code class="docutils literal notranslate"><span class="pre">object.__setattr__(self,</span> <span class="pre">name,</span> <span class="pre">value)</span></code> とします。</p>
</dd></dl>

<dl class="method">
<dt id="object.__delattr__">
<code class="descclassname">object.</code><code class="descname">__delattr__</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delattr__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> に似ていますが、代入ではなく値の削除を行います。このメソッドを実装するのは、オブジェクトにとって <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">obj.name</span></code> が意味がある場合だけにしなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="object.__dir__">
<code class="descclassname">object.</code><code class="descname">__dir__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__dir__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オブジェクトに <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> が呼び出されたときに呼び出されます。シーケンスが返されなければなりません。 <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> は返されたシーケンスをリストに変換し、ソートします。</p>
</dd></dl>

<div class="section" id="customizing-module-attribute-access">
<h4>3.3.2.1. モジュールの属性値アクセスをカスタマイズする<a class="headerlink" href="#customizing-module-attribute-access" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p id="index-79">特殊な名前の <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> と <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> も、モジュール属性へのアクセスをカスタマイズするのに使えます。
モジュールレベルの <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> 関数は属性名である 1 引数を受け取り、計算した値を返すか <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> を送出します。
属性がモジュールオブジェクトから、通常の検索、つまり <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__getattribute__()</span></code></a> で見付からなかった場合は、 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> を送出する前に、モジュールの <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> から <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> が検索されます。
見付かった場合は、その属性名で呼び出され、結果が返されます。</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> function should accept no arguments, and return a sequence of
strings that represents the names accessible on module. If present, this
function overrides the standard <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> search on a module.</p>
<p>より細かい粒度でのモジュールの動作 (属性やプロパティの設定など) のカスタマイズのために、モジュールオブジェクトの <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 属性に <a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a> のサブクラスが設定できます。
例えば次のようになります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">ModuleType</span>

<span class="k">class</span> <span class="nc">VerboseModule</span><span class="p">(</span><span class="n">ModuleType</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Verbose </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Setting </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s1">...&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="n">VerboseModule</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">モジュールの <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> を定義したり <code class="docutils literal notranslate"><span class="pre">__class__</span></code> を設定したりしても、影響があるのは属性アクセスの構文が使われる検索だけです -- モジュールの globals への直接アクセスは (モジュール内のコードからとモジュールの globals のどちらでも) 影響を受けません。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span>モジュールの属性 <code class="docutils literal notranslate"><span class="pre">__class__</span></code> が書き込み可能になりました。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.7 で追加: </span><code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> モジュール属性と <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> モジュール属性。</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-115"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0562"><strong>PEP 562</strong></a> - モジュールの __getattr__ と __dir__</dt>
<dd>モジュールの <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> 関数および <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> 関数の説明。</dd>
</dl>
</div>
</div>
<div class="section" id="implementing-descriptors">
<span id="descriptors"></span><h4>3.3.2.2. デスクリプタ (descriptor) の実装<a class="headerlink" href="#implementing-descriptors" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>以下のメソッドは、このメソッドを持つクラス (いわゆる <em>デスクリプタ(descriptor)</em> クラス) のインスタンスが、 <em>オーナー (owner)</em> クラスに存在するときにのみ適用されます (デスクリプタは、オーナーのクラス辞書か、その親のいずれかのクラス辞書になければなりません)。
以下の例では、&quot;属性&quot; とは、名前がオーナークラスの <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> のプロパティ (porperty) のキーであるような属性を指します。</p>
<dl class="method">
<dt id="object.__get__">
<code class="descclassname">object.</code><code class="descname">__get__</code><span class="sig-paren">(</span><em>self</em>, <em>instance</em>, <em>owner=None</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__get__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Called to get the attribute of the owner class (class attribute access) or
of an instance of that class (instance attribute access). The optional
<em>owner</em> argument is the owner class, while <em>instance</em> is the instance that
the attribute was accessed through, or <code class="docutils literal notranslate"><span class="pre">None</span></code> when the attribute is
accessed through the <em>owner</em>.</p>
<p>This method should return the computed attribute value or raise an
<a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> exception.</p>
<p><span class="target" id="index-81"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0252"><strong>PEP 252</strong></a> specifies that <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> is callable with one or two
arguments.  Python's own built-in descriptors support this specification;
however, it is likely that some third-party tools have descriptors
that require both arguments.  Python's own <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a>
implementation always passes in both arguments whether they are required
or not.</p>
</dd></dl>

<dl class="method">
<dt id="object.__set__">
<code class="descclassname">object.</code><code class="descname">__set__</code><span class="sig-paren">(</span><em>self</em>, <em>instance</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__set__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オーナークラスのインスタンス <em>instance</em> 上の属性を新たな値 <em>value</em> に設定する際に呼び出されます。</p>
<p>Note, adding <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> or <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a> changes the kind of
descriptor to a &quot;data descriptor&quot;.  See <a class="reference internal" href="#descriptor-invocation"><span class="std std-ref">デスクリプタの呼び出し</span></a> for
more details.</p>
</dd></dl>

<dl class="method">
<dt id="object.__delete__">
<code class="descclassname">object.</code><code class="descname">__delete__</code><span class="sig-paren">(</span><em>self</em>, <em>instance</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delete__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オーナークラスのインスタンス <em>instance</em> 上の属性を削除する際に呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="object.__set_name__">
<code class="descclassname">object.</code><code class="descname">__set_name__</code><span class="sig-paren">(</span><em>self</em>, <em>owner</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__set_name__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オーナーとなるクラス <em>owner</em> が作成された時点で呼び出されます。
ディスクリプタは <em>name</em> に割り当てられます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p><a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> is only called implicitly as part of the
<a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> constructor, so it will need to be called explicitly with
the appropriate parameters when a descriptor is added to a class after
initial creation:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
   <span class="k">pass</span>
<span class="n">descr</span> <span class="o">=</span> <span class="n">custom_descriptor</span><span class="p">()</span>
<span class="n">A</span><span class="o">.</span><span class="n">attr</span> <span class="o">=</span> <span class="n">descr</span>
<span class="n">descr</span><span class="o">.</span><span class="n">__set_name__</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;attr&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">See <a class="reference internal" href="#class-object-creation"><span class="std std-ref">クラスオブジェクトの作成</span></a> for more details.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加.</span></p>
</div>
</dd></dl>

<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__objclass__</span></code> 属性は <a class="reference internal" href="../library/inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> モジュールによって解釈され、このオブジェクトが定義されたクラスを特定するのに使われます (この属性を適切に設定しておくと、動的なクラスの属性を実行時に調べる助けになります)。
呼び出される側にとっては、この属性で指定されたクラス (もしくはそのサブクラス) のインスタンスが1番目の位置引数として期待もしくは要求されていることが示せます (例えば、 CPython は束縛されていない C で実行されたメソッドにこの属性を設定します)。</p>
</div>
<div class="section" id="invoking-descriptors">
<span id="descriptor-invocation"></span><h4>3.3.2.3. デスクリプタの呼び出し<a class="headerlink" href="#invoking-descriptors" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>一般にデスクリプタとは、特殊な &quot;束縛に関する動作 (binding behaviour)&quot; をもつオブジェクト属性のことです。デスクリプタは、デスクリプタプロトコル (descriptor protocol) のメソッド: <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>, <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a>, および <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a> を使って、属性アクセスをオーバーライドしているものです。これらのメソッドのいずれかがオブジェクトに対して定義されている場合、オブジェクトはデスクリプタであるといいます。</p>
<p>属性アクセスのデフォルトの動作は、オブジェクトの辞書から値を取り出したり、値を設定したり、削除したりするというものです。例えば、 <code class="docutils literal notranslate"><span class="pre">a.x</span></code> による属性の検索では、まず <code class="docutils literal notranslate"><span class="pre">a.__dict__['x']</span></code> 、次に <code class="docutils literal notranslate"><span class="pre">type(a).__dict__['x']</span></code> 、そして <code class="docutils literal notranslate"><span class="pre">type(a)</span></code> の基底クラスでメタクラスでないものに続く、といった具合に連鎖が起こります。</p>
<p>しかし、検索対象の値が、デスクリプタメソッドのいずれかを定義しているオブジェクトであれば、Python はデフォルトの動作をオーバーライドして、代わりにデスクリプタメソッドを呼び出します。先述の連鎖の中のどこでデスクリプタメソッドが呼び出されるかは、どのデスクリプタメソッドが定義されていて、どのように呼び出されたかに依存します。</p>
<p>デスクリプタ呼び出しの基点となるのは、属性名への束縛 (binding) 、すなわち <code class="docutils literal notranslate"><span class="pre">a.x</span></code> です。引数がどのようにデスクリプタに結合されるかは <code class="docutils literal notranslate"><span class="pre">a</span></code> に依存します:</p>
<dl class="docutils">
<dt>直接呼び出し (Direct Call)</dt>
<dd>最も単純で、かつめったに使われない呼び出し操作は、コード中で直接デスクリプタメソッドの呼び出し: <code class="docutils literal notranslate"><span class="pre">x.__get__(a)</span></code> を行うというものです。</dd>
<dt>インスタンス束縛 (Instance Binding)</dt>
<dd>オブジェクトインスタンスへ束縛すると、<code class="docutils literal notranslate"><span class="pre">a.x</span></code> は呼び出し <code class="docutils literal notranslate"><span class="pre">type(a).__dict__['x'].__get__(a,</span> <span class="pre">type(a))</span></code> に変換されます。</dd>
<dt>クラス束縛 (Class Binding)</dt>
<dd>クラスへ束縛すると、<code class="docutils literal notranslate"><span class="pre">A.x</span></code> は呼び出し <code class="docutils literal notranslate"><span class="pre">A.__dict__['x'].__get__(None,</span> <span class="pre">A)</span></code> に変換されます。</dd>
<dt>super 束縛 (Super Binding)</dt>
<dd><code class="docutils literal notranslate"><span class="pre">a</span></code> が <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-class docutils literal notranslate"><span class="pre">super</span></code></a> のインスタンスである場合、束縛 <code class="docutils literal notranslate"><span class="pre">super(B,</span> <span class="pre">obj).m()</span></code> を行うとまず <code class="docutils literal notranslate"><span class="pre">A</span></code> 、続いて <code class="docutils literal notranslate"><span class="pre">B</span></code> に対して <code class="docutils literal notranslate"><span class="pre">obj.__class_.__mro__</span></code> を検索し、次に呼び出し: <code class="docutils literal notranslate"><span class="pre">A.__dict__['m'].__get__(obj,</span> <span class="pre">obj.__class__)</span></code> でデスクリプタを呼び出します。</dd>
</dl>
<p>インスタンス束縛では、デスクリプタ呼び出しの優先順位はどのデスクリプタが定義されているかに依存します。データデスクリプタは、 <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> と <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> 、 <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a> の任意の組合せを定義することができます。 <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> が定義されない場合には、その属性にアクセスすると、そのオブジェクトのインスタンス辞書にその値がある場合を除けば、デスクリプタオブジェクト自身が返ってきます。デスクリプタが <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> と <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a> またはそのどちらかを定義していれば、データデスクリプタとなります; もし両方とも定義しなければ、非データデスクリプタです。通常、データデスクリプタでは、 <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> と <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> を定義し、一方、非データデスクリプタには <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> メソッドしかありません。 <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> と <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> を定義したデータデスクリプタは、インスタンス辞書内で属性値が再定義されても、常にこの値をオーバーライドします。対照的に、非データデスクリプタの場合には、属性値はインスタンス側でオーバーライドされます。</p>
<p>(<a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a> や <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> を含む) Python メソッドは、非データデスクリプタとして実装されています。その結果、インスタンスではメソッドを再定義したりオーバーライドできます。このことにより、個々のインスタンスが同じクラスの他のインスタンスと互いに異なる動作を獲得することができます。</p>
<p><a class="reference internal" href="../library/functions.html#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a> 関数はデータデスクリプタとして実装されています。従って、インスタンスはあるプロパティの動作をオーバーライドすることができません。</p>
</div>
<div class="section" id="slots">
<span id="id3"></span><h4>3.3.2.4. __slots__<a class="headerlink" href="#slots" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><em>__slots__</em> を使うと、(プロパティのように) データメンバを明示的に宣言し、 (明示的に <em>__slots__</em> で宣言しているか親クラスに存在しているかでない限り) <em>__dict__</em> や <em>__weakref__</em> を作成しないようにできます。</p>
<p><em>__dict__</em> を使うのに比べて、節約できるメモリ空間はかなり大きいです。
属性探索のスピードもかなり向上できます。</p>
<dl class="data">
<dt id="object.__slots__">
<code class="descclassname">object.</code><code class="descname">__slots__</code><a class="headerlink" href="#object.__slots__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このクラス変数には、インスタンスが用いる変数名を表す、文字列、イテラブル、または文字列のシーケンスを代入できます。<em>__slots__</em> は、各インスタンスに対して宣言された変数に必要な記憶領域を確保し、<em>__dict__</em> と <em>__weakref__</em> が自動的に生成されないようにします。</p>
</dd></dl>

<div class="section" id="notes-on-using-slots">
<h5>3.3.2.4.1. <em>__slots__</em> を利用する際の注意<a class="headerlink" href="#notes-on-using-slots" title="このヘッドラインへのパーマリンク">¶</a></h5>
<ul class="simple">
<li><em>__slots__</em> を持たないクラスから継承するとき、インスタンスの <em>__dict__</em> 属性と <em>__weakref__</em> 属性は常に利用可能です。</li>
<li><em>__dict__</em> 変数がない場合、 <em>__slots__</em> に列挙されていない新たな変数をインスタンスに代入することはできません。列挙されていない変数名を使って代入しようとした場合、 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> が送出されます。新たな変数を動的に代入したいのなら、 <em>__slots__</em> を宣言する際に <code class="docutils literal notranslate"><span class="pre">'__dict__'</span></code> を変数名のシーケンスに追加してください。</li>
<li><em>__slots__</em> を定義しているクラスの各インスタンスに <em>__weakref__</em> 変数がない場合、インスタンスに対する弱参照 (weak reference) はサポートされません。弱参照のサポートが必要なら、 <em>__slots__</em> を宣言する際に <code class="docutils literal notranslate"><span class="pre">'__weakref__'</span></code> を変数名のシーケンスに追加してください。</li>
<li><em>__slots__</em> は、クラスのレベルで各変数に対するデスクリプタ (<a class="reference internal" href="#descriptors"><span class="std std-ref">デスクリプタ (descriptor) の実装</span></a> を参照) を使って実装されます。その結果、 <em>__slots__</em> に定義されているインスタンス変数のデフォルト値はクラス属性を使って設定できなくなっています; そうしないと、デスクリプタによる代入をクラス属性が上書きしてしまうからです。</li>
<li><em>__slots__</em> の宣言の作用は、それが定義されたクラスだけには留まりません。
親クラスで宣言された <em>__slots__</em> は子クラスでも利用可能です。
ただし、子クラスは、自身も <em>__slots__</em> (ここには <em>追加の</em> スロットの名前のみ含めるべき) を定義しない限り*__dict__* や <em>__weakref__</em> を持ちます。</li>
<li>あるクラスで、基底クラスですでに定義されているスロットを定義した場合、基底クラスのスロットで定義されているインスタンス変数は (デスクリプタを基底クラスから直接取得しない限り) アクセスできなくなります。これにより、プログラムの趣意が不定になってしまいます。将来は、この問題を避けるために何らかのチェックが追加されるかもしれません。</li>
<li>空でない <em>__slots__</em> は、 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> や <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> や <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> のような &quot;可変長の&quot; 組み込み型から派生したクラスでは動作しません。</li>
<li><em>__slots__</em> には、文字列でない反復可能オブジェクトを代入することができます。辞書型も使うことができます; しかし将来、辞書の各キーに相当する値に何らかの特殊な意味が割り当てられるかもしれません。</li>
<li><em>__class__</em> への代入は、両方のクラスが同じ <em>__slots__</em> を持っているときのみ動作します。</li>
<li>複数のスロットを持つ親クラスを使った多重継承はできますが、スロットで作成された属性を持つ親クラスは 1 つに限られます (他の基底クラスのスロットは空でなければなりません) - それに違反すると <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> が送出されます。</li>
<li>If an iterator is used for <em>__slots__</em> then a descriptor is created for each
of the iterator's values. However, the <em>__slots__</em> attribute will be an empty
iterator.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="customizing-class-creation">
<span id="class-customization"></span><h3>3.3.3. クラス生成をカスタマイズする<a class="headerlink" href="#customizing-class-creation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>クラスが他のクラスを継承するときに必ず、継承元のクラスの <em>__init_subclass__</em> が呼び出されます。これを利用すると、サブクラスの挙動を変更するクラスを書くことができます。これは、クラスデコレータととても良く似ていますが、クラスデコレータが、それが適用された特定のクラスにのみに影響するのに対して、 <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> は、もっぱら、このメソッドを定義したクラスの将来のサブクラスに適用されます。</p>
<dl class="classmethod">
<dt id="object.__init_subclass__">
<em class="property">classmethod </em><code class="descclassname">object.</code><code class="descname">__init_subclass__</code><span class="sig-paren">(</span><em>cls</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__init_subclass__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは、それが定義されたクラスが継承された際に必ず呼び出されます。<em>cls</em> は新しいサブクラスです。もし、このメソッドがインスタンスメソッドとして定義されると、暗黙的にクラスメソッドに変換されます。</p>
<p>新しいクラスに与えられたキーワード引数は、親のクラスの <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> に渡されます。 <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> を利用している他のクラスとの互換性のために、以下のコードのように必要なキーワード引数を取得したら、他の引数は基底クラスに引き渡すべきです:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Philosopher</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">default_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">default_name</span> <span class="o">=</span> <span class="n">default_name</span>

<span class="k">class</span> <span class="nc">AustralianPhilosopher</span><span class="p">(</span><span class="n">Philosopher</span><span class="p">,</span> <span class="n">default_name</span><span class="o">=</span><span class="s2">&quot;Bruce&quot;</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">object.__init_subclass__</span></code> のデフォルト実装は何も行いませんが、何らかの引数とともに呼び出された場合は、エラーを送出します。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">メタクラスのヒント <code class="docutils literal notranslate"><span class="pre">metaclass</span></code> は残りの型機構によって消費され、 <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> 実装に渡されることはありません。
実際のメタクラス (明示的なヒントではなく) は、 <code class="docutils literal notranslate"><span class="pre">type(cls)</span></code> としてアクセスできます。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加.</span></p>
</div>
</dd></dl>

<div class="section" id="metaclasses">
<span id="id4"></span><h4>3.3.3.1. メタクラス<a class="headerlink" href="#metaclasses" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p id="index-82">デフォルトでは、クラスは <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> を使って構築されます。 クラス本体は新しい名前空間で実行され、クラス名が <code class="docutils literal notranslate"><span class="pre">type(name,</span> <span class="pre">bases,</span> <span class="pre">namespace)</span></code> の結果にローカルに束縛されます。</p>
<p>クラス生成プロセスはカスタマイズできます。
そのためにはクラス定義行で <code class="docutils literal notranslate"><span class="pre">metaclass</span></code> キーワード引数を渡すか、そのような引数を定義行に含む既存のクラスを継承します。
次の例で <code class="docutils literal notranslate"><span class="pre">MyClass</span></code> と <code class="docutils literal notranslate"><span class="pre">MySubclass</span></code> は両方とも <code class="docutils literal notranslate"><span class="pre">Meta</span></code> のインスタンスです:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Meta</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MySubclass</span><span class="p">(</span><span class="n">MyClass</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>クラス定義の中で指定された他のキーワード引数は、後述するすべてのメタクラス操作に渡されます。</p>
<p>クラス定義が実行される際に、以下のステップが生じます:</p>
<ul class="simple">
<li>MRO エントリの解決が行われる;</li>
<li>適切なメタクラスが決定される;</li>
<li>クラスの名前空間が準備される;</li>
<li>クラスの本体が実行される;</li>
<li>クラスオブジェクトが作られる。</li>
</ul>
</div>
<div class="section" id="resolving-mro-entries">
<h4>3.3.3.2. MRO エントリの解決<a class="headerlink" href="#resolving-mro-entries" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>クラス定義に現れる基底が <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> のインスタンスではない場合、そのインスタンスの <code class="docutils literal notranslate"><span class="pre">__mro_entries__</span></code> メソッドが検索されます。
見付かった場合、その基底そのものを要素に持つタプルを引数として、 <code class="docutils literal notranslate"><span class="pre">__mro_entries__</span></code> メソッドが呼び出されます。
このメソッドは、この基底の代わりに使われるクラスのタプルを返さなければなりません。
このタプルは空であることもあり、そのような場合ではその基底は無視されます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><span class="target" id="index-116"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0560"><strong>PEP 560</strong></a> - typing モジュールとジェネリック型に対する言語コアによるサポート</p>
</div>
</div>
<div class="section" id="determining-the-appropriate-metaclass">
<h4>3.3.3.3. 適切なメタクラスの決定<a class="headerlink" href="#determining-the-appropriate-metaclass" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p id="index-84">クラス定義に対して適切なメタクラスは、以下のように決定されます:</p>
<ul class="simple">
<li>基底も明示的なメタクラスも与えられていない場合は、 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> が使われます;</li>
<li>明示的なメタクラスが与えられていて、それが <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> のインスタンス <em>ではない</em> 場合、それをメタクラスとして直接使います;</li>
<li>明示的なメタクラスとして <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> のインスタンスが与えられたか、基底が定義されていた場合は、最も派生した (継承関係で最も下の) メタクラスが使われます。</li>
</ul>
<p>最も派生的なメタクラスは、(もしあれば) 明示的に指定されたメタクラスと、指定されたすべてのベースクラスのメタクラスから選ばれます。最も派生的なメタクラスは、これらのメタクラス候補のすべてのサブタイプであるようなものです。メタクラス候補のどれもその基準を満たさなければ、クラス定義は <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> で失敗します。</p>
</div>
<div class="section" id="preparing-the-class-namespace">
<span id="prepare"></span><h4>3.3.3.4. クラスの名前空間の準備<a class="headerlink" href="#preparing-the-class-namespace" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p id="index-85">Once the appropriate metaclass has been identified, then the class namespace
is prepared. If the metaclass has a <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> attribute, it is called
as <code class="docutils literal notranslate"><span class="pre">namespace</span> <span class="pre">=</span> <span class="pre">metaclass.__prepare__(name,</span> <span class="pre">bases,</span> <span class="pre">**kwds)</span></code> (where the
additional keyword arguments, if any, come from the class definition). The
<code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> method should be implemented as a <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a>. The
namespace returned by <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> is passed in to <code class="docutils literal notranslate"><span class="pre">__new__</span></code>, but when
the final class object is created the namespace is copied into a new <code class="docutils literal notranslate"><span class="pre">dict</span></code>.</p>
<p>メタクラスに <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> 属性がない場合、クラスの名前空間は空の 順序付きマッピングとして初期化されます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-86"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3115"><strong>PEP 3115</strong></a> - Metaclasses in Python 3000</dt>
<dd><code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> 名前空間フックの導入</dd>
</dl>
</div>
</div>
<div class="section" id="executing-the-class-body">
<h4>3.3.3.5. クラス本体の実行<a class="headerlink" href="#executing-the-class-body" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p id="index-87">クラス本体が (大まかには) <code class="docutils literal notranslate"><span class="pre">exec(body,</span> <span class="pre">globals(),</span> <span class="pre">namespace)</span></code> として実行されます。通常の呼び出しと <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> の重要な違いは、クラス定義が関数内部で行われる場合、レキシカルスコープによってクラス本体 (任意のメソッドを含む) が現在のスコープと外側のスコープから名前を参照できるという点です。</p>
<p>しかし、クラス定義が関数内部で行われる時でさえ、クラス内部で定義されたメソッドはクラススコープで定義された名前を見ることはできません。クラス変数はインスタンスメソッドかクラスメソッドの最初のパラメータからアクセスするか、次の節で説明する、暗黙的に静的スコープが切られている <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 参照からアクセスしなければなりません。</p>
</div>
<div class="section" id="creating-the-class-object">
<span id="class-object-creation"></span><h4>3.3.3.6. クラスオブジェクトの作成<a class="headerlink" href="#creating-the-class-object" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p id="index-88">クラス本体の実行によってクラスの名前空間が初期化されたら、<code class="docutils literal notranslate"><span class="pre">metaclass(name,</span> <span class="pre">bases,</span> <span class="pre">namespace,</span> <span class="pre">**kwds)</span></code> を呼び出すことでクラスオブジェクトが作成されます (ここで渡される追加のキーワードは <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> に渡されるものと同じです)。</p>
<p>このクラスオブジェクトは、 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> の無引数形式によって参照されるものです。 <code class="docutils literal notranslate"><span class="pre">__class__</span></code> は、クラス本体中のメソッドが <code class="docutils literal notranslate"><span class="pre">__class__</span></code> または <code class="docutils literal notranslate"><span class="pre">super</span></code> のいずれかを参照している場合に、コンパイラによって作成される暗黙のクロージャー参照です。これは、メソッドに渡された最初の引数に基づいて現在の呼び出しを行うために使用されるクラスまたはインスタンスが識別される一方、 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> の無引数形式がレキシカルスコープに基づいて定義されているクラスを正確に識別することを可能にします。</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> In CPython 3.6 and later, the <code class="docutils literal notranslate"><span class="pre">__class__</span></code> cell is passed to the metaclass
as a <code class="docutils literal notranslate"><span class="pre">__classcell__</span></code> entry in the class namespace. If present, this must
be propagated up to the <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> call in order for the class to be
initialised correctly.
Failing to do so will result in a <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> in Python 3.8.</p>
</div>
<p>デフォルトのメタクラス <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> や最終的には <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> を呼び出すメタクラスを使っているときは、クラスオブジェクトを作成した後に次のカスタム化の手順が起動されます:</p>
<ul class="simple">
<li>最初に、 <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> が <a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> が定義されているクラスの名前空間にある全てのデスクリプタを収集します;</li>
<li>次に、それら全ての <code class="docutils literal notranslate"><span class="pre">__set_name__</span></code> メソッドが、そのメソッドが定義されているクラス、およびそこに属するデスクリプタに割り当てられている名前を引数として呼び出されます;</li>
<li>最後に、新しいクラスのメソッド解決順序ですぐ上に位置する親クラスで <a class="reference internal" href="#object.__init_subclass__" title="object.__init_subclass__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init_subclass__()</span></code></a> フックが呼び出されます。</li>
</ul>
<p>クラスオブジェクトが作成された後には、クラス定義に含まれているクラスデコレータ (もしあれば) にクラスオブジェクトが渡され、デコレータが返すオブジェクトがここで定義されたクラスとしてローカルの名前空間に束縛されます。</p>
<p>新しいクラスが <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> で生成されたときは、名前空間引数として与えられたオブジェクトは新しい順序付きのマッピングに複製され、元のオブジェクトは破棄されます。
新しく複製したものは読み出し専用のプロキシでラップされ、クラスオブジェクトの <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性になります。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-89"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3135"><strong>PEP 3135</strong></a> - New super</dt>
<dd>暗黙の <code class="docutils literal notranslate"><span class="pre">__class__</span></code> クロージャ参照について記述しています</dd>
</dl>
</div>
</div>
<div class="section" id="uses-for-metaclasses">
<h4>3.3.3.7. メタクラスの用途<a class="headerlink" href="#uses-for-metaclasses" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>メタクラスは限りない潜在的利用価値を持っています。これまで試されてきたアイデアには、列挙型、ログ記録、インタフェースのチェック、 自動デリゲーション、自動プロパティ生成、プロキシ、フレームワーク、そして自動リソースロック／同期といったものがあります。</p>
</div>
</div>
<div class="section" id="customizing-instance-and-subclass-checks">
<h3>3.3.4. インスタンスのカスタマイズとサブクラスチェック<a class="headerlink" href="#customizing-instance-and-subclass-checks" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下のメソッドは組み込み関数 <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> と <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> のデフォルトの動作を上書きするのに利用します。</p>
<p>特に、 <a class="reference internal" href="../library/abc.html#abc.ABCMeta" title="abc.ABCMeta"><code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABCMeta</span></code></a> メタクラスは、抽象基底クラス (ABCs) を&quot;仮想基底クラス (virtual base classes)&quot; として、他の ABC を含む、任意のクラスや (組み込み型を含む) 型に追加するために、これらのメソッドを実装しています。</p>
<dl class="method">
<dt id="class.__instancecheck__">
<code class="descclassname">class.</code><code class="descname">__instancecheck__</code><span class="sig-paren">(</span><em>self</em>, <em>instance</em><span class="sig-paren">)</span><a class="headerlink" href="#class.__instancecheck__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>instance</em> が (直接、または間接的に) <em>class</em> のインスタンスと考えられる場合に true を返します。定義されていれば、 <code class="docutils literal notranslate"><span class="pre">isinstance(instance,</span> <span class="pre">class)</span></code> の実装のために呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="class.__subclasscheck__">
<code class="descclassname">class.</code><code class="descname">__subclasscheck__</code><span class="sig-paren">(</span><em>self</em>, <em>subclass</em><span class="sig-paren">)</span><a class="headerlink" href="#class.__subclasscheck__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>subclass</em> が (直接、または間接的に) <em>class</em> のサブクラスと考えられる場合に true を返します。定義されていれば、 <code class="docutils literal notranslate"><span class="pre">issubclass(subclass,</span> <span class="pre">class)</span></code> の実装のために呼び出されます。</p>
</dd></dl>

<p>なお、これらのメソッドは、クラスの型 (メタクラス) 上で検索されます。実際のクラスにクラスメソッドとして定義することはできません。これは、インスタンスそれ自体がクラスであるこの場合にのみ、インスタンスに呼び出される特殊メソッドの検索と一貫しています。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-117"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3119"><strong>PEP 3119</strong></a> - 抽象基底クラスの導入</dt>
<dd>抽象基底クラス (<a class="reference internal" href="../library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a> モジュールを参照) を言語に追加する文脈においての動機から、 <a class="reference internal" href="#class.__instancecheck__" title="class.__instancecheck__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__instancecheck__()</span></code></a> と <a class="reference internal" href="#class.__subclasscheck__" title="class.__subclasscheck__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__subclasscheck__()</span></code></a> を通して、 <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> と <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> に独自の動作をさせるための仕様の記述があります。</dd>
</dl>
</div>
</div>
<div class="section" id="emulating-generic-types">
<h3>3.3.5. ジェネリック型をエミュレートする<a class="headerlink" href="#emulating-generic-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>特殊メソッドを定義することで、 <span class="target" id="index-118"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> で指定されたジェネリッククラス構文 (例えば <code class="docutils literal notranslate"><span class="pre">List[int]</span></code>) を実装できます:</p>
<dl class="classmethod">
<dt id="object.__class_getitem__">
<em class="property">classmethod </em><code class="descclassname">object.</code><code class="descname">__class_getitem__</code><span class="sig-paren">(</span><em>cls</em>, <em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__class_getitem__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>key</em> にある型引数で特殊化されたジェネリッククラスを表すオブジェクトを返します。</p>
</dd></dl>

<p>このメソッドはクラスオブジェクト自身から検索され、クラスの本体に定義されていたら、暗黙的にクラスメソッドになります。
この機構は主に静的な型ヒントで使うために備わっているもので、それ以外での使用は推奨されません。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><span class="target" id="index-119"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0560"><strong>PEP 560</strong></a> - typing モジュールとジェネリック型に対する言語コアによるサポート</p>
</div>
</div>
<div class="section" id="emulating-callable-objects">
<span id="callable-types"></span><h3>3.3.6. 呼び出し可能オブジェクトをエミュレートする<a class="headerlink" href="#emulating-callable-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="method">
<dt id="object.__call__">
<code class="descclassname">object.</code><code class="descname">__call__</code><span class="sig-paren">(</span><em>self</em><span class="optional">[</span>, <em>args...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__call__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-93">インスタンスが関数として &quot;呼ばれた&quot; 際に呼び出されます; このメソッドが定義されている場合、 <code class="docutils literal notranslate"><span class="pre">x(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code> は <code class="docutils literal notranslate"><span class="pre">x.__call__(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code> を短く書いたものになります。</p>
</dd></dl>

</div>
<div class="section" id="emulating-container-types">
<span id="sequence-types"></span><h3>3.3.7. コンテナをエミュレートする<a class="headerlink" href="#emulating-container-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The following methods can be defined to implement container objects.  Containers
usually are sequences (such as lists or tuples) or mappings (like dictionaries),
but can represent other containers as well.  The first set of methods is used
either to emulate a sequence or to emulate a mapping; the difference is that for
a sequence, the allowable keys should be the integers <em>k</em> for which <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span>
<span class="pre">N</span></code> where <em>N</em> is the length of the sequence, or slice objects, which define a
range of items.  It is also recommended that mappings provide the methods
<code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">values()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">items()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">clear()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">setdefault()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">popitem()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code>, and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code> behaving similar to those for Python's standard dictionary
objects.  The <a class="reference internal" href="../library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> module provides a
<a class="reference internal" href="../library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableMapping</span></code></a>
abstract base class to help create those methods from a base set of
<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, <a class="reference internal" href="#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a>, <a class="reference internal" href="#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delitem__()</span></code></a>, and <code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code>.
Mutable sequences should provide methods <code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">index()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">extend()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">insert()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">remove()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">reverse()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code>, like Python standard list objects.  Finally,
sequence types should implement addition (meaning concatenation) and
multiplication (meaning repetition) by defining the methods <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a>,
<a class="reference internal" href="#object.__radd__" title="object.__radd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__radd__()</span></code></a>, <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a>, <a class="reference internal" href="#object.__mul__" title="object.__mul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mul__()</span></code></a>, <a class="reference internal" href="#object.__rmul__" title="object.__rmul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rmul__()</span></code></a> and
<a class="reference internal" href="#object.__imul__" title="object.__imul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__imul__()</span></code></a> described below; they should not define other numerical
operators.  It is recommended that both mappings and sequences implement the
<a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> method to allow efficient use of the <code class="docutils literal notranslate"><span class="pre">in</span></code> operator; for
mappings, <code class="docutils literal notranslate"><span class="pre">in</span></code> should search the mapping's keys; for sequences, it should
search through the values.  It is further recommended that both mappings and
sequences implement the <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> method to allow efficient iteration
through the container; for mappings, <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> should iterate
through the object's keys; for sequences, it should iterate through the values.</p>
<dl class="method">
<dt id="object.__len__">
<code class="descclassname">object.</code><code class="descname">__len__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__len__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-94">呼び出して組み込み関数 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> を実装します。
オブジェクトの長さを 0 以上の整数で返さなければなりません。
また、 <a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a>  メソッドを定義しておらず、 <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> メソッドが 0 を返すようなオブジェクトは、ブール演算コンテキストでは偽とみなされます。</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> CPython では、オブジェクトの長さは最大でも <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.maxsize</span></code></a> であることが要求されます。
長さが <code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.maxsize</span></code> を越える場合、(<a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> のような) いくつかの機能は <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a> を送出するでしょう。
真偽値としての判定で <code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code> を送出しないようにするには、オブジェクトは meth:<cite>__bool__</cite> メソッドを定義していなければなりません。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__length_hint__">
<code class="descclassname">object.</code><code class="descname">__length_hint__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__length_hint__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Called to implement <a class="reference internal" href="../library/operator.html#operator.length_hint" title="operator.length_hint"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.length_hint()</span></code></a>. Should return an estimated
length for the object (which may be greater or less than the actual length).
The length must be an integer <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 0. The return value may also be
<a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-const docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>, which is treated the same as if the
<code class="docutils literal notranslate"><span class="pre">__length_hint__</span></code> method didn't exist at all. This method is purely an
optimization and is never required for correctness.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<div class="admonition note" id="index-95">
<p class="first admonition-title">注釈</p>
<p>スライシングは、以下の 3 メソッドによって排他的に行われます。次のような呼び出しは</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
</pre></div>
</div>
<p>次のように翻訳され</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">=</span> <span class="n">b</span>
</pre></div>
</div>
<p class="last">以下も同様です。存在しないスライスの要素は <code class="docutils literal notranslate"><span class="pre">None</span></code> で埋められます。</p>
</div>
<dl class="method">
<dt id="object.__getitem__">
<code class="descclassname">object.</code><code class="descname">__getitem__</code><span class="sig-paren">(</span><em>self</em>, <em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getitem__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">self[key]</span></code> の値評価 (evaluation) を実現するために呼び出されます。シーケンスの場合、キーとして整数とスライスオブジェクトを受理できなければなりません。 (シーケンス型をエミュレートする場合) 負のインデクスの解釈は <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> メソッド次第となります。 <em>key</em> が不適切な型であった場合、 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> を送出してもかまいません; (負のインデクス値に対して何らかの解釈を行った上で) <em>key</em> がシーケンスのインデクス集合外の値である場合、 <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> を送出しなければなりません。マップ型の場合は、 <em>key</em> に誤りがある場合（コンテナに含まれていない場合）、 <a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> を送出しなければなりません。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> ループでは、シーケンスの終端を正しく検出できるようにするために、不正なインデクスに対して <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> が送出されるものと期待しています。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__setitem__">
<code class="descclassname">object.</code><code class="descname">__setitem__</code><span class="sig-paren">(</span><em>self</em>, <em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setitem__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">self[key]</span></code> に対する代入を実装するために呼び出されます。 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> と同じ注意事項があてはまります。このメソッドを実装できるのは、あるキーに対する値の変更をサポートしているか、新たなキーを追加できるようなマップの場合と、ある要素を置き換えることができるシーケンスの場合だけです。不正な <em>key</em> に対しては、 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> メソッドと同様の例外の送出を行わなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="object.__delitem__">
<code class="descclassname">object.</code><code class="descname">__delitem__</code><span class="sig-paren">(</span><em>self</em>, <em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delitem__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">self[key]</span></code> の削除を実装するために呼び出されます。 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> と同じ注意事項があてはまります。このメソッドを実装できるのは、キーの削除をサポートしているマップの場合と、要素を削除できるシーケンスの場合だけです。不正な <em>key</em> に対しては、 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> メソッドと同様の例外の送出を行わなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="object.__missing__">
<code class="descclassname">object.</code><code class="descname">__missing__</code><span class="sig-paren">(</span><em>self</em>, <em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__missing__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">self[key]</span></code> の実装において辞書内にキーが存在しなかった場合に、 dict のサブクラスのために <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>.<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> によって呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="object.__iter__">
<code class="descclassname">object.</code><code class="descname">__iter__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iter__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは、コンテナに対してイテレータが要求された際に呼び出されます。このメソッドは、コンテナ内の全てのオブジェクトに渡って反復処理できるような、新たなイテレータオブジェクトを返さなければなりません。マッピングでは、コンテナ内のキーに渡って反復処理しなければなりません。</p>
<p>イテレータオブジェクトでもこのメソッドを実装する必要があります; イテレータの場合、自分自身を返さなければなりません。イテレータオブジェクトに関するより詳細な情報は、 <a class="reference internal" href="../library/stdtypes.html#typeiter"><span class="std std-ref">イテレータ型</span></a> を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="object.__reversed__">
<code class="descclassname">object.</code><code class="descname">__reversed__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__reversed__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> 組み込み関数が逆方向イテレーションを実装するために、(存在すれば)呼び出します。コンテナ内の全要素を逆順にイテレートする、新しいイテレータを返すべきです。</p>
<p><a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> メソッドが定義されていない場合、 <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> 組込み関数は sequence プロトコル (<a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> と <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>) を使った方法にフォールバックします。 sequence プロトコルをサポートしたオブジェクトは、 <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> よりも効率のいい実装を提供できる場合にのみ <a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> を定義するべきです。</p>
</dd></dl>

<p>The membership test operators (<a class="reference internal" href="expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> and <a class="reference internal" href="expressions.html#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a>) are normally
implemented as an iteration through a container. However, container objects can
supply the following special method with a more efficient implementation, which
also does not require the object be iterable.</p>
<dl class="method">
<dt id="object.__contains__">
<code class="descclassname">object.</code><code class="descname">__contains__</code><span class="sig-paren">(</span><em>self</em>, <em>item</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__contains__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>帰属テスト演算を実装するために呼び出されます。 <em>item</em> が <em>self</em> 内に存在する場合には真を、そうでない場合には偽を返さなければなりません。マップオブジェクトの場合、値やキーと値の組ではなく、キーに対する帰属テストを考えなければなりません。</p>
<p><a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> を定義しないオブジェクトに対しては、メンバシップテストはまず、 <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> を使った反復を試みます、次に古いシーケンス反復プロトコル <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> を使います、 <a class="reference internal" href="expressions.html#membership-test-details"><span class="std std-ref">言語レファレンスのこの節</span></a> を参照して下さい。</p>
</dd></dl>

</div>
<div class="section" id="emulating-numeric-types">
<span id="numeric-types"></span><h3>3.3.8. 数値型をエミュレートする<a class="headerlink" href="#emulating-numeric-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下のメソッドを定義して、数値型オブジェクトをエミュレートすることができます。特定の種類の数値型ではサポートされていないような演算に対応するメソッド (非整数の数値に対するビット単位演算など) は、未定義のままにしておかなければなりません。</p>
<dl class="method">
<dt id="object.__add__">
<code class="descclassname">object.</code><code class="descname">__add__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__add__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__sub__">
<code class="descclassname">object.</code><code class="descname">__sub__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__sub__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__mul__">
<code class="descclassname">object.</code><code class="descname">__mul__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mul__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__matmul__">
<code class="descclassname">object.</code><code class="descname">__matmul__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__matmul__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__truediv__">
<code class="descclassname">object.</code><code class="descname">__truediv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__truediv__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__floordiv__">
<code class="descclassname">object.</code><code class="descname">__floordiv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__floordiv__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__mod__">
<code class="descclassname">object.</code><code class="descname">__mod__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mod__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__divmod__">
<code class="descclassname">object.</code><code class="descname">__divmod__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__divmod__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__pow__">
<code class="descclassname">object.</code><code class="descname">__pow__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="optional">[</span>, <em>modulo</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__pow__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__lshift__">
<code class="descclassname">object.</code><code class="descname">__lshift__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__lshift__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rshift__">
<code class="descclassname">object.</code><code class="descname">__rshift__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rshift__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__and__">
<code class="descclassname">object.</code><code class="descname">__and__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__and__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__xor__">
<code class="descclassname">object.</code><code class="descname">__xor__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__xor__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__or__">
<code class="descclassname">object.</code><code class="descname">__or__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__or__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-96">これらのメソッドを呼んで二項算術演算子 (<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>, <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">**</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>) を実装します。
例えば <em>x</em> が <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a> メソッドのあるクラスのインスタンスである場合、式 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code> を評価すると <code class="docutils literal notranslate"><span class="pre">x.__add__(y)</span></code> が呼ばれます。
<a class="reference internal" href="#object.__divmod__" title="object.__divmod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__divmod__()</span></code></a> メソッドは <a class="reference internal" href="#object.__floordiv__" title="object.__floordiv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__floordiv__()</span></code></a> と <a class="reference internal" href="#object.__mod__" title="object.__mod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mod__()</span></code></a> を使用するのと等価でなければなりません。
<a class="reference internal" href="#object.__truediv__" title="object.__truediv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__truediv__()</span></code></a> と関連してはなりません。
組み込みの <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> 関数の三項のものがサポートされていなければならない場合、 <a class="reference internal" href="#object.__pow__" title="object.__pow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__pow__()</span></code></a> はオプションの第三引数を受け取るものとして定義されなければなりません。</p>
<p>これらのメソッドのいずれかが渡された引数に対する操作を提供していない場合、 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> を返すべきです。</p>
</dd></dl>

<dl class="method">
<dt id="object.__radd__">
<code class="descclassname">object.</code><code class="descname">__radd__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__radd__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rsub__">
<code class="descclassname">object.</code><code class="descname">__rsub__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rsub__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rmul__">
<code class="descclassname">object.</code><code class="descname">__rmul__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmul__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rmatmul__">
<code class="descclassname">object.</code><code class="descname">__rmatmul__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmatmul__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rtruediv__">
<code class="descclassname">object.</code><code class="descname">__rtruediv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rtruediv__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rfloordiv__">
<code class="descclassname">object.</code><code class="descname">__rfloordiv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rfloordiv__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rmod__">
<code class="descclassname">object.</code><code class="descname">__rmod__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmod__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rdivmod__">
<code class="descclassname">object.</code><code class="descname">__rdivmod__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rdivmod__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rpow__">
<code class="descclassname">object.</code><code class="descname">__rpow__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="optional">[</span>, <em>modulo</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__rpow__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rlshift__">
<code class="descclassname">object.</code><code class="descname">__rlshift__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rlshift__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rrshift__">
<code class="descclassname">object.</code><code class="descname">__rrshift__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rrshift__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rand__">
<code class="descclassname">object.</code><code class="descname">__rand__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rand__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rxor__">
<code class="descclassname">object.</code><code class="descname">__rxor__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rxor__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ror__">
<code class="descclassname">object.</code><code class="descname">__ror__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ror__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-97">これらのメソッドを呼んで二項算術演算 (<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>, <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">**</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>) の、被演算子が反射した (入れ替えられた) ものを実装します。
これらの関数は、左側の被演算子が対応する演算をサポートしておらず  <a class="footnote-reference" href="#id10" id="id5">[3]</a>  、非演算子が異なる型の場合にのみ呼び出されます。 <a class="footnote-reference" href="#id11" id="id6">[4]</a>
例えば、 <em>y</em> が <a class="reference internal" href="#object.__rsub__" title="object.__rsub__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rsub__()</span></code></a> メソッドのあるクラスのインスタンスである場合、 式 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></code> を評価すると <code class="docutils literal notranslate"><span class="pre">x.__sub__(y)</span></code> が <em>NotImplemented</em> を返すときは <code class="docutils literal notranslate"><span class="pre">y.__rsub__(x)</span></code> が呼ばれます。</p>
<p id="index-98">ただし、三項演算子 <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> が <a class="reference internal" href="#object.__rpow__" title="object.__rpow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rpow__()</span></code></a> を呼ぶことはないので注意してください (型強制の規則が非常に難解になるからです)。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">右側の被演算子の型が左側の被演算子の型のサブクラスであり、このサブクラスであるメソッドに対する反射メソッドが定義されている場合には、左側の被演算子の非反射メソッドが呼ばれる前に、このメソッドが呼ばれます。この振る舞いにより、サブクラスが親の演算をオーバーライドすることが可能になります。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__iadd__">
<code class="descclassname">object.</code><code class="descname">__iadd__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iadd__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__isub__">
<code class="descclassname">object.</code><code class="descname">__isub__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__isub__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__imul__">
<code class="descclassname">object.</code><code class="descname">__imul__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imul__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__imatmul__">
<code class="descclassname">object.</code><code class="descname">__imatmul__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imatmul__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__itruediv__">
<code class="descclassname">object.</code><code class="descname">__itruediv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__itruediv__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ifloordiv__">
<code class="descclassname">object.</code><code class="descname">__ifloordiv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ifloordiv__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__imod__">
<code class="descclassname">object.</code><code class="descname">__imod__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imod__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ipow__">
<code class="descclassname">object.</code><code class="descname">__ipow__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="optional">[</span>, <em>modulo</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__ipow__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ilshift__">
<code class="descclassname">object.</code><code class="descname">__ilshift__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ilshift__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__irshift__">
<code class="descclassname">object.</code><code class="descname">__irshift__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__irshift__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__iand__">
<code class="descclassname">object.</code><code class="descname">__iand__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iand__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ixor__">
<code class="descclassname">object.</code><code class="descname">__ixor__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ixor__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ior__">
<code class="descclassname">object.</code><code class="descname">__ior__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ior__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これらのメソッドを呼び出して累算算術代入 (<code class="docutils literal notranslate"><span class="pre">+=</span></code>, <code class="docutils literal notranslate"><span class="pre">-=</span></code>, <code class="docutils literal notranslate"><span class="pre">*=</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;=</span></code>, <code class="docutils literal notranslate"><span class="pre">/=</span></code>, <code class="docutils literal notranslate"><span class="pre">//=</span></code>, <code class="docutils literal notranslate"><span class="pre">%=</span></code>, <code class="docutils literal notranslate"><span class="pre">**=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;=</span></code>, <code class="docutils literal notranslate"><span class="pre">^=</span></code>, <code class="docutils literal notranslate"><span class="pre">|=</span></code>) を実装します。
これらのメソッドは演算をインプレースで (<em>self</em> を変更する) 行うよう試み、その結果 (その必要はありませんが <em>self</em> でも構いません) を返さなければなりません。
特定のメソッドが定義されていない場合、その累算算術演算は通常のメソッドにフォールバックされます。
例えば <em>x</em> が <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a> メソッドを持つクラスのインスタンスである場合、<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">y</span></code> は <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x.__iadd__(y)</span></code> と等価です。
そうでない場合、<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code> の評価と同様に <code class="docutils literal notranslate"><span class="pre">x.__add__(y)</span></code> と <code class="docutils literal notranslate"><span class="pre">y.__radd__(x)</span></code> が考慮されます。
特定の状況では、累算代入は予期しないエラーに終わるかもしれません (<a class="reference internal" href="../faq/programming.html#faq-augmented-assignment-tuple-error"><span class="std std-ref">なぜ加算はされるのに a_tuple[i] += ['item'] は例外を送出するのですか?</span></a> を参照してください) が、この挙動は実際はデータモデルの挙動の一部です。</p>
</dd></dl>

<dl class="method">
<dt id="object.__neg__">
<code class="descclassname">object.</code><code class="descname">__neg__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__neg__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__pos__">
<code class="descclassname">object.</code><code class="descname">__pos__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__pos__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__abs__">
<code class="descclassname">object.</code><code class="descname">__abs__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__abs__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__invert__">
<code class="descclassname">object.</code><code class="descname">__invert__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__invert__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-99">呼び出して単項算術演算 (<code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a> および <code class="docutils literal notranslate"><span class="pre">~</span></code>) を実装します。</p>
</dd></dl>

<dl class="method">
<dt id="object.__complex__">
<code class="descclassname">object.</code><code class="descname">__complex__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__complex__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__int__">
<code class="descclassname">object.</code><code class="descname">__int__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__int__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__float__">
<code class="descclassname">object.</code><code class="descname">__float__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__float__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-100">組み込み関数の <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a>, <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a>, <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a> の実装から呼び出されます。
適切な型の値を返さなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="object.__index__">
<code class="descclassname">object.</code><code class="descname">__index__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__index__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>呼び出して <a class="reference internal" href="../library/operator.html#operator.index" title="operator.index"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.index()</span></code></a> を実装します。
Python が数値オブジェクトを整数オブジェクトに損失なく変換する必要がある場合 (たとえばスライシングや、組み込みの <a class="reference internal" href="../library/functions.html#bin" title="bin"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin()</span></code></a> 、 <a class="reference internal" href="../library/functions.html#hex" title="hex"><code class="xref py py-func docutils literal notranslate"><span class="pre">hex()</span></code></a> 、 <a class="reference internal" href="../library/functions.html#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a> 関数) は常に呼び出されます。
このメソッドがあるとその数値オブジェクトが整数型であることが示唆されます。
整数を返さなければなりません。</p>
<p>If <a class="reference internal" href="#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a>, <a class="reference internal" href="#object.__float__" title="object.__float__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__float__()</span></code></a> and <a class="reference internal" href="#object.__complex__" title="object.__complex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__complex__()</span></code></a> are not
defined then corresponding built-in functions <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a>, <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a>
and <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a> fall back to <a class="reference internal" href="#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="object.__round__">
<code class="descclassname">object.</code><code class="descname">__round__</code><span class="sig-paren">(</span><em>self</em><span class="optional">[</span>, <em>ndigits</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__round__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__trunc__">
<code class="descclassname">object.</code><code class="descname">__trunc__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__trunc__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__floor__">
<code class="descclassname">object.</code><code class="descname">__floor__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__floor__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ceil__">
<code class="descclassname">object.</code><code class="descname">__ceil__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ceil__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-101">組み込み関数の <a class="reference internal" href="../library/functions.html#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a> と <a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> モジュール関数の <a class="reference internal" href="../library/math.html#math.trunc" title="math.trunc"><code class="xref py py-func docutils literal notranslate"><span class="pre">trunc()</span></code></a>, <a class="reference internal" href="../library/math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">floor()</span></code></a>, <a class="reference internal" href="../library/math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal notranslate"><span class="pre">ceil()</span></code></a> の実装から呼び出されます。
<em>ndigits</em> が <code class="xref py py-meth docutils literal notranslate"><span class="pre">__round__()</span></code> に渡されない限りは、これらの全てのメソッドは <a class="reference internal" href="../library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a> (たいていは <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) に切り詰められたオブジェクトの値を返すべきです。</p>
<p><a class="reference internal" href="#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a> が定義されていない場合は、組み込み関数の <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> は <a class="reference internal" href="#object.__trunc__" title="object.__trunc__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__trunc__()</span></code></a> へフォールバックされます。</p>
</dd></dl>

</div>
<div class="section" id="with-statement-context-managers">
<span id="context-managers"></span><h3>3.3.9. with文とコンテキストマネージャ<a class="headerlink" href="#with-statement-context-managers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>コンテキストマネージャ(<em class="dfn">context manager</em>) とは、 <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 文の実行時にランタイムコンテキストを定義するオブジェクトです。コンテキストマネージャは、コードブロックを実行するために必要な入り口および出口の処理を扱います。コンテキストマネージャは通常、 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> 文（ <a class="reference internal" href="compound_stmts.html#with"><span class="std std-ref">with 文</span></a> の章を参照）により起動されますが、これらのメソッドを直接呼び出すことで起動することもできます。</p>
<p id="index-102">コンテキストマネージャの代表的な使い方としては、様々なグローバル情報の保存および更新、リソースのロックとアンロック、ファイルのオープンとクローズなどが挙げられます。</p>
<p>コンテキストマネージャについてのさらなる情報については、 <a class="reference internal" href="../library/stdtypes.html#typecontextmanager"><span class="std std-ref">コンテキストマネージャ型</span></a> を参照してください。</p>
<dl class="method">
<dt id="object.__enter__">
<code class="descclassname">object.</code><code class="descname">__enter__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__enter__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンテキストマネージャのの入り口で実行される処理です。 <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 文は、文の <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> 節で規定された値を返すこのメソッドを呼び出します。</p>
</dd></dl>

<dl class="method">
<dt id="object.__exit__">
<code class="descclassname">object.</code><code class="descname">__exit__</code><span class="sig-paren">(</span><em>self</em>, <em>exc_type</em>, <em>exc_value</em>, <em>traceback</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__exit__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンテキストマネージャの出口で実行される処理です。パラメータは、コンテキストが終了した原因となった例外について説明しています。コンテキストが例外を送出せず終了した場合は、全ての引き数に <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> が設定されます。</p>
<p>もし、例外が送出され、かつメソッドが例外を抑制したい場合（すなわち、例外が伝播されるのを防ぎたい場合）、このメソッドは True を返す必要があります。そうでなければ、このメソッドの終了後、例外は通常通り伝播することになります。</p>
<p><a class="reference internal" href="#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> メソッドは受け取った例外を再度送出すべきではありません。これは、呼び出し側の責任でおこなってください。</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-120"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0343"><strong>PEP 343</strong></a> - &quot;with&quot; 文</dt>
<dd>Python の <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 文の仕様、背景、および例が記載されています。</dd>
</dl>
</div>
</div>
<div class="section" id="special-method-lookup">
<span id="special-lookup"></span><h3>3.3.10. 特殊メソッド検索<a class="headerlink" href="#special-method-lookup" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>カスタムクラスでは、特殊メソッドの暗黙の呼び出しは、オブジェクトのインスタンス辞書ではなく、オブジェクトの型で定義されているときにのみ正しく動作することが保証されます。この動作のため、以下のコードは例外を送出します:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="fm">__len__</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">object of type &#39;C&#39; has no len()</span>
</pre></div>
</div>
<p>この動作の背景となる理由は、 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> と <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> といった type オブジェクトを含むすべてのオブジェクトで定義されている特殊メソッドにあります。これらのメソッドの暗黙の検索が通常の検索プロセスを使った場合、 type オブジェクト自体に対して実行されたときに失敗してしまいます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">descriptor &#39;__hash__&#39; of &#39;int&#39; object needs an argument</span>
</pre></div>
</div>
<p>クラスの非結合メソッドをこのようにして実行しようとすることは、'metaclass confusion' と呼ばれることもあり、特殊メソッドを検索するときはインスタンスをバイパスすることで回避されます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>正確性のためにインスタンス属性をスキップするのに加えて、特殊メソッド検索はオブジェクトのメタクラスを含めて、 <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> メソッドもバイパスします:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Metaclass getattribute invoked&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">Meta</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">10</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Class getattribute invoked&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>                 <span class="c1"># Explicit lookup via instance</span>
<span class="go">Class getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="fm">__len__</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>          <span class="c1"># Explicit lookup via type</span>
<span class="go">Metaclass getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>                      <span class="c1"># Implicit lookup</span>
<span class="go">10</span>
</pre></div>
</div>
<p>このように <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 機構をバイパスすることで、特殊メソッドの扱いに関するある程度の自由度と引き換えに (特殊メソッドはインタプリタから一貫して実行されるためにクラスオブジェクトに設定 <em>しなければならない</em>)、インタープリタを高速化するための大きな余地が手に入ります。</p>
</div>
</div>
<div class="section" id="coroutines">
<span id="index-104"></span><h2>3.4. コルーチン<a class="headerlink" href="#coroutines" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="awaitable-objects">
<h3>3.4.1. 待機可能オブジェクト (Awaitable Object)<a class="headerlink" href="#awaitable-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> オブジェクトは一般的には <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> が実装されています。
<a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 関数が返す <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">Coroutine</span></a> オブジェクトは待機可能です。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="../library/types.html#types.coroutine" title="types.coroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">types.coroutine()</span></code></a> デコレータもしくは <a class="reference internal" href="../library/asyncio-task.html#asyncio.coroutine" title="asyncio.coroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.coroutine()</span></code></a> でデコレータが付けられたジェネレータから返される <a class="reference internal" href="../glossary.html#term-generator-iterator"><span class="xref std std-term">generator iterator</span></a> オブジェクトも待機可能ですが、 <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> は実装されていません。</p>
</div>
<dl class="method">
<dt id="object.__await__">
<code class="descclassname">object.</code><code class="descname">__await__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__await__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> を返さなければなりません。
このメソッドは <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> オブジェクトを実装するのに使われるべきです。
簡単のために、 <a class="reference internal" href="../library/asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> にはこのメソッドが実装され、 <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 式と互換性を持つようになっています。</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">待機可能オブジェクトについてより詳しくは <span class="target" id="index-121"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> を参照してください。</p>
</div>
</div>
<div class="section" id="coroutine-objects">
<span id="id7"></span><h3>3.4.2. コルーチンオブジェクト<a class="headerlink" href="#coroutine-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">Coroutine</span></a> オブジェクトは <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> オブジェクトです。
<a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> を呼び出し、その返り値に対し反復処理をすることでコルーチンの実行を制御できます。
コルーチンの実行が完了し制御を戻したとき、イテレータは <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> を送出し、その例外の <code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> 属性に返り値を持たせます。
コルーチンが例外を送出した場合は、イテレータにより伝搬されます。
コルーチンから <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 例外を外に送出すべきではありません。</p>
<p>コルーチンには以下に挙げるメソッドもあり、これらはジェネレータのメソッドからの類似です (<a class="reference internal" href="expressions.html#generator-methods"><span class="std std-ref">ジェネレータ-イテレータメソッド</span></a> を参照してください)。
ただし、ジェネレータと違って、コルーチンは反復処理を直接はサポートしていません。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5.2 で変更: </span>コルーチンで2回以上待機 (await) すると <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> となります。</p>
</div>
<dl class="method">
<dt id="coroutine.send">
<code class="descclassname">coroutine.</code><code class="descname">send</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.send" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コルーチンの実行を開始したり再開したりします。
<em>value</em> が <code class="docutils literal notranslate"><span class="pre">None</span></code> の場合は、 <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> から返されたイテレータを進めるのと同等です。
<em>value</em> が <code class="docutils literal notranslate"><span class="pre">None</span></code> でない場合は、このコルーチンを一時停止させたイテレータの <a class="reference internal" href="expressions.html#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> メソッドに処理を委任します。
結果 (返り値か <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> かその他の例外) は、上で解説したような <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> の返り値に対して反復処理を行ったときと同じです。</p>
</dd></dl>

<dl class="method">
<dt id="coroutine.throw">
<code class="descclassname">coroutine.</code><code class="descname">throw</code><span class="sig-paren">(</span><em>type</em><span class="optional">[</span>, <em>value</em><span class="optional">[</span>, <em>traceback</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.throw" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コルーチンで指定された例外を送出します。
このメソッドは、イテレータにコルーチンを一時停止する <a class="reference internal" href="expressions.html#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> メソッドがある場合に処理を委任します。
そうでない場合には、中断した地点から例外が送出されます。
結果 (返り値か <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> かその他の例外) は、上で解説したような <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> の返り値に対して反復処理を行ったときと同じです。
例外がコルーチンの中で捕捉されなかった場合、呼び出し元へ伝搬されます。</p>
</dd></dl>

<dl class="method">
<dt id="coroutine.close">
<code class="descclassname">coroutine.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コルーチンが自分自身の後片付けをし終了します。
コルーチンが一時停止している場合は、コルーチンを一時停止させたイテレータに <a class="reference internal" href="expressions.html#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> メソッドがあれば、まずはそれに処理を委任します。
そして一時停止した地点から <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> が送出され、ただちにコルーチンが自分自身の後片付けを行います。
最後に、実行が開始されていなかった場合でも、コルーチンに実行が完了した印を付けます。</p>
<p>コルーチンオブジェクトが破棄されるときには、上記の手順を経て自動的に閉じられます。</p>
</dd></dl>

</div>
<div class="section" id="asynchronous-iterators">
<span id="async-iterators"></span><h3>3.4.3. 非同期イテレータ (Asynchronous Iterator)<a class="headerlink" href="#asynchronous-iterators" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><em>非同期イテレータ</em> の <code class="docutils literal notranslate"><span class="pre">__anext__</span></code> メソッドからは非同期のコードが呼べます。</p>
<p>非同期イテレータは <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 文の中で使えます。</p>
<dl class="method">
<dt id="object.__aiter__">
<code class="descclassname">object.</code><code class="descname">__aiter__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aiter__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>非同期イテレータ</em> オブジェクトを返さなくてはなりません。</p>
</dd></dl>

<dl class="method">
<dt id="object.__anext__">
<code class="descclassname">object.</code><code class="descname">__anext__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__anext__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>イテレータの次の値を返す <em>待機可能オブジェクト</em> を返さなければなりません。
反復処理が終了したときには <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> エラーを送出すべきです。</p>
</dd></dl>

<p>非同期イテラブルオブジェクトの例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Reader</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="fm">__aiter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__anext__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopAsyncIteration</span>
        <span class="k">return</span> <span class="n">val</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.7 で変更: </span>Python 3.7 より前では、 <code class="docutils literal notranslate"><span class="pre">__aiter__</span></code> は <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">非同期イテレータ</span></a> になる <em>awaitable</em> を返せました。</p>
<p>Python 3.7 からは、 <code class="docutils literal notranslate"><span class="pre">__aiter__</span></code> は非同期イテレータオブジェクトを返さなければなりません。
それ以外のものを返すと <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> になります。</p>
</div>
</div>
<div class="section" id="asynchronous-context-managers">
<span id="async-context-managers"></span><h3>3.4.4. 非同期コンテキストマネージャ (Asynchronous Context Manager)<a class="headerlink" href="#asynchronous-context-managers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><em>非同期コンテキストマネージャ</em> は、 <code class="docutils literal notranslate"><span class="pre">__aenter__</span></code> メソッドと <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code> メソッド内部で実行を一時停止できる <em>コンテキストマネージャ</em> です。</p>
<p>非同期コンテキストマネージャは <a class="reference internal" href="compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 文の中で使えます。</p>
<dl class="method">
<dt id="object.__aenter__">
<code class="descclassname">object.</code><code class="descname">__aenter__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aenter__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Semantically similar to <a class="reference internal" href="#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a>, the only
difference being that it must return an <em>awaitable</em>.</p>
</dd></dl>

<dl class="method">
<dt id="object.__aexit__">
<code class="descclassname">object.</code><code class="descname">__aexit__</code><span class="sig-paren">(</span><em>self</em>, <em>exc_type</em>, <em>exc_value</em>, <em>traceback</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aexit__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Semantically similar to <a class="reference internal" href="#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a>, the only
difference being that it must return an <em>awaitable</em>.</p>
</dd></dl>

<p>非同期コンテキストマネージャクラスの例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AsyncContextManager</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">log</span><span class="p">(</span><span class="s1">&#39;entering context&#39;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aexit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">log</span><span class="p">(</span><span class="s1">&#39;exiting context&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
<p class="rubric">脚注</p>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>特定の条件が満たされた場合、オブジェクトの type を変更することが <em>できます</em> 。これは、正しく扱われなかった場合にとても奇妙な動作を引き起こすので、一般的には良い考えではありません。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>, <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>, <a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a>, <a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> メソッドはこのような特別な扱われ方をします;
他の特殊メソッドも <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> を送出するかもしれませんが、これは <code class="docutils literal notranslate"><span class="pre">None</span></code> が呼び出し可能でないという振る舞いに基づいた動作です。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[3]</a></td><td>ここでの &quot;サポートしていない&quot; というのは、クラスがそのメソッドを持っていないか、そのメソッドが <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> を返すという意味です。
右の被演算子の対をなすメソッドへ処理を回したい場合には、メソッドに <code class="docutils literal notranslate"><span class="pre">None</span></code> を設定してはいけません—こうするとむしろ、処理を回すのを明示的に <em>妨げる</em> という正反対の効果を生みます。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[4]</a></td><td>同じ型の被演算子については、無反転のメソッド (たとえば <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a>) が失敗した場合、その演算はサポートされていないとみなされます。
これは、反射したメソッドが呼び出されないためです。</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">3. データモデル</a><ul>
<li><a class="reference internal" href="#objects-values-and-types">3.1. オブジェクト、値、および型</a></li>
<li><a class="reference internal" href="#the-standard-type-hierarchy">3.2. 標準型の階層</a></li>
<li><a class="reference internal" href="#special-method-names">3.3. 特殊メソッド名</a><ul>
<li><a class="reference internal" href="#basic-customization">3.3.1. 基本的なカスタマイズ</a></li>
<li><a class="reference internal" href="#customizing-attribute-access">3.3.2. 属性値アクセスをカスタマイズする</a><ul>
<li><a class="reference internal" href="#customizing-module-attribute-access">3.3.2.1. モジュールの属性値アクセスをカスタマイズする</a></li>
<li><a class="reference internal" href="#implementing-descriptors">3.3.2.2. デスクリプタ (descriptor) の実装</a></li>
<li><a class="reference internal" href="#invoking-descriptors">3.3.2.3. デスクリプタの呼び出し</a></li>
<li><a class="reference internal" href="#slots">3.3.2.4. __slots__</a><ul>
<li><a class="reference internal" href="#notes-on-using-slots">3.3.2.4.1. <em>__slots__</em> を利用する際の注意</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-class-creation">3.3.3. クラス生成をカスタマイズする</a><ul>
<li><a class="reference internal" href="#metaclasses">3.3.3.1. メタクラス</a></li>
<li><a class="reference internal" href="#resolving-mro-entries">3.3.3.2. MRO エントリの解決</a></li>
<li><a class="reference internal" href="#determining-the-appropriate-metaclass">3.3.3.3. 適切なメタクラスの決定</a></li>
<li><a class="reference internal" href="#preparing-the-class-namespace">3.3.3.4. クラスの名前空間の準備</a></li>
<li><a class="reference internal" href="#executing-the-class-body">3.3.3.5. クラス本体の実行</a></li>
<li><a class="reference internal" href="#creating-the-class-object">3.3.3.6. クラスオブジェクトの作成</a></li>
<li><a class="reference internal" href="#uses-for-metaclasses">3.3.3.7. メタクラスの用途</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-instance-and-subclass-checks">3.3.4. インスタンスのカスタマイズとサブクラスチェック</a></li>
<li><a class="reference internal" href="#emulating-generic-types">3.3.5. ジェネリック型をエミュレートする</a></li>
<li><a class="reference internal" href="#emulating-callable-objects">3.3.6. 呼び出し可能オブジェクトをエミュレートする</a></li>
<li><a class="reference internal" href="#emulating-container-types">3.3.7. コンテナをエミュレートする</a></li>
<li><a class="reference internal" href="#emulating-numeric-types">3.3.8. 数値型をエミュレートする</a></li>
<li><a class="reference internal" href="#with-statement-context-managers">3.3.9. with文とコンテキストマネージャ</a></li>
<li><a class="reference internal" href="#special-method-lookup">3.3.10. 特殊メソッド検索</a></li>
</ul>
</li>
<li><a class="reference internal" href="#coroutines">3.4. コルーチン</a><ul>
<li><a class="reference internal" href="#awaitable-objects">3.4.1. 待機可能オブジェクト (Awaitable Object)</a></li>
<li><a class="reference internal" href="#coroutine-objects">3.4.2. コルーチンオブジェクト</a></li>
<li><a class="reference internal" href="#asynchronous-iterators">3.4.3. 非同期イテレータ (Asynchronous Iterator)</a></li>
<li><a class="reference internal" href="#asynchronous-context-managers">3.4.4. 非同期コンテキストマネージャ (Asynchronous Context Manager)</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="lexical_analysis.html"
                        title="前の章へ">2. 字句解析</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="executionmodel.html"
                        title="次の章へ">4. 実行モデル</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.8/Doc/reference/datamodel.rst"
            rel="nofollow">ソースコードを表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. 実行モデル"
             >次へ</a> |</li>
        <li class="right" >
          <a href="lexical_analysis.html" title="2. 字句解析"
             >前へ</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.3rc1 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 言語リファレンス</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" type="text" name="q" />
          <input type="submit" value="検索" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">著作権</a> 2001-2020, Python Software Foundation.
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最終更新: 5月 12, 2020
    <a href="https://docs.python.org/3/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>

  </body>
</html>