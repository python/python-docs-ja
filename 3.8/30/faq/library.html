
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>ライブラリと拡張 FAQ &#8212; Python 3.8.3 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.8.3 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="next" title="拡張と埋め込み FAQ" href="extending.html" />
    <link rel="prev" title="デザインと歴史 FAQ" href="design.html" />
    <link rel="canonical" href="https://docs.python.org/3/faq/library.html" />
    
      
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="extending.html" title="拡張と埋め込み FAQ"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="design.html" title="デザインと歴史 FAQ"
             accesskey="P">前へ</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.3 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python よくある質問</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" type="text" name="q" />
          <input type="submit" value="検索" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="library-and-extension-faq">
<h1><a class="toc-backref" href="#id2">ライブラリと拡張 FAQ</a><a class="headerlink" href="#library-and-extension-faq" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="contents topic" id="id1">
<p class="topic-title">目次</p>
<ul class="simple">
<li><a class="reference internal" href="#library-and-extension-faq" id="id2">ライブラリと拡張 FAQ</a><ul>
<li><a class="reference internal" href="#general-library-questions" id="id3">ライブラリ一般の質問</a><ul>
<li><a class="reference internal" href="#how-do-i-find-a-module-or-application-to-perform-task-x" id="id4">作業 X を行うためのモジュールやアプリケーションを探すにはどうしますか？</a></li>
<li><a class="reference internal" href="#where-is-the-math-py-socket-py-regex-py-etc-source-file" id="id5">math.py (socket.py, regex.py, etc.) のソースファイルはどこにありますか？</a></li>
<li><a class="reference internal" href="#how-do-i-make-a-python-script-executable-on-unix" id="id6">Python のスクリプトを Unix で実行可能にするにはどうしますか？</a></li>
<li><a class="reference internal" href="#is-there-a-curses-termcap-package-for-python" id="id7">Python には curses/termcap パッケージはありますか？</a></li>
<li><a class="reference internal" href="#is-there-an-equivalent-to-c-s-onexit-in-python" id="id8">Python には C の onexit() に相当するものはありますか？</a></li>
<li><a class="reference internal" href="#why-don-t-my-signal-handlers-work" id="id9">シグナルハンドラが動かないのですがなぜですか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#common-tasks" id="id10">よくある作業</a><ul>
<li><a class="reference internal" href="#how-do-i-test-a-python-program-or-component" id="id11">Python のプログラムやコンポーネントをテストするにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-do-i-create-documentation-from-doc-strings" id="id12">Python のドキュメント文字列からドキュメントを生成するにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-do-i-get-a-single-keypress-at-a-time" id="id13">一度に一つの押鍵を取得するにはどうしますか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#threads" id="id14">スレッド</a><ul>
<li><a class="reference internal" href="#how-do-i-program-using-threads" id="id15">スレッドを使ったプログラムを書くにはどうしますか？</a></li>
<li><a class="reference internal" href="#none-of-my-threads-seem-to-run-why" id="id16">スレッドが一つも実行されていないようです。なぜですか？</a></li>
<li><a class="reference internal" href="#how-do-i-parcel-out-work-among-a-bunch-of-worker-threads" id="id17">たくさんのワーカースレッドに作業を割り振るにはどうしますか？</a></li>
<li><a class="reference internal" href="#what-kinds-of-global-value-mutation-are-thread-safe" id="id18">グローバルな値のどんな種類の変更がスレッドセーフになるのですか？</a></li>
<li><a class="reference internal" href="#can-t-we-get-rid-of-the-global-interpreter-lock" id="id19">グローバルインタプリタロック (Global Interpreter Lock) を取り除くことはできないのですか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#input-and-output" id="id20">入力と出力</a><ul>
<li><a class="reference internal" href="#how-do-i-delete-a-file-and-other-file-questions" id="id21">ファイルを削除するにはどうしますか？ (その他、ファイルに関する質問...)</a></li>
<li><a class="reference internal" href="#how-do-i-copy-a-file" id="id22">ファイルをコピーするにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-do-i-read-or-write-binary-data" id="id23">バイナリデータを読み書きするにはどうしますか？</a></li>
<li><a class="reference internal" href="#i-can-t-seem-to-use-os-read-on-a-pipe-created-with-os-popen-why" id="id24">os.popen() によって作られたパイプで os.read() が使われていないようです。なぜですか？</a></li>
<li><a class="reference internal" href="#how-do-i-access-the-serial-rs232-port" id="id25">シリアル (RS232) ポートにアクセスするにはどうしますか？</a></li>
<li><a class="reference internal" href="#why-doesn-t-closing-sys-stdout-stdin-stderr-really-close-it" id="id26">sys.stdout (stdin, stderr) を閉じようとしても実際に閉じられないのはなぜですか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#network-internet-programming" id="id27">ネットワーク/インターネットプログラミング</a><ul>
<li><a class="reference internal" href="#what-www-tools-are-there-for-python" id="id28">Python の WWW ツールには何がありますか？</a></li>
<li><a class="reference internal" href="#how-can-i-mimic-cgi-form-submission-method-post" id="id29">CGI フォームの発信 (METHOD=POST) を模倣するにはどうしますか？</a></li>
<li><a class="reference internal" href="#what-module-should-i-use-to-help-with-generating-html" id="id30">どのモジュールが HTML の生成の役に立ちますか？</a></li>
<li><a class="reference internal" href="#how-do-i-send-mail-from-a-python-script" id="id31">Python のスクリプトからメールを送るにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-do-i-avoid-blocking-in-the-connect-method-of-a-socket" id="id32">ソケットの connect() メソッドでブロッキングされなくするにはどうしますか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#databases" id="id33">データベース</a><ul>
<li><a class="reference internal" href="#are-there-any-interfaces-to-database-packages-in-python" id="id34">Python にはデータベースパッケージへのインタフェースはありますか？</a></li>
<li><a class="reference internal" href="#how-do-you-implement-persistent-objects-in-python" id="id35">Python で永続的なオブジェクトを実装するにはどうしますか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mathematics-and-numerics" id="id36">数学と数</a><ul>
<li><a class="reference internal" href="#how-do-i-generate-random-numbers-in-python" id="id37">Python で乱数を生成するにはどうしますか？</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="general-library-questions">
<h2><a class="toc-backref" href="#id3">ライブラリ一般の質問</a><a class="headerlink" href="#general-library-questions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="how-do-i-find-a-module-or-application-to-perform-task-x">
<h3><a class="toc-backref" href="#id4">作業 X を行うためのモジュールやアプリケーションを探すにはどうしますか？</a><a class="headerlink" href="#how-do-i-find-a-module-or-application-to-perform-task-x" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/index.html#library-index"><span class="std std-ref">ライブラリリファンレス</span></a> から関係がありそうな標準ライブラリモジュールがあるかどうか調べてください。 (標準ライブラリに何があるかが分かるようになると、この段階をスキップすることができます。)</p>
<p>サードパーティのパッケージについては、<a class="reference external" href="https://pypi.org">Python Package Index</a> を探したり、<a class="reference external" href="https://www.google.com">Google</a> その他の Web サーチエンジンを試してください。&quot;Python&quot; に加えて一つか二つのキーワードで興味のある話題を検索すれば、たいてい役に立つものが見つかるでしょう。</p>
</div>
<div class="section" id="where-is-the-math-py-socket-py-regex-py-etc-source-file">
<h3><a class="toc-backref" href="#id5">math.py (socket.py, regex.py, etc.) のソースファイルはどこにありますか？</a><a class="headerlink" href="#where-is-the-math-py-socket-py-regex-py-etc-source-file" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>モジュールのソースファイルが見付けられない場合は、それは C 、 C++ かもしくは別のコンパイル言語で実装された、ビルトインもしくは動的に読み込まれるモジュールかもしれません。この場合、ソースは手に入らないかもしれませんし、 <code class="file docutils literal notranslate"><span class="pre">mathmodule.c</span></code> のようなものが (Python の読み込みパスに無い) C ソースディレクトリのどこかにあるかもしれません。</p>
<p>Python のモジュールには、(少なくとも) 3 種類あります:</p>
<ol class="arabic">
<li><p class="first">Python で書かれたモジュール (.py)。</p>
</li>
<li><p class="first">C で書かれ、動的にロードされるモジュール (.dll, .pyd, .so, .sl, etc)。</p>
</li>
<li><p class="first">C で書かれ、インタプリタにリンクされているモジュール。このリストを得るには、こうタイプしてください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">builtin_module_names</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="how-do-i-make-a-python-script-executable-on-unix">
<h3><a class="toc-backref" href="#id6">Python のスクリプトを Unix で実行可能にするにはどうしますか？</a><a class="headerlink" href="#how-do-i-make-a-python-script-executable-on-unix" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>二つの条件があります :スクリプトファイルのモードが実行可能で、最初の行が <code class="docutils literal notranslate"><span class="pre">#!</span></code> で始まり Python インタプリタのパスが続いていなければなりません。</p>
<p>前者は、<code class="docutils literal notranslate"><span class="pre">chmod</span> <span class="pre">+x</span> <span class="pre">scriptfile</span></code> 、場合によっては <code class="docutils literal notranslate"><span class="pre">chmod</span> <span class="pre">755</span> <span class="pre">scriptfile</span></code> を実行すればできます。</p>
<p>後者は、いくつかの方法でできます。最も直接的な方法はこのように</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/local/bin/python</span>
</pre></div>
</div>
<p>のようにファイルの一番最初の行に、プラットフォーム上の Python がインストールされているパス名を書くことです。</p>
<p>スクリプトを Python インタプリタの場所に依存させたくない場合は、 <strong class="program">env</strong> プログラムが使えます。 Python インタプリタがユーザの <span class="target" id="index-4"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PATH</span></code> のディレクトリにあることを前提とすれば、ほとんど全ての Unix 系 OS では次の書き方をサポートしています:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
</pre></div>
</div>
<p>CGI スクリプトでこれをやっては <em>いけません</em> 。 CGI スクリプトの <span class="target" id="index-5"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PATH</span></code> 変数はたいてい最小限のものになっているので、実際のインタプリタの絶対パスを使う必要があります。</p>
<p>ときおり、ユーザ環境に余裕が無く <strong class="program">/usr/bin/env</strong> プログラムが失敗することがあります; もしくは、 env プログラム自体が無いことがあります。そのような場合は、次の (Alex Rezinsky による) ハックが試せます:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="ch">#! /bin/sh</span>
<span class="s2">&quot;&quot;&quot;:&quot;</span>
<span class="nb">exec</span> python <span class="nv">$0</span> <span class="si">${</span><span class="nv">1</span><span class="p">+</span><span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span><span class="si">}</span>
<span class="s2">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>これには、スクリプトの __doc__ 文字列を定義するというちょっとした欠点があります。しかし、これを付け足せば直せます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;...Whatever...&quot;&quot;&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="is-there-a-curses-termcap-package-for-python">
<h3><a class="toc-backref" href="#id7">Python には curses/termcap パッケージはありますか？</a><a class="headerlink" href="#is-there-a-curses-termcap-package-for-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Unix 系 OS において: 標準の Python ソースディストリビューションには <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Modules">Modules</a> サブディレクトリに curses モジュールが付いてきますが、デフォルトではコンパイルされていません。 (これは Windows 用ディストリビューションでは利用できないことに注意してください -- Windows には curses モジュールはありません。)</p>
<p><a class="reference internal" href="../library/curses.html#module-curses" title="curses: An interface to the curses library, providing portable terminal handling. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">curses</span></code></a> モジュールは基本的な curses の機能や、色付きの表示、別の文字集合サポート、パッド、マウスサポートなどの ncurses や SYSV curses の多くの機能をサポートしています。このことは、モジュールが BSD curses だけしか持っていない OS とは互換性が無いことを意味しますが、現在メンテナンスされている OS でそういう類のものは無さそうです。</p>
<p>Windows では: <a class="reference external" href="http://effbot.org/zone/console-index.htm">the consolelib module</a> を使ってください。</p>
</div>
<div class="section" id="is-there-an-equivalent-to-c-s-onexit-in-python">
<h3><a class="toc-backref" href="#id8">Python には C の onexit() に相当するものはありますか？</a><a class="headerlink" href="#is-there-an-equivalent-to-c-s-onexit-in-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a> モジュールは、 C の <code class="xref c c-func docutils literal notranslate"><span class="pre">onexit()</span></code> と同じような関数登録を提供します。</p>
</div>
<div class="section" id="why-don-t-my-signal-handlers-work">
<h3><a class="toc-backref" href="#id9">シグナルハンドラが動かないのですがなぜですか？</a><a class="headerlink" href="#why-don-t-my-signal-handlers-work" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>最もありがちな問題は、シグナルハンドラが間違った引数リストで宣言されていることです。これは次のように呼び出されます</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">handler</span><span class="p">(</span><span class="n">signum</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
</pre></div>
</div>
<p>だから、これは二つの引数で宣言されるべきです:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">signum</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="common-tasks">
<h2><a class="toc-backref" href="#id10">よくある作業</a><a class="headerlink" href="#common-tasks" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="how-do-i-test-a-python-program-or-component">
<h3><a class="toc-backref" href="#id11">Python のプログラムやコンポーネントをテストするにはどうしますか？</a><a class="headerlink" href="#how-do-i-test-a-python-program-or-component" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python には二つのテストフレームワークがついています。<a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> モジュールは、モジュールの docstring から使用例を見つけてそれらを実行し、出力を docstring によって与えられた望まれる出力と比較します。</p>
<p><a class="reference internal" href="../library/unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> モジュールは、Java や Smalltalk のテストフレームワークを模した装飾されたテストフレームワークです。</p>
<p>テスト作業を簡単にするために、プログラムにおいてモジュール性の良い設計を使うべきです。プログラムでは、ほぼ全ての処理を関数やクラスのメソッドで包むべきです -- こうすることで、プログラムが速くなるという驚くような愉快な効果がときおり得られることがあります (というのも、ローカル変数へのアクセスはグローバルなアクセスよりも速いからです)。さらに言うと、テストを行うのがより難しくなってしまうため、プログラムは可変なグローバル変数に依存するのを避けるべきです。</p>
<p>プログラムの &quot;global main logic&quot; は</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main_logic</span><span class="p">()</span>
</pre></div>
</div>
<p>のように main モジュールの最後に出来る限りシンプルなものを書くのが良いでしょう。</p>
<p>プログラムが整理され、関数やクラスの動作が追いやすい状態になったら、その動作を試すテスト関数を書くべきです。一連のテストを自動化するテストスイートは、それぞれのモジュールに関連付けることができます。これは手間が掛かりそうに思えますが、Python は簡素で融通が効くので、驚くほど簡単です。&quot;製品コード (production code)&quot; と並行でテスト関数を書くことで、バグや設計の不備でさえも早い段階で簡単に見付かるようになるので、コーディング作業をより心地良く楽しいものにできます。</p>
<p>プログラムのメインモジュールとして設計されたのではない &quot;補助モジュール&quot; には、モジュールの自己テストを含めるといいでしょう。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">self_test</span><span class="p">()</span>
</pre></div>
</div>
<p>複雑な外部インタフェースと作用し合うプログラムでさえ、外部インタフェースが使えない時でも、Python で実装された &quot;fake&quot; インタフェースを使ってテストできます。</p>
</div>
<div class="section" id="how-do-i-create-documentation-from-doc-strings">
<h3><a class="toc-backref" href="#id12">Python のドキュメント文字列からドキュメントを生成するにはどうしますか？</a><a class="headerlink" href="#how-do-i-create-documentation-from-doc-strings" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> モジュールで Python ソースコード内のドキュメント文字列から HTML を生成できます。純粋に docstring から API ドキュメントを生成するには、他に <a class="reference external" href="http://epydoc.sourceforge.net/">epydoc</a> という選択肢もあります。 <a class="reference external" href="http://sphinx-doc.org">Sphinx</a> も docstring の内容を含めることができます。</p>
</div>
<div class="section" id="how-do-i-get-a-single-keypress-at-a-time">
<h3><a class="toc-backref" href="#id13">一度に一つの押鍵を取得するにはどうしますか？</a><a class="headerlink" href="#how-do-i-get-a-single-keypress-at-a-time" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Unix 系 OS ではいくつか解決方法があります。curses を使うのが素直なやり方ですが、curses は学ぶには少し大き過ぎるモジュールです。</p>
</div>
</div>
<div class="section" id="threads">
<h2><a class="toc-backref" href="#id14">スレッド</a><a class="headerlink" href="#threads" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="how-do-i-program-using-threads">
<h3><a class="toc-backref" href="#id15">スレッドを使ったプログラムを書くにはどうしますか？</a><a class="headerlink" href="#how-do-i-program-using-threads" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/_thread.html#module-_thread" title="_thread: Low-level threading API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">_thread</span></code></a> モジュールではなく、必ず <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> モジュールを使ってください。 <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> モジュールは、 <a class="reference internal" href="../library/_thread.html#module-_thread" title="_thread: Low-level threading API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">_thread</span></code></a> モジュールで提供される低レベルな基本要素の、便利な抽象化を構成します。</p>
<p>Aahz は、役立つスレッディングのチュートリアルから成るスライドを揃えています。 <a class="reference external" href="http://www.pythoncraft.com/OSCON2001/">http://www.pythoncraft.com/OSCON2001/</a> を参照してください。</p>
</div>
<div class="section" id="none-of-my-threads-seem-to-run-why">
<h3><a class="toc-backref" href="#id16">スレッドが一つも実行されていないようです。なぜですか？</a><a class="headerlink" href="#none-of-my-threads-seem-to-run-why" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>メインスレッドが終了するとともに、全てのスレッドは終了されます。メインスレッドは速く働きすぎるので、スレッドには何をする時間も与えられません。</p>
<p>簡単な解決策は、プログラムの終わりに、スレッドが完了するのに十分な時間のスリープを加えることです:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span><span class="o">,</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">thread_task</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">thread_task</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="p">))</span>
    <span class="n">T</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  <span class="c1"># &lt;---------------------------!</span>
</pre></div>
</div>
<p>しかし、実際は (ほとんどのプラットフォームでは) スレッドは並行して実行されるのではなく、一つづつ実行されるのです！なぜなら、OS のスレッドスケジューラは、前のスレッドがブロックされるまで新しいスレッドを開始しないからです。</p>
<p>簡単に直すには、関数の実行の最初にちょっとスリープを加えることです:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">thread_task</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.001</span><span class="p">)</span>  <span class="c1"># &lt;--------------------!</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">thread_task</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="p">))</span>
    <span class="n">T</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/time.html#time.sleep" title="time.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.sleep()</span></code></a> の良い遅延時間を推測しようとするよりも、セマフォのような仕組みを使う方が良いでしょう。 1 つのアイディアは <a class="reference internal" href="../library/queue.html#module-queue" title="queue: A synchronized queue class."><code class="xref py py-mod docutils literal notranslate"><span class="pre">queue</span></code></a> モジュールを使って、キューオブジェクトを作り、各スレッドが完了したときにキューにトークンを追加し、メインスレッドにスレッドと同じ数のトークンをキューから読み出させることです。</p>
</div>
<div class="section" id="how-do-i-parcel-out-work-among-a-bunch-of-worker-threads">
<h3><a class="toc-backref" href="#id17">たくさんのワーカースレッドに作業を割り振るにはどうしますか？</a><a class="headerlink" href="#how-do-i-parcel-out-work-among-a-bunch-of-worker-threads" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>最も簡単な方法は、新しい <a class="reference internal" href="../library/concurrent.futures.html#module-concurrent.futures" title="concurrent.futures: Execute computations concurrently using threads or processes."><code class="xref py py-mod docutils literal notranslate"><span class="pre">concurrent.futures</span></code></a> モジュール、特に <a class="reference internal" href="../library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a> クラスを使うことです。</p>
<p>もしくは、実行アルゴリズムを上手にコントロールしたい場合は、自身の手でロジックを書くこともできます。 <a class="reference internal" href="../library/queue.html#module-queue" title="queue: A synchronized queue class."><code class="xref py py-mod docutils literal notranslate"><span class="pre">queue</span></code></a> モジュールを使って、ジョブのリストを含むキューを作ってください。 <a class="reference internal" href="../library/queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> クラスはオブジェクトのリストを保持し、キューに要素を追加する <code class="docutils literal notranslate"><span class="pre">.put(obj)</span></code> メソッド、それら要素を返す <code class="docutils literal notranslate"><span class="pre">.get()</span></code> メソッドを持っています。このクラスは、それぞれのジョブがきっちり 1 回だけ取り出されることを保証するのに必要なロック処理にも配慮します。</p>
<p>ここにちょっとした例があります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span><span class="o">,</span> <span class="nn">queue</span><span class="o">,</span> <span class="nn">time</span>

<span class="c1"># The worker thread gets jobs off the queue.  When the queue is empty, it</span>
<span class="c1"># assumes there will be no more work and exits.</span>
<span class="c1"># (Realistically workers will run until terminated.)</span>
<span class="k">def</span> <span class="nf">worker</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running worker&#39;</span><span class="p">)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">queue</span><span class="o">.</span><span class="n">Empty</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Worker&#39;</span><span class="p">,</span> <span class="n">threading</span><span class="o">.</span><span class="n">currentThread</span><span class="p">(),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;queue empty&#39;</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Worker&#39;</span><span class="p">,</span> <span class="n">threading</span><span class="o">.</span><span class="n">currentThread</span><span class="p">(),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;running with argument&#39;</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Create queue</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>

<span class="c1"># Start a pool of 5 workers</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">worker</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;worker </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="c1"># Begin adding work to the queue</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">):</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="c1"># Give threads time to run</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Main thread sleeping&#39;</span><span class="p">)</span>
<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>実行時には、以下のように出力されます:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Running worker
Running worker
Running worker
Running worker
Running worker
Main thread sleeping
Worker &lt;Thread(worker 1, started 130283832797456)&gt; running with argument 0
Worker &lt;Thread(worker 2, started 130283824404752)&gt; running with argument 1
Worker &lt;Thread(worker 3, started 130283816012048)&gt; running with argument 2
Worker &lt;Thread(worker 4, started 130283807619344)&gt; running with argument 3
Worker &lt;Thread(worker 5, started 130283799226640)&gt; running with argument 4
Worker &lt;Thread(worker 1, started 130283832797456)&gt; running with argument 5
...
</pre></div>
</div>
<p>より詳しいことはモジュールのドキュメントを調べてください; <a class="reference internal" href="../library/queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> クラスは多機能なインターフェースを提供しています。</p>
</div>
<div class="section" id="what-kinds-of-global-value-mutation-are-thread-safe">
<h3><a class="toc-backref" href="#id18">グローバルな値のどんな種類の変更がスレッドセーフになるのですか？</a><a class="headerlink" href="#what-kinds-of-global-value-mutation-are-thread-safe" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">global interpreter lock</span></a> (GIL) が内部で使われ、Python VM で一度に一つだけのスレッドが実行されることが保証されています。一般に、Python ではスレッド間の切り替えをバイトコード命令の間でのみ行います。切り替えの周期は、 <a class="reference internal" href="../library/sys.html#sys.setswitchinterval" title="sys.setswitchinterval"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setswitchinterval()</span></code></a> で設定できます。したがって、それぞれのバイトコード命令、そしてそれぞれの命令が届く全ての C 実装コードは、 Python プログラムの観点からは、アトミックです。</p>
<p>このことから、理論上は、正確な勘定のためには PVM バイトコードの実装を理解することが必要です。実際上は、組み込みデータ型(整数、リスト、辞書、等)の、変数を共有する &quot;アトミックそうな&quot; 演算は、実際にアトミックです。</p>
<p>例えば、以下の演算は全てアトミックです (L、L1、L2 はリスト、 D、D1、D2 は辞書、x、y はオブジェクト、i、j は整数です):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">L1</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">L2</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">L1</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">L2</span>
<span class="n">L</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">y</span>
<span class="n">x</span><span class="o">.</span><span class="n">field</span> <span class="o">=</span> <span class="n">y</span>
<span class="n">D</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
<span class="n">D1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">D2</span><span class="p">)</span>
<span class="n">D</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</pre></div>
</div>
<p>これらは、アトミックではありません:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
<span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
<span class="n">D</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>他のオブジェクトを置き換えるような演算は、そのオブジェクトの参照カウントがゼロになったときに <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> メソッドを呼び出すことがあり、これが影響を及ぼすかもしれません。これは特に、辞書やリストの大規模な更新に当てはまります。疑わしければ、mutex を使ってください！</p>
</div>
<div class="section" id="can-t-we-get-rid-of-the-global-interpreter-lock">
<h3><a class="toc-backref" href="#id19">グローバルインタプリタロック (Global Interpreter Lock) を取り除くことはできないのですか？</a><a class="headerlink" href="#can-t-we-get-rid-of-the-global-interpreter-lock" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>マルチスレッド Python プログラムは事実上一つの CPU しか使えず、 (ほとんど) 全ての Python コードが <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">グローバルインタプリタロック</span></a>  (GIL)  が保持されている間しか作動しなくなるということで、GIL は、 Python をハイエンドなマルチプロセッササーバマシン上に配備する上で邪魔であると見なされがちです。</p>
<p>Python 1.5 の時代、Greg Stein は実際に、GIL を取り除いてよりきめ細かいロッキングで置き換える包括的なパッチセット (&quot;free threading&quot; パッチ) を実装しました。Adam Olsen は最近、 <a class="reference external" href="https://code.google.com/archive/p/python-safethread">python-safethread</a>  プロジェクトで似たような実験を行いました。残念ながらどちらの実験も、GIL の除去を補償するために必要なきめ細かいロッキングの量のため、シングルスレッドのパフォーマンスの極端な低下 (少なくとも 30% の遅れ) を示しました。</p>
<p>これは、マルチ CPU マシン上で Python を使いこなせないことを意味しません！タスクを複数の <em>スレッド</em> ではなく複数の <em>プロセス</em> に分けることを考えればいいのです。これは、新しい <a class="reference internal" href="../library/concurrent.futures.html#module-concurrent.futures" title="concurrent.futures: Execute computations concurrently using threads or processes."><code class="xref py py-mod docutils literal notranslate"><span class="pre">concurrent.futures</span></code></a> モジュールの <a class="reference internal" href="../library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" title="concurrent.futures.ProcessPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProcessPoolExecutor</span></code></a> クラスを使えば簡単です。<a class="reference internal" href="../library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> モジュールは、タスクのディスパッチをより深く制御したいときのためのより低水準な API を提供します。</p>
<p>C 拡張をうまく使うことも役立ちます。C 拡張を時間のかかるタスクの実行に使えば、その拡張は実行が C コードで行われている間 GIL を解放でき、その間に他のスレッドで作業が進められます。 <a class="reference internal" href="../library/zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> や <a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a> など、すでにこれを行なっている標準ライブラリモジュールもあります。</p>
<p>GIL を本当にグローバルにするより、インタプリタ状態ごとのロックにするべきという提案もあります。そして、インタプリタはオブジェクトを共有するべきではないということです。残念ながら、どちらも実現しないでしょう。多くのオブジェクトの実装は現在、グローバル状態を持っているので、実現はたいへんな大仕事になりそうです。例えば、小さな整数と短い文字列はキャッシュされます。このキャッシュはインタプリタ状態に動かされなくてはなりません。他のオブジェクト型は自身の自由変数リストを持っています。これらの自由変数リストはインタプリタ状態に動かされなくてはなりません。等々。</p>
<p>それどころか、その作業が終わる時が来るかもわかりません。なぜなら、サードパーティ拡張にも問題があるからです。サードパーティ拡張が書かれるペースは、インタプリタ状態にすべてのグローバル状態を格納するように変換できるペースよりも速いことでしょう。</p>
<p>そして最後に、一旦複数のインタプリタを状態を全く共有しないようにしたとして、それぞれのインタプリタを独立したプロセス上で動かしてなにが得られるというのでしょうか？</p>
</div>
</div>
<div class="section" id="input-and-output">
<h2><a class="toc-backref" href="#id20">入力と出力</a><a class="headerlink" href="#input-and-output" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="how-do-i-delete-a-file-and-other-file-questions">
<h3><a class="toc-backref" href="#id21">ファイルを削除するにはどうしますか？ (その他、ファイルに関する質問...)</a><a class="headerlink" href="#how-do-i-delete-a-file-and-other-file-questions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">os.remove(filename)</span></code> または <code class="docutils literal notranslate"><span class="pre">os.unlink(filename)</span></code> を使ってください。ドキュメントは、 <a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a> モジュールを参照してください。この二つの関数は同じものです。 <a class="reference internal" href="../library/os.html#os.unlink" title="os.unlink"><code class="xref py py-func docutils literal notranslate"><span class="pre">unlink()</span></code></a> は単に、この関数の Unix システムコールの名称です。</p>
<p>ディレクトリを削除するには、<a class="reference internal" href="../library/os.html#os.rmdir" title="os.rmdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.rmdir()</span></code></a> を使ってください。作成には <a class="reference internal" href="../library/os.html#os.mkdir" title="os.mkdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.mkdir()</span></code></a> を使ってください。<code class="docutils literal notranslate"><span class="pre">os.makedirs(path)</span></code> は <code class="docutils literal notranslate"><span class="pre">path</span></code> の中間のディレクトリの、存在しないものを作成します。<code class="docutils literal notranslate"><span class="pre">os.removedirs(path)</span></code> は中間のディレクトリが空である限り、それらを削除します。ディレクトリツリー全体とその中身全てを削除したいなら、<a class="reference internal" href="../library/shutil.html#shutil.rmtree" title="shutil.rmtree"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.rmtree()</span></code></a> を使ってください。</p>
<p>ファイルの名前を変更するには、<code class="docutils literal notranslate"><span class="pre">os.rename(old_path,</span> <span class="pre">new_path)</span></code> を使ってください。</p>
<p>ファイルを切り詰めるには、 <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">open(filename,</span> <span class="pre">&quot;rb+&quot;)</span></code> を使ってファイルを開き、 <code class="docutils literal notranslate"><span class="pre">f.truncate(offset)</span></code> を使ってください; offset はデフォルトでは現在のシーク位置です。 <a class="reference internal" href="../library/os.html#os.open" title="os.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.open()</span></code></a> で開かれたファイル用の <code class="docutils literal notranslate"><span class="pre">os.ftruncate(fd,</span> <span class="pre">offset)</span></code> もあります。 <em>fd</em> はファイルディスクリプタ (小さい整数値) です。</p>
<p><a class="reference internal" href="../library/shutil.html#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code></a> モジュールにも、<a class="reference internal" href="../library/shutil.html#shutil.copyfile" title="shutil.copyfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">copyfile()</span></code></a>、 <a class="reference internal" href="../library/shutil.html#shutil.copytree" title="shutil.copytree"><code class="xref py py-func docutils literal notranslate"><span class="pre">copytree()</span></code></a>、<a class="reference internal" href="../library/shutil.html#shutil.rmtree" title="shutil.rmtree"><code class="xref py py-func docutils literal notranslate"><span class="pre">rmtree()</span></code></a> 等、ファイルに作用する関数がいくつか含まれます。</p>
</div>
<div class="section" id="how-do-i-copy-a-file">
<h3><a class="toc-backref" href="#id22">ファイルをコピーするにはどうしますか？</a><a class="headerlink" href="#how-do-i-copy-a-file" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/shutil.html#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code></a> モジュールには <a class="reference internal" href="../library/shutil.html#shutil.copyfile" title="shutil.copyfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">copyfile()</span></code></a> 関数があります。なお、MacOS 9 ではリソースフォークやファインダー情報をコピーしません。</p>
</div>
<div class="section" id="how-do-i-read-or-write-binary-data">
<h3><a class="toc-backref" href="#id23">バイナリデータを読み書きするにはどうしますか？</a><a class="headerlink" href="#how-do-i-read-or-write-binary-data" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>複雑なバイナリデータ形式の読み書きには、<a class="reference internal" href="../library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> モジュールを使うのが一番です。これでバイナリデータ (通常は数) を含む文字列を取って、 Python オブジェクトに変換することができますし、その逆もできます。</p>
<p>例えば、以下のコードはファイルから 2 バイトの整数 2 個と 4 バイトの整数 1 個をビッグエンディアンフォーマットで読み込みます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">struct</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;&gt;hhl&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>フォーマット中の '&gt;' はデータを強制的にビッグエンディアンにします。ファイルから、文字 'h' は一つの&quot;整数&quot;(2 バイト)を読み込み、文字 'l' は一つの&quot;long 整数&quot;を読み込みます。</p>
<p>より規則的なデータ (例えば、整数や浮動小数点数の中身の型が揃ったリスト) に対しては、 <a class="reference internal" href="../library/array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a> モジュールを使うこともできます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">バイナリデータを読み書きするには、 (ここにあるように <code class="docutils literal notranslate"><span class="pre">&quot;rb&quot;</span></code> を <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> に渡して) ファイルをバイナリモードで開く義務があります。代わりに (デフォルトの) <code class="docutils literal notranslate"><span class="pre">&quot;r&quot;</span></code> を使った場合は、ファイルはテキストモードで開かれ、 <code class="docutils literal notranslate"><span class="pre">f.read()</span></code> は <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> オブジェクトではなく <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> オブジェクトを返します。</p>
</div>
</div>
<div class="section" id="i-can-t-seem-to-use-os-read-on-a-pipe-created-with-os-popen-why">
<h3><a class="toc-backref" href="#id24">os.popen() によって作られたパイプで os.read() が使われていないようです。なぜですか？</a><a class="headerlink" href="#i-can-t-seem-to-use-os-read-on-a-pipe-created-with-os-popen-why" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/os.html#os.read" title="os.read"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.read()</span></code></a> は、開かれたファイルを表す小さな整数、ファイルディスクリプタを引数に取る、低レベルの関数です。 <a class="reference internal" href="../library/os.html#os.popen" title="os.popen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.popen()</span></code></a> は、組み込みの <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 関数の返り値と同じ型の、高レベルなファイルオブジェクトを作成します。従って、 <a class="reference internal" href="../library/os.html#os.popen" title="os.popen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.popen()</span></code></a> によって作成されたパイプ <em>p</em> から <em>n</em> バイト分だけ読み取るには、 <code class="docutils literal notranslate"><span class="pre">p.read(n)</span></code> を使う必要があります。</p>
</div>
<div class="section" id="how-do-i-access-the-serial-rs232-port">
<h3><a class="toc-backref" href="#id25">シリアル (RS232) ポートにアクセスするにはどうしますか？</a><a class="headerlink" href="#how-do-i-access-the-serial-rs232-port" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Win32、POSIX (Linux、BSD、など)、Jythonでは:</p>
<blockquote>
<div><a class="reference external" href="http://pyserial.sourceforge.net">http://pyserial.sourceforge.net</a></div></blockquote>
<p>Unix では、Mitch Chapman による Usenet の投稿を参照してください:</p>
<blockquote>
<div><a class="reference external" href="https://groups.google.com/groups?selm=34A04430.CF9&#64;ohioee.com">https://groups.google.com/groups?selm=34A04430.CF9&#64;ohioee.com</a></div></blockquote>
</div>
<div class="section" id="why-doesn-t-closing-sys-stdout-stdin-stderr-really-close-it">
<h3><a class="toc-backref" href="#id26">sys.stdout (stdin, stderr) を閉じようとしても実際に閉じられないのはなぜですか？</a><a class="headerlink" href="#why-doesn-t-closing-sys-stdout-stdin-stderr-really-close-it" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python の <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a> は、低水準の C ファイルディスクリプタ上の、抽象の高水準レイヤです。</p>
<p>組み込みの <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 関数によって生成されたほとんどのファイルオブジェクトでは、 <code class="docutils literal notranslate"><span class="pre">f.close()</span></code> は Python ファイルオブジェクトが Python の視点からは閉じられているものとする印をつけ、その下にある C ファイルディスクリプタを閉じるように手配します。これは、 <code class="docutils literal notranslate"><span class="pre">f</span></code> がガベージとなったときにも、 <code class="docutils literal notranslate"><span class="pre">f</span></code> のデストラクタで自動的に起こります。</p>
<p>しかし、stdin、stdout、stderr は C で特別な立場が与えられていることから、Python でも同様に特別に扱われます。<code class="docutils literal notranslate"><span class="pre">sys.stdout.close()</span></code> を実行すると、Python レベルのファイルオブジェクトには閉じられているものとする印がつけられますが、C ファイルディスクリプタは <em>閉じられません</em>。</p>
<p>下にある C ファイルディスクリプタのうち、この三つのどれかを閉じるには、まず本当に閉じる必要があることを確かめるべきです (例えば、拡張モジュールの I/O を混乱させてしまうかもしれません)。本当に必要ならば、 <a class="reference internal" href="../library/os.html#os.close" title="os.close"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.close()</span></code></a> を使ってください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">stdin</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
<span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">stdout</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
<span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">stderr</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
</pre></div>
</div>
<p>または、数の定数としてそれぞれ 0, 1, 2 も使えます。</p>
</div>
</div>
<div class="section" id="network-internet-programming">
<h2><a class="toc-backref" href="#id27">ネットワーク/インターネットプログラミング</a><a class="headerlink" href="#network-internet-programming" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="what-www-tools-are-there-for-python">
<h3><a class="toc-backref" href="#id28">Python の WWW ツールには何がありますか？</a><a class="headerlink" href="#what-www-tools-are-there-for-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ライブラリリファレンスマニュアルの <a class="reference internal" href="../library/internet.html#internet"><span class="std std-ref">インターネットプロトコルとサポート</span></a> と <a class="reference internal" href="../library/netdata.html#netdata"><span class="std std-ref">インターネット上のデータの操作</span></a> という章を参照してください。Python には、サーバサイドとクライアントサイドの web システムを構築するのに便利な多くのモジュールがあります。</p>
<p>利用可能なフレームワークの概要は Paul Boddie によって、 <a class="reference external" href="https://wiki.python.org/moin/WebProgramming">https://wiki.python.org/moin/WebProgramming</a> でメンテナンスされています。</p>
<p>Cameron Laird は、<a class="reference external" href="http://phaseit.net/claird/comp.lang.python/web_python">http://phaseit.net/claird/comp.lang.python/web_python</a> で Python のウェブ技術に関する便利なページ群を整備しています。</p>
</div>
<div class="section" id="how-can-i-mimic-cgi-form-submission-method-post">
<h3><a class="toc-backref" href="#id29">CGI フォームの発信 (METHOD=POST) を模倣するにはどうしますか？</a><a class="headerlink" href="#how-can-i-mimic-cgi-form-submission-method-post" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>フォームを POST した結果のウェブページを取得したいです。簡単に取得するためのコードはあるでしょうか？</p>
<p>あります。これは urllib.request を利用した簡単な例です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/local/bin/python</span>

<span class="kn">import</span> <span class="nn">urllib.request</span>

<span class="c1"># build the query string</span>
<span class="n">qs</span> <span class="o">=</span> <span class="s2">&quot;First=Josephine&amp;MI=Q&amp;Last=Public&quot;</span>

<span class="c1"># connect and send the server a path</span>
<span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.some-server.out-there&#39;</span>
                             <span class="s1">&#39;/cgi-bin/some-cgi-script&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">qs</span><span class="p">)</span>
<span class="k">with</span> <span class="n">req</span><span class="p">:</span>
    <span class="n">msg</span><span class="p">,</span> <span class="n">hdrs</span> <span class="o">=</span> <span class="n">req</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> <span class="n">req</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
</pre></div>
</div>
<p>一般的には、パーセント記号でエンコードされた POST 操作では、クエリ文字列は <a class="reference internal" href="../library/urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> を使って処理されなければならないことに注意してください。例えば、 <code class="docutils literal notranslate"><span class="pre">name=Guy</span> <span class="pre">Steele,</span> <span class="pre">Jr.</span></code> を送信するには:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.parse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urlencode</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;Guy Steele, Jr.&#39;</span><span class="p">})</span>
<span class="go">&#39;name=Guy+Steele%2C+Jr.&#39;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="../howto/urllib2.html#urllib-howto"><span class="std std-ref">urllib パッケージを使ってインターネット上のリソースを取得するには</span></a> に多くの例があります。</p>
</div>
</div>
<div class="section" id="what-module-should-i-use-to-help-with-generating-html">
<h3><a class="toc-backref" href="#id30">どのモジュールが HTML の生成の役に立ちますか？</a><a class="headerlink" href="#what-module-should-i-use-to-help-with-generating-html" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference external" href="https://wiki.python.org/moin/WebProgramming">Web Programming についての wiki のページ</a> から役に立つリンクが見付けられます。</p>
</div>
<div class="section" id="how-do-i-send-mail-from-a-python-script">
<h3><a class="toc-backref" href="#id31">Python のスクリプトからメールを送るにはどうしますか？</a><a class="headerlink" href="#how-do-i-send-mail-from-a-python-script" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>標準ライブラリモジュール <a class="reference internal" href="../library/smtplib.html#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code></a> を使ってください。</p>
<p>以下に示すのが、これを使ったごく単純な対話型のメール送信器です。このメソッドは SMTP リスナをサポートするホストならどこででも作動します。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">smtplib</span>

<span class="n">fromaddr</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;From: &quot;</span><span class="p">)</span>
<span class="n">toaddrs</span>  <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;To: &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Enter message, end with ^D:&quot;</span><span class="p">)</span>
<span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="n">msg</span> <span class="o">+=</span> <span class="n">line</span>

<span class="c1"># The actual mail send</span>
<span class="n">server</span> <span class="o">=</span> <span class="n">smtplib</span><span class="o">.</span><span class="n">SMTP</span><span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">sendmail</span><span class="p">(</span><span class="n">fromaddr</span><span class="p">,</span> <span class="n">toaddrs</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
</pre></div>
</div>
<p>Unix 限定の代わりの選択肢は sendmail を使うことです。sendmail プログラムの場所はシステムによって様々です; あるときは <code class="docutils literal notranslate"><span class="pre">/usr/lib/sendmail</span></code> だったり、あるときは <code class="docutils literal notranslate"><span class="pre">/usr/sbin/sendmail</span></code> だったり。sendmail のマニュアルページが助けになるでしょう。サンプルコードはこのようになります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>

<span class="n">SENDMAIL</span> <span class="o">=</span> <span class="s2">&quot;/usr/sbin/sendmail&quot;</span>  <span class="c1"># sendmail location</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">popen</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> -t -i&quot;</span> <span class="o">%</span> <span class="n">SENDMAIL</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;To: receiver@example.com</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Subject: test</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># blank line separating headers from body</span>
<span class="n">p</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Some text</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;some more text</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">sts</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="k">if</span> <span class="n">sts</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sendmail exit status&quot;</span><span class="p">,</span> <span class="n">sts</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="how-do-i-avoid-blocking-in-the-connect-method-of-a-socket">
<h3><a class="toc-backref" href="#id32">ソケットの connect() メソッドでブロッキングされなくするにはどうしますか？</a><a class="headerlink" href="#how-do-i-avoid-blocking-in-the-connect-method-of-a-socket" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>主に <a class="reference internal" href="../library/select.html#module-select" title="select: Wait for I/O completion on multiple streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">select</span></code></a> モジュールがソケットの非同期の I/O を扱うのに使われます。</p>
<p>TCP 接続がブロッキングされないようにするために、ソケットをノンブロッキングモードに設定することが出来ます。そして <code class="docutils literal notranslate"><span class="pre">connect()</span></code> したときに、即座に接続できるか、エラー番号を <code class="docutils literal notranslate"><span class="pre">.errno</span></code> として含む例外を受け取るかのどちらかになります。<code class="docutils literal notranslate"><span class="pre">errno.EINPROGRESS</span></code> は、接続が進行中であるが、まだ完了していないということを示します。異なる OS では異なる値が返されるので、あなたのシステムで何が返されるかを確かめておく必要があります。</p>
<p><code class="docutils literal notranslate"><span class="pre">connect_ex()</span></code> メソッドを使えば例外を生成しなくて済みます。これは単に errno の値を返すでしょう。ポーリングのためには、後でまた <code class="docutils literal notranslate"><span class="pre">connect_ex()</span></code> を呼び出すことができます -- <code class="docutils literal notranslate"><span class="pre">0</span></code> または <code class="docutils literal notranslate"><span class="pre">errno.EISCONN</span></code> は接続されたことを表します -- または、選択するソケットにこれを渡して書き込み可能か調べることができます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="../library/asyncore.html#module-asyncore" title="asyncore: A base class for developing asynchronous socket handling services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncore</span></code></a> モジュールは、ノンブロッキングのネットワークコードを書く作業のためにフレームワークのような方法を提供します。サードパーティの <a class="reference external" href="https://twistedmatrix.com/trac/">Twisted</a> ライブラリは一般的で多機能な選択肢です。</p>
</div>
</div>
</div>
<div class="section" id="databases">
<h2><a class="toc-backref" href="#id33">データベース</a><a class="headerlink" href="#databases" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="are-there-any-interfaces-to-database-packages-in-python">
<h3><a class="toc-backref" href="#id34">Python にはデータベースパッケージへのインタフェースはありますか？</a><a class="headerlink" href="#are-there-any-interfaces-to-database-packages-in-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>はい。</p>
<p>標準の Python には、 <a class="reference internal" href="../library/dbm.html#module-dbm.ndbm" title="dbm.ndbm: The standard &quot;database&quot; interface, based on ndbm. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">DBM</span></code></a> や <a class="reference internal" href="../library/dbm.html#module-dbm.gnu" title="dbm.gnu: GNU's reinterpretation of dbm. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">GDBM</span></code></a> などの、ディスクベースのハッシュへのインタフェースも含まれています。また、 <a class="reference internal" href="../library/sqlite3.html#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> モジュールは、軽量なディスクベースの関係データベースを提供します。</p>
<p>ほとんどの関係データベースがサポートされています。詳細は <a class="reference external" href="https://wiki.python.org/moin/DatabaseProgramming">DatabaseProgramming wiki page</a> を参照してください。</p>
</div>
<div class="section" id="how-do-you-implement-persistent-objects-in-python">
<h3><a class="toc-backref" href="#id35">Python で永続的なオブジェクトを実装するにはどうしますか？</a><a class="headerlink" href="#how-do-you-implement-persistent-objects-in-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> ライブラリモジュールで、ごく一般的な方法でこれを解決できます (開かれたファイル、ソケット、ウィンドウのようなものを保管することはできませんが)。 <a class="reference internal" href="../library/shelve.html#module-shelve" title="shelve: Python object persistence."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shelve</span></code></a> ライブラリモジュールは pickle と (g)dbm を使い、任意の Python オブジェクトを含む永続的なマッピングを生成します。</p>
</div>
</div>
<div class="section" id="mathematics-and-numerics">
<h2><a class="toc-backref" href="#id36">数学と数</a><a class="headerlink" href="#mathematics-and-numerics" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="how-do-i-generate-random-numbers-in-python">
<h3><a class="toc-backref" href="#id37">Python で乱数を生成するにはどうしますか？</a><a class="headerlink" href="#how-do-i-generate-random-numbers-in-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>標準モジュールの <a class="reference internal" href="../library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a> が乱数生成器を実装しています。使い方は単純です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
<span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
</pre></div>
</div>
<p>これは区間 [0, 1) 内のランダムな浮動小数点数を返します。</p>
<p>このモジュールにはその他多くの特化した生成器もあります。例えば:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">randrange(a,</span> <span class="pre">b)</span></code> は区間 [a, b) から整数を選びます。</li>
<li><code class="docutils literal notranslate"><span class="pre">uniform(a,</span> <span class="pre">b)</span></code> は区間 [a, b) から浮動小数点数を選びます。</li>
<li><code class="docutils literal notranslate"><span class="pre">normalvariate(mean,</span> <span class="pre">sdev)</span></code> は正規 (ガウス) 分布をサンプリングします。</li>
</ul>
<p>シーケンスに直接作用する高水準な関数もあります。例えば:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">choice(S)</span></code> は与えられたシーケンスからランダムな要素を選びます。</li>
<li><code class="docutils literal notranslate"><span class="pre">shuffle(L)</span></code> はリストをインプレースにシャッフルします。すなわち、ランダムに並び替えます。</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">Random</span></code> クラスのインスタンスを生成して、複数の独立な乱数生成器をつくることもできます。</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">ライブラリと拡張 FAQ</a><ul>
<li><a class="reference internal" href="#general-library-questions">ライブラリ一般の質問</a></li>
<li><a class="reference internal" href="#common-tasks">よくある作業</a></li>
<li><a class="reference internal" href="#threads">スレッド</a></li>
<li><a class="reference internal" href="#input-and-output">入力と出力</a></li>
<li><a class="reference internal" href="#network-internet-programming">ネットワーク/インターネットプログラミング</a></li>
<li><a class="reference internal" href="#databases">データベース</a></li>
<li><a class="reference internal" href="#mathematics-and-numerics">数学と数</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="design.html"
                        title="前の章へ">デザインと歴史 FAQ</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="extending.html"
                        title="次の章へ">拡張と埋め込み FAQ</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.8/Doc/faq/library.rst"
            rel="nofollow">ソースコードを表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="extending.html" title="拡張と埋め込み FAQ"
             >次へ</a> |</li>
        <li class="right" >
          <a href="design.html" title="デザインと歴史 FAQ"
             >前へ</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.3 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python よくある質問</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" type="text" name="q" />
          <input type="submit" value="検索" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">著作権</a> 2001-2020, Python Software Foundation.
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最終更新: 5月 15, 2020
    <a href="https://docs.python.org/3/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>

  </body>
</html>