
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>デザインと歴史 FAQ &#8212; Python 3.8.3 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.8.3 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="next" title="ライブラリと拡張 FAQ" href="library.html" />
    <link rel="prev" title="プログラミング FAQ" href="programming.html" />
    <link rel="canonical" href="https://docs.python.org/3/faq/design.html" />
    
      
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="library.html" title="ライブラリと拡張 FAQ"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="programming.html" title="プログラミング FAQ"
             accesskey="P">前へ</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.3 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python よくある質問</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" type="text" name="q" />
          <input type="submit" value="検索" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="design-and-history-faq">
<h1><a class="toc-backref" href="#id3">デザインと歴史 FAQ</a><a class="headerlink" href="#design-and-history-faq" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="contents topic" id="id1">
<p class="topic-title">目次</p>
<ul class="simple">
<li><a class="reference internal" href="#design-and-history-faq" id="id3">デザインと歴史 FAQ</a><ul>
<li><a class="reference internal" href="#why-does-python-use-indentation-for-grouping-of-statements" id="id4">Python はなぜ文のグループ化にインデントを使うのですか？</a></li>
<li><a class="reference internal" href="#why-am-i-getting-strange-results-with-simple-arithmetic-operations" id="id5">なぜ単純な算術演算が奇妙な結果になるのですか？</a></li>
<li><a class="reference internal" href="#why-are-floating-point-calculations-so-inaccurate" id="id6">なんで浮動小数点数の計算はこんなに不正確なんですか？</a></li>
<li><a class="reference internal" href="#why-are-python-strings-immutable" id="id7">なぜ Python の文字列はイミュータブルなのですか？</a></li>
<li><a class="reference internal" href="#why-must-self-be-used-explicitly-in-method-definitions-and-calls" id="id8">なぜメソッドの定義や呼び出しにおいて 'self' を明示しなければならないのですか？</a></li>
<li><a class="reference internal" href="#why-can-t-i-use-an-assignment-in-an-expression" id="id9">式中で代入ができないのはなぜですか？</a></li>
<li><a class="reference internal" href="#why-does-python-use-methods-for-some-functionality-e-g-list-index-but-functions-for-other-e-g-len-list" id="id10">Python にメソッドを使う機能 (list.index() 等) と関数を使う機能 (len(list) 等) があるのはなぜですか？</a></li>
<li><a class="reference internal" href="#why-is-join-a-string-method-instead-of-a-list-or-tuple-method" id="id11">join() がリストやタプルのメソッドではなく文字列のメソッドなのはなぜですか？</a></li>
<li><a class="reference internal" href="#how-fast-are-exceptions" id="id12">例外はどれくらい速いのですか？</a></li>
<li><a class="reference internal" href="#why-isn-t-there-a-switch-or-case-statement-in-python" id="id13">Python に switch や case 文がないのはなぜですか？</a></li>
<li><a class="reference internal" href="#can-t-you-emulate-threads-in-the-interpreter-instead-of-relying-on-an-os-specific-thread-implementation" id="id14">OS 特有のスレッド実装に依らずにインタプリタでスレッドをエミュレートすることはできないのですか？</a></li>
<li><a class="reference internal" href="#why-can-t-lambda-expressions-contain-statements" id="id15">なぜラムダ式は文を含むことができないのですか?</a></li>
<li><a class="reference internal" href="#can-python-be-compiled-to-machine-code-c-or-some-other-language" id="id16">Python は C やその他の言語のように機械語にコンパイルできますか？</a></li>
<li><a class="reference internal" href="#how-does-python-manage-memory" id="id17">Python はメモリをどのように管理するのですか？</a></li>
<li><a class="reference internal" href="#why-doesn-t-cpython-use-a-more-traditional-garbage-collection-scheme" id="id18">CPython はなぜ伝統的なガベージコレクションスキームを使わないのですか？</a></li>
<li><a class="reference internal" href="#why-isn-t-all-memory-freed-when-cpython-exits" id="id19">なぜ CPython の終了時にすべてのメモリが解放されるわけではないのですか？</a></li>
<li><a class="reference internal" href="#why-are-there-separate-tuple-and-list-data-types" id="id20">なぜタプルとリストという別のデータ型が用意されているのですか？</a></li>
<li><a class="reference internal" href="#how-are-lists-implemented-in-cpython" id="id21">CPythonでリストはどのように実装されているのですか？</a></li>
<li><a class="reference internal" href="#how-are-dictionaries-implemented-in-cpython" id="id22">CPythonで辞書はどのように実装されていますか？</a></li>
<li><a class="reference internal" href="#why-must-dictionary-keys-be-immutable" id="id23">なぜ辞書のキーはイミュータブルでなくてはならないのですか？</a></li>
<li><a class="reference internal" href="#why-doesn-t-list-sort-return-the-sorted-list" id="id24">なぜ list.sort() はソートされたリストを返さないのですか？</a></li>
<li><a class="reference internal" href="#how-do-you-specify-and-enforce-an-interface-spec-in-python" id="id25">Python ではどのようにインタフェース仕様を特定し適用するのですか？</a></li>
<li><a class="reference internal" href="#why-is-there-no-goto" id="id26">なぜ goto が無いのですか？</a></li>
<li><a class="reference internal" href="#why-can-t-raw-strings-r-strings-end-with-a-backslash" id="id27">なぜ raw 文字列 (r-strings) はバックスラッシュで終わってはいけないのですか？</a></li>
<li><a class="reference internal" href="#why-doesn-t-python-have-a-with-statement-for-attribute-assignments" id="id28">属性の代入に &quot;with&quot; 文が使えないのはなぜですか？</a></li>
<li><a class="reference internal" href="#why-are-colons-required-for-the-if-while-def-class-statements" id="id29">if/while/def/class 文にコロンが必要なのはなぜですか？</a></li>
<li><a class="reference internal" href="#why-does-python-allow-commas-at-the-end-of-lists-and-tuples" id="id30">なぜ Python ではリストやタプルの最後にカンマがあっても良いのですか？</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="why-does-python-use-indentation-for-grouping-of-statements">
<h2><a class="toc-backref" href="#id4">Python はなぜ文のグループ化にインデントを使うのですか？</a><a class="headerlink" href="#why-does-python-use-indentation-for-grouping-of-statements" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Guido van Rossum の信じるところによれば、インデントによるグループ化は非常にエレガントで、普通の Python プログラムを大いに読みやすくします。しばらくすればほとんどの人はこの仕様を気に入るようになります。</p>
<p>開始/終了の括弧がないので、構文解析器と人間の読者の間にグループ化の解釈の違いは起こりえません。時折、C のプログラマはこのようなコード片に出くわします:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">x</span><span class="o">++</span><span class="p">;</span>
        <span class="n">y</span><span class="o">--</span><span class="p">;</span>
<span class="n">z</span><span class="o">++</span><span class="p">;</span>
</pre></div>
</div>
<p>この条件文が真の時のみ実行されるのは <code class="docutils literal notranslate"><span class="pre">x++</span></code> 文だけですが、このインデントでは誤解を招きます。経験を積んだ C プログラマでさえ、 <code class="docutils literal notranslate"><span class="pre">y</span></code> が <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></code> の時にもデクリメントされるのはなぜか分からず長いこと立ち止まることがあるでしょう。</p>
<p>開始/終了の括弧がないので、Python はコーディングスタイルの対立が非常に起こりにくくなります。C では多様なカッコの置き方があります。一つのスタイルでのコードの読み書きに慣れてしまうと、他のスタイルを読む (あるいは書く必要がある) ときにむずむずするでしょう。</p>
<p>多くのコーディングスタイルは begin/end の括弧にそれぞれ一行を使います。これではプログラムは冗長になって画面を浪費し、プログラムの見通しが悪くなります。一つの関数は一画面 (例えば 20 から 30 行) に収めるのが理想です。20 行の Python は 20 行の C よりもはるかに多くの作業ができます。これは begin/end の括弧がないからだけではありません -- 宣言が不要なことや高レベルなデータ型もその理由です -- が、インデントに基づく構文は確かに役に立っています。</p>
</div>
<div class="section" id="why-am-i-getting-strange-results-with-simple-arithmetic-operations">
<h2><a class="toc-backref" href="#id5">なぜ単純な算術演算が奇妙な結果になるのですか？</a><a class="headerlink" href="#why-am-i-getting-strange-results-with-simple-arithmetic-operations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>次の質問を参照してください。</p>
</div>
<div class="section" id="why-are-floating-point-calculations-so-inaccurate">
<h2><a class="toc-backref" href="#id6">なんで浮動小数点数の計算はこんなに不正確なんですか？</a><a class="headerlink" href="#why-are-floating-point-calculations-so-inaccurate" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ユーザーはよく次のような結果に驚きます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">1.2</span> <span class="o">-</span> <span class="mf">1.0</span>
<span class="go">0.19999999999999996</span>
</pre></div>
</div>
<p>そしてこれが Python のバグだと考えます。が、これはバグではありません。この結果に Python はほとんど関与しておらず、むしろ基底のプラットフォームによる浮動小数点数の扱い方が関与しています。</p>
<p>CPython における <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 型は記憶に C 言語の <code class="docutils literal notranslate"><span class="pre">double</span></code> 型を使います。 <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> オブジェクトの値は固定精度 (典型的には 53 bit) の 2 進浮動小数点数として格納され、 Python はプロセッサのハードウェアが実装している C 言語上の演算を使います。つまり、浮動小数点数に関して Python は C 言語や Java のような多くの一般的な言語と同じように振る舞います。</p>
<p>10 進数で簡単に書ける多くの数が、2 進浮動小数点数では正確に表すことができません。例えばこうすると:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mf">1.2</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">x</span></code> に保存された値は 10 進数の <code class="docutils literal notranslate"><span class="pre">1.2</span></code> の (とても高い精度の) 近似値であって、厳密な <code class="docutils literal notranslate"><span class="pre">1.2</span></code> ではありません。一般的なコンピューターでは、実際に格納される値は:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="mf">1.0011001100110011001100110011001100110011001100110011</span> <span class="p">(</span><span class="n">binary</span><span class="p">)</span>
</pre></div>
</div>
<p>で、正確には次の値です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="mf">1.1999999999999999555910790149937383830547332763671875</span> <span class="p">(</span><span class="n">decimal</span><span class="p">)</span>
</pre></div>
</div>
<p>53bit の典型的な精度は、Python の float に 10 進数で 15〜16桁の精度を与えます。</p>
<p>詳しくは、Python チュートリアルの <a class="reference internal" href="../tutorial/floatingpoint.html#tut-fp-issues"><span class="std std-ref">floating point arithmetic</span></a> の章を参照してください。</p>
</div>
<div class="section" id="why-are-python-strings-immutable">
<h2><a class="toc-backref" href="#id7">なぜ Python の文字列はイミュータブルなのですか？</a><a class="headerlink" href="#why-are-python-strings-immutable" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>これにはいくつかの利点があります。</p>
<p>一つはパフォーマンスです。文字列がイミュータブルなら、生成時に領域を割り当てることができるので、必要な記憶域は固定されて、変更されません。これはタプルとリストを区別する理由の一つでもあります。</p>
<p>他の利点は、Python の文字列は数と同じくらい &quot;基本的&quot; なものと考えられることです。8 という値を他の何かに変える手段が無いように、文字列 &quot;eight&quot; を他の何かに変える手段も無いのです。</p>
</div>
<div class="section" id="why-must-self-be-used-explicitly-in-method-definitions-and-calls">
<span id="why-self"></span><h2><a class="toc-backref" href="#id8">なぜメソッドの定義や呼び出しにおいて 'self' を明示しなければならないのですか？</a><a class="headerlink" href="#why-must-self-be-used-explicitly-in-method-definitions-and-calls" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このアイデアは Modula-3 から取り入れられました。これは様々な理由からとても便利だと言えます。</p>
<p>まず、ローカル変数ではなく、メソッドやインスタンス属性を扱っていることがより明確になります。 <code class="docutils literal notranslate"><span class="pre">self.x</span></code> や <code class="docutils literal notranslate"><span class="pre">self.meth()</span></code> と書いてあれば、そのクラスの定義を憶えていなくても、それがインスタンス変数やメソッドであることは明らかです。C++ では、(グローバルが滅多になかったり、簡単に見分けがつくなら) ローカル変数宣言がないことからある程度わかるでしょう。-- しかし Python にはローカル変数宣言がないので、クラス定義を調べて確かめなくてはなりません。C++ や Java のコーディングスタンダードに、インスタンス属性に <code class="docutils literal notranslate"><span class="pre">m_</span></code> 接頭辞をつけるものがあるので、この明示性はそれらの言語においても有用です。</p>
<p>第二に、特定のクラスからメソッドを明示的に参照または呼び出ししたい時に、特別な構文が必要なくなります。C++ では、派生クラスでオーバーライドされた基底クラスからメソッドを使うには、 <code class="docutils literal notranslate"><span class="pre">::</span></code> 演算子を使わなければなりません。 -- Python では、 <code class="docutils literal notranslate"><span class="pre">baseclass.methodname(self,</span> <span class="pre">&lt;argument</span> <span class="pre">list&gt;)</span></code> と書けます。これは特に、 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> メソッドに便利ですし、派生クラスのメソッドが、基底クラスにある同じ名前のメソッドを拡張するために、基底クラスのメソッドをどうにかして呼び出したい時にも便利です。</p>
<p>最後に、インスタンス変数に対する、代入の構文の問題を解決できます。Python のローカル変数は、関数の中で (global が明示的に宣言されることなく) 値が代入された変数 (と定義されています！) です。なので、ある代入が意図するのが、ローカル変数へではなくインスタンス変数への代入であると、インタプリタが判断する手段が必要です。そしてそれは構文を見るだけで分かる方が (効率が) 良いのです。C++ ではその区別を宣言時に行いますが、Python では宣言がないので、この方法でしか区別できなかったら残念です。 <code class="docutils literal notranslate"><span class="pre">self.var</span></code> を明示すればうまく解決できます。同様に、インスタンス変数を使うのにも <code class="docutils literal notranslate"><span class="pre">self.var</span></code> と書かなければならないので、メソッドの中の self が付いていない名前への参照は、そのインスタンスのディレクトリを検索するまでもなくローカル変数とわかります。別の言い方をすれば、ローカル変数とインスタンス変数は二つの異なる名前空間に存在し、Python にどちらの名前空間を使うかを伝えなくてはならないのです。</p>
</div>
<div class="section" id="why-can-t-i-use-an-assignment-in-an-expression">
<span id="id2"></span><h2><a class="toc-backref" href="#id9">式中で代入ができないのはなぜですか？</a><a class="headerlink" href="#why-can-t-i-use-an-assignment-in-an-expression" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 3.8 以降ならできるよ!</p>
<p>セイウチ演算子 <cite>:=</cite> を使った代入式は、式の中で変数に代入します:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">chunk</span> <span class="o">:=</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">200</span><span class="p">):</span>
   <span class="nb">print</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
</pre></div>
</div>
<p>より詳しくは <span class="target" id="index-4"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0572"><strong>PEP 572</strong></a> を参照してください。</p>
</div>
<div class="section" id="why-does-python-use-methods-for-some-functionality-e-g-list-index-but-functions-for-other-e-g-len-list">
<h2><a class="toc-backref" href="#id10">Python にメソッドを使う機能 (list.index() 等) と関数を使う機能 (len(list) 等) があるのはなぜですか？</a><a class="headerlink" href="#why-does-python-use-methods-for-some-functionality-e-g-list-index-but-functions-for-other-e-g-len-list" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Guidoいわく：</p>
<blockquote>
<div><p>(a) 幾つかの演算では、接頭辞は接尾辞よりも単純に読みやすいからです。接頭辞（そして接中辞！）による演算は数学において長い歴史があり、そこでは課題に対する数学者の思考を視覚的に助けるような記法が好まれます。x*(a+b)をx*a + x*bに書き換える容易さと、それと同じことを純粋なオブジェクト指向の記法で行う煩わしさを比較してみてください。</p>
<p>(b) len(x)というコードを読んだ時、私はそれが何かの長さを問うているのだなと知ることができます。これは私に2つの事を知らせています。一つは結果が整数であること、そして引数は何らかのコンテナであることです。対して、x.len()を目にした場合、私はその時点でxが何らかのコンテナであり、それが標準のlen()を持っているクラスを継承しているか、インターフェースを実装していることを知っている必要があります。mappingを実装していないクラスがget()やkeys()メソッドを持っていたり、fileでない何かがwrite()メソッドを持っているような混乱は時折見かけます。</p>
<p class="attribution">&mdash;<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2006-November/004643.html">https://mail.python.org/pipermail/python-3000/2006-November/004643.html</a></p>
</div></blockquote>
</div>
<div class="section" id="why-is-join-a-string-method-instead-of-a-list-or-tuple-method">
<h2><a class="toc-backref" href="#id11">join() がリストやタプルのメソッドではなく文字列のメソッドなのはなぜですか？</a><a class="headerlink" href="#why-is-join-a-string-method-instead-of-a-list-or-tuple-method" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>文字列は Python 1.6 から他の標準型に大きく近づきました。それ以前は常に string モジュールの関数を使ってできていたことと同等の機能を持つメソッドがこの時に追加されました。その新しいメソッドの多くは広く受け入れられましたが、一部のプログラマに不快を感じさせていると思われるものがこれで:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">,</span> <span class="s1">&#39;8&#39;</span><span class="p">,</span> <span class="s1">&#39;16&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>結果はこうなります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;1, 2, 4, 8, 16&quot;</span>
</pre></div>
</div>
<p>この使い方には二つの議論があります。</p>
<p>一つ目は、「文字列リテラル (文字列定数) のメソッドを使うのは醜すぎる」というようなものです。確かにそうかも知れませんが、文字列リテラルは単なる固定された値に過ぎないというのが答えです。文字列に束縛された名前にメソッドが許されるなら、リテラルに使えないようにする論理的な理由はないでしょう。</p>
<p>二つ目の反対理由は、典型的には「私は実際、要素を文字列定数とともに結合させるよう、シーケンスに命じているのだ」というものです。残念ながら、そうではないのです。いくつかの理由から <a class="reference internal" href="../library/stdtypes.html#str.split" title="str.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a> を文字列のメソッドとしておいた方がはるかに簡単です。これを見ると分かりやすいでしょう</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;1, 2, 4, 8, 16&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>これは文字列リテラルに対する、与えられたセパレータ (または、デフォルトでは任意の空白文字の連続) で区切られた部分文字列を返せという指示です。</p>
<p><a class="reference internal" href="../library/stdtypes.html#str.join" title="str.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code></a> は、セパレータ文字列に、文字列のシーケンスをイテレートして隣り合う要素の間に自身を挿入するように指示しているので、文字列のメソッドです。このメソッドは、独自に定義された新しいクラスを含め、シーケンスの規則を満たすいかなる引数にも使えます。バイト列やバイト配列にも同様のメソッドがあります。</p>
</div>
<div class="section" id="how-fast-are-exceptions">
<h2><a class="toc-backref" href="#id12">例外はどれくらい速いのですか？</a><a class="headerlink" href="#how-fast-are-exceptions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>try/except ブロックは例外が送出されなければ極端に効率的です。実際に例外を捕捉するのは高価です。Python 2.0 より前のバージョンでは、このイディオムを使うのが一般的でした:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
    <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">getvalue</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</pre></div>
</div>
<p>これは、辞書がほとんどの場合にキーを持っていると予想できるときにのみ意味をなします。そうでなければ、このように書きます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">mydict</span><span class="p">:</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">getvalue</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</pre></div>
</div>
<p>この特殊な場合では <code class="docutils literal notranslate"><span class="pre">value</span> <span class="pre">=</span> <span class="pre">dict.setdefault(key,</span> <span class="pre">getvalue(key))</span></code> も使えますが、これは <code class="docutils literal notranslate"><span class="pre">getvalue()</span></code> 呼び出しが十分安価な場合に限ります。なぜならそれが全ての場合に評価されるからです。</p>
</div>
<div class="section" id="why-isn-t-there-a-switch-or-case-statement-in-python">
<h2><a class="toc-backref" href="#id13">Python に switch や case 文がないのはなぜですか？</a><a class="headerlink" href="#why-isn-t-there-a-switch-or-case-statement-in-python" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">if...</span> <span class="pre">elif...</span> <span class="pre">elif...</span> <span class="pre">else</span></code> の繰り返しで簡単に同じことができます。switch 文の構文に関する提案がいくつかありましたが、範囲判定をするべきか、あるいはどのようにするべきかについての合意は (まだ) 得られていません。現在の状況の完全な詳細は <span class="target" id="index-5"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0275"><strong>PEP 275</strong></a> を参照してください。</p>
<p>非常に大きな数の選択肢から選ぶとき、値を呼び出す関数に対応づける辞書を作れます。例えば:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">function_1</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>

<span class="n">functions</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="n">function_1</span><span class="p">,</span>
             <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="n">function_2</span><span class="p">,</span>
             <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">method_1</span><span class="p">,</span> <span class="o">...</span><span class="p">}</span>

<span class="n">func</span> <span class="o">=</span> <span class="n">functions</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
<span class="n">func</span><span class="p">()</span>
</pre></div>
</div>
<p>オブジェクトのメソッドを呼び出すには、さらに単純に <a class="reference internal" href="../library/functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> 組み込み関数で特定の名前のメソッドを検索できます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">visit_a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>
<span class="o">...</span>

<span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">method_name</span> <span class="o">=</span> <span class="s1">&#39;visit_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method_name</span><span class="p">)</span>
    <span class="n">method</span><span class="p">()</span>
</pre></div>
</div>
<p>メソッドの名前にこの例の <code class="docutils literal notranslate"><span class="pre">visit_</span></code> のような接頭辞を使うことを勧めます。このような接頭辞がないと、信頼できないソースから値が与えられたときに、オブジェクトの任意のメソッドを呼び出す攻撃をされる可能性があります。</p>
</div>
<div class="section" id="can-t-you-emulate-threads-in-the-interpreter-instead-of-relying-on-an-os-specific-thread-implementation">
<h2><a class="toc-backref" href="#id14">OS 特有のスレッド実装に依らずにインタプリタでスレッドをエミュレートすることはできないのですか？</a><a class="headerlink" href="#can-t-you-emulate-threads-in-the-interpreter-instead-of-relying-on-an-os-specific-thread-implementation" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>答 1: 残念なことに、インタプリタは Python のスタックフレームごとに少なくとも一つの C のスタックフレームを push します。同様に、拡張もほとんどランダムなときに Python にコールバックすることがあります。よって、完全なスレッド実装には C のスレッドサポートが必要です。</p>
<p>答 2: 幸運なことに、<a class="reference external" href="https://github.com/stackless-dev/stackless/wiki">Stackless Python</a> があります。これは完全に再デザインされたインタープリタで、Cのスタックを回避しています。</p>
</div>
<div class="section" id="why-can-t-lambda-expressions-contain-statements">
<h2><a class="toc-backref" href="#id15">なぜラムダ式は文を含むことができないのですか?</a><a class="headerlink" href="#why-can-t-lambda-expressions-contain-statements" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python のラムダ式が文を含むことができないのは、Python の文法的な枠組みが式の中にネストされた文を扱うことができないからです。しかし、Python では、これは深刻な問題ではありません。他の言語のラムダに機能が追加されているのと違い、Python のラムダは単なる、関数を定義するのが面倒すぎる場合のための簡略な記法に過ぎないのです。</p>
<p>関数は既に Python の第一級オブジェクトで、ローカルスコープ内で宣言できます。従って、ローカルで定義された関数ではなくラムダを使う利点は、関数の名前を考える必要が無いことだけです -- しかし、(ラムダ式が生み出すオブジェクトと厳密に同じ型の) 関数オブジェクトが代入される先はただのローカル変数です！</p>
</div>
<div class="section" id="can-python-be-compiled-to-machine-code-c-or-some-other-language">
<h2><a class="toc-backref" href="#id16">Python は C やその他の言語のように機械語にコンパイルできますか？</a><a class="headerlink" href="#can-python-be-compiled-to-machine-code-c-or-some-other-language" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference external" href="http://cython.org/">Cython</a> は オプションのアノテーション付きのPythonの修正版を C拡張へ変換します。<a class="reference external" href="http://www.nuitka.net/">Nuitka</a> はPythonをC++コードへ変換する将来有望なPythonコンパイラで、完全なPython言語をサポートすることを目的としています。Javaへコンパイラするには、 <a class="reference external" href="https://voc.readthedocs.io">VOC</a> を検討してください。</p>
</div>
<div class="section" id="how-does-python-manage-memory">
<h2><a class="toc-backref" href="#id17">Python はメモリをどのように管理するのですか？</a><a class="headerlink" href="#how-does-python-manage-memory" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python のメモリ管理の詳細は実装に依ります。Python の標準の C 実装 <a class="reference internal" href="../glossary.html#term-cpython"><span class="xref std std-term">CPython</span></a> は参照カウントを使って、アクセスできないオブジェクトを探します。また別のメカニズムを使って参照サイクルを集めます。これはサイクル検出アルゴリズムを定期的に実行し、アクセスできないサイクルを探し、巻き込まれたオブジェクトを削除します。 <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> モジュールの関数で、ガベージコレクションを実行し、デバッグ統計を取得し、コレクタのパラメタを変更できます。</p>
<p>ただし、他の実装 (例えば <a class="reference external" href="http://www.jython.org">Jython</a> や <a class="reference external" href="http://www.pypy.org">PyPy</a>) は本格的 (full-blown) なガベージコレクタのような別のメカニズムに依存するかもしれません。あなたの Python コードが参照カウントの実装の振る舞いに依存する場合、この違いが微妙な移植上の問題を引き起こすでしょう。</p>
<p>Python の実装によっては、以下の (CPython では通る) コードはおそらく、ファイルディスクリプタを使い果たすでしょう:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">very_long_list_of_files</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>実際、CPython の参照カウントとデストラクタのスキームを使えば <em>f</em> への新しい代入ごとにファイルは閉じられます。しかし、伝統的な GC を使うと、これらのファイルオブジェクトが回収され (て閉じられる) までに不定な、場合によっては長い、間隔が空くことがあります。</p>
<p>Python の実装に依らずに動くコードを書くには、ファイルを明示的に閉じるか、 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 文を使ってください。これでメモリ管理のスキームに関係なく動きます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">very_long_list_of_files</span><span class="p">:</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="why-doesn-t-cpython-use-a-more-traditional-garbage-collection-scheme">
<h2><a class="toc-backref" href="#id18">CPython はなぜ伝統的なガベージコレクションスキームを使わないのですか？</a><a class="headerlink" href="#why-doesn-t-cpython-use-a-more-traditional-garbage-collection-scheme" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>まず、それは C の標準的な機能ではないのでポータブルではありません。(確かに Boehm GC ライブラリはあります。しかし、これにはアセンブリコードが含まれ、<em>ほとんどの</em> 有名なプラットフォームに対応していますが全てではありません。また、ほとんど透過的ですが、完全に透過的ではありません。Python を対応させるにはパッチが必要です。)</p>
<p>伝統的な GC は Python が他のアプリケーションに組み込まれるときにも問題となります。スタンドアロンの Python で動く限りでは、標準の malloc() と free() を GC ライブラリから提供されるものに置き換えても問題ありませんが、Python を実装したアプリケーションは Python のものではない <em>独自の</em> 代替品を使おうとするかもしれません。現在のようにすることで、CPython は malloc() と free() が適切に実装されている限りどんなものにも対応させられます。</p>
</div>
<div class="section" id="why-isn-t-all-memory-freed-when-cpython-exits">
<h2><a class="toc-backref" href="#id19">なぜ CPython の終了時にすべてのメモリが解放されるわけではないのですか？</a><a class="headerlink" href="#why-isn-t-all-memory-freed-when-cpython-exits" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python モジュールのグローバルな名前空間から参照されるオブジェクトは、Python の終了時にメモリの割り当てを解除されるとは限りません。これは、循環参照があるときに起こりえます。解放できない C ライブラリ (例えば、Purify のようなツールなどが当てはまります) によって割り当てられたいくらかのメモリも含まれます。しかし、Python は終了時にメモリをクリーンアップすることには積極的で、全ての単一のオブジェクトを破棄しようとします。</p>
<p>再割り当て時に Python が特定のものを削除するように強制したいときは、 <a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a> モジュールを使って削除を強制する関数を実行してください。</p>
</div>
<div class="section" id="why-are-there-separate-tuple-and-list-data-types">
<h2><a class="toc-backref" href="#id20">なぜタプルとリストという別のデータ型が用意されているのですか？</a><a class="headerlink" href="#why-are-there-separate-tuple-and-list-data-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>リストとタプルは、多くの点で似ていますが、一般には本質的に異なる方法で使われます。タプルは、Pascal のレコードや C の構造体と同様なものと考えられます。型が異なっても良い関連するデータの小さな集合で、グループとして演算されます。例えば、デカルト座標は 2 つや 3 つの数のタプルとして適切に表せます。</p>
<p>一方、リストは、もっと他の言語の配列に近いものです。全て同じ型の可変数のオブジェクトを持ち、それらが一つ一つ演算される傾向にあります。例えば、 <code class="docutils literal notranslate"><span class="pre">os.listdir('.')</span></code> はカレントディレクトリ内にあるファイルの文字列表現のリストを返します。この出力を演算する関数は一般に、ディレクトリに一つや二つの別のファイルを加えても壊れません。</p>
<p>タプルはイミュータブルなので、一度タプルが生成されたら、そのどの要素も新しい値に置き換えられません。リストはミュータブルなので、リストの要素はいつでも変更できます。イミュータブルな要素だけが辞書のキーとして使えるので、リストではなくタプルだけがキーとして使えます。</p>
</div>
<div class="section" id="how-are-lists-implemented-in-cpython">
<h2><a class="toc-backref" href="#id21">CPythonでリストはどのように実装されているのですか？</a><a class="headerlink" href="#how-are-lists-implemented-in-cpython" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>CPythonのリストは実際に変数分の長さの配列で、Lispスタイルの連結リストではありません。この実装は他のオブジェクトへの参照の連続した配列を使用していて、この配列へのポインタおよび配列長はリストの先頭の構造体に保存されています。</p>
<p>これにより、リストのインデクシング <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> は、リストの大きさやインデクスの値に依存しないコストで演算できます。</p>
<p>要素が追加または挿入されるとき、この参照の配列は大きさが変更されます。要素追加の繰り返しのパフォーマンスを上げるために、少し工夫されています。配列が大きくなるとき、次の何回かは実際に大きさを変更する必要がないように、いくらかの追加の領域が割り当てられます。</p>
</div>
<div class="section" id="how-are-dictionaries-implemented-in-cpython">
<h2><a class="toc-backref" href="#id22">CPythonで辞書はどのように実装されていますか？</a><a class="headerlink" href="#how-are-dictionaries-implemented-in-cpython" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>CPython の辞書は大きさを変更できるハッシュテーブルとして実装されています。B 木と比べて、ほとんどの条件下で (特に一般的な演算である) 探索のパフォーマンスが良いですし、実装も単純です。</p>
<p>辞書は、 辞書に保存されているそれぞれのキーに対応するハッシュコードを:func:<cite>hash</cite> ビルトイン関数で計算することで機能します。このハッシュコードはキーやプロセスごとのシードによって大きく変化します。例えば、&quot;Python&quot; のハッシュ値は -539294296 ですが、ビットが一つ違うだけの文字列 &quot;python&quot; のハッシュ値は 1142331976 です。そしてこのハッシュコードは、値が保存される内部配列での位置を計算するために使われます。保存しているキーのハッシュ値が全て異なるとすれば、一定の時間 − big O-記法ではO(1) − でキーを検索できることになります。</p>
</div>
<div class="section" id="why-must-dictionary-keys-be-immutable">
<h2><a class="toc-backref" href="#id23">なぜ辞書のキーはイミュータブルでなくてはならないのですか？</a><a class="headerlink" href="#why-must-dictionary-keys-be-immutable" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>辞書のハッシュテーブルの実装は、キーを見つけるために、キー値から計算されたハッシュ値を使います。もしキーがミュータブルなオブジェクトだったら、その値は変えられ、それによりハッシュ値も変わってしまいます。しかし、キーオブジェクトを変更したのが何者であれ、値が辞書のキーとして使われていたと気付けないので、辞書の中のエントリを適切な場所に動かせません。そして、同じオブジェクトを探そうとしても、ハッシュ値が違うため見つかりません。古い値を探そうとしても、そのハッシュバイナリから見つかるオブジェクトの値は異なるでしょうから、これも見つかりません。</p>
<p>リストでインデクシングされた辞書が必要なら、まず単純にリストをタプルに変換してください。関数 <code class="docutils literal notranslate"><span class="pre">tuple(L)</span></code> は、リスト <code class="docutils literal notranslate"><span class="pre">L</span></code> と同じエントリのタプルを生成します。タプルはイミュータブルなので、辞書のキーとして使えます。</p>
<p>いくつかの受け入れられなかった提案:</p>
<ul>
<li><p class="first">アドレス (オブジェクト ID) のハッシュリスト。これは、同じ値の新しいリストを作っても見つからないので駄目です。例えば:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">mydict</span> <span class="o">=</span> <span class="p">{[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span> <span class="s1">&#39;12&#39;</span><span class="p">}</span>
<span class="nb">print</span><span class="p">(</span><span class="n">mydict</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2]</span></code> の2行目のidは1行目のそれと異なってしまうために <a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> 例外を送出するでしょう。言い換えれば、辞書のキーは <code class="docutils literal notranslate"><span class="pre">==</span></code> を使って比較されるべきであり、 <a class="reference internal" href="../reference/expressions.html#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> ではないということです。</p>
</li>
<li><p class="first">リストをキーとして使うときにコピーを作る。リストはミュータブルなので、自分自身への参照を含むことができ、コードをコピーするときに無限ループにハマる可能性があるので、これは駄目です。</p>
</li>
<li><p class="first">リストをキーとして使うことを認めるが、ユーザにそれを変更させないように伝える。もしユーザが忘れたり、偶然にリストが変更されてしまったりしたら、追跡困難なバグの可能性を生じてしまいます。またこれは、 <code class="docutils literal notranslate"><span class="pre">d.keys()</span></code> のすべての値は辞書のキーとして使えるという、辞書の重要な不変性も潰してしまいます。</p>
</li>
<li><p class="first">リストが一旦辞書のキーとして使われたら、読み出し専用のマークを付ける。問題は、値を変えられるのはトップレベルオブジェクトだけではないことです。リストを含むタプルもキーとして使えます。全てを辞書のキーとして導入すると、そこから到達可能な全てのオブジェクトに読み出し専用のマークを付ける必要があります -- そして再び、自己参照オブジェクトが無限ループを引き起こします。</p>
</li>
</ul>
<p>必要ならばこれを回避する方法がありますが、自己責任のもとで行ってください。ミュータブルな構造を、 <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> と <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> メソッドの両方を持つクラスインスタンスに含めることができます。その時、辞書 (またはハッシュに基づく別の構造体) に属するような全てのラッパーオブジェクトのハッシュ値が、そのオブジェクトが辞書 (その他の構造体) 中にある間固定され続けることを確実にしてください。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ListWrapper</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">the_list</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">the_list</span> <span class="o">=</span> <span class="n">the_list</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">the_list</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">the_list</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">the_list</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">98767</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">*</span><span class="mi">555</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="o">%</span> <span class="mi">9999999</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1001</span> <span class="o">+</span> <span class="n">i</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span> <span class="o">%</span> <span class="mi">7777777</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">333</span>
        <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>なお、リストのメンバーの中にハッシュ化できないものがある可能性や、算術オーバーフローの可能性から、ハッシュ計算は複雑になります。</p>
<p>さらに、そのオブジェクトが辞書に含まれるか否かにかかわらず、 <code class="docutils literal notranslate"><span class="pre">o1</span> <span class="pre">==</span> <span class="pre">o2</span></code> (すなわち <code class="docutils literal notranslate"><span class="pre">o1.__eq__(o2)</span> <span class="pre">is</span> <span class="pre">True</span></code>) ならばいつでも <code class="docutils literal notranslate"><span class="pre">hash(o1)</span> <span class="pre">==</span> <span class="pre">hash(o2)</span></code> (すなわち <code class="docutils literal notranslate"><span class="pre">o1.__hash__()</span> <span class="pre">==</span> <span class="pre">o2.__hash__()</span></code>) でなくてはなりません。その制限に適合できなければ、辞書やその他のハッシュに基づく構造体は間違いを起こします。</p>
<p>この ListWrapper の例では、異常を避けるため、ラッパオブジェクトが辞書内にある限りラップされたリストが変更されてはなりません。この条件と満たせなかった時の結果について知恵を絞る覚悟がない限り、これをしてはいけません。よく考えてください。</p>
</div>
<div class="section" id="why-doesn-t-list-sort-return-the-sorted-list">
<h2><a class="toc-backref" href="#id24">なぜ list.sort() はソートされたリストを返さないのですか？</a><a class="headerlink" href="#why-doesn-t-list-sort-return-the-sorted-list" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>パフォーマンスが問題となる状況では、ソートするためだけにリストのコピーを作るのは無駄が多いです。そこで、 <a class="reference internal" href="../library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> はインプレースにリストをソートします。このことを忘れないため、この関数はソートされたリストを返しません。こうすることで、ソートされたコピーが必要で、ソートされていないものも残しておきたいときに、うっかり上書きしてしまうようなことがなくなります。</p>
<p>新しいリストを返したいなら、代わりに組み込みの <a class="reference internal" href="../library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a> 関数を使ってください。この関数は、与えられたイテレート可能オブジェクトから新しいリストを生成し、ソートして返します。例えば、辞書のキーをソートされた順序でイテレートする方法は:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">mydict</span><span class="p">):</span>
    <span class="o">...</span>  <span class="c1"># do whatever with mydict[key]...</span>
</pre></div>
</div>
</div>
<div class="section" id="how-do-you-specify-and-enforce-an-interface-spec-in-python">
<h2><a class="toc-backref" href="#id25">Python ではどのようにインタフェース仕様を特定し適用するのですか？</a><a class="headerlink" href="#how-do-you-specify-and-enforce-an-interface-spec-in-python" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>C++ や Java のような言語が提供するような、モジュールに対するインタフェース仕様の特定は、モジュールのメソッドや関数の原型を表現します。インタフェースの特定がコンパイル時に適用されることが、大きなプログラムの構成に役立つと、広く感じられています。</p>
<p>Python 2.6 で、抽象基底クラス (Abstract Base Class, ABC) が定義できるようになる <a class="reference internal" href="../library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a> モジュールが追加されました。なので <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> と <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> を使って、インスタンスやクラスが、ある ABC を実装しているかどうかチェックできます。<a class="reference internal" href="../library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> モジュールでは、 <a class="reference internal" href="../library/collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a> 、 <a class="reference internal" href="../library/collections.abc.html#collections.abc.Container" title="collections.abc.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">Container</span></code></a> 、 <a class="reference internal" href="../library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableMapping</span></code></a> などの便利な ABC が定義されています。</p>
<p>Python では、コンポーネントの適切なテスト規律によって、インタフェース仕様の多くの強みを活かせます。サブクラス化による問題を見つけるために使えるツール PyChecker もあります。</p>
<p>モジュールのための適切なテストスイートは、回帰テストを提供し、モジュールのインタフェース仕様や用例集としても役立ちます。多くの Python モジュールは、簡単な「自己テスト」を提供するスクリプトとして実行できます。複雑な外部インタフェースを使うモジュールさえ、外部インタフェースの細かい「スタブ」エミュレーションで単独にテストできることが多いです。 <a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> や <a class="reference internal" href="../library/unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> モジュール、あるいはサードパーティのテストフレームワークで、モジュールのコードの全ての行に及ぶ徹底的なテストスイートを構成できます。</p>
<p>Python で大きくて複雑なアプリケーションを構築するとき、インタフェース仕様と同様に、適切なテスト規律も役立ちます。実際には、インタフェース仕様ではテストできないプログラムの属性もあるので、それ以上にもなりえます。例えば、 <code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code> メソッドは新しい要素をある内部リストの終わりに加えます。インタフェース仕様ではこの <code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code> の実装が実際にこれを行うかをテストできませんが、テストスイートならこの機能を簡単に確かめられます。</p>
<p>テストスイートを書くことはとても役に立ちますし、テストのしやすさという視点でコードを設計することにもつながります。テスト指向開発は、人気を増しつつある技法で、実際のコードを書き始める前に、最初からテストスイートの部品を書くことを求めます。もちろん、 Python で粗雑にテストケースを全く書かないこともできます。</p>
</div>
<div class="section" id="why-is-there-no-goto">
<h2><a class="toc-backref" href="#id26">なぜ goto が無いのですか？</a><a class="headerlink" href="#why-is-there-no-goto" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>関数の呼び出しをまたいでも動作する &quot;構造化された goto&quot; をまかなうものとして例外を使えます。C、Fortran、その他の言語での &quot;go&quot; あるいは &quot;goto&quot; 構造の適切な用途は全て、例外で同じようなことををすれば便利であると、広く感じられています。例えば:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">label</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span> <span class="k">pass</span>  <span class="c1"># declare a label</span>

<span class="k">try</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">if</span> <span class="n">condition</span><span class="p">:</span> <span class="k">raise</span> <span class="n">label</span><span class="p">()</span>  <span class="c1"># goto label</span>
    <span class="o">...</span>
<span class="k">except</span> <span class="n">label</span><span class="p">:</span>  <span class="c1"># where to goto</span>
    <span class="k">pass</span>
<span class="o">...</span>
</pre></div>
</div>
<p>例外ではループ内へ跳ぶことはできませんが、どちらにしてもそれは goto の乱用と見なされるものです。使うのは控えてください。</p>
</div>
<div class="section" id="why-can-t-raw-strings-r-strings-end-with-a-backslash">
<h2><a class="toc-backref" href="#id27">なぜ raw 文字列 (r-strings) はバックスラッシュで終わってはいけないのですか？</a><a class="headerlink" href="#why-can-t-raw-strings-r-strings-end-with-a-backslash" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>正確には、奇数個のバックスラッシュで終わってはいけません。終わりの対になっていないバックスラッシュは、閉じ引用文字をエスケープし、終っていない文字列を残してしまいます。</p>
<p>raw 文字列は、独自にバックスラッシュの処理をしようとするプロセッサ (主に正規表現エンジン) への入力を生成しやすいように設計されたものです。このようなプロセッサは、終端の対になっていないバックスラッシュを結局エラーとみなすので、raw 文字列はそれを認めません。その代わりに、バックスラッシュでエスケープすることで、引用文字を文字列として渡すことができます。r-string が意図された目的に使われるときに、この規則が役に立つのです。</p>
<p>Windows のパス名を構築するときには、Windows のシステムコールは普通のスラッシュも受け付けることを憶えておいてください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;/mydir/file.txt&quot;</span><span class="p">)</span>  <span class="c1"># works fine!</span>
</pre></div>
</div>
<p>DOS コマンドのパス名を構築するときには、例えばこの中のどれかを試してください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">dir</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\this\is\my\dos\dir&quot;</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span>
<span class="nb">dir</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\this\is\my\dos\dir\ &quot;</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="nb">dir</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">this</span><span class="se">\\</span><span class="s2">is</span><span class="se">\\</span><span class="s2">my</span><span class="se">\\</span><span class="s2">dos</span><span class="se">\\</span><span class="s2">dir</span><span class="se">\\</span><span class="s2">&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="why-doesn-t-python-have-a-with-statement-for-attribute-assignments">
<h2><a class="toc-backref" href="#id28">属性の代入に &quot;with&quot; 文が使えないのはなぜですか？</a><a class="headerlink" href="#why-doesn-t-python-have-a-with-statement-for-attribute-assignments" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python には、ブロックの実行を包む 'with' 文があり、ブロックに入るときとブロックから出るときに、コードを呼び出します。以下のような構造を持つ言語があります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">obj</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>               <span class="c1"># equivalent to obj.a = 1</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">total</span> <span class="o">+</span> <span class="mi">1</span>   <span class="c1"># obj.total = obj.total + 1</span>
</pre></div>
</div>
<p>Python では、このような構造は曖昧になるでしょう。</p>
<p>Object Pascal、Delphi、C++のような他の言語では、静的な型を使うので、曖昧な方法でも、どのメンバに代入されているのか分かります。これが静的型付けの要点です -- コンパイラは <em>いつでも</em> コンパイル時にすべての変数のスコープを知るのです。</p>
<p>Python は動的な型を使います。実行時にどの属性が参照されるか事前に分かりません。動作中にメンバ属性が追加あるいは除去されるかもしれません。これでは、単純に読むだけではどのアトリビュートが参照されているか分かりません。ローカルなのか、グローバルなのか、メンバ属性なのか？</p>
<p>例えば、以下の不完全なコード片を考えましょう:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">a</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>このコード片では、&quot;a&quot; は &quot;x&quot; というメンバ属性を持っていると仮定されています。しかし、Python ではインタプリタにはこの仮定を伝えられる仕組みはありません。 &quot;a&quot; が、例えば整数だったら、どうなってしまうでしょうか。 &quot;x&quot; という名前のグローバル変数があったら、それが with ブロックの中で使われるのでしょうか。この通り、Python の動的な特質から、このような選択はとても難しい物になっています。</p>
<p>しかし、&quot;with&quot; やそれに類する言語の機能の一番の利点 (コード量の削減) は、 Python では代入により簡単に手に入れられます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">function</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">mydict</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">21</span>
<span class="n">function</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">mydict</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">function</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">mydict</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="mi">63</span>
</pre></div>
</div>
<p>こう書いてください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ref</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">mydict</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">index</span><span class="p">]</span>
<span class="n">ref</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">21</span>
<span class="n">ref</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">ref</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="mi">63</span>
</pre></div>
</div>
<p>Python では実行時に名前束縛が解決され、後者はその解決が一度で済むため、これには実行速度をあげる副作用もあります。</p>
</div>
<div class="section" id="why-are-colons-required-for-the-if-while-def-class-statements">
<h2><a class="toc-backref" href="#id29">if/while/def/class 文にコロンが必要なのはなぜですか？</a><a class="headerlink" href="#why-are-colons-required-for-the-if-while-def-class-statements" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>主に可読性を高めるため (実験的な ABC 言語の結果の一つ) に、コロンが必要です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>と:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>を考えれば、後者のほうが少し読みやすいでしょう。さらに言えば、この FAQ の解答例は次のようになるでしょう。これは、英語の標準的な用法です。</p>
<p>他の小さな理由は、コロンによってエディタがシンタックスハイライトをしやすくなることです。プログラムテキストの手の込んだ解析をしなくても、コロンを探せばいつインデントを増やすべきかを決められます。</p>
</div>
<div class="section" id="why-does-python-allow-commas-at-the-end-of-lists-and-tuples">
<h2><a class="toc-backref" href="#id30">なぜ Python ではリストやタプルの最後にカンマがあっても良いのですか？</a><a class="headerlink" href="#why-does-python-allow-commas-at-the-end-of-lists-and-tuples" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python では、リスト、タプル、辞書の最後の要素の後端にカンマをつけても良いことになっています:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,]</span>
<span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,)</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
    <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>  <span class="c1"># last trailing comma is optional but good style</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これを許すのには、いくつかの理由があります。</p>
<p>リストやタプルや辞書のリテラルが複数行に渡っているときに、前の行にカンマを追加するのを覚えておく必要が無いため、要素を追加するのが楽になります。また、文法エラーを起こすこと無く、行の並べ替えを行うことができます。</p>
<p>間違えてカンマを落としてしまうと、診断しづらいエラーにつながります。例えば:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span>
  <span class="s2">&quot;fee&quot;</span><span class="p">,</span>
  <span class="s2">&quot;fie&quot;</span>
  <span class="s2">&quot;foo&quot;</span><span class="p">,</span>
  <span class="s2">&quot;fum&quot;</span>
<span class="p">]</span>
</pre></div>
</div>
<p>このリストには4つの要素があるように見えますが、実際には3つしかありません。
&quot;fee&quot;、&quot;fiefoo&quot;、&quot;fum&quot; です。
常にカンマを付けるようにすれば、この種のエラーが避けられます。</p>
<p>後端にカンマをつけても良いことにすれば、プログラムによるコード生成も簡単になります。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">デザインと歴史 FAQ</a><ul>
<li><a class="reference internal" href="#why-does-python-use-indentation-for-grouping-of-statements">Python はなぜ文のグループ化にインデントを使うのですか？</a></li>
<li><a class="reference internal" href="#why-am-i-getting-strange-results-with-simple-arithmetic-operations">なぜ単純な算術演算が奇妙な結果になるのですか？</a></li>
<li><a class="reference internal" href="#why-are-floating-point-calculations-so-inaccurate">なんで浮動小数点数の計算はこんなに不正確なんですか？</a></li>
<li><a class="reference internal" href="#why-are-python-strings-immutable">なぜ Python の文字列はイミュータブルなのですか？</a></li>
<li><a class="reference internal" href="#why-must-self-be-used-explicitly-in-method-definitions-and-calls">なぜメソッドの定義や呼び出しにおいて 'self' を明示しなければならないのですか？</a></li>
<li><a class="reference internal" href="#why-can-t-i-use-an-assignment-in-an-expression">式中で代入ができないのはなぜですか？</a></li>
<li><a class="reference internal" href="#why-does-python-use-methods-for-some-functionality-e-g-list-index-but-functions-for-other-e-g-len-list">Python にメソッドを使う機能 (list.index() 等) と関数を使う機能 (len(list) 等) があるのはなぜですか？</a></li>
<li><a class="reference internal" href="#why-is-join-a-string-method-instead-of-a-list-or-tuple-method">join() がリストやタプルのメソッドではなく文字列のメソッドなのはなぜですか？</a></li>
<li><a class="reference internal" href="#how-fast-are-exceptions">例外はどれくらい速いのですか？</a></li>
<li><a class="reference internal" href="#why-isn-t-there-a-switch-or-case-statement-in-python">Python に switch や case 文がないのはなぜですか？</a></li>
<li><a class="reference internal" href="#can-t-you-emulate-threads-in-the-interpreter-instead-of-relying-on-an-os-specific-thread-implementation">OS 特有のスレッド実装に依らずにインタプリタでスレッドをエミュレートすることはできないのですか？</a></li>
<li><a class="reference internal" href="#why-can-t-lambda-expressions-contain-statements">なぜラムダ式は文を含むことができないのですか?</a></li>
<li><a class="reference internal" href="#can-python-be-compiled-to-machine-code-c-or-some-other-language">Python は C やその他の言語のように機械語にコンパイルできますか？</a></li>
<li><a class="reference internal" href="#how-does-python-manage-memory">Python はメモリをどのように管理するのですか？</a></li>
<li><a class="reference internal" href="#why-doesn-t-cpython-use-a-more-traditional-garbage-collection-scheme">CPython はなぜ伝統的なガベージコレクションスキームを使わないのですか？</a></li>
<li><a class="reference internal" href="#why-isn-t-all-memory-freed-when-cpython-exits">なぜ CPython の終了時にすべてのメモリが解放されるわけではないのですか？</a></li>
<li><a class="reference internal" href="#why-are-there-separate-tuple-and-list-data-types">なぜタプルとリストという別のデータ型が用意されているのですか？</a></li>
<li><a class="reference internal" href="#how-are-lists-implemented-in-cpython">CPythonでリストはどのように実装されているのですか？</a></li>
<li><a class="reference internal" href="#how-are-dictionaries-implemented-in-cpython">CPythonで辞書はどのように実装されていますか？</a></li>
<li><a class="reference internal" href="#why-must-dictionary-keys-be-immutable">なぜ辞書のキーはイミュータブルでなくてはならないのですか？</a></li>
<li><a class="reference internal" href="#why-doesn-t-list-sort-return-the-sorted-list">なぜ list.sort() はソートされたリストを返さないのですか？</a></li>
<li><a class="reference internal" href="#how-do-you-specify-and-enforce-an-interface-spec-in-python">Python ではどのようにインタフェース仕様を特定し適用するのですか？</a></li>
<li><a class="reference internal" href="#why-is-there-no-goto">なぜ goto が無いのですか？</a></li>
<li><a class="reference internal" href="#why-can-t-raw-strings-r-strings-end-with-a-backslash">なぜ raw 文字列 (r-strings) はバックスラッシュで終わってはいけないのですか？</a></li>
<li><a class="reference internal" href="#why-doesn-t-python-have-a-with-statement-for-attribute-assignments">属性の代入に &quot;with&quot; 文が使えないのはなぜですか？</a></li>
<li><a class="reference internal" href="#why-are-colons-required-for-the-if-while-def-class-statements">if/while/def/class 文にコロンが必要なのはなぜですか？</a></li>
<li><a class="reference internal" href="#why-does-python-allow-commas-at-the-end-of-lists-and-tuples">なぜ Python ではリストやタプルの最後にカンマがあっても良いのですか？</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="programming.html"
                        title="前の章へ">プログラミング FAQ</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="library.html"
                        title="次の章へ">ライブラリと拡張 FAQ</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.8/Doc/faq/design.rst"
            rel="nofollow">ソースコードを表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="library.html" title="ライブラリと拡張 FAQ"
             >次へ</a> |</li>
        <li class="right" >
          <a href="programming.html" title="プログラミング FAQ"
             >前へ</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.3 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python よくある質問</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" type="text" name="q" />
          <input type="submit" value="検索" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">著作権</a> 2001-2020, Python Software Foundation.
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最終更新: 5月 16, 2020
    <a href="https://docs.python.org/3/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>

  </body>
</html>