
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>プログラミング FAQ &#8212; Python 3.8.3 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.8.3 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="next" title="デザインと歴史 FAQ" href="design.html" />
    <link rel="prev" title="一般 Python FAQ" href="general.html" />
    <link rel="canonical" href="https://docs.python.org/3/faq/programming.html" />
    
      
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="design.html" title="デザインと歴史 FAQ"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="general.html" title="一般 Python FAQ"
             accesskey="P">前へ</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.3 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python よくある質問</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" type="text" name="q" />
          <input type="submit" value="検索" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="programming-faq">
<h1><a class="toc-backref" href="#id2">プログラミング FAQ</a><a class="headerlink" href="#programming-faq" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="contents topic" id="id1">
<p class="topic-title">目次</p>
<ul class="simple">
<li><a class="reference internal" href="#programming-faq" id="id2">プログラミング FAQ</a><ul>
<li><a class="reference internal" href="#general-questions" id="id3">一般的な質問</a><ul>
<li><a class="reference internal" href="#is-there-a-source-code-level-debugger-with-breakpoints-single-stepping-etc" id="id4">ブレークポイントやシングルステップ実行などを備えたソースコードレベルデバッガはありますか？</a></li>
<li><a class="reference internal" href="#is-there-a-tool-to-help-find-bugs-or-perform-static-analysis" id="id5">バグの発見や静的解析に役立つツールはありますか？</a></li>
<li><a class="reference internal" href="#how-can-i-create-a-stand-alone-binary-from-a-python-script" id="id6">どうしたら Python スクリプトからスタンドアロンバイナリを作れますか？</a></li>
<li><a class="reference internal" href="#are-there-coding-standards-or-a-style-guide-for-python-programs" id="id7">Python プログラムのためのコーディングスタンダードやスタイルガイドはありますか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#core-language" id="id8">コア言語</a><ul>
<li><a class="reference internal" href="#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" id="id9">なぜ変数に値があるのに UnboundLocalError が出るのですか？</a></li>
<li><a class="reference internal" href="#what-are-the-rules-for-local-and-global-variables-in-python" id="id10">Python のローカルとグローバル変数のルールは何ですか？</a></li>
<li><a class="reference internal" href="#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result" id="id11">ループの中で異なる値で定義されたラムダ式が、同じ値を返すのはなぜですか？</a></li>
<li><a class="reference internal" href="#how-do-i-share-global-variables-across-modules" id="id12">グローバル変数をモジュール間で共有するにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#what-are-the-best-practices-for-using-import-in-a-module" id="id13">モジュールで import を使う際の「ベストプラクティス」は何ですか？</a></li>
<li><a class="reference internal" href="#why-are-default-values-shared-between-objects" id="id14">なぜオブジェクト間でデフォルト値が共有されるのですか？</a></li>
<li><a class="reference internal" href="#how-can-i-pass-optional-or-keyword-parameters-from-one-function-to-another" id="id15">オプションパラメータやキーワードパラメータを関数から関数へ渡すにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#what-is-the-difference-between-arguments-and-parameters" id="id16">実引数と仮引数の違いは何ですか?</a></li>
<li><a class="reference internal" href="#why-did-changing-list-y-also-change-list-x" id="id17">なぜ list 'y' を変更すると list 'x' も変更されるのですか?</a></li>
<li><a class="reference internal" href="#how-do-i-write-a-function-with-output-parameters-call-by-reference" id="id18">出力引数のある関数 (参照渡し) はどのように書きますか？</a></li>
<li><a class="reference internal" href="#how-do-you-make-a-higher-order-function-in-python" id="id19">Python で高次関数はどのようにつくりますか？</a></li>
<li><a class="reference internal" href="#how-do-i-copy-an-object-in-python" id="id20">Python のオブジェクトはどのようにコピーしますか？</a></li>
<li><a class="reference internal" href="#how-can-i-find-the-methods-or-attributes-of-an-object" id="id21">オブジェクトのメソッドや属性はどのように見つけますか？</a></li>
<li><a class="reference internal" href="#how-can-my-code-discover-the-name-of-an-object" id="id22">コードはどのようにオブジェクトの名前を見つけるのですか？</a></li>
<li><a class="reference internal" href="#what-s-up-with-the-comma-operator-s-precedence" id="id23">カンマ演算子はなぜ優先されるのですか？</a></li>
<li><a class="reference internal" href="#is-there-an-equivalent-of-c-s-ternary-operator" id="id24">C の &quot;?:&quot; 三項演算子と等価なものはありますか？</a></li>
<li><a class="reference internal" href="#is-it-possible-to-write-obfuscated-one-liners-in-python" id="id25">Python で解し難いワンライナーを書くことはできますか？</a></li>
<li><a class="reference internal" href="#what-does-the-slash-in-the-parameter-list-of-a-function-mean" id="id26">関数の引数リストにあるスラッシュ (/) は何を意味しますか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#numbers-and-strings" id="id27">数と文字列</a><ul>
<li><a class="reference internal" href="#how-do-i-specify-hexadecimal-and-octal-integers" id="id28">十六進数や八進数を指定するにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#why-does-22-10-return-3" id="id29">なぜ -22 // 10 は -3 を返すのですか？</a></li>
<li><a class="reference internal" href="#how-do-i-convert-a-string-to-a-number" id="id30">文字列を数に変換するにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#how-do-i-convert-a-number-to-a-string" id="id31">数を文字列に変換するにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#how-do-i-modify-a-string-in-place" id="id32">文字列をインプレースに変更するにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#how-do-i-use-strings-to-call-functions-methods" id="id33">関数やメソッドを呼ぶのに文字列を使うにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#is-there-an-equivalent-to-perl-s-chomp-for-removing-trailing-newlines-from-strings" id="id34">文字列から後端の改行を取り除く Perl の chomp() に相当するものはありますか？</a></li>
<li><a class="reference internal" href="#is-there-a-scanf-or-sscanf-equivalent" id="id35">scanf() や sscanf() と同等なものはありますか？</a></li>
<li><a class="reference internal" href="#what-does-unicodedecodeerror-or-unicodeencodeerror-error-mean" id="id36">'UnicodeDecodeError' や 'UnicodeEncodeError' はどういう意味ですか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#performance" id="id37">性能</a><ul>
<li><a class="reference internal" href="#my-program-is-too-slow-how-do-i-speed-it-up" id="id38">プログラムが遅すぎます。どうしたら速くなりますか？</a></li>
<li><a class="reference internal" href="#what-is-the-most-efficient-way-to-concatenate-many-strings-together" id="id39">多くの文字列を結合するのに最も効率的な方法は何ですか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sequences-tuples-lists" id="id40">シーケンス(タプル/リスト)</a><ul>
<li><a class="reference internal" href="#how-do-i-convert-between-tuples-and-lists" id="id41">タプル、リスト間の変更はどのようにするのですか？</a></li>
<li><a class="reference internal" href="#what-s-a-negative-index" id="id42">負の添え字は何ですか？</a></li>
<li><a class="reference internal" href="#how-do-i-iterate-over-a-sequence-in-reverse-order" id="id43">シーケンスを逆順にイテレートするにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#how-do-you-remove-duplicates-from-a-list" id="id44">リストから重複を取り除くにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-do-you-make-an-array-in-python" id="id45">Python で配列を作るにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-do-i-create-a-multidimensional-list" id="id46">多次元のリストを作るにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-do-i-apply-a-method-to-a-sequence-of-objects" id="id47">オブジェクトのシーケンスにメソッドを適用するにはどうしますか？</a></li>
<li><a class="reference internal" href="#why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works" id="id48">なぜ加算はされるのに a_tuple[i] += ['item'] は例外を送出するのですか?</a></li>
<li><a class="reference internal" href="#i-want-to-do-a-complicated-sort-can-you-do-a-schwartzian-transform-in-python" id="id49">複雑なソートがしたいのですが、Python でシュワルツ変換はできますか？</a></li>
<li><a class="reference internal" href="#how-can-i-sort-one-list-by-values-from-another-list" id="id50">リストを別のリストの値によってソートするにはどうしますか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#objects" id="id51">オブジェクト</a><ul>
<li><a class="reference internal" href="#what-is-a-class" id="id52">クラスとは何ですか？</a></li>
<li><a class="reference internal" href="#what-is-a-method" id="id53">メソッドとは何ですか？</a></li>
<li><a class="reference internal" href="#what-is-self" id="id54">self とは何ですか？</a></li>
<li><a class="reference internal" href="#how-do-i-check-if-an-object-is-an-instance-of-a-given-class-or-of-a-subclass-of-it" id="id55">あるオブジェクトが、与えられたクラスやそのサブクラスのインスタンスであるかを調べるにはどうしますか？</a></li>
<li><a class="reference internal" href="#what-is-delegation" id="id56">委譲とは何ですか？</a></li>
<li><a class="reference internal" href="#how-do-i-call-a-method-defined-in-a-base-class-from-a-derived-class-that-overrides-it" id="id57">基底クラスで定義されたメソッドを、そのクラスをオーバーライドした派生クラスから呼び出すにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-can-i-organize-my-code-to-make-it-easier-to-change-the-base-class" id="id58">基底クラスの名前を変えやすいコードを書くにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-do-i-create-static-class-data-and-static-class-methods" id="id59">静的なクラスデータや静的なクラスメソッドを作るにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-can-i-overload-constructors-or-methods-in-python" id="id60">Python でコンストラクタ(やメソッド)をオーバーロードするにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#i-try-to-use-spam-and-i-get-an-error-about-someclassname-spam" id="id61">__spam を使おうとしたら _SomeClassName__spam からエラーがでました。</a></li>
<li><a class="reference internal" href="#my-class-defines-del-but-it-is-not-called-when-i-delete-the-object" id="id62">クラスに __del__ メソッドを定義しているのですが、オブジェクトを削除したときに呼ばれません。</a></li>
<li><a class="reference internal" href="#how-do-i-get-a-list-of-all-instances-of-a-given-class" id="id63">与えられたクラスのすべてのインスタンスのリストを得るにはどうしますか？</a></li>
<li><a class="reference internal" href="#why-does-the-result-of-id-appear-to-be-not-unique" id="id64">なぜ <code class="docutils literal notranslate"><span class="pre">id()</span></code> の結果は一意でないように見えるのですか?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#modules" id="id65">モジュール (module)</a><ul>
<li><a class="reference internal" href="#how-do-i-create-a-pyc-file" id="id66">.pyc ファイルを作るにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-do-i-find-the-current-module-name" id="id67">現在のモジュール名を知るにはどうしますか？</a></li>
<li><a class="reference internal" href="#how-can-i-have-modules-that-mutually-import-each-other" id="id68">相互にインポートしあうモジュールを作るにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#import-x-y-z-returns-module-x-how-do-i-get-z" id="id69">__import__('x.y.z') は &lt;module 'x'&gt; を返しますが、z を得るためにはどうしますか？</a></li>
<li><a class="reference internal" href="#when-i-edit-an-imported-module-and-reimport-it-the-changes-don-t-show-up-why-does-this-happen" id="id70">インポートされたモジュールを編集してから再インポートしましたが、変化が現れません。なぜですか？</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="general-questions">
<h2><a class="toc-backref" href="#id3">一般的な質問</a><a class="headerlink" href="#general-questions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="is-there-a-source-code-level-debugger-with-breakpoints-single-stepping-etc">
<h3><a class="toc-backref" href="#id4">ブレークポイントやシングルステップ実行などを備えたソースコードレベルデバッガはありますか？</a><a class="headerlink" href="#is-there-a-source-code-level-debugger-with-breakpoints-single-stepping-etc" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>はい。</p>
<p>Python 用のデバッガについては次に解説してあり、組み込みの <a class="reference internal" href="../library/functions.html#breakpoint" title="breakpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">breakpoint()</span></code></a> 関数でそれらのデバッガに処理を移せます。</p>
<p>pdb モジュールは簡素にして十分な Python のコンソールモードデバッガです。これは Python の標準ライブラリに含まれているもので、 <a class="reference internal" href="../library/pdb.html#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ライブラリリファレンスマニュアルにドキュメントがあります</span></code></a> 。 pdb のコードを手本にして自分用のデバッガを書くこともできます。</p>
<p>Python に同梱されている統合開発環境の IDLE は通常の Python の配布形態の一部 (普通は Tools/scripts/idle から利用可能) であり、グラフィカルなデバッガを含んでいます。</p>
<p>PythonWin は、pdb をベースとした GUI デバッガを含む Python IDE です。Pythonwin デバッガは、ブレークポイントの色付けや非 Pythonwin プログラムのデバッグなどのたくさんの素敵な機能を持っています。Pythonwin は <a class="reference external" href="https://sourceforge.net/projects/pywin32/">Python for Windows Extensions</a> プロジェクトの一部、あるいは ActivePython ディストリビューション (<a class="reference external" href="https://www.activestate.com/activepython">https://www.activestate.com/activepython</a> を参照) の一部として利用可能です。</p>
<p><a class="reference external" href="http://boa-constructor.sourceforge.net/">Boa Constructor</a> は、wxWidgets を使った IDE と GUI ビルダーです。これは視覚フレームの作成と操作、オブジェクト検査、オブジェクトブラウザのような多くのビュー、継承構造、doc string から生成される html ドキュメント、高度なデバッガ、総合ヘルプ、Zope のサポートを提供します。</p>
<p><a class="reference external" href="http://eric-ide.python-projects.org/">Eric</a> は PyQt や Scintilla editing component をもとにした IDE です。</p>
<p>Pydb は標準のデバッガである pdb を人気のグラフィカルデバッガフロントエンドである DDD (Data Display Debugger) とともに使うために改変したものです。Pydb は <a class="reference external" href="http://bashdb.sourceforge.net/pydb/">http://bashdb.sourceforge.net/pydb/</a> に、 DDD は <a class="reference external" href="https://www.gnu.org/software/ddd">https://www.gnu.org/software/ddd</a> にあります。</p>
<p>商業のグラフィカルデバッガ付き Python IDE もあります。例えば:</p>
<ul class="simple">
<li>Wing IDE (<a class="reference external" href="https://wingware.com/">https://wingware.com/</a>)</li>
<li>Komodo IDE (<a class="reference external" href="https://komodoide.com/">https://komodoide.com/</a>)</li>
<li>PyCharm (<a class="reference external" href="https://www.jetbrains.com/pycharm/">https://www.jetbrains.com/pycharm/</a>)</li>
</ul>
</div>
<div class="section" id="is-there-a-tool-to-help-find-bugs-or-perform-static-analysis">
<h3><a class="toc-backref" href="#id5">バグの発見や静的解析に役立つツールはありますか？</a><a class="headerlink" href="#is-there-a-tool-to-help-find-bugs-or-perform-static-analysis" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>はい。</p>
<p>PyChecker は Python ソースコードのバグを発見しコードの複雑さとスタイルについて警告する静的解析ツールです。PyChecker は <a class="reference external" href="http://pychecker.sourceforge.net/">http://pychecker.sourceforge.net/</a> から手に入ります。</p>
<p><a class="reference external" href="https://www.pylint.org/">Pylint</a> も、モジュールがコーディング標準を満たすかを調べ、プラグインを書いてカスタム機能を加えられるようにするツールです。PyChecker が行うバグチェックに加え、 Pylint は行の長さ、変数名が一貫しているか、宣言されたインタフェースが完全に実装されているか、などを確かめる追加の機能を提供します。 <a class="reference external" href="https://docs.pylint.org/">https://docs.pylint.org/</a> で Pylint の機能の一覧を見られます。</p>
<p><a class="reference external" href="http://mypy-lang.org/">Mypy</a>, <a class="reference external" href="https://pyre-check.org/">Pyre</a>, <a class="reference external" href="https://github.com/google/pytype">Pytype</a> などの静的型チェッカーは、 Python ソースコードにある型ヒントをチェックできます。</p>
</div>
<div class="section" id="how-can-i-create-a-stand-alone-binary-from-a-python-script">
<h3><a class="toc-backref" href="#id6">どうしたら Python スクリプトからスタンドアロンバイナリを作れますか？</a><a class="headerlink" href="#how-can-i-create-a-stand-alone-binary-from-a-python-script" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ユーザがダウンロードでき、Python ディストリビューションをインストールせずに実行できるようなスタンドアロンプログラムだけでいいなら、Python を C コードにコンパイルできなくても構いません。プログラムに対して必要なモジュールを選び、そのモジュールを Python バイナリに束縛して一つの実行可能ファイルにまとめる多くのツールがあります。</p>
<p>一つは freeze ツールで、Python ソースツリーに <code class="docutils literal notranslate"><span class="pre">Tools/freeze</span></code> として含まれています。これは Python バイトコードを C 配列に変換します。すべてのモジュールを新しいプログラムに埋め込む C コンパイラで、そのプログラムは Python モジュールにリンクされます。</p>
<p>これはあなたのソースの (両方の形式の) import 文を再帰的にスキャンし、import されたモジュールを標準の Python パスと (組み込みモジュールのある) ソースディレクトリから探します。そして Python で書かれたモジュールのバイトコードを C コード (marshal モジュールでコードオブジェクトに変換できる配列) に変換し、実際にそのプログラム内で使われている組み込みモジュールだけが含まれたカスタムメイドの設定ファイルを作成します。そして生成された C コードをコンパイルして Python インタプリタの残りとリンクし、元のスクリプトと全く同じように動作する自己完結的なバイナリを形成します。</p>
<p>もちろん、freeze には C コンパイラが必要です。C コンパイラを必要としない選択肢もあります。その一つは、Thomas Heller の py2exe (Windows 専用) です</p>
<blockquote>
<div><a class="reference external" href="http://www.py2exe.org/">http://www.py2exe.org/</a></div></blockquote>
<p>他には Anthony Tuininga の <a class="reference external" href="https://anthony-tuininga.github.io/cx_Freeze/">cx_Freeze</a> があります。</p>
</div>
<div class="section" id="are-there-coding-standards-or-a-style-guide-for-python-programs">
<h3><a class="toc-backref" href="#id7">Python プログラムのためのコーディングスタンダードやスタイルガイドはありますか？</a><a class="headerlink" href="#are-there-coding-standards-or-a-style-guide-for-python-programs" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>はい。標準ライブラリモジュールに求められるコーディングスタイルは <span class="target" id="index-7"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0008"><strong>PEP 8</strong></a> として文書化されています。</p>
</div>
</div>
<div class="section" id="core-language">
<h2><a class="toc-backref" href="#id8">コア言語</a><a class="headerlink" href="#core-language" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value">
<h3><a class="toc-backref" href="#id9">なぜ変数に値があるのに UnboundLocalError が出るのですか？</a><a class="headerlink" href="#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>もともと動いていたコードが、関数の本体のどこかに代入文を加えるという変更をしたら UnboundLocalError を出すのには驚くかもしれません。</p>
<p>このコード:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="p">()</span>
<span class="go">10</span>
</pre></div>
</div>
<p>は動きますが、このコード:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>は UnboundLocalError になります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">UnboundLocalError</span>: <span class="n">local variable &#39;x&#39; referenced before assignment</span>
</pre></div>
</div>
<p>これは、あるスコープの中で変数に代入を行うとき、その変数はそのスコープに対してローカルになり、外のスコープにある同じ名前の変数を隠すからです。foo の最後の文が <code class="docutils literal notranslate"><span class="pre">x</span></code> に新しい値を代入しているので、コンパイラはこれをローカル変数であると認識します。その結果、先の <code class="docutils literal notranslate"><span class="pre">print(x)</span></code> が初期化されていないローカル変数を表示しようとして結果はエラーとなります。</p>
<p>上の例では、グローバルであると宣言することで外のスコープにアクセスできます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foobar</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">global</span> <span class="n">x</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foobar</span><span class="p">()</span>
<span class="go">10</span>
</pre></div>
</div>
<p>この明示的な宣言は (表面的には似ているクラスとインスタンス変数の例とは違って) あなたは実際は他のスコープの変数の値を変えようとしているのだ、ということを知らせるのに必要です:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">11</span>
</pre></div>
</div>
<p>同様のことを、ネストされたスコープで <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 予約語を使うことでもできます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="gp">... </span>   <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">... </span>   <span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
<span class="gp">... </span>       <span class="k">nonlocal</span> <span class="n">x</span>
<span class="gp">... </span>       <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>       <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>   <span class="n">bar</span><span class="p">()</span>
<span class="gp">... </span>   <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">()</span>
<span class="go">10</span>
<span class="go">11</span>
</pre></div>
</div>
</div>
<div class="section" id="what-are-the-rules-for-local-and-global-variables-in-python">
<h3><a class="toc-backref" href="#id10">Python のローカルとグローバル変数のルールは何ですか？</a><a class="headerlink" href="#what-are-the-rules-for-local-and-global-variables-in-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python では、関数内で参照されるだけの変数は暗黙的にグローバルとなります。
関数の本体のどこかで値が変数に代入されたなら、それは明示的にグローバルであると宣言されない限り、ローカルであるとみなされます。</p>
<p>最初はちょっと驚くでしょうが、少し考えると納得できます。一方では、代入された変数に <a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> を要求することで、意図しない副作用を防げます。他方では、グローバルな参照の度に <code class="docutils literal notranslate"><span class="pre">global</span></code> が要求されてしまうと、 <code class="docutils literal notranslate"><span class="pre">global</span></code> を使ってばかりになってしまいます。ビルトイン関数やインポートされたモジュールの内容を参照するたびにグローバル宣言をしなければならないのです。その乱雑さは副作用を特定するための <code class="docutils literal notranslate"><span class="pre">global</span></code> 宣言の便利さよりも重大です。</p>
</div>
<div class="section" id="why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result">
<h3><a class="toc-backref" href="#id11">ループの中で異なる値で定義されたラムダ式が、同じ値を返すのはなぜですか？</a><a class="headerlink" href="#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>for ループを使って、少しずつ異なるラムダを定義 (もしくは簡単な関数) するとします。例えば:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">squares</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>これで <code class="docutils literal notranslate"><span class="pre">x**2</span></code> を計算する 5 つのラムダのリストが得られます。それらを呼び出したとき、それぞれ <code class="docutils literal notranslate"><span class="pre">0</span></code>、<code class="docutils literal notranslate"><span class="pre">1</span></code>、<code class="docutils literal notranslate"><span class="pre">4</span></code>、<code class="docutils literal notranslate"><span class="pre">9</span></code>、<code class="docutils literal notranslate"><span class="pre">16</span></code> を返すと予想するかもしれません。しかし実際にやってみると、全て <code class="docutils literal notranslate"><span class="pre">16</span></code> が返ってくるのを目にするでしょう:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">2</span><span class="p">]()</span>
<span class="go">16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">4</span><span class="p">]()</span>
<span class="go">16</span>
</pre></div>
</div>
<p>これは、<code class="docutils literal notranslate"><span class="pre">x</span></code> がラムダにとってのローカル変数ではなく外側のスコープで定義されていて、ラムダが定義されたときでなく呼び出されたときにアクセスされるために起こります。ループが終わった時点では <code class="docutils literal notranslate"><span class="pre">x</span></code> は <code class="docutils literal notranslate"><span class="pre">4</span></code> であり、従って、全ての関数は <code class="docutils literal notranslate"><span class="pre">4**2</span></code> つまり <code class="docutils literal notranslate"><span class="pre">16</span></code> を返します。このことは <code class="docutils literal notranslate"><span class="pre">x</span></code> の値を変えてみることで検証でき、ラムダの返り値がどのように変わるのか観察できます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">2</span><span class="p">]()</span>
<span class="go">64</span>
</pre></div>
</div>
<p>これを避けるためには、グローバルの <code class="docutils literal notranslate"><span class="pre">x</span></code> の値に依存しないために、ラムダにとってのローカル変数に値を保存する必要があります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">squares</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="o">=</span><span class="n">x</span><span class="p">:</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>ここで、<code class="docutils literal notranslate"><span class="pre">n=x</span></code> は新しいラムダにとってのローカル変数 <code class="docutils literal notranslate"><span class="pre">n</span></code> を作成し、ラムダが定義されるときに計算されるので、ループのその時点での <code class="docutils literal notranslate"><span class="pre">x</span></code> と同じ値を持っています。これは、1 つ目のラムダでは <code class="docutils literal notranslate"><span class="pre">n</span></code> の値は <code class="docutils literal notranslate"><span class="pre">0</span></code> になり、2 つ目では <code class="docutils literal notranslate"><span class="pre">1</span></code>、3 つ目では <code class="docutils literal notranslate"><span class="pre">2</span></code> 以下同様、となることを意味します。従って、それぞれのラムダは今や正しい値を返すようになりました:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">2</span><span class="p">]()</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">4</span><span class="p">]()</span>
<span class="go">16</span>
</pre></div>
</div>
<p>この動作はラムダに特有なものではなく、通常の関数にも適用されることに注意してください。</p>
</div>
<div class="section" id="how-do-i-share-global-variables-across-modules">
<h3><a class="toc-backref" href="#id12">グローバル変数をモジュール間で共有するにはどうしたらいいですか？</a><a class="headerlink" href="#how-do-i-share-global-variables-across-modules" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>一つのプログラムのモジュール間で情報を共有する正準な方法は、特別なモジュール (しばしば config や cfg と呼ばれる) を作ることです。単に設定モジュールをアプリケーションのすべてのモジュールにインポートしてください。このモジュールはグローバルな名前として使えます。それぞれのモジュールのただ一つのインスタンスがあるので、設定モジュールオブジェクトに対するいかなる変更も全体に反映されます。例えば:</p>
<p>config.py:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># Default value of the &#39;x&#39; configuration setting</span>
</pre></div>
</div>
<p>mod.py:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">config</span>
<span class="n">config</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>main.py:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">config</span>
<span class="kn">import</span> <span class="nn">mod</span>
<span class="nb">print</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>なお、同じ理由から、モジュールを使うということは、シングルトンデザインパターンを実装することの基礎でもあります。</p>
</div>
<div class="section" id="what-are-the-best-practices-for-using-import-in-a-module">
<h3><a class="toc-backref" href="#id13">モジュールで import を使う際の「ベストプラクティス」は何ですか？</a><a class="headerlink" href="#what-are-the-best-practices-for-using-import-in-a-module" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>一般的に <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">modulename</span> <span class="pre">import</span> <span class="pre">*</span></code> を使ってはいけません。そのようにするとインポータの名前空間は汚染され、linter が未定義の名前を発見することが難しくなります。</p>
<p>モジュールはファイルの先頭でインポートしてください。これによってコードが必要とする他のモジュールが明確になり、モジュール名がスコープに含まれるかどうかに迷わなくなります。行に一つのインポートにすると、モジュールのインポートの追加と削除が容易になりますが、行に複数のインポートにすると画面の領域が少なく済みます。</p>
<p>次の手順でモジュールをインポートするのが、良い習慣になります:</p>
<ol class="arabic simple">
<li>標準ライブラリモジュール -- 例 <code class="docutils literal notranslate"><span class="pre">sys</span></code>、<code class="docutils literal notranslate"><span class="pre">os</span></code>、<code class="docutils literal notranslate"><span class="pre">getopt</span></code>、<code class="docutils literal notranslate"><span class="pre">re</span></code></li>
<li>サードパーティのライブラリモジュール (Python の site-packages ディレクトリにあるもの) -- 例 mx.DateTime、ZODB、PIL.Image、など</li>
<li>自前で開発したモジュール</li>
</ol>
<p>循環参照の問題を避けるために、インポートを関数やクラスに移すことが必要なときもあります。Gordon McMillan によれば:</p>
<blockquote>
<div>循環参照は両方のモジュールが &quot;import &lt;module&gt;&quot; 形式のインポートを使っていれば大丈夫です。二つ目のモジュールが最初のモジュールから名前を確保しようとして (&quot;from module import name&quot;)、そのインポートがトップレベルにあると駄目です。最初のモジュールが二つ目のモジュールをインポートするのに忙しくて、最初のモジュールの名前が利用可能になっていないからです。</div></blockquote>
<p>この状況では、二つ目のモジュールが一つの関数の中でのみ使われているならば、そのインポートは簡単に関数の中に移せます。インポートが呼ばれたとき、最初のモジュールは初期化を完了していて、二つ目のモジュールは自分のインポートをできます。</p>
<p>プラットフォーム依存のモジュールがあるときには、インポートをトップレベルの外に動かすことも必要です。この場合、ファイルの先頭ではすべてのモジュールをインポートすることさえできないかもしれません。この場合は、対応するプラットフォームに合わせたコードで正しいモジュールをインポートすることを選ぶと良いです。</p>
<p>循環参照の問題を避けたりモジュールの初期化にかかる時間を減らしたりしたいなら、単にインポートを関数定義の中などのローカルなスコープに移してください。この手法は多くのインポートがプログラムがどのように実行されるかに依存しなくてよいときに特に有効です。ある関数の中でのみモジュールが使われるのなら、インポートをその関数の中に移すことを考えてもいいでしょう。なお、モジュールを読み込む最初の回はモジュールの初期化の時間のために高価になりえますが、複数回目にモジュールを読み込むのは事実上無料、辞書探索の数回のコストだけで済みます。モジュール名がスコープから外れてさえ、そのモジュールはおそらく <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> から利用できるでしょう。</p>
</div>
<div class="section" id="why-are-default-values-shared-between-objects">
<h3><a class="toc-backref" href="#id14">なぜオブジェクト間でデフォルト値が共有されるのですか？</a><a class="headerlink" href="#why-are-default-values-shared-between-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>この種のバグがよく初心者プログラマに噛み付きます。この関数を考えてみてください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">mydict</span><span class="o">=</span><span class="p">{}):</span>  <span class="c1"># Danger: shared reference to one dict for all calls</span>
    <span class="o">...</span> <span class="n">compute</span> <span class="n">something</span> <span class="o">...</span>
    <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">mydict</span>
</pre></div>
</div>
<p>初めてこの関数を呼び出した時、<code class="docutils literal notranslate"><span class="pre">mydict</span></code> には一つの要素があります。二回目には、<code class="docutils literal notranslate"><span class="pre">foo()</span></code> が実行されるときに <code class="docutils literal notranslate"><span class="pre">mydict</span></code> には初めから一つの要素をすでに持っているので、<code class="docutils literal notranslate"><span class="pre">mydict</span></code> には二つの要素があります。</p>
<p>関数の呼び出しによって、デフォルトの値に対する新しいオブジェクトが作られるのだと予想しがちです。実はそうなりません。デフォルト値は、関数が定義されたときに一度だけ生成されます。この例の辞書のように、そのオブジェクトが変更されたとき、その後の関数の呼び出しは変更後のオブジェクトを参照します。</p>
<p>定義の時に、数、文字列、タプル、<code class="docutils literal notranslate"><span class="pre">None</span></code> など、イミュータブルなオブジェクトを使うと変更される危険がありません。辞書、リスト、クラスインスタンスなどのミュータブルなオブジェクトは混乱のもとです。</p>
<p>この性質から、ミュータブルなオブジェクトをデフォルト値として使わないプログラミング手法がいいです。代わりに、<code class="docutils literal notranslate"><span class="pre">None</span></code> をデフォルト値に使い、そのパラメタが <code class="docutils literal notranslate"><span class="pre">None</span></code> である時にだけ、関数の内部で新しいリスト/辞書/その他をつくるようにしてください。例えば、こう書かずに:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">mydict</span><span class="o">=</span><span class="p">{}):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>代わりに:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">mydict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">mydict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mydict</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># create a new dict for local namespace</span>
</pre></div>
</div>
<p>この性質が便利なこともあります。時間のかかる計算を行う関数があるときに使われる一般的な技法は、関数が呼び出されるごとにパラメタと結果の値をキャッシュし、再び同じ値が要求されたらキャッシュされた値を返すというものです。これは &quot;memoizing&quot; と呼ばれ、このように実装されます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Callers can only provide two parameters and optionally pass _cache by keyword</span>
<span class="k">def</span> <span class="nf">expensive</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">_cache</span><span class="o">=</span><span class="p">{}):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">_cache</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_cache</span><span class="p">[(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)]</span>

    <span class="c1"># Calculate the value</span>
    <span class="n">result</span> <span class="o">=</span> <span class="o">...</span> <span class="n">expensive</span> <span class="n">computation</span> <span class="o">...</span>
    <span class="n">_cache</span><span class="p">[(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">result</span>           <span class="c1"># Store result in the cache</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>デフォルト値の代わりに、辞書を含むグローバル変数も使えます。これは好みの問題です。</p>
</div>
<div class="section" id="how-can-i-pass-optional-or-keyword-parameters-from-one-function-to-another">
<h3><a class="toc-backref" href="#id15">オプションパラメータやキーワードパラメータを関数から関数へ渡すにはどうしたらいいですか？</a><a class="headerlink" href="#how-can-i-pass-optional-or-keyword-parameters-from-one-function-to-another" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>関数のパラメータリストに引数を <code class="docutils literal notranslate"><span class="pre">*</span></code> と <code class="docutils literal notranslate"><span class="pre">**</span></code> 指定子 (specifier) で集めてください。そうすれば、位置引数をタプルとして、キーワード引数を辞書として得られます。これで、他の関数を呼び出すときに <code class="docutils literal notranslate"><span class="pre">*</span></code> と <code class="docutils literal notranslate"><span class="pre">**</span></code> を使ってそれらの引数を渡せます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;14.3c&#39;</span>
    <span class="o">...</span>
    <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="what-is-the-difference-between-arguments-and-parameters">
<span id="faq-argument-vs-parameter"></span><span id="index-1"></span><h3><a class="toc-backref" href="#id16">実引数と仮引数の違いは何ですか?</a><a class="headerlink" href="#what-is-the-difference-between-arguments-and-parameters" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">仮引数 (parameter)</span></a> は関数定義に表れる名前で定義されるのに対し、 <a class="reference internal" href="../glossary.html#term-argument"><span class="xref std std-term">実引数 (argument)</span></a> は関数を呼び出すときに実際に渡す値のことです。仮引数は関数が受け取ることの出来る実引数の型を定義します。例えば、以下のような関数定義があったとして:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p><em>foo</em>、<em>bar</em>、<em>kwargs</em> は <code class="docutils literal notranslate"><span class="pre">func</span></code> の仮引数です。一方、<code class="docutils literal notranslate"><span class="pre">func</span></code> を呼び出すときには、例えば:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">func</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="mi">314</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="n">somevar</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">42</span></code>、<code class="docutils literal notranslate"><span class="pre">314</span></code>、<code class="docutils literal notranslate"><span class="pre">somevar</span></code> という値は実引数です。</p>
</div>
<div class="section" id="why-did-changing-list-y-also-change-list-x">
<h3><a class="toc-backref" href="#id17">なぜ list 'y' を変更すると list 'x' も変更されるのですか?</a><a class="headerlink" href="#why-did-changing-list-y-also-change-list-x" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>次のようなコードを書いたとします:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">[10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">[10]</span>
</pre></div>
</div>
<p>どうして <code class="docutils literal notranslate"><span class="pre">y</span></code> への要素の追加が <code class="docutils literal notranslate"><span class="pre">x</span></code> も変更してしまうのか疑問に思うかもしれません。</p>
<p>このような結果になる2つの要因があります:</p>
<ol class="arabic simple">
<li>変数とは、単にオブジェクトを参照するための名前に過ぎません。 <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">x</span></code> とすることは、リストのコピーを作りません -- それは <code class="docutils literal notranslate"><span class="pre">x</span></code> が参照するのと同じオブジェクトを参照する新しい変数 <code class="docutils literal notranslate"><span class="pre">y</span></code> を作ります。つまり、あるのは一つのオブジェクト(この場合リスト)だけであって、 <code class="docutils literal notranslate"><span class="pre">x</span></code> と <code class="docutils literal notranslate"><span class="pre">y</span></code> の両方がそれを参照しているのです。</li>
<li>リストは <a class="reference internal" href="../glossary.html#term-mutable"><span class="xref std std-term">mutable</span></a> です。内容を変更出来る、ということです。</li>
</ol>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code> 呼び出しの後、ミュータブルオブジェクトの内容が <code class="docutils literal notranslate"><span class="pre">[]</span></code> から <code class="docutils literal notranslate"><span class="pre">[10]</span></code> に変わります。 変数が同じオブジェクトを参照しているので、どちらの名前であっても変更された値 <code class="docutils literal notranslate"><span class="pre">[10]</span></code> にアクセスします。</p>
<p>代わりに <code class="docutils literal notranslate"><span class="pre">x</span></code> にイミュータブルを代入すると:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># ints are immutable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># 5 can&#39;t be mutated, we are creating a new object here</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">5</span>
</pre></div>
</div>
<p>この場合ご覧の通り <code class="docutils literal notranslate"><span class="pre">x</span></code> と <code class="docutils literal notranslate"><span class="pre">y</span></code> はまったく同じではありませんね。これは整数が <a class="reference internal" href="../glossary.html#term-immutable"><span class="xref std std-term">immutable</span></a> だからで、 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code> は整数の <code class="docutils literal notranslate"><span class="pre">5</span></code> の値を変更しているのではありません; 代わりに新しいオブジェクト(整数 <code class="docutils literal notranslate"><span class="pre">6</span></code>)を作って <code class="docutils literal notranslate"><span class="pre">x</span></code> に代入しています (つまり <code class="docutils literal notranslate"><span class="pre">x</span></code> が参照するオブジェクトが変わります)。この代入の後では私たちは 2 つのオブジェクト(整数の <code class="docutils literal notranslate"><span class="pre">6</span></code> と <code class="docutils literal notranslate"><span class="pre">5</span></code>)を持っていて、2 つの変数はそれらを参照しています(<code class="docutils literal notranslate"><span class="pre">x</span></code> はいまや <code class="docutils literal notranslate"><span class="pre">6</span></code> を参照していますが <code class="docutils literal notranslate"><span class="pre">y</span></code> は <code class="docutils literal notranslate"><span class="pre">5</span></code> を参照したままです)。</p>
<p>ある演算 (たとえば <code class="docutils literal notranslate"><span class="pre">y.append(10)</span></code>, <code class="docutils literal notranslate"><span class="pre">y.sort()</span></code>) がオブジェクトを変更する一方で、外見上は似た演算 (たとえば <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">[10]</span></code>, <code class="docutils literal notranslate"><span class="pre">sorted(y)</span></code>) は新しいオブジェクトを作ります。Python では一般に (そして標準ライブラリの全てのケースで)、このような 2 つのタイプの演算にまつわる混乱を避けるために、オブジェクトを変更するメソッドは <code class="docutils literal notranslate"><span class="pre">None</span></code> を返します。ですからもしあなたが誤って <code class="docutils literal notranslate"><span class="pre">y</span></code> の複製の並び替えをするつもりで <code class="docutils literal notranslate"><span class="pre">y.sort()</span></code> と書いた場合に結果手にするのは <code class="docutils literal notranslate"><span class="pre">None</span></code> でしょうから、あなたのプログラムは簡単に診断出来るエラーを起こすでしょう。</p>
<p>しかしながら、同じ操作が型ごとに異なる振る舞いをする演算の種類が一つあります: 累算代入演算です。例えば <code class="docutils literal notranslate"><span class="pre">+=</span></code> はリストを変更しますが、タプルや整数は変更しません(<code class="docutils literal notranslate"><span class="pre">a_list</span> <span class="pre">+=</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code> は <code class="docutils literal notranslate"><span class="pre">a_list.extend([1,</span> <span class="pre">2,</span> <span class="pre">3])</span></code> と同じ意味で、そして <code class="docutils literal notranslate"><span class="pre">a_list</span></code> を変更しますが、 <code class="docutils literal notranslate"><span class="pre">some_tuple</span> <span class="pre">+=</span> <span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3)</span></code> と <code class="docutils literal notranslate"><span class="pre">some_int</span> <span class="pre">+=</span> <span class="pre">1</span></code> は新しいオブジェクトを作ります)。</p>
<p>言い換えると:</p>
<ul class="simple">
<li>ミュータブルなオブジェクト(<a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>, 等)を持っている場合、私たちはその内容を変更するある種の演算を使うことが出来、それを参照している全ての変数はその変化を見ることになるでしょう。</li>
<li>イミュータブルなオブジェクト(<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, 等)を持っている場合、それを参照している全ての変数は同じ値を参照しているでしょうが、持っている値を新しい値に変換する演算はいつでも新しいオブジェクトを返します。</li>
</ul>
<p>2つの変数が同じオブジェクトを参照しているかどうかが知りたければ、 <a class="reference internal" href="../reference/expressions.html#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> 演算子や組み込み関数 <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> が使えます。</p>
</div>
<div class="section" id="how-do-i-write-a-function-with-output-parameters-call-by-reference">
<h3><a class="toc-backref" href="#id18">出力引数のある関数 (参照渡し) はどのように書きますか？</a><a class="headerlink" href="#how-do-i-write-a-function-with-output-parameters-call-by-reference" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>前提として、Python では引数は代入によって渡されます。代入はオブジェクトへの参照を作るだけなので、呼び出し元と呼び出し先にある引数名の間にエイリアスはありませんし、参照渡しそれ自体はありません。望む効果を得るためには幾つかの方法があります。</p>
<ol class="arabic">
<li><p class="first">結果のタプルを返すことによって:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="s1">&#39;new-value&#39;</span>        <span class="c1"># a and b are local names</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span>              <span class="c1"># assigned to new objects</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>            <span class="c1"># return new values</span>

<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="s1">&#39;old-value&#39;</span><span class="p">,</span> <span class="mi">99</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">func2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>                <span class="c1"># output: new-value 100</span>
</pre></div>
</div>
<p>これはたいてい一番明確な方法です。</p>
</li>
<li><p class="first">グローバル変数を使って。これはスレッドセーフでないので、推奨されません。</p>
</li>
<li><p class="first">ミュータブルな (インプレースに変更可能な) オブジェクトを渡すことによって:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func1</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;new-value&#39;</span>     <span class="c1"># &#39;a&#39; references a mutable list</span>
    <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>        <span class="c1"># changes a shared object</span>

<span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;old-value&#39;</span><span class="p">,</span> <span class="mi">99</span><span class="p">]</span>
<span class="n">func1</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>    <span class="c1"># output: new-value 100</span>
</pre></div>
</div>
</li>
<li><p class="first">変更される辞書に渡すことによって:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func3</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="n">args</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;new-value&#39;</span>     <span class="c1"># args is a mutable dictionary</span>
    <span class="n">args</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>   <span class="c1"># change it in-place</span>

<span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;old-value&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">99</span><span class="p">}</span>
<span class="n">func3</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
</pre></div>
</div>
</li>
<li><p class="first">または、クラスインスタンスに値を同梱することによって:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">callByRef</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">func4</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="n">args</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="s1">&#39;new-value&#39;</span>        <span class="c1"># args is a mutable callByRef</span>
    <span class="n">args</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span>         <span class="c1"># change object in-place</span>

<span class="n">args</span> <span class="o">=</span> <span class="n">callByRef</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="s1">&#39;old-value&#39;</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">99</span><span class="p">)</span>
<span class="n">func4</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>このような複雑なことをする理由はめったに無いでしょう。</p>
</li>
</ol>
<p>一番の選択は、複数の結果を含むタプルを返すことです。</p>
</div>
<div class="section" id="how-do-you-make-a-higher-order-function-in-python">
<h3><a class="toc-backref" href="#id19">Python で高次関数はどのようにつくりますか？</a><a class="headerlink" href="#how-do-you-make-a-higher-order-function-in-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>二つの方法があります: ネストされたスコープを使う方法と、呼び出し可能オブジェクトを使う方法です。例えば、<code class="docutils literal notranslate"><span class="pre">a*x+b</span></code> の値を計算する <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> 関数を返す <code class="docutils literal notranslate"><span class="pre">linear(a,b)</span></code> を定義したいとします。ネストされたスコープを使うと:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">linear</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">result</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>また、呼び出し可能オブジェクトを使うと:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">linear</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span>
</pre></div>
</div>
<p>どちらの場合でも、</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">taxes</span> <span class="o">=</span> <span class="n">linear</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>とすれば、<code class="docutils literal notranslate"><span class="pre">taxes(10e6)</span> <span class="pre">==</span> <span class="pre">0.3</span> <span class="pre">*</span> <span class="pre">10e6</span> <span class="pre">+</span> <span class="pre">2</span></code> となるような呼び出し可能オブジェクトを得られます。</p>
<p>呼び出し可能オブジェクトを使う方法は、少し遅くなり、わずかにコードが長くなるという短所があります。ですが、継承を使って呼び出し可能オブジェクト同士で記号を共有することもできます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">exponential</span><span class="p">(</span><span class="n">linear</span><span class="p">):</span>
    <span class="c1"># __init__ inherited</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>オブジェクトはいくつかのメソッドに状態をカプセル化できます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">counter</span><span class="p">:</span>

    <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">up</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">down</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="mi">1</span>

<span class="n">count</span> <span class="o">=</span> <span class="n">counter</span><span class="p">()</span>
<span class="n">inc</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">reset</span> <span class="o">=</span> <span class="n">count</span><span class="o">.</span><span class="n">up</span><span class="p">,</span> <span class="n">count</span><span class="o">.</span><span class="n">down</span><span class="p">,</span> <span class="n">count</span><span class="o">.</span><span class="n">set</span>
</pre></div>
</div>
<p>ここで、<code class="docutils literal notranslate"><span class="pre">inc()</span></code>、<code class="docutils literal notranslate"><span class="pre">dec()</span></code>、<code class="docutils literal notranslate"><span class="pre">reset()</span></code> は同じカウント変数を共有する関数のようにふるまいます。</p>
</div>
<div class="section" id="how-do-i-copy-an-object-in-python">
<h3><a class="toc-backref" href="#id20">Python のオブジェクトはどのようにコピーしますか？</a><a class="headerlink" href="#how-do-i-copy-an-object-in-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>一般的に、普通は <a class="reference internal" href="../library/copy.html#copy.copy" title="copy.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.copy()</span></code></a> や <a class="reference internal" href="../library/copy.html#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code></a> を試してください。何でもコピーできるとは限りませんが、たいていはできます。</p>
<p>もっと簡単にコピーできるオブジェクトもあります。辞書には <a class="reference internal" href="../library/stdtypes.html#dict.copy" title="dict.copy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code></a> メソッドがあります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">newdict</span> <span class="o">=</span> <span class="n">olddict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
<p>シーケンスはスライシングでコピーできます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">new_l</span> <span class="o">=</span> <span class="n">l</span><span class="p">[:]</span>
</pre></div>
</div>
</div>
<div class="section" id="how-can-i-find-the-methods-or-attributes-of-an-object">
<h3><a class="toc-backref" href="#id21">オブジェクトのメソッドや属性はどのように見つけますか？</a><a class="headerlink" href="#how-can-i-find-the-methods-or-attributes-of-an-object" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ユーザー定義クラスのインスタンス x で、<code class="docutils literal notranslate"><span class="pre">dir(x)</span></code> はインスタンス属性とそのクラスで定義されたメソッドや属性を含む名前のアルファベット順リストを返します。</p>
</div>
<div class="section" id="how-can-my-code-discover-the-name-of-an-object">
<h3><a class="toc-backref" href="#id22">コードはどのようにオブジェクトの名前を見つけるのですか？</a><a class="headerlink" href="#how-can-my-code-discover-the-name-of-an-object" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>概して、オブジェクトは本当は名前を持たないので、見つけることはできません。本質的には、代入とはいつも値に名前を束縛することです。<code class="docutils literal notranslate"><span class="pre">def</span></code> と <code class="docutils literal notranslate"><span class="pre">class</span></code> 文も同じですが、この場合は値はコーラブルです。以下のコードを考えてみましょう:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">&lt;__main__.A object at 0x16D07CC&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&lt;__main__.A object at 0x16D07CC&gt;</span>
</pre></div>
</div>
<p>おそらく、このクラスには名前があります。このクラスは二つの名前に縛られて、名前 B を通して呼び出されますが、それでもクラス A のインスタンスとして報告されるのです。しかし、両方の名前が同じ値に束縛されている以上、このインスタンスの名前が a か b か決めることはできないのです。</p>
<p>概して、コードにとってある値の「名前を知っている」事は重要ではありません。あなたがわざと内省的なコードを書いているのでない限り、方針を変えた方がいいかもしれないということになるでしょう。</p>
<p>comp.lang.python で、Fredrik Lundh はこの問題の答えとして素晴らしい喩えをしてくれました:</p>
<blockquote>
<div><p>玄関にいた猫の名前を知るのと同じ方法です: その猫 (オブジェクト) 自体はその名前を言うことができないし、それは実は問題ではありません -- その猫が何と呼ばれているかを知る唯一の方法は、すべての隣人 (名前空間) にその猫 (オブジェクト) が何と呼ばれているかを聞くことです。</p>
<p>……そして、その猫が沢山の名前で知られていたり、逆に全く名前が無かったりしても驚かないでください！</p>
</div></blockquote>
</div>
<div class="section" id="what-s-up-with-the-comma-operator-s-precedence">
<h3><a class="toc-backref" href="#id23">カンマ演算子はなぜ優先されるのですか？</a><a class="headerlink" href="#what-s-up-with-the-comma-operator-s-precedence" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>カンマは Python では演算子ではありません。このセッションを考えてください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;a&quot;</span> <span class="ow">in</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span>
<span class="go">(False, &#39;a&#39;)</span>
</pre></div>
</div>
<p>カンマは演算子ではなく、式の分離子なので、上の式は次の式と同じように評価されます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="s2">&quot;a&quot;</span> <span class="ow">in</span> <span class="s2">&quot;b&quot;</span><span class="p">),</span> <span class="s2">&quot;a&quot;</span>
</pre></div>
</div>
<p>こうではありません:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;a&quot;</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>他のさまざまな演算子(<code class="docutils literal notranslate"><span class="pre">=</span></code>、<code class="docutils literal notranslate"><span class="pre">+=</span></code> など)も同じです。これらは真の演算子ではありませんが、代入文の構文上のデリミタです。</p>
</div>
<div class="section" id="is-there-an-equivalent-of-c-s-ternary-operator">
<h3><a class="toc-backref" href="#id24">C の &quot;?:&quot; 三項演算子と等価なものはありますか？</a><a class="headerlink" href="#is-there-an-equivalent-of-c-s-ternary-operator" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>はい、あります。構文は以下のようになります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">on_true</span><span class="p">]</span> <span class="k">if</span> <span class="p">[</span><span class="n">expression</span><span class="p">]</span> <span class="k">else</span> <span class="p">[</span><span class="n">on_false</span><span class="p">]</span>

<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">25</span>
<span class="n">small</span> <span class="o">=</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">else</span> <span class="n">y</span>
</pre></div>
</div>
<p>この構文が導入された 2.5 以前のバージョンに関しては、論理演算子を使ったこのイディオムが一般的でした:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">expression</span><span class="p">]</span> <span class="ow">and</span> <span class="p">[</span><span class="n">on_true</span><span class="p">]</span> <span class="ow">or</span> <span class="p">[</span><span class="n">on_false</span><span class="p">]</span>
</pre></div>
</div>
<p>しかし、このイディオムは安全ではありません。<em>on_true</em> のブール値が偽であるときに間違った結果を与えることがあります。ですから、いつでも <code class="docutils literal notranslate"><span class="pre">...</span> <span class="pre">if</span> <span class="pre">...</span> <span class="pre">else</span> <span class="pre">...</span></code> 形式を使ったほうが良いです。</p>
</div>
<div class="section" id="is-it-possible-to-write-obfuscated-one-liners-in-python">
<h3><a class="toc-backref" href="#id25">Python で解し難いワンライナーを書くことはできますか？</a><a class="headerlink" href="#is-it-possible-to-write-obfuscated-one-liners-in-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>はい。そういうものはたいてい、 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code> の中に <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> がネストされています。Ulf Bartelt による下の３つの例を見てください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>

<span class="c1"># Primes &lt; 1000</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span><span class="n">y</span><span class="o">*</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">!=</span><span class="mi">0</span><span class="p">,</span>
<span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">:</span><span class="n">y</span><span class="o">%</span><span class="n">x</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))),</span><span class="mi">1</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1000</span><span class="p">)))))</span>

<span class="c1"># First 10 Fibonacci numbers</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">f</span><span class="p">:(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">f</span><span class="p">)</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">f</span><span class="p">))</span> <span class="k">if</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span><span class="p">:</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">f</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))))</span>

<span class="c1"># Mandelbrot set</span>
<span class="nb">print</span><span class="p">((</span><span class="k">lambda</span> <span class="n">Ru</span><span class="p">,</span><span class="n">Ro</span><span class="p">,</span><span class="n">Iu</span><span class="p">,</span><span class="n">Io</span><span class="p">,</span><span class="n">IM</span><span class="p">,</span><span class="n">Sx</span><span class="p">,</span><span class="n">Sy</span><span class="p">:</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">,</span>
<span class="n">Iu</span><span class="o">=</span><span class="n">Iu</span><span class="p">,</span><span class="n">Io</span><span class="o">=</span><span class="n">Io</span><span class="p">,</span><span class="n">Ru</span><span class="o">=</span><span class="n">Ru</span><span class="p">,</span><span class="n">Ro</span><span class="o">=</span><span class="n">Ro</span><span class="p">,</span><span class="n">Sy</span><span class="o">=</span><span class="n">Sy</span><span class="p">,</span><span class="n">L</span><span class="o">=</span><span class="k">lambda</span> <span class="n">yc</span><span class="p">,</span><span class="n">Iu</span><span class="o">=</span><span class="n">Iu</span><span class="p">,</span><span class="n">Io</span><span class="o">=</span><span class="n">Io</span><span class="p">,</span><span class="n">Ru</span><span class="o">=</span><span class="n">Ru</span><span class="p">,</span><span class="n">Ro</span><span class="o">=</span><span class="n">Ro</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="n">IM</span><span class="p">,</span>
<span class="n">Sx</span><span class="o">=</span><span class="n">Sx</span><span class="p">,</span><span class="n">Sy</span><span class="o">=</span><span class="n">Sy</span><span class="p">:</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">xc</span><span class="o">=</span><span class="n">Ru</span><span class="p">,</span><span class="n">yc</span><span class="o">=</span><span class="n">yc</span><span class="p">,</span><span class="n">Ru</span><span class="o">=</span><span class="n">Ru</span><span class="p">,</span><span class="n">Ro</span><span class="o">=</span><span class="n">Ro</span><span class="p">,</span>
<span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span><span class="n">Sx</span><span class="o">=</span><span class="n">Sx</span><span class="p">,</span><span class="n">F</span><span class="o">=</span><span class="k">lambda</span> <span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="k">lambda</span> <span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">f</span><span class="p">:(</span><span class="n">k</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span><span class="ow">or</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span>
<span class="o">&gt;=</span><span class="mf">4.0</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">1</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">xc</span><span class="p">,</span><span class="mf">2.0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">yc</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">f</span><span class="p">):</span><span class="n">f</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">f</span><span class="p">):</span><span class="nb">chr</span><span class="p">(</span>
<span class="mi">64</span><span class="o">+</span><span class="n">F</span><span class="p">(</span><span class="n">Ru</span><span class="o">+</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">Ro</span><span class="o">-</span><span class="n">Ru</span><span class="p">)</span><span class="o">/</span><span class="n">Sx</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">)),</span><span class="nb">range</span><span class="p">(</span><span class="n">Sx</span><span class="p">))):</span><span class="n">L</span><span class="p">(</span><span class="n">Iu</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="n">Io</span><span class="o">-</span><span class="n">Iu</span><span class="p">)</span><span class="o">/</span><span class="n">Sy</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">Sy</span>
<span class="p">))))(</span><span class="o">-</span><span class="mf">2.1</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">24</span><span class="p">))</span>
<span class="c1">#    \___ ___/  \___ ___/  |   |   |__ lines on screen</span>
<span class="c1">#        V          V      |   |______ columns on screen</span>
<span class="c1">#        |          |      |__________ maximum of &quot;iterations&quot;</span>
<span class="c1">#        |          |_________________ range on y axis</span>
<span class="c1">#        |____________________________ range on x axis</span>
</pre></div>
</div>
<p>よい子はまねしないでね！</p>
</div>
<div class="section" id="what-does-the-slash-in-the-parameter-list-of-a-function-mean">
<span id="faq-positional-only-arguments"></span><h3><a class="toc-backref" href="#id26">関数の引数リストにあるスラッシュ (/) は何を意味しますか？</a><a class="headerlink" href="#what-does-the-slash-in-the-parameter-list-of-a-function-mean" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>パラメータ関数の仮引数にあるスラッシュは、それより前にある仮引数は位置専用引数であることを示します。
位置専用引数は、外で使える名前を持たない仮引数です。
位置専用引数を受け付ける関数の呼び出しにおいて、実引数はその位置だけに基づいて仮引数に対応付けられます。
例えば、 <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a> は位置専用引数を受け付けます。
そのドキュメントは次のようになります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="nb">divmod</span><span class="p">)</span>
<span class="go">Help on built-in function divmod in module builtins:</span>

<span class="go">divmod(x, y, /)</span>
<span class="go">    Return the tuple (x//y, x%y).  Invariant: div*y + mod == x.</span>
</pre></div>
</div>
<p>この引数リストの末尾にスラッシュは、この2つの仮引数が両方とも位置専用引数であることを意味します。
したがって、<a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a> をキーワード引数を使って呼び出すとエラーになります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">divmod</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">divmod() takes no keyword arguments</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="numbers-and-strings">
<h2><a class="toc-backref" href="#id27">数と文字列</a><a class="headerlink" href="#numbers-and-strings" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="how-do-i-specify-hexadecimal-and-octal-integers">
<h3><a class="toc-backref" href="#id28">十六進数や八進数を指定するにはどうしたらいいですか？</a><a class="headerlink" href="#how-do-i-specify-hexadecimal-and-octal-integers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>八進数を指定するには、八進数での値の先頭に 0 と &quot;o&quot; (小文字または大文字) を加えてください。たとえば、変数 &quot;a&quot; に八進数での &quot;10&quot; (十進数での&quot;8&quot;) を代入するには、こう打ってください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mo">0o10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">8</span>
</pre></div>
</div>
<p>十六進数も簡単です。ただ十六進数での値の先頭に 0 と &quot;x&quot; (小文字または大文字) を加えてください。十六進数は小文字でも大文字でも指定できます。たとえば、Python インタプリタで:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mh">0xa5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">165</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mh">0XB2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">178</span>
</pre></div>
</div>
</div>
<div class="section" id="why-does-22-10-return-3">
<h3><a class="toc-backref" href="#id29">なぜ -22 // 10 は -3 を返すのですか？</a><a class="headerlink" href="#why-does-22-10-return-3" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">%</span> <span class="pre">j</span></code> が <code class="docutils literal notranslate"><span class="pre">j</span></code> と同じ符号であってほしいことに基づいています。それに加えて以下のようにもしたいとすると:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="n">i</span> <span class="o">//</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
<p>整数除算は床を返すことになります。C にも C の一貫性があって、<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">%</span> <span class="pre">j</span></code> が <code class="docutils literal notranslate"><span class="pre">i</span></code> と同じ符号を持つように <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">//</span> <span class="pre">j</span></code> を丸めています。</p>
<p><code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">%</span> <span class="pre">j</span></code> は、<code class="docutils literal notranslate"><span class="pre">j</span></code> が負の時には実際にはほとんど使いません。<code class="docutils literal notranslate"><span class="pre">j</span></code> が正なら、たくさん使います。その事実上すべての場合、<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">%</span> <span class="pre">j</span></code> は <code class="docutils literal notranslate"><span class="pre">&gt;=</span> <span class="pre">0</span></code> となる方が便利です。時計が 10 時を指している時、その 200 時間前は何時でしょうか。<code class="docutils literal notranslate"><span class="pre">-190</span> <span class="pre">%</span> <span class="pre">12</span> <span class="pre">==</span> <span class="pre">2</span></code> となるのが便利です。<code class="docutils literal notranslate"><span class="pre">-190</span> <span class="pre">%</span> <span class="pre">12</span> <span class="pre">==</span> <span class="pre">-10</span></code> は噛み付きかねないバグです。</p>
</div>
<div class="section" id="how-do-i-convert-a-string-to-a-number">
<h3><a class="toc-backref" href="#id30">文字列を数に変換するにはどうしたらいいですか？</a><a class="headerlink" href="#how-do-i-convert-a-string-to-a-number" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>整数に変換するには、組み込みの <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> 型コンストラクタを使ってください。例えば、 <code class="docutils literal notranslate"><span class="pre">int('144')</span> <span class="pre">==</span> <span class="pre">144</span></code> です。同様に、 <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a> は浮動小数点に変換します。例えば、 <code class="docutils literal notranslate"><span class="pre">float('144')</span> <span class="pre">==</span> <span class="pre">144.0</span></code> です。</p>
<p>デフォルトでは、これらは数を十進数として解釈するので、 <code class="docutils literal notranslate"><span class="pre">int('0144')</span> <span class="pre">==</span> <span class="pre">144</span></code> や <code class="docutils literal notranslate"><span class="pre">int('0x144')</span></code> は <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> を送出します。 <code class="docutils literal notranslate"><span class="pre">int(string,</span> <span class="pre">base)</span></code> はオプションの第二引数をとって変換元の基数にします。つまり <code class="docutils literal notranslate"><span class="pre">int('0x144',</span> <span class="pre">16)</span> <span class="pre">==</span> <span class="pre">324</span></code> です。基数が 0 と指定された場合、その数は Python の基準によって解釈されます。先頭が '0o' なら八進数で、'0x' なら十六進数を表します。</p>
<p>文字列を数に変換するだけのために <a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> を使わないでください。 <a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> は特に遅いですし、セキュリティ上のリスクもあります。求められない副作用を持つような Python の式を渡そうとする人がいるかも知れません。例えば、あなたのホームディレクトリを消去する <code class="docutils literal notranslate"><span class="pre">__import__('os').system(&quot;rm</span> <span class="pre">-rf</span> <span class="pre">$HOME&quot;)</span></code> を渡そうとする人がいるかも知れません。</p>
<p><a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> にも数を Python の式として解釈する機能があります。だから例えば、 <code class="docutils literal notranslate"><span class="pre">eval('09')</span></code> は構文エラー起こします。Python は ('0' 以外の) 十進数を '0' で始めてはならないからです。</p>
</div>
<div class="section" id="how-do-i-convert-a-number-to-a-string">
<h3><a class="toc-backref" href="#id31">数を文字列に変換するにはどうしたらいいですか？</a><a class="headerlink" href="#how-do-i-convert-a-number-to-a-string" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>例えば、144 という数を '144' という文字列に変換したいなら、組み込み型のコンストラクタ <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> を使ってください。
十六進数や八進数にしたければ、組み込み関数の <a class="reference internal" href="../library/functions.html#hex" title="hex"><code class="xref py py-func docutils literal notranslate"><span class="pre">hex()</span></code></a> や <a class="reference internal" href="../library/functions.html#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a> を使ってください。
手の込んだフォーマット形式を使うなら、 <a class="reference internal" href="../reference/lexical_analysis.html#f-strings"><span class="std std-ref">フォーマット済み文字列リテラル</span></a> と <a class="reference internal" href="../library/string.html#formatstrings"><span class="std std-ref">書式指定文字列の文法</span></a> の節を参照してください。
例えば、 <code class="docutils literal notranslate"><span class="pre">&quot;{:04d}&quot;.format(144)</span></code> は <code class="docutils literal notranslate"><span class="pre">'0144'</span></code> になり、 <code class="docutils literal notranslate"><span class="pre">&quot;{:.3f}&quot;.format(1.0/3.0)</span></code> は <code class="docutils literal notranslate"><span class="pre">'0.333'</span></code> になります。</p>
</div>
<div class="section" id="how-do-i-modify-a-string-in-place">
<h3><a class="toc-backref" href="#id32">文字列をインプレースに変更するにはどうしたらいいですか？</a><a class="headerlink" href="#how-do-i-modify-a-string-in-place" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>文字列はイミュータブルなので、それはできません。殆どの場合、組み立てたい個別の部品から単純に新しい文字列を構成するべきです。しかし、Unicode データをインプレースに変更できるオブジェクトが必要なら、 <a class="reference internal" href="../library/array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a> モジュールの <a class="reference internal" href="../library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a> オブジェクトを試してください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">io</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Hello, world&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sio</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sio</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
<span class="go">&#39;Hello, world&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sio</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;there!&quot;</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sio</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
<span class="go">&#39;Hello, there!&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array(&#39;u&#39;, &#39;Hello, world&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array(&#39;u&#39;, &#39;yello, world&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">tounicode</span><span class="p">()</span>
<span class="go">&#39;yello, world&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="how-do-i-use-strings-to-call-functions-methods">
<h3><a class="toc-backref" href="#id33">関数やメソッドを呼ぶのに文字列を使うにはどうしたらいいですか？</a><a class="headerlink" href="#how-do-i-use-strings-to-call-functions-methods" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>様々なテクニックがあります。</p>
<ul>
<li><p class="first">一番いいのは、文字列を関数に対応させる辞書を使うことです。このテクニックの一番の利点は、文字列が関数の名前と同じ必要がないことです。この方法は case 構造をエミュレートするための一番のテクニックでもあります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">a</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">b</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="n">dispatch</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;go&#39;</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="s1">&#39;stop&#39;</span><span class="p">:</span> <span class="n">b</span><span class="p">}</span>  <span class="c1"># Note lack of parens for funcs</span>

<span class="n">dispatch</span><span class="p">[</span><span class="n">get_input</span><span class="p">()]()</span>  <span class="c1"># Note trailing parens to call function</span>
</pre></div>
</div>
</li>
<li><p class="first">組み込み関数の <a class="reference internal" href="../library/functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> を使う方法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">foo</span>
<span class="nb">getattr</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">)()</span>
</pre></div>
</div>
<p>なお、 <a class="reference internal" href="../library/functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> はクラス、クラスインスタンス、モジュールなど、どんなオブジェクトにも使えます。</p>
<p>これは標準ライブラリでも何箇所か使われています。このように:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">do_foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">do_bar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

<span class="n">f</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">foo_instance</span><span class="p">,</span> <span class="s1">&#39;do_&#39;</span> <span class="o">+</span> <span class="n">opname</span><span class="p">)</span>
<span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
</li>
<li><p class="first"><a class="reference internal" href="../library/functions.html#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> や <a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> を使って関数名を決める方法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">myFunc</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>

<span class="n">fname</span> <span class="o">=</span> <span class="s2">&quot;myFunc&quot;</span>

<span class="n">f</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">fname</span><span class="p">]</span>
<span class="n">f</span><span class="p">()</span>

<span class="n">f</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
<span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
<p>ノート: <a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> の使用は遅いし危険です。もしあなたが文字列の内容を絶対的に支配できなければ、任意の関数を実行されるようにする文字列を渡す人がいるかも知れません。</p>
</li>
</ul>
</div>
<div class="section" id="is-there-an-equivalent-to-perl-s-chomp-for-removing-trailing-newlines-from-strings">
<h3><a class="toc-backref" href="#id34">文字列から後端の改行を取り除く Perl の chomp() に相当するものはありますか？</a><a class="headerlink" href="#is-there-an-equivalent-to-perl-s-chomp-for-removing-trailing-newlines-from-strings" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">S.rstrip(&quot;\r\n&quot;)</span></code> を使って文字列 <code class="docutils literal notranslate"><span class="pre">S</span></code> の終端から他の空白文字を取り除くことなくすべての行末記号を取り除くことができます。文字列 <code class="docutils literal notranslate"><span class="pre">S</span></code> が複数行を表し、終端に空行があるとき、そのすべての空行も取り除かれます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lines</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;line 1 </span><span class="se">\r\n</span><span class="s2">&quot;</span>
<span class="gp">... </span>         <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span>
<span class="gp">... </span>         <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lines</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\r</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">&#39;line 1 &#39;</span>
</pre></div>
</div>
<p>これは典型的に一度に一行ずつテキストを読みたい時にのみ使われるので、<code class="docutils literal notranslate"><span class="pre">S.rstrip()</span></code> をこの方法で使うとうまくいきます。</p>
</div>
<div class="section" id="is-there-a-scanf-or-sscanf-equivalent">
<h3><a class="toc-backref" href="#id35">scanf() や sscanf() と同等なものはありますか？</a><a class="headerlink" href="#is-there-a-scanf-or-sscanf-equivalent" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>そのようなものはありません。</p>
<p>簡単な入力解析で、多くの場合に一番簡単な方法は、文字列オブジェクトの <a class="reference internal" href="../library/stdtypes.html#str.split" title="str.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a> メソッドで行を空白文字で区切られた単語に分け、十進数の文字列を <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> や <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a> で数値に変換することです。 <code class="docutils literal notranslate"><span class="pre">split()</span></code> にはオプションの &quot;sep&quot; 変数があり、行に空白文字以外の区切りを使っているときに便利です。</p>
<p>もっと複雑な入力解析をしたいなら、C の <code class="xref c c-func docutils literal notranslate"><span class="pre">sscanf()</span></code> よりも正規表現の方が便利ですし、この処理に向いています。</p>
</div>
<div class="section" id="what-does-unicodedecodeerror-or-unicodeencodeerror-error-mean">
<h3><a class="toc-backref" href="#id36">'UnicodeDecodeError' や 'UnicodeEncodeError' はどういう意味ですか？</a><a class="headerlink" href="#what-does-unicodedecodeerror-or-unicodeencodeerror-error-mean" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../howto/unicode.html#unicode-howto"><span class="std std-ref">Unicode HOWTO</span></a> を参照して下さい。</p>
</div>
</div>
<div class="section" id="performance">
<h2><a class="toc-backref" href="#id37">性能</a><a class="headerlink" href="#performance" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="my-program-is-too-slow-how-do-i-speed-it-up">
<h3><a class="toc-backref" href="#id38">プログラムが遅すぎます。どうしたら速くなりますか？</a><a class="headerlink" href="#my-program-is-too-slow-how-do-i-speed-it-up" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これは、一般的に難しい問題です。まず、先に進む前に覚えておいて欲しいことをここに挙げます:</p>
<ul class="simple">
<li>性能の傾向は Python 実装によって変わります。この FAQ では <a class="reference internal" href="../glossary.html#term-cpython"><span class="xref std std-term">CPython</span></a> に焦点を当てます。</li>
<li>振る舞いはオペレーティングシステムによって変わりえます。特に、I/O やマルチスレッドに関しては顕著です。</li>
<li>常に、コードの最適化を始める <em>前に</em> プログラムのホットスポットを見つけるべきです (<a class="reference internal" href="../library/profile.html#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a> モジュールを参照してください)。</li>
<li>ベンチマークスクリプトを書くことで、改善箇所の捜索を素早く繰り返せます (<a class="reference internal" href="../library/timeit.html#module-timeit" title="timeit: Measure the execution time of small code snippets."><code class="xref py py-mod docutils literal notranslate"><span class="pre">timeit</span></code></a> モジュールを参照してください)。</li>
<li>洗練された最適化に隠れたリグレッションの可能性を生む前に、(ユニットテストやその他の技法で) コードカバレッジを上げることを強く推奨します。</li>
</ul>
<p>とは言っても、Python コードを高速化する技法はたくさんあります。ここでは、満足な性能のレベルにたどり着くまでの長い道のりを進む、一般的な方針を示します:</p>
<ul class="simple">
<li>コード中に細かい最適化の技法をばらまこうとするよりも、アルゴリズムを高速化 (または高速なアルゴリズムに変更) するほうが、大きな利益を生むことがあります。</li>
<li>適切なデータ構造を使ってください。<a class="reference internal" href="../library/stdtypes.html#bltin-types"><span class="std std-ref">組み込み型</span></a> や <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> を調べてください。</li>
<li>何かをするための基本要素が標準ライブラリにあるなら、自分で発明した代用品よりもそちらのほうが、(絶対にとは言えませんが) おそらく速いです。
それが組み込み型やある種の拡張型のように C で書かれたものならなおさらです。
たとえば、ソートするには、必ず <a class="reference internal" href="../library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> 組み込みメソッドか <a class="reference internal" href="../library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a> 関数を使ってください (また、中程度に高度な例は、 <a class="reference internal" href="../howto/sorting.html#sortinghowto"><span class="std std-ref">ソート HOW TO</span></a> を参照してください)。</li>
<li>抽象化は、遠回りにしがちで、インタプリタの作業を増やすことになります。この遠回りさが、なされる作業の量より重大になると、プログラムが遅くなってしまいます。過度な抽象化、特に細かい関数やメソッドの形で現れるもの (これは読みにくさも落とします) は防ぐべきです。</li>
</ul>
<p>pure Python にできる限界に達したなら、更に進むためのツールがあります。例えば、 <a class="reference external" href="http://cython.org">Cython</a> は、Python コードのわずかに変形した版を C 拡張にコンパイルし、多種のプラットフォームで使えます。Cython は、コンパイル (と任意の型アノテーション) を利用し、コードの解釈を大幅に速くします。C プログラミングに自信があるなら、自分で <a class="reference internal" href="../extending/index.html#extending-index"><span class="std std-ref">write a C extension module</span></a> こともできます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference external" href="https://wiki.python.org/moin/PythonSpeed/PerformanceTips">パフォーマンス tips</a> が載っている wiki のページ。</p>
</div>
</div>
<div class="section" id="what-is-the-most-efficient-way-to-concatenate-many-strings-together">
<span id="efficient-string-concatenation"></span><h3><a class="toc-backref" href="#id39">多くの文字列を結合するのに最も効率的な方法は何ですか？</a><a class="headerlink" href="#what-is-the-most-efficient-way-to-concatenate-many-strings-together" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> および <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> オブジェクトはイミュータブルなので、多くの文字列の結合は結合ごとに新しいオブジェクトを作成し、効率が悪いです。
一般的に、全体の実行時間のコストは文字列の長さの二乗に比例します。</p>
<p>多くの <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> オブジェクトを累積するのにおすすめのイディオムは、すべてをリストに配置してから最後に <a class="reference internal" href="../library/stdtypes.html#str.join" title="str.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.join()</span></code></a> を呼び出すことです:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">my_strings</span><span class="p">:</span>
    <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
</pre></div>
</div>
<p>(他の割と効率的なイディオムは、 <a class="reference internal" href="../library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a> を使うことです)</p>
<p>多くの <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> オブジェクトを累積するのにおすすめのイディオムは、 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> オブジェクトをインプレース結合 (<code class="docutils literal notranslate"><span class="pre">+=</span></code> 演算子) で拡張することです:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
<span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">my_bytes_objects</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="n">b</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="sequences-tuples-lists">
<h2><a class="toc-backref" href="#id40">シーケンス(タプル/リスト)</a><a class="headerlink" href="#sequences-tuples-lists" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="how-do-i-convert-between-tuples-and-lists">
<h3><a class="toc-backref" href="#id41">タプル、リスト間の変更はどのようにするのですか？</a><a class="headerlink" href="#how-do-i-convert-between-tuples-and-lists" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>型コンストラクタ <code class="docutils literal notranslate"><span class="pre">tuple(seq)</span></code> はすべてのシーケンス (実際には、すべてのイテラブル) を同じ要素、同じ順序のタプルに変換します。</p>
<p>例えば、 <code class="docutils literal notranslate"><span class="pre">tuple([1,</span> <span class="pre">2,</span> <span class="pre">3])</span></code> は <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3)</span></code> を与え、 <code class="docutils literal notranslate"><span class="pre">tuple('abc')</span></code> は <code class="docutils literal notranslate"><span class="pre">('a',</span> <span class="pre">'b',</span> <span class="pre">'c')</span></code> を与えます。引数がタプルなら、コピーを作らずに引数のオブジェクトそのものを返すので、あるオブジェクトが既にタプルになっているか確信が持てないのなら、 <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">tuple()</span></code></a> を呼ぶのが手軽です。</p>
<p>型コンストラクタ <code class="docutils literal notranslate"><span class="pre">list(seq)</span></code> はすべてのシーケンスあるいはイテラブルを同じ要素、同じ順序のリストに変換します。例えば、<code class="docutils literal notranslate"><span class="pre">list((1,</span> <span class="pre">2,</span> <span class="pre">3))</span></code> は <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code> を与え、<code class="docutils literal notranslate"><span class="pre">list('abc')</span></code> は <code class="docutils literal notranslate"><span class="pre">['a',</span> <span class="pre">'b',</span> <span class="pre">'c']</span></code> を与えます。引数がリストなら、<code class="docutils literal notranslate"><span class="pre">seq[:]</span></code> と同様にコピーを作ります。</p>
</div>
<div class="section" id="what-s-a-negative-index">
<h3><a class="toc-backref" href="#id42">負の添え字は何ですか？</a><a class="headerlink" href="#what-s-a-negative-index" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python のシーケンスは正の数と負の数でインデクスされます。正の数では、0 が最初のインデクス、1 が 2 番目のインデクス、以下も同様です。負のインデクスでは、-1 が最後のインデクス、-2 が最後から 2 番目のインデクス、以下も同様です。<code class="docutils literal notranslate"><span class="pre">seq[-n]</span></code> は <code class="docutils literal notranslate"><span class="pre">seq[len(seq)-n]</span></code> と同じだと考えてください。</p>
<p>負のインデクスを使うと便利なことがあります。例えば、<code class="docutils literal notranslate"><span class="pre">S[:-1]</span></code> は文字列の最後以外のすべての文字を表すので、文字列の末尾の改行を取り除くときに便利です。</p>
</div>
<div class="section" id="how-do-i-iterate-over-a-sequence-in-reverse-order">
<h3><a class="toc-backref" href="#id43">シーケンスを逆順にイテレートするにはどうしたらいいですか？</a><a class="headerlink" href="#how-do-i-iterate-over-a-sequence-in-reverse-order" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python 2.4 で追加された <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> を使ってください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
    <span class="o">...</span>  <span class="c1"># do something with x ...</span>
</pre></div>
</div>
<p>これは元のシーケンスをいじるのではなく、逆順の新しいコピーを作ってイテレートさせます。</p>
<p>Python 2.3 では、拡張スライス構文を使います:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
    <span class="o">...</span>  <span class="c1"># do something with x ...</span>
</pre></div>
</div>
</div>
<div class="section" id="how-do-you-remove-duplicates-from-a-list">
<h3><a class="toc-backref" href="#id44">リストから重複を取り除くにはどうしますか？</a><a class="headerlink" href="#how-do-you-remove-duplicates-from-a-list" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python Cookbook の長い議論に多くの方法があるので参照してください:</p>
<blockquote>
<div><a class="reference external" href="https://code.activestate.com/recipes/52560/">https://code.activestate.com/recipes/52560/</a></div></blockquote>
<p>リストを並び替えて構わないのなら、ソートした上でリストの最初から最後までを調べ、次のように重複を削除してください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">mylist</span><span class="p">:</span>
    <span class="n">mylist</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">last</span> <span class="o">=</span> <span class="n">mylist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mylist</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">last</span> <span class="o">==</span> <span class="n">mylist</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">del</span> <span class="n">mylist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">mylist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>リストのすべての要素が集合のキーとして使える (つまり、すべての要素が <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>) なら、おそらくこのほうが速いです</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">mylist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">mylist</span><span class="p">))</span>
</pre></div>
</div>
<p>リストを集合に変換するときに重複は取り除かれるので、それをリストに戻せばいいのです。</p>
</div>
<div class="section" id="how-do-you-make-an-array-in-python">
<h3><a class="toc-backref" href="#id45">Python で配列を作るにはどうしますか？</a><a class="headerlink" href="#how-do-you-make-an-array-in-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>リストを使ってください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s2">&quot;this&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;is&quot;</span><span class="p">,</span> <span class="s2">&quot;an&quot;</span><span class="p">,</span> <span class="s2">&quot;array&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>リストの時間計算量は C や Pascal の配列と同じです。大きな違いは、Python のリストは多くの異なる型のオブジェクトを含めることです。</p>
<p><code class="docutils literal notranslate"><span class="pre">array</span></code> モジュールにも固定された型を簡潔に表現する配列を作るためのメソッドがありますが、リストよりもインデクスが遅いです。また、Numeric 拡張その他でも、様々な特徴をもつ配列的な構造体が定義されています。</p>
<p>Lisp 方式の連結リストを得るのに、タプルを使ってコンスセルをエミュレートできます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">lisp_list</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;like&quot;</span><span class="p">,</span>  <span class="p">(</span><span class="s2">&quot;this&quot;</span><span class="p">,</span>  <span class="p">(</span><span class="s2">&quot;example&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>ミュータブルな必要があるなら、タプルではなくリストを使いましょう。lisp の car にあたるものが <code class="docutils literal notranslate"><span class="pre">lisp_list[0]</span></code> で、cdr にあたるものが <code class="docutils literal notranslate"><span class="pre">lisp_list[1]</span></code> です。本当に必要だと確信できるとき以外はこれはしないでください。たいてい、これは Python のリストを使うよりも非常に遅いですから。</p>
</div>
<div class="section" id="how-do-i-create-a-multidimensional-list">
<span id="faq-multidimensional-list"></span><h3><a class="toc-backref" href="#id46">多次元のリストを作るにはどうしますか？</a><a class="headerlink" href="#how-do-i-create-a-multidimensional-list" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>このようにして多次元の配列を作ろうとしてしまったことがあるでしょう:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
</pre></div>
</div>
<p>これを表示したときには問題なさそうに見えます:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">[[None, None], [None, None], [None, None]]</span>
</pre></div>
</div>
<p>しかし値を代入すると、その値が複数の場所に現れてしまいます:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">[[5, None], [5, None], [5, None]]</span>
</pre></div>
</div>
<p>これは、<code class="docutils literal notranslate"><span class="pre">*</span></code> を使ったリストの複製がコピーを作らず、存在するオブジェクトへの参照を作るだけだからです。この <code class="docutils literal notranslate"><span class="pre">*3</span></code> は長さ 2 の同じリストへの参照を含むリストを作ります。一つの列に対する変更はすべての列に現れますが、これが望んだ結果であることはまずないでしょう。</p>
<p>おすすめの方法は、最初に望んだ長さのリストを作り、それから新しく作ったリストでそれぞれの要素を埋めていくことです:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
</pre></div>
</div>
<p>これは長さ 2 の異なるリスト 3 つを含むリストを生成します。リスト内包表記も使えます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">h</span><span class="p">)]</span>
</pre></div>
</div>
<p>あるいは、行列データ型を提供している拡張を使用することもできます; <a class="reference external" href="http://www.numpy.org/">NumPy</a> が最もよく知られています。</p>
</div>
<div class="section" id="how-do-i-apply-a-method-to-a-sequence-of-objects">
<h3><a class="toc-backref" href="#id47">オブジェクトのシーケンスにメソッドを適用するにはどうしますか？</a><a class="headerlink" href="#how-do-i-apply-a-method-to-a-sequence-of-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>リスト内包表記を使ってください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">method</span><span class="p">()</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">mylist</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works">
<span id="faq-augmented-assignment-tuple-error"></span><h3><a class="toc-backref" href="#id48">なぜ加算はされるのに a_tuple[i] += ['item'] は例外を送出するのですか?</a><a class="headerlink" href="#why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これは、累算代入演算子は <em>代入</em> 演算子だ、という事実と、Python での可変オブジェクトと不変オブジェクトの違いが組み合わさって起きるのです。</p>
<p>この議論は一般的に、可変オブジェクトを指すタプルの要素に、累算代入演算子が適用されたときにも適用できますが、例として <code class="docutils literal notranslate"><span class="pre">list</span></code> と <code class="docutils literal notranslate"><span class="pre">+=</span></code> を使います。</p>
<p>次のように書いたとします:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gt">Traceback (most recent call last):</span>
   <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;tuple&#39; object does not support item assignment</span>
</pre></div>
</div>
<p>例外が送出された理由は明らかです: <code class="docutils literal notranslate"><span class="pre">1</span></code> が (<code class="docutils literal notranslate"><span class="pre">1</span></code>) を指すオブジェクト <code class="docutils literal notranslate"><span class="pre">a_tuple[0]</span></code> に加えられ、結果のオブジェクト <code class="docutils literal notranslate"><span class="pre">2</span></code> が生成されますが、計算結果 <code class="docutils literal notranslate"><span class="pre">2</span></code> をタプルの第 <code class="docutils literal notranslate"><span class="pre">0</span></code> 要素に代入しようとしたときに、エラーが発生します。なぜならば、タプルの要素が何を指すかは変えられないからです。</p>
<p>このような裏事情の元、累算代入文はだいたい次のようなことをしています:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;tuple&#39; object does not support item assignment</span>
</pre></div>
</div>
<p>タプルは不変なので、例外を生み出しているのは操作の代入部分なのです。</p>
<p>次のように書いたとします:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span> <span class="o">=</span> <span class="p">([</span><span class="s1">&#39;foo&#39;</span><span class="p">],</span> <span class="s1">&#39;bar&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;item&#39;</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;tuple&#39; object does not support item assignment</span>
</pre></div>
</div>
<p>この例外にはちょっと驚きますが、もっと驚くべきことは、エラーがあったとしても追記はきちんと動いている、という事実です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[&#39;foo&#39;, &#39;item&#39;]</span>
</pre></div>
</div>
<p>なぜこれが起きるかを調べるためには、次の 2 点を知っている必要があります。(a) オブジェクトに <code class="docutils literal notranslate"><span class="pre">__iadd__</span></code> 特殊メソッドが実装されている場合、拡張代入 <code class="docutils literal notranslate"><span class="pre">+=</span></code> が実行されるときにそれが呼び出され、その返り値が代入文で使われます; (b) リストでは、<code class="docutils literal notranslate"><span class="pre">__iadd__</span></code> は <code class="docutils literal notranslate"><span class="pre">extend</span></code> の呼び出しと等価で、リストを返します。こんな理由で、リストでは <code class="docutils literal notranslate"><span class="pre">+=</span></code> は <code class="docutils literal notranslate"><span class="pre">list.extend</span></code> の &quot;略記&quot; だと言ったのでした:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_list</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_list</span>
<span class="go">[1]</span>
</pre></div>
</div>
<p>これは次と等価です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">a_list</span><span class="o">.</span><span class="fm">__iadd__</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_list</span> <span class="o">=</span> <span class="n">result</span>
</pre></div>
</div>
<p>a_list が指していたオブジェクトは更新され、更新されたオブジェクトへのポインタは再度 <code class="docutils literal notranslate"><span class="pre">a_list</span></code> に代入されます。代入しているのは、<code class="docutils literal notranslate"><span class="pre">a_list</span></code> が更新前まで指していた同じオブジェクトへのポインタなので、代入は最終的には何もしていないのですが、代入処理自体は起きています。</p>
<p>従って、今のタプルの例では、次のと同じことが起きています:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="fm">__iadd__</span><span class="p">([</span><span class="s1">&#39;item&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;tuple&#39; object does not support item assignment</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">__iadd__</span></code> は成功し、リストは拡張 (extend) されますが、<code class="docutils literal notranslate"><span class="pre">result</span></code> が <code class="docutils literal notranslate"><span class="pre">a_tuple[0]</span></code> が既に指しているオブジェクトと同じオブジェクトを指していたとしても、タプルは不変なので、その最後の代入はやはりエラーとなります。</p>
</div>
<div class="section" id="i-want-to-do-a-complicated-sort-can-you-do-a-schwartzian-transform-in-python">
<h3><a class="toc-backref" href="#id49">複雑なソートがしたいのですが、Python でシュワルツ変換はできますか？</a><a class="headerlink" href="#i-want-to-do-a-complicated-sort-can-you-do-a-schwartzian-transform-in-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Perl コミュニティの Randal Schwartz の作とされるこのテクニックは、リストの要素を、それぞれの要素をその「ソート値」に対応付けるメトリックによってソートします。Python では、 <a class="reference internal" href="../library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> メソッドに <code class="docutils literal notranslate"><span class="pre">key</span></code> 引数を使ってください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Isorted</span> <span class="o">=</span> <span class="n">L</span><span class="p">[:]</span>
<span class="n">Isorted</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">15</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="section" id="how-can-i-sort-one-list-by-values-from-another-list">
<h3><a class="toc-backref" href="#id50">リストを別のリストの値によってソートするにはどうしますか？</a><a class="headerlink" href="#how-can-i-sort-one-list-by-values-from-another-list" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>二つのイテレータを混ぜあわせてタプルのイテレータにしてから、必要な要素を選んでください。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">list1</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;what&quot;</span><span class="p">,</span> <span class="s2">&quot;I&#39;m&quot;</span><span class="p">,</span> <span class="s2">&quot;sorting&quot;</span><span class="p">,</span> <span class="s2">&quot;by&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">list2</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;something&quot;</span><span class="p">,</span> <span class="s2">&quot;else&quot;</span><span class="p">,</span> <span class="s2">&quot;to&quot;</span><span class="p">,</span> <span class="s2">&quot;sort&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pairs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pairs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pairs</span>
<span class="go">[(&quot;I&#39;m&quot;, &#39;else&#39;), (&#39;by&#39;, &#39;sort&#39;), (&#39;sorting&#39;, &#39;to&#39;), (&#39;what&#39;, &#39;something&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span>
<span class="go">[&#39;else&#39;, &#39;sort&#39;, &#39;to&#39;, &#39;something&#39;]</span>
</pre></div>
</div>
<p>最後の段階の別のやり方は:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span> <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>これのほうが読みやすいと、最後のリスト内包表記ではなくこれを使いたくなるかもしれません。しかし、これは長いリストではほぼ二倍の時間がかかります。なぜでしょうか。まず、<code class="docutils literal notranslate"><span class="pre">append()</span></code> 演算はメモリを割り当て直す必要があり、それを避けるために毎回ちょっと工夫していますが、それでも避けられないことがあるので、少し時間がかかるのです。二つ目に、&quot;result.append&quot; には属性探索が余計に必要で、三つ目に、これらすべての関数を呼ぶ必要があることで速度が落ちてしまいます。</p>
</div>
</div>
<div class="section" id="objects">
<h2><a class="toc-backref" href="#id51">オブジェクト</a><a class="headerlink" href="#objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="what-is-a-class">
<h3><a class="toc-backref" href="#id52">クラスとは何ですか？</a><a class="headerlink" href="#what-is-a-class" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>クラスは、class 文の実行で生成される特殊なオブジェクトです。クラスオブジェクトはインスタンスオブジェクトを生成するためのテンプレートとして使われ、あるデータ型に特有のデータ (attribute/属性) とコード (メソッド) の両方を内蔵しています。</p>
<p>新しいクラスを一つ以上の他のクラス (新しいクラスの基底クラスと呼ばれます) に基づいて作ることもできます。この新しいクラスは、基底クラスから属性とメソッドを継承します。これにより、オブジェクトモデルを継承で連続的に洗練できます。メールボックスへの基本的なアクセサを提供する一般的な <code class="docutils literal notranslate"><span class="pre">Mailbox</span></code> クラスを作って、それからいろいろな特定のメールボックスの形式を扱う <code class="docutils literal notranslate"><span class="pre">MboxMailbox</span></code>、<code class="docutils literal notranslate"><span class="pre">MaildirMailbox</span></code>、<code class="docutils literal notranslate"><span class="pre">OutlookMailbox</span></code> のようなサブクラスを作れるのです。</p>
</div>
<div class="section" id="what-is-a-method">
<h3><a class="toc-backref" href="#id53">メソッドとは何ですか？</a><a class="headerlink" href="#what-is-a-method" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>メソッドは、オブジェクト <code class="docutils literal notranslate"><span class="pre">x</span></code> が持つ関数で、通常 <code class="docutils literal notranslate"><span class="pre">x.name(arguments...)</span></code> として呼び出されるものです。メソッドはクラス定義の中で関数として定義されます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">arg</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">attribute</span>
</pre></div>
</div>
</div>
<div class="section" id="what-is-self">
<h3><a class="toc-backref" href="#id54">self とは何ですか？</a><a class="headerlink" href="#what-is-self" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>self はメソッドの第一引数に慣習的につけられる名前にすぎません。<code class="docutils literal notranslate"><span class="pre">meth(self,</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> として定義されたメソッドは、その定義がなされたクラスのインスタンス <code class="docutils literal notranslate"><span class="pre">x</span></code> に対して <code class="docutils literal notranslate"><span class="pre">x.meth(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> として呼び出されます。呼び出されたメソッドは、<code class="docutils literal notranslate"><span class="pre">meth(x,</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> が呼ばれたものと考えます。</p>
<p><a class="reference internal" href="design.html#why-self"><span class="std std-ref">なぜメソッドの定義や呼び出しにおいて 'self' を明示しなければならないのですか？</span></a> も参照してください。</p>
</div>
<div class="section" id="how-do-i-check-if-an-object-is-an-instance-of-a-given-class-or-of-a-subclass-of-it">
<h3><a class="toc-backref" href="#id55">あるオブジェクトが、与えられたクラスやそのサブクラスのインスタンスであるかを調べるにはどうしますか？</a><a class="headerlink" href="#how-do-i-check-if-an-object-is-an-instance-of-a-given-class-or-of-a-subclass-of-it" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ビルトイン関数 <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">cls)</span></code> を使ってください。クラスのタプルを与えて <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">(class1,</span> <span class="pre">class2,</span> <span class="pre">...))</span></code> のようにすれば、あるオブジェクトが任意の数のクラスのオブジェクトであるかを調べられますし、<code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">str)</span></code> や <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">(int,</span> <span class="pre">float,</span> <span class="pre">complex))</span></code> のようにすれば、Python のビルトイン型のオブジェクトであるかも調べられます。</p>
<p>なお、大部分のプログラムでは、 <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> をユーザー定義のクラスに何度も使うべきではありません。クラスを自分で開発するときに、適切なオブジェクト指向スタイルは、特定の振る舞いをカプセル化するクラスのメソッドを定義するものであって、オブジェクトのクラスを調べてそのクラスに応じて違うことをするものではありません。例えば、何かをする関数があったとして:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Mailbox</span><span class="p">):</span>
        <span class="o">...</span>  <span class="c1"># code to search a mailbox</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Document</span><span class="p">):</span>
        <span class="o">...</span>  <span class="c1"># code to search a document</span>
    <span class="k">elif</span> <span class="o">...</span>
</pre></div>
</div>
<p>よりよいアプローチは、<code class="docutils literal notranslate"><span class="pre">search()</span></code> メソッドをすべてのクラスに定義して、それをただ呼び出すことです:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Mailbox</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>  <span class="c1"># code to search a mailbox</span>

<span class="k">class</span> <span class="nc">Document</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>  <span class="c1"># code to search a document</span>

<span class="n">obj</span><span class="o">.</span><span class="n">search</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="what-is-delegation">
<h3><a class="toc-backref" href="#id56">委譲とは何ですか？</a><a class="headerlink" href="#what-is-delegation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>委譲 (delegation) とは、オブジェクト指向のテクニック (デザインパターンとも呼ばれる) の一つです。オブジェクト <code class="docutils literal notranslate"><span class="pre">x</span></code> があって、そのメソッドのうちただ一つの振る舞いを変えたいとしましょう。新しいクラスを作成し、変えたいメソッドだけを新しく実装し、他のすべてのメソッドを <code class="docutils literal notranslate"><span class="pre">x</span></code> の対応するメソッドに委譲する新しいクラスを作れます。</p>
<p>Python プログラマは簡単に委譲を実装できます。例えば、以下のクラスは、ファイルのように振る舞いながらすべての文字を大文字に変換するクラスを実装します:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">UpperOut</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outfile</span> <span class="o">=</span> <span class="n">outfile</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_outfile</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>Here the <code class="docutils literal notranslate"><span class="pre">UpperOut</span></code> class redefines the <code class="docutils literal notranslate"><span class="pre">write()</span></code> method to convert the
argument string to uppercase before calling the underlying
<code class="docutils literal notranslate"><span class="pre">self._outfile.write()</span></code> method.  All other methods are delegated to the
underlying <code class="docutils literal notranslate"><span class="pre">self._outfile</span></code> object.  The delegation is accomplished via the
<code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> method; consult <a class="reference internal" href="../reference/datamodel.html#attribute-access"><span class="std std-ref">the language reference</span></a>
for more information about controlling attribute access.</p>
<p>なお、一般的に委譲はトリッキーになりがちです。属性が設定される時には読み出される時と同様に、そのクラスに <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> メソッドを定義する必要があり、それには細心の注意が必要です。 <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> の基本的な実装はおおよそ以下のようになります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">X</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>たいてい、 <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 実装は <code class="docutils literal notranslate"><span class="pre">self.__dict__</span></code> を変更して、無限再帰を起こすことなくローカルな状態を保存するようにしなければなりません。</p>
</div>
<div class="section" id="how-do-i-call-a-method-defined-in-a-base-class-from-a-derived-class-that-overrides-it">
<h3><a class="toc-backref" href="#id57">基底クラスで定義されたメソッドを、そのクラスをオーバーライドした派生クラスから呼び出すにはどうしますか？</a><a class="headerlink" href="#how-do-i-call-a-method-defined-in-a-base-class-from-a-derived-class-that-overrides-it" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>組み込みの <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 関数を使ってください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Derived</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Derived</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">meth</span><span class="p">()</span>
</pre></div>
</div>
<p>3.0 以前のバージョンで旧スタイルクラスを使っているなら: <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">Derived(Base):</span> <span class="pre">...</span></code> のようなクラス定義で、<code class="docutils literal notranslate"><span class="pre">Base.meth(self,</span> <span class="pre">arguments...)</span></code> とすれば、<code class="docutils literal notranslate"><span class="pre">Base</span></code> (または <code class="docutils literal notranslate"><span class="pre">Base</span></code> の基底クラス) で定義された <code class="docutils literal notranslate"><span class="pre">meth()</span></code> メソッドを呼び出せます。ここで、<code class="docutils literal notranslate"><span class="pre">Base.meth</span></code> は束縛されていないメソッドなので、<code class="docutils literal notranslate"><span class="pre">self</span></code> 引数を渡す必要があります。</p>
</div>
<div class="section" id="how-can-i-organize-my-code-to-make-it-easier-to-change-the-base-class">
<h3><a class="toc-backref" href="#id58">基底クラスの名前を変えやすいコードを書くにはどうしますか？</a><a class="headerlink" href="#how-can-i-organize-my-code-to-make-it-easier-to-change-the-base-class" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>基底クラスのエイリアス (alias) を定義し、先にそれに本当の基底クラスを代入しておいてから、クラス定義の中でそのエイリアスを使うといいかもしれません。そうすればエイリアスに代入する値を変えるだけで済みます。ちなみに、この手法は使用する基底クラスを動的に選びたいとき、例えば使えるリソースによって選びたいときなどにも便利です。例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">BaseAlias</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">real</span> <span class="n">base</span> <span class="n">class</span><span class="o">&gt;</span>

<span class="k">class</span> <span class="nc">Derived</span><span class="p">(</span><span class="n">BaseAlias</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">BaseAlias</span><span class="o">.</span><span class="n">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="how-do-i-create-static-class-data-and-static-class-methods">
<h3><a class="toc-backref" href="#id59">静的なクラスデータや静的なクラスメソッドを作るにはどうしますか？</a><a class="headerlink" href="#how-do-i-create-static-class-data-and-static-class-methods" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>(C++ や Java の意味で) 静的なデータも静的なメソッドも Python でサポートされています。</p>
<p>静的なデータを作るには、単純にクラス属性を定義してください。その属性に新しい値を代入するには、代入するクラス名を明示する必要があります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># number of times C.__init__ called</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">C</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">getcount</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">count</span>  <span class="c1"># or return self.count</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">c</span></code> そのものや <code class="docutils literal notranslate"><span class="pre">c.__class__</span></code> から <code class="docutils literal notranslate"><span class="pre">C</span></code> にいたるパス探索経路上のクラスによってオーバーライドされない限り、<code class="docutils literal notranslate"><span class="pre">c.count</span></code> も <code class="docutils literal notranslate"><span class="pre">isinstance(c,</span> <span class="pre">C)</span></code> であるすべての <code class="docutils literal notranslate"><span class="pre">c</span></code> に対する <code class="docutils literal notranslate"><span class="pre">C.count</span></code> を参照します。</p>
<p>注意: C のメソッド内では、<code class="docutils literal notranslate"><span class="pre">self.count</span> <span class="pre">=</span> <span class="pre">42</span></code> のような代入は <code class="docutils literal notranslate"><span class="pre">self</span></code> 自身の辞書に &quot;count&quot; という名前の新しくて関係ないインスタンスを作ります。クラスの静的なデータの再束縛には、メソッド内であるか否かにかかわらず、いつもクラスを指定しなければなりません:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">314</span>
</pre></div>
</div>
<p>静的メソッドが使えます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">static</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">):</span>
        <span class="c1"># No &#39;self&#39; parameter!</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>しかし、静的メソッドの効果を得るもっと簡単な方法は、単にモジュールレベル関数を使うことです:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">getcount</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">count</span>
</pre></div>
</div>
<p>モジュールあたりに一つのクラスを定義するように (あるいはクラス組織を厳密に関連させるように) コードが構成されているなら、これで必要なカプセル化ができます。</p>
</div>
<div class="section" id="how-can-i-overload-constructors-or-methods-in-python">
<h3><a class="toc-backref" href="#id60">Python でコンストラクタ(やメソッド)をオーバーロードするにはどうしたらいいですか？</a><a class="headerlink" href="#how-can-i-overload-constructors-or-methods-in-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>この質問の答えはすべてのメソッドについて言えることですが、この質問はだいたい以下の構造の文脈から出てきます。</p>
<p>C++ では、このように書けます</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">class</span> <span class="n">C</span> <span class="p">{</span>
    <span class="n">C</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;No arguments</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">C</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Argument is &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Python では、一つのコンストラクタでデフォルトの引数を使ってすべての場合に対応するように書かなければなりません。例えば:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No arguments&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Argument is&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>これで完全に等価とは言えませんが、実用上は十分に近いです。</p>
<p>長さが変えられる引数のリストを試すには、例えば</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>これと同じやり方がすべてのメソッド定義で使えます。</p>
</div>
<div class="section" id="i-try-to-use-spam-and-i-get-an-error-about-someclassname-spam">
<h3><a class="toc-backref" href="#id61">__spam を使おうとしたら _SomeClassName__spam からエラーがでました。</a><a class="headerlink" href="#i-try-to-use-spam-and-i-get-an-error-about-someclassname-spam" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>先頭にアンダースコアが二つ付いた変数名は、クラスのプライベートな変数を、 &quot;マングル化&quot; という単純かつ効率のいい方法で定義します。<code class="docutils literal notranslate"><span class="pre">__spam</span></code> のような形式 (先頭に二つ以上、末尾にもしあっても一つのアンダースコアがある) のすべての識別子は、<code class="docutils literal notranslate"><span class="pre">classname</span></code> が先頭のアンダースコアをすべて削除した現在のクラス名とすれば、<code class="docutils literal notranslate"><span class="pre">_classname__spam</span></code> のように文字上で置換えられます。</p>
<p>これはプライベートであることを保証するものではありません。これでも外部のユーザが &quot;_classname__spam&quot; 属性に直接アクセスできますし、プライベートな変数はオブジェクトの <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> から見えます。多くの Python プログラマはわざわざプライベートな変数名を使おうとなど考えません。</p>
</div>
<div class="section" id="my-class-defines-del-but-it-is-not-called-when-i-delete-the-object">
<h3><a class="toc-backref" href="#id62">クラスに __del__ メソッドを定義しているのですが、オブジェクトを削除したときに呼ばれません。</a><a class="headerlink" href="#my-class-defines-del-but-it-is-not-called-when-i-delete-the-object" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>いくつかの可能性があります。</p>
<p>del 文は必ずしも <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> を呼び出すとは限りません -- これは単純にオブジェクトの参照カウントを減らすもので、カウントがゼロになったときに <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> が呼び出されます。</p>
<p>データ構造が循環リンク (子のそれぞれが親の参照を持ち、親のそれぞれが子のリストを持つツリーなど) を含む場合、その参照カウントは決して 0 にはなりません。時々、Python はこのようなサイクルを検出するアルゴリズムを実行しますが、データ構造への参照がなくなってからこのガベージコレクタが実行されるまでいくらか時間が掛かるかもしれないので、 <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> メソッドは不都合な予期できないタイミングで呼び出されるかもしれません。これは問題を再現しようとするときに不便です。さらに悪いことに、オブジェクトの <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> メソッドが実行される順序は任意です。 <a class="reference internal" href="../library/gc.html#gc.collect" title="gc.collect"><code class="xref py py-func docutils literal notranslate"><span class="pre">gc.collect()</span></code></a> を起動して収集を強制することができますが、オブジェクトが決して回収されないような本当に病的な場合も <em>あります</em> 。</p>
<p>循環参照コレクタがあるとはいえ、オブジェクトに <code class="docutils literal notranslate"><span class="pre">close()</span></code> メソッドを明示的に定義し、使い終わったらいつでも呼び出せるようにするのはいいことです。
<code class="docutils literal notranslate"><span class="pre">close()</span></code> メソッドを使うと、サブオブジェクトを参照している属性を取り除けます。
<a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> を直接呼び出さないでください -- <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> は <code class="docutils literal notranslate"><span class="pre">close()</span></code> を呼び出すでしょうし、 <code class="docutils literal notranslate"><span class="pre">close()</span></code> なら同じオブジェクトに対して複数回呼ばれてもいいことが保証されているでしょう。</p>
<p>循環参照を避ける他の方法は、 <a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">weakref</span></code></a> モジュールを使って、参照カウントを増やすことなくオブジェクトを示すことです。例えばツリー構造は、親と (必要なら！) 兄弟に弱参照を使うべきです。</p>
<p>最後に、 <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> メソッドが例外を発生させた場合、警告のメッセージが <a class="reference internal" href="../library/sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a> に書きこまれます。</p>
</div>
<div class="section" id="how-do-i-get-a-list-of-all-instances-of-a-given-class">
<h3><a class="toc-backref" href="#id63">与えられたクラスのすべてのインスタンスのリストを得るにはどうしますか？</a><a class="headerlink" href="#how-do-i-get-a-list-of-all-instances-of-a-given-class" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python はクラス (やビルトイン型) のすべてのインスタンスをたどりません。クラスのコンストラクタにそれぞれのインスタンスへの弱参照のリストを作らせることですべてのインスタンスをたどらせられます。</p>
</div>
<div class="section" id="why-does-the-result-of-id-appear-to-be-not-unique">
<h3><a class="toc-backref" href="#id64">なぜ <code class="docutils literal notranslate"><span class="pre">id()</span></code> の結果は一意でないように見えるのですか?</a><a class="headerlink" href="#why-does-the-result-of-id-appear-to-be-not-unique" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>組み込みの <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> は、オブジェクトが生存している間は一意なことが保証されている整数値を返します。 CPython では、それはオブジェクトのメモリアドレスなので、オブジェクトがメモリから削除された後に、次に新しく生成されたオブジェクトはメモリの同じ場所にメモリ領域を確保されていることが、しばしば起きます。この現象を次の例で示しましょう:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="c1"># doctest: +SKIP</span>
<span class="go">13901272</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="mi">2000</span><span class="p">)</span> <span class="c1"># doctest: +SKIP</span>
<span class="go">13901272</span>
</pre></div>
</div>
<p>2 つの同じ値を持つ id は <code class="docutils literal notranslate"><span class="pre">id()</span></code> の実行の前に作られてすぐさま削除された異なる整数オブジェクトによるものです。id を調べたいオブジェクトがまだ生きてることを保証したいなら、オブジェクトへの別の参照を作ってください:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1"># doctest: +SKIP</span>
<span class="go">13901272</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c1"># doctest: +SKIP</span>
<span class="go">13891296</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="modules">
<h2><a class="toc-backref" href="#id65">モジュール (module)</a><a class="headerlink" href="#modules" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="how-do-i-create-a-pyc-file">
<h3><a class="toc-backref" href="#id66">.pyc ファイルを作るにはどうしますか？</a><a class="headerlink" href="#how-do-i-create-a-pyc-file" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>モジュールが初めてインポートされたとき (もしくは、現在のコンパイルされたファイルが作られてから、ソースファイルが変更されたとき) 、コンパイルされたコードが入っている <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> ファイルが、 <code class="docutils literal notranslate"><span class="pre">.py</span></code> ファイルのあるディレクトリのサブディレクトリ <code class="docutils literal notranslate"><span class="pre">__pycache__</span></code> に作成されます。 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> ファイルのファイル名は、 <code class="docutils literal notranslate"><span class="pre">.py</span></code> ファイルの名前で始まり、 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> で終わり、中間部分はこのファイルを作った <code class="docutils literal notranslate"><span class="pre">python</span></code> バイナリに依存した文字列になります。 (詳細は <span class="target" id="index-8"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a> を参照してください。)</p>
<p><code class="docutils literal notranslate"><span class="pre">.pyc</span></code> が作られない理由の 1 つは、ソースファイルがあるディレクトリの権限の問題、つまり <code class="docutils literal notranslate"><span class="pre">__pycache__</span></code> サブディレクトリが作れない問題です。これは、例えば、ウェブサーバーでテストを行っているときのような、開発者のユーザと実行者のユーザが別な場合に、起こり得ます。</p>
<p><span class="target" id="index-9"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONDONTWRITEBYTECODE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONDONTWRITEBYTECODE</span></code></a> 環境変数がセットされない限り、モジュールをインポートしていて、 Python に <code class="docutils literal notranslate"><span class="pre">__pycache__</span></code> サブディレクトリを作り、そこにコンパイルされたモジュールが置ける能力 (権限、ディスクの空きスペース、など) がある場合は、 .pyc ファイルは自動的に作られます。</p>
<p>最上位のスクリプトを Python で実行するのはインポートとはみなされず、<code class="docutils literal notranslate"><span class="pre">.pyc</span></code> は作成されません。例えば、最上位のモジュール <code class="docutils literal notranslate"><span class="pre">foo.py</span></code> が別のモジュール <code class="docutils literal notranslate"><span class="pre">xyz.py</span></code> をインポートしている場合、(シェルコマンドとして <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">foo.py</span></code> と打ち込んで) <code class="docutils literal notranslate"><span class="pre">foo</span></code> を実行すると、<code class="docutils literal notranslate"><span class="pre">xyz</span></code> はインポートされるので <code class="docutils literal notranslate"><span class="pre">xyz</span></code> の <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> は作成されますが、<code class="docutils literal notranslate"><span class="pre">foo.py</span></code> はインポートされたわけではないので <code class="docutils literal notranslate"><span class="pre">foo</span></code> の <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> は作られません。</p>
<p><code class="docutils literal notranslate"><span class="pre">foo</span></code> の <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> ファイルを作成する -- つまり、インポートされていないモジュールの <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> ファイルを作成する -- 必要がある場合、 <a class="reference internal" href="../library/py_compile.html#module-py_compile" title="py_compile: Generate byte-code files from Python source files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">py_compile</span></code></a> モジュールと <a class="reference internal" href="../library/compileall.html#module-compileall" title="compileall: Tools for byte-compiling all Python source files in a directory tree."><code class="xref py py-mod docutils literal notranslate"><span class="pre">compileall</span></code></a> モジュールを使えば可能です。</p>
<p><a class="reference internal" href="../library/py_compile.html#module-py_compile" title="py_compile: Generate byte-code files from Python source files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">py_compile</span></code></a> モジュールは手動で任意のモジュールをコンパイルできます。やり方の一つは、このモジュールの <code class="docutils literal notranslate"><span class="pre">compile()</span></code> 関数をインタラクティブに実行することです:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_compile</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">py_compile</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;foo.py&#39;</span><span class="p">)</span>                 
</pre></div>
</div>
<p>このように実行すると、<code class="docutils literal notranslate"><span class="pre">foo.py</span></code> と同じ場所の <code class="docutils literal notranslate"><span class="pre">__pycache__</span></code> サブディレクトリに <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> が書き出されます (出力ファイルの位置は、オプション引数 <code class="docutils literal notranslate"><span class="pre">cfile</span></code> で上書きすることもできます)。</p>
<p><a class="reference internal" href="../library/compileall.html#module-compileall" title="compileall: Tools for byte-compiling all Python source files in a directory tree."><code class="xref py py-mod docutils literal notranslate"><span class="pre">compileall</span></code></a> モジュールを使えば自動的に一つや複数のディレクトリのすべてのファイルをコンパイルできます。シェルプロンプトから <code class="docutils literal notranslate"><span class="pre">compileall.py</span></code> を起動して、コンパイルしたいファイルを含むディレクトリのパスを指定してください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">compileall</span> <span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="how-do-i-find-the-current-module-name">
<h3><a class="toc-backref" href="#id67">現在のモジュール名を知るにはどうしますか？</a><a class="headerlink" href="#how-do-i-find-the-current-module-name" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>モジュールは前もって定義されたグローバル変数 <code class="docutils literal notranslate"><span class="pre">__name__</span></code> を検索することで自身の名前を決定できます。この値が <code class="docutils literal notranslate"><span class="pre">'__main__'</span></code> であるとき、そのプログラムはスクリプトとして実行されています。インポートされることによって使われる大抵のモジュールはコマンドラインインタフェースや自己テストも提供していて、<code class="docutils literal notranslate"><span class="pre">__name__</span></code> をチェックしてからそのコードだけを実行します:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running test...&#39;</span><span class="p">)</span>
    <span class="o">...</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="how-can-i-have-modules-that-mutually-import-each-other">
<h3><a class="toc-backref" href="#id68">相互にインポートしあうモジュールを作るにはどうしたらいいですか？</a><a class="headerlink" href="#how-can-i-have-modules-that-mutually-import-each-other" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下のモジュールがあったとしましょう:</p>
<p>foo.py:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bar</span> <span class="kn">import</span> <span class="n">bar_var</span>
<span class="n">foo_var</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>bar.py:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">foo</span> <span class="kn">import</span> <span class="n">foo_var</span>
<span class="n">bar_var</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>問題はインタプリタが以下の段階を実行することです:</p>
<ul class="simple">
<li>main が foo をインポートする</li>
<li>foo の空のグローバルが生成される</li>
<li>foo がコンパイルされ実行を始める</li>
<li>foo が bar をインポートする</li>
<li>bar の空のグローバルが生成される</li>
<li>bar がコンパイルされ実行を始める</li>
<li>bar が foo をインポートする(すでに foo という名前のモジュールがあるので no-op となる)</li>
<li>bar.foo_var = foo.foo_var</li>
</ul>
<p>この最後の段階は失敗します。Python が <code class="docutils literal notranslate"><span class="pre">foo</span></code> を解釈し終わっていなくて、<code class="docutils literal notranslate"><span class="pre">foo</span></code> のグローバルなシンボルの辞書はまだ空ですから。</p>
<p><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">foo</span></code> を使って、グローバルコードの <code class="docutils literal notranslate"><span class="pre">foo.foo_var</span></code> にアクセスしようとしたときにも、これと同じことが起こります。</p>
<p>この問題には (少なくとも) 三つの解決策があります。</p>
<p>Guido van Rossum は <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">&lt;module&gt;</span> <span class="pre">import</span> <span class="pre">...</span></code> を全く使わないで、すべてのコードを関数の中に入れることを勧めています。グローバル変数とクラス変数の初期化は定数とビルトイン関数のみで行われるべきです。これでインポートされたすべてのモジュールは <code class="docutils literal notranslate"><span class="pre">&lt;module&gt;.&lt;name&gt;</span></code> として参照されることになります。</p>
<p>Jim Roskind はそれぞれのモジュールに対して以下の順に進めることを提案しています:</p>
<ul class="simple">
<li>エクスポート (インポートされた基底クラスを必要としないグローバル、関数、クラス)</li>
<li><code class="docutils literal notranslate"><span class="pre">import</span></code> 文</li>
<li>アクティブなコード (インポートされた値によって初期化されるグローバルを含む)。</li>
</ul>
<p>インポートが奇妙な場所に現れることから van Rossum はこの方法をそれほど好みませんが、これは有効です。</p>
<p>Matthias Urlichs は第一に再帰インポートが必要ないようにコードを構築しなおすことを推奨しています。</p>
<p>これらの解決策はそれぞれ両立させることもできます。</p>
</div>
<div class="section" id="import-x-y-z-returns-module-x-how-do-i-get-z">
<h3><a class="toc-backref" href="#id69">__import__('x.y.z') は &lt;module 'x'&gt; を返しますが、z を得るためにはどうしますか？</a><a class="headerlink" href="#import-x-y-z-returns-module-x-how-do-i-get-z" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> に <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a> という便利な関数があるので、代わりにそちらを使用することを検討してください。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s1">&#39;x.y.z&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="when-i-edit-an-imported-module-and-reimport-it-the-changes-don-t-show-up-why-does-this-happen">
<h3><a class="toc-backref" href="#id70">インポートされたモジュールを編集してから再インポートしましたが、変化が現れません。なぜですか？</a><a class="headerlink" href="#when-i-edit-an-imported-module-and-reimport-it-the-changes-don-t-show-up-why-does-this-happen" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>効率と一貫性上の理由から、Python はモジュールが最初にインポートされた時にのみモジュールファイルを読み込みます。そうしないと、たくさんのモジュールでできていて、それぞれが同じ基本モジュールをインポートしているようなプログラムでは、その基本モジュールの解析と再解析が繰り返されることになります。変更されさたモジュールの再読込を強制するには、こうしてください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib</span>
<span class="kn">import</span> <span class="nn">modname</span>
<span class="n">importlib</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="n">modname</span><span class="p">)</span>
</pre></div>
</div>
<p>注意:この手法は 100%安全とは言えません。とりわけ</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">modname</span> <span class="kn">import</span> <span class="n">some_objects</span>
</pre></div>
</div>
<p>のような文を含むモジュールは、インポートされたオブジェクトの古いバージョンを使い続けます。そのモジュールにクラス定義が含まれていたら、存在するクラスインスタンスは新しいクラス定義を使うようにアップデート <em>されません</em>。これによって以下の矛盾した振舞いがなされえます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">importlib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cls</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">C</span><span class="p">()</span>                <span class="c1"># Create an instance of C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">importlib</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
<span class="go">&lt;module &#39;cls&#39; from &#39;cls.py&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">C</span><span class="p">)</span>       <span class="c1"># isinstance is false?!?</span>
<span class="go">False</span>
</pre></div>
</div>
<p>この問題の本質は、クラスオブジェクトの &quot;固有値&quot; を印字することで明らかになります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span>
<span class="go">&#39;0x7352a0&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">C</span><span class="p">))</span>
<span class="go">&#39;0x4198d0&#39;</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">プログラミング FAQ</a><ul>
<li><a class="reference internal" href="#general-questions">一般的な質問</a></li>
<li><a class="reference internal" href="#core-language">コア言語</a></li>
<li><a class="reference internal" href="#numbers-and-strings">数と文字列</a></li>
<li><a class="reference internal" href="#performance">性能</a></li>
<li><a class="reference internal" href="#sequences-tuples-lists">シーケンス(タプル/リスト)</a></li>
<li><a class="reference internal" href="#objects">オブジェクト</a></li>
<li><a class="reference internal" href="#modules">モジュール (module)</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="general.html"
                        title="前の章へ">一般 Python FAQ</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="design.html"
                        title="次の章へ">デザインと歴史 FAQ</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.8/Doc/faq/programming.rst"
            rel="nofollow">ソースコードを表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="design.html" title="デザインと歴史 FAQ"
             >次へ</a> |</li>
        <li class="right" >
          <a href="general.html" title="一般 Python FAQ"
             >前へ</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.3 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python よくある質問</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" type="text" name="q" />
          <input type="submit" value="検索" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">著作権</a> 2001-2020, Python Software Foundation.
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最終更新: 5月 15, 2020
    <a href="https://docs.python.org/3/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>

  </body>
</html>