
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>7. 単純文 (simple statement) &#8212; Python 3.8.3 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.8.3 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="next" title="8. 複合文 (compound statement)" href="compound_stmts.html" />
    <link rel="prev" title="6. 式 (expression)" href="expressions.html" />
    <link rel="canonical" href="https://docs.python.org/3/reference/simple_stmts.html" />
    
      
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="compound_stmts.html" title="8. 複合文 (compound statement)"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="expressions.html" title="6. 式 (expression)"
             accesskey="P">前へ</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.3 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python 言語リファレンス</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" type="text" name="q" />
          <input type="submit" value="検索" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="simple-statements">
<span id="simple"></span><h1>7. 単純文 (simple statement)<a class="headerlink" href="#simple-statements" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p id="index-0">単純文とは、単一の論理行内に収められる文です。単一の行内には、複数の単純文をセミコロンで区切って入れることができます。単純文の構文は以下の通りです:</p>
<pre>
<strong id="grammar-token-simple-stmt">simple_stmt</strong> ::=  <a class="reference internal" href="#grammar-token-expression-stmt"><code class="xref docutils literal notranslate"><span class="pre">expression_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-assert-stmt"><code class="xref docutils literal notranslate"><span class="pre">assert_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-assignment-stmt"><code class="xref docutils literal notranslate"><span class="pre">assignment_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-augmented-assignment-stmt"><code class="xref docutils literal notranslate"><span class="pre">augmented_assignment_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-annotated-assignment-stmt"><code class="xref docutils literal notranslate"><span class="pre">annotated_assignment_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-pass-stmt"><code class="xref docutils literal notranslate"><span class="pre">pass_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-del-stmt"><code class="xref docutils literal notranslate"><span class="pre">del_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-return-stmt"><code class="xref docutils literal notranslate"><span class="pre">return_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-yield-stmt"><code class="xref docutils literal notranslate"><span class="pre">yield_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-raise-stmt"><code class="xref docutils literal notranslate"><span class="pre">raise_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-break-stmt"><code class="xref docutils literal notranslate"><span class="pre">break_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-continue-stmt"><code class="xref docutils literal notranslate"><span class="pre">continue_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-import-stmt"><code class="xref docutils literal notranslate"><span class="pre">import_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-future-stmt"><code class="xref docutils literal notranslate"><span class="pre">future_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-global-stmt"><code class="xref docutils literal notranslate"><span class="pre">global_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-nonlocal-stmt"><code class="xref docutils literal notranslate"><span class="pre">nonlocal_stmt</span></code></a>
</pre>
<div class="section" id="expression-statements">
<span id="exprstmts"></span><h2>7.1. 式文 (expression statement)<a class="headerlink" href="#expression-statements" title="このヘッドラインへのパーマリンク">¶</a></h2>
<span class="target" id="index-1"></span><p id="index-2">式文は、(主に対話的な使い方では) 値を計算して出力するために使ったり、(通常は) プロシジャ (procedure: 有意な結果を返さない関数のことです; Python では、プロシジャは値 <code class="docutils literal notranslate"><span class="pre">None</span></code> を返します) を呼び出すために使います。その他の使い方でも式文を使うことができますし、有用なこともあります。式文の構文は以下の通りです:</p>
<pre>
<strong id="grammar-token-expression-stmt">expression_stmt</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-starred-expression"><code class="xref docutils literal notranslate"><span class="pre">starred_expression</span></code></a>
</pre>
<p>式文は式のリスト (単一の式のこともあります) を値評価します。</p>
<p id="index-3">対話モードでは、値が <code class="docutils literal notranslate"><span class="pre">None</span></code> でなければ、値を組み込み関数 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> で文字列に変換して、その結果の文字列を標準出力に一行使って書き出します。 (<code class="docutils literal notranslate"><span class="pre">None</span></code> になる式文の値は書き出されないので、プロシジャの呼び出しを行っても出力は得られません。)</p>
</div>
<div class="section" id="assignment-statements">
<span id="assignment"></span><h2>7.2. 代入文 (assignment statement)<a class="headerlink" href="#assignment-statements" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-4">代入文は、名前を値に (再) 束縛したり、変更可能なオブジェクトの属性や要素を変更したりするために使われます:</p>
<pre>
<strong id="grammar-token-assignment-stmt">assignment_stmt</strong> ::=  (<a class="reference internal" href="#grammar-token-target-list"><code class="xref docutils literal notranslate"><span class="pre">target_list</span></code></a> &quot;=&quot;)+ (<a class="reference internal" href="expressions.html#grammar-token-starred-expression"><code class="xref docutils literal notranslate"><span class="pre">starred_expression</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-yield-expression"><code class="xref docutils literal notranslate"><span class="pre">yield_expression</span></code></a>)
<strong id="grammar-token-target-list">target_list    </strong> ::=  <a class="reference internal" href="#grammar-token-target"><code class="xref docutils literal notranslate"><span class="pre">target</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-target"><code class="xref docutils literal notranslate"><span class="pre">target</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-target">target         </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>
                     | &quot;(&quot; [<a class="reference internal" href="#grammar-token-target-list"><code class="xref docutils literal notranslate"><span class="pre">target_list</span></code></a>] &quot;)&quot;
                     | &quot;[&quot; [<a class="reference internal" href="#grammar-token-target-list"><code class="xref docutils literal notranslate"><span class="pre">target_list</span></code></a>] &quot;]&quot;
                     | <a class="reference internal" href="expressions.html#grammar-token-attributeref"><code class="xref docutils literal notranslate"><span class="pre">attributeref</span></code></a>
                     | <a class="reference internal" href="expressions.html#grammar-token-subscription"><code class="xref docutils literal notranslate"><span class="pre">subscription</span></code></a>
                     | <a class="reference internal" href="expressions.html#grammar-token-slicing"><code class="xref docutils literal notranslate"><span class="pre">slicing</span></code></a>
                     | &quot;*&quot; <a class="reference internal" href="#grammar-token-target"><code class="xref docutils literal notranslate"><span class="pre">target</span></code></a>
</pre>
<p>(<em>attributeref</em>, <em>subscription</em>, <em>slicing</em> の構文については <a class="reference internal" href="expressions.html#primaries"><span class="std std-ref">プライマリ</span></a> 節を参照してください。)</p>
<p>代入文は式のリスト (これは単一の式でも、カンマで区切られた式リストでもよく、後者はタプルになることを思い出してください) を評価し、得られた単一の結果オブジェクトをターゲット (target) のリストに対して左から右へと代入してゆきます。</p>
<p id="index-5">代入はターゲット (リスト) の形式に従って再帰的に行われます。ターゲットが変更可能なオブジェクト (属性参照、添字表記、またはスライス) の一部である場合、この変更可能なオブジェクトは最終的に代入を実行して、その代入が有効な操作であるか判断しなければなりません。代入が不可能な場合には例外を発行することもできます。型ごとにみられる規則や、送出される例外は、そのオブジェクト型定義で与えられています (<a class="reference internal" href="datamodel.html#types"><span class="std std-ref">標準型の階層</span></a> 節を参照してください).</p>
<p id="index-6">ターゲットリストは、丸括弧や角括弧で囲まれていてもよく、それに対するオブジェクトの代入は、以下のように再帰的に定義されています。</p>
<ul class="simple">
<li>ターゲットリストのターゲットが1つだけでコンマが続いておらず、任意に丸括弧で囲われている場合、オブジェクトはそのターゲットに代入されます。</li>
<li>そうでない場合: オブジェクトは、ターゲットリストのターゲットと同じ数の要素を持つイテラブルでなければならず、要素は左から右へ対応するターゲットに代入されます。<ul>
<li>&quot;星付き&quot;のターゲットと呼ばれる、頭にアスタリスクが一つ付いたターゲットがターゲットリストに一つだけ含まれている場合: オブジェクトはイテラブルで、少なくともターゲットリストのターゲットの数よりも一つ少ない要素を持たなければはなりません。
星付きのターゲットより前のターゲットに、イテラブルの先頭の要素が左から右へ代入されます。
星付きのターゲットより後ろのターゲットに、イテラブルの末尾の要素が代入されます。
星付きのターゲットに、イテラブルの残った要素のリストが代入されます (リスト空でもかまいません)。</li>
<li>そうでない場合: オブジェクトは、ターゲットリストのターゲットと同じ数の要素を持つイテラブルでなければならず、要素は左から右へ対応するターゲットに代入されます。</li>
</ul>
</li>
</ul>
<p>単一のターゲットへの単一のオブジェクトの代入は、以下のようにして再帰的に定義されています。</p>
<ul>
<li><p class="first">ターゲットが識別子 (名前) の場合:</p>
<ul class="simple">
<li>名前が現在のコードブロック内の <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> や <a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 文に書かれていないければ: 名前は現在のローカル名前空間内のオブジェクトに束縛されます。</li>
<li>そうでなければ: 名前はそれぞれグローバル名前空間内か、 <a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> で決められた外側の名前空間内のオブジェクトに束縛されます。</li>
</ul>
<p id="index-7">名前がすでに束縛済みの場合、再束縛 (rebind) がおこなわれます。再束縛によって、以前その名前に束縛されていたオブジェクトの参照カウント (reference count) がゼロになった場合、オブジェクトは解放 (deallocate) され、デストラクタ  (destructor) が (存在すれば) 呼び出されます。</p>
</li>
<li id="index-8"><p class="first">ターゲットが属性参照の場合: 参照されている一次語の式が値評価されます。値は代入可能な属性を伴うオブジェクトでなければなりません; そうでなければ、 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> が送出されます。次に、このオブジェクトに対して、被代入オブジェクトを指定した属性に代入してよいか問い合わせます; 代入を実行できない場合、例外 (通常は <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> ですが、必然ではありません) を送出します。</p>
<p id="attr-target-note">Note: If the object is a class instance and the attribute reference occurs on
both sides of the assignment operator, the right-hand side expression, <code class="docutils literal notranslate"><span class="pre">a.x</span></code> can access
either an instance attribute or (if no instance attribute exists) a class
attribute.  The left-hand side target <code class="docutils literal notranslate"><span class="pre">a.x</span></code> is always set as an instance attribute,
creating it if necessary.  Thus, the two occurrences of <code class="docutils literal notranslate"><span class="pre">a.x</span></code> do not
necessarily refer to the same attribute: if the right-hand side expression refers to a
class attribute, the left-hand side creates a new instance attribute as the target of the
assignment:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Cls</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>             <span class="c1"># class variable</span>
<span class="n">inst</span> <span class="o">=</span> <span class="n">Cls</span><span class="p">()</span>
<span class="n">inst</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">inst</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>   <span class="c1"># writes inst.x as 4 leaving Cls.x as 3</span>
</pre></div>
</div>
<p>このことは、 <a class="reference internal" href="../library/functions.html#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a> で作成されたプロパティのようなデスクリプタ属性に対しては、必ずしもあてはまるとは限りません。</p>
</li>
<li id="index-9"><p class="first">ターゲットが添字表記なら: 参照されている一次語式が評価されます。参照から (リストのような) ミュータブルなシーケンスオブジェクトか、(辞書のような) マッピングオブジェクトが得られなければなりません。次に、添字表記の表す式が評価されます。</p>
<p id="index-10">一次語が (リストのような) ミュータブルなシーケンスオブジェクトであれば、添字表記は整数を与えなければなりません。整数が負なら、シーケンスの長さが加算されます。整数は最終的に、シーケンスの長さよりも小さな非負の整数でなくてはならず、シーケンスは、そのインデクスに持つ要素に被代入オブジェクトを代入してよいか問い合わせられます。インデクスが範囲外なら、 <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> が送出されます (添字指定されたシーケンスに代入を行っても、リスト要素の新たな追加はできません)。</p>
<p id="index-11">一次語が (辞書のような) マップオブジェクトの場合、まず添字はマップのキー型と互換性のある型でなくてはなりません。次に、添字を被代入オブジェクトに関連付けるようなキー/データの対を生成するようマップオブジェクトに問い合わせます。この操作では、既存のキー/値の対を同じキーと別の値で置き換えてもよく、(同じ値を持つキーが存在しない場合) 新たなキー/値の対を挿入してもかまいません。</p>
<p>ユーザ定義のオブジェクトには、適切な引数で <a class="reference internal" href="datamodel.html#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a> メソッドが呼び出されます。</p>
</li>
<li id="index-12"><p class="first">ターゲットがスライスなら: 参照されている一次語式が評価されます。一次語式は、(リストのような) ミュータブルなシーケンスオブジェクトを与えなければなりません。被代入オブジェクトは同じ型のシーケンスオブジェクトでなければなりません。次に、スライスの下限と上限を示す式があれば評価されます; デフォルト値はそれぞれ 0 とシーケンスの長さです。上限と下限の評価は整数でなければなりません。いずれかの境界が負数なら、シーケンスの長さが加算されます。最終的に、境界は 0 からシーケンスの長さまでに収まるように刈りこまれます。最後に、スライスを被代入オブジェクトで置き換えてよいかシーケンスオブジェクトに問い合わせます。ターゲットシーケンスで許されている限り、スライスの長さは被代入シーケンスの長さと異なっていてよく、この場合にはターゲットシーケンスの長さが変更されます。</p>
</li>
</ul>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> 現在の実装では、ターゲットの構文は式の構文と同じであるとみなされており、無効な構文はコード生成フェーズ中に詳細なエラーメッセージを伴って拒否されます。</p>
</div>
<p>代入の定義によれば、左辺と右辺のオーバーラップは '同時 (simultaneous)' です (例えば <code class="docutils literal notranslate"><span class="pre">a,</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">b,</span> <span class="pre">a</span></code> は二つの変数を入れ替えます) が、代入対象となる変数群 <em>どうし</em> のオーバーラップは左から右へ起こり、混乱の元です。例えば、以下のプログラムは <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">2]</span></code> を出力してしまいます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>         <span class="c1"># i is updated, then x[i] is updated</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-13"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3132"><strong>PEP 3132</strong></a> - Extended Iterable Unpacking</dt>
<dd><code class="docutils literal notranslate"><span class="pre">*target</span></code> の指定機能。</dd>
</dl>
</div>
<div class="section" id="augmented-assignment-statements">
<span id="augassign"></span><h3>7.2.1. 累算代入文 (augmented assignment statement)<a class="headerlink" href="#augmented-assignment-statements" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-14">累算代入文は、二項演算と代入文を組み合わせて一つの文にしたものです:</p>
<pre>
<strong id="grammar-token-augmented-assignment-stmt">augmented_assignment_stmt</strong> ::=  <a class="reference internal" href="#grammar-token-augtarget"><code class="xref docutils literal notranslate"><span class="pre">augtarget</span></code></a> <a class="reference internal" href="#grammar-token-augop"><code class="xref docutils literal notranslate"><span class="pre">augop</span></code></a> (<a class="reference internal" href="expressions.html#grammar-token-expression-list"><code class="xref docutils literal notranslate"><span class="pre">expression_list</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-yield-expression"><code class="xref docutils literal notranslate"><span class="pre">yield_expression</span></code></a>)
<strong id="grammar-token-augtarget">augtarget                </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-attributeref"><code class="xref docutils literal notranslate"><span class="pre">attributeref</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-subscription"><code class="xref docutils literal notranslate"><span class="pre">subscription</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-slicing"><code class="xref docutils literal notranslate"><span class="pre">slicing</span></code></a>
<strong id="grammar-token-augop">augop                    </strong> ::=  &quot;+=&quot; | &quot;-=&quot; | &quot;*=&quot; | &quot;&#64;=&quot; | &quot;/=&quot; | &quot;//=&quot; | &quot;%=&quot; | &quot;**=&quot;
                               | &quot;&gt;&gt;=&quot; | &quot;&lt;&lt;=&quot; | &quot;&amp;=&quot; | &quot;^=&quot; | &quot;|=&quot;
</pre>
<p>(最後の3つの構文定義については <a class="reference internal" href="expressions.html#primaries"><span class="std std-ref">プライマリ</span></a> を参照してください。)</p>
<p>累算代入文は、ターゲット (通常の代入文と違って、アンパックは起こりません) と式リストを評価し、それら二つの被演算子間で特定の累算代入型の二項演算を行い、結果をもとのターゲットに代入します。ターゲットは一度しか評価されません。</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">1</span></code> のような累算代入式は、 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code> のように書き換えてほぼ同様の動作にできますが、厳密に等価にはなりません。累算代入の方では、 <code class="docutils literal notranslate"><span class="pre">x</span></code> は一度しか評価されません。また、実際の処理として、可能ならば <em>インプレース (in-place)</em> 演算が実行されます。これは、代入時に新たなオブジェクトを生成してターゲットに代入するのではなく、以前のオブジェクトの内容を変更するということです。</p>
<p>通常の代入とは違い、累算代入文は右辺を評価する*前に*左辺を評価します。たとえば、<code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">+=</span> <span class="pre">f(x)</span></code> はまず <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> を調べ、<code class="docutils literal notranslate"><span class="pre">f(x)</span></code> を評価して加算を行い、最後に結果を <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> に割り当てます。</p>
<p>累算代入文で行われる代入は、タプルへの代入や、一文中に複数のターゲットが存在する場合を除き、通常の代入と同じように扱われます。同様に、累算代入で行われる二項演算は、場合によって <em>インプレース演算</em> が行われることを除き、通常の二項演算と同じです。</p>
<p>属性参照のターゲットの場合、 <a class="reference internal" href="#attr-target-note"><span class="std std-ref">クラス属性とインスタンス属性についての注意</span></a> と同様に通常の代入が適用されます。</p>
</div>
<div class="section" id="annotated-assignment-statements">
<span id="annassign"></span><h3>7.2.2. 注釈付き代入文 (annotated assignment statements)<a class="headerlink" href="#annotated-assignment-statements" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-15"><a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">注釈</span></a> 代入は、1 つの文の中で変数や属性のアノテーションとオプションの代入文を組み合わせたものです:</p>
<pre>
<strong id="grammar-token-annotated-assignment-stmt">annotated_assignment_stmt</strong> ::=  <a class="reference internal" href="#grammar-token-augtarget"><code class="xref docutils literal notranslate"><span class="pre">augtarget</span></code></a> &quot;:&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
                               [&quot;=&quot; (<a class="reference internal" href="expressions.html#grammar-token-starred-expression"><code class="xref docutils literal notranslate"><span class="pre">starred_expression</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-yield-expression"><code class="xref docutils literal notranslate"><span class="pre">yield_expression</span></code></a>)]
</pre>
<p>The difference from normal <a class="reference internal" href="#assignment"><span class="std std-ref">代入文 (assignment statement)</span></a> is that only single target is allowed.</p>
<p>代入先として単純名を使うと、クラススコープもしくはモジュールスコープの場合、注釈は評価され、クラスもしくはモジュールの特殊属性 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> に格納されます。
この属性は、変数名 (プライベート変数の場合はマングリングされた名前) から評価後の注釈への対応付けを持つ辞書です。
この属性は書き込み可能であり、注釈が静的に存在している場合、クラスもしくはモジュールの本体の実行の先頭で自動的に作成されます。</p>
<p>代入先として式を使うと、クラススコープもしくはモジュールスコープの場合、注釈は評価されますが、格納されません。</p>
<p>関数スコープで名前に注釈が付いていた場合は、その名前はその関数スコープでローカルなものになります。
注釈は絶対に評価されず、関数スコープにも格納されません。</p>
<p>右辺がある場合、注釈代入はアノテーション (有効であれば) を評価する前に、実際に代入を行います。
対象となる式の右辺が無い場合は、インタプリタは最後の <a class="reference internal" href="datamodel.html#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a> や <a class="reference internal" href="datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 呼び出し以外の対象の式を評価します。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-16"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a> - Syntax for Variable Annotations</dt>
<dd>(クラス変数やインスタンス変数を含んだ) 変数の型注釈を付ける、コメントで表現するのではない文法の追加提案。</dd>
<dt><span class="target" id="index-17"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> - Type hints</dt>
<dd><a class="reference internal" href="../library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> モジュールを追加し、静的解析ツールや IDE で使える型アノテーションの標準的な文法を提供する提案。</dd>
</dl>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.8 で変更: </span>Now annotated assignments allow same expressions in the right hand side as
the regular assignments. Previously, some expressions (like un-parenthesized
tuple expressions) caused a syntax error.</p>
</div>
</div>
</div>
<div class="section" id="the-assert-statement">
<span id="assert"></span><h2>7.3. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code> 文<a class="headerlink" href="#the-assert-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-18">assert 文は、プログラム内にデバッグ用アサーション (debugging assertion) を仕掛けるための便利な方法です:</p>
<pre>
<strong id="grammar-token-assert-stmt">assert_stmt</strong> ::=  &quot;assert&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> [&quot;,&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>]
</pre>
<p>単純な形式 <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">expression</span></code> は</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">expression</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">AssertionError</span>
</pre></div>
</div>
<p>と等価です。拡張形式 <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">expression1,</span> <span class="pre">expression2</span></code> は、これと等価です</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">expression1</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">expression2</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-19">上記の等価関係は、 <code class="docutils literal notranslate"><span class="pre">__debug__</span></code> と <a class="reference internal" href="../library/exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> が、同名の組み込み変数を参照しているという前提の上に成り立っています。現在の実装では、組み込み変数 <code class="docutils literal notranslate"><span class="pre">__debug__</span></code> は通常の状況では <code class="docutils literal notranslate"><span class="pre">True</span></code> であり、最適化が要求された場合（コマンドラインオプション <a class="reference internal" href="../using/cmdline.html#cmdoption-o"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a>）は <code class="docutils literal notranslate"><span class="pre">False</span></code> です。現状のコード生成器は、コンパイル時に最適化が要求されていると assert 文のコードを一切出力しません。実行に失敗した式のソースコードをエラーメッセージ内に入れる必要はありません; コードはスタックトレース内で表示されます。</p>
<p><a class="reference internal" href="../library/constants.html#__debug__" title="__debug__"><code class="xref py py-const docutils literal notranslate"><span class="pre">__debug__</span></code></a> への代入は不正な操作です。組み込み変数の値は、インタプリタが開始するときに決定されます。</p>
</div>
<div class="section" id="the-pass-statement">
<span id="pass"></span><h2>7.4. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">pass</span></code> 文<a class="headerlink" href="#the-pass-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-20">
<strong id="grammar-token-pass-stmt">pass_stmt</strong> ::=  &quot;pass&quot;
</pre>
<p><a class="reference internal" href="#pass"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">pass</span></code></a> はヌル操作 (null operation) です --- <a class="reference internal" href="#pass"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">pass</span></code></a> が実行されても、何も起きません。 <a class="reference internal" href="#pass"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">pass</span></code></a> は、構文法的には文が必要だが、コードとしては何も実行したくない場合のプレースホルダとして有用です。例えば:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span> <span class="k">pass</span>    <span class="c1"># a function that does nothing (yet)</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">:</span> <span class="k">pass</span>       <span class="c1"># a class with no methods (yet)</span>
</pre></div>
</div>
</div>
<div class="section" id="the-del-statement">
<span id="del"></span><h2>7.5. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code> 文<a class="headerlink" href="#the-del-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-21">
<strong id="grammar-token-del-stmt">del_stmt</strong> ::=  &quot;del&quot; <a class="reference internal" href="#grammar-token-target-list"><code class="xref docutils literal notranslate"><span class="pre">target_list</span></code></a>
</pre>
<p>オブジェクトの削除 (deletion) は、代入の定義と非常に似た方法で再帰的に定義されています。ここでは完全な詳細は記述せず、いくつかのヒントを述べるにとどめます。</p>
<p>ターゲットリストに対する削除は、各々のターゲットを左から右へと順に再帰的に削除します。</p>
<p id="index-22">名前の削除は、ローカルまたはグローバル名前空間からその名前の束縛を取り除きます。どちらの名前空間かは、名前が同じコードブロック内の <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 文で宣言されているかどうかによります。名前が未束縛 (unbound) なら、 <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> 例外が送出されます。</p>
<p id="index-23">属性参照、添字表記、およびスライスの削除操作は、対象となる一次語オブジェクトに渡されます; スライスの削除は一般的には適切な型の空のスライスを代入するのと等価です (が、この仕様自体もスライスされるオブジェクトで決定されています)。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span>以前は、ある名前がネストしたブロックの自由変数として表れる場合は、ローカル名前空間からその名前を削除することは不正な処理でした。</p>
</div>
</div>
<div class="section" id="the-return-statement">
<span id="return"></span><h2>7.6. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code> 文<a class="headerlink" href="#the-return-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-24">
<strong id="grammar-token-return-stmt">return_stmt</strong> ::=  &quot;return&quot; [<a class="reference internal" href="expressions.html#grammar-token-expression-list"><code class="xref docutils literal notranslate"><span class="pre">expression_list</span></code></a>]
</pre>
<p><a class="reference internal" href="#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> は、関数定義内で構文法的にネストして現れますが、ネストしたクラス定義内には現れません。</p>
<p>式リストがある場合、リストが値評価されます。それ以外の場合は <code class="docutils literal notranslate"><span class="pre">None</span></code> で置き換えられます。</p>
<p><a class="reference internal" href="#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> を使うと、式リスト (または <code class="docutils literal notranslate"><span class="pre">None</span></code>) を戻り値として、現在の関数呼び出しから抜け出します。</p>
<p id="index-25"><a class="reference internal" href="#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> によって、 <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 節をともなう <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 文の外に処理が引き渡されると、実際に関数から抜ける前に <code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code> 節が実行されます。</p>
<p>ジェネレータ関数では、 <a class="reference internal" href="#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 文はジェネレータの終わりを示し、 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 例外を送出させます。返された値は (あれば)、 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> を構成する引数に使われ、 <code class="xref py py-attr docutils literal notranslate"><span class="pre">StopIteration.value</span></code> 属性になります。</p>
<p>非同期ジェネレータ関数では、引数無しの <a class="reference internal" href="#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 文は非同期ジェネレータの終わりを示し、 <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> を送出させます。
引数ありの <code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code> 文は、非同期ジェネレータ関数では文法エラーです。</p>
</div>
<div class="section" id="the-yield-statement">
<span id="yield"></span><h2>7.7. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 文<a class="headerlink" href="#the-yield-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-26">
<strong id="grammar-token-yield-stmt">yield_stmt</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-yield-expression"><code class="xref docutils literal notranslate"><span class="pre">yield_expression</span></code></a>
</pre>
<p><a class="reference internal" href="#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 文は意味的に <a class="reference internal" href="expressions.html#yieldexpr"><span class="std std-ref">yield expression</span></a> 式と同じです。yield 文を用いると yield 式文で必要な括弧を省略することが出来ます。例えば、yield 文</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">yield</span> <span class="o">&lt;</span><span class="n">expr</span><span class="o">&gt;</span>
<span class="k">yield from</span> <span class="o">&lt;</span><span class="n">expr</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>は以下の yield 式文と等価です</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">yield</span> <span class="o">&lt;</span><span class="n">expr</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">(</span><span class="k">yield from</span> <span class="o">&lt;</span><span class="n">expr</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>yield 式及び文は <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a> を定義するときに、その本体内でのみ使うことが出来ます。関数定義内で yield を使用することで、その定義は通常の関数でなくジェネレータ関数になります。</p>
<p><a class="reference internal" href="#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> の意味の完全な説明は、 <a class="reference internal" href="expressions.html#yieldexpr"><span class="std std-ref">Yield 式</span></a> 節を参照してください。</p>
</div>
<div class="section" id="the-raise-statement">
<span id="raise"></span><h2>7.8. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code> 文<a class="headerlink" href="#the-raise-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-27">
<strong id="grammar-token-raise-stmt">raise_stmt</strong> ::=  &quot;raise&quot; [<a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> [&quot;from&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>]]
</pre>
<p>式を伴わなければ、 <a class="reference internal" href="#raise"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code></a> は現在のスコープで最終的に有効になっている例外を再送出します。そのような例外が現在のスコープでアクティブでない場合、 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 例外が送出されて、これがエラーであることを示します。</p>
<p>そうでなければ、 <a class="reference internal" href="#raise"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code></a> は最初の式を、例外オブジェクトとして評価します。これは、 <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseException</span></code></a> のサブクラスまたはインスタンスでなければなりません。クラスなら、例外インスタンスが必要なとき、クラスを無引数でインスタンス化することで得られます。</p>
<p>例外の <em class="dfn">型</em> は例外インスタンスのクラスで、 <em class="dfn">値</em> はインスタンスそのものです。</p>
<p id="index-28">トレースバックオブジェクトは通常、例外が送出される時に自動で作られ、その例外に書き込み可能の <code class="xref py py-attr docutils literal notranslate"><span class="pre">__traceback__</span></code> 属性として付与されます。 <code class="xref py py-meth docutils literal notranslate"><span class="pre">with_traceback()</span></code> 例外メソッド (トレースバックを引数に設定した同じ例外を返します) を使い、例外を作って独自のトレースバックを設定するのを一度に出来ます。このように:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;foo occurred&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">tracebackobj</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-29"><code class="docutils literal notranslate"><span class="pre">from</span></code> 節は例外の連鎖に使われます: 第二の <em>expression</em> は、与えられるなら、別の例外クラスまたはインスタンスでなければならず、これが送出された例外に (書き込み可能の) <code class="xref py py-attr docutils literal notranslate"><span class="pre">__cause__</span></code> 属性として付与されます。送出された例外がハンドルされなければ、両方の例外が印字されます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Something bad happened&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">exc</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ZeroDivisionError</span>: <span class="n">division by zero</span>

<span class="go">The above exception was the direct cause of the following exception:</span>

<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">4</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">RuntimeError</span>: <span class="n">Something bad happened</span>
</pre></div>
</div>
<p>例外ハンドラまたは <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 節の中で例外が送出された時も、同じような機構が暗黙に働きます。このとき、先に起こった例外が、新しい例外の <code class="xref py py-attr docutils literal notranslate"><span class="pre">__context__</span></code> 属性に付与されます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Something bad happened&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ZeroDivisionError</span>: <span class="n">division by zero</span>

<span class="go">During handling of the above exception, another exception occurred:</span>

<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">4</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">RuntimeError</span>: <span class="n">Something bad happened</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">from</span></code> 節に <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> を指定することで、例外の連鎖を明示的に非表示にできます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Something bad happened&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">4</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">RuntimeError</span>: <span class="n">Something bad happened</span>
</pre></div>
</div>
<p>例外に関する追加情報は <a class="reference internal" href="executionmodel.html#exceptions"><span class="std std-ref">例外</span></a> 節にあります。また、例外処理に関する情報は <a class="reference internal" href="compound_stmts.html#try"><span class="std std-ref">try 文</span></a> 節にあります。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span><a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> が <code class="docutils literal notranslate"><span class="pre">raise</span> <span class="pre">X</span> <span class="pre">from</span> <span class="pre">Y</span></code> の <code class="docutils literal notranslate"><span class="pre">Y</span></code> として使えるようになりました。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加: </span><code class="docutils literal notranslate"><span class="pre">__suppress_context__</span></code> 属性の設定で、例外のコンテキストが自動的に非表示になります。</p>
</div>
</div>
<div class="section" id="the-break-statement">
<span id="break"></span><h2>7.9. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code> 文<a class="headerlink" href="#the-break-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-30">
<strong id="grammar-token-break-stmt">break_stmt</strong> ::=  &quot;break&quot;
</pre>
<p><a class="reference internal" href="#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a> 文は、構文としては <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> ループや <a class="reference internal" href="compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> ループの内側でのみ出現することができますが、ループ内の関数定義やクラス定義の内側には出現できません。</p>
<p id="index-31"><a class="reference internal" href="#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a> 文は、文を囲う最も内側のループを終了させ、ループにオプションの <code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code> 節がある場合にはそれをスキップします。</p>
<p><a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> ループを <a class="reference internal" href="#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a> によって終了すると、ループ制御ターゲットはその時の値を保持します。</p>
<p id="index-32"><a class="reference internal" href="#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a> が <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 節を伴う <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 文の外側に処理を渡す際には、ループを実際に抜ける前にその <code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code> 節が実行されます。</p>
</div>
<div class="section" id="the-continue-statement">
<span id="continue"></span><h2>7.10. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code> 文<a class="headerlink" href="#the-continue-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-33">
<strong id="grammar-token-continue-stmt">continue_stmt</strong> ::=  &quot;continue&quot;
</pre>
<p><a class="reference internal" href="#continue"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code></a> may only occur syntactically nested in a <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> or
<a class="reference internal" href="compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> loop, but not nested in a function or class definition within
that loop.  It continues with the next cycle of the nearest enclosing loop.</p>
<p><a class="reference internal" href="#continue"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code></a> が <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 句を持った <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 文を抜けるとき、その <code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code> 句が次のループサイクルを始める前に実行されます。</p>
</div>
<div class="section" id="the-import-statement">
<span id="from"></span><span id="import"></span><h2>7.11. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 文<a class="headerlink" href="#the-import-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-34">
<strong id="grammar-token-import-stmt">import_stmt    </strong> ::=  &quot;import&quot; <a class="reference internal" href="#grammar-token-module"><code class="xref docutils literal notranslate"><span class="pre">module</span></code></a> [&quot;as&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>] (&quot;,&quot; <a class="reference internal" href="#grammar-token-module"><code class="xref docutils literal notranslate"><span class="pre">module</span></code></a> [&quot;as&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>])*
                     | &quot;from&quot; <a class="reference internal" href="#grammar-token-relative-module"><code class="xref docutils literal notranslate"><span class="pre">relative_module</span></code></a> &quot;import&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> [&quot;as&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>]
                     (&quot;,&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> [&quot;as&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>])*
                     | &quot;from&quot; <a class="reference internal" href="#grammar-token-relative-module"><code class="xref docutils literal notranslate"><span class="pre">relative_module</span></code></a> &quot;import&quot; &quot;(&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> [&quot;as&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>]
                     (&quot;,&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> [&quot;as&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>])* [&quot;,&quot;] &quot;)&quot;
                     | &quot;from&quot; <a class="reference internal" href="#grammar-token-module"><code class="xref docutils literal notranslate"><span class="pre">module</span></code></a> &quot;import&quot; &quot;*&quot;
<strong id="grammar-token-module">module         </strong> ::=  (<a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> &quot;.&quot;)* <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>
<strong id="grammar-token-relative-module">relative_module</strong> ::=  &quot;.&quot;* <a class="reference internal" href="#grammar-token-module"><code class="xref docutils literal notranslate"><span class="pre">module</span></code></a> | &quot;.&quot;+
</pre>
<p>(<a class="reference internal" href="#from"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> 節が無い) 基本の import 文は 2 つのステップで実行されます:</p>
<ol class="arabic simple">
<li>モジュールを見付け出し、必要であればロードし初期化する</li>
<li><a class="reference internal" href="#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 文が表れるスコープのローカル名前空間で名前を定義する。</li>
</ol>
<p>文が (カンマで区切られた) 複数の節を含んでいるときは、ちょうどその節が個別の import 文に分割されたかのように、2つのステップが節ごとに個別に実行されます。</p>
<p>モジュールを見付け、ロードする 1 つ目のステップの詳細については、 <a class="reference internal" href="import.html#importsystem"><span class="std std-ref">インポートシステム</span></a> の節により詳しく書かれています。そこでは、インポートシステムの動作をカスタマイズするのに使える全てのフックの仕組みだけでなく、様々な種類のインポートできるパッケージとモジュールについても解説されています。このステップが失敗するということは、おそらくモジュールが見付からないか、 <em>あるいは</em> モジュールにあるコードの実行を含め、モジュールの初期化の途中でエラーが起きるかのどちらかが起きていることに注意してください。</p>
<p>要求したモジュールが無事に取得できた場合、次の 3 つのうちの 1 つの方法でローカル名前空間で使えるようになります:</p>
<ul class="simple" id="index-35">
<li>モジュール名の後に <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> が続いていた場合は、 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> の後ろの名前を直接、インポートされたモジュールが束縛します。</li>
<li>他の名前が指定されておらず、インポートされているモジュールが最上位のモジュールだった場合、そのモジュール名がインポートされたモジュールへの参照として、ローカル名前空間で束縛されます</li>
<li>インポートされているモジュールが最上位のモジュール <em>でない</em> 場合、モジュールを含む最上位のパッケージ名が、そのパッケージへの参照として、ローカル名前空間で束縛されます。インポートされたモジュールには、直接ではなく完全修飾名を使ってアクセスしなければなりません</li>
</ul>
<p id="index-36"><a class="reference internal" href="#from"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> 形式ではもう少し複雑な手順を踏みます:</p>
<ol class="arabic simple">
<li><a class="reference internal" href="#from"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> 節で指定されたモジュールを見付け出し、必要であればロードし初期化する;</li>
<li><a class="reference internal" href="#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 節で指定されたそれぞれの識別子に対し以下の処理を行う:<ol class="arabic">
<li>インポートされたモジュールがその識別子名の属性を持っているかを確認する</li>
<li>その識別子名の属性を持っていなかった場合は、その識別子名でサブモジュールのインポートを試み、インポートされたモジュールにその属性があるか再度確認する</li>
<li>属性が見付からない場合は、 <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> を送出する。</li>
<li>属性が見付かった場合は、 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> 節があるならそこの名前、そうでないなら属性名を使って、その値への参照がローカル名前空間に保存される</li>
</ol>
</li>
</ol>
<p>例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">foo</span>                 <span class="c1"># foo imported and bound locally</span>
<span class="kn">import</span> <span class="nn">foo.bar.baz</span>         <span class="c1"># foo.bar.baz imported, foo bound locally</span>
<span class="kn">import</span> <span class="nn">foo.bar.baz</span> <span class="k">as</span> <span class="nn">fbb</span>  <span class="c1"># foo.bar.baz imported and bound as fbb</span>
<span class="kn">from</span> <span class="nn">foo.bar</span> <span class="kn">import</span> <span class="n">baz</span>    <span class="c1"># foo.bar.baz imported and bound as baz</span>
<span class="kn">from</span> <span class="nn">foo</span> <span class="kn">import</span> <span class="n">attr</span>       <span class="c1"># foo imported and foo.attr bound as attr</span>
</pre></div>
</div>
<p id="index-37">識別子のリストが星 (<code class="docutils literal notranslate"><span class="pre">'*'</span></code>) に置き換わっている場合は、モジュールで定義されている公開された全ての名前が、 <a class="reference internal" href="#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 文がいるスコープのローカル名前空間に束縛されます。</p>
<p id="index-38">モジュールで定義される <em>公開された名前</em> は、モジュールの名前空間にある <code class="docutils literal notranslate"><span class="pre">__all__</span></code> という名前の変数を調べることで決定されます; その変数が定義されている場合は、それはモジュールで定義されたかインポートされた名前からなる、文字列のシーケンスでなければいけません。<code class="docutils literal notranslate"><span class="pre">__all__</span></code> で列挙された名前は、全て公開されていると見なされ、存在することが要求されます。<code class="docutils literal notranslate"><span class="pre">__all__</span></code> が定義されていない場合、公開された名前とは、モジュールの名前空間で見付かった、アンダースコア文字 (<code class="docutils literal notranslate"><span class="pre">'_'</span></code>) で始まらない全ての名前のことです。<code class="docutils literal notranslate"><span class="pre">__all__</span></code> は全ての公開 API を含むべきです。これは API の一部でないもの (そのモジュールでインポートされ使われているライブラリモジュールなど) をうっかり外部に公開してしまわないための仕組みです。</p>
<p>インポートのワイルドカード形式 --- <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> --- は、モジュールレベルでのみ許されます。クラスや関数定義でこの形式を使おうとすると、 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> が送出されます。</p>
<p id="index-39">インポートするモジュールを指定するとき、そのモジュールの絶対名 (absolute name) を指定する必要はありません。モジュールやパッケージが他のパッケージに含まれている場合、共通のトップパッケージからそのパッケージ名を記述することなく相対インポートすることができます。 <a class="reference internal" href="#from"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> の後に指定されるモジュールやパッケージの先頭に複数個のドットを付けることで、正確な名前を指定することなしに現在のパッケージ階層からいくつ上の階層へ行くかを指定することができます。先頭のドットが 1 つの場合、 import をおこなっているモジュールが存在する現在のパッケージを示します。 3 つのドットは 2 つ上のレベルを示します。なので、 <code class="docutils literal notranslate"><span class="pre">pkg</span></code> パッケージの中のモジュールで <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">.</span> <span class="pre">import</span> <span class="pre">mod</span></code> を実行すると、 <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code> をインポートすることになります。 <code class="docutils literal notranslate"><span class="pre">pkg.subpkg1</span></code> の中から <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">..subpkg2</span> <span class="pre">import</span> <span class="pre">mod</span></code> を実行すると、 <code class="docutils literal notranslate"><span class="pre">pkg.subpkg2.mod</span></code> をインポートします。相対インポートの仕様は <a class="reference internal" href="import.html#relativeimports"><span class="std std-ref">Package Relative Imports</span></a> の節に含まれています。</p>
<p>どのモジュールがロードされるべきかを動的に決めたいアプリケーションのために、組み込み関数 <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> が提供されています。</p>
<p class="audit-hook">Raises an <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">import</span></code> with arguments <code class="docutils literal notranslate"><span class="pre">module</span></code>, <code class="docutils literal notranslate"><span class="pre">filename</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.meta_path</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.path_hooks</span></code>.</p>
<div class="section" id="future-statements">
<span id="future"></span><h3>7.11.1. future 文 (future statement)<a class="headerlink" href="#future-statements" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-40"><em class="dfn">future 文</em> は、将来の特定の新たな機能が標準化された Python のリリースで利用可能になるような構文や意味付けを使って、特定のモジュールをコンパイルさせるための、コンパイラに対する指示句 (directive) です。</p>
<p>future 文は互換性のない変更がされた将来の Python のバージョンに容易に移行するためのものです。future 文によって新機能が標準となるリリースの前にそれをモジュール単位で使用することが出来ます。</p>
<pre>
<strong id="grammar-token-future-stmt">future_stmt</strong> ::=  &quot;from&quot; &quot;__future__&quot; &quot;import&quot; <a class="reference internal" href="#grammar-token-feature"><code class="xref docutils literal notranslate"><span class="pre">feature</span></code></a> [&quot;as&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>]
                 (&quot;,&quot; <a class="reference internal" href="#grammar-token-feature"><code class="xref docutils literal notranslate"><span class="pre">feature</span></code></a> [&quot;as&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>])*
                 | &quot;from&quot; &quot;__future__&quot; &quot;import&quot; &quot;(&quot; <a class="reference internal" href="#grammar-token-feature"><code class="xref docutils literal notranslate"><span class="pre">feature</span></code></a> [&quot;as&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>]
                 (&quot;,&quot; <a class="reference internal" href="#grammar-token-feature"><code class="xref docutils literal notranslate"><span class="pre">feature</span></code></a> [&quot;as&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>])* [&quot;,&quot;] &quot;)&quot;
<strong id="grammar-token-feature">feature    </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>
</pre>
<p>future 文は、モジュールの先頭周辺に書かなければなりません。 future 文の前に書いてよい内容は以下です :</p>
<ul class="simple">
<li>モジュールのドキュメンテーション文字列 ( あれば )</li>
<li>コメント ,</li>
<li>空行 ,</li>
<li>その他の future 文。</li>
</ul>
<p>future 文を使う必要がある Python 3.7 の唯一の機能は <code class="docutils literal notranslate"><span class="pre">annotations</span></code> です。</p>
<p>future 文で有効にできる歴史的な機能は、今でも Python 3 が認識します。
そのリストは <code class="docutils literal notranslate"><span class="pre">absolute_import</span></code>, <code class="docutils literal notranslate"><span class="pre">division</span></code>, <code class="docutils literal notranslate"><span class="pre">generator_stop</span></code>, <code class="docutils literal notranslate"><span class="pre">generators</span></code>, <code class="docutils literal notranslate"><span class="pre">unicode_literals</span></code>, <code class="docutils literal notranslate"><span class="pre">print_function</span></code>, <code class="docutils literal notranslate"><span class="pre">nested_scopes</span></code>, <code class="docutils literal notranslate"><span class="pre">with_statement</span></code> です。
これらは既に全てが有効になっていて、後方互換性のためだけに残されているため、冗長なだけです。</p>
<p>future 文は、コンパイル時に特別なやり方で認識され、扱われます: 言語の中核をなす構文構成 (construct) に対する意味付けが変更されている場合、変更部分はしばしば異なるコードを生成することで実現されています。新たな機能によって、(新たな予約語のような) 互換性のない新たな構文が取り入れられることさえあります。この場合、コンパイラはモジュールを別のやりかたで解析する必要があるかもしれません。こうしたコード生成に関する決定は、実行時まで先延ばしすることはできません。</p>
<p>これまでの全てのリリースにおいて、コンパイラはどの機能が定義済みかを知っており、 future 文に未知の機能が含まれている場合にはコンパイル時エラーを送出します。</p>
<p>future 文の実行時における直接的な意味付けは、 import 文と同じです。標準モジュール <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a> があり、これについては後で述べます。 <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a> は、 future 文が実行される際に通常の方法で import されます。</p>
<p>future 文の実行時における特別な意味付けは、 future 文で有効化される特定の機能によって変わります。</p>
<p>以下の文には、何ら特殊な意味はないので注意してください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">__future__</span> <span class="p">[</span><span class="k">as</span> <span class="n">name</span><span class="p">]</span>
</pre></div>
</div>
<p>これは future 文ではありません; この文は通常の import 文であり、その他の特殊な意味付けや構文的な制限はありません。</p>
<p>future 文の入ったモジュール <code class="xref py py-mod docutils literal notranslate"><span class="pre">M</span></code> 内で使われている組み込み関数 <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> や <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> によってコンパイルされるコードは、デフォルトの設定では、 future 文に関係する新たな構文や意味付けを使うようになっています。この仕様は <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> のオプション引数で制御できます --- 詳細はこの関数に関するドキュメントを参照してください。</p>
<p>対話的インタプリタのプロンプトでタイプ入力した future 文は、その後のインタプリタセッション中で有効になります。インタプリタを <a class="reference internal" href="../using/cmdline.html#cmdoption-i"><code class="xref std std-option docutils literal notranslate"><span class="pre">-i</span></code></a> オプションで起動して実行すべきスクリプト名を渡し、スクリプト中に future 文を入れておくと、新たな機能はスクリプトが実行された後に開始する対話セッションで有効になります。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-41"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0236"><strong>PEP 236</strong></a> - Back to the __future__</dt>
<dd>__future__ 機構の原案</dd>
</dl>
</div>
</div>
</div>
<div class="section" id="the-global-statement">
<span id="global"></span><h2>7.12. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code> 文<a class="headerlink" href="#the-global-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-42">
<strong id="grammar-token-global-stmt">global_stmt</strong> ::=  &quot;global&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> (&quot;,&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>)*
</pre>
<p><a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 文は、現在のコードブロック全体で維持される宣言文です。 <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 文は、列挙した識別子をグローバル変数として解釈するよう指定することを意味します。 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code> を使わずにグローバル変数に代入を行うことは不可能ですが、自由変数を使えばその変数をグローバルであると宣言せずにグローバル変数を参照することができます。</p>
<p><a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 文で列挙する名前は、同じコードブロック中で、プログラムテキスト上 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code> 文より前に使ってはなりません。</p>
<p><a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 文で列挙する名前は、 <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> ループのループ制御ターゲットや、 <a class="reference internal" href="compound_stmts.html#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a> 定義、関数定義、 <a class="reference internal" href="#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 文、変数アノテーションで仮引数として使ってはなりません。</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> 現在の実装では、これらの制限のうち幾つかについては強制していませんが、プログラムでこの緩和された仕様を乱用すべきではありません。将来の実装では、この制限を強制したり、暗黙のうちにプログラムの意味付けを変更したりする可能性があります。</p>
</div>
<p id="index-43"><strong>プログラマのための注意点:</strong> <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> はパーザに対する指示句 (directive) です。この指示句は、 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code> 文と同時に読み込まれたコードに対してのみ適用されます。特に、組み込みの <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 関数内に入っている <code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code> 文は、関数の呼び出しを <em>含んでいる</em> コードブロック内に効果を及ぼすことはなく、そのような文字列に含まれているコードは、関数の呼び出しを含むコード内の <code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code> 文に影響を受けません。同様のことが、関数 <a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> および <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> にも当てはまります。</p>
</div>
<div class="section" id="the-nonlocal-statement">
<span id="nonlocal"></span><h2>7.13. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code> 文<a class="headerlink" href="#the-nonlocal-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-44">
<strong id="grammar-token-nonlocal-stmt">nonlocal_stmt</strong> ::=  &quot;nonlocal&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> (&quot;,&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>)*
</pre>
<p><a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 文は、列挙された識別子がグローバルを除く一つ外側のスコープで先に束縛された変数を参照するようにします。これは、束縛のデフォルトの動作がまずローカル名前空間を探索するので重要です。この文は、中にあるコードが、グローバル (モジュール) スコープ以外のローカルスコープの外側の変数を再束縛できるようにします。</p>
<p><a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 文で列挙された名前は、 <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 文で列挙された名前と違い、外側のスコープですでに存在する束縛を参照しなければなりません (新しい束縛が作られるべきスコープの選択が曖昧さを排除できません)。</p>
<p><a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 文で列挙された名前は、ローカルスコープですでに存在する束縛と衝突してはなりません。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-45"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3104"><strong>PEP 3104</strong></a> - Access to Names in Outer Scopes</dt>
<dd><a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 文の詳細。</dd>
</dl>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">7. 単純文 (simple statement)</a><ul>
<li><a class="reference internal" href="#expression-statements">7.1. 式文 (expression statement)</a></li>
<li><a class="reference internal" href="#assignment-statements">7.2. 代入文 (assignment statement)</a><ul>
<li><a class="reference internal" href="#augmented-assignment-statements">7.2.1. 累算代入文 (augmented assignment statement)</a></li>
<li><a class="reference internal" href="#annotated-assignment-statements">7.2.2. 注釈付き代入文 (annotated assignment statements)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-assert-statement">7.3. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code> 文</a></li>
<li><a class="reference internal" href="#the-pass-statement">7.4. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">pass</span></code> 文</a></li>
<li><a class="reference internal" href="#the-del-statement">7.5. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code> 文</a></li>
<li><a class="reference internal" href="#the-return-statement">7.6. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code> 文</a></li>
<li><a class="reference internal" href="#the-yield-statement">7.7. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 文</a></li>
<li><a class="reference internal" href="#the-raise-statement">7.8. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code> 文</a></li>
<li><a class="reference internal" href="#the-break-statement">7.9. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code> 文</a></li>
<li><a class="reference internal" href="#the-continue-statement">7.10. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code> 文</a></li>
<li><a class="reference internal" href="#the-import-statement">7.11. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 文</a><ul>
<li><a class="reference internal" href="#future-statements">7.11.1. future 文 (future statement)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-global-statement">7.12. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code> 文</a></li>
<li><a class="reference internal" href="#the-nonlocal-statement">7.13. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code> 文</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="expressions.html"
                        title="前の章へ">6. 式 (expression)</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="compound_stmts.html"
                        title="次の章へ">8. 複合文 (compound statement)</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.8/Doc/reference/simple_stmts.rst"
            rel="nofollow">ソースコードを表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="compound_stmts.html" title="8. 複合文 (compound statement)"
             >次へ</a> |</li>
        <li class="right" >
          <a href="expressions.html" title="6. 式 (expression)"
             >前へ</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.3 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 言語リファレンス</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" type="text" name="q" />
          <input type="submit" value="検索" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">著作権</a> 2001-2020, Python Software Foundation.
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最終更新: 5月 15, 2020
    <a href="https://docs.python.org/3/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>

  </body>
</html>