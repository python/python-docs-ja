
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>logging --- Python 用ロギング機能 &#8212; Python 3.8.3 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.8.3 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="next" title="logging.config --- ロギングの環境設定" href="logging.config.html" />
    <link rel="prev" title="getopt --- C 言語スタイルのコマンドラインオプションパーサ" href="getopt.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/logging.html" />
    
      
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="logging.config.html" title="logging.config --- ロギングの環境設定"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="getopt.html" title="getopt --- C 言語スタイルのコマンドラインオプションパーサ"
             accesskey="P">前へ</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.3 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" accesskey="U">汎用オペレーティングシステムサービス</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" type="text" name="q" />
          <input type="submit" value="検索" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-logging">
<span id="logging-logging-facility-for-python"></span><h1><a class="reference internal" href="#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> --- Python 用ロギング機能<a class="headerlink" href="#module-logging" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p><strong>ソースコード:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/logging/__init__.py">Lib/logging/__init__.py</a></p>
<div class="sidebar" id="index-0">
<p class="first sidebar-title">Important</p>
<p>このページには、リファレンス情報だけが含まれています。チュートリアルは、以下のページを参照してください</p>
<ul class="last simple">
<li><a class="reference internal" href="../howto/logging.html#logging-basic-tutorial"><span class="std std-ref">基本チュートリアル</span></a></li>
<li><a class="reference internal" href="../howto/logging.html#logging-advanced-tutorial"><span class="std std-ref">上級チュートリアル</span></a></li>
<li><a class="reference internal" href="../howto/logging-cookbook.html#logging-cookbook"><span class="std std-ref">ロギングクックブック</span></a></li>
</ul>
</div>
<hr class="docutils" />
<p>このモジュールは、アプリケーションやライブラリのための柔軟なエラーログ記録 (logging) システムを実装するための関数やクラスを定義しています。</p>
<p>標準ライブラリモジュールとしてログ記録 API が提供される利点は、すべての Python モジュールがログ記録に参加できることであり、これによってあなたが書くアプリケーションのログにサードパーティーのモジュールが出力するメッセージを含ませることができます。</p>
<p>このモジュールは、多くの機能性と柔軟性を提供します。ロギングに慣れていないなら、つかむのに一番いいのはチュートリアルを読むことです (右のリンクを参照してください)。</p>
<p>モジュールで定義されている基本的なクラスと関数を、以下に列挙します。</p>
<ul class="simple">
<li>ロガーは、アプリケーションコードが直接使うインタフェースを公開します。</li>
<li>ハンドラは、(ロガーによって生成された) ログ記録を適切な送信先に送ります。</li>
<li>フィルタは、どのログ記録を出力するかを決定する、きめ細かい機能を提供します。</li>
<li>フォーマッタは、ログ記録が最終的に出力されるレイアウトを指定します。</li>
</ul>
<div class="section" id="logger-objects">
<span id="logger"></span><h2>ロガーオブジェクト<a class="headerlink" href="#logger-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ロガーには以下のような属性とメソッドがあります。
ロガーを直接インスタンス化することは <em>絶対に</em> してはならず、常にモジュール関数 <code class="docutils literal notranslate"><span class="pre">logging.getLogger(name)</span></code> を介してインスタンス化することに注意してください。
同じ name で <a class="reference internal" href="#logging.getLogger" title="logging.getLogger"><code class="xref py py-func docutils literal notranslate"><span class="pre">getLogger()</span></code></a> を複数回呼び出すと、常に同じロガー・オブジェクトへの参照が返されます。</p>
<p><code class="docutils literal notranslate"><span class="pre">name</span></code> は <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code> のようにピリオドで分割された (ただし単なるプレーンな <code class="docutils literal notranslate"><span class="pre">foo</span></code> もありえます) 潜在的に階層的な値です。階層リスト中でより下位のロガーは、上位のロガーの子です。例えば、<code class="docutils literal notranslate"><span class="pre">foo</span></code> という名前を持つロガーがあるとき、<code class="docutils literal notranslate"><span class="pre">foo.bar</span></code>, <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code>, <code class="docutils literal notranslate"><span class="pre">foo.bam</span></code> という名前を持つロガーはすべて <code class="docutils literal notranslate"><span class="pre">foo</span></code> の子孫です。ロガー名の階層は Python パッケージ階層と類似していて、推奨される構築方法 <code class="docutils literal notranslate"><span class="pre">logging.getLogger(__name__)</span></code> を使用してロガーをモジュール単位で構成すれば、Python パッケージ階層と同一になります。これは、モジュールの中では <code class="docutils literal notranslate"><span class="pre">__name__</span></code> が Python パッケージ名前空間におけるモジュール名だからです。</p>
<dl class="class">
<dt id="logging.Logger">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">Logger</code><a class="headerlink" href="#logging.Logger" title="この定義へのパーマリンク">¶</a></dt>
<dd><dl class="attribute">
<dt id="logging.Logger.propagate">
<code class="descname">propagate</code><a class="headerlink" href="#logging.Logger.propagate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この属性が真と評価された場合、このロガーに記録されたイベントは、このロガーに取り付けられた全てのハンドラに加え、上位 (祖先) ロガーのハンドラにも渡されます。
メッセージは、祖先ロガーのハンドラに直接渡されます - 今問題にしている祖先ロガーのレベルもフィルタも、どちらも考慮されません。</p>
<p>この値の評価結果が偽になる場合、ロギングメッセージは祖先ロガーのハンドラに渡されません。</p>
<p>コンストラクタはこの属性を <code class="docutils literal notranslate"><span class="pre">True</span></code> に設定します。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">ハンドラを、あるロガー <em>と</em> その祖先のロガーに接続した場合、同一レコードが複数回発行される場合があります。一般的に、ハンドラを複数のロガーに接続する必要はありません。propagate 設定が <code class="docutils literal notranslate"><span class="pre">True</span></code> のままになっていれば、ロガーの階層において最上位にある適切なロガーにハンドラを接続するだけで、そのハンドラは全ての子孫ロガーが記録する全てのイベントを確認することができます。一般的なシナリオでは、ハンドラをルートロガーに対してのみ接続し、残りは propagate にすべて委ねます。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.setLevel">
<code class="descname">setLevel</code><span class="sig-paren">(</span><em>level</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.setLevel" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このロガーの閾値を <em>level</em> に設定します。
<em>level</em> よりも深刻でないログメッセージは無視されます; 深刻さが <em>level</em> 以上のログメッセージは、ハンドラのレベルが <em>level</em> より上に設定されていない限り、このロガーに取り付けられているハンドラによって投げられます。</p>
<p>ロガーが生成された際、レベルは <code class="xref py py-const docutils literal notranslate"><span class="pre">NOTSET</span></code> (これによりすべてのメッセージについて、ロガーがルートロガーであれば処理される、そうでなくてロガーが非ルートロガーの場合には親ロガーに委譲させる) に設定されます。
ルートロガーは <code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code> レベルで生成されることに注意してください。</p>
<p>「親ロガーに委譲」という用語の意味は、もしロガーのレベルが NOTSET ならば、祖先ロガーの系列の中を NOTSET 以外のレベルの祖先を見つけるかルートに到達するまで辿っていく、ということです。</p>
<p>もし NOTSET 以外のレベルの祖先が見つかったなら、その祖先のレベルが探索を開始したロガーの実効レベルとして扱われ、ログイベントがどのように処理されるかを決めるのに使われます。</p>
<p>ルートに到達した場合、ルートのレベルが NOTSET ならばすべてのメッセージは処理されます。そうでなければルートのレベルが実効レベルとして使われます。</p>
<p>レベルの一覧については <a class="reference internal" href="#levels"><span class="std std-ref">ロギングレベル</span></a> を参照してください。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span><em>level</em> パラメータは、 <code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code> のような整数定数の代わりに 'INFO' のようなレベルの文字列表現も受け付けるようになりました。ただし、レベルは内部で整数として保存されますし、 <a class="reference internal" href="#logging.Logger.getEffectiveLevel" title="logging.Logger.getEffectiveLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getEffectiveLevel()</span></code></a> や <a class="reference internal" href="#logging.Logger.isEnabledFor" title="logging.Logger.isEnabledFor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isEnabledFor()</span></code></a> といったメソッドは、整数を返し、また渡されるものと期待します。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.isEnabledFor">
<code class="descname">isEnabledFor</code><span class="sig-paren">(</span><em>level</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.isEnabledFor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Indicates if a message of severity <em>level</em> would be processed by this logger.
This method checks first the module-level level set by
<code class="docutils literal notranslate"><span class="pre">logging.disable(level)</span></code> and then the logger's effective level as determined
by <a class="reference internal" href="#logging.Logger.getEffectiveLevel" title="logging.Logger.getEffectiveLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getEffectiveLevel()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.getEffectiveLevel">
<code class="descname">getEffectiveLevel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.getEffectiveLevel" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このロガーの実効レベルを示します。 <code class="xref py py-const docutils literal notranslate"><span class="pre">NOTSET</span></code> 以外の値が <a class="reference internal" href="#logging.Logger.setLevel" title="logging.Logger.setLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLevel()</span></code></a> で設定されていた場合、その値が返されます。そうでない場合、 <code class="xref py py-const docutils literal notranslate"><span class="pre">NOTSET</span></code> 以外の値が見つかるまでロガーの階層をルートロガーの方向に追跡します。見つかった場合、その値が返されます。返される値は整数で、典型的には <code class="xref py py-const docutils literal notranslate"><span class="pre">logging.DEBUG</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">logging.INFO</span></code> 等のうち一つです。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.getChild">
<code class="descname">getChild</code><span class="sig-paren">(</span><em>suffix</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.getChild" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このロガーの子であるロガーを、接頭辞によって決定し、返します。従って、<code class="docutils literal notranslate"><span class="pre">logging.getLogger('abc').getChild('def.ghi')</span></code> は、<code class="docutils literal notranslate"><span class="pre">logging.getLogger('abc.def.ghi')</span></code> によって返されるのと同じロガーを返すことになります。これは簡便なメソッドで、親ロガーがリテラルでなく <code class="docutils literal notranslate"><span class="pre">__name__</span></code> などを使って名付けられているときに便利です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.debug">
<code class="descname">debug</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.debug" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Logs a message with level <code class="xref py py-const docutils literal notranslate"><span class="pre">DEBUG</span></code> on this logger. The <em>msg</em> is the
message format string, and the <em>args</em> are the arguments which are merged into
<em>msg</em> using the string formatting operator. (Note that this means that you can
use keywords in the format string, together with a single dictionary argument.)
No % formatting operation is performed on <em>msg</em> when no <em>args</em> are supplied.</p>
<p>There are four keyword arguments in <em>kwargs</em> which are inspected:
<em>exc_info</em>, <em>stack_info</em>, <em>stacklevel</em> and <em>extra</em>.</p>
<p><em>exc_info</em> は、この値の評価値が false でない場合、例外情報がロギングメッセージに追加されます。もし例外情報をあらわすタプル(<a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 関数によって戻されるフォーマットにおいて)、または、例外情報をあらわすインスタンスが与えられていれば、それが使用されることになります。それ以外の場合には、 <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> を呼び出して例外情報を取得します。</p>
<p>2つ目の省略可能なキーワード引数は <em>stack_info</em> で、デフォルトは <code class="docutils literal notranslate"><span class="pre">False</span></code> です。真の場合、実際のロギング呼び出しを含むスタック情報がロギングメッセージに追加されます。これは <em>exc_info</em> 指定によって表示されるスタック情報と同じものではないことに注意してください: 前者はカレントスレッド内での、一番下からロギング呼び出しまでのスタックフレームですが、後者は例外に呼応して、例外ハンドラが見つかるところまで巻き戻されたスタックフレームの情報です。</p>
<p><em>exc_info</em> とは独立に <em>stack_info</em> を指定することもできます (例えば、例外が上げられなかった場合でも、コード中のある地点にどのように到着したかを単に示すために)。スタックフレームは、次のようなヘッダー行に続いて表示されます:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Stack (most recent call last):
</pre></div>
</div>
<p>これは、例外フレームを表示する場合に使用される <code class="docutils literal notranslate"><span class="pre">Traceback</span> <span class="pre">(most</span> <span class="pre">recent</span> <span class="pre">call</span> <span class="pre">last):</span></code> を模倣します。</p>
<p>The third optional keyword argument is <em>stacklevel</em>, which defaults to <code class="docutils literal notranslate"><span class="pre">1</span></code>.
If greater than 1, the corresponding number of stack frames are skipped
when computing the line number and function name set in the <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a>
created for the logging event. This can be used in logging helpers so that
the function name, filename and line number recorded are not the information
for the helper function/method, but rather its caller. The name of this
parameter mirrors the equivalent one in the <a class="reference internal" href="warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal notranslate"><span class="pre">warnings</span></code></a> module.</p>
<p>The fourth keyword argument is <em>extra</em> which can be used to pass a
dictionary which is used to populate the __dict__ of the <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a>
created for the logging event with user-defined attributes. These custom
attributes can then be used as you like. For example, they could be
incorporated into logged messages. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">FORMAT</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%(asctime)-15s</span><span class="s1"> </span><span class="si">%(clientip)s</span><span class="s1"> </span><span class="si">%(user)-8s</span><span class="s1"> </span><span class="si">%(message)s</span><span class="s1">&#39;</span>
<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="n">FORMAT</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;clientip&#39;</span><span class="p">:</span> <span class="s1">&#39;192.168.0.1&#39;</span><span class="p">,</span> <span class="s1">&#39;user&#39;</span><span class="p">:</span> <span class="s1">&#39;fbloggs&#39;</span><span class="p">}</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;tcpserver&#39;</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Protocol problem: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;connection reset&#39;</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<p>これは以下のような出力を行います</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset
</pre></div>
</div>
<p><em>extra</em> で渡される辞書のキーはロギングシステムで使われているものと衝突しないようにしなければなりません。 (どのキーがロギングシステムで使われているかについての詳細は <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> のドキュメントを参照してください。)</p>
<p>If you choose to use these attributes in logged messages, you need to exercise
some care. In the above example, for instance, the <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> has been
set up with a format string which expects 'clientip' and 'user' in the attribute
dictionary of the <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a>. If these are missing, the message will
not be logged because a string formatting exception will occur. So in this case,
you always need to pass the <em>extra</em> dictionary with these keys.</p>
<p>このようなことは煩わしいかもしれませんが、この機能は限定された場面で使われるように意図しているものなのです。たとえば同じコードがいくつものコンテキストで実行されるマルチスレッドのサーバで、興味のある条件が現れるのがそのコンテキストに依存している (上の例で言えば、リモートのクライアント IP アドレスや認証されたユーザ名など)、というような場合です。そういった場面では、それ用の <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> が特定の <a class="reference internal" href="#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handler</span></code></a> と共に使われるというのはよくあることです。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span><em>stack_info</em> パラメータが追加されました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span><em>exc_info</em> パラメータは例外インスタンスを受け入れることが可能です。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.8 で変更: </span>The <em>stacklevel</em> parameter was added.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.info">
<code class="descname">info</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.info" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レベル <code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code> のメッセージをこのロガーで記録します。引数は <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a> と同じように解釈されます。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.warning">
<code class="descname">warning</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.warning" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レベル <code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code> のメッセージをこのロガーで記録します。引数は <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a> と同じように解釈されます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">warning</span></code> と機能的に等価な古いメソッド <code class="docutils literal notranslate"><span class="pre">warn</span></code> があります。<code class="docutils literal notranslate"><span class="pre">warn</span></code> は廃止予定なので使わないでください - 代わりに <code class="docutils literal notranslate"><span class="pre">warning</span></code> を使ってください。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.error">
<code class="descname">error</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.error" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レベル <code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code> のメッセージをこのロガーで記録します。引数は <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a> と同じように解釈されます。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.critical">
<code class="descname">critical</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.critical" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レベル <code class="xref py py-const docutils literal notranslate"><span class="pre">CRITICAL</span></code> のメッセージをこのロガーで記録します。引数は <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a> と同じように解釈されます。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.log">
<code class="descname">log</code><span class="sig-paren">(</span><em>level</em>, <em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.log" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Logs a message with integer level <em>level</em> on this logger. The other arguments are
interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.exception">
<code class="descname">exception</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.exception" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レベル <code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code> のメッセージをこのロガーで記録します。引数は <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a> と同じように解釈されます。例外情報がログメッセージに追加されます。このメソッドは例外ハンドラからのみ呼び出されるべきです。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.addFilter">
<code class="descname">addFilter</code><span class="sig-paren">(</span><em>filter</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.addFilter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたフィルタ <em>filter</em> をこのロガーに追加します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.removeFilter">
<code class="descname">removeFilter</code><span class="sig-paren">(</span><em>filter</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.removeFilter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたフィルタ <em>filter</em> をこのロガーから取り除きます。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.filter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Apply this logger's filters to the record and return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the
record is to be processed. The filters are consulted in turn, until one of
them returns a false value. If none of them return a false value, the record
will be processed (passed to handlers). If one returns a false value, no
further processing of the record occurs.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.addHandler">
<code class="descname">addHandler</code><span class="sig-paren">(</span><em>hdlr</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.addHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたハンドラ <em>hdlr</em> をこのロガーに追加します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.removeHandler">
<code class="descname">removeHandler</code><span class="sig-paren">(</span><em>hdlr</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.removeHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたハンドラ <em>hdlr</em> をこのロガーから取り除きます。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.findCaller">
<code class="descname">findCaller</code><span class="sig-paren">(</span><em>stack_info=False</em>, <em>stacklevel=1</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.findCaller" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>呼び出し元のソースファイル名と行番号を調べます。ファイル名と行番号、関数名、スタック情報を 4 要素のタプルで返します。<em>stack_info</em> が <code class="docutils literal notranslate"><span class="pre">True</span></code> でなければ、スタック情報は <code class="docutils literal notranslate"><span class="pre">None</span></code> が返されます。</p>
<p>The <em>stacklevel</em> parameter is passed from code calling the <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>
and other APIs. If greater than 1, the excess is used to skip stack frames
before determining the values to be returned. This will generally be useful
when calling logging APIs from helper/wrapper code, so that the information
in the event log refers not to the helper/wrapper code, but to the code that
calls it.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.handle">
<code class="descname">handle</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.handle" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードを、このロガーおよびその上位ロガー (ただし <em>propagate</em> の値が false になったところまで) に関連付けられているすべてのハンドラに渡して処理します。このメソッドは、ローカルで生成されたレコードだけでなく、ソケットから受信した unpickle されたレコードに対しても同様に用いられます。 <a class="reference internal" href="#logging.Logger.filter" title="logging.Logger.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> によって、ロガーレベルでのフィルタが適用されます。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.makeRecord">
<code class="descname">makeRecord</code><span class="sig-paren">(</span><em>name</em>, <em>level</em>, <em>fn</em>, <em>lno</em>, <em>msg</em>, <em>args</em>, <em>exc_info</em>, <em>func=None</em>, <em>extra=None</em>, <em>sinfo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.makeRecord" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは、特殊な <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> インスタンスを生成するためにサブクラスでオーバライドできるファクトリメソッドです。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.hasHandlers">
<code class="descname">hasHandlers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.hasHandlers" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このロガーにハンドラが設定されているかどうかを調べます。
そのために、このロガーとロガー階層におけるその祖先についてハンドラ探していきます。
ハンドラが見つかれば <code class="docutils literal notranslate"><span class="pre">True</span></code> 、そうでなければ <code class="docutils literal notranslate"><span class="pre">False</span></code> を返します。
このメソッドは、'propagate' 属性が偽に設定されたロガーを見つけると、さらに上位の探索をやめます - そのロガーが、ハンドラが存在するかどうかチェックされる最後のロガー、という意味です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.7 で変更: </span>ロガーの pickle 化と unpickle 化ができるようになりました。</p>
</div>
</dd></dl>

</div>
<div class="section" id="logging-levels">
<span id="levels"></span><h2>ロギングレベル<a class="headerlink" href="#logging-levels" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ログレベルの数値は以下の表のように与えられています。これらは基本的に自分でレベルを定義したい人のためのもので、定義するレベルを既存のレベルの間に位置づけるためには具体的な値が必要になります。もし数値が他のレベルと同じだったら、既存の値は上書きされその名前は失われます。</p>
<table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="52%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">レベル</th>
<th class="head">数値</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">CRITICAL</span></code></td>
<td>50</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">ERROR</span></code></td>
<td>40</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">WARNING</span></code></td>
<td>30</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">INFO</span></code></td>
<td>20</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">DEBUG</span></code></td>
<td>10</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">NOTSET</span></code></td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="handler-objects">
<span id="handler"></span><h2>ハンドラオブジェクト<a class="headerlink" href="#handler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ハンドラ (Handler) は以下の属性とメソッドを持ちます。 <a class="reference internal" href="#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handler</span></code></a> は直接インスタンス化されることはありません; このクラスはより便利なサブクラスの基底クラスとして働きます。しかしながら、サブクラスにおける <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> メソッドでは、 <a class="reference internal" href="#logging.Handler.__init__" title="logging.Handler.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Handler.__init__()</span></code></a> を呼び出す必要があります。</p>
<dl class="class">
<dt id="logging.Handler">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">Handler</code><a class="headerlink" href="#logging.Handler" title="この定義へのパーマリンク">¶</a></dt>
<dd><dl class="method">
<dt id="logging.Handler.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>level=NOTSET</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レベルを設定して、 <a class="reference internal" href="#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handler</span></code></a> インスタンスを初期化します。空のリストを使ってフィルタを設定し、 I/O 機構へのアクセスを直列化するために (<a class="reference internal" href="#logging.Handler.createLock" title="logging.Handler.createLock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">createLock()</span></code></a> を使って) ロックを生成します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.createLock">
<code class="descname">createLock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.createLock" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>スレッドセーフでない背後の I/O 機能に対するアクセスを直列化するために用いられるスレッドロック (thread lock) を初期化します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.acquire">
<code class="descname">acquire</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.acquire" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.Handler.createLock" title="logging.Handler.createLock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">createLock()</span></code></a> で生成されたスレッドロックを獲得します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.release">
<code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.release" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.Handler.acquire" title="logging.Handler.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> で獲得したスレッドロックを解放します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.setLevel">
<code class="descname">setLevel</code><span class="sig-paren">(</span><em>level</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.setLevel" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このハンドラに対する閾値を <em>level</em> に設定します。
<em>level</em> よりも深刻でないログメッセージは無視されます。
ハンドラが生成された際、レベルは <code class="xref py py-const docutils literal notranslate"><span class="pre">NOTSET</span></code> (すべてのメッセージが処理される) に設定されます。</p>
<p>レベルの一覧については <a class="reference internal" href="#levels"><span class="std std-ref">ロギングレベル</span></a> を参照してください。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span><em>level</em> パラメータは、 <code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code> のような整数定数の代わりに 'INFO' のようなレベルの文字列表現も受け付けるようになりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.setFormatter">
<code class="descname">setFormatter</code><span class="sig-paren">(</span><em>fmt</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.setFormatter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このハンドラのフォーマッタを <em>fmt</em> に設定します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.addFilter">
<code class="descname">addFilter</code><span class="sig-paren">(</span><em>filter</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.addFilter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたフィルタ <em>filter</em> をこのハンドラに追加します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.removeFilter">
<code class="descname">removeFilter</code><span class="sig-paren">(</span><em>filter</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.removeFilter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたフィルタ <em>filter</em> をこのハンドラから除去します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.filter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Apply this handler's filters to the record and return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the
record is to be processed. The filters are consulted in turn, until one of
them returns a false value. If none of them return a false value, the record
will be emitted. If one returns a false value, the handler will not emit the
record.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.flush">
<code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.flush" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>すべてのログ出力がフラッシュされるようにします。このクラスのバージョンではなにも行わず、サブクラスで実装するためのものです。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ハンドラで使われているすべてのリソースの後始末を行います。このバージョンでは何も出力せず、 <a class="reference internal" href="#logging.shutdown" title="logging.shutdown"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutdown()</span></code></a> が呼ばれたときに閉じられたハンドラを内部リストから削除します。サブクラスではオーバライドされた <a class="reference internal" href="#logging.Handler.close" title="logging.Handler.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> メソッドからこのメソッドが必ず呼ばれるようにしてください。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.handle">
<code class="descname">handle</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.handle" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ハンドラに追加されたフィルタの条件に応じて、指定されたログレコードを出力します。このメソッドは I/O スレッドロックの獲得/解放を伴う実際のログ出力をラップします。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.handleError">
<code class="descname">handleError</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.handleError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは <a class="reference internal" href="#logging.Handler.emit" title="logging.Handler.emit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">emit()</span></code></a> の呼び出し中に例外に遭遇した際にハンドラから呼び出されます。モジュールレベル属性 <code class="docutils literal notranslate"><span class="pre">raiseExceptions</span></code> が <code class="docutils literal notranslate"><span class="pre">False</span></code> の場合、例外は暗黙のまま無視されます。ほとんどの場合、これがロギングシステムの望ましい動作です - というのは、ほとんどのユーザはロギングシステム自体のエラーは気にせず、むしろアプリケーションのエラーに興味があるからです。しかしながら、望むならこのメソッドを自作のハンドラと置き換えることもできます。 <em>record</em> には、例外発生時に処理されていたレコードが入ります。 (<em>raiseExceptions</em> のデフォルト値は <code class="docutils literal notranslate"><span class="pre">True</span></code> です。これは開発中はその方が便利だからです)。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.format">
<code class="descname">format</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.format" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードに対する書式化を行います - フォーマッタが設定されていれば、それを使います。そうでない場合、モジュールにデフォルト指定されたフォーマッタを使います。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたログ記録レコードを実際にログ記録する際のすべての処理を行います。このメソッドはサブクラスで実装されることを意図しており、そのためこのクラスのバージョンは <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> を送出します。</p>
</dd></dl>

</dd></dl>

<p>標準として含まれているハンドラについては、 <a class="reference internal" href="logging.handlers.html#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> を参照してください。</p>
</div>
<div class="section" id="formatter-objects">
<span id="id1"></span><h2>フォーマッタオブジェクト<a class="headerlink" href="#formatter-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> オブジェクトは以下の属性とメソッドを持っています。 <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> は <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> を (通常は) 人間か外部のシステムで解釈できる文字列に変換する役割を担っています。基底クラスの <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> では書式文字列を指定することができます。何も指定されなかった場合、ロギングコール中のメッセージ以外の情報だけを持つ <code class="docutils literal notranslate"><span class="pre">'%(message)s'</span></code> の値が使われます。フォーマットされた出力に情報の要素 (タイムスタンプなど) を追加したいなら、このまま読み進めてください。</p>
<p>Formatter は <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 属性の知識を利用できるような書式文字列を用いて初期化することができます。例えば、上で言及したデフォルト値では、ユーザによるメッセージと引数はあらかじめフォーマットされて、 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> の <em>message</em> 属性に入っていることを利用しています。この書式文字列は、 Python 標準の % を使った変換文字列で構成されます。文字列整形に関する詳細は <a class="reference internal" href="stdtypes.html#old-string-formatting"><span class="std std-ref">printf 形式の文字列書式化</span></a> を参照してください。</p>
<p><a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> の便利なマッピングキーは、 <a class="reference internal" href="#logrecord-attributes"><span class="std std-ref">LogRecord 属性</span></a> の節で与えられます。</p>
<dl class="class">
<dt id="logging.Formatter">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">Formatter</code><span class="sig-paren">(</span><em>fmt=None</em>, <em>datefmt=None</em>, <em>style='%'</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Formatter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> クラスの新たなインスタンスを返します。インスタンスは全体としてのメッセージに対する書式文字列と、メッセージの日付/時刻部分のための書式文字列を伴って初期化されます。 <em>fmt</em> が指定されない場合、 <code class="docutils literal notranslate"><span class="pre">'%(message)s'</span></code> が使われます。 <em>datefmt</em> が指定されない場合、 <a class="reference internal" href="#logging.Formatter.formatTime" title="logging.Formatter.formatTime"><code class="xref py py-meth docutils literal notranslate"><span class="pre">formatTime()</span></code></a> ドキュメントで解説されている書式が使われます。</p>
<p><em>style</em> パラメータは '%',  '{', '$' のうちのいずれかで、書式文字列がどのようにデータとマージされるかを決めます: %-format 、 <a class="reference internal" href="stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> 、 <a class="reference internal" href="string.html#string.Template" title="string.Template"><code class="xref py py-class docutils literal notranslate"><span class="pre">string.Template</span></code></a> のうちのどれかが使用されます。ログメッセージに使用する { および $ 形式のフォーマットの情報は <a class="reference internal" href="../howto/logging-cookbook.html#formatting-styles"><span class="std std-ref">固有の書式化スタイルをアプリケーション全体で使う</span></a> を参照してください。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span><em>style</em> パラメータが追加されました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.8 で変更: </span>The <em>validate</em> parameter was added. Incorrect or mismatched style and fmt
will raise a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.
For example: <code class="docutils literal notranslate"><span class="pre">logging.Formatter('%(asctime)s</span> <span class="pre">-</span> <span class="pre">%(message)s',</span> <span class="pre">style='{')</span></code>.</p>
</div>
<dl class="method">
<dt id="logging.Formatter.format">
<code class="descname">format</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Formatter.format" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードの属性辞書が、文字列を書式化する演算で被演算子として使われます。書式化された結果の文字列を返します。辞書を書式化する前に、二つの準備段階を経ます。レコードの <em>message</em> 属性が <em>msg</em> % <em>args</em> を使って処理されます。書式化された文字列が <code class="docutils literal notranslate"><span class="pre">'(asctime)'</span></code> を含むなら、 <a class="reference internal" href="#logging.Formatter.formatTime" title="logging.Formatter.formatTime"><code class="xref py py-meth docutils literal notranslate"><span class="pre">formatTime()</span></code></a> が呼び出され、イベントの発生時刻を書式化します。例外情報が存在する場合、 <a class="reference internal" href="#logging.Formatter.formatException" title="logging.Formatter.formatException"><code class="xref py py-meth docutils literal notranslate"><span class="pre">formatException()</span></code></a> を使って書式化され、メッセージに追加されます。ここで注意していただきたいのは、書式化された例外情報は <em>exc_text</em> にキャッシュされるという点です。これが有用なのは例外情報がピックル化されて回線上を送ることができるからですが、しかし二つ以上の <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> サブクラスで例外情報の書式化をカスタマイズしている場合には注意が必要になります。この場合、フォーマッタが書式化を終えるごとにキャッシュをクリアして、次のフォーマッタがキャッシュされた値を使わずに新鮮な状態で再計算するようにしなければならないことになります。</p>
<p>スタック情報が利用可能な場合、(必要ならば <a class="reference internal" href="#logging.Formatter.formatStack" title="logging.Formatter.formatStack"><code class="xref py py-meth docutils literal notranslate"><span class="pre">formatStack()</span></code></a> を使って整形した上で) スタック情報が例外情報の後に追加されます。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Formatter.formatTime">
<code class="descname">formatTime</code><span class="sig-paren">(</span><em>record</em>, <em>datefmt=None</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Formatter.formatTime" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは、フォーマッタが書式化された時間を利用したい際に、 <a class="reference internal" href="functions.html#format" title="format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">format()</span></code></a> から呼び出されます。
このメソッドは特定の要求を提供するためにフォーマッタで上書きすることができますが、基本的な振る舞いは以下のようになります: <em>datefmt</em> (文字列) が指定された場合、レコードが生成された時刻を書式化するために <a class="reference internal" href="time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.strftime()</span></code></a> で使われます。
そうでない場合、 '%Y-%m-%d %H:%M:%S,uuu' というフォーマットが使われます。 uuu 部分はミリ秒値で、それ以外の文字は <a class="reference internal" href="time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.strftime()</span></code></a> ドキュメントに従います。
このフォーマットの時刻の例は <code class="docutils literal notranslate"><span class="pre">2003-01-23</span> <span class="pre">00:29:50,411</span></code> です。
結果の文字列が返されます。</p>
<p>この関数は、ユーザが設定できる関数を使って、生成時刻をタプルに変換します。デフォルトでは、 <a class="reference internal" href="time.html#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.localtime()</span></code></a> が使われます。特定のフォーマッタインスタンスに対してこれを変更するには、 <code class="docutils literal notranslate"><span class="pre">converter</span></code> 属性を <a class="reference internal" href="time.html#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.localtime()</span></code></a> や <a class="reference internal" href="time.html#time.gmtime" title="time.gmtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.gmtime()</span></code></a> と同じ署名をもつ関数に設定してください。すべてのフォーマッタインスタンスに対してこれを変更するには、例えば全てのロギング時刻を GMT で表示するには、 <code class="docutils literal notranslate"><span class="pre">Formatter</span></code> クラスの <code class="docutils literal notranslate"><span class="pre">converter</span></code> 属性を設定してください。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>以前は、デフォルトのフォーマットがこの例のようにハードコーディングされていました: <code class="docutils literal notranslate"><span class="pre">2010-09-06</span> <span class="pre">22:38:15,292</span></code> ここで、コンマの前の部分は strptime フォーマット文字列 (<code class="docutils literal notranslate"><span class="pre">'%Y-%m-%d</span> <span class="pre">%H:%M:%S'</span></code>) によって扱われる部分で、コンマの後の部分はミリ秒値です。strptime にミリ秒のフォーマットプレースホルダーがないので、ミリ秒値は別のフォーマット文字列 <code class="docutils literal notranslate"><span class="pre">'%s,%03d'</span></code> を使用して追加されます。そして、これらのフォーマット文字列は両方ともこのメソッドでハードコーディングされていました。変更後は、これらの文字列はクラスレベル属性として定義され、必要ならインスタンスレベルでオーバーライドすることができます。属性の名前は <code class="docutils literal notranslate"><span class="pre">default_time_format</span></code> (strptime 書式文字列用) と <code class="docutils literal notranslate"><span class="pre">default_msec_format</span></code> (ミリ秒値の追加用) です。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Formatter.formatException">
<code class="descname">formatException</code><span class="sig-paren">(</span><em>exc_info</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Formatter.formatException" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定された例外情報 (<a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> が返すような標準例外のタプル) を文字列として書式化します。デフォルトの実装は単に <a class="reference internal" href="traceback.html#traceback.print_exception" title="traceback.print_exception"><code class="xref py py-func docutils literal notranslate"><span class="pre">traceback.print_exception()</span></code></a> を使います。結果の文字列が返されます。</p>
</dd></dl>

<dl class="method">
<dt id="logging.Formatter.formatStack">
<code class="descname">formatStack</code><span class="sig-paren">(</span><em>stack_info</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Formatter.formatStack" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたスタック情報を文字列としてフォーマットします (<a class="reference internal" href="traceback.html#traceback.print_stack" title="traceback.print_stack"><code class="xref py py-func docutils literal notranslate"><span class="pre">traceback.print_stack()</span></code></a> によって返される文字列ですが、最後の改行が取り除かれています)。このデフォルト実装は、単に入力値をそのまま返します。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="filter-objects">
<span id="filter"></span><h2>フィルタオブジェクト<a class="headerlink" href="#filter-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">フィルタ</span> <span class="pre">(Filter)</span></code> は、<code class="docutils literal notranslate"><span class="pre">ハンドラ</span></code> や <code class="docutils literal notranslate"><span class="pre">ロガー</span></code> によって使われ、レベルによって提供されるのよりも洗練されたフィルタリングを実現します。基底のフィルタクラスは、ロガー階層構造内の特定地点の配下にあるイベントだけを許可します。例えば、'A.B' で初期化されたフィルタは、ロガー 'A.B', 'A.B.C', 'A.B.C.D', 'A.B.D' 等によって記録されたイベントは許可しますが、'A.BB', 'B.A.B' などは許可しません。空の文字列で初期化された場合、すべてのイベントを通過させます。</p>
<dl class="class">
<dt id="logging.Filter">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">Filter</code><span class="sig-paren">(</span><em>name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Filter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.Filter" title="logging.Filter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Filter</span></code></a> クラスのインスタンスを返します。 <em>name</em> が指定されていれば、 <em>name</em> はロガーの名前を表します。指定されたロガーとその子ロガーのイベントがフィルタを通過できるようになります。 <em>name</em> が指定されなければ、すべてのイベントを通過させます。</p>
<dl class="method">
<dt id="logging.Filter.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Filter.filter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたレコードがログされるべきか？no ならばばゼロを、yes ならばゼロでない値を返します。適切と判断されれば、このメソッドによってレコードはその場で修正されることがあります。</p>
</dd></dl>

</dd></dl>

<p>ハンドラに対するフィルタはハンドラがイベントを発行する前に試され、一方ではロガーに対するフィルタは、イベントが(<a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>, <a class="reference internal" href="#logging.info" title="logging.info"><code class="xref py py-meth docutils literal notranslate"><span class="pre">info()</span></code></a> などによって)ロギングされる際には、ハンドラにイベントが送信される前にはいつでも試されることに注意してください。そのフィルタがそれら子孫ロガーにも適用されていない限り、子孫ロガーによって生成されたイベントはロガーのフィルタ設定によってフィルタされることはありません。</p>
<p>実際には、<code class="docutils literal notranslate"><span class="pre">Filter</span></code> をサブクラス化する必要はありません。同じ意味の <code class="docutils literal notranslate"><span class="pre">filter</span></code> メソッドを持つ、すべてのインスタンスを通せます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span>特殊な <code class="docutils literal notranslate"><span class="pre">Filter</span></code> クラスを作ったり、 <code class="docutils literal notranslate"><span class="pre">filter</span></code> メソッドを持つ他のクラスを使う必要はありません: 関数 (あるいは他の callable) をフィルタとして使用することができます。フィルタロジックは、フィルタオブジェクトが <code class="docutils literal notranslate"><span class="pre">filter</span></code> 属性を持っているかどうかチェックします: もし <code class="docutils literal notranslate"><span class="pre">filter</span></code> 属性を持っていたら、それは <code class="docutils literal notranslate"><span class="pre">Filter</span></code> であると仮定され、その <a class="reference internal" href="#logging.Filter.filter" title="logging.Filter.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> メソッドが呼び出されます。そうでなければ、それは callable であると仮定され、レコードを単一のパラメータとして呼び出されます。返される値は <a class="reference internal" href="#logging.Filter.filter" title="logging.Filter.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> によって返されるものと一致すべきです。</p>
</div>
<p>Although filters are used primarily to filter records based on more
sophisticated criteria than levels, they get to see every record which is
processed by the handler or logger they're attached to: this can be useful if
you want to do things like counting how many records were processed by a
particular logger or handler, or adding, changing or removing attributes in
the <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> being processed. Obviously changing the LogRecord needs
to be done with some care, but it does allow the injection of contextual
information into logs (see <a class="reference internal" href="../howto/logging-cookbook.html#filters-contextual"><span class="std std-ref">Filter を使ったコンテキスト情報の伝達</span></a>).</p>
</div>
<div class="section" id="logrecord-objects">
<span id="log-record"></span><h2>LogRecord オブジェクト<a class="headerlink" href="#logrecord-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> インスタンスは、何かをログ記録するたびに <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> によって生成されます。また、 <a class="reference internal" href="#logging.makeLogRecord" title="logging.makeLogRecord"><code class="xref py py-func docutils literal notranslate"><span class="pre">makeLogRecord()</span></code></a> を通して (例えば、ワイヤを通して受け取られた pickle 化されたイベントから) 手動で生成することも出来ます。</p>
<dl class="class">
<dt id="logging.LogRecord">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">LogRecord</code><span class="sig-paren">(</span><em>name</em>, <em>level</em>, <em>pathname</em>, <em>lineno</em>, <em>msg</em>, <em>args</em>, <em>exc_info</em>, <em>func=None</em>, <em>sinfo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.LogRecord" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ロギングされているイベントに適切なすべての情報を含みます。</p>
<p>基本的な情報は <code class="xref py py-attr docutils literal notranslate"><span class="pre">msg</span></code> と <code class="xref py py-attr docutils literal notranslate"><span class="pre">args</span></code> に渡され、レコードの <code class="xref py py-attr docutils literal notranslate"><span class="pre">message</span></code> フィールドは <code class="docutils literal notranslate"><span class="pre">msg</span> <span class="pre">%</span> <span class="pre">args</span></code> による結合で生成されます。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> -- この LogRecord で表されるイベントをロギングするのに使われるロガーの名前です。ここで与える名前が、たとえ他の(祖先の)ロガーに結び付けられたハンドラによって発せられるとしても、与えたこの値のままであることに注意してください。</li>
<li><strong>level</strong> -- このロギングイベントの数値のレベル (DEBUG, INFO などのいずれか) です。なお、これは LogRecord の <em>2つの</em> 属性に変換されます。数値 <code class="docutils literal notranslate"><span class="pre">levelno</span></code> と、対応するレベル名 <code class="docutils literal notranslate"><span class="pre">levelname</span></code> です。</li>
<li><strong>pathname</strong> -- ロギングの呼び出しが発せられたファイルの完全なパス名。</li>
<li><strong>lineno</strong> -- ロギングの呼び出しが発せられたソース行番号。</li>
<li><strong>msg</strong> -- イベント記述メッセージで、これは変数データのプレースホルダを持つフォーマット文字列になり得ます。</li>
<li><strong>args</strong> -- <em>msg</em> 引数と組み合わせてイベント記述を得るための変数データです。</li>
<li><strong>exc_info</strong> -- 現在の例外情報を含む例外タプルか、利用できる例外情報がない場合は <code class="docutils literal notranslate"><span class="pre">None</span></code> です。</li>
<li><strong>func</strong> -- ロギングの呼び出しを行った関数またはメソッドの名前です。</li>
<li><strong>sinfo</strong> -- 現在のスレッドのスタックベースからログ呼び出しまでの間のスタック情報を表わすテキスト文字列。</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="logging.LogRecord.getMessage">
<code class="descname">getMessage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.LogRecord.getMessage" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ユーザが提供した引数をメッセージに交ぜた後、この <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> インスタンスへのメッセージを返します。ユーザがロギングの呼び出しに与えた引数が文字列でなければ、その引数に <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> が呼ばれ、文字列に変換されます。これにより、 <code class="docutils literal notranslate"><span class="pre">__str__</span></code> メソッドが実際のフォーマット文字列を返せるようなユーザ定義のクラスをメッセージとして使えます。</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span>The creation of a <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> has been made more configurable by
providing a factory which is used to create the record. The factory can be
set using <a class="reference internal" href="#logging.getLogRecordFactory" title="logging.getLogRecordFactory"><code class="xref py py-func docutils literal notranslate"><span class="pre">getLogRecordFactory()</span></code></a> and <a class="reference internal" href="#logging.setLogRecordFactory" title="logging.setLogRecordFactory"><code class="xref py py-func docutils literal notranslate"><span class="pre">setLogRecordFactory()</span></code></a>
(see this for the factory's signature).</p>
</div>
<p>This functionality can be used to inject your own values into a
<a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> at creation time. You can use the following pattern:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">old_factory</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogRecordFactory</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">record_factory</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">record</span> <span class="o">=</span> <span class="n">old_factory</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">record</span><span class="o">.</span><span class="n">custom_attribute</span> <span class="o">=</span> <span class="mh">0xdecafbad</span>
    <span class="k">return</span> <span class="n">record</span>

<span class="n">logging</span><span class="o">.</span><span class="n">setLogRecordFactory</span><span class="p">(</span><span class="n">record_factory</span><span class="p">)</span>
</pre></div>
</div>
<p>このパターンでは複数のファクトリをつなぐこともできます。それらが互いの属性を上書きしたりせず、また上にリストされた標準属性を意図せず上書きしたりしない限り、驚くようなことは何も起こりません (there should be no surprises)。</p>
</dd></dl>

</div>
<div class="section" id="logrecord-attributes">
<span id="id2"></span><h2>LogRecord 属性<a class="headerlink" href="#logrecord-attributes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>LogRecord には幾つかの属性があり、そのほとんどはコンストラクタの引数から得られます。(なお、LogRecord コンストラクタの引数と LogRecord 属性が常に厳密に対応するわけではありません。) これらの属性は、レコードからのデータをフォーマット文字列に統合するのに使えます。以下のテーブルに、属性名、意味、そして % 形式フォーマット文字列における対応するプレースホルダを (アルファベット順に) 列挙します。</p>
<p>{}-フォーマット (<a class="reference internal" href="stdtypes.html#str.format" title="str.format"><code class="xref py py-func docutils literal notranslate"><span class="pre">str.format()</span></code></a>) を使用していれば、書式文字列の中でプレースホールダーとして <code class="docutils literal notranslate"><span class="pre">{attrname}</span></code> を使うことができます。 $-フォーマット (<a class="reference internal" href="string.html#string.Template" title="string.Template"><code class="xref py py-class docutils literal notranslate"><span class="pre">string.Template</span></code></a>) を使用している場合は、 <code class="docutils literal notranslate"><span class="pre">${attrname}</span></code> 形式にしてください。もちろん、両方の場合で <code class="docutils literal notranslate"><span class="pre">attrname</span></code> は使用したい実際の属性名に置き換えてください。</p>
<p>{}-フォーマットの場合には、属性名の後にフォーマットフラグを指定することができます。属性名とフォーマットフラグの間はコロンで分割します。例: プレースホールダー <code class="docutils literal notranslate"><span class="pre">{msecs:03d}</span></code> は、ミリセカンド値 <code class="docutils literal notranslate"><span class="pre">4</span></code> を <code class="docutils literal notranslate"><span class="pre">004</span></code> としてフォーマットします。利用可能なオプション上の全詳細に関しては <a class="reference internal" href="stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> ドキュメンテーションを参照してください。</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="28%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">属性名</th>
<th class="head">フォーマット</th>
<th class="head">説明</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">args</span></code></td>
<td>このフォーマットを自分で使う必要はないでしょう。</td>
<td><code class="docutils literal notranslate"><span class="pre">msg</span></code> に組み合わせて <code class="docutils literal notranslate"><span class="pre">message</span></code> を生成するための引数のタプル、または、マージに用いられる辞書(引数が一つしかなく、かつそれが辞書の場合)。</td>
</tr>
<tr class="row-odd"><td>asctime</td>
<td><code class="docutils literal notranslate"><span class="pre">%(asctime)s</span></code></td>
<td><a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> が生成された時刻を人間が読める書式で表したもの。デフォルトでは &quot;2003-07-08 16:49:45,896&quot; 形式 (コンマ以降の数字は時刻のミリ秒部分) です。</td>
</tr>
<tr class="row-even"><td>created</td>
<td><code class="docutils literal notranslate"><span class="pre">%(created)f</span></code></td>
<td><a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> が生成された時刻 (<a class="reference internal" href="time.html#time.time" title="time.time"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.time()</span></code></a> によって返される形式で)。</td>
</tr>
<tr class="row-odd"><td>exc_info</td>
<td>このフォーマットを自分で使う必要はないでしょう。</td>
<td>(<code class="docutils literal notranslate"><span class="pre">sys.exc_info</span></code> 風の) 例外タプルか、例外が起こっていない場合は <code class="docutils literal notranslate"><span class="pre">None</span></code>。</td>
</tr>
<tr class="row-even"><td>ファイル名</td>
<td><code class="docutils literal notranslate"><span class="pre">%(filename)s</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">pathname</span></code> のファイル名部分。</td>
</tr>
<tr class="row-odd"><td>funcName</td>
<td><code class="docutils literal notranslate"><span class="pre">%(funcName)s</span></code></td>
<td>ロギングの呼び出しを含む関数の名前。</td>
</tr>
<tr class="row-even"><td>levelname</td>
<td><code class="docutils literal notranslate"><span class="pre">%(levelname)s</span></code></td>
<td>メッセージのための文字のロギングレベル (<code class="docutils literal notranslate"><span class="pre">'DEBUG'</span></code>, <code class="docutils literal notranslate"><span class="pre">'INFO'</span></code>, <code class="docutils literal notranslate"><span class="pre">'WARNING'</span></code>, <code class="docutils literal notranslate"><span class="pre">'ERROR'</span></code>, <code class="docutils literal notranslate"><span class="pre">'CRITICAL'</span></code>)。</td>
</tr>
<tr class="row-odd"><td>levelno</td>
<td><code class="docutils literal notranslate"><span class="pre">%(levelno)s</span></code></td>
<td>メッセージのための数値のロギングレベル (<code class="xref py py-const docutils literal notranslate"><span class="pre">DEBUG</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">CRITICAL</span></code>)。</td>
</tr>
<tr class="row-even"><td>lineno</td>
<td><code class="docutils literal notranslate"><span class="pre">%(lineno)d</span></code></td>
<td>ロギングの呼び出しが発せられたソース行番号 (利用できる場合のみ)。</td>
</tr>
<tr class="row-odd"><td>message</td>
<td><code class="docutils literal notranslate"><span class="pre">%(message)s</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">msg</span> <span class="pre">%</span> <span class="pre">args</span></code> として求められた、ログメッセージ。 <a class="reference internal" href="#logging.Formatter.format" title="logging.Formatter.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Formatter.format()</span></code></a> が呼び出されたときに設定されます。</td>
</tr>
<tr class="row-even"><td>module</td>
<td><code class="docutils literal notranslate"><span class="pre">%(module)s</span></code></td>
<td>モジュール (<code class="docutils literal notranslate"><span class="pre">filename</span></code> の名前部分)。</td>
</tr>
<tr class="row-odd"><td>msecs</td>
<td><code class="docutils literal notranslate"><span class="pre">%(msecs)d</span></code></td>
<td><a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> が生成された時刻のミリ秒部分。</td>
</tr>
<tr class="row-even"><td>msg</td>
<td>このフォーマットを自分で使う必要はないでしょう。</td>
<td>元のロギングの呼び出しで渡されたフォーマット文字列。 <code class="docutils literal notranslate"><span class="pre">args</span></code> と合わせて、 <code class="docutils literal notranslate"><span class="pre">message</span></code> 、または任意のオブジェクトを生成します (<a class="reference internal" href="../howto/logging.html#arbitrary-object-messages"><span class="std std-ref">任意のオブジェクトをメッセージに使用する</span></a> 参照)。</td>
</tr>
<tr class="row-odd"><td>name</td>
<td><code class="docutils literal notranslate"><span class="pre">%(name)s</span></code></td>
<td>ロギングに使われたロガーの名前。</td>
</tr>
<tr class="row-even"><td>pathname</td>
<td><code class="docutils literal notranslate"><span class="pre">%(pathname)s</span></code></td>
<td>ロギングの呼び出しが発せられたファイルの完全なパス名 (利用できる場合のみ)。</td>
</tr>
<tr class="row-odd"><td>process</td>
<td><code class="docutils literal notranslate"><span class="pre">%(process)d</span></code></td>
<td>プロセス ID (利用可能な場合のみ)。</td>
</tr>
<tr class="row-even"><td>processName</td>
<td><code class="docutils literal notranslate"><span class="pre">%(processName)s</span></code></td>
<td>プロセス名 (利用可能な場合のみ)。</td>
</tr>
<tr class="row-odd"><td>relativeCreated</td>
<td><code class="docutils literal notranslate"><span class="pre">%(relativeCreated)d</span></code></td>
<td>logging モジュールが読み込まれた時刻に対する、LogRecord が生成された時刻を、ミリ秒で表したもの。</td>
</tr>
<tr class="row-even"><td>stack_info</td>
<td>このフォーマットを自分で使う必要はないでしょう。</td>
<td>現在のスレッドでのスタックの底からこのレコードの生成に帰着したログ呼び出しまでのスタックフレーム情報 (利用可能な場合)。</td>
</tr>
<tr class="row-odd"><td>thread</td>
<td><code class="docutils literal notranslate"><span class="pre">%(thread)d</span></code></td>
<td>スレッド ID (利用可能な場合のみ)。</td>
</tr>
<tr class="row-even"><td>threadName</td>
<td><code class="docutils literal notranslate"><span class="pre">%(threadName)s</span></code></td>
<td>スレッド名 (利用可能な場合のみ)。</td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.1 で変更: </span><em>processName</em> が追加されました。</p>
</div>
</div>
<div class="section" id="loggeradapter-objects">
<span id="logger-adapter"></span><h2>LoggerAdapter オブジェクト<a class="headerlink" href="#loggeradapter-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#logging.LoggerAdapter" title="logging.LoggerAdapter"><code class="xref py py-class docutils literal notranslate"><span class="pre">LoggerAdapter</span></code></a> インスタンスは文脈情報をログ記録呼び出しに渡すのを簡単にするために使われます。使い方の例は <a class="reference internal" href="../howto/logging-cookbook.html#context-info"><span class="std std-ref">コンテキスト情報をログ記録出力に付加する</span></a> を参照してください。</p>
<dl class="class">
<dt id="logging.LoggerAdapter">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">LoggerAdapter</code><span class="sig-paren">(</span><em>logger</em>, <em>extra</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.LoggerAdapter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>内部で使う <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> インスタンスと辞書風 (dict-like) オブジェクトで初期化した <a class="reference internal" href="#logging.LoggerAdapter" title="logging.LoggerAdapter"><code class="xref py py-class docutils literal notranslate"><span class="pre">LoggerAdapter</span></code></a> のインスタンスを返します。</p>
<dl class="method">
<dt id="logging.LoggerAdapter.process">
<code class="descname">process</code><span class="sig-paren">(</span><em>msg</em>, <em>kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.LoggerAdapter.process" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文脈情報を挿入するために、ログ記録呼び出しに渡されたメッセージおよび/またはキーワード引数に変更を加えます。ここでの実装は <em>extra</em> としてコンストラクタに渡されたオブジェクトを取り、'extra' キーを使って <em>kwargs</em> に加えます。返り値は (<em>msg</em>, <em>kwargs</em>) というタプルで、(変更されているはずの) 渡された引数を含みます。</p>
</dd></dl>

</dd></dl>

<p><a class="reference internal" href="#logging.LoggerAdapter" title="logging.LoggerAdapter"><code class="xref py py-class docutils literal notranslate"><span class="pre">LoggerAdapter</span></code></a> は上記に加え <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> のメソッド <a class="reference internal" href="#logging.Logger.debug" title="logging.Logger.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>, <a class="reference internal" href="#logging.Logger.info" title="logging.Logger.info"><code class="xref py py-meth docutils literal notranslate"><span class="pre">info()</span></code></a>, <a class="reference internal" href="#logging.Logger.warning" title="logging.Logger.warning"><code class="xref py py-meth docutils literal notranslate"><span class="pre">warning()</span></code></a>, <a class="reference internal" href="#logging.Logger.error" title="logging.Logger.error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">error()</span></code></a>, <a class="reference internal" href="#logging.Logger.exception" title="logging.Logger.exception"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exception()</span></code></a>, <a class="reference internal" href="#logging.Logger.critical" title="logging.Logger.critical"><code class="xref py py-meth docutils literal notranslate"><span class="pre">critical()</span></code></a>, <a class="reference internal" href="#logging.Logger.log" title="logging.Logger.log"><code class="xref py py-meth docutils literal notranslate"><span class="pre">log()</span></code></a>, <a class="reference internal" href="#logging.Logger.isEnabledFor" title="logging.Logger.isEnabledFor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isEnabledFor()</span></code></a>, <a class="reference internal" href="#logging.Logger.getEffectiveLevel" title="logging.Logger.getEffectiveLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getEffectiveLevel()</span></code></a>, <a class="reference internal" href="#logging.Logger.setLevel" title="logging.Logger.setLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLevel()</span></code></a>, <a class="reference internal" href="#logging.Logger.hasHandlers" title="logging.Logger.hasHandlers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hasHandlers()</span></code></a> をサポートします。これらは <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> の対応するメソッドと同じシグニチャを持つため、2つのインスタンスは区別せずに利用出来ます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span><a class="reference internal" href="#logging.Logger.isEnabledFor" title="logging.Logger.isEnabledFor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isEnabledFor()</span></code></a>, <a class="reference internal" href="#logging.Logger.getEffectiveLevel" title="logging.Logger.getEffectiveLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getEffectiveLevel()</span></code></a>, <a class="reference internal" href="#logging.Logger.setLevel" title="logging.Logger.setLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLevel()</span></code></a>, <a class="reference internal" href="#logging.Logger.hasHandlers" title="logging.Logger.hasHandlers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hasHandlers()</span></code></a> が <a class="reference internal" href="#logging.LoggerAdapter" title="logging.LoggerAdapter"><code class="xref py py-class docutils literal notranslate"><span class="pre">LoggerAdapter</span></code></a> に追加されました。これらメソッドは元のロガーに処理を委譲します。</p>
</div>
</div>
<div class="section" id="thread-safety">
<h2>スレッドセーフ性<a class="headerlink" href="#thread-safety" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>logging モジュールは、クライアントで特殊な作業を必要としない限りスレッドセーフになっています。このスレッドセーフ性はスレッドロックによって達成されています; モジュールの共有データへのアクセスを直列化するためのロックが一つ存在し、各ハンドラでも背後にある I/O へのアクセスを直列化するためにロックを生成します。</p>
<p><a class="reference internal" href="signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a> モジュールを使用して非同期シグナルハンドラを実装している場合、そのようなハンドラからはログ記録を使用できないかもしれません。これは、 <a class="reference internal" href="threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> モジュールにおけるロック実装が常にリエントラントではなく、そのようなシグナルハンドラから呼び出すことができないからです。</p>
</div>
<div class="section" id="module-level-functions">
<h2>モジュールレベルの関数<a class="headerlink" href="#module-level-functions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>上で述べたクラスに加えて、いくつかのモジュールレベルの関数が存在します。</p>
<dl class="function">
<dt id="logging.getLogger">
<code class="descclassname">logging.</code><code class="descname">getLogger</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.getLogger" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定された名前のロガーを返します。名前が <code class="docutils literal notranslate"><span class="pre">None</span></code> であれば、ロガー階層のルート (root) にあるロガーを返します。<em>name</em> を指定する場合には、通常は <em>'a'</em>, <em>'a.b'</em>, <em>'a.b.c.d'</em> といったドット区切りの階層的な名前にします。名前の付け方はログ機能を使う開発者次第です。</p>
<p>与えられた名前に対して、この関数はどの呼び出しでも同じロガーインスタンスを返します。したがって、ロガーインスタンスをアプリケーションの各部でやりとりする必要はありません。</p>
</dd></dl>

<dl class="function">
<dt id="logging.getLoggerClass">
<code class="descclassname">logging.</code><code class="descname">getLoggerClass</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.getLoggerClass" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>標準の <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> クラスか、最後に <a class="reference internal" href="#logging.setLoggerClass" title="logging.setLoggerClass"><code class="xref py py-func docutils literal notranslate"><span class="pre">setLoggerClass()</span></code></a> に渡したクラスを返します。この関数は、新たなクラス定義の中で呼び出して、カスタマイズした <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> クラスのインストールが既に他のコードで適用したカスタマイズを取り消さないことを保証するために使われることがあります。例えば以下のようにします:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyLogger</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">getLoggerClass</span><span class="p">()):</span>
    <span class="c1"># ... override behaviour here</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.getLogRecordFactory">
<code class="descclassname">logging.</code><code class="descname">getLogRecordFactory</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.getLogRecordFactory" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> を生成するのに使われる callable を返します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加: </span>この関数は、ログイベントを表現する <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> の構築方法に関して開発者により多くのコントロールを与えるため、 <a class="reference internal" href="#logging.setLogRecordFactory" title="logging.setLogRecordFactory"><code class="xref py py-func docutils literal notranslate"><span class="pre">setLogRecordFactory()</span></code></a> とともに提供されました。</p>
</div>
<p>このファクトリがどのように呼ばれるかに関する詳細は <a class="reference internal" href="#logging.setLogRecordFactory" title="logging.setLogRecordFactory"><code class="xref py py-func docutils literal notranslate"><span class="pre">setLogRecordFactory()</span></code></a> を参照してください。</p>
</dd></dl>

<dl class="function">
<dt id="logging.debug">
<code class="descclassname">logging.</code><code class="descname">debug</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.debug" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レベル <code class="xref py py-const docutils literal notranslate"><span class="pre">DEBUG</span></code> のメッセージをルートロガーで記録します。 <em>msg</em> はメッセージの書式文字列で、 <em>args</em> は <em>msg</em> に文字列書式化演算子を使って取り込むための引数です。 (これは、書式文字列の中でキーワードを使い、引数として単一の辞書を渡すことができる、ということを意味します。)</p>
<p>キーワード引数 <em>kwargs</em> からは 3 つのキーワードが調べられます。一つ目は <em>exc_info</em> で、この値の評価値が false でない場合、例外情報をログメッセージに追加します。 (<a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> の返す形式の) 例外情報を表すタプルや例外インスタンスが与えられていれば、それをメッセージに使います。それ以外の場合には、 <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> を呼び出して例外情報を取得します。</p>
<p>2つ目の省略可能なキーワード引数は <em>stack_info</em> で、デフォルトは <code class="docutils literal notranslate"><span class="pre">False</span></code> です。真の場合、実際のロギング呼び出しを含むスタック情報がロギングメッセージに追加されます。これは <em>exc_info</em> 指定によって表示されるスタック情報と同じものではないことに注意してください: 前者はカレントスレッド内での、一番下からロギング呼び出しまでのスタックフレームですが、後者は例外に呼応して、例外ハンドラが見つかるところまで巻き戻されたスタックフレームの情報です。</p>
<p><em>exc_info</em> とは独立に <em>stack_info</em> を指定することもできます (例えば、例外が上げられなかった場合でも、コード中のある地点にどのように到着したかを単に示すために)。スタックフレームは、次のようなヘッダー行に続いて表示されます:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Stack (most recent call last):
</pre></div>
</div>
<p>これは、例外フレームを表示する場合に使用される <code class="docutils literal notranslate"><span class="pre">Traceback</span> <span class="pre">(most</span> <span class="pre">recent</span> <span class="pre">call</span> <span class="pre">last):</span></code> を模倣します。</p>
<p>3番目のキーワード引数は <em>extra</em> で、当該ログイベント用に作られる LogRecoed の __dict__ にユーザー定義属性を加えるのに使われる辞書を渡すために用いられます。これらの属性は好きなように使えます。たとえば、ログメッセージの一部にすることもできます。以下の例を見てください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">FORMAT</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%(asctime)-15s</span><span class="s1"> </span><span class="si">%(clientip)s</span><span class="s1"> </span><span class="si">%(user)-8s</span><span class="s1"> </span><span class="si">%(message)s</span><span class="s1">&#39;</span>
<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="n">FORMAT</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;clientip&#39;</span><span class="p">:</span> <span class="s1">&#39;192.168.0.1&#39;</span><span class="p">,</span> <span class="s1">&#39;user&#39;</span><span class="p">:</span> <span class="s1">&#39;fbloggs&#39;</span><span class="p">}</span>
<span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Protocol problem: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;connection reset&#39;</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<p>これは以下のような出力を行います:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset
</pre></div>
</div>
<p><em>extra</em> で渡される辞書のキーはロギングシステムで使われているものと衝突しないようにしなければなりません。 (どのキーがロギングシステムで使われているかについての詳細は <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> のドキュメントを参照してください。)</p>
<p>これらの属性をログメッセージに使うことにしたなら、少し注意が必要です。上の例では、 'clientip' と 'user' が LogRecord の属性辞書に含まれていることを期待した書式文字列で <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> がセットアップされています。もしこれらが欠けていると、書式化例外が発生してしまうためメッセージはログに残りません。したがってこの場合、常にこれらのキーを含む <em>extra</em> 辞書を渡す必要があります。</p>
<p>このようなことは煩わしいかもしれませんが、この機能は限定された場面で使われるように意図しているものなのです。たとえば同じコードがいくつものコンテキストで実行されるマルチスレッドのサーバで、興味のある条件が現れるのがそのコンテキストに依存している (上の例で言えば、リモートのクライアント IP アドレスや認証されたユーザ名など)、というような場合です。そういった場面では、それ用の <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> が特定の <a class="reference internal" href="#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handler</span></code></a> と共に使われるというのはよくあることです。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span><em>stack_info</em> パラメータが追加されました。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.info">
<code class="descclassname">logging.</code><code class="descname">info</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.info" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レベル <code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code> のメッセージをルートロガーで記録します。引数は <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a> と同じように解釈されます。</p>
</dd></dl>

<dl class="function">
<dt id="logging.warning">
<code class="descclassname">logging.</code><code class="descname">warning</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.warning" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レベル <code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code> のメッセージをルートロガーで記録します。引数は <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a> と同じように解釈されます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">warning</span></code> と機能的に等価な古い関数 <code class="docutils literal notranslate"><span class="pre">warn</span></code> があります。<code class="docutils literal notranslate"><span class="pre">warn</span></code> は廃止予定なので使わないでください - 代わりに <code class="docutils literal notranslate"><span class="pre">warning</span></code> を使ってください。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.error">
<code class="descclassname">logging.</code><code class="descname">error</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.error" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レベル <code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code> のメッセージをルートロガーで記録します。引数は <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a> と同じように解釈されます。</p>
</dd></dl>

<dl class="function">
<dt id="logging.critical">
<code class="descclassname">logging.</code><code class="descname">critical</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.critical" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レベル <code class="xref py py-const docutils literal notranslate"><span class="pre">CRITICAL</span></code> のメッセージをルートロガーで記録します。引数は <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a> と同じように解釈されます。</p>
</dd></dl>

<dl class="function">
<dt id="logging.exception">
<code class="descclassname">logging.</code><code class="descname">exception</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.exception" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レベル <code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code> のメッセージをルートロガーで記録します。引数は <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a> と同じように解釈されます。例外情報がログメッセージに追加されます。このメソッドは例外ハンドラからのみ呼び出されます。</p>
</dd></dl>

<dl class="function">
<dt id="logging.log">
<code class="descclassname">logging.</code><code class="descname">log</code><span class="sig-paren">(</span><em>level</em>, <em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.log" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レベル <em>level</em> のメッセージをルートロガーで記録します。その他の引数は <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a> と同じように解釈されます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">上述の便利なルートロガーに処理を委譲するモジュールレベル関数は <a class="reference internal" href="#logging.basicConfig" title="logging.basicConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">basicConfig()</span></code></a> を呼び出して、少なくとも 1 つのハンドラが利用できることを保証します。これにより Python の 2.7.1 以前や 3.2 以前のバージョンでは、スレッドが開始される <em>前に</em> 少なくともひとつのハンドラがルートロガーに加えられるのでない限り、スレッド内で使うべき <em>ではありません</em> 。以前のバージョンの Python では、 <a class="reference internal" href="#logging.basicConfig" title="logging.basicConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">basicConfig()</span></code></a> のスレッドセーフ性の欠陥により、(珍しい状況下とはいえ)ハンドラがルートロガーに複数回加えられることがあり、ログ内のメッセージが重複するという予期しない結果をもたらすことがあります。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.disable">
<code class="descclassname">logging.</code><code class="descname">disable</code><span class="sig-paren">(</span><em>level=CRITICAL</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.disable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Provides an overriding level <em>level</em> for all loggers which takes precedence over
the logger's own level. When the need arises to temporarily throttle logging
output down across the whole application, this function can be useful. Its
effect is to disable all logging calls of severity <em>level</em> and below, so that
if you call it with a value of INFO, then all INFO and DEBUG events would be
discarded, whereas those of severity WARNING and above would be processed
according to the logger's effective level. If
<code class="docutils literal notranslate"><span class="pre">logging.disable(logging.NOTSET)</span></code> is called, it effectively removes this
overriding level, so that logging output again depends on the effective
levels of individual loggers.</p>
<p>Note that if you have defined any custom logging level higher than
<code class="docutils literal notranslate"><span class="pre">CRITICAL</span></code> (this is not recommended), you won't be able to rely on the
default value for the <em>level</em> parameter, but will have to explicitly supply a
suitable value.</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.7 で変更: </span>The <em>level</em> parameter was defaulted to level <code class="docutils literal notranslate"><span class="pre">CRITICAL</span></code>. See Issue
#28524 for more information about this change.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.addLevelName">
<code class="descclassname">logging.</code><code class="descname">addLevelName</code><span class="sig-paren">(</span><em>level</em>, <em>levelName</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.addLevelName" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Associates level <em>level</em> with text <em>levelName</em> in an internal dictionary, which is
used to map numeric levels to a textual representation, for example when a
<a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> formats a message. This function can also be used to define
your own levels. The only constraints are that all levels used must be
registered using this function, levels should be positive integers and they
should increase in increasing order of severity.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">独自のレベルを定義したい場合、 <a class="reference internal" href="../howto/logging.html#custom-levels"><span class="std std-ref">カスタムレベル</span></a> のセクションを参照してください。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.getLevelName">
<code class="descclassname">logging.</code><code class="descname">getLevelName</code><span class="sig-paren">(</span><em>level</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.getLevelName" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns the textual representation of logging level <em>level</em>. If the level is one
of the predefined levels <code class="xref py py-const docutils literal notranslate"><span class="pre">CRITICAL</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code>,
<code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code> or <code class="xref py py-const docutils literal notranslate"><span class="pre">DEBUG</span></code> then you get the corresponding string. If you
have associated levels with names using <a class="reference internal" href="#logging.addLevelName" title="logging.addLevelName"><code class="xref py py-func docutils literal notranslate"><span class="pre">addLevelName()</span></code></a> then the name you
have associated with <em>level</em> is returned. If a numeric value corresponding to one
of the defined levels is passed in, the corresponding string representation is
returned. Otherwise, the string 'Level %s' % level is returned.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">レベルは内部的には整数です(これはロギングのロジックが大小比較をする必要があるからです)。この関数は、数値のレベルを、書式記述子 <code class="docutils literal notranslate"><span class="pre">%(levelname)s</span></code> (<a class="reference internal" href="#logrecord-attributes"><span class="std std-ref">LogRecord 属性</span></a> 参照)によって書式化されるログ出力の表示用レベル名に変換するのに使用されます。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>Python 3.4以前のバージョンでは、この関数にはテキストのレベルも渡すことが出来、これは対応する数字レベルに読み替えられていました。このドキュメントされていなかった振る舞いは誤りであると判断され、Python 3.4 で一度削除されました。ただし後方互換性のために、これは 3.4.2 で元に戻されました。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.makeLogRecord">
<code class="descclassname">logging.</code><code class="descname">makeLogRecord</code><span class="sig-paren">(</span><em>attrdict</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.makeLogRecord" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>属性が <em>attrdict</em> で定義された、新しい <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> インスタンスを生成して返します。この関数は、 pickle された <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 属性の辞書をソケットを介して送信し、受信端で <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> インスタンスとして再構成する場合に便利です。</p>
</dd></dl>

<dl class="function">
<dt id="logging.basicConfig">
<code class="descclassname">logging.</code><code class="descname">basicConfig</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.basicConfig" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>デフォルトの <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> を持つ <a class="reference internal" href="logging.handlers.html#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamHandler</span></code></a> を生成してルートロガーに追加し、ロギングシステムの基本的な環境設定を行います。関数 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a>, <a class="reference internal" href="#logging.info" title="logging.info"><code class="xref py py-func docutils literal notranslate"><span class="pre">info()</span></code></a>, <a class="reference internal" href="#logging.warning" title="logging.warning"><code class="xref py py-func docutils literal notranslate"><span class="pre">warning()</span></code></a>, <a class="reference internal" href="#logging.error" title="logging.error"><code class="xref py py-func docutils literal notranslate"><span class="pre">error()</span></code></a>, <a class="reference internal" href="#logging.critical" title="logging.critical"><code class="xref py py-func docutils literal notranslate"><span class="pre">critical()</span></code></a> は、ルートロガーにハンドラが定義されていない場合に自動的に <a class="reference internal" href="#logging.basicConfig" title="logging.basicConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">basicConfig()</span></code></a> を呼び出します。</p>
<p>This function does nothing if the root logger already has handlers
configured, unless the keyword argument <em>force</em> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">この関数は、他のスレッドが開始される前にメインスレッドから呼び出されるべきです。Python の 2.7.1 や 3.2 以前のバージョンでは、この関数が複数のスレッドから呼ばれると(珍しい状況下とはいえ)ハンドラがルートロガーに複数回加えられることがあり、ログ内のメッセージが重複するという予期しない結果をもたらすことがあります。</p>
</div>
<p>以下のキーワード引数がサポートされます。</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">フォーマット</th>
<th class="head">説明</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><em>filename</em></td>
<td>StreamHandler ではなく指定された名前で FileHandler が作られます。</td>
</tr>
<tr class="row-odd"><td><em>filemode</em></td>
<td><em>filename</em> が指定された場合、この <a class="reference internal" href="functions.html#filemodes"><span class="std std-ref">モード</span></a> でファイルが開かれます。
デフォルトは  <code class="docutils literal notranslate"><span class="pre">'a'</span></code> です。</td>
</tr>
<tr class="row-even"><td><em>format</em></td>
<td>指定された書式文字列をハンドラで使います。</td>
</tr>
<tr class="row-odd"><td><em>datefmt</em></td>
<td>指定された日時の書式で <a class="reference internal" href="time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.strftime()</span></code></a> が受け付けるものを使います。</td>
</tr>
<tr class="row-even"><td><em>style</em></td>
<td><em>format</em> が指定された場合、書式文字列にこのスタイルを仕様します。
<code class="docutils literal notranslate"><span class="pre">'%'</span></code>, <code class="docutils literal notranslate"><span class="pre">'{'</span></code>, <code class="docutils literal notranslate"><span class="pre">'$'</span></code> のうち1つで、それぞれ <a class="reference internal" href="stdtypes.html#old-string-formatting"><span class="std std-ref">printf-style</span></a>, <a class="reference internal" href="stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a>, <a class="reference internal" href="string.html#string.Template" title="string.Template"><code class="xref py py-class docutils literal notranslate"><span class="pre">string.Template</span></code></a> に対応します。
デフォルトは <code class="docutils literal notranslate"><span class="pre">'%'</span></code> です。</td>
</tr>
<tr class="row-odd"><td><em>level</em></td>
<td>ルートロガーのレベルを指定された <a class="reference internal" href="#levels"><span class="std std-ref">レベル</span></a> に設定します。</td>
</tr>
<tr class="row-even"><td><em>stream</em></td>
<td>指定されたストリームを StreamHandler の初期化に使います。
この引数は <em>filename</em> と同時には使えないことに注意してください。
両方が指定されたときには <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> が送出されます。</td>
</tr>
<tr class="row-odd"><td><em>handlers</em></td>
<td>もし指定されれば、 これは root ロガーに追加される既に作られたハンドラのイテラブルになります。まだフォーマッタがセットされていないすべてのハンドラは、この関数で作られたデフォルトフォーマッタが割り当てられることになります。この引数は <em>filename</em> や <em>stream</em> と互換性がないことに注意してください。両方が存在する場合 <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> が上げられます。</td>
</tr>
<tr class="row-even"><td><em>force</em></td>
<td>If this keyword argument is specified as
true, any existing handlers attached to the
root logger are removed and closed, before
carrying out the configuration as specified
by the other arguments.</td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span><em>style</em> 引数が追加されました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>互換性のない引数が指定された状況 (例えば <em>handlers</em> が <em>stream</em> や <em>filename</em> と一緒に指定されたり、<em>stream</em> が <em>filename</em> と一緒に指定された場合) を捕捉するために、追加のチェックが加えられました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.8 で変更: </span>The <em>force</em> argument was added.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.shutdown">
<code class="descclassname">logging.</code><code class="descname">shutdown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.shutdown" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ロギングシステムに対して、バッファのフラッシュを行い、すべてのハンドラを閉じることで順次シャットダウンを行うように告知します。この関数はアプリケーションの終了時に呼ばれるべきであり、また呼び出し以降はそれ以上ロギングシステムを使ってはなりません。</p>
<p>When the logging module is imported, it registers this function as an exit
handler (see <a class="reference internal" href="atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a>), so normally there's no need to do that
manually.</p>
</dd></dl>

<dl class="function">
<dt id="logging.setLoggerClass">
<code class="descclassname">logging.</code><code class="descname">setLoggerClass</code><span class="sig-paren">(</span><em>klass</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.setLoggerClass" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ロギングシステムに対して、ロガーをインスタンス化する際にクラス <em>klass</em> を使うように指示します。
指定するクラスは引数として名前だけをとるようなメソッド <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> を定義していなければならず、 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> では <code class="xref py py-meth docutils literal notranslate"><span class="pre">Logger.__init__()</span></code> を呼び出さなければなりません。
この関数が呼び出されるのはたいてい、独自の振る舞いをするロガーを使う必要のあるアプリケーションでロガーがインスタンス化される前です。
呼び出された後は、いつでもそのサブクラスを使ってロガーのインスタンス化をしてはいけません: 引き続き <a class="reference internal" href="#logging.getLogger" title="logging.getLogger"><code class="xref py py-func docutils literal notranslate"><span class="pre">logging.getLogger()</span></code></a> API を使用してロガーを取得してください。</p>
</dd></dl>

<dl class="function">
<dt id="logging.setLogRecordFactory">
<code class="descclassname">logging.</code><code class="descname">setLogRecordFactory</code><span class="sig-paren">(</span><em>factory</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.setLogRecordFactory" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> を生成するのに使われる callable をセットします。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><strong>factory</strong> -- ログレコードを生成するファクトリとして振舞う callable。</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加: </span>この関数は、ログイベントを表現する <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> の構築方法に関して開発者により多くのコントロールを与えるため、 <a class="reference internal" href="#logging.getLogRecordFactory" title="logging.getLogRecordFactory"><code class="xref py py-func docutils literal notranslate"><span class="pre">getLogRecordFactory()</span></code></a> とともに提供されました。</p>
</div>
<p>ファクトリは以下のようなシグネチャを持っています:</p>
<p><code class="docutils literal notranslate"><span class="pre">factory(name,</span> <span class="pre">level,</span> <span class="pre">fn,</span> <span class="pre">lno,</span> <span class="pre">msg,</span> <span class="pre">args,</span> <span class="pre">exc_info,</span> <span class="pre">func=None,</span> <span class="pre">sinfo=None,</span> <span class="pre">**kwargs)</span></code></p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">name:</th><td class="field-body">ロガーの名前。</td>
</tr>
<tr class="field-even field"><th class="field-name">level:</th><td class="field-body">ログレベル (数値)。</td>
</tr>
<tr class="field-odd field"><th class="field-name">fn:</th><td class="field-body">ログ呼び出しが行われたファイルのフルパス名。</td>
</tr>
<tr class="field-even field"><th class="field-name">lno:</th><td class="field-body">ログ呼び出しが行われたファイルの行数。</td>
</tr>
<tr class="field-odd field"><th class="field-name">msg:</th><td class="field-body">ログメッセージ。</td>
</tr>
<tr class="field-even field"><th class="field-name"><code class="docutils literal notranslate"><span class="pre">args</span></code>:</th><td class="field-body">ログメッセージに対する引数。</td>
</tr>
<tr class="field-odd field"><th class="field-name">exc_info:</th><td class="field-body">例外タプルまたは <code class="docutils literal notranslate"><span class="pre">None</span></code>。</td>
</tr>
<tr class="field-even field"><th class="field-name">func:</th><td class="field-body">ログ呼び出しを起動した関数またはメソッドの名前。</td>
</tr>
<tr class="field-odd field"><th class="field-name">sinfo:</th><td class="field-body"><a class="reference internal" href="traceback.html#traceback.print_stack" title="traceback.print_stack"><code class="xref py py-func docutils literal notranslate"><span class="pre">traceback.print_stack()</span></code></a> で提供されるような、呼び出し階層を示すスタックトレースバック。</td>
</tr>
<tr class="field-even field"><th class="field-name"><code class="docutils literal notranslate"><span class="pre">kwargs</span></code>:</th><td class="field-body">追加のキーワード引数。</td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd></dl>

</div>
<div class="section" id="module-level-attributes">
<h2>モジュールレベル属性<a class="headerlink" href="#module-level-attributes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="attribute">
<dt id="logging.lastResort">
<code class="descclassname">logging.</code><code class="descname">lastResort</code><a class="headerlink" href="#logging.lastResort" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>「最後の手段のハンドラ」が、この属性で利用可能です。これは <a class="reference internal" href="logging.handlers.html#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamHandler</span></code></a> が <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> に <code class="docutils literal notranslate"><span class="pre">WARNING</span></code> レベルで書き出しているのがそうですし、ロギングの設定がなにか不在のロギングイベントを扱う場合に使われます。最終的な結果は、メッセージを単に <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> に出力することです。これはかつて「logger XYZ についてのハンドラが見つかりません」と言っていたエラーメッセージを置き換えています。もしも何らかの理由でその昔の振る舞いが必要な場合は、 <code class="docutils literal notranslate"><span class="pre">lastResort</span></code> に <code class="docutils literal notranslate"><span class="pre">None</span></code> をセットすれば良いです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="integration-with-the-warnings-module">
<h2>warnings モジュールとの統合<a class="headerlink" href="#integration-with-the-warnings-module" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#logging.captureWarnings" title="logging.captureWarnings"><code class="xref py py-func docutils literal notranslate"><span class="pre">captureWarnings()</span></code></a> 関数を使って、 <a class="reference internal" href="#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> を <a class="reference internal" href="warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal notranslate"><span class="pre">warnings</span></code></a> モジュールと統合できます。</p>
<dl class="function">
<dt id="logging.captureWarnings">
<code class="descclassname">logging.</code><code class="descname">captureWarnings</code><span class="sig-paren">(</span><em>capture</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.captureWarnings" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は、logging による警告の補足を、有効にまたは無効にします。</p>
<p><em>capture</em> が <code class="docutils literal notranslate"><span class="pre">True</span></code> なら、 <a class="reference internal" href="warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal notranslate"><span class="pre">warnings</span></code></a> モジュールに発せられた警告は、ロギングシステムにリダイレクトされるようになります。具体的には、警告が <a class="reference internal" href="warnings.html#warnings.formatwarning" title="warnings.formatwarning"><code class="xref py py-func docutils literal notranslate"><span class="pre">warnings.formatwarning()</span></code></a> でフォーマット化され、結果の文字列が <code class="docutils literal notranslate"><span class="pre">'py.warnings'</span></code> という名のロガーに、 <code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code> の重大度でロギングされるようになります。</p>
<p><em>capture</em> が <code class="docutils literal notranslate"><span class="pre">False</span></code> なら、警告のロギングシステムに対するリダイレクトは止められ、警告は元の (すなわち、<code class="docutils literal notranslate"><span class="pre">captureWarnings(True)</span></code> が呼び出される前に有効だった) 送信先にリダイレクトされるようになります。</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference internal" href="logging.config.html#module-logging.config" title="logging.config: Configuration of the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.config</span></code></a> モジュール</dt>
<dd>logging モジュールの環境設定 API です。</dd>
<dt><a class="reference internal" href="logging.handlers.html#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> モジュール</dt>
<dd>logging モジュールに含まれる、便利なハンドラです。</dd>
<dt><span class="target" id="index-3"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0282"><strong>PEP 282</strong></a> - ログシステム</dt>
<dd>この機能を Python 標準ライブラリに含めることを述べた提案です。</dd>
<dt><a class="reference external" href="https://www.red-dove.com/python_logging.html">Original Python logging package</a></dt>
<dd>これは、 <a class="reference internal" href="#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> パッケージのオリジナルのソースです。このサイトから利用できるバージョンのパッケージは、 <a class="reference internal" href="#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> パッケージを標準ライブラリに含まない、 Python 1.5.2, 2.1.x および 2.2.x で使うのに適しています。</dd>
</dl>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">logging</span></code> --- Python 用ロギング機能</a><ul>
<li><a class="reference internal" href="#logger-objects">ロガーオブジェクト</a></li>
<li><a class="reference internal" href="#logging-levels">ロギングレベル</a></li>
<li><a class="reference internal" href="#handler-objects">ハンドラオブジェクト</a></li>
<li><a class="reference internal" href="#formatter-objects">フォーマッタオブジェクト</a></li>
<li><a class="reference internal" href="#filter-objects">フィルタオブジェクト</a></li>
<li><a class="reference internal" href="#logrecord-objects">LogRecord オブジェクト</a></li>
<li><a class="reference internal" href="#logrecord-attributes">LogRecord 属性</a></li>
<li><a class="reference internal" href="#loggeradapter-objects">LoggerAdapter オブジェクト</a></li>
<li><a class="reference internal" href="#thread-safety">スレッドセーフ性</a></li>
<li><a class="reference internal" href="#module-level-functions">モジュールレベルの関数</a></li>
<li><a class="reference internal" href="#module-level-attributes">モジュールレベル属性</a></li>
<li><a class="reference internal" href="#integration-with-the-warnings-module">warnings モジュールとの統合</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="getopt.html"
                        title="前の章へ"><code class="docutils literal notranslate"><span class="pre">getopt</span></code> --- C 言語スタイルのコマンドラインオプションパーサ</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="logging.config.html"
                        title="次の章へ"><code class="docutils literal notranslate"><span class="pre">logging.config</span></code> --- ロギングの環境設定</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.8/Doc/library/logging.rst"
            rel="nofollow">ソースコードを表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="logging.config.html" title="logging.config --- ロギングの環境設定"
             >次へ</a> |</li>
        <li class="right" >
          <a href="getopt.html" title="getopt --- C 言語スタイルのコマンドラインオプションパーサ"
             >前へ</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.3 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" >汎用オペレーティングシステムサービス</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" type="text" name="q" />
          <input type="submit" value="検索" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">著作権</a> 2001-2020, Python Software Foundation.
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最終更新: 5月 15, 2020
    <a href="https://docs.python.org/3/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>

  </body>
</html>