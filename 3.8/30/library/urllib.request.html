
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>urllib.request --- URL を開くための拡張可能なライブラリ &#8212; Python 3.8.3 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.8.3 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="next" title="urllib.parse --- URL を解析して構成要素にする" href="urllib.parse.html" />
    <link rel="prev" title="urllib --- URL を扱うモジュール群" href="urllib.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/urllib.request.html" />
    
      
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="urllib.parse.html" title="urllib.parse --- URL を解析して構成要素にする"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="urllib.html" title="urllib --- URL を扱うモジュール群"
             accesskey="P">前へ</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.3 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" accesskey="U">インターネットプロトコルとサポート</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" type="text" name="q" />
          <input type="submit" value="検索" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-urllib.request">
<span id="urllib-request-extensible-library-for-opening-urls"></span><h1><a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> --- URL を開くための拡張可能なライブラリ<a class="headerlink" href="#module-urllib.request" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p><strong>ソースコード:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/urllib/request.py">Lib/urllib/request.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> モジュールは基本的な認証、暗号化認証、リダイレクション、Cookie、その他の介在する複雑なアクセス環境において (大抵は HTTP で) URL を開くための関数とクラスを定義します。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">The <a class="reference external" href="https://requests.readthedocs.io/en/master/">Requests package</a>
is recommended for a higher-level HTTP client interface.</p>
</div>
<p><a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> モジュールでは以下の関数を定義しています:</p>
<dl class="function">
<dt id="urllib.request.urlopen">
<code class="descclassname">urllib.request.</code><code class="descname">urlopen</code><span class="sig-paren">(</span><em>url</em>, <em>data=None</em>, <span class="optional">[</span><em>timeout</em>, <span class="optional">]</span><em>*</em>, <em>cafile=None</em>, <em>capath=None</em>, <em>cadefault=False</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.urlopen" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>URL <em>url</em> を開きます。 <em>url</em> は文字列でも <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> オブジェクトでもかまいません。</p>
<p><em>data</em> must be an object specifying additional data to be sent to the
server, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if no such data is needed.  See <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>
for details.</p>
<p>urllib.request モジュールは HTTP/1.1 を使用し、その HTTP リクエストに <code class="docutils literal notranslate"><span class="pre">Connection:close</span></code> ヘッダーを含みます。</p>
<p>任意引数 <em>timeout</em> には接続開始などのブロックする操作におけるタイムアウト時間を秒数で指定します (指定されなかった場合、グローバルのデフォルトタイムアウト時間が利用されます)。この引数は、 HTTP, HTTPS, FTP 接続でのみ有効です。</p>
<p><em>context</em> を指定する場合は、様々な SSL オプションを記述する <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> インスタンスでなければなりません。
詳細は <a class="reference internal" href="http.client.html#http.client.HTTPSConnection" title="http.client.HTTPSConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPSConnection</span></code></a> を参照してください。</p>
<p>任意引数 <em>cafile</em> および <em>capath</em> には HTTPS リクエストのための CA 証明書のセットを指定します。<em>cafile</em> には CA 証明書のリストを含む 1 個のファイルを指定し、<em>capath</em> にはハッシュ化された証明書ファイルが格納されたディレクトリを指定しなければなりません。より詳しい情報は <a class="reference internal" href="ssl.html#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.load_verify_locations()</span></code></a> を参照してください。</p>
<p><em>cadefault</em> 引数は無視されます。</p>
<p>この関数は常に <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">コンテキストマネージャ</span></a> として機能するオブジェクトを返します。このオブジェクトには以下のメソッドがあります。</p>
<ul class="simple">
<li><code class="xref py py-meth docutils literal notranslate"><span class="pre">geturl()</span></code> --- 取得されたリソースの URL を返します。 主に、リダイレクトが発生したかどうかを確認するために利用します</li>
<li><code class="xref py py-meth docutils literal notranslate"><span class="pre">info()</span></code> --- return the meta-information of the page, such as headers,
in the form of an <a class="reference internal" href="email.parser.html#email.message_from_string" title="email.message_from_string"><code class="xref py py-func docutils literal notranslate"><span class="pre">email.message_from_string()</span></code></a> instance (see
<a class="reference external" href="http://jkorpela.fi/http.html">Quick Reference to HTTP Headers</a>)</li>
<li><code class="xref py py-meth docutils literal notranslate"><span class="pre">getcode()</span></code> -- レスポンスの HTTP ステータスコードです。</li>
</ul>
<p>HTTP および HTTPS URL の場合、この関数は、わずかに修正された <a class="reference internal" href="http.client.html#http.client.HTTPResponse" title="http.client.HTTPResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">http.client.HTTPResponse</span></code></a> オブジェクトを返します。上記の3つの新しいメソッドに加えて、 msg 属性が <a class="reference internal" href="http.client.html#http.client.HTTPResponse" title="http.client.HTTPResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPResponse</span></code></a> のドキュメンテーションで指定されているレスポンスヘッダーの代わりに <a class="reference internal" href="http.client.html#http.client.HTTPResponse.reason" title="http.client.HTTPResponse.reason"><code class="xref py py-attr docutils literal notranslate"><span class="pre">reason</span></code></a> 属性 --- サーバーから返された reason フレーズ --- と同じ情報を含んでいます。</p>
<p>FTP 、ファイルおよびデータ URL 、レガシーな <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> や <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> によって明示的に扱われるリクエストの場合、この関数は <code class="xref py py-class docutils literal notranslate"><span class="pre">urllib.response.addinfourl</span></code> オブジェクトを返します。</p>
<p>プロトコルエラー発生時は <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a> を送出します。</p>
<p>どのハンドラもリクエストを処理しなかった場合には <code class="docutils literal notranslate"><span class="pre">None</span></code> を返すことがあるので注意してください (デフォルトでインストールされる グローバルハンドラの <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> は、 <a class="reference internal" href="#urllib.request.UnknownHandler" title="urllib.request.UnknownHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnknownHandler</span></code></a> を使って上記の問題が起きないようにしています)。</p>
<p>さらに、プロキシ設定が検出された場合(例えば <span class="target" id="index-22"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">http_proxy</span></code> のような <code class="docutils literal notranslate"><span class="pre">*_proxy</span></code> 環境変数がセットされているなど)には <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> がデフォルトでインストールされ、これがプロキシを通してリクエストを処理するようにしています。</p>
<p>Python 2.6 以前のレガシーな <code class="docutils literal notranslate"><span class="pre">urllib.urlopen</span></code> 関数は廃止されました。<a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.request.urlopen()</span></code></a> が過去の <code class="docutils literal notranslate"><span class="pre">urllib2.urlopen</span></code> に相当します。<code class="docutils literal notranslate"><span class="pre">urllib.urlopen</span></code> において辞書型オブジェクトで渡していたプロキシの扱いは、<a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> オブジェクトを使用して取得できます。</p>
<p class="audit-hook">The default opener raises an <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a>
<code class="docutils literal notranslate"><span class="pre">urllib.Request</span></code> with arguments <code class="docutils literal notranslate"><span class="pre">fullurl</span></code>, <code class="docutils literal notranslate"><span class="pre">data</span></code>, <code class="docutils literal notranslate"><span class="pre">headers</span></code>,
<code class="docutils literal notranslate"><span class="pre">method</span></code> taken from the request object.</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span><em>cafile</em> および <em>capath</em> が追加されました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span>HTTPS バーチャルホストがサポートされました (<a class="reference internal" href="ssl.html#ssl.HAS_SNI" title="ssl.HAS_SNI"><code class="xref py py-data docutils literal notranslate"><span class="pre">ssl.HAS_SNI</span></code></a> が真の場合のみ)。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加: </span><em>data</em> にイテラブルなオブジェクトを指定できるようになりました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span><em>cadefault</em> が追加されました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4.3 で変更: </span><em>context</em> が追加されました。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.6 で非推奨: </span><em>cafile</em>, <em>capath</em> and <em>cadefault</em> are deprecated in favor of <em>context</em>.
Please use <a class="reference internal" href="ssl.html#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.load_cert_chain()</span></code></a> instead, or let
<a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a> select the system's trusted CA
certificates for you.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="urllib.request.install_opener">
<code class="descclassname">urllib.request.</code><code class="descname">install_opener</code><span class="sig-paren">(</span><em>opener</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.install_opener" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定された <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> のインスタンスを、デフォルトで利用されるグローバルの opener としてインストールします。 opener のインストールは、 urlopen にその opener を使って欲しいとき以外必要ありません。普段は単に <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> の代わりに <a class="reference internal" href="#urllib.request.OpenerDirector.open" title="urllib.request.OpenerDirector.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OpenerDirector.open()</span></code></a> を利用してください。この関数は引数が本当に <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> のインスタンスであるかどうかはチェックしません。適切なインタフェースを持った任意のクラスを利用することができます。</p>
</dd></dl>

<dl class="function">
<dt id="urllib.request.build_opener">
<code class="descclassname">urllib.request.</code><code class="descname">build_opener</code><span class="sig-paren">(</span><span class="optional">[</span><em>handler</em>, <em>...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.build_opener" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられた順番に URL ハンドラを連鎖させる <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>  のインスタンスを返します。 <em>handler</em> は <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> または <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> のサブクラスのインスタンスのどちらかです (どちらの場合も、コンストラクトは引数無しで呼び出せるようになっていなければなりません) 。クラス  <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> (proxy 設定が検出された場合), <a class="reference internal" href="#urllib.request.UnknownHandler" title="urllib.request.UnknownHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnknownHandler</span></code></a>, <a class="reference internal" href="#urllib.request.HTTPHandler" title="urllib.request.HTTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPHandler</span></code></a>, <a class="reference internal" href="#urllib.request.HTTPDefaultErrorHandler" title="urllib.request.HTTPDefaultErrorHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPDefaultErrorHandler</span></code></a>, <a class="reference internal" href="#urllib.request.HTTPRedirectHandler" title="urllib.request.HTTPRedirectHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPRedirectHandler</span></code></a>, <a class="reference internal" href="#urllib.request.FTPHandler" title="urllib.request.FTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FTPHandler</span></code></a>, <a class="reference internal" href="#urllib.request.FileHandler" title="urllib.request.FileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileHandler</span></code></a>, <a class="reference internal" href="#urllib.request.HTTPErrorProcessor" title="urllib.request.HTTPErrorProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPErrorProcessor</span></code></a> については、そのクラスのインスタンスか、そのサブクラスのインスタンスが <em>handler</em>  に含まれていない限り、 <em>handler</em> よりも先に連鎖します。</p>
<p>Python が SSL をサポートするように設定してインストールされている場合 (すなわち、 <a class="reference internal" href="ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> モジュールを import できる場合) <a class="reference internal" href="#urllib.request.HTTPSHandler" title="urllib.request.HTTPSHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPSHandler</span></code></a> も追加されます。</p>
<p><a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> サブクラスでも <code class="xref py py-attr docutils literal notranslate"><span class="pre">handler_order</span></code> メンバー変数を変更して、ハンドラーリスト内での場所を変更できます。</p>
</dd></dl>

<dl class="function">
<dt id="urllib.request.pathname2url">
<code class="descclassname">urllib.request.</code><code class="descname">pathname2url</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.pathname2url" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ローカルシステムにおける記法で表されたパス名 <em>path</em> をURL におけるパス部分の形式に変換します。これは完全な URL を生成するわけではありません。戻り値は <a class="reference internal" href="urllib.parse.html#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a> 関数によってクオートされています。</p>
</dd></dl>

<dl class="function">
<dt id="urllib.request.url2pathname">
<code class="descclassname">urllib.request.</code><code class="descname">url2pathname</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.url2pathname" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>URL の、パーセントエンコードされたパス部分 <em>path</em> をローカルシステムの記法に変換します。これは完全な URL を受け付けません。<em>path</em> のデコードには <a class="reference internal" href="urllib.parse.html#urllib.parse.unquote" title="urllib.parse.unquote"><code class="xref py py-func docutils literal notranslate"><span class="pre">unquote()</span></code></a> 関数を使用します。</p>
</dd></dl>

<dl class="function">
<dt id="urllib.request.getproxies">
<code class="descclassname">urllib.request.</code><code class="descname">getproxies</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.getproxies" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このヘルパー関数はスキーマからプロキシサーバーのURLへのマッピングを行う辞書を返します。この関数はまず、どのOSでも最初に <code class="docutils literal notranslate"><span class="pre">&lt;scheme&gt;_proxy</span></code> という名前の環境変数を大文字小文字を区別せずにスキャンします。そこで見つからなかった場合、 Max OS X の場合は Mac OSX システム環境設定を、 Windows の場合はシステムレジストリを参照します。もし小文字と大文字の環境変数が両方存在する (そして値が一致しない) なら、小文字の環境変数が優先されます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">もし環境変数 <code class="docutils literal notranslate"><span class="pre">REQUEST_METHOD</span></code> が設定されていたら (これは通常スクリプトが CGI 環境で動いていることを示しています)、環境変数 <code class="docutils literal notranslate"><span class="pre">HTTP_PROXY</span></code> (大文字の <code class="docutils literal notranslate"><span class="pre">_PROXY</span></code>) は無視されます。その理由は、クライアントが &quot;Proxy:&quot; HTTP ヘッダーを使ってこの環境変数を注入できるからです。もし CGI 環境で HTTP プロキシを使う必要があれば、 <code class="docutils literal notranslate"><span class="pre">ProxyHandler</span></code> を明示的に使用するか、環境変数名を小文字にしてください (あるいは、少なくともサフィックスを <code class="docutils literal notranslate"><span class="pre">_proxy</span></code> にしてください) 。</p>
</div>
</dd></dl>

<p>以下のクラスが提供されています:</p>
<dl class="class">
<dt id="urllib.request.Request">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">Request</code><span class="sig-paren">(</span><em>url</em>, <em>data=None</em>, <em>headers={}</em>, <em>origin_req_host=None</em>, <em>unverifiable=False</em>, <em>method=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このクラスは URL リクエストを抽象化したものです。</p>
<p><em>url</em> は有効な URL を指す文字列でなくてはなりません。</p>
<p><em>data</em> must be an object specifying additional data to send to the
server, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if no such data is needed.  Currently HTTP
requests are the only ones that use <em>data</em>.  The supported object
types include bytes, file-like objects, and iterables of bytes-like objects.
If no <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code> nor <code class="docutils literal notranslate"><span class="pre">Transfer-Encoding</span></code> header field
has been provided, <a class="reference internal" href="#urllib.request.HTTPHandler" title="urllib.request.HTTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPHandler</span></code></a> will set these headers according
to the type of <em>data</em>.  <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code> will be used to send
bytes objects, while <code class="docutils literal notranslate"><span class="pre">Transfer-Encoding:</span> <span class="pre">chunked</span></code> as specified in
<span class="target" id="index-1"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc7230.html"><strong>RFC 7230</strong></a>, Section 3.3.1 will be used to send files and other iterables.</p>
<p>For an HTTP POST request method, <em>data</em> should be a buffer in the
standard <em class="mimetype">application/x-www-form-urlencoded</em> format.  The
<a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> function takes a mapping or sequence
of 2-tuples and returns an ASCII string in this format. It should
be encoded to bytes before being used as the <em>data</em> parameter.</p>
<p><em>headers</em> は辞書でなければなりません。この辞書は <a class="reference internal" href="#urllib.request.Request.add_header" title="urllib.request.Request.add_header"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_header()</span></code></a> を辞書のキーおよび値を引数として呼び出した時と同じように扱われます。この引数は、多くの場合ブラウザーが何であるかを特定する <code class="docutils literal notranslate"><span class="pre">User-Agent</span></code> ヘッダーの値を &quot;偽装&quot; するために用いられます。これは一部の HTTP サーバーが、スクリプトからのアクセスを禁止するために一般的なブラウザーの <code class="docutils literal notranslate"><span class="pre">User-Agent</span></code> ヘッダーしか許可しないためです。例えば、 Mozilla Firefox は <code class="docutils literal notranslate"><span class="pre">User-Agent</span></code> に <code class="docutils literal notranslate"><span class="pre">&quot;Mozilla/5.0</span> <span class="pre">(X11;</span> <span class="pre">U;</span> <span class="pre">Linux</span> <span class="pre">i686)</span> <span class="pre">Gecko/20071127</span> <span class="pre">Firefox/2.0.0.11&quot;</span></code> のように設定し、 <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> はデフォルトで <code class="docutils literal notranslate"><span class="pre">&quot;Python-urllib/2.6&quot;</span></code> (Python 2.6の場合) と設定します。</p>
<p>An appropriate <code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> header should be included if the <em>data</em>
argument is present.  If this header has not been provided and <em>data</em>
is not None, <code class="docutils literal notranslate"><span class="pre">Content-Type:</span> <span class="pre">application/x-www-form-urlencoded</span></code> will
be added as a default.</p>
<p>The next two arguments are only of interest for correct handling
of third-party HTTP cookies:</p>
<p><em>origin_req_host</em> は、 <span class="target" id="index-23"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2965.html"><strong>RFC 2965</strong></a> で定義されている元のトランザクションにおけるリクエストホスト (request-host of the origin transaction) です。デフォルトの値は <code class="docutils literal notranslate"><span class="pre">http.cookiejar.request_host(self)</span></code> です。この値は、ユーザーによって開始された元々のリクエストにおけるホスト名や IP アドレスです。例えば、もしリクエストがある HTML ドキュメント内の画像を指していれば、この値は画像を含んでいるページへのリクエストにおけるリクエストホストになるはずです。</p>
<p><em>unverifiable</em> should indicate whether the request is unverifiable,
as defined by <span class="target" id="index-3"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2965.html"><strong>RFC 2965</strong></a>.  It defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code>.  An unverifiable
request is one whose URL the user did not have the option to
approve.  For example, if the request is for an image in an HTML
document, and the user had no option to approve the automatic
fetching of the image, this should be true.</p>
<p><em>method</em> should be a string that indicates the HTTP request method that
will be used (e.g. <code class="docutils literal notranslate"><span class="pre">'HEAD'</span></code>).  If provided, its value is stored in the
<a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">method</span></code></a> attribute and is used by <a class="reference internal" href="#urllib.request.Request.get_method" title="urllib.request.Request.get_method"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_method()</span></code></a>.
The default is <code class="docutils literal notranslate"><span class="pre">'GET'</span></code> if <em>data</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code> or <code class="docutils literal notranslate"><span class="pre">'POST'</span></code> otherwise.
Subclasses may indicate a different default method by setting the
<a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">method</span></code></a> attribute in the class itself.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">The request will not work as expected if the data object is unable
to deliver its content more than once (e.g. a file or an iterable
that can produce the content only once) and the request is retried
for HTTP redirects or authentication.  The <em>data</em> is sent to the
HTTP server right away after the headers.  There is no support for
a 100-continue expectation in the library.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>引数 <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.method</span></code></a> が Request クラスに追加されました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.method</span></code></a> のデフォルト値はクラスレベルで指定されることがあります。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>Do not raise an error if the <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code> has not been
provided and <em>data</em> is neither <code class="docutils literal notranslate"><span class="pre">None</span></code> nor a bytes object.
Fall back to use chunked transfer encoding instead.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.OpenerDirector">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">OpenerDirector</code><a class="headerlink" href="#urllib.request.OpenerDirector" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> クラスは、 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> の連鎖的に呼び出して URL を開きます。このクラスはハンドラをどのように連鎖させるか、またどのようにエラーをリカバリするかを管理します。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.BaseHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">BaseHandler</code><a class="headerlink" href="#urllib.request.BaseHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このクラスはハンドラ連鎖に登録される全てのハンドラがベースとしているクラスです -- このクラスでは登録のための単純なメカニズムだけを扱います。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPDefaultErrorHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">HTTPDefaultErrorHandler</code><a class="headerlink" href="#urllib.request.HTTPDefaultErrorHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>HTTP エラーレスポンスのデフォルトハンドラーを定義するクラスです; すべてのレスポンスは <a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a> 例外に変換されます。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPRedirectHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">HTTPRedirectHandler</code><a class="headerlink" href="#urllib.request.HTTPRedirectHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リダイレクションを扱うクラスです。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPCookieProcessor">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">HTTPCookieProcessor</code><span class="sig-paren">(</span><em>cookiejar=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPCookieProcessor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>HTTP Cookie を扱うためのクラスです。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.ProxyHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">ProxyHandler</code><span class="sig-paren">(</span><em>proxies=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Cause requests to go through a proxy. If <em>proxies</em> is given, it must be a
dictionary mapping protocol names to URLs of proxies. The default is to read
the list of proxies from the environment variables
<code class="docutils literal notranslate"><span class="pre">&lt;protocol&gt;_proxy</span></code>.  If no proxy environment variables are set, then
in a Windows environment proxy settings are obtained from the registry's
Internet Settings section, and in a Mac OS X environment proxy information
is retrieved from the OS X System Configuration Framework.</p>
<p>自動検出されたproxyを無効にするには、空の辞書を渡してください。</p>
<p><span class="target" id="index-24"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">no_proxy</span></code> 環境変数は、proxyを利用せずにアクセスするべきホストを指定するために利用されます。設定する場合は、カンマ区切りの、ホストネーム suffix のリストで、オプションとして <code class="docutils literal notranslate"><span class="pre">:port</span></code> を付けることができます。例えば、 <code class="docutils literal notranslate"><span class="pre">cern.ch,ncsa.uiuc.edu,some.host:8080</span></code>.</p>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">変数 <code class="docutils literal notranslate"><span class="pre">REQUEST_METHOD</span></code> が設定されている場合、 <code class="docutils literal notranslate"><span class="pre">HTTP_PROXY</span></code> は無視されます; <a class="reference internal" href="#urllib.request.getproxies" title="urllib.request.getproxies"><code class="xref py py-func docutils literal notranslate"><span class="pre">getproxies()</span></code></a> のドキュメンテーションを参照してください。</p>
</div>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPPasswordMgr">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">HTTPPasswordMgr</code><a class="headerlink" href="#urllib.request.HTTPPasswordMgr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">(realm,</span> <span class="pre">uri)</span> <span class="pre">-&gt;</span> <span class="pre">(user,</span> <span class="pre">password)</span></code> の対応付けデータベースを保持します。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPPasswordMgrWithDefaultRealm">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">HTTPPasswordMgrWithDefaultRealm</code><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">(realm,</span> <span class="pre">uri)</span> <span class="pre">-&gt;</span> <span class="pre">(user,</span> <span class="pre">password)</span></code>  の対応付けデータベースを保持します。レルム <code class="docutils literal notranslate"><span class="pre">None</span></code> はその他諸々のレルムを表し、他のレルムが該当しない場合に検索されます。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPPasswordMgrWithPriorAuth">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">HTTPPasswordMgrWithPriorAuth</code><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">uri</span> <span class="pre">-&gt;</span> <span class="pre">is_authenticated</span></code> マッピングのデータベースも持つ <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> のバリエーションです。最初に <code class="docutils literal notranslate"><span class="pre">401</span></code> レスポンスを待つのではなく直ちに認証情報を送るときの条件を判断するために、 BasicAuth ハンドラによって使われます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.AbstractBasicAuthHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">AbstractBasicAuthHandler</code><span class="sig-paren">(</span><em>password_mgr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractBasicAuthHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これは、リモートホストとプロキシの両方に対して HTTP 認証を行うことを助ける mixin クラスです。 <em>password_mgr</em> は、もし与えられたら <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> と互換性のあるオブジェクトでなければなりません; サポートすべきインタフェースに関する情報は <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr オブジェクト</span></a> 節を参照してください。もし <em>passwd_mgr</em> が <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> と <code class="docutils literal notranslate"><span class="pre">update_authenticated</span></code> メソッドも提供するなら (<a class="reference internal" href="#http-password-mgr-with-prior-auth"><span class="std std-ref">HTTPPasswordMgrWithPriorAuth オブジェクト</span></a> を参照)、ハンドラは与えられた URI に対する <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> の結果を用いてリクエストにおいて認証情報を送るかどうかを決定します。もし <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> がその URI に対して <code class="docutils literal notranslate"><span class="pre">True</span></code> を返すなら、認証情報が送られます。 <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> が <code class="docutils literal notranslate"><span class="pre">False</span></code> なら認証情報は送られません。そして、もし <code class="docutils literal notranslate"><span class="pre">401</span></code> レスポンスを受け取ったら、認証情報を付けて改めてリクエストが送信されます。もし認証が成功したら、それ以降その URI またはその親 URI に対して行われるリクエストが認証情報を自動的に含むように、 URI に対して <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> を <code class="docutils literal notranslate"><span class="pre">True</span></code> に設定するために <code class="docutils literal notranslate"><span class="pre">update_authenticated</span></code> が呼ばれます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加: </span><code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> サポートが追加されました。</p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPBasicAuthHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">HTTPBasicAuthHandler</code><span class="sig-paren">(</span><em>password_mgr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPBasicAuthHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>遠隔ホストとの間での認証を扱います。 <em>password_mgr</em> を与える場合、 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> と互換性がなければなりません; 互換性のためにサポートしなければならないインタフェースについての情報はセクション <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr オブジェクト</span></a> を参照してください。HTTPBasicAuthHandler は、間違った認証スキーマが与えられると <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.ProxyBasicAuthHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">ProxyBasicAuthHandler</code><span class="sig-paren">(</span><em>password_mgr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyBasicAuthHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロキシとの間での認証を扱います。 <em>password_mgr</em> を与える場合、 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> と互換性が なければなりません;  互換性のためにサポートしなければならないインタフェースについての情報はセクション <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr オブジェクト</span></a> を参照してください。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.AbstractDigestAuthHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">AbstractDigestAuthHandler</code><span class="sig-paren">(</span><em>password_mgr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractDigestAuthHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このクラスはHTTP 認証を補助するための混ぜ込みクラス (mixin class) です。遠隔ホストとプロキシの両方に対応しています。 <em>password_mgr</em> を与える場合、 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> と互換性がなければなりません; 互換性のためにサポートしなければならないインタフェースについての情報はセクション <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr オブジェクト</span></a> を参照してください。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPDigestAuthHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">HTTPDigestAuthHandler</code><span class="sig-paren">(</span><em>password_mgr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPDigestAuthHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リモートホストとの認証を扱います。<em>password_mgr</em> を与える場合、<a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> と互換性のあるものでなければなりません。サポートしなければならないインターフェースについての情報は <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr オブジェクト</span></a> 節を参照してください。Digest 認証ハンドラーと Basic 認証ハンドラーの両方が追加された場合、常に Digest 認証を先に試みます。Digest 認証が 40x のレスポンスを再び返すと、Basic 認証ハンドラーに送信されます。このハンドラーメソッドは、Digest および Basic 以外の認証スキームが存在する場合は <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> を送出します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>未サポートの認証スキームでは <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> を送出するようになりました。</p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.ProxyDigestAuthHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">ProxyDigestAuthHandler</code><span class="sig-paren">(</span><em>password_mgr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyDigestAuthHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロキシとの間での認証を扱います。 <em>password_mgr</em> を与える場合、 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> と互換性が なければなりません;  互換性のためにサポートしなければならないインタフェースについての情報はセクション <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr オブジェクト</span></a> を参照してください。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">HTTPHandler</code><a class="headerlink" href="#urllib.request.HTTPHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>HTTP の URL を開きます。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPSHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">HTTPSHandler</code><span class="sig-paren">(</span><em>debuglevel=0</em>, <em>context=None</em>, <em>check_hostname=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPSHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>HTTPS で URL を開きます。<em>context</em> および <em>check_hostname</em> は <a class="reference internal" href="http.client.html#http.client.HTTPSConnection" title="http.client.HTTPSConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">http.client.HTTPSConnection</span></code></a> のものと同じ意味です。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span><em>context</em> および <em>check_hostname</em> が追加されました。</p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.FileHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">FileHandler</code><a class="headerlink" href="#urllib.request.FileHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ローカルファイルを開きます。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.DataHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">DataHandler</code><a class="headerlink" href="#urllib.request.DataHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>data URL を開きます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.FTPHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">FTPHandler</code><a class="headerlink" href="#urllib.request.FTPHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>FTP の URL を開きます。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.CacheFTPHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">CacheFTPHandler</code><a class="headerlink" href="#urllib.request.CacheFTPHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>FTP の URL を開きます。遅延を最小限にするために、開かれている FTP  接続に対するキャッシュを保持します。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.UnknownHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">UnknownHandler</code><a class="headerlink" href="#urllib.request.UnknownHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>その他諸々のためのクラスで、未知のプロトコルの URL を開きます。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPErrorProcessor">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">HTTPErrorProcessor</code><a class="headerlink" href="#urllib.request.HTTPErrorProcessor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>HTTP エラー応答の処理をします。</p>
</dd></dl>

<div class="section" id="request-objects">
<span id="id1"></span><h2>Request オブジェクト<a class="headerlink" href="#request-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下のメソッドは <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> の公開インターフェースについて説明しています。これらはすべてサブクラスでオーバーライドできます。また、解析したリクエストを調査するためにクライアントで使用するいくつかの属性も定義します。</p>
<dl class="attribute">
<dt id="urllib.request.Request.full_url">
<code class="descclassname">Request.</code><code class="descname">full_url</code><a class="headerlink" href="#urllib.request.Request.full_url" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンストラクターに渡されたオリジナルの URL です。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更.</span></p>
</div>
<p>Request.full_url は、 setter, getter, deleter を持つプロパティです。もし存在すれば、 <a class="reference internal" href="#urllib.request.Request.full_url" title="urllib.request.Request.full_url"><code class="xref py py-attr docutils literal notranslate"><span class="pre">full_url</span></code></a> はオリジナルのリクエスト URL フラグメント付きで返します。</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.type">
<code class="descclassname">Request.</code><code class="descname">type</code><a class="headerlink" href="#urllib.request.Request.type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>URI スキームです。</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.host">
<code class="descclassname">Request.</code><code class="descname">host</code><a class="headerlink" href="#urllib.request.Request.host" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>URI オーソリティです。通常はホスト名ですが、コロンで区切られたポート番号が付随することもあります。</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.origin_req_host">
<code class="descclassname">Request.</code><code class="descname">origin_req_host</code><a class="headerlink" href="#urllib.request.Request.origin_req_host" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リクエストしたオリジナルのホスト名です。ポート番号はつきません。</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.selector">
<code class="descclassname">Request.</code><code class="descname">selector</code><a class="headerlink" href="#urllib.request.Request.selector" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>URI パスです。<a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> がプロキシを使用する場合、セレクターはプロキシに渡される完全な URL になります。</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.data">
<code class="descclassname">Request.</code><code class="descname">data</code><a class="headerlink" href="#urllib.request.Request.data" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リクエストのエンティティボディか、指定されない場合は <code class="docutils literal notranslate"><span class="pre">None</span></code> になります。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><a class="reference internal" href="#urllib.request.Request.data" title="urllib.request.Request.data"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.data</span></code></a> の値が変更されると、もしそれ以前に &quot;Content-Length&quot; ヘッダーの値が設定または計算されていたらヘッダーが削除されるようになりました。</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.unverifiable">
<code class="descclassname">Request.</code><code class="descname">unverifiable</code><a class="headerlink" href="#urllib.request.Request.unverifiable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>boolean, indicates whether the request is unverifiable as defined
by <span class="target" id="index-5"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2965.html"><strong>RFC 2965</strong></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.method">
<code class="descclassname">Request.</code><code class="descname">method</code><a class="headerlink" href="#urllib.request.Request.method" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>HTTP リクエストで使うメソッドです。
デフォルト値は <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> で、このときは使うメソッドを <a class="reference internal" href="#urllib.request.Request.get_method" title="urllib.request.Request.get_method"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_method()</span></code></a> が通常の方法で決定するということになります。
この値を設定する (従って <a class="reference internal" href="#urllib.request.Request.get_method" title="urllib.request.Request.get_method"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_method()</span></code></a> のデフォルトの決定を上書きする) 方法は、 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> サブクラスでのクラスレベルの設定処理でデフォルト値を提供するか、 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> のコンストラクタの <em>method</em> 引数へ値を渡すかです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>サブクラスでデフォルト値が設定できるようになりました; 以前はコンストラクタ引数からしか設定できませんでした。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.get_method">
<code class="descclassname">Request.</code><code class="descname">get_method</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.get_method" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>HTTP リクエストメソッドを示す文字列を返します。<a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.method</span></code></a> が <code class="docutils literal notranslate"><span class="pre">None</span></code> でなければその値を返します。そうでない場合、<a class="reference internal" href="#urllib.request.Request.data" title="urllib.request.Request.data"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.data</span></code></a> が <code class="docutils literal notranslate"><span class="pre">None</span></code> なら <code class="docutils literal notranslate"><span class="pre">'GET'</span></code> を、そうでなければ <code class="docutils literal notranslate"><span class="pre">'POST'</span></code> を返します。これは HTTP リクエストに対してのみ意味を持ちます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>get_method は <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.method</span></code></a> の値を参照するようになりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.add_header">
<code class="descclassname">Request.</code><code class="descname">add_header</code><span class="sig-paren">(</span><em>key</em>, <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.add_header" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リクエストに新たなヘッダーを追加します。ヘッダーは HTTP ハンドラ以外のハンドラでは無視されます。HTTP ハンドラでは、引数はサーバに送信される ヘッダーのリストに追加されます。同じ名前を持つヘッダを 2 つ以上持つことはできず、 <em>key</em> の衝突が生じた場合、後で追加したヘッダーが前に 追加したヘッダーを上書きします。現時点では、この機能は HTTP の機能を損ねることはありません。というのは、複数回呼び出したときに意味を 持つようなヘッダーには、どれもただ一つのヘッダーを使って同じ機能を果たすための (ヘッダー特有の) 方法があるからです。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.add_unredirected_header">
<code class="descclassname">Request.</code><code class="descname">add_unredirected_header</code><span class="sig-paren">(</span><em>key</em>, <em>header</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.add_unredirected_header" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リダイレクトされたリクエストには追加されないヘッダーを追加します。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.has_header">
<code class="descclassname">Request.</code><code class="descname">has_header</code><span class="sig-paren">(</span><em>header</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.has_header" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>インスタンスが名前つきヘッダーであるかどうかを (通常のヘッダーと非リダイレクトヘッダの両方を調べて) 返します。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.remove_header">
<code class="descclassname">Request.</code><code class="descname">remove_header</code><span class="sig-paren">(</span><em>header</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.remove_header" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リクエストインスタンス (の通常のヘッダーと非リダイレクトヘッダーの両方) から名前つきヘッダーを削除します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.get_full_url">
<code class="descclassname">Request.</code><code class="descname">get_full_url</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.get_full_url" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンストラクタで与えられた URL を返します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更.</span></p>
</div>
<p><a class="reference internal" href="#urllib.request.Request.full_url" title="urllib.request.Request.full_url"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.full_url</span></code></a> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.set_proxy">
<code class="descclassname">Request.</code><code class="descname">set_proxy</code><span class="sig-paren">(</span><em>host</em>, <em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.set_proxy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リクエストがプロキシサーバを経由するように準備します。 <em>host</em> および <em>type</em> はインスタンスのもとの設定と置き換えられ ます。インスタンスのセレクタはコンストラクタに与えたもともとの URL になります。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.get_header">
<code class="descclassname">Request.</code><code class="descname">get_header</code><span class="sig-paren">(</span><em>header_name</em>, <em>default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.get_header" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたヘッダーの値を返します。ヘッダーがない場合は、 <em>default</em> の値を返します。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.header_items">
<code class="descclassname">Request.</code><code class="descname">header_items</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.header_items" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リクエストヘッダーの値を、タプル (header_name, header_value) のリストで返します。</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>3.3 から非推奨だった Request オブジェクトのメソッド add_data, has_data, get_data, get_type, get_host, get_selector, get_origin_req_host, is_unverifiable が削除されました。</p>
</div>
</div>
<div class="section" id="openerdirector-objects">
<span id="opener-director-objects"></span><h2>OpenerDirector オブジェクト<a class="headerlink" href="#openerdirector-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> インスタンスは以下のメソッドを持っています:</p>
<dl class="method">
<dt id="urllib.request.OpenerDirector.add_handler">
<code class="descclassname">OpenerDirector.</code><code class="descname">add_handler</code><span class="sig-paren">(</span><em>handler</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.OpenerDirector.add_handler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>handler</em> should be an instance of <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>.  The following methods
are searched, and added to the possible chains (note that HTTP errors are a
special case).  Note that, in the following, <em>protocol</em> should be replaced
with the actual protocol to handle, for example <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_response()</span></code> would
be the HTTP protocol response handler.  Also <em>type</em> should be replaced with
the actual HTTP code, for example <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_404()</span></code> would handle HTTP
404 errors.</p>
<ul>
<li><p class="first"><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_open()</span></code> --- signal that the handler knows how to open <em>protocol</em>
URLs.</p>
<p>See <a class="reference internal" href="#protocol-open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseHandler.&lt;protocol&gt;_open()</span></code></a> for more information.</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_&lt;type&gt;()</span></code> --- signal that the handler knows how to handle HTTP
errors with HTTP error code <em>type</em>.</p>
<p>See <a class="reference internal" href="#http-error-nnn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseHandler.http_error_&lt;nnn&gt;()</span></code></a> for more information.</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_error()</span></code> --- signal that the handler knows how to handle errors
from (non-<code class="docutils literal notranslate"><span class="pre">http</span></code>) <em>protocol</em>.</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_request()</span></code> --- signal that the handler knows how to pre-process
<em>protocol</em> requests.</p>
<p>See <a class="reference internal" href="#protocol-request"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseHandler.&lt;protocol&gt;_request()</span></code></a> for more information.</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_response()</span></code> --- signal that the handler knows how to
post-process <em>protocol</em> responses.</p>
<p>See <a class="reference internal" href="#protocol-response"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseHandler.&lt;protocol&gt;_response()</span></code></a> for more information.</p>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="urllib.request.OpenerDirector.open">
<code class="descclassname">OpenerDirector.</code><code class="descname">open</code><span class="sig-paren">(</span><em>url</em>, <em>data=None</em><span class="optional">[</span>, <em>timeout</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.OpenerDirector.open" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられた <em>url</em> (リクエストオブジェクトでも文字列でもかまいません) を開きます。オプションとして <em>data</em> を与えることができます。 引数、戻り値、および送出される例外は <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> と同じです (<a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> の場合、標準でインストールされている グローバルな <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> の <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a> メソッドを呼び出します) 。 オプションの <em>timeout</em> 引数は、接続開始のようなブロックする処理におけるタイムアウト時間を 秒数で指定します。(指定しなかった場合は、グローバルのデフォルト設定が利用されます) タイムアウト機能は、 HTTP, HTTPS, FTP 接続でのみ有効です。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.OpenerDirector.error">
<code class="descclassname">OpenerDirector.</code><code class="descname">error</code><span class="sig-paren">(</span><em>proto</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.OpenerDirector.error" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Handle an error of the given protocol.  This will call the registered error
handlers for the given protocol with the given arguments (which are protocol
specific).  The HTTP protocol is a special case which uses the HTTP response
code to determine the specific error handler; refer to the <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_&lt;type&gt;()</span></code>
methods of the handler classes.</p>
<p>戻り値および送出される例外は <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> と同じものです。</p>
</dd></dl>

<p>OpenerDirector オブジェクトは、以下の 3 つのステージに分けて URL を開きます:</p>
<p>各ステージで OpenerDirector オブジェクトのメソッドがどのような順で呼び出されるかは、ハンドラインスタンスの並び方で決まります。</p>
<ol class="arabic">
<li><p class="first">Every handler with a method named like <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_request()</span></code> has that
method called to pre-process the request.</p>
</li>
<li><p class="first">Handlers with a method named like <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_open()</span></code> are called to handle
the request. This stage ends when a handler either returns a non-<a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>
value (ie. a response), or raises an exception (usually
<a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a>).  Exceptions are allowed to propagate.</p>
<p>In fact, the above algorithm is first tried for methods named
<code class="xref py py-meth docutils literal notranslate"><span class="pre">default_open()</span></code>.  If all such methods return <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>, the algorithm
is repeated for methods named like <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_open()</span></code>.  If all such methods
return <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>, the algorithm is repeated for methods named
<code class="xref py py-meth docutils literal notranslate"><span class="pre">unknown_open()</span></code>.</p>
<p>これらのメソッドの実装には、親となる <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> インスタンスの <code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code> や <code class="xref py py-meth docutils literal notranslate"><span class="pre">error()</span></code> といったメソッド呼び出しが入る場合があるので注意してください。</p>
</li>
<li><p class="first">Every handler with a method named like <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_response()</span></code> has that
method called to post-process the response.</p>
</li>
</ol>
</div>
<div class="section" id="basehandler-objects">
<span id="base-handler-objects"></span><h2>BaseHandler オブジェクト<a class="headerlink" href="#basehandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> オブジェクトは直接的に役に立つ 2 つのメソッドと、その他として派生クラスで使われることを想定したメソッドを 提供します。以下は直接的に使うためのメソッドです:</p>
<dl class="method">
<dt id="urllib.request.BaseHandler.add_parent">
<code class="descclassname">BaseHandler.</code><code class="descname">add_parent</code><span class="sig-paren">(</span><em>director</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.add_parent" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>親オブジェクトとして、 <code class="docutils literal notranslate"><span class="pre">director</span></code> を追加します。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.BaseHandler.close">
<code class="descclassname">BaseHandler.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>全ての親オブジェクトを削除します。</p>
</dd></dl>

<p>以下の属性およびメソッドは <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> から派生したクラスでのみ使われます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">The convention has been adopted that subclasses defining
<code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_request()</span></code> or <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_response()</span></code> methods are named
<code class="xref py py-class docutils literal notranslate"><span class="pre">*Processor</span></code>; all others are named <code class="xref py py-class docutils literal notranslate"><span class="pre">*Handler</span></code>.</p>
</div>
<dl class="attribute">
<dt id="urllib.request.BaseHandler.parent">
<code class="descclassname">BaseHandler.</code><code class="descname">parent</code><a class="headerlink" href="#urllib.request.BaseHandler.parent" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>有効な <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> です。この値は違うプロトコルを使って URL を開く場合やエラーを処理する際に使われます。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.BaseHandler.default_open">
<code class="descclassname">BaseHandler.</code><code class="descname">default_open</code><span class="sig-paren">(</span><em>req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.default_open" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> では定義されて <em>いません</em> 。しかし、全ての URL をキャッチさせたいなら、サブクラスで定義する 必要があります。</p>
<p>このメソッドが実装されていれば、<a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> の親クラスによって呼び出されます。これは <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> の <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a> の戻り値で表されるファイルライクオブジェクトか、または <code class="docutils literal notranslate"><span class="pre">None</span></code> を返さなければならず、真に想定外の事態が発生した場合を除き、<a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a> を送出しなければなりません (例えば、<a class="reference internal" href="exceptions.html#MemoryError" title="MemoryError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MemoryError</span></code></a> は <code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code> にマップしてはなりません)。</p>
<p>このメソッドはプロトコル固有のオープンメソッドが呼び出される前に呼び出されます。</p>
</dd></dl>

<span class="target" id="protocol-open"></span><dl class="method">
<dt>
<code class="descname">BaseHandler.&lt;protocol&gt;_open(req)</code></dt>
<dd><p>このメソッドは <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> では定義されて <em>いません</em> 。しかしプロトコルの URL をキャッチしたいなら、サブクラスで定義する必要があります。</p>
<p>このメソッドが定義されていた場合、 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> から呼び出されます。戻り値は <code class="xref py py-meth docutils literal notranslate"><span class="pre">default_open()</span></code> と同じでなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.BaseHandler.unknown_open">
<code class="descclassname">BaseHandler.</code><code class="descname">unknown_open</code><span class="sig-paren">(</span><em>req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.unknown_open" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> では定義されて <em>いません</em> 。しかし URL を開くための特定のハンドラが登録されていないような URL をキャッチしたいなら、サブクラスで定義する必要があります。</p>
<p>このメソッドが定義されていた場合、 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> から呼び出されます。戻り値は <a class="reference internal" href="#urllib.request.BaseHandler.default_open" title="urllib.request.BaseHandler.default_open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">default_open()</span></code></a> と同じでなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.BaseHandler.http_error_default">
<code class="descclassname">BaseHandler.</code><code class="descname">http_error_default</code><span class="sig-paren">(</span><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.http_error_default" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> では定義されて <em>いません</em> 。しかしその他の処理されなかった HTTP エラーを処理する機能をもたせたいなら、サブクラスで定義する必要があります。このメソッドはエラーに遭遇した <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> から自動的に呼び出されます。その他の状況では普通呼び出すべきではありません。</p>
<p><em>req</em> は <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> オブジェクトで、 <em>fp</em> は HTTP エラー本体を読み出せるようなファイル類似のオブジェクトに なります。 <em>code</em> は 3 桁の 10 進数からなるエラーコードで、 <em>msg</em> ユーザ向けのエラーコード解説です。 <em>hdrs</em> は エラー応答のヘッダーをマップしたオブジェクトです。</p>
<p>返される値および送出される例外は <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> と同じものでなければなりません。</p>
</dd></dl>

<span class="target" id="http-error-nnn"></span><dl class="method">
<dt>
<code class="descname">BaseHandler.http_error_&lt;nnn&gt;(req, fp, code, msg, hdrs)</code></dt>
<dd><p><em>nnn</em> は 3 桁の 10 進数からなる HTTP エラーコードでなくてはなりません。このメソッドも <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> では定義されていませんが、サブクラスのインスタンスで定義されていた場合、エラーコード <em>nnn</em> の HTTP エラーが発生した際に呼び出されます。</p>
<p>特定の HTTP エラーに対する処理を行うためには、このメソッドをサブクラスでオーバライドする必要があります。</p>
<p>引数、返される値、および送出される例外は <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_default()</span></code> と同じものでなければなりません。</p>
</dd></dl>

<span class="target" id="protocol-request"></span><dl class="method">
<dt>
<code class="descname">BaseHandler.&lt;protocol&gt;_request(req)</code></dt>
<dd><p>このメソッドは <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> では <em>定義されていません</em> が、サブクラスで特定のプロトコルのリクエストのプリプロセスを行いたい場合には定義する必要があります。</p>
<p>このメソッドが定義されていると、親となる <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> から呼び出されます。その際、 <em>req</em> は <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> オブジェクトになります。戻り値は <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> オブジェクトでなければなりません。</p>
</dd></dl>

<span class="target" id="protocol-response"></span><dl class="method">
<dt>
<code class="descname">BaseHandler.&lt;protocol&gt;_response(req, response)</code></dt>
<dd><p>このメソッドは <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> では <em>定義されていません</em> が、サブクラスで特定のプロトコルのリクエストのポストプロセスを行いたい場合には定義する必要があります。</p>
<p>このメソッドが定義されていると、親となる <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> から呼び出されます。その際、 <em>req</em> は <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> オブジェクトになります。 <em>response</em> は <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> の戻り値と同じインタフェースを 実装したオブジェクトになります。戻り値もまた、 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> の戻り値と同じインタフェースを実装したオブジェクトでなければなりません。</p>
</dd></dl>

</div>
<div class="section" id="httpredirecthandler-objects">
<span id="http-redirect-handler"></span><h2>HTTPRedirectHandler オブジェクト<a class="headerlink" href="#httpredirecthandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>一部の HTTP リクエストはこのモジュールのクライアントモードからの操作を要求します。その場合、<a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a> が送出されます。さまざまなリダイレクションコードの正確な意味についての詳細は <span class="target" id="index-25"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2616.html"><strong>RFC 2616</strong></a> を参照してください。</p>
<p class="last">セキュリティ上の配慮として、HTTPRedirectHandler に HTTP、HTTPS、あるいは FTP の URL ではないリダイレクトされた URL が存在した場合、<code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPError</span></code> 例外が送出されます。</p>
</div>
<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.redirect_request">
<code class="descclassname">HTTPRedirectHandler.</code><code class="descname">redirect_request</code><span class="sig-paren">(</span><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em>, <em>newurl</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.redirect_request" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リダイレクトへのレスポンスの <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> または <code class="docutils literal notranslate"><span class="pre">None</span></code> を返します。これはサーバーからリダイレクションを受信した時に <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_30*()</span></code> メソッドのデフォルトの実装によって呼び出されます。リダイレクションを行わなければならない場合、<em>newurl</em> へのリダイレクトを実行するための <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_30*()</span></code> を許可する新しい <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> を返します。その他の場合、この URL を扱うその他のハンドラーがない場合は <a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a> を、他のハンドラーでできそうな場合は <code class="docutils literal notranslate"><span class="pre">None</span></code> を返します。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">このメソッドのデフォルトの実装は、 <span class="target" id="index-26"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2616.html"><strong>RFC 2616</strong></a> に厳密に従ったものではありません。 <span class="target" id="index-27"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2616.html"><strong>RFC 2616</strong></a> では、 <code class="docutils literal notranslate"><span class="pre">POST</span></code> リクエストに対する 301 および 302 応答が、ユーザの承認なく自動的にリダイレクトされてはならないと述べています。現実には、ブラウザは POST を <code class="docutils literal notranslate"><span class="pre">GET</span></code> に変更することで、これらの応答に対して自動的にリダイレクトを行えるようにしています。デフォルトの実装でも、この挙動を再現しています。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.http_error_301">
<code class="descclassname">HTTPRedirectHandler.</code><code class="descname">http_error_301</code><span class="sig-paren">(</span><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Location:</span></code> か <code class="docutils literal notranslate"><span class="pre">URI:</span></code> のURL にリダイレクトします。このメソッドは HTTP  における 'moved permanently' レスポンスを取得した際に 親オブジェクトとなる <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> によって呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.http_error_302">
<code class="descclassname">HTTPRedirectHandler.</code><code class="descname">http_error_302</code><span class="sig-paren">(</span><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_302" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="urllib.request.HTTPRedirectHandler.http_error_301"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_301()</span></code></a> と同じですが、'found' レスポンスに対して呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.http_error_303">
<code class="descclassname">HTTPRedirectHandler.</code><code class="descname">http_error_303</code><span class="sig-paren">(</span><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_303" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="urllib.request.HTTPRedirectHandler.http_error_301"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_301()</span></code></a> と同じですが、'see other' レスポンスに対して呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.http_error_307">
<code class="descclassname">HTTPRedirectHandler.</code><code class="descname">http_error_307</code><span class="sig-paren">(</span><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_307" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="urllib.request.HTTPRedirectHandler.http_error_301"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_301()</span></code></a> と同じですが、'temporary redirect'  レスポンスに対して呼び出されます。</p>
</dd></dl>

</div>
<div class="section" id="httpcookieprocessor-objects">
<span id="http-cookie-processor"></span><h2>HTTPCookieProcessor オブジェクト<a class="headerlink" href="#httpcookieprocessor-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#urllib.request.HTTPCookieProcessor" title="urllib.request.HTTPCookieProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPCookieProcessor</span></code></a> インスタンスは属性をひとつだけ持ちます:</p>
<dl class="attribute">
<dt id="urllib.request.HTTPCookieProcessor.cookiejar">
<code class="descclassname">HTTPCookieProcessor.</code><code class="descname">cookiejar</code><a class="headerlink" href="#urllib.request.HTTPCookieProcessor.cookiejar" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Cookie の入っている <a class="reference internal" href="http.cookiejar.html#http.cookiejar.CookieJar" title="http.cookiejar.CookieJar"><code class="xref py py-class docutils literal notranslate"><span class="pre">http.cookiejar.CookieJar</span></code></a> オブジェクトです。</p>
</dd></dl>

</div>
<div class="section" id="proxyhandler-objects">
<span id="proxy-handler"></span><h2>ProxyHandler オブジェクト<a class="headerlink" href="#proxyhandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt>
<code class="descname">ProxyHandler.&lt;protocol&gt;_open(request)</code></dt>
<dd><p>The <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> will have a method <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_open()</span></code> for every
<em>protocol</em> which has a proxy in the <em>proxies</em> dictionary given in the
constructor.  The method will modify requests to go through the proxy, by
calling <code class="docutils literal notranslate"><span class="pre">request.set_proxy()</span></code>, and call the next handler in the chain to
actually execute the protocol.</p>
</dd></dl>

</div>
<div class="section" id="httppasswordmgr-objects">
<span id="http-password-mgr"></span><h2>HTTPPasswordMgr オブジェクト<a class="headerlink" href="#httppasswordmgr-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下のメソッドは <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> および <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> オブジェクトで利用できます。</p>
<dl class="method">
<dt id="urllib.request.HTTPPasswordMgr.add_password">
<code class="descclassname">HTTPPasswordMgr.</code><code class="descname">add_password</code><span class="sig-paren">(</span><em>realm</em>, <em>uri</em>, <em>user</em>, <em>passwd</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgr.add_password" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>uri</em> は単一の URI でも複数の URI からなるシーケンスでもかまいません。 <em>realm</em> 、 <em>user</em> および <em>passwd</em> は文字列でなくてはなりません。このメソッドによって、 <em>realm</em> と与えられた URI の上位 URI に対して <code class="docutils literal notranslate"><span class="pre">(user,</span> <span class="pre">passwd)</span></code> が認証トークンとして使われるようになります。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPPasswordMgr.find_user_password">
<code class="descclassname">HTTPPasswordMgr.</code><code class="descname">find_user_password</code><span class="sig-paren">(</span><em>realm</em>, <em>authuri</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgr.find_user_password" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられたレルムおよび URI に対するユーザ名またはパスワードがあればそれを取得します。該当するユーザ名／パスワードが存在しない場合、このメソッドは <code class="docutils literal notranslate"><span class="pre">(None,</span> <span class="pre">None)</span></code> を返します。</p>
<p><a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> オブジェクトでは、与えられた <em>realm</em> に対して該当するユーザ名/パスワードが存在しない場合、レルム <code class="docutils literal notranslate"><span class="pre">None</span></code> が検索されます。</p>
</dd></dl>

</div>
<div class="section" id="httppasswordmgrwithpriorauth-objects">
<span id="http-password-mgr-with-prior-auth"></span><h2>HTTPPasswordMgrWithPriorAuth オブジェクト<a class="headerlink" href="#httppasswordmgrwithpriorauth-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このパスワードマネージャは <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> を継承して、認証の証明書を常に送らないといけない URI を追跡する機能をサポートしています。</p>
<dl class="method">
<dt id="urllib.request.HTTPPasswordMgrWithPriorAuth.add_password">
<code class="descclassname">HTTPPasswordMgrWithPriorAuth.</code><code class="descname">add_password</code><span class="sig-paren">(</span><em>realm</em>, <em>uri</em>, <em>user</em>, <em>passwd</em>, <em>is_authenticated=False</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth.add_password" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>realm</em>, <em>uri</em>, <em>user</em>, <em>passwd</em> は <a class="reference internal" href="#urllib.request.HTTPPasswordMgr.add_password" title="urllib.request.HTTPPasswordMgr.add_password"><code class="xref py py-meth docutils literal notranslate"><span class="pre">HTTPPasswordMgr.add_password()</span></code></a> のものと同じです。
<em>is_authenticated</em> は、与えられた URI や URI のリストの <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> フラグの初期値に設定されます。
<em>is_authenticated</em> に <code class="docutils literal notranslate"><span class="pre">True</span></code> を指定した場合は、 <em>realm</em> は無視されます。</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descclassname">HTTPPasswordMgr.</code><code class="descname">find_user_password</code><span class="sig-paren">(</span><em>realm</em>, <em>authuri</em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> オブジェクトに対する同名のメソッドと同じです。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPPasswordMgrWithPriorAuth.update_authenticated">
<code class="descclassname">HTTPPasswordMgrWithPriorAuth.</code><code class="descname">update_authenticated</code><span class="sig-paren">(</span><em>self</em>, <em>uri</em>, <em>is_authenticated=False</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth.update_authenticated" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられた <em>url</em> や URI のリストの <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> フラグを更新します。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPPasswordMgrWithPriorAuth.is_authenticated">
<code class="descclassname">HTTPPasswordMgrWithPriorAuth.</code><code class="descname">is_authenticated</code><span class="sig-paren">(</span><em>self</em>, <em>authuri</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth.is_authenticated" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられた URI の <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> フラグの現在の状態を返します。</p>
</dd></dl>

</div>
<div class="section" id="abstractbasicauthhandler-objects">
<span id="abstract-basic-auth-handler"></span><h2>AbstractBasicAuthHandler オブジェクト<a class="headerlink" href="#abstractbasicauthhandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.AbstractBasicAuthHandler.http_error_auth_reqed">
<code class="descclassname">AbstractBasicAuthHandler.</code><code class="descname">http_error_auth_reqed</code><span class="sig-paren">(</span><em>authreq</em>, <em>host</em>, <em>req</em>, <em>headers</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractBasicAuthHandler.http_error_auth_reqed" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ユーザ名／パスワードを取得し、再度サーバへのリクエストを試みることで、サーバからの認証リクエストを処理します。 <em>authreq</em> はリクエストにおいて レルムに関する情報が含まれているヘッダーの名前、 <em>host</em> は認証を行う対象の URL とパスを指定します、 <em>req</em> は (失敗した) <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> オブジェクト、そして <em>headers</em> はエラーヘッダーでなくてはなりません。</p>
<p><em>host</em> は、オーソリティ (例 <code class="docutils literal notranslate"><span class="pre">&quot;python.org&quot;</span></code>) か、オーソリティコンポーネントを含む URL (例 <code class="docutils literal notranslate"><span class="pre">&quot;http://python.org&quot;</span></code>) です。どちらの場合も、オーソリティはユーザ情報コンポーネントを含んではいけません (なので、 <code class="docutils literal notranslate"><span class="pre">&quot;python.org&quot;</span></code> や <code class="docutils literal notranslate"><span class="pre">&quot;python.org:80&quot;</span></code> は正しく、 <code class="docutils literal notranslate"><span class="pre">&quot;joe:password&#64;python.org&quot;</span></code> は不正です) 。</p>
</dd></dl>

</div>
<div class="section" id="httpbasicauthhandler-objects">
<span id="http-basic-auth-handler"></span><h2>HTTPBasicAuthHandler オブジェクト<a class="headerlink" href="#httpbasicauthhandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPBasicAuthHandler.http_error_401">
<code class="descclassname">HTTPBasicAuthHandler.</code><code class="descname">http_error_401</code><span class="sig-paren">(</span><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPBasicAuthHandler.http_error_401" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>認証情報がある場合、認証情報付きで再度リクエストを試みます。</p>
</dd></dl>

</div>
<div class="section" id="proxybasicauthhandler-objects">
<span id="proxy-basic-auth-handler"></span><h2>ProxyBasicAuthHandler オブジェクト<a class="headerlink" href="#proxybasicauthhandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.ProxyBasicAuthHandler.http_error_407">
<code class="descclassname">ProxyBasicAuthHandler.</code><code class="descname">http_error_407</code><span class="sig-paren">(</span><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyBasicAuthHandler.http_error_407" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>認証情報がある場合、認証情報付きで再度リクエストを試みます。</p>
</dd></dl>

</div>
<div class="section" id="abstractdigestauthhandler-objects">
<span id="abstract-digest-auth-handler"></span><h2>AbstractDigestAuthHandler オブジェクト<a class="headerlink" href="#abstractdigestauthhandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.AbstractDigestAuthHandler.http_error_auth_reqed">
<code class="descclassname">AbstractDigestAuthHandler.</code><code class="descname">http_error_auth_reqed</code><span class="sig-paren">(</span><em>authreq</em>, <em>host</em>, <em>req</em>, <em>headers</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractDigestAuthHandler.http_error_auth_reqed" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>authreq</em> はリクエストにおいてレルムに関する情報が含まれているヘッダーの名前、 <em>host</em> は認証を行う対象のホスト名、 <em>req</em> は  (失敗した) <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> オブジェクト、そして <em>headers</em> はエラーヘッダーでなくてはなりません。</p>
</dd></dl>

</div>
<div class="section" id="httpdigestauthhandler-objects">
<span id="http-digest-auth-handler"></span><h2>HTTPDigestAuthHandler オブジェクト<a class="headerlink" href="#httpdigestauthhandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPDigestAuthHandler.http_error_401">
<code class="descclassname">HTTPDigestAuthHandler.</code><code class="descname">http_error_401</code><span class="sig-paren">(</span><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPDigestAuthHandler.http_error_401" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>認証情報がある場合、認証情報付きで再度リクエストを試みます。</p>
</dd></dl>

</div>
<div class="section" id="proxydigestauthhandler-objects">
<span id="proxy-digest-auth-handler"></span><h2>ProxyDigestAuthHandler オブジェクト<a class="headerlink" href="#proxydigestauthhandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.ProxyDigestAuthHandler.http_error_407">
<code class="descclassname">ProxyDigestAuthHandler.</code><code class="descname">http_error_407</code><span class="sig-paren">(</span><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyDigestAuthHandler.http_error_407" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>認証情報がある場合、認証情報付きで再度リクエストを試みます。</p>
</dd></dl>

</div>
<div class="section" id="httphandler-objects">
<span id="http-handler-objects"></span><h2>HTTPHandler オブジェクト<a class="headerlink" href="#httphandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPHandler.http_open">
<code class="descclassname">HTTPHandler.</code><code class="descname">http_open</code><span class="sig-paren">(</span><em>req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPHandler.http_open" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>HTTP リクエストを送ります。 <code class="docutils literal notranslate"><span class="pre">req.has_data()</span></code> に応じて、 GET または POST のどちらでも送ることができます。</p>
</dd></dl>

</div>
<div class="section" id="httpshandler-objects">
<span id="https-handler-objects"></span><h2>HTTPSHandler オブジェクト<a class="headerlink" href="#httpshandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPSHandler.https_open">
<code class="descclassname">HTTPSHandler.</code><code class="descname">https_open</code><span class="sig-paren">(</span><em>req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPSHandler.https_open" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>HTTPS リクエストを送ります。 <code class="docutils literal notranslate"><span class="pre">req.has_data()</span></code> に応じて、 GET または POST のどちらでも送ることができます。</p>
</dd></dl>

</div>
<div class="section" id="filehandler-objects">
<span id="file-handler-objects"></span><h2>FileHandler オブジェクト<a class="headerlink" href="#filehandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.FileHandler.file_open">
<code class="descclassname">FileHandler.</code><code class="descname">file_open</code><span class="sig-paren">(</span><em>req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FileHandler.file_open" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ホスト名がない場合、またはホスト名が <code class="docutils literal notranslate"><span class="pre">'localhost'</span></code> の場合にファイルをローカルでオープンします。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span>このメソッドはローカルのホスト名に対してのみ適用可能です。リモートホスト名が与えられた場合、<a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a> が送出されます。</p>
</div>
</dd></dl>

</div>
<div class="section" id="datahandler-objects">
<span id="data-handler-objects"></span><h2>DataHandler オブジェクト<a class="headerlink" href="#datahandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.DataHandler.data_open">
<code class="descclassname">DataHandler.</code><code class="descname">data_open</code><span class="sig-paren">(</span><em>req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.DataHandler.data_open" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Read a data URL. This kind of URL contains the content encoded in the URL
itself. The data URL syntax is specified in <span class="target" id="index-8"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2397.html"><strong>RFC 2397</strong></a>. This implementation
ignores white spaces in base64 encoded data URLs so the URL may be wrapped
in whatever source file it comes from. But even though some browsers don't
mind about a missing padding at the end of a base64 encoded data URL, this
implementation will raise an <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> in that case.</p>
</dd></dl>

</div>
<div class="section" id="ftphandler-objects">
<span id="ftp-handler-objects"></span><h2>FTPHandler オブジェクト<a class="headerlink" href="#ftphandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.FTPHandler.ftp_open">
<code class="descclassname">FTPHandler.</code><code class="descname">ftp_open</code><span class="sig-paren">(</span><em>req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FTPHandler.ftp_open" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>req</em> で表されるファイルを FTP 越しにオープンします。ログインは常に空のユーザネームおよびパスワードで行われます。</p>
</dd></dl>

</div>
<div class="section" id="cacheftphandler-objects">
<span id="cacheftp-handler-objects"></span><h2>CacheFTPHandler オブジェクト<a class="headerlink" href="#cacheftphandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#urllib.request.CacheFTPHandler" title="urllib.request.CacheFTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">CacheFTPHandler</span></code></a> オブジェクトは <a class="reference internal" href="#urllib.request.FTPHandler" title="urllib.request.FTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FTPHandler</span></code></a> オブジェクトに以下のメソッドを追加したものです:</p>
<dl class="method">
<dt id="urllib.request.CacheFTPHandler.setTimeout">
<code class="descclassname">CacheFTPHandler.</code><code class="descname">setTimeout</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.CacheFTPHandler.setTimeout" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>接続のタイムアウトを <em>t</em> 秒に設定します。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.CacheFTPHandler.setMaxConns">
<code class="descclassname">CacheFTPHandler.</code><code class="descname">setMaxConns</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.CacheFTPHandler.setMaxConns" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>キャッシュ付き接続の最大接続数を <em>m</em> に設定します。</p>
</dd></dl>

</div>
<div class="section" id="unknownhandler-objects">
<span id="unknown-handler-objects"></span><h2>UnknownHandler オブジェクト<a class="headerlink" href="#unknownhandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.UnknownHandler.unknown_open">
<code class="descclassname">UnknownHandler.</code><code class="descname">unknown_open</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.UnknownHandler.unknown_open" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a> 例外を送出します。</p>
</dd></dl>

</div>
<div class="section" id="httperrorprocessor-objects">
<span id="http-error-processor-objects"></span><h2>HTTPErrorProcessor オブジェクト<a class="headerlink" href="#httperrorprocessor-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPErrorProcessor.http_response">
<code class="descclassname">HTTPErrorProcessor.</code><code class="descname">http_response</code><span class="sig-paren">(</span><em>request</em>, <em>response</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPErrorProcessor.http_response" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>HTTP エラー応答の処理をします。</p>
<p>エラーコード 200 の場合、レスポンスオブジェクトを即座に返します。</p>
<p>For non-200 error codes, this simply passes the job on to the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_&lt;type&gt;()</span></code> handler methods, via <a class="reference internal" href="#urllib.request.OpenerDirector.error" title="urllib.request.OpenerDirector.error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OpenerDirector.error()</span></code></a>.
Eventually, <a class="reference internal" href="#urllib.request.HTTPDefaultErrorHandler" title="urllib.request.HTTPDefaultErrorHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPDefaultErrorHandler</span></code></a> will raise an
<a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a> if no other handler handles the error.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPErrorProcessor.https_response">
<code class="descclassname">HTTPErrorProcessor.</code><code class="descname">https_response</code><span class="sig-paren">(</span><em>request</em>, <em>response</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPErrorProcessor.https_response" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>HTTPS エラー応答の処理をします。</p>
<p>振る舞いは <a class="reference internal" href="#urllib.request.HTTPErrorProcessor.http_response" title="urllib.request.HTTPErrorProcessor.http_response"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_response()</span></code></a> と同じです。</p>
</dd></dl>

</div>
<div class="section" id="examples">
<span id="urllib-request-examples"></span><h2>使用例<a class="headerlink" href="#examples" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下の例の他に <a class="reference internal" href="../howto/urllib2.html#urllib-howto"><span class="std std-ref">urllib パッケージを使ってインターネット上のリソースを取得するには</span></a> に多くの例があります。</p>
<p>以下の例では、python.org のメインページを取得して、その最初の 300 バイト分を表示します。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">300</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">b&#39;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>
<span class="go">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;\n\n\n&lt;html</span>
<span class="go">xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot; lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n</span>
<span class="go">&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;\n</span>
<span class="go">&lt;title&gt;Python Programming &#39;</span>
</pre></div>
</div>
<p>urlopen は bytes オブジェクトを返すことに注意してください。これは urlopen が、HTTP サーバーから受信したバイトストリームのエンコーディングを自動的に決定できないためです。一般に、返された bytes オブジェクトを文字列にデコードするためのエンコーディングの決定あるいは推測はプログラム側が行います。</p>
<p>以下の W3C ドキュメント <a class="reference external" href="https://www.w3.org/International/O-charset">https://www.w3.org/International/O-charset</a>には (X)HTML や XML ドキュメントでそのエンコーディング情報を指定するさまざまな方法の一覧があります。</p>
<p>python.org ウェブサイトでは <em>utf-8</em> エンコーディングを使用しており、それをその meta タグで指定していますので、bytes オブジェクトのデコードも同様に行います。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>
<span class="go">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtm</span>
</pre></div>
</div>
<p><a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">コンテキストマネージャー</span></a> を使用しないアプローチでも同様の結果を得ることができます。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="go">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>
<span class="go">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtm</span>
</pre></div>
</div>
<p>以下の例では、データストリームを CGI の標準入力へ送信し、返されたデータを読み込みます。この例は Python が SSL をサポートするように設定してインストールされている場合のみ動作します。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="s1">&#39;https://localhost/cgi-bin/test.cgi&#39;</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">data</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;This data is passed to stdin of the CGI&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">Got Data: &quot;This data is passed to stdin of the CGI&quot;</span>
</pre></div>
</div>
<p>上の例で使われているサンプルの CGI は以下のようになっています:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Content-type: text/plain</span><span class="se">\n\n</span><span class="s1">Got Data: &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>これは <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> を使った <code class="docutils literal notranslate"><span class="pre">PUT</span></code> リクエストの例です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="n">DATA</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;some data&#39;</span>
<span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="s1">&#39;http://localhost:8080&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">DATA</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;PUT&#39;</span><span class="p">)</span>
<span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">reason</span><span class="p">)</span>
</pre></div>
</div>
<p>以下はベーシック HTTP 認証の例です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="c1"># Create an OpenerDirector with support for Basic HTTP Authentication...</span>
<span class="n">auth_handler</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">HTTPBasicAuthHandler</span><span class="p">()</span>
<span class="n">auth_handler</span><span class="o">.</span><span class="n">add_password</span><span class="p">(</span><span class="n">realm</span><span class="o">=</span><span class="s1">&#39;PDQ Application&#39;</span><span class="p">,</span>
                          <span class="n">uri</span><span class="o">=</span><span class="s1">&#39;https://mahler:8092/site-updates.py&#39;</span><span class="p">,</span>
                          <span class="n">user</span><span class="o">=</span><span class="s1">&#39;klem&#39;</span><span class="p">,</span>
                          <span class="n">passwd</span><span class="o">=</span><span class="s1">&#39;kadidd!ehopper&#39;</span><span class="p">)</span>
<span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">build_opener</span><span class="p">(</span><span class="n">auth_handler</span><span class="p">)</span>
<span class="c1"># ...and install it globally so it can be used with urlopen.</span>
<span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">install_opener</span><span class="p">(</span><span class="n">opener</span><span class="p">)</span>
<span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/login.html&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#urllib.request.build_opener" title="urllib.request.build_opener"><code class="xref py py-func docutils literal notranslate"><span class="pre">build_opener()</span></code></a> はデフォルトで沢山のハンドラを提供しており、その中に <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> があります。デフォルトでは、 <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> は <code class="docutils literal notranslate"><span class="pre">&lt;scheme&gt;_proxy</span></code> という環境変数を使います。 ここで <code class="docutils literal notranslate"><span class="pre">&lt;scheme&gt;</span></code> は URL スキームです。例えば、 HTTP プロキシの URL を得るには、環境変数 <span class="target" id="index-28"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">http_proxy</span></code> を読み出します。</p>
<p>この例では、デフォルトの <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> を置き換えてプログラム的に作成したプロキシ URL を使うようにし、 <a class="reference internal" href="#urllib.request.ProxyBasicAuthHandler" title="urllib.request.ProxyBasicAuthHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyBasicAuthHandler</span></code></a> でプロキシ認証サポートを追加します。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">proxy_handler</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">ProxyHandler</span><span class="p">({</span><span class="s1">&#39;http&#39;</span><span class="p">:</span> <span class="s1">&#39;http://www.example.com:3128/&#39;</span><span class="p">})</span>
<span class="n">proxy_auth_handler</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">ProxyBasicAuthHandler</span><span class="p">()</span>
<span class="n">proxy_auth_handler</span><span class="o">.</span><span class="n">add_password</span><span class="p">(</span><span class="s1">&#39;realm&#39;</span><span class="p">,</span> <span class="s1">&#39;host&#39;</span><span class="p">,</span> <span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="s1">&#39;password&#39;</span><span class="p">)</span>

<span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">build_opener</span><span class="p">(</span><span class="n">proxy_handler</span><span class="p">,</span> <span class="n">proxy_auth_handler</span><span class="p">)</span>
<span class="c1"># This time, rather than install the OpenerDirector, we use it directly:</span>
<span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/login.html&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>以下は HTTP ヘッダーを追加する例です:</p>
<p><em>headers</em> 引数を使って <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> コンストラクタを呼び出す方法の他に、以下のようにできます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/&#39;</span><span class="p">)</span>
<span class="n">req</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;Referer&#39;</span><span class="p">,</span> <span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span>
<span class="c1"># Customize the default User-Agent header value:</span>
<span class="n">req</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;User-Agent&#39;</span><span class="p">,</span> <span class="s1">&#39;urllib-example/0.1 (Contact: . . .)&#39;</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> は全ての <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> に <em class="mailheader">User-Agent</em> ヘッダーを自動的に追加します。これを変更するには以下のようにします:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">build_opener</span><span class="p">()</span>
<span class="n">opener</span><span class="o">.</span><span class="n">addheaders</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;User-agent&#39;</span><span class="p">,</span> <span class="s1">&#39;Mozilla/5.0&#39;</span><span class="p">)]</span>
<span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>また、 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> が <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> (や <a class="reference internal" href="#urllib.request.OpenerDirector.open" title="urllib.request.OpenerDirector.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OpenerDirector.open()</span></code></a>)に渡される際には、いくつかの標準ヘッダー (<em class="mailheader">Content-Length</em>, <em class="mailheader">Content-Type</em> および <em class="mailheader">Host</em>) も追加されることを忘れないでください。</p>
<p id="urllib-examples">以下は <code class="docutils literal notranslate"><span class="pre">GET</span></code> メソッドを使ってパラメータを含む URL を取得するセッションの例です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.parse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">params</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urlencode</span><span class="p">({</span><span class="s1">&#39;spam&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;eggs&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;http://www.musi-cal.com/cgi-bin/query?</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">params</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>以下の例では、<code class="docutils literal notranslate"><span class="pre">POST</span></code> メソッドを使用しています。urlencode から出力されたパラメーターは urlopen にデータとして渡される前に bytes にエンコードされていることに注意してください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.parse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urlencode</span><span class="p">({</span><span class="s1">&#39;spam&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;eggs&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s2">&quot;http://requestb.in/xrbl82xr&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>以下の例では、環境変数による設定内容に対して上書きする形で HTTP プロキシを明示的に設定しています:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proxies</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;http&#39;</span><span class="p">:</span> <span class="s1">&#39;http://proxy.example.com:8080/&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">FancyURLopener</span><span class="p">(</span><span class="n">proxies</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;http://www.python.org&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>以下の例では、環境変数による設定内容に対して上書きする形で、まったくプロキシを使わないよう設定しています:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">FancyURLopener</span><span class="p">({})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;http://www.python.org/&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
</div>
<div class="section" id="legacy-interface">
<h2>レガシーインターフェース<a class="headerlink" href="#legacy-interface" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下の関数およびクラスは、Python 2 のモジュール <code class="docutils literal notranslate"><span class="pre">urllib</span></code> (<code class="docutils literal notranslate"><span class="pre">urllib2</span></code> ではありません) から移植されたものです。これらは将来的に廃止されるかもしれません。</p>
<dl class="function">
<dt id="urllib.request.urlretrieve">
<code class="descclassname">urllib.request.</code><code class="descname">urlretrieve</code><span class="sig-paren">(</span><em>url</em>, <em>filename=None</em>, <em>reporthook=None</em>, <em>data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.urlretrieve" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>URL で表されるネットワークオブジェクトをローカルファイルにコピーします。 URL がローカルファイルを示している場合は、ファイル名が与えられない限りオブジェクトはコピーされません。戻り値はタプル <code class="docutils literal notranslate"><span class="pre">(filename,</span> <span class="pre">headers)</span></code> になり、 <em>filename</em> はオブジェクトが保存されたローカルファイル名、 <em>headers</em> は (リモートオブジェクトに対しては) <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> が返したオブジェクトの <code class="xref py py-meth docutils literal notranslate"><span class="pre">info()</span></code> メソッドが返すものすべてになります。例外は <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> のものと同じになります。</p>
<p>The second argument, if present, specifies the file location to copy to (if
absent, the location will be a tempfile with a generated name). The third
argument, if present, is a callable that will be called once on
establishment of the network connection and once after each block read
thereafter.  The callable will be passed three arguments; a count of blocks
transferred so far, a block size in bytes, and the total size of the file.  The
third argument may be <code class="docutils literal notranslate"><span class="pre">-1</span></code> on older FTP servers which do not return a file
size in response to a retrieval request.</p>
<p>以下は最も一般的な使用例です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">local_filename</span><span class="p">,</span> <span class="n">headers</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlretrieve</span><span class="p">(</span><span class="s1">&#39;http://python.org/&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">html</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">local_filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">html</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p><em>url</em> が <code class="file docutils literal notranslate"><span class="pre">http:</span></code> スキーム識別子を使用していた場合、任意の引数 <em>data</em> は <code class="docutils literal notranslate"><span class="pre">POST</span></code> リクエストの指定に使用される場合があります (通常のリクエストタイプは <code class="docutils literal notranslate"><span class="pre">GET</span></code> です)。引数 <em>data</em> は標準 <em class="mimetype">application/x-www-form-urlencoded</em> 形式のバイトオブジェクトでなければなりません。 <a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> 関数を参照してください。</p>
<p><a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a> は、予想 (これは <em>Content-Length</em> ヘッダーにより通知されるサイズです) よりも取得できるデータ量が少ないことを検知した場合、 <code class="xref py py-exc docutils literal notranslate"><span class="pre">ContentTooShortError</span></code> を発生します。これは、例えば、ダウンロードが中断された場合などに発生します。</p>
<p><em>Content-Length</em> はデータ量の下限です: 読み込むデータ量がこれを超えている場合 urlretrieve はそれらも読み込みますが、利用できるデータがこれを下回った場合、例外が送出されます。</p>
<p>このような場合にもダウンロードされたデータを取得することは可能で、これは exception インスタンスの <code class="xref py py-attr docutils literal notranslate"><span class="pre">content</span></code> 属性に保存されています。</p>
<p><em>Content-Length</em> ヘッダーが与えられなれけば urlretrieve はダウンロードしたデータのサイズをチェックできません。この場合ダウンロードは正常に完了したとみなすしかありません。</p>
</dd></dl>

<dl class="function">
<dt id="urllib.request.urlcleanup">
<code class="descclassname">urllib.request.</code><code class="descname">urlcleanup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.urlcleanup" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>以前の <a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a> 呼び出し後に残っているかもしれない一時ファイルをクリーンアップします。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.URLopener">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">URLopener</code><span class="sig-paren">(</span><em>proxies=None</em>, <em>**x509</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">バージョン 3.3 で非推奨.</span></p>
</div>
<p>URL をオープンし、読み出すためのクラスの基底クラスです。<code class="file docutils literal notranslate"><span class="pre">http:</span></code>, <code class="file docutils literal notranslate"><span class="pre">ftp:</span></code>, <code class="file docutils literal notranslate"><span class="pre">file:</span></code> 以外のスキームを使ったオブジェクトのオープンをサポートしたいのでないかぎり、<a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> を使おうと思うことになるでしょう。</p>
<p>デフォルトでは、 <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> クラスは <em class="mailheader">User-Agent</em> ヘッダーとして <code class="docutils literal notranslate"><span class="pre">urllib/VVV</span></code> を送信します。ここで <em>VVV</em> は <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> のバージョン番号です。アプリケーションで独自の <em class="mailheader">User-Agent</em> ヘッダーを送信したい場合は、 <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> かまたは <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> のサブクラスを作成し、サブクラス定義においてクラス属性 <a class="reference internal" href="#urllib.request.URLopener.version" title="urllib.request.URLopener.version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">version</span></code></a> を適切な文字列値に設定することで行うことができます。</p>
<p>オプションのパラメーター <em>proxies</em> はスキーム名をプロキシの URL にマップする辞書でなければなりません。空の辞書はプロキシ機能を完全にオフにします。デフォルトの値は <code class="docutils literal notranslate"><span class="pre">None</span></code> で、この場合、 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> の定義で述べたように、プロキシを設定する環境変数が存在するならそれを使います。</p>
<p>追加のキーワードパラメーターは <em>x509</em> に集められますが、これは <code class="file docutils literal notranslate"><span class="pre">https:</span></code> スキームを使った際のクライアント認証に使われることがあります。キーワード引数 <em>key_file</em> および <em>cert_file</em> が SSL 鍵と証明書を設定するためにサポートされています; クライアント認証をするには両方が必要です。</p>
<p><a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> オブジェクトはサーバーがエラーコードを返した場合に <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 例外を送出します。</p>
<dl class="method">
<dt id="urllib.request.URLopener.open">
<code class="descname">open</code><span class="sig-paren">(</span><em>fullurl</em>, <em>data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener.open" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>適切なプロトコルを使って <em>fullurl</em> を開きます。このメソッドはキャッシュとプロキシ情報を設定し、その後適切な open メソッドを入力引数つきで呼び出します。認識できないスキームが与えられた場合、 <a class="reference internal" href="#urllib.request.URLopener.open_unknown" title="urllib.request.URLopener.open_unknown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open_unknown()</span></code></a> が呼び出されます。 <em>data</em> 引数は <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> の引数 <em>data</em> と同じ意味を持っています。</p>
<p>This method always quotes <em>fullurl</em> using <a class="reference internal" href="urllib.parse.html#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.URLopener.open_unknown">
<code class="descname">open_unknown</code><span class="sig-paren">(</span><em>fullurl</em>, <em>data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener.open_unknown" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オーバライド可能な、未知のタイプの URL を開くためのインタフェースです。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.URLopener.retrieve">
<code class="descname">retrieve</code><span class="sig-paren">(</span><em>url</em>, <em>filename=None</em>, <em>reporthook=None</em>, <em>data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener.retrieve" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>url</em> の内容を取得し、<em>filename</em> に保存します。戻り値は、ローカルファイル名と、レスポンスヘッダーが含まれる <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">email.message.Message</span></code></a> (リモート URL の場合) か <code class="docutils literal notranslate"><span class="pre">None</span></code> (ローカル URL の場合) からなるタプルになります。呼び出し側は、その後 <em>filename</em> を開いてその内容を読み込まなければなりません。<em>filename</em> が与えられず、URL がローカルファイルを参照している場合、入力ファイル名が返されます。URL がローカルでなく、<em>filename</em> が与えられていない場合、ファイル名は入力 URL のパスの最後の構成要素のサフィックスとマッチするサフィックスを持つ <a class="reference internal" href="tempfile.html#tempfile.mktemp" title="tempfile.mktemp"><code class="xref py py-func docutils literal notranslate"><span class="pre">tempfile.mktemp()</span></code></a> の出力になります。<em>reporthook</em> が与えられている場合、3 つの数値 (チャンク数、読み込んだチャンクの最大サイズ、および総ダウンロードサイズ --- 不明の場合は -1) の引数を受け取る関数でなければなりません。これは開始時に 1 回と、ネットワークからデータのチャンクを読み込む度に呼び出されます。<em>reporthook</em> はローカル URL に対しては無視されます。</p>
<p><em>url</em> が <code class="file docutils literal notranslate"><span class="pre">http:</span></code> スキーム識別子を使用していた場合、任意の引数 <em>data</em> は <code class="docutils literal notranslate"><span class="pre">POST</span></code> リクエストの指定に使用される場合があります (通常のリクエストタイプは <code class="docutils literal notranslate"><span class="pre">GET</span></code> です)。引数 <em>data</em> は標準 <em class="mimetype">application/x-www-form-urlencoded</em> 形式でなければなりません。<a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> 関数を参照してください。</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.URLopener.version">
<code class="descname">version</code><a class="headerlink" href="#urllib.request.URLopener.version" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>URL をオープンするオブジェクトのユーザエージェントを指定する変数です。 <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> を特定のユーザエージェントであるとサーバに通知するには、サブクラスの中でこの値をクラス変数として値を設定するか、コンストラクタの中でベースクラスを呼び出す前に値を設定してください。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="urllib.request.FancyURLopener">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">FancyURLopener</code><span class="sig-paren">(</span><em>...</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FancyURLopener" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">バージョン 3.3 で非推奨.</span></p>
</div>
<p><a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> は <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> のサブクラスで、以下の HTTP レスポンスコード: 301、302、303、 307、および 401 を取り扱う機能を提供します。レスポンスコード 30x に対しては、 <em class="mailheader">Location</em> ヘッダーを使って実際の URL を取得します。レスポンスコード 401 (認証が要求されていることを示す) に対しては、BASIC認証 (basic HTTP authintication) が行われます。レスポンスコード 30x に対しては、最大で <em>maxtries</em> 属性に指定された数だけ再帰呼び出しを行うようになっています。この値はデフォルトで 10 です。</p>
<p>その他のレスポンスコードについては、 <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_default()</span></code> が呼ばれます。これはサブクラスでエラーを適切に処理するようにオーバーライドすることができます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><span class="target" id="index-29"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2616.html"><strong>RFC 2616</strong></a> によると、 POST 要求に対する 301 および 302 応答はユーザの承認無しに自動的にリダイレクトしてはなりません。実際は、これらの応答に対して自動リダイレクトを許すブラウザでは POST を GET に変更しており、 <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> でもこの動作を再現します。</p>
</div>
<p>コンストラクタに与えるパラメーターは <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> と同じです。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">基本的な HTTP 認証を行う際、 <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> インスタンスは <a class="reference internal" href="#urllib.request.FancyURLopener.prompt_user_passwd" title="urllib.request.FancyURLopener.prompt_user_passwd"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prompt_user_passwd()</span></code></a> メソッドを呼び出します。このメソッドはデフォルトでは実行を制御している端末上で認証に必要な情報を要求するように実装されています。必要ならば、このクラスのサブクラスにおいてより適切な動作をサポートするために <a class="reference internal" href="#urllib.request.FancyURLopener.prompt_user_passwd" title="urllib.request.FancyURLopener.prompt_user_passwd"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prompt_user_passwd()</span></code></a> メソッドをオーバライドしてもかまいません。</p>
</div>
<p><a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> クラスはオーバライド可能な追加のメソッドを提供しており、適切な振る舞いをさせることができます:</p>
<dl class="method">
<dt id="urllib.request.FancyURLopener.prompt_user_passwd">
<code class="descname">prompt_user_passwd</code><span class="sig-paren">(</span><em>host</em>, <em>realm</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FancyURLopener.prompt_user_passwd" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたセキュリティ領域 (security realm) 下にある与えられたホストにおいて、ユーザー認証に必要な情報を返すための関数です。この関数が返す値は <code class="docutils literal notranslate"><span class="pre">(user,</span> <span class="pre">password)</span></code> からなるタプルでなければなりません。値は Basic 認証で使われます。</p>
<p>このクラスでの実装では、端末に情報を入力するようプロンプトを出します; ローカルの環境において適切な形で対話型モデルを使うには、このメソッドをオーバライドしなければなりません。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="urllib-request-restrictions">
<h2><a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> の制限事項<a class="headerlink" href="#urllib-request-restrictions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<blockquote>
<div></div></blockquote>
<ul id="index-11">
<li><p class="first">現在、次のプロトコルのみサポートされています: HTTP (バージョン 0.9 および 1.0)、FTP、ローカルファイル、およびデータ URL</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>データ URL サポートが追加されました。</p>
</div>
</li>
<li><p class="first"><a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a> のキャッシュ機能は、誰かが Expiration time ヘッダーの正しい処理をハックする時間を見つけるまで無効にされています。</p>
</li>
<li><p class="first">ある URL がキャッシュにあるかどうか調べるような関数があればと思っています。</p>
</li>
<li><p class="first">後方互換性のため、 URL がローカルシステム上のファイルを指しているように見えるにも関わらずファイルを開くことができなければ、 URL は FTP プロトコルを使って再解釈されます。この機能は時として混乱を招くエラーメッセージを引き起こします。</p>
</li>
<li><p class="first">関数 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> および <a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a> は、ネットワーク接続が確立されるまでの間、一定でない長さの遅延を引き起こすことがあります。このことは、これらの関数を使ってインタラクティブな Web クライアントを構築するのはスレッドなしには難しいことを意味します。</p>
</li>
<li id="index-12"><p class="first"><a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> あるいは <a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a> が返すデータはサーバーから返された生データです。これは (画像のような) バイナリ、プレーンテキスト、あるいは (例えば) HTML などになります。HTTP プロトコルはレスポンスヘッダー内でタイプ情報を提供しており、<em class="mailheader">Content-Type</em> ヘッダーを見ることで調査できます。返されたデータが HTML の場合、モジュール <a class="reference internal" href="html.parser.html#module-html.parser" title="html.parser: A simple parser that can handle HTML and XHTML."><code class="xref py py-mod docutils literal notranslate"><span class="pre">html.parser</span></code></a> を使用してこれを解析できます。</p>
</li>
<li id="index-13"><p class="first">FTP プロトコルを扱うコードでは、ファイルとディレクトリを区別できません。このことから、アクセスできないファイルを指している URL からデータを読み出そうとすると、予期しない動作を引き起こす場合があります。 URL が <code class="docutils literal notranslate"><span class="pre">/</span></code> で終わっていれば、ディレクトリを指しているものとみなして、それに適した処理を行います。しかし、ファイルの読み出し操作が 550 エラー (URL が存在しないか、主にパーミッションの理由でアクセスできない) になった場合、 URL がディレクトリを指していて、末尾の <code class="docutils literal notranslate"><span class="pre">/</span></code> を忘れたケースを処理するため、パスをディレクトリとして扱います。このために、パーミッションのためにアクセスできないファイルを fetch しようとすると、FTP コードはそのファイルを開こうとして 550 エラーに陥り、次にディレクトリ一覧を表示しようとするため、誤解を生むような結果を引き起こす可能性があるのです。よく調整された制御が必要なら、 <a class="reference internal" href="ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftplib</span></code></a> モジュールを使うか、 <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> をサブクラス化するか、 <em>_urlopener</em> を変更して目的に合わせるよう検討してください。</p>
</li>
</ul>
</div>
</div>
<div class="section" id="module-urllib.response">
<span id="urllib-response-response-classes-used-by-urllib"></span><h1><a class="reference internal" href="#module-urllib.response" title="urllib.response: Response classes used by urllib."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.response</span></code></a> --- urllib で使用するレスポンスクラス<a class="headerlink" href="#module-urllib.response" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p><a class="reference internal" href="#module-urllib.response" title="urllib.response: Response classes used by urllib."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.response</span></code></a> モジュールは、<code class="docutils literal notranslate"><span class="pre">read()</span></code> および <code class="docutils literal notranslate"><span class="pre">readline()</span></code> を含む 最小限のファイルライクインターフェースを定義する関数およびクラスを定義しています。代表的なレスポンスオブジェクトは addinfourl インスタンスで、レスポンスヘッダーを返す <code class="docutils literal notranslate"><span class="pre">info()</span></code> メソッドおよび URL を返す <code class="docutils literal notranslate"><span class="pre">geturl()</span></code> メソッドを定義しています。このモジュールで定義された関数は、<a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> モジュール内で使用されます。</p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">urllib.request</span></code> --- URL を開くための拡張可能なライブラリ</a><ul>
<li><a class="reference internal" href="#request-objects">Request オブジェクト</a></li>
<li><a class="reference internal" href="#openerdirector-objects">OpenerDirector オブジェクト</a></li>
<li><a class="reference internal" href="#basehandler-objects">BaseHandler オブジェクト</a></li>
<li><a class="reference internal" href="#httpredirecthandler-objects">HTTPRedirectHandler オブジェクト</a></li>
<li><a class="reference internal" href="#httpcookieprocessor-objects">HTTPCookieProcessor オブジェクト</a></li>
<li><a class="reference internal" href="#proxyhandler-objects">ProxyHandler オブジェクト</a></li>
<li><a class="reference internal" href="#httppasswordmgr-objects">HTTPPasswordMgr オブジェクト</a></li>
<li><a class="reference internal" href="#httppasswordmgrwithpriorauth-objects">HTTPPasswordMgrWithPriorAuth オブジェクト</a></li>
<li><a class="reference internal" href="#abstractbasicauthhandler-objects">AbstractBasicAuthHandler オブジェクト</a></li>
<li><a class="reference internal" href="#httpbasicauthhandler-objects">HTTPBasicAuthHandler オブジェクト</a></li>
<li><a class="reference internal" href="#proxybasicauthhandler-objects">ProxyBasicAuthHandler オブジェクト</a></li>
<li><a class="reference internal" href="#abstractdigestauthhandler-objects">AbstractDigestAuthHandler オブジェクト</a></li>
<li><a class="reference internal" href="#httpdigestauthhandler-objects">HTTPDigestAuthHandler オブジェクト</a></li>
<li><a class="reference internal" href="#proxydigestauthhandler-objects">ProxyDigestAuthHandler オブジェクト</a></li>
<li><a class="reference internal" href="#httphandler-objects">HTTPHandler オブジェクト</a></li>
<li><a class="reference internal" href="#httpshandler-objects">HTTPSHandler オブジェクト</a></li>
<li><a class="reference internal" href="#filehandler-objects">FileHandler オブジェクト</a></li>
<li><a class="reference internal" href="#datahandler-objects">DataHandler オブジェクト</a></li>
<li><a class="reference internal" href="#ftphandler-objects">FTPHandler オブジェクト</a></li>
<li><a class="reference internal" href="#cacheftphandler-objects">CacheFTPHandler オブジェクト</a></li>
<li><a class="reference internal" href="#unknownhandler-objects">UnknownHandler オブジェクト</a></li>
<li><a class="reference internal" href="#httperrorprocessor-objects">HTTPErrorProcessor オブジェクト</a></li>
<li><a class="reference internal" href="#examples">使用例</a></li>
<li><a class="reference internal" href="#legacy-interface">レガシーインターフェース</a></li>
<li><a class="reference internal" href="#urllib-request-restrictions"><code class="docutils literal notranslate"><span class="pre">urllib.request</span></code> の制限事項</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-urllib.response"><code class="docutils literal notranslate"><span class="pre">urllib.response</span></code> --- urllib で使用するレスポンスクラス</a></li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="urllib.html"
                        title="前の章へ"><code class="docutils literal notranslate"><span class="pre">urllib</span></code> --- URL を扱うモジュール群</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="urllib.parse.html"
                        title="次の章へ"><code class="docutils literal notranslate"><span class="pre">urllib.parse</span></code> --- URL を解析して構成要素にする</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.8/Doc/library/urllib.request.rst"
            rel="nofollow">ソースコードを表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="urllib.parse.html" title="urllib.parse --- URL を解析して構成要素にする"
             >次へ</a> |</li>
        <li class="right" >
          <a href="urllib.html" title="urllib --- URL を扱うモジュール群"
             >前へ</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.3 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" >インターネットプロトコルとサポート</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" type="text" name="q" />
          <input type="submit" value="検索" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">著作権</a> 2001-2020, Python Software Foundation.
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最終更新: 5月 16, 2020
    <a href="https://docs.python.org/3/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>

  </body>
</html>