
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>What&#39;s New in Python 2.3 &#8212; Python 3.8.3rc1 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.8.3rc1 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="next" title="What&#39;s New in Python 2.2" href="2.2.html" />
    <link rel="prev" title="What&#39;s New in Python 2.4" href="2.4.html" />
    <link rel="canonical" href="https://docs.python.org/3/whatsnew/2.3.html" />
    
      
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="2.2.html" title="What&#39;s New in Python 2.2"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="2.4.html" title="What&#39;s New in Python 2.4"
             accesskey="P">前へ</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.3rc1 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">What's New in Python</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" type="text" name="q" />
          <input type="submit" value="検索" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="what-s-new-in-python-2-3">
<h1>What's New in Python 2.3<a class="headerlink" href="#what-s-new-in-python-2-3" title="このヘッドラインへのパーマリンク">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">著者:</th><td class="field-body">A.M. Kuchling</td>
</tr>
</tbody>
</table>
<p>この文書は Python 2.3 の新機能について解説します。Python 2.3 は 2003 年 7 月 29 日にリリースされました。</p>
<p>Python 2.3 の主要なテーマは、2.2 で追加されたいくつかの機能を磨くこと、言語中核に小さいながらも有用な種々の拡張をすること、そして標準ライブラリの拡充です。ひとつ前のバージョンで導入された新しいオブジェクトモデルは、18 ヶ月に渡るバグフィックスと新スタイルクラスの性能改善をもたらした最適化の努力の恩恵を受けました。 <a class="reference internal" href="../library/functions.html#sum" title="sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a>, <a class="reference internal" href="../library/functions.html#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a> のような、新たなビルトイン関数が少し追加されました。 <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> 演算子がサブストリングの検索に使えるようになりました (例えば <code class="docutils literal notranslate"><span class="pre">&quot;ab&quot;</span> <span class="pre">in</span> <span class="pre">&quot;abc&quot;</span></code> は <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> を返します)。</p>
<p>たくさんのライブラリ新機能…、Boolean、 set、 heap、 日付/時刻データ型、ZIP 形式アーカイブからのモジュールインポート、待ち望まれていた Python カタログのためのメタデータサポート、更新されたバージョンの IDLE、ロギングメッセージのためのモジュール、テキストの折り返し、CSV ファイルの解析、コマンドラインオプションの処理、BerkeleyDB データベースの使用…、新機能、強化機能のリストは長大になります。</p>
<p>このドキュメントは個々の新機能の完全な詳細を提供するのではなくて、簡易な概要を提供することを目的にしています。完全な詳細が知りたければ、 Python ライブラリリファレンス、Python リファレンスマニュアルのような Python 2.4 のドキュメントを参照してください。設計と実装の根拠を理解したい場合は、新機能に関する PEP を参照してください。</p>
<div class="section" id="pep-218-a-standard-set-datatype">
<h2>PEP 218: 標準の集合データ型<a class="headerlink" href="#pep-218-a-standard-set-datatype" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>(---訳注: イキナリですが、あなたが今これを「Python の歴史を知る」もしくは「初登場時の熱量高い紹介」を読みたくて読んでいるのでない限りは、もしくは本当に今 2.3 を使う必要があれば別ですが、このモジュールは 2.4 で既にビルトインで置き換えられ、2.6 では非推奨となり、3.0 では削除されています。ので、集合型について知りたければここよりも 2.4 のビルトインの方から読んだ方が良いです。---) --- 新しいモジュール <code class="xref py py-mod docutils literal notranslate"><span class="pre">sets</span></code> には、集合データ型の実装が含まれています。 <code class="xref py py-class docutils literal notranslate"><span class="pre">Set</span></code> クラスは <a class="reference internal" href="../glossary.html#term-mutable"><span class="xref std std-term">mutable</span></a> の集合のためのクラスで、メンバの追加と削除が出来ます。 <code class="xref py py-class docutils literal notranslate"><span class="pre">ImmutableSet</span></code> は変更できない集合のためのクラスなので、辞書のキーとして利用出来ます。集合型は辞書の上に構築されているので、集合内の要素はハッシュ可能でなければなりません。</p>
<p>単純な使用例です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">sets</span><span class="o">.</span><span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span>
<span class="go">Set([1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="ow">in</span> <span class="n">S</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="ow">in</span> <span class="n">S</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span>
<span class="go">Set([1, 2, 5])</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>和集合 (union) と共通集合 (intersection) は <code class="xref py py-meth docutils literal notranslate"><span class="pre">union()</span></code> と <code class="xref py py-meth docutils literal notranslate"><span class="pre">intersection()</span></code> メソッドで計算出来ます; 別の記法として、ビット演算子 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> と <code class="docutils literal notranslate"><span class="pre">|</span></code> も使えます。変更可能な集合ではこれらのインプレイス版 <code class="xref py py-meth docutils literal notranslate"><span class="pre">union_update()</span></code> と <code class="xref py py-meth docutils literal notranslate"><span class="pre">intersection_update()</span></code> も使えます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span> <span class="o">=</span> <span class="n">sets</span><span class="o">.</span><span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S2</span> <span class="o">=</span> <span class="n">sets</span><span class="o">.</span><span class="n">Set</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span>
<span class="go">Set([1, 2, 3, 4, 5, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span> <span class="o">|</span> <span class="n">S2</span>                  <span class="c1"># Alternative notation</span>
<span class="go">Set([1, 2, 3, 4, 5, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span>
<span class="go">Set([])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span> <span class="o">&amp;</span> <span class="n">S2</span>                  <span class="c1"># Alternative notation</span>
<span class="go">Set([])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span><span class="o">.</span><span class="n">union_update</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span>
<span class="go">Set([1, 2, 3, 4, 5, 6])</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>It's also possible to take the symmetric difference of two sets.  This is the
set of all elements in the union that aren't in the intersection.  Another way
of putting it is that the symmetric difference contains all elements that are in
exactly one set.  Again, there's an alternative notation (<code class="docutils literal notranslate"><span class="pre">^</span></code>), and an
in-place version with the ungainly name <code class="xref py py-meth docutils literal notranslate"><span class="pre">symmetric_difference_update()</span></code>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span> <span class="o">=</span> <span class="n">sets</span><span class="o">.</span><span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S2</span> <span class="o">=</span> <span class="n">sets</span><span class="o">.</span><span class="n">Set</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span>
<span class="go">Set([1, 2, 5, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span> <span class="o">^</span> <span class="n">S2</span>
<span class="go">Set([1, 2, 5, 6])</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">issubset()</span></code> と <code class="xref py py-meth docutils literal notranslate"><span class="pre">issuperset()</span></code> メソッドも使えます。これはある集合が部分集合、上位集合であるかとうかをチェックします:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span> <span class="o">=</span> <span class="n">sets</span><span class="o">.</span><span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S2</span> <span class="o">=</span> <span class="n">sets</span><span class="o">.</span><span class="n">Set</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S2</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-55"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0218"><strong>PEP 218</strong></a> - 集合オブジェクト型をビルトインに追加する</dt>
<dd>PEP 著 Greg V. Wilson. 実装: Greg V. Wilson, Alex Martelli, GvR. (---訳注: PEPそのものは 2.4 のビルトイン型 set, frozenset の追加と同じものですが、2.3 ではモジュールとして追加され、2.4 でビルトイン版が追加され、2.6 でモジュール版が非推奨となった、という流れです。---)</dd>
</dl>
</div>
</div>
<div class="section" id="pep-255-simple-generators">
<span id="section-generators"></span><h2>PEP 255: 単純なジェネレータ<a class="headerlink" href="#pep-255-simple-generators" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 2.2 では、ジェネレータが <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">generators</span></code> ディレクティブで有効に出来るオプションの機能として追加されました。2.3 ではジェネレータは特別に有効化する必要なく、もうキーワード <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> として、いつでもそこにあります。このセクションの残りの部分は &quot;What's New in Python 2.2&quot; のジェネレータの記述からの丸々コピーですので、2.2 のときに読んだなら読み飛ばしてもらって結構です。</p>
<p>Python や C の標準的な関数コールについては、よくご存じに違いありません。関数を呼ぶと、ローカル変数を作るプライベートな名前空間ができますね。その関数が <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 文まで来ると、ローカル変数が破壊されてから、返り値が呼び出し元に返ります。次に同じ関数をもう一度呼ぶと、新しいプライベート名前空間に新規のローカル変数が作られるのです。しかし、関数を出るときにローカル変数を捨てなければどうなるでしょうか。その出ていったところから関数を続行できたとしたら、どうでしょう。これこそジェネレータが提供する機能です; すなわち、ジェネレータは続行できる関数と考えることができます。</p>
<p>ジェネレータ関数の最も単純な例です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_ints</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">i</span>
</pre></div>
</div>
<p>A new keyword, <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a>, was introduced for generators.  Any function
containing a <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> statement is a generator function; this is
detected by Python's bytecode compiler which compiles the function specially as
a result.</p>
<p>When you call a generator function, it doesn't return a single value; instead it
returns a generator object that supports the iterator protocol.  On executing
the <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> statement, the generator outputs the value of <code class="docutils literal notranslate"><span class="pre">i</span></code>,
similar to a <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> statement.  The big difference between
<code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> and a <code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code> statement is that on reaching a
<code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> the generator's state of execution is suspended and local
variables are preserved.  On the next call to the generator's <code class="docutils literal notranslate"><span class="pre">.next()</span></code>
method, the function will resume executing immediately after the
<code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> statement.  (For complicated reasons, the <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code>
statement isn't allowed inside the <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> block of a
<code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code>...<code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code> statement; read <span class="target" id="index-1"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0255"><strong>PEP 255</strong></a> for a full
explanation of the interaction between <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> and exceptions.)</p>
<p>上記 <code class="docutils literal notranslate"><span class="pre">generate_ints()</span></code> ジェネレータはこんな具合に使います:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="n">generate_ints</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span>
<span class="go">&lt;generator object at 0x8117f90&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;stdin&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
  File <span class="nb">&quot;stdin&quot;</span>, line <span class="m">2</span>, in <span class="n">generate_ints</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<p>同じく <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">generate_ints(5)</span></code> や <code class="docutils literal notranslate"><span class="pre">a,b,c</span> <span class="pre">=</span> <span class="pre">generate_ints(3)</span></code> といった書き方もできます。</p>
<p>Inside a generator function, the <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> statement can only be used
without a value, and signals the end of the procession of values; afterwards the
generator cannot return any further values. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code> with a value, such
as <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">5</span></code>, is a syntax error inside a generator function.  The end of the
generator's results can also be indicated by raising <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>
manually, or by just letting the flow of execution fall off the bottom of the
function.</p>
<p>自分でクラスを書いて、ジェネレータで言うところのローカル変数をインスタンス変数として全部保管しておけば、同じ効果を得ることは可能です。たとえば整数のリストを返すのは、 <code class="docutils literal notranslate"><span class="pre">self.count</span></code> を 0 にして、 <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a> メソッドが <code class="docutils literal notranslate"><span class="pre">self.count</span></code> をインクリメントして返すようにすればできます。しかしながら、ある程度複雑なジェネレータになってくると、同じことをするクラスを書くのは格段にややこしいことになります。 <code class="file docutils literal notranslate"><span class="pre">Lib/test/test_generators.py</span></code> にはもっと面白い例がたくさん含まれています。一番単純な一つは、ジェネレータを再帰的に使ってツリーを順繰りに横断する実装をするこれです (---訳注: ジェネレータは現在の最新 3.5 までの間に 2 度大きな機能強化が行われているのですが、一つが 2.5 での PEP 342 でこれは yield 「に」値を戻せるようにするものです。もう一つが 3.3 での PEP 380 で、これはサブジェネレータへの委譲 <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;subgen&gt;</span></code> の追加でした。ですのでこの 3.3 からの <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> を使うと下記例はもっとスッキリ書けます。---):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># A recursive generator that generates Tree leaves in in-order.</span>
<span class="k">def</span> <span class="nf">inorder</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">t</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inorder</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">left</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">x</span>
        <span class="k">yield</span> <span class="n">t</span><span class="o">.</span><span class="n">label</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inorder</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">right</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">x</span>
</pre></div>
</div>
<p>ほかにも <code class="file docutils literal notranslate"><span class="pre">Lib/test/test_generators.py</span></code> には、N-Queens 問題 (N×N コマのチェス盤に、互いに攻撃できないような配置で N 個のクイーンを置く) やナイト・ツアー (N×N 盤の全コマをナイトが一度ずつ通るような経路を探す) の解を出す例が入っています。</p>
<p>ジェネレータの発想はほかのプログラミング言語、特に Icon (<a class="reference external" href="https://www.cs.arizona.edu/icon/">https://www.cs.arizona.edu/icon/</a>) から着想しています。Icon ではジェネレータが言語の中枢になっています。Icon では、あらゆる式と関数がジェネレータのように振舞います。 <a class="reference external" href="https://www.cs.arizona.edu/icon/docs/ipd266.htm">https://www.cs.arizona.edu/icon/docs/ipd266.htm</a> の &quot;Icon プログラミング言語の概要&quot; の一つの例が、これがどのようなものであるのかを教えてくれます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sentence</span> <span class="o">:=</span> <span class="s2">&quot;Store it in the neighboring harbor&quot;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">:=</span> <span class="n">find</span><span class="p">(</span><span class="s2">&quot;or&quot;</span><span class="p">,</span> <span class="n">sentence</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="n">then</span> <span class="n">write</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>Icon では <code class="xref py py-func docutils literal notranslate"><span class="pre">find()</span></code> 関数は部分文字列 &quot;or&quot; が見つかる位置 3, 23, 33 を返します。 <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 文内では <code class="docutils literal notranslate"><span class="pre">i</span></code> には最初 3 が代入されますが、これは 3 より小さいので比較は失敗し、Icon は次の値 23 を取り出します。 23 は 5 より大きいので比較は成功し、コードは 23 をスクリーンに表示します。</p>
<p>Python では Icon がそうするほどにはジェネレータを中心的概念に置きません。ジェネレータは Python 言語中核の新たな一面ではありますが、それらを学ぶのも使うのも誰しも行うべきだというものでもなく、そしてこれで解決できない何か問題があれば、忘れてしまっても良いものです。Icon と比較した特筆すべき Python インターフェイスの機能はジェネレータの状態が具象オブジェクト (イテレータ) で表現されることであり、それは他の関数に渡せますし、データ構造に記憶しておくことも出来ます。(---訳注: ジェネレータについてかなり控えめなのは、この時点で著者は将来の拡張を既に見据えていたから? かもしれませんね。PEP 342 と PEP 380 により今やジェネレータはこの頃より遥かに高機能になっており、今ではきっと「こんなものなくても困らない」なんて Python 使いはいないでしょう。---)</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-56"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0255"><strong>PEP 255</strong></a> - 単純なジェネレータ</dt>
<dd>Neil Schemenauer, Tim Peters, Magnus Lie Hetland により著されました。実装のほとんどは Neil Schemenauer と Tim Peters により行われ、 Python Labs クルーにより他の修正が行われました。</dd>
</dl>
</div>
</div>
<div class="section" id="pep-263-source-code-encodings">
<span id="section-encodings"></span><h2>PEP 263: ソースコードのエンコーディング<a class="headerlink" href="#pep-263-source-code-encodings" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python ソースファイルで、異なる文字セットエンコーディングを宣言出来るようになりました。エンコーディングはソースコードの 1 行目か 2 行目に特殊形式のコメントを含めることで宣言出来ます。 UTF-8 ファイルであればこのように宣言出来ます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: UTF-8 -*-</span>
</pre></div>
</div>
<p>このエンコーディング宣言がなければ、デフォルトの 7 ビット ASCII エンコーディングが使われます(訳注: Python 3 からはデフォルトは utf-8 (PEP 3120))。8 ビット文字を含んでいるのにエンコーディング宣言がないモジュールの実行やインポートを行うと、 Python 2.3 では <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> を引き起こします; 2.4 ではこれは構文エラーになる予定です(訳注: 実際には 2.4 ではこれは実現せず、2.5 から)。</p>
<p>エンコーディング宣言は Unicode 文字列リテラルにのみ影響します。それらは指定したエンコーディングで Unicode 文字列に変換されます。Python 識別子は今でも ASCII 文字列に制限されていることに注意してください。ですから普通の英数字範囲外の文字を変数名に使うことは出来ません。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-57"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0263"><strong>PEP 263</strong></a> - Python ソースコードのエンコーディングを定義する</dt>
<dd>Marc-André Lemburg、 Martin von Löwis 著; Suzuki Hisao、 Martin von Löwis 実装.</dd>
</dl>
</div>
</div>
<div class="section" id="pep-273-importing-modules-from-zip-archives">
<h2>PEP 273: Zip アーカイブからモジュールをインポートする<a class="headerlink" href="#pep-273-importing-modules-from-zip-archives" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The new <a class="reference internal" href="../library/zipimport.html#module-zipimport" title="zipimport: Support for importing Python modules from ZIP archives."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipimport</span></code></a> module adds support for importing modules from a
ZIP-format archive.  You don't need to import the module explicitly; it will be
automatically imported if a ZIP archive's filename is added to <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>.
For example:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">amk@nyman:~/src/python$</span> unzip -l /tmp/example.zip
<span class="go">Archive:  /tmp/example.zip</span>
<span class="go">  Length     Date   Time    Name</span>
<span class="go"> --------    ----   ----    ----</span>
<span class="go">     8467  11-26-02 22:30   jwzthreading.py</span>
<span class="go"> --------                   -------</span>
<span class="go">     8467                   1 file</span>
<span class="gp">amk@nyman:~/src/python$</span> ./python
<span class="go">Python 2.3 (#1, Aug 1 2003, 19:54:32)</span>
<span class="gp">&gt;</span>&gt;&gt; import sys
<span class="gp">&gt;</span>&gt;&gt; sys.path.insert<span class="o">(</span><span class="m">0</span>, <span class="s1">&#39;/tmp/example.zip&#39;</span><span class="o">)</span>  <span class="c1"># Add .zip file to front of path</span>
<span class="gp">&gt;</span>&gt;&gt; import jwzthreading
<span class="gp">&gt;</span>&gt;&gt; jwzthreading.__file__
<span class="go">&#39;/tmp/example.zip/jwzthreading.py&#39;</span>
<span class="gp">&gt;</span>&gt;&gt;
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">sys.path</span></code> には今や ZIP 書庫のファイル名も入れることが出来ます。ZIP アーカイブ内にはどんなファイルを置いてもかまいませんが、import できるのは <code class="file docutils literal notranslate"><span class="pre">*.py</span></code>, <code class="file docutils literal notranslate"><span class="pre">*.pyc</span></code>, <code class="file docutils literal notranslate"><span class="pre">*.pyo</span></code> だけです。書庫に <code class="file docutils literal notranslate"><span class="pre">*.py</span></code> だけが含まれる場合には、Python は書庫を修正して対応する <code class="file docutils literal notranslate"><span class="pre">*.pyc</span></code> を作るなどということはしないので、 <code class="file docutils literal notranslate"><span class="pre">*.pyc</span></code> ファイルを含まない ZIP 書庫からのインポートはやや遅いかもしれません。</p>
<p>書庫内のパスをサブディレクトリ以下のみインポートするように指定出来ます; 例えば、パス <code class="file docutils literal notranslate"><span class="pre">/tmp/example.zip/lib/</span></code> はその書庫内の <code class="file docutils literal notranslate"><span class="pre">lib/</span></code> サブディレクトリだけからインポートします。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-58"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0273"><strong>PEP 273</strong></a> - Zip アーカイブからモジュールをインポートする</dt>
<dd>このモジュールの実装も行った、James C. Ahlstrom による PEP です。 Python 2.3 は  <span class="target" id="index-59"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0273"><strong>PEP 273</strong></a> の仕様に従っていますが、 Just van Rossum の書いた、 <span class="target" id="index-60"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> に記述されている import フックによる実装を使っています。その新しい import フックについては  <a class="reference internal" href="#section-pep302"><span class="std std-ref">PEP 302: 新たなインポートフック</span></a>  をみてください。</dd>
</dl>
</div>
</div>
<div class="section" id="pep-277-unicode-file-name-support-for-windows-nt">
<h2>PEP 277: Windows NT での Unicode ファイル名サポート<a class="headerlink" href="#pep-277-unicode-file-name-support-for-windows-nt" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Windows NT, 2000, XP では、ファイルシステムはファイル名として Unicode 文字列を使います。伝統的に Python はファイル名をバイト文字列として表現してきましたが、それはアクセス出来ないファイル名を表してしまう場合があって、不十分でした。</p>
<p>Python はいまや (ファイルシステムの制約の範囲内での) 任意の Unicode 文字列をファイル名が期待される全ての関数で許容します。 <a class="reference internal" href="../library/os.html#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.listdir()</span></code></a> に Unicode 文字列が渡されれば、Python は今では Unicode 文字列のリストを返します。新しい関数 <code class="xref py py-func docutils literal notranslate"><span class="pre">os.getcwdu()</span></code> は Unicode 文字列でカレントディレクトリを返します(訳注: ちなみに Python 3 での Unicode 周りの大改造に伴いこの関数はなくなり、代わりに「あえてバイト列のほうを返す」 <code class="docutils literal notranslate"><span class="pre">os.getcwdb</span></code> が追加されています(<code class="docutils literal notranslate"><span class="pre">os.getcwdu</span></code> がもはや Unicode を返すので)。)。</p>
<p>ファイル名のバイト文字列はいまでも動きます。Windows 版 Python は透過的にそれらを Unicode に <code class="docutils literal notranslate"><span class="pre">mbcs</span></code> エンコーディングを使って変換します。</p>
<p>ほかのシステムでもファイル名の Unicode は許容されますが、システムに渡す前にバイト文字列に変換され、 <a class="reference internal" href="../library/exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a> 例外を引き起こすかもしれません。アプリケーションは任意の Unicode 文字列がファイル名に許されるかどうかを、ブーリアン値 <a class="reference internal" href="../library/os.path.html#os.path.supports_unicode_filenames" title="os.path.supports_unicode_filenames"><code class="xref py py-attr docutils literal notranslate"><span class="pre">os.path.supports_unicode_filenames</span></code></a> をチェックすることでテスト出来ます。</p>
<p>MacOS では、 <a class="reference internal" href="../library/os.html#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.listdir()</span></code></a> は Unicode ファイル名を返すようになっているでしょう。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-61"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0277"><strong>PEP 277</strong></a> - Windows NT での Unicode ファイル名サポート</dt>
<dd>Neil Hodgson 著; 実装 Neil Hodgson, Martin von Löwis, Mark Hammond。</dd>
</dl>
</div>
</div>
<div class="section" id="pep-278-universal-newline-support">
<span id="index-8"></span><h2>PEP 278: Universal Newline サポート<a class="headerlink" href="#pep-278-universal-newline-support" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The three major operating systems used today are Microsoft Windows, Apple's
Macintosh OS, and the various Unix derivatives.  A minor irritation of
cross-platform work  is that these three platforms all use different characters to
mark the ends of lines in text files.  Unix uses the linefeed (ASCII character
10), MacOS uses the carriage return (ASCII character 13), and Windows uses a
two-character sequence of a carriage return plus a newline.</p>
<p>Python のファイルオブジェクトが、動作しているプラットフォームに従わない行終端変換をサポートするようになりました。ファイルのオープンにモード <code class="docutils literal notranslate"><span class="pre">'U'</span></code> や <code class="docutils literal notranslate"><span class="pre">'rU'</span></code> を使うと、 <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a> モードを使った読み込みとしてファイルを開きます。これで <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code>, <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a> などのファイルメソッドが、 3 つどの行終端でも <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> に翻訳して返すようになります。</p>
<p>universal newline サポートはモジュールのインポートと <code class="xref py py-func docutils literal notranslate"><span class="pre">execfile()</span></code> 関数でのファイル実行にも使われます。これで 3 つ全てのオペレーティングシステム間で行終端変換の必要なく Python モジュールを共有出来ます。</p>
<p>This feature can be disabled when compiling Python by specifying the
<code class="xref std std-option docutils literal notranslate"><span class="pre">--without-universal-newlines</span></code> switch when running Python's
<strong class="program">configure</strong> script.</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-62"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0278"><strong>PEP 278</strong></a> : Universal Newline サポート</dt>
<dd>Jack Jansen 著、実装</dd>
</dl>
</div>
</div>
<div class="section" id="pep-279-enumerate">
<span id="section-enumerate"></span><h2>PEP 279: enumerate()<a class="headerlink" href="#pep-279-enumerate" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>新たな組み込み関数 <a class="reference internal" href="../library/functions.html#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a> はある種のループ処理を少し簡潔にするものです。 <em>thing</em> がイテレータかシーケンスだとして、 <code class="docutils literal notranslate"><span class="pre">enumerate(thing)</span></code> は <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">thing[0])</span></code>, <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">thing[1])</span></code>, <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">thing[2])</span></code>, … を生成するイテレータを返します。</p>
<p>リストの全てを変更するためのよくあるイディオムはこのようなものでしょう:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)):</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="c1"># ... compute some result based on item ...</span>
    <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
</pre></div>
</div>
<p>これは <a class="reference internal" href="../library/functions.html#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a> を使ってこのように書き換えることが出来ます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="c1"># ... compute some result based on item ...</span>
    <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-63"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0279"><strong>PEP 279</strong></a> - 組み込み関数 enumerate()</dt>
<dd>Raymond D. Hettinger 著、実装.</dd>
</dl>
</div>
</div>
<div class="section" id="pep-282-the-logging-package">
<h2>PEP 282: ロギングパッケージ<a class="headerlink" href="#pep-282-the-logging-package" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ログ記録のための標準パッケージ <a class="reference internal" href="../library/logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> が Python 2.3 に追加されています。それはログ出力生成の強力で柔軟なメカニズムを提供し、フィルタと加工を色々な方法で行えます。標準フォーマットで書く設定ファイルで、プログラムのロギングの振る舞いを制御出来ます。ログレコードを標準エラー出力やファイルやソケット、システムログへの送信、あるいは e-mail 送信するようなハンドラが Python に含まれています。もちろん、あなた自身のハンドラクラスを書くことも出来ます。</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code> が最も重要なクラスです。ほとんどのアプリケーションコードは一つかそれ以上の <code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code> オブジェクトを扱い、それぞれ一つはそのアプリケーションの特定のサブシステムで使われるでしょう。それぞれの <code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code> は名前で識別され、名前は <code class="docutils literal notranslate"><span class="pre">.</span></code> をコンポーネントのセパレータとして使う階層で体系化されます。例えば <code class="docutils literal notranslate"><span class="pre">server</span></code>, <code class="docutils literal notranslate"><span class="pre">server.auth</span></code>, <code class="docutils literal notranslate"><span class="pre">server.network</span></code> といった名前の <code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code> インスタンスを持つといった具合です。この例の後ろ 2 つは階層で <code class="docutils literal notranslate"><span class="pre">server</span></code> の下にあります。 <code class="docutils literal notranslate"><span class="pre">server</span></code> への冗長性を見つけた場合や <code class="docutils literal notranslate"><span class="pre">server</span></code> メッセージを直接異なるハンドラに向けた場合、変更は <code class="docutils literal notranslate"><span class="pre">server.auth</span></code> と <code class="docutils literal notranslate"><span class="pre">server.network</span></code> へのログ記録にも適用されるということです。全てのほかのロガーの親となる、ルート <code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code> もあります。</p>
<p>単純な用法のために、 <a class="reference internal" href="../library/logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> パッケージはいくつかの便利関数を含んでいて、これは常にルートログを使います:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">logging</span>

<span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Debugging information&#39;</span><span class="p">)</span>
<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Informational message&#39;</span><span class="p">)</span>
<span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Warning:config file </span><span class="si">%s</span><span class="s1"> not found&#39;</span><span class="p">,</span> <span class="s1">&#39;server.conf&#39;</span><span class="p">)</span>
<span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Error occurred&#39;</span><span class="p">)</span>
<span class="n">logging</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s1">&#39;Critical error -- shutting down&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>これは以下のような出力をします:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">WARNING</span><span class="p">:</span><span class="n">root</span><span class="p">:</span><span class="ne">Warning</span><span class="p">:</span><span class="n">config</span> <span class="n">file</span> <span class="n">server</span><span class="o">.</span><span class="n">conf</span> <span class="ow">not</span> <span class="n">found</span>
<span class="n">ERROR</span><span class="p">:</span><span class="n">root</span><span class="p">:</span><span class="n">Error</span> <span class="n">occurred</span>
<span class="n">CRITICAL</span><span class="p">:</span><span class="n">root</span><span class="p">:</span><span class="n">Critical</span> <span class="n">error</span> <span class="o">--</span> <span class="n">shutting</span> <span class="n">down</span>
</pre></div>
</div>
<p>デフォルトの設定では、情報メッセージとデバッグメッセージは揉み消され、また、出力は標準エラー出力に送られます。情報メッセージとデバッグメッセージ表示の有効化は、ルートロガーの <code class="xref py py-meth docutils literal notranslate"><span class="pre">setLevel()</span></code> メソッドを呼び出して行えます。</p>
<p>上の例での <code class="xref py py-func docutils literal notranslate"><span class="pre">warning()</span></code> 呼び出しの文字列フォーマットの操作に注目してください。全てのログメッセージ関数は、引数 <code class="docutils literal notranslate"><span class="pre">(msg,</span> <span class="pre">arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code> を取り、 <code class="docutils literal notranslate"><span class="pre">msg</span> <span class="pre">%</span> <span class="pre">(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code> の結果の文字列をログ出力します。</p>
<p>最も最新のトレースバックを記録する <code class="xref py py-func docutils literal notranslate"><span class="pre">exception()</span></code> 関数もあります。他の全ての関数も、 <em>exc_info</em> 引数を真にすればトレースバックを記録します。:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>    <span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
    <span class="k">except</span><span class="p">:</span> <span class="n">logging</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">&#39;Problem recorded&#39;</span><span class="p">)</span>

<span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
<p>これは以下のような出力をします:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ERROR</span><span class="p">:</span><span class="n">root</span><span class="p">:</span><span class="n">Problem</span> <span class="n">recorded</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;t.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">6</span><span class="p">,</span> <span class="ow">in</span> <span class="n">f</span>
    <span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
<span class="ne">ZeroDivisionError</span><span class="p">:</span> <span class="n">integer</span> <span class="n">division</span> <span class="ow">or</span> <span class="n">modulo</span> <span class="n">by</span> <span class="n">zero</span>
</pre></div>
</div>
<p>多少なりとも高度なプログラムでは、ルートロガー以上のロガーを使うでしょう。 <code class="docutils literal notranslate"><span class="pre">getLogger(name)</span></code> 関数は特定のロガーを取得するのに使います。その時点で存在していなければ、作成されます。 <code class="docutils literal notranslate"><span class="pre">getLogger(None)</span></code> はルートロガーを返します。:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;server&#39;</span><span class="p">)</span>
 <span class="o">...</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Listening on port </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
 <span class="o">...</span>
<span class="n">log</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s1">&#39;Disk full&#39;</span><span class="p">)</span>
 <span class="o">...</span>
</pre></div>
</div>
<p>ログレコードは普通階層を上に向かって伝播するので、 <code class="docutils literal notranslate"><span class="pre">server.auth</span></code> へのログは <code class="docutils literal notranslate"><span class="pre">server</span></code> と <code class="docutils literal notranslate"><span class="pre">root</span></code> にも見られますが、 <code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code> はこれを <code class="xref py py-attr docutils literal notranslate"><span class="pre">propagate</span></code> 属性に <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> を設定することで避けれます。</p>
<p><a class="reference internal" href="../library/logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> パッケージにはさらに、カスタマイズ可能なクラス群があります。 <code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code> インスタンスにログメッセージを伝える際、それは <code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code> インスタンスを作って、任意の数の異なる <code class="xref py py-class docutils literal notranslate"><span class="pre">Handler</span></code> インスタンスへ送ります。ロガーとハンドラにはフィルタのリストを取り付けることも出来、それぞれのフィルタは無視する <code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code> を決めたり、渡す前にレコードを修正したり出来ます。それらが最後に出力される際、 <code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code> インスタンスは <code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code> クラスによりテキストに変換されます。これら全てのクラスはあなた自身の特別に書いたクラスに置き換え可能です。</p>
<p>これら全ての機能で <a class="reference internal" href="../library/logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> パッケージは最も複雑なアプリケーションでさえ、十分な柔軟性を提供しているはずです。ここではそれら機能の不完全な概要しか示しませんでしたので、全ての詳細はパッケージのドキュメントを参照してください。 <span class="target" id="index-64"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0282"><strong>PEP 282</strong></a> を読むことも助けになるでしょう。(---訳注: 今ではクックブックもあるのでそちらもどうぞ。---)</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-65"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0282"><strong>PEP 282</strong></a> - ログシステム</dt>
<dd>PEP 著: Vinay Sajip と Trent Mick; 実装: Vinay Sajip.</dd>
</dl>
</div>
</div>
<div class="section" id="pep-285-a-boolean-type">
<span id="section-bool"></span><h2>PEP 285: Boolean 型<a class="headerlink" href="#pep-285-a-boolean-type" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>真偽値型 (Boolean) が Python 2.3 に追加されました。関連して 2 つの定数 <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> と <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> が <code class="xref py py-mod docutils literal notranslate"><span class="pre">__builtin__</span></code> モジュールに追加されています。(定数 <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> と <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> は Python 2.2.1 にはビルトインに追加されてはいたのですが、 2.2.1 版のものは単純に整数の 1 と 0 をセットしただけのもので、独立した真偽値型ではありませんでした。)</p>
<p>この新しい型の型オブジェクトの名前は <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> です; これのコンストラクタは任意の Python 値を取り、 <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> または <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> に変換します:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">([])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>標準ライブラリモジュールとビルトイン関数のほとんどが、そうすべきときには Boolean を返すように変更されました:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;append&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Python の Boolean はコードを明快にすることを主たる目標として追加されました。例えばあなたがコードを読んでいて <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">1</span></code> に出くわした場合、あなたは考えるはずです。この <code class="docutils literal notranslate"><span class="pre">1</span></code> は、真偽としての真値なのであろうか、それともインデクスだろうか、はたまた何かほかの数量に掛ける係数だろうか、と。 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">True</span></code> であればその意味するところはかなり明らかです。</p>
<p>Python's Booleans were <em>not</em> added for the sake of strict type-checking.  A very
strict language such as Pascal would also prevent you performing arithmetic with
Booleans, and would require that the expression in an <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> statement
always evaluate to a Boolean result.  Python is not this strict and never will
be, as <span class="target" id="index-13"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0285"><strong>PEP 285</strong></a> explicitly says.  This means you can still use any expression
in an <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> statement, even ones that evaluate to a list or tuple or
some random object.  The Boolean type is a subclass of the <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> class so
that arithmetic using a Boolean still works.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kc">True</span> <span class="o">+</span> <span class="mi">1</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kc">False</span> <span class="o">+</span> <span class="mi">1</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kc">False</span> <span class="o">*</span> <span class="mi">75</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kc">True</span> <span class="o">*</span> <span class="mi">75</span>
<span class="go">75</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> と <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> はぶっちゃけて言えば…: これらは整数値 1 と 0 の別名だけれども唯一異なるのは <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> と <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> が <code class="docutils literal notranslate"><span class="pre">'1'</span></code> と <code class="docutils literal notranslate"><span class="pre">'0'</span></code> ではなく <code class="docutils literal notranslate"><span class="pre">'True'</span></code> と <code class="docutils literal notranslate"><span class="pre">'False'</span></code> を返すことだけである。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-66"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0285"><strong>PEP 285</strong></a> - 真偽値型の追加</dt>
<dd>Guido van Rossum 著、実装</dd>
</dl>
</div>
</div>
<div class="section" id="pep-293-codec-error-handling-callbacks">
<h2>PEP 293: コーデックエラーを処理するコールバック<a class="headerlink" href="#pep-293-codec-error-handling-callbacks" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Unicode 文字列をバイト文字列にエンコードする際には、エンコード出来ない文字に出会うことがあります。いまのところ Python は、そのエラー処理として &quot;strict&quot; (<a class="reference internal" href="../library/exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a> を発生させる)、  &quot;ignore&quot; (その文字をスキップする)、 &quot;replace&quot; (出力文字列ではクエッションマークに置換する)、のいずれか一つを指定出来て、 &quot;strict&quot; がデフォルトの振る舞いになっています。その種のエラーのために、ほかの代わりとなる処理が望ましいかもしれません。例えば XML や HTML の実体参照に置き換えるなどの。</p>
<p>Python は今や、異なる処理戦略を追加する柔軟なフレームワークを手にしました。新しいエラーハンドラを <a class="reference internal" href="../library/codecs.html#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">codecs.register_error()</span></code></a> で追加出来、コーデックは <a class="reference internal" href="../library/codecs.html#codecs.lookup_error" title="codecs.lookup_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">codecs.lookup_error()</span></code></a> を使ってそのエラーハンドラにアクセス出来ます。等価な C API も C で書かれたコーデックのために追加されています。エラーハンドラは、変換すべき文字列、そのエラーが検出されたその文字列内での位置、ターゲットエンコーディングのような必要な状態情報を受け取ります。ハンドラは例外を投げるか、置換文字列を返せます。</p>
<p>このフレームワークを使って 2 つのエラーハンドラが実装されました: &quot;backslashreplace&quot; はエンコード出来ない文字をバックスラッシュで引用し、 &quot;xmlcharrefreplace&quot; は XML 文字参照を発行します。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-67"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0293"><strong>PEP 293</strong></a> - コーデックエラーを処理するコールバック</dt>
<dd>Walter Dörwald 著、実装</dd>
</dl>
</div>
</div>
<div class="section" id="pep-301-package-index-and-metadata-for-distutils">
<span id="section-pep301"></span><h2>PEP 301: パッケージインデクスと、 Distutils のためのメタデータ<a class="headerlink" href="#pep-301-package-index-and-metadata-for-distutils" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>長い間要望されてきた Python カタログのサポートが 2.3 で初登場です。</p>
<p>カタログの心臓部は Distutils の新コマンド <strong class="command">register</strong> です。 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">register</span></code> を実行すると、名前、バージョン、メンテナ、説明、ライセンスのようなパッケージ記述のメタデータを収集して、中央カタログサーバに送信します。結果のカタログは <a class="reference external" href="https://pypi.org">https://pypi.org</a> で利用可能です。</p>
<p>カタログ作成をもう少し便利にするために、Distutils の <code class="xref py py-func docutils literal notranslate"><span class="pre">setup()</span></code> 関数に新たにオプショナルな <em>classifiers</em> キーワード引数が追加されています。 <a class="reference external" href="http://catb.org/~esr/trove/">Trove</a> スタイルの文字列のリストは、ソフトウェアの分類を助けるために与えることが出来ます。</p>
<p>以下は <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> に分類指定子 (classifier) を記述する例です。 Distutils の古いバージョンと互換になるように書いています。:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">distutils</span> <span class="kn">import</span> <span class="n">core</span>
<span class="n">kw</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s2">&quot;Quixote&quot;</span><span class="p">,</span>
      <span class="s1">&#39;version&#39;</span><span class="p">:</span> <span class="s2">&quot;0.5.1&quot;</span><span class="p">,</span>
      <span class="s1">&#39;description&#39;</span><span class="p">:</span> <span class="s2">&quot;A highly Pythonic Web application framework&quot;</span><span class="p">,</span>
      <span class="c1"># ...</span>
      <span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">core</span><span class="p">,</span> <span class="s1">&#39;setup_keywords&#39;</span><span class="p">)</span> <span class="ow">and</span>
    <span class="s1">&#39;classifiers&#39;</span> <span class="ow">in</span> <span class="n">core</span><span class="o">.</span><span class="n">setup_keywords</span><span class="p">):</span>
    <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;classifiers&#39;</span><span class="p">]</span> <span class="o">=</span> \
        <span class="p">[</span><span class="s1">&#39;Topic :: Internet :: WWW/HTTP :: Dynamic Content&#39;</span><span class="p">,</span>
         <span class="s1">&#39;Environment :: No Input/Output (Daemon)&#39;</span><span class="p">,</span>
         <span class="s1">&#39;Intended Audience :: Developers&#39;</span><span class="p">],</span>

<span class="n">core</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
</pre></div>
</div>
<p>classifier の完全なリストは <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">register</span> <span class="pre">--list-classifiers</span></code> と実行することで得ることが出来ます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-16"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0301"><strong>PEP 301</strong></a> - Package Index and Metadata for Distutils</dt>
<dd>Richard Jones 著、実装</dd>
</dl>
</div>
</div>
<div class="section" id="pep-302-new-import-hooks">
<span id="section-pep302"></span><h2>PEP 302: 新たなインポートフック<a class="headerlink" href="#pep-302-new-import-hooks" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>カスタムなインポートフックを書くことは、Python 1.3 で <code class="xref py py-mod docutils literal notranslate"><span class="pre">ihooks</span></code> モジュールが導入されたその日からずっと可能でした。それでも本当のところそれで幸せになった人は誰一人いません。それで新しいインポートフックを書くのが難しくてとっ散らかっていたからです。 <code class="xref py py-mod docutils literal notranslate"><span class="pre">imputil</span></code> と <code class="xref py py-mod docutils literal notranslate"><span class="pre">iu</span></code> モジュール のような代わりとなる色々な提案がありましたが、そのいずれも多くの賛同を得ることが出来たものはありませんし、そのいずれもが簡単に C コードから使うことが出来ませんでした。</p>
<p><span class="target" id="index-68"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> はその先駆者、特に Gordon McMillan の <code class="xref py py-mod docutils literal notranslate"><span class="pre">iu</span></code> モジュールからアイディアを借りています。3 つの新たなアイテムが <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> モジュールに追加されています:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">sys.path_hooks</span></code> は呼び出し可能オブジェクトのリストです。ほとんどの場合クラスになるでしょう。それぞれの呼び出し可能オブジェクトは、パスを含む文字列を受け取って、このパスからインポートを処理するインポーターオブジェクトを返すか、このパスを処理出来なければ <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> を送出します。</li>
<li><code class="docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code> はそれぞれのパスごとのインポーターオブジェクトをキャッシュしますので、 <code class="docutils literal notranslate"><span class="pre">sys.path_hooks</span></code> は個々のパスを一回だけ横断すれば良いことになります。</li>
<li><code class="docutils literal notranslate"><span class="pre">sys.meta_path</span></code> は <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> がチェックされる前に横断させるインポーターオブジェクトのリストです(訳注: ここだけ読むとわかりにくいですがライブラリリファレンスを読めばわかります)。このリストは初期状態で空ですが、ユーザコードがオブジェクトをそれに追加出来ます。追加のビルトインと凍結モジュールを、このリストにオブジェクトを追加することによってインポートさせることが出来ます。</li>
</ul>
<p>インポーターオブジェクトは一つのメソッド <code class="docutils literal notranslate"><span class="pre">find_module(fullname,</span> <span class="pre">path=None)</span></code> を持たなければなりません。 <em>fullname</em> はモジュールかパッケージの名前です。例えば <code class="docutils literal notranslate"><span class="pre">string</span></code> や <code class="docutils literal notranslate"><span class="pre">distutils.core</span></code> です。 <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code> メソッドは一つのメソッド <code class="docutils literal notranslate"><span class="pre">load_module(fullname)</span></code> を持つローダーオブジェクトを返さなければなりません。 <code class="docutils literal notranslate"><span class="pre">load_module(fullname)</span></code> では対応するモジュールオブジェクトを生成して返します。</p>
<p>Python の新しいインポートのロジックは、なので、擬似コードで示すとだいたいこんな感じです (少し単純化しています; 完全な詳細は <span class="target" id="index-69"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> 参照):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">mp</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="p">:</span>
    <span class="n">loader</span> <span class="o">=</span> <span class="n">mp</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">loader</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>

<span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">hook</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">path_hooks</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">importer</span> <span class="o">=</span> <span class="n">hook</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="c1"># ImportError, so try the other path hooks</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loader</span> <span class="o">=</span> <span class="n">importer</span><span class="o">.</span><span class="n">find_module</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
            <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>

<span class="c1"># Not found!</span>
<span class="k">raise</span> <span class="ne">ImportError</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-70"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> - 新たなインポートフック</dt>
<dd>Just van Rossum、Paul Moore 著、実装 Just van Rossum。</dd>
</dl>
</div>
</div>
<div class="section" id="pep-305-comma-separated-files">
<span id="section-pep305"></span><h2>PEP 305: カンマ区切り形式ファイル<a class="headerlink" href="#pep-305-comma-separated-files" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>カンマ区切りファイルは、データベースやスプレッドシートからのエキスポートのために頻繁に使われるフォーマットです。Python 2.3 はカンマ区切りファイルのパーサを追加しました。</p>
<p>カンマ区切りフォーマットは、ぱっと見で、簡単そうに見えます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Costs</span><span class="p">,</span><span class="mi">150</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mf">3.95</span>
</pre></div>
</div>
<p>行を読んで <code class="docutils literal notranslate"><span class="pre">line.split(',')</span></code>: これほどに簡単なものはあるだろうか、って? ですが、文字列データ内にカンマを含んだりすると、コトは複雑になります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;Costs&quot;</span><span class="p">,</span><span class="mi">150</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mf">3.95</span><span class="p">,</span><span class="s2">&quot;Includes taxes, shipping, and sundry items&quot;</span>
</pre></div>
</div>
<p>デカくて醜い正規表現でこれをパース出来るでしょうが、新登場の <a class="reference internal" href="../library/csv.html#module-csv" title="csv: Write and read tabular data to and from delimited files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">csv</span></code></a> を使えば遥かに単純になります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">csv</span>

<span class="nb">input</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;datafile&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
<span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>
    <span class="nb">print</span> <span class="n">line</span>
</pre></div>
</div>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">reader()</span></code> 関数はたくさんのオプションを取ります。フィールドセパレータはカンマだけに制限されておらず任意の文字に変更出来、引用も変更できます。</p>
<p>カンマ区切りファイルの異なった方言を定義して登録出来ます。今のところ 2 つの方言があって、両者とも Microsoft Excel で使われるものです。独立している <a class="reference internal" href="../library/csv.html#csv.writer" title="csv.writer"><code class="xref py py-class docutils literal notranslate"><span class="pre">csv.writer</span></code></a> はタプルやリストの連続から、デリミタを含む文字列は引用符で囲みつつカンマ区切りファイルを生成します。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-20"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0305"><strong>PEP 305</strong></a> - CSV File API</dt>
<dd>PEP 著と実装: Kevin Altis, Dave Cole, Andrew McNamara, Skip Montanaro, Cliff Wells.</dd>
</dl>
</div>
</div>
<div class="section" id="pep-307-pickle-enhancements">
<span id="section-pep307"></span><h2>PEP 307: Pickle の機能拡張<a class="headerlink" href="#pep-307-pickle-enhancements" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">cPickle</span></code> モジュールで、2.3 の開発サイクル中にいくつか留意すべきことがありました。2.2 では新スタイルクラスを特に困難なく pickle 化出来たものの、あまりコンパクトには pickle 化は出来ませんでした。 <span class="target" id="index-71"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0307"><strong>PEP 307</strong></a> が些細な例を引用しています。新スタイルクラスは旧スタイルクラスに較べて 3 倍の長さになっていました。</p>
<p>解決方法として、新しい pickle プロトコルが発明されました。 <a class="reference internal" href="../library/pickle.html#pickle.dumps" title="pickle.dumps"><code class="xref py py-func docutils literal notranslate"><span class="pre">pickle.dumps()</span></code></a> 関数はずっと長い間、テキストとするのかバイナリとするのかについてはサポートしていました。2.3 ではこのフラグは Boolean から整数に再定義されました: 0 は旧式のテキストモード pickle フォーマット、1 が同じく旧式のバイナリフォーマット、そして 2 が今回の 2.3 から特有のフォーマットです。新しく追加された定数 <a class="reference internal" href="../library/pickle.html#pickle.HIGHEST_PROTOCOL" title="pickle.HIGHEST_PROTOCOL"><code class="xref py py-const docutils literal notranslate"><span class="pre">pickle.HIGHEST_PROTOCOL</span></code></a> を指定すると、最も望ましいものが選択されます。</p>
<p>unpickle は安全な操作についての考慮はしなくなりました。2.2 の <a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> は unpickle される安全でないクラス (特に <code class="xref py py-attr docutils literal notranslate"><span class="pre">__safe_for_unpickling__</span></code> 属性) を避けようとするフックを提供していましたが、このコードは一度も監査されることがなく、2.3 で全て白紙にしました。Python のどのバージョンでも、信頼出来ないデータを unpickle すべきではありません。</p>
<p>新スタイルクラスでの pickle のオーバーヘッドを減らすために、pickle をカスタマイズする、3 つの特殊メソッドを使った新インターフェイスが追加されました: <a class="reference internal" href="../library/pickle.html#object.__getstate__" title="object.__getstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getstate__()</span></code></a>, <a class="reference internal" href="../library/pickle.html#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a>, <a class="reference internal" href="../library/pickle.html#object.__getnewargs__" title="object.__getnewargs__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs__()</span></code></a> 。これらメソッドの完全なセマンティクスについては <span class="target" id="index-72"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0307"><strong>PEP 307</strong></a> を調べてください。</p>
<p>pickle をもっとさらに圧縮する方法として、pickle されるクラスの身元特定のために長い文字列を使う代わりに整数コードを使えるようになっています。Python Software Foundation は標準コードのリストを保守しています; プライベート使用のためのコード範囲もあります。現在のところ指定されているコードはありません。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-73"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0307"><strong>PEP 307</strong></a> - pickle プロトコルの拡張</dt>
<dd>著、実装: Guido van Rossum と Tim Peters</dd>
</dl>
</div>
</div>
<div class="section" id="extended-slices">
<span id="section-slices"></span><h2>拡張スライス<a class="headerlink" href="#extended-slices" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 1.4 以来ずっと、スライシングの構文は省略可能な 3 つ目の引数 &quot;step&quot; またの名を &quot;stride&quot; 、をサポートしていたのです。例えばこれらは全て合法な Python 構文です: <code class="docutils literal notranslate"><span class="pre">L[1:10:2]</span></code>, <code class="docutils literal notranslate"><span class="pre">L[:-1:1]</span></code>, <code class="docutils literal notranslate"><span class="pre">L[::-1]</span></code> 。これはこの 3 つ目の引数を大々的に使う Numerical Python 開発者によって要望されたことで Python に追加されたものですが、Python ビルトインのリスト、タプル、文字列といったシーケンス型がこの機能をサポートすることはなく、これを試みると <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> を起こしていました。Michael Hudson がこの不徹底を修正するパッチを寄稿しました。</p>
<p>例えば、今やリストの偶数番目要素を簡単に取り出せます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[0, 2, 4, 6, 8]</span>
</pre></div>
</div>
<p>負の値では、同じリストの逆順コピーを作るように動作します:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span>
</pre></div>
</div>
<p>これはタプル、配列、文字列に対しても使えます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">=</span><span class="s1">&#39;abcd&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="go">&#39;ac&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">&#39;dcba&#39;</span>
</pre></div>
</div>
<p>リストや配列のような <a class="reference internal" href="../glossary.html#term-mutable"><span class="xref std std-term">mutable</span></a> なシーケンスに対して、拡張スライスを代入や削除に使えますが、拡張スライスと普通のスライスではいくつかの違いがあります。普通のスライスで代入を行えば、シーケンスの長さを変更出来ます (---訳注: 念のため。Python 3 の range は list を直接返す関数ではなくジェネレータなので、以下例は <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">list(range(3))</span></code> などとしないと動作しません。続く例でも同じです。---):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[0, 1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[0, 4, 5, 6]</span>
</pre></div>
</div>
<p>拡張スライスにはこの柔軟性はありません。拡張スライスを代入に使う際は、ステートメントの右辺のリストは、置換されるスライスとしての要素数と同数でなければなりません:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[0, 1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[0, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[0, 1, -1, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
<span class="gr">ValueError</span>: <span class="n">attempt to assign sequence of size 3 to extended slice of size 2</span>
</pre></div>
</div>
<p>削除はもっと素直です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[0, 1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[0, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[1, 3]</span>
</pre></div>
</div>
<p>ビルトインのシーケンスの <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> メソッドに slice オブジェクトを渡すことも出来るようになりました:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">[0, 2, 4]</span>
</pre></div>
</div>
<p>あるいは直接 slice オブジェクトを添え字に使えます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="go">[0, 2, 4]</span>
</pre></div>
</div>
<p>拡張スライスをサポートするシーケンスの実装を単純化するために、 slice オブジェクトに <code class="xref py py-meth docutils literal notranslate"><span class="pre">indices(length)()</span></code> メソッドが追加されています。これはシーケンスの長さを受け取って、タプル <code class="docutils literal notranslate"><span class="pre">(start,</span> <span class="pre">stop,</span> <span class="pre">step)</span></code> を返すことで直接 <a class="reference internal" href="../library/stdtypes.html#range" title="range"><code class="xref py py-func docutils literal notranslate"><span class="pre">range()</span></code></a> に渡せるようにしています。 <code class="xref py py-meth docutils literal notranslate"><span class="pre">indices()</span></code> は範囲外のインデクスを、標準のスライスと一貫した方法で処理します (そしてこの当たり障りのない言い回しは、ややこしい詳細の荒波を隠しているのですよ…!) このメソッドはこうやって使うのを意図したものです:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FakeSeq</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">calc_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">FakeSeq</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_item</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">indices</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_item</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>ところでこの例からは、ビルトインの <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> オブジェクトが今では slice 型という型オブジェクトで、もう関数ではないことがわかるでしょう。これは、Python 2.2 で <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> などに対して行われた同じ目的の修正と一貫しています。</p>
</div>
<div class="section" id="other-language-changes">
<h2>その他の言語変更<a class="headerlink" href="#other-language-changes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下が、Python 2.3 言語コアに加えられた全ての変更点です。</p>
<ul>
<li><p class="first"><a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> がこのドキュメントの <a class="reference internal" href="#section-generators"><span class="std std-ref">PEP 255: 単純なジェネレータ</span></a> で述べた通り、キーワードになっています。</p>
</li>
<li><p class="first">新たなビルトイン関数 <a class="reference internal" href="../library/functions.html#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a> が追加されました。このドキュメントの <a class="reference internal" href="#section-enumerate"><span class="std std-ref">PEP 279: enumerate()</span></a> で述べた通りです。</p>
</li>
<li><p class="first">新たな定数 <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>,  <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> がビルトイン <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> 型の追加に伴い追加されました。このドキュメントの <a class="reference internal" href="#section-bool"><span class="std std-ref">PEP 285: Boolean 型</span></a> で述べた通りです。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> 型コンストラクタは、文字列や浮動小数点数を整数に収める際、それがとても大き場合に  <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a> を投げるのではなく長整数を返すようになっています。これは <code class="docutils literal notranslate"><span class="pre">isinstance(int(expression),</span> <span class="pre">int)</span></code> が偽を返すかもしれないという逆説的な結果をもたらし得ますが、これが実際に問題を起こすとはあまり思えません。</p>
</li>
<li><p class="first">ビルトイン型が拡張スライス構文をサポートするようになりました。このドキュメントの <a class="reference internal" href="#section-slices"><span class="std std-ref">拡張スライス</span></a> で述べた通りです。</p>
</li>
<li><p class="first">新規ビルトイン関数 <code class="docutils literal notranslate"><span class="pre">sum(iterable,</span> <span class="pre">start=0)</span></code> はイテラブル内の数値アイテムを足し込んで総和を返します。 <a class="reference internal" href="../library/functions.html#sum" title="sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a> は数値しか受け付けませんので、文字列群を連結するのには使えません。 (Contributed by Alex Martelli.)</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">list.insert(pos,</span> <span class="pre">value)</span></code> で <em>value</em> を先頭に追加するのに <em>pos</em> に負数が使われてきました。この振る舞いはスライスのインデクシングとの一貫性のために変更されました。つまり <em>pos</em> が -1 の場合は最終要素の前への追加、などとなります。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">list.index(value)</span></code> はリスト内から <em>value</em> を探してそのインデクスを返しますが、オプショナルな <em>start</em> と <em>stop</em> 引数を取って、リストの部分列からの検索が可能になりました。</p>
</li>
<li><p class="first">辞書の新たなメソッド <code class="docutils literal notranslate"><span class="pre">pop(key[,</span> <span class="pre">*default*])</span></code> は、 <em>key</em> に対応する値を返して辞書からそのキー/値ペアを取り除きます。辞書内にそのキーが不在であれば、 <em>default</em> が指定されていればそれを、そうでなければ <a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> を投げます。:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">{1: 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;stdin&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
<span class="gr">KeyError</span>: <span class="n">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;stdin&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
<span class="gr">KeyError</span>: <span class="n">&#39;pop(): dictionary is empty&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">{}</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>また、新しいメソッド <code class="docutils literal notranslate"><span class="pre">dict.fromkeys(iterable,</span> <span class="pre">value)</span></code> は、与えられたイテレータ <em>iterable</em> からキーを取り出しつつ全ての値を <em>value</em> にセットすることで構築します。 <em>value</em> のデフォルトは <code class="docutils literal notranslate"><span class="pre">None</span></code> です。</p>
<p>(Patches contributed by Raymond Hettinger.)</p>
<p>また、 <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">dict()</span></code></a> コンストラクタは小さな辞書を簡単に構築出来るよう、キーワード引数を受け付けるようになりました:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">(</span><span class="n">red</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">blue</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">green</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">black</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">{&#39;blue&#39;: 2, &#39;black&#39;: 4, &#39;green&#39;: 3, &#39;red&#39;: 1}</span>
</pre></div>
</div>
<p>(Contributed by Just van Rossum.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../reference/simple_stmts.html#assert"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code></a> ステートメントが <code class="docutils literal notranslate"><span class="pre">__debug__</span></code> フラグをチェックすることはもうありません。このため、 <code class="docutils literal notranslate"><span class="pre">__debug__</span></code> に代入することによってアサーションを無効にすることは出来ません。Python を <a class="reference internal" href="../using/cmdline.html#cmdoption-o"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a> スイッチで起動により全てのアサーションが実行されない点は、以前と変わりません。</p>
</li>
<li><p class="first">ほとんどの型オブジェクトが今では呼び出し可能であり、なので関数、クラス、モジュールのようなオブジェクトを新たに構築するのにそれを使えます。 (<code class="xref py py-mod docutils literal notranslate"><span class="pre">new</span></code> モジュールはこれにより将来のバージョンの Python で撤廃される可能性があります。 <a class="reference internal" href="../library/types.html#module-types" title="types: Names for built-in types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">types</span></code></a> モジュール内の型オブジェクトが使えるからです。 ---訳注: 2.6 で実際に撤廃されています。---) 例えば新規モジュールオブジェクトは以下コードで構築出来ます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">types</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span><span class="s1">&#39;docstring&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">&lt;module &#39;abc&#39; (built-in)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="go">&#39;docstring&#39;</span>
</pre></div>
</div>
</li>
<li><p class="first">A new warning, <a class="reference internal" href="../library/exceptions.html#PendingDeprecationWarning" title="PendingDeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PendingDeprecationWarning</span></code></a> was added to indicate features
which are in the process of being deprecated.  The warning will <em>not</em> be printed
by default.  To check for use of features that will be deprecated in the future,
supply <a class="reference internal" href="../using/cmdline.html#cmdoption-w"><code class="xref std std-option docutils literal notranslate"><span class="pre">-Walways::PendingDeprecationWarning::</span></code></a> on the command line or
use <a class="reference internal" href="../library/warnings.html#warnings.filterwarnings" title="warnings.filterwarnings"><code class="xref py py-func docutils literal notranslate"><span class="pre">warnings.filterwarnings()</span></code></a>.</p>
</li>
<li><p class="first">文字列ベースの例外、例えば <code class="docutils literal notranslate"><span class="pre">raise</span> <span class="pre">&quot;Error</span> <span class="pre">occurred&quot;</span></code> のようなもの、これは廃止のための過程を開始しています。文字列を例外として投げると <a class="reference internal" href="../library/exceptions.html#PendingDeprecationWarning" title="PendingDeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PendingDeprecationWarning</span></code></a> が発行されます。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">None</span></code> を変数名に使うと <a class="reference internal" href="../library/exceptions.html#SyntaxWarning" title="SyntaxWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxWarning</span></code></a> 警告を出すようになっています。将来バージョンの Python では <code class="docutils literal notranslate"><span class="pre">None</span></code> はキーワードになります。</p>
</li>
<li><p class="first">ファイルオブジェクト自身が自身のイテレータのように振舞うようになったために、Python 2.1 で導入されたファイルオブジェクトの <code class="xref py py-meth docutils literal notranslate"><span class="pre">xreadlines()</span></code> メソッドはもう必要ありません。 <code class="xref py py-meth docutils literal notranslate"><span class="pre">xreadlines()</span></code> メソッドは元々はファイル内の全行をループするのに高速な手段として導入されましたが、今では単純に <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">line</span> <span class="pre">in</span> <span class="pre">file_obj</span></code> と書くことが出来ます。ファイルオブジェクトにはさらに読み出し専用の <code class="xref py py-attr docutils literal notranslate"><span class="pre">encoding</span></code> 属性を持つようになっていて、これはファイルで使われているエンコーディングを与えます。ファイルへの Unicode 文字列書き込みでは、与えられたエンコーディングを使って自動的にバイト列に変換されます。(---訳注: <code class="xref py py-attr docutils literal notranslate"><span class="pre">encoding</span></code> は読み出し専用なので「与える」といっても直接セットすることは出来ません。ビルトインの <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> と <code class="xref py py-class docutils literal notranslate"><span class="pre">file</span></code> にはエンコーディングを指定するインターフェイスがありません。一般にはこれは何かほかの関数などで間接的にセットすることになりますが、2.6 以降であれば <a class="reference internal" href="../library/io.html#io.open" title="io.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 、そうでないなら <code class="xref py py-mod docutils literal notranslate"><span class="pre">codec</span></code> モジュールなどを介して制御することになると思います。Python 3 以降を含む 2.6 以降は <a class="reference internal" href="../library/io.html#io.open" title="io.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> が良いです。---)</p>
</li>
<li><p class="first">The method resolution order used by new-style classes has changed, though
you'll only notice the difference if you have a really complicated inheritance
hierarchy.  Classic classes are unaffected by this change.  Python 2.2
originally used a topological sort of a class's ancestors, but 2.3 now uses the
C3 algorithm as described in the paper <a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.3910">&quot;A Monotonic Superclass Linearization
for Dylan&quot;</a>. To
understand the motivation for this change,  read Michele Simionato's article
<a class="reference external" href="http://www.phyast.pitt.edu/~micheles/mro.html">&quot;Python 2.3 Method Resolution Order&quot;</a>, or
read the thread on python-dev starting with the message at
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2002-October/029035.html">https://mail.python.org/pipermail/python-dev/2002-October/029035.html</a>. Samuele
Pedroni first pointed out the problem and also implemented the fix by coding the
C3 algorithm.</p>
</li>
<li><p class="first">Python はマルチスレッドプログラムを、バイトコード N 個実行のたびに実行スレッドを切り替えて実行します。このデフォルトの N が 10 から 100 に増やされました。これはシングルスレッドアプリケーションにおいてこの切り替えのオーバヘッドを減らして高速化するためです。マルチスレッドアプリケーションでは応答時間が遅くなる被害を被るかもしれませんが、このリミット値を元の小さな値に戻すのは簡単で、 <code class="docutils literal notranslate"><span class="pre">sys.setcheckinterval(N)</span></code> を使います。設定されているリミット値は新規関数 <a class="reference internal" href="../library/sys.html#sys.getcheckinterval" title="sys.getcheckinterval"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getcheckinterval()</span></code></a> で取得できます。</p>
</li>
<li><p class="first">マイナーですが広範囲に渡る変更として、拡張型の名前の変更があります。Python と一緒に含まれるモジュールで定義される拡張型の名前が、モジュール名と <code class="docutils literal notranslate"><span class="pre">'.'</span></code> が型名に前置されるようになりました。例えば Python 2.2 ではソケットオブジェクトを作って <code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code> を出力すると、このような出力だったでしょう:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;type &#39;socket&#39;&gt;</span>
</pre></div>
</div>
<p>2.3 ではこうなります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;type &#39;_socket.socket&#39;&gt;</span>
</pre></div>
</div>
</li>
<li><p class="first">One of the noted incompatibilities between old- and new-style classes has been
removed: you can now assign to the <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> and <a class="reference internal" href="../library/stdtypes.html#class.__bases__" title="class.__bases__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__bases__</span></code></a>
attributes of new-style classes.  There are some restrictions on what can be
assigned to <a class="reference internal" href="../library/stdtypes.html#class.__bases__" title="class.__bases__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__bases__</span></code></a> along the lines of those relating to assigning to
an instance's <a class="reference internal" href="../library/stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> attribute.</p>
</li>
</ul>
<div class="section" id="string-changes">
<h3>文字列に関する変更<a class="headerlink" href="#string-changes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<ul>
<li><p class="first"><a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> 演算子が文字列に対して違った振る舞いをするようになりました。以前は <em>X</em> と <em>Y</em> が文字列の場合の <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">in</span> <span class="pre">Y</span></code> は、 <em>X</em> は単一文字でなければなりませんでした。これが <em>X</em> はどんな長さでも良くなり、 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">in</span> <span class="pre">Y</span></code> は <em>X</em> が <em>Y</em> のサブストリングであれば <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> を返すように変更されました。 <em>X</em> が空文字列の場合は結果は常に <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> になります。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;ab&#39;</span> <span class="ow">in</span> <span class="s1">&#39;abcd&#39;</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;ad&#39;</span> <span class="ow">in</span> <span class="s1">&#39;abcd&#39;</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&#39;</span> <span class="ow">in</span> <span class="s1">&#39;abcd&#39;</span>
<span class="go">True</span>
</pre></div>
</div>
<p>これはサブストリングの開始位置を教えてくれるわけではないので、その情報が必要であれば <code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code>  メソッドを使ってください。</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal notranslate"><span class="pre">strip()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">lstrip()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">rstrip()</span></code> に、剥ぎ取る文字を指定する省略可能引数が追加されています。デフォルトは従来通り全ての空白文字を削除します。:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   abc &#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="go">&#39;abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&gt;&lt;&gt;&lt;abc&lt;&gt;&lt;&gt;&lt;&gt;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">)</span>
<span class="go">&#39;abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&gt;&lt;&gt;&lt;abc&lt;&gt;&lt;&gt;&lt;&gt;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">)</span>
<span class="go">&#39;abc&lt;&gt;&lt;&gt;&lt;&gt;\n&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u4000\u4001</span><span class="s1">abc</span><span class="se">\u4000</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u4000</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">u&#39;\u4001abc&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>(Suggested by Simon Brunning and implemented by Walter Dörwald.)</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal notranslate"><span class="pre">startswith()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">endswith()</span></code> メソッドが <em>start</em> と <em>end</em> パラメータとして負数を受け付けるようになりました。</p>
</li>
<li><p class="first">もう一つ追加の文字列メソッドは <code class="xref py py-meth docutils literal notranslate"><span class="pre">zfill()</span></code> で、これは <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a> モジュール内で元々関数だったものです。 <code class="xref py py-meth docutils literal notranslate"><span class="pre">zfill()</span></code> は指定の幅まで数値文字列の左側にゼロ埋めをします。なお、 <code class="docutils literal notranslate"><span class="pre">%</span></code> 演算子の方が今でも <code class="xref py py-meth docutils literal notranslate"><span class="pre">zfill()</span></code> より柔軟で強力です。:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;45&#39;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">&#39;0045&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;12345&#39;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">&#39;12345&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;goofy&#39;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">&#39;0goofy&#39;</span>
</pre></div>
</div>
<p>(Contributed by Walter Dörwald.)</p>
</li>
<li><p class="first">新規の型オブジェクト <code class="xref py py-class docutils literal notranslate"><span class="pre">basestring</span></code> が追加されました。 8 ビット文字列と Unicode 文字列はともにこの型から派生しているので、 <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">basestring)</span></code> はどちらの文字列型でも <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> を返します。これは完全に抽象型なので <code class="xref py py-class docutils literal notranslate"><span class="pre">basestring</span></code> のインスタンスを構築することは出来ません。 (---訳注: Python 3 では文字列 = Unicode、バイト列の扱いが大きく変わり、まずバイト列と Unicode は決して同じものとはみなされません (今ここで 8 ビット文字列と呼んでいるものは Python 3 では文字列ではありません、バイト列です) し、 <code class="xref py py-class docutils literal notranslate"><span class="pre">basestring</span></code> 型も撤廃されています。Python 2.7 で Python 3 をサポートする必要があるような場合は、なるべく <code class="xref py py-class docutils literal notranslate"><span class="pre">basestring</span></code> に依存しないようにした方が良いです。---)</p>
</li>
<li><p class="first">内部化した文字列はもう不死身ではないので、内部辞書からの参照が、参照している唯一のものとなれば、普通にガーベージコレクト対象となります。 (Implemented by Oren Tirosh.)</p>
</li>
</ul>
</div>
<div class="section" id="optimizations">
<h3>最適化<a class="headerlink" href="#optimizations" title="このヘッドラインへのパーマリンク">¶</a></h3>
<ul class="simple">
<li>The creation of new-style class instances has been made much faster; they're
now faster than classic classes!</li>
<li>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code> method of list objects has been extensively rewritten by Tim
Peters, and the implementation is significantly faster.</li>
<li>Multiplication of large long integers is now much faster thanks to an
implementation of Karatsuba multiplication, an algorithm that scales better than
the O(n*n) required for the grade-school multiplication algorithm.  (Original
patch by Christopher A. Craig, and significantly reworked by Tim Peters.)</li>
<li>The <code class="docutils literal notranslate"><span class="pre">SET_LINENO</span></code> opcode is now gone.  This may provide a small speed
increase, depending on your compiler's idiosyncrasies. See section
<a class="reference internal" href="#section-other"><span class="std std-ref">その他の変更と修正</span></a> for a longer explanation. (Removed by Michael Hudson.)</li>
<li><code class="xref py py-func docutils literal notranslate"><span class="pre">xrange()</span></code> objects now have their own iterator, making <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span>
<span class="pre">xrange(n)</span></code> slightly faster than <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">range(n)</span></code>.  (Patch by Raymond
Hettinger.)</li>
<li>A number of small rearrangements have been made in various hotspots to improve
performance, such as inlining a function or removing some code.  (Implemented
mostly by GvR, but lots of people have contributed single changes.)</li>
</ul>
<p>The net result of the 2.3 optimizations is that Python 2.3 runs the  pystone
benchmark around 25% faster than Python 2.2.</p>
</div>
</div>
<div class="section" id="new-improved-and-deprecated-modules">
<h2>新たなモジュール、改良されたモジュール、非推奨のモジュール<a class="headerlink" href="#new-improved-and-deprecated-modules" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>いつものように、Python の標準ライブラリには数多くの拡張とバグ修正がありました。ここでは最も注目に値する変更について、モジュールの辞書順に列挙します。変更の完全なリストについてはソースツリーの <code class="file docutils literal notranslate"><span class="pre">Misc/NEWS</span></code> を調べるか、あるいは全ての詳細について CVS ログに目を通してみてください。</p>
<ul>
<li><p class="first"><a class="reference internal" href="../library/array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a> モジュールが <code class="docutils literal notranslate"><span class="pre">'u'</span></code> フォーマット文字を使った Unicode 文字の配列をサポートするようになっています。配列はまた、 <code class="docutils literal notranslate"><span class="pre">+=</span></code> 代入演算子を使ってほかの配列内容を加算すること、 <code class="docutils literal notranslate"><span class="pre">*=</span></code> 演算子を使って配列を繰り返すことが可能になっています。(Contributed by Jason Orendorff.)</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bsddb</span></code> が <a class="reference external" href="http://pybsddb.sourceforge.net">PyBSDDB</a> バージョン 4.1.6 によって置き換えられています。これは BerkeleyDB のトランザクションの機能へのより完全なインターフェイスを提供します。</p>
<p>古いバージョンのモジュールは <code class="xref py py-mod docutils literal notranslate"><span class="pre">bsddb185</span></code> にリネームされて、自動的にはビルドされません。有効にするには <code class="file docutils literal notranslate"><span class="pre">Modules/Setup</span></code> を編集する必要があります。新しい <code class="xref py py-mod docutils literal notranslate"><span class="pre">bsddb</span></code> パッケージは古いモジュールと互換となるように意図されていますので、何か非互換を見つけたらファイルのバグを確認してください。Python 2.3 へのアップグレードの際、前提となる BerkeleyDB ライブラリの新バージョンでインタプリタがコンパイルされるならば、ほぼ確実にあなたのデータベースは新バージョンに変換しなければならないでしょう。ソース配布物の <code class="file docutils literal notranslate"><span class="pre">Tools/scripts</span></code> ディレクトリの <code class="file docutils literal notranslate"><span class="pre">db2pickle.py</span></code> と <code class="file docutils literal notranslate"><span class="pre">pickle2db.py</span></code> スクリプトを使って、これをかなり簡単に行うことが出来ます。もし既に PyBSDDB パッケージを使っていて <code class="xref py py-mod docutils literal notranslate"><span class="pre">bsddb3</span></code> としてインポートしているならば、 <code class="xref py py-mod docutils literal notranslate"><span class="pre">bsddb</span></code> をインポートするように <code class="docutils literal notranslate"><span class="pre">import</span></code> 文を変更する必要があります。</p>
</li>
<li><p class="first">新規の <a class="reference internal" href="../library/bz2.html#module-bz2" title="bz2: Interfaces for bzip2 compression and decompression."><code class="xref py py-mod docutils literal notranslate"><span class="pre">bz2</span></code></a> モジュールは bz2 データ圧縮ライブラリへのインターフェイスです。bz2 圧縮データは普通 <a class="reference internal" href="../library/zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> 圧縮データよりも小さくなります。 (Contributed by Gustavo Niemeyer.)</p>
</li>
<li><p class="first">標準の日付時刻型が <a class="reference internal" href="../library/datetime.html#module-datetime" title="datetime: Basic date and time types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">datetime</span></code></a> モジュールとして追加されています。詳細はこのドキュメントの下の方に記述してありますのでそちらを参照して下さい。</p>
</li>
<li><p class="first">Distutils の <code class="xref py py-class docutils literal notranslate"><span class="pre">Extension</span></code> クラスに新たにコンストラクタ引数 <em>depends</em> が追加されました。これは拡張が依存する追加的なソースファイルを列挙します。Distutils はその依存ファイルのいずれかが更新されると再コンパイルを行います。例えば <code class="file docutils literal notranslate"><span class="pre">sampmodule.c</span></code> がヘッダファイル <code class="file docutils literal notranslate"><span class="pre">sample.h</span></code> をインクルードしているとして、 <code class="xref py py-class docutils literal notranslate"><span class="pre">Extension</span></code> オブジェクトをこのように構築します:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ext</span> <span class="o">=</span> <span class="n">Extension</span><span class="p">(</span><span class="s2">&quot;samp&quot;</span><span class="p">,</span>
                <span class="n">sources</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sampmodule.c&quot;</span><span class="p">],</span>
                <span class="n">depends</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sample.h&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p><code class="file docutils literal notranslate"><span class="pre">sample.h</span></code> を修正するとモジュールは再コンパイルされます。 (Contributed by Jeremy Hylton.)</p>
</li>
<li><p class="first">Distutils のほかのマイナーな変更: 環境変数 <span class="target" id="index-74"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">CC</span></code>, <span class="target" id="index-75"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">CFLAGS</span></code>, <span class="target" id="index-76"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">CPP</span></code>, <span class="target" id="index-77"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">LDFLAGS</span></code>, <span class="target" id="index-78"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">CPPFLAGS</span></code> をチェックして Python のコンフィグレーションでの設定をオーバライドするようになっています (contributed by Robert Weber)。</p>
</li>
<li><p class="first">以前までは <a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> モジュールは公開メソッドの docstring とテストケースの関数を検索するだけでしたが、今ではプライベートなものも調べます。 <code class="xref py py-func docutils literal notranslate"><span class="pre">DocTestSuite()</span></code> 関数は <a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> テスト群から <a class="reference internal" href="../library/unittest.html#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestSuite</span></code></a> オブジェクトを作ります。</p>
</li>
<li><p class="first">新しい関数 <code class="docutils literal notranslate"><span class="pre">gc.get_referents(object)</span></code> は <em>object</em> により参照されている全てのオブジェクトのリストを返します。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/getopt.html#module-getopt" title="getopt: Portable parser for command line options; support both short and long option names."><code class="xref py py-mod docutils literal notranslate"><span class="pre">getopt</span></code></a> モジュールに新規関数 <code class="xref py py-func docutils literal notranslate"><span class="pre">gnu_getopt()</span></code> が追加されました。これは既存の <a class="reference internal" href="../library/getopt.html#module-getopt" title="getopt: Portable parser for command line options; support both short and long option names."><code class="xref py py-func docutils literal notranslate"><span class="pre">getopt()</span></code></a> 関数と同じ引数を取りますが、GNU スタイルの走査モードを使います。既存の <a class="reference internal" href="../library/getopt.html#module-getopt" title="getopt: Portable parser for command line options; support both short and long option names."><code class="xref py py-func docutils literal notranslate"><span class="pre">getopt()</span></code></a> 関数は非オプション引数が現れるとすぐにオプション処理をやめますが、GNU スタイルモードは処理を続行するので、オプションと引数をミックス出来ます。例えば:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getopt</span><span class="o">.</span><span class="n">getopt</span><span class="p">([</span><span class="s1">&#39;-f&#39;</span><span class="p">,</span> <span class="s1">&#39;filename&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="s1">&#39;-v&#39;</span><span class="p">],</span> <span class="s1">&#39;f:v&#39;</span><span class="p">)</span>
<span class="go">([(&#39;-f&#39;, &#39;filename&#39;)], [&#39;output&#39;, &#39;-v&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getopt</span><span class="o">.</span><span class="n">gnu_getopt</span><span class="p">([</span><span class="s1">&#39;-f&#39;</span><span class="p">,</span> <span class="s1">&#39;filename&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="s1">&#39;-v&#39;</span><span class="p">],</span> <span class="s1">&#39;f:v&#39;</span><span class="p">)</span>
<span class="go">([(&#39;-f&#39;, &#39;filename&#39;), (&#39;-v&#39;, &#39;&#39;)], [&#39;output&#39;])</span>
</pre></div>
</div>
<p>(Contributed by Peter Åstrand.)</p>
</li>
<li><p class="first">モジュール <a class="reference internal" href="../library/grp.html#module-grp" title="grp: The group database (getgrnam() and friends). (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">grp</span></code></a>, <a class="reference internal" href="../library/pwd.html#module-pwd" title="pwd: The password database (getpwnam() and friends). (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pwd</span></code></a>, <a class="reference internal" href="../library/resource.html#module-resource" title="resource: An interface to provide resource usage information on the current process. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">resource</span></code></a> では拡張されたタプルを返すようになりました:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">grp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">grp</span><span class="o">.</span><span class="n">getgrnam</span><span class="p">(</span><span class="s1">&#39;amk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">gr_name</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">gr_gid</span>
<span class="go">(&#39;amk&#39;, 500)</span>
</pre></div>
</div>
</li>
<li><p class="first"><a class="reference internal" href="../library/gzip.html#module-gzip" title="gzip: Interfaces for gzip compression and decompression using file objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gzip</span></code></a> モジュールが 2 GiB を超えるファイルを扱えるようになっています。</p>
</li>
<li><p class="first">The new <a class="reference internal" href="../library/heapq.html#module-heapq" title="heapq: Heap queue algorithm (a.k.a. priority queue)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">heapq</span></code></a> module contains an implementation of a heap queue
algorithm.  A heap is an array-like data structure that keeps items in a
partially sorted order such that, for every index <em>k</em>, <code class="docutils literal notranslate"><span class="pre">heap[k]</span> <span class="pre">&lt;=</span>
<span class="pre">heap[2*k+1]</span></code> and <code class="docutils literal notranslate"><span class="pre">heap[k]</span> <span class="pre">&lt;=</span> <span class="pre">heap[2*k+2]</span></code>.  This makes it quick to remove the
smallest item, and inserting a new item while maintaining the heap property is
O(lg n).  (See <a class="reference external" href="https://xlinux.nist.gov/dads//HTML/priorityque.html">https://xlinux.nist.gov/dads//HTML/priorityque.html</a> for more
information about the priority queue data structure.)</p>
<p><a class="reference internal" href="../library/heapq.html#module-heapq" title="heapq: Heap queue algorithm (a.k.a. priority queue)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">heapq</span></code></a> モジュールには、 <code class="xref py py-func docutils literal notranslate"><span class="pre">heappush()</span></code> 関数と <code class="xref py py-func docutils literal notranslate"><span class="pre">heappop()</span></code> 関数が含まれており、これらはほかの <a class="reference internal" href="../glossary.html#term-mutable"><span class="xref std std-term">mutable</span></a> な Python シーケンス型の上にヒーププライオリティを保ちつつアイテムの追加と削除を行います。Python リストを使う例としてはこのような具合です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">heapq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heap</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
<span class="gp">... </span>   <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heap</span>
<span class="go">[1, 3, 5, 11, 7]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heap</span>
<span class="go">[5, 7, 11]</span>
</pre></div>
</div>
<p>(Contributed by Kevin O'Connor.)</p>
</li>
<li><p class="first">IDLE 統合開発環境は IDLEfork プロジェクト (<a class="reference external" href="http://idlefork.sourceforge.net">http://idlefork.sourceforge.net</a>) からのコードを用いるように更新されました。最も特筆すべき特徴は開発コードがサブプロセスで実行されるようになったことで、これにより手動で <code class="docutils literal notranslate"><span class="pre">reload()</span></code> 操作を行う必要はなくなっています。IDLE の中核コードは標準ライブラリの <code class="xref py py-mod docutils literal notranslate"><span class="pre">idlelib</span></code> パッケージとして組み込まれました。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/imaplib.html#module-imaplib" title="imaplib: IMAP4 protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">imaplib</span></code></a> モジュールが  IMAP over SSL をサポートするようになりました. (Contributed by Piers Lauder and Tino Lange.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal notranslate"><span class="pre">itertools</span></code></a> モジュールは ML 言語や Haskell 言語で提供されている様々な関数に触発された、イテレータとともに用いる有用な数多くの関数を含んでいます。例えば、 <code class="docutils literal notranslate"><span class="pre">itertools.ifilter(predicate,</span> <span class="pre">iterator)</span></code> はイテレータ内で関数 <code class="xref py py-func docutils literal notranslate"><span class="pre">predicate()</span></code> が <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> を返す要素全てを返し、 <code class="docutils literal notranslate"><span class="pre">itertools.repeat(obj,</span> <span class="pre">N)</span></code> は <code class="docutils literal notranslate"><span class="pre">obj</span></code> の <em>N</em> 回繰り返しを返します。ほかにもモジュールには数多くの関数を含んでいます。詳細はパッケージのドキュメントを参照してください。(Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> module の 2 つの新規関数 <code class="docutils literal notranslate"><span class="pre">degrees(rads)</span></code> と <code class="docutils literal notranslate"><span class="pre">radians(degs)</span></code> は、ラジアンと度の間の変換を行います。 <a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> モジュールの <a class="reference internal" href="../library/math.html#math.sin" title="math.sin"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.sin()</span></code></a> や <a class="reference internal" href="../library/math.html#math.cos" title="math.cos"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.cos()</span></code></a> などは常にラジアンでの入力が必要です。 <a class="reference internal" href="../library/math.html#math.log" title="math.log"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.log()</span></code></a> 関数には底を指定するオプショナルの <em>base</em> 引数が追加されていて、 <code class="docutils literal notranslate"><span class="pre">e</span></code> と <code class="docutils literal notranslate"><span class="pre">10</span></code> でない底の対数を計算するのが簡単になりました。 (Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first">いくつもの新規 POSIX 関数 (<code class="xref py py-func docutils literal notranslate"><span class="pre">getpgid()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">killpg()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">lchown()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">loadavg()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">major()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">makedev()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">minor()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">mknod()</span></code>) が <a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a> モジュールの下位の <a class="reference internal" href="../library/posix.html#module-posix" title="posix: The most common POSIX system calls (normally used via module os). (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">posix</span></code></a> モジュールに追加されました。(Contributed by Gustavo Niemeyer, Geert Jansen, and Denis S. Otkidach.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a> モジュール内の <code class="xref py py-func docutils literal notranslate"><span class="pre">*stat()</span></code> 系関数が、タイムスタンプの秒の端数を報告するようになりました。そのようなタイムスタンプは <a class="reference internal" href="../library/time.html#time.time" title="time.time"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.time()</span></code></a> が返すのと同じで浮動小数点数で表現されます。</p>
<p>テストを通じて、タイムスタンプが浮動小数点となっていくつかのアプリケーションが破壊されることがわかっています。互換性のために、 <code class="xref py py-class docutils literal notranslate"><span class="pre">stat_result</span></code> タイムスタンプのタプルインターフェイスは整数で表現されます。名前付きフィールド (これは Python 2.2 で最初に導入されました) を用いる場合にもタイムスタンプは今でも整数ですが、 <code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat_float_times()</span></code> を呼び出すことで浮動小数点数で返却するように出来ます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="s2">&quot;/tmp&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">st_mtime</span>
<span class="go">1034791200</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">stat_float_times</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="s2">&quot;/tmp&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">st_mtime</span>
<span class="go">1034791200.6335014</span>
</pre></div>
</div>
<p>Python 2.4 では、浮動小数点数を返すのがデフォルトとなります。</p>
<p>アプリケーション開発者は、この機能を有効にするのは、全ての自身のライブラリが浮動小数点数のタイムスタンプで正しく動作するか、タプル API を使用する場合のみにしてください。使うのであればこの機能は、都度都度有効にしようとせずにアプリケーションレベルで有効にすべきです。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/optparse.html#module-optparse" title="optparse: Command-line option parsing library. (非推奨)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">optparse</span></code></a> モジュールに新たなコマンドライン引数パーサが追加されました。これはオプション値を特定の Python 型に変換することが出来、また、自動的に使用例メッセージを生成します。詳細はこのドキュメントの続くセクションを参照して下さい。</p>
</li>
<li><p class="first">古く、また一度としてドキュメントされたこともない <code class="xref py py-mod docutils literal notranslate"><span class="pre">linuxaudiodev</span></code> モジュールは非推奨となり、新しいバージョンが <a class="reference internal" href="../library/ossaudiodev.html#module-ossaudiodev" title="ossaudiodev: Access to OSS-compatible audio devices. (Linux, FreeBSD)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ossaudiodev</span></code></a> として追加されました。このモジュールがリネームされたのは OSS サウンドドライバは Linux に限って利用出来るものではなく、インターフェイスも整理され、色々な手で更新されたからです。(Contributed by Greg Ward and Nicholas FitzRoy-Dale.)</p>
</li>
<li><p class="first">実行中のプラットフォームについての色々な特性を決定する数多くの関数を含む、新規 <a class="reference internal" href="../library/platform.html#module-platform" title="platform: Retrieves as much platform identifying data as possible."><code class="xref py py-mod docutils literal notranslate"><span class="pre">platform</span></code></a> モジュールが追加されました。アーキテクチャ、CPU タイプ、Windows の OS バージョンや Linux ディストリビューションのバージョンなどを取得できます。(Contributed by Marc-André Lemburg.)</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyexpat</span></code> モジュールのパーサオブジェクトが、オプショナルで文字データをバッファ出来るようになりました。結果として文字データハンドラの呼び出しが少なくなり、速くなります。バッファリングの有効化にはパーサオブジェクトの <code class="xref py py-attr docutils literal notranslate"><span class="pre">buffer_text</span></code> 属性を <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> にセットします。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a> モジュールに <code class="docutils literal notranslate"><span class="pre">sample(population,</span> <span class="pre">k)</span></code> 関数が追加されました。 <em>population</em> は母集団の要素を含んだ、シーケンスか <code class="xref py py-class docutils literal notranslate"><span class="pre">xrange</span></code> オブジェクトで、 <code class="xref py py-func docutils literal notranslate"><span class="pre">sample()</span></code> は母集団から <em>k</em> 要素を値の置換なしに選択します。 <em>k</em> は <code class="docutils literal notranslate"><span class="pre">len(population)</span></code> までの任意の値を渡せます。例えば:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">days</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Mo&#39;</span><span class="p">,</span> <span class="s1">&#39;Tu&#39;</span><span class="p">,</span> <span class="s1">&#39;We&#39;</span><span class="p">,</span> <span class="s1">&#39;Th&#39;</span><span class="p">,</span> <span class="s1">&#39;Fr&#39;</span><span class="p">,</span> <span class="s1">&#39;St&#39;</span><span class="p">,</span> <span class="s1">&#39;Sn&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">days</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>      <span class="c1"># Choose 3 elements</span>
<span class="go">[&#39;St&#39;, &#39;Sn&#39;, &#39;Th&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">days</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>      <span class="c1"># Choose 7 elements</span>
<span class="go">[&#39;Tu&#39;, &#39;Th&#39;, &#39;Mo&#39;, &#39;We&#39;, &#39;St&#39;, &#39;Fr&#39;, &#39;Sn&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">days</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>      <span class="c1"># Choose 7 again</span>
<span class="go">[&#39;We&#39;, &#39;Mo&#39;, &#39;Sn&#39;, &#39;Fr&#39;, &#39;Tu&#39;, &#39;St&#39;, &#39;Th&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">days</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>      <span class="c1"># Can&#39;t choose eight</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
  File <span class="nb">&quot;random.py&quot;</span>, line <span class="m">414</span>, in <span class="n">sample</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s2">&quot;sample larger than population&quot;</span>
<span class="gr">ValueError</span>: <span class="n">sample larger than population</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10000</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="mi">10</span><span class="p">)</span>   <span class="c1"># Choose ten odd nos. under 10000</span>
<span class="go">[3407, 3805, 1505, 7023, 2401, 2267, 9733, 3151, 8083, 9195]</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a> が C で実装された新しいアルゴリズムのメルセンヌ・ツイスタを使うようになりました。これは以前のアルゴリズムよりも高速で、より広く研究されています。</p>
<p>(All changes contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readline</span></code></a> モジュールは多くの新規関数を追加しました: <code class="xref py py-func docutils literal notranslate"><span class="pre">get_history_item()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">get_current_history_length()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">redisplay()</span></code> 。</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal notranslate"><span class="pre">rexec</span></code> モジュールと <code class="xref py py-mod docutils literal notranslate"><span class="pre">Bastion</span></code> モジュールはもう利用出来ないようにしてあります。インポートを試みれば <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> を投げます。新スタイルクラスは <code class="xref py py-mod docutils literal notranslate"><span class="pre">rexec</span></code> により提供される制限実行環境を突破する新たな術を持っており、誰もそれを修正することに興味もなく、その時間も持っていません。 <code class="xref py py-mod docutils literal notranslate"><span class="pre">rexec</span></code> を使うアプリケーションを持っているならば、何かほかの手段で書き換えてください。</p>
<p>(Python 2.2 または 2.1 に留まるにしてもそれは何一つあなたのアプリケーションを安全にはしません。それらバージョンの <code class="xref py py-mod docutils literal notranslate"><span class="pre">rexec</span></code> モジュールには既知のバグがあるからです。繰り返します。 <code class="xref py py-mod docutils literal notranslate"><span class="pre">rexec</span></code> を使っているなら、即座に使用をやめてください。)</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal notranslate"><span class="pre">rotor</span></code> モジュールが非推奨となりました。暗号化に使うアルゴリズムが安全ではないと思われているからです。暗号が必要なのであれば、独立して入手出来るいくつもの AES Python モジュールのなかの一つを使ってください。(---訳注: rotor モジュールは 2.4 で削除されました。---)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/shutil.html#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code></a> モジュールに <code class="docutils literal notranslate"><span class="pre">move(src,</span> <span class="pre">dest)</span></code> が追加されており、これはファイルまたはディレクトリを新しい場所へ再帰的に移動します。</p>
</li>
<li><p class="first">Support for more advanced POSIX signal handling was added to the <a class="reference internal" href="../library/signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a>
but then removed again as it proved impossible to make it work reliably across
platforms.</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> モジュールがタイムアウトをサポートするようになりました。ソケットオブジェクトの <code class="docutils literal notranslate"><span class="pre">settimeout(t)</span></code> メソッドに <em>t</em> 秒を与えることで行えます。これに続くソケット操作が <em>t</em> 秒を超えて完了しない場合には操作は中断し、 <a class="reference internal" href="../library/socket.html#socket.timeout" title="socket.timeout"><code class="xref py py-exc docutils literal notranslate"><span class="pre">socket.timeout</span></code></a> 例外を投げます。</p>
<p>オリジナルのタイムアウト実装は Tim O'Malley によりなされました。Michael Gilfix がこれを Python <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> モジュールに統合し、長い長いレビューに導きました。コードがチェックインされたのち、Guido van Rossum はそれを部分的に書き換えました。(これは協調的開発プロセスの好例です。)</p>
</li>
<li><p class="first">Windows での <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> モジュールの Secure  Sockets Layer (SSL) サポートが始まりました。</p>
</li>
<li><p class="first">C マクロの <code class="xref py py-const docutils literal notranslate"><span class="pre">PYTHON_API_VERSION</span></code> の値が Python レベルで <code class="docutils literal notranslate"><span class="pre">sys.api_version</span></code> として公開されるようになりました。新関数 <code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_clear()</span></code> を呼び出すことで、現在の例外をクリア出来るようになりました。</p>
</li>
<li><p class="first">新モジュール <a class="reference internal" href="../library/tarfile.html#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> で <strong class="program">tar</strong> 形式のアーカイブファイルの読み書きが出来ます。 (Contributed by Lars Gustäbel.)</p>
</li>
<li><p class="first">新規モジュール <a class="reference internal" href="../library/textwrap.html#module-textwrap" title="textwrap: Text wrapping and filling"><code class="xref py py-mod docutils literal notranslate"><span class="pre">textwrap</span></code></a> には、テキストのパラグラフを含んだ文字列を折り返すための関数群を含まれています。 <code class="docutils literal notranslate"><span class="pre">wrap(text,</span> <span class="pre">width)</span></code> 関数は文字列を入力に取り、指定した幅より長いものを含まない行に分割して文字列のリストで返します。 <code class="docutils literal notranslate"><span class="pre">fill(text,</span> <span class="pre">width)</span></code> 関数は指定した幅を超えない分割行に再整形して単一文字列で返します。(ご想像どおり <code class="xref py py-func docutils literal notranslate"><span class="pre">fill()</span></code> は <code class="xref py py-func docutils literal notranslate"><span class="pre">wrap()</span></code> の上に構築されています。例えば:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">textwrap</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paragraph</span> <span class="o">=</span> <span class="s2">&quot;Not a whit, we defy augury: ... more text ...&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">textwrap</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">paragraph</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
<span class="go">[&quot;Not a whit, we defy augury: there&#39;s a special providence in&quot;,</span>
<span class="go"> &quot;the fall of a sparrow. If it be now, &#39;tis not to come; if it&quot;,</span>
<span class="go"> ...]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">paragraph</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span>
<span class="go">Not a whit, we defy augury: there&#39;s</span>
<span class="go">a special providence in the fall of</span>
<span class="go">a sparrow. If it be now, &#39;tis not</span>
<span class="go">to come; if it be not to come, it</span>
<span class="go">will be now; if it be not now, yet</span>
<span class="go">it will come: the readiness is all.</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>モジュールには実際のテキスト折り返しの戦略を実装する <code class="xref py py-class docutils literal notranslate"><span class="pre">TextWrapper</span></code> クラスが含まれています。 <code class="xref py py-class docutils literal notranslate"><span class="pre">TextWrapper</span></code> クラスと  <code class="xref py py-func docutils literal notranslate"><span class="pre">wrap()</span></code> 関数、 <code class="xref py py-func docutils literal notranslate"><span class="pre">fill()</span></code> 関数のどちらも、整形を細かく制御するための数多くの追加的なキーワード引数をサポートしています。詳細はモジュールのドキュメントを調べてください。(Contributed by Greg Ward.)</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal notranslate"><span class="pre">thread</span></code> モジュールと <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> モジュールの仲間として、プラットフォームがスレッドをサポートしない場合の何もしない実装の <code class="xref py py-mod docutils literal notranslate"><span class="pre">thread</span></code> モジュールインターフェイスとして <code class="xref py py-mod docutils literal notranslate"><span class="pre">dummy_thread</span></code> と <a class="reference internal" href="../library/dummy_threading.html#module-dummy_threading" title="dummy_threading: Drop-in replacement for the threading module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">dummy_threading</span></code></a> が追加されました。これはスレッド化を意図する (スレッドが実際動くかには依存 <em>しない</em>) モジュールがコードの先頭に以下のように書くことで単純化することを狙ったものです:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">threading</span> <span class="k">as</span> <span class="nn">_threading</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">dummy_threading</span> <span class="k">as</span> <span class="nn">_threading</span>
</pre></div>
</div>
<p>この例ではモジュール名として <code class="xref py py-mod docutils literal notranslate"><span class="pre">_threading</span></code> を使っていて、これは実際の <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> モジュールが必ずしも必要ではないことをはっきりさせています。 <code class="xref py py-mod docutils literal notranslate"><span class="pre">_threading</span></code> モジュール内の関数とクラスはスレッドがサポートされているいないに関わらず呼び出すことが出来、これは <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 文を避け、コードを少しばかり明快にします。このモジュールはスレッドなしのマルチスレッドコードを走らせるのに特別なことをしません。つまり他のスレッドが戻るのを待ったり何か他のことをするのを待つコードは、単に永遠にハングします。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/time.html#module-time" title="time: Time access and conversions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">time</span></code></a> モジュールの <code class="xref py py-func docutils literal notranslate"><span class="pre">strptime()</span></code> 関数は長いこと混乱の元でした。それがプラットフォームの C 関数 <code class="xref py py-func docutils literal notranslate"><span class="pre">strptime()</span></code> を使い、異なったプラットフォームごとに時折おかしなバグを持っていたからです。Brett Cannon は pure Python で、全てのプラットフォームで全く同じに振舞うように書き直した実装を寄稿しました。</p>
</li>
<li><p class="first">新規モジュール <a class="reference internal" href="../library/timeit.html#module-timeit" title="timeit: Measure the execution time of small code snippets."><code class="xref py py-mod docutils literal notranslate"><span class="pre">timeit</span></code></a> は、Python コードの断片 (スニペット) を実行するのにかかる時間を計測します。ファイル <code class="file docutils literal notranslate"><span class="pre">timeit.py</span></code> は直接コマンドラインから実行出来ますし、モジュールの <code class="xref py py-class docutils literal notranslate"><span class="pre">Timer</span></code> クラスをインポートして直接使うことも出来ます。以下に、空の Unicode 文字列を追加することによって 8 ビット文字列を Unicode に変換するのと <code class="xref py py-func docutils literal notranslate"><span class="pre">unicode()</span></code> 関数を使うのとでいずれが高速なのかを把握するための短い例をお見せします:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">timeit</span>

<span class="n">timer1</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">Timer</span><span class="p">(</span><span class="s1">&#39;unicode(&quot;abc&quot;)&#39;</span><span class="p">)</span>
<span class="n">timer2</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">Timer</span><span class="p">(</span><span class="s1">&#39;&quot;abc&quot; + u&quot;&quot;&#39;</span><span class="p">)</span>

<span class="c1"># Run three trials</span>
<span class="nb">print</span> <span class="n">timer1</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">repeat</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">100000</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">timer2</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">repeat</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">100000</span><span class="p">)</span>

<span class="c1"># On my laptop this outputs:</span>
<span class="c1"># [0.36831796169281006, 0.37441694736480713, 0.35304892063140869]</span>
<span class="c1"># [0.17574405670166016, 0.18193507194519043, 0.17565798759460449]</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Tix</span></code> モジュールに色々バグ修正がなされ、Tix パッケージの現在バージョンに更新されました。</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Tkinter</span></code> モジュールがスレッドを有効化した Tcl で動作するようになりました。Tcl のスレッドモデルは、ウィジットはそれが作られたスレッドからのみアクセスされることを必要とします。ほかのスレッドからのアクセスは Tcl を混乱させます。ある特定の Tcl インターフェイスでは、 <code class="xref py py-mod docutils literal notranslate"><span class="pre">Tkinter</span></code> はウィジットがコマンドの纏め上げによって異なるスレッドからアクセスされる際に、正しいスレッドに向けて結果を待つことで自動的にこれを避けるようになりました。それ以外のインターフェイスでは自動で処理は出来ませんが、 <code class="xref py py-mod docutils literal notranslate"><span class="pre">Tkinter</span></code> はそのようなアクセス時に最低でもそれが問題とわかるよう例外を送出するようになっています。この変更についての詳細な説明は <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2002-December/031107.html">https://mail.python.org/pipermail/python-dev/2002-December/031107.html</a> をみてください。(Implemented by Martin von Löwis.)</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal notranslate"><span class="pre">_tkinter</span></code> を介した Tcl メソッド呼び出しは今では文字列だけを返すのではありません。代わりに Tcl は対応する Python の等価なオブジェクトに変換されたオブジェクトを返します。Python に等価なものがなければ <code class="xref py py-class docutils literal notranslate"><span class="pre">_tkinter.Tcl_Obj</span></code> で包んで返します。この振る舞いは <code class="xref py py-class docutils literal notranslate"><span class="pre">tkapp</span></code> オブジェクトの <code class="xref py py-meth docutils literal notranslate"><span class="pre">wantobjects()</span></code> メソッドで制御出来ます。</p>
<p>(ほとんどの Tkinter アプリケーションがそうするように) <code class="xref py py-mod docutils literal notranslate"><span class="pre">Tkinter</span></code> モジュールを通して <code class="xref py py-mod docutils literal notranslate"><span class="pre">_tkinter</span></code> を使う際、この機能は常に有効になります。これは互換性の問題を引き起こさないはずです。 Tkinter は可能な場合には文字列を Python 型に常に変換していたからです。</p>
<p>何か非互換性を見つけたら古い振る舞いに戻せます。最初の <code class="xref py py-class docutils literal notranslate"><span class="pre">tkapp</span></code> オブジェクトを生成する前に <code class="xref py py-mod docutils literal notranslate"><span class="pre">Tkinter</span></code> モジュールの <code class="xref py py-attr docutils literal notranslate"><span class="pre">wantobjects</span></code> 変数に偽をセットしてください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">Tkinter</span>
<span class="n">Tkinter</span><span class="o">.</span><span class="n">wantobjects</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>ここで説明した変更によって何かアプリケーションの破壊があれば、バグとして報告してください。</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal notranslate"><span class="pre">UserDict</span></code> モジュールに新しく <code class="xref py py-class docutils literal notranslate"><span class="pre">DictMixin</span></code> クラスが追加されました。既に最小限のマッピングインターフェイスを持っているクラスのために、全ての辞書メソッドを定義します。これは、 <a class="reference internal" href="../library/shelve.html#module-shelve" title="shelve: Python object persistence."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shelve</span></code></a> モジュール内のクラスのような、辞書に置換可能である必要があるクラスの記述を大幅に単純化します。</p>
<p>クラスがメソッド <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delitem__()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code> を定義している場合にはいつでも、スーパークラスとして mix-in を追加すると完全な辞書インターフェイスになります。例えば:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">UserDict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">SeqDict</span><span class="p">(</span><span class="n">UserDict</span><span class="o">.</span><span class="n">DictMixin</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&quot;&quot;&quot;Dictionary lookalike implemented with lists.&quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">keylist</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">valuelist</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keylist</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">raise</span> <span class="ne">KeyError</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">valuelist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keylist</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="gp">... </span>            <span class="bp">self</span><span class="o">.</span><span class="n">valuelist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
<span class="gp">... </span>        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
<span class="gp">... </span>            <span class="bp">self</span><span class="o">.</span><span class="n">keylist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="gp">... </span>            <span class="bp">self</span><span class="o">.</span><span class="n">valuelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keylist</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">raise</span> <span class="ne">KeyError</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">keylist</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">valuelist</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keylist</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SeqDict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>      <span class="c1"># See that other dictionary methods are implemented</span>
<span class="go">[&#39;__cmp__&#39;, &#39;__contains__&#39;, &#39;__delitem__&#39;, &#39;__doc__&#39;, &#39;__getitem__&#39;,</span>
<span class="go"> &#39;__init__&#39;, &#39;__iter__&#39;, &#39;__len__&#39;, &#39;__module__&#39;, &#39;__repr__&#39;,</span>
<span class="go"> &#39;__setitem__&#39;, &#39;clear&#39;, &#39;get&#39;, &#39;has_key&#39;, &#39;items&#39;, &#39;iteritems&#39;,</span>
<span class="go"> &#39;iterkeys&#39;, &#39;itervalues&#39;, &#39;keylist&#39;, &#39;keys&#39;, &#39;pop&#39;, &#39;popitem&#39;,</span>
<span class="go"> &#39;setdefault&#39;, &#39;update&#39;, &#39;valuelist&#39;, &#39;values&#39;]</span>
</pre></div>
</div>
<p>(Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/xml.dom.minidom.html#module-xml.dom.minidom" title="xml.dom.minidom: Minimal Document Object Model (DOM) implementation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.dom.minidom</span></code></a> の DOM 実装で、指定したエンコーディングによる XML 出力が可能になりました。DOM ノードの <code class="xref py py-meth docutils literal notranslate"><span class="pre">toxml()</span></code> メソッド、 <code class="xref py py-meth docutils literal notranslate"><span class="pre">toprettyxml()</span></code> メソッドにオプショナルなエンコーディング引数を与えることで行えます。</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpclib</span></code> モジュールが、 Python の <code class="docutils literal notranslate"><span class="pre">None</span></code> のような nil データを処理するための XML-RPC 拡張をサポートするようになりました。 nil 値は XML-RPC 応答のアンマーシャルでいつでもサポートされます。 <code class="docutils literal notranslate"><span class="pre">None</span></code> を含んだリクエストを生成するためには、 <code class="xref py py-class docutils literal notranslate"><span class="pre">Marshaller</span></code> のインスタンスを生成する際に <em>allow_none</em> パラメータに真を与えなければなりません。</p>
</li>
<li><p class="first">新規モジュール <code class="xref py py-mod docutils literal notranslate"><span class="pre">DocXMLRPCServer</span></code> は、セルフ-ドキュメンティング XML-RPC サーバを書くのに使えます。実際のところをみるためにはデモモード (つまりプログラムとして) 実行してみてください。ウェブブラウザを RPC サーバに向ければ pydoc スタイルのドキュメントを生成します。xmlrpclib をサーバに向ければ実際のメソッドを呼び出せます。(Contributed by Brian Quinlan.)</p>
</li>
<li><p class="first">internationalized domain names (RFC 3454, 3490, 3491, 3492) のサポートが追加されました。Unicode ドメイン名とその名前の ASCII 互換エンコーディング (ACE=ASCII-compatible encoding) の間の変換をするのに &quot;idna&quot; エンコーディングを使用出来ます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="p">{}</span><span class="o">&gt;</span><span class="p">{}</span><span class="o">&gt;</span> <span class="sa">u</span><span class="s2">&quot;www.Alliancefrançaise.nu&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;idna&quot;</span><span class="p">)</span>
<span class="s1">&#39;www.xn--alliancefranaise-npb.nu&#39;</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> モジュールも、C ライブラリに渡す前に Unicode ホスト名を ACE バージョンに透過的に変換するように拡張されています。 <code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code> や <a class="reference internal" href="../library/ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftplib</span></code></a> のようなホスト名を扱うモジュールも Unicode ホスト名をサポートしています; <code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code> は HTTP <code class="docutils literal notranslate"><span class="pre">Host</span></code> ヘッダをドメイン名の ACE 版を使って送信します。 <a class="reference internal" href="../library/urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> は URL の <code class="docutils literal notranslate"><span class="pre">path</span></code> 部分が ASCII のみである限り、非 ASCII ホスト名を持つ Unicode URL をサポートします</p>
<p>この変更の実装のために、 <a class="reference internal" href="../library/stringprep.html#module-stringprep" title="stringprep: String preparation, as per RFC 3453"><code class="xref py py-mod docutils literal notranslate"><span class="pre">stringprep</span></code></a> モジュール、 <code class="docutils literal notranslate"><span class="pre">mkstringprep</span></code> ツール、 <code class="docutils literal notranslate"><span class="pre">punycode</span></code> エンコーディングが追加されました。</p>
</li>
</ul>
<div class="section" id="date-time-type">
<h3>日付時刻型<a class="headerlink" href="#date-time-type" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>タイムスタンプとして使うのに相応しい日付と時刻の型が <a class="reference internal" href="../library/datetime.html#module-datetime" title="datetime: Basic date and time types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">datetime</span></code></a> モジュールとして追加されました。これら型は異なるカレンダであるとか多くの洒落た機能をサポートはせずに、時刻表現の基礎だけに集中するものです。</p>
<p>The three primary types are: <code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code>, representing a day, month, and year;
<a class="reference internal" href="../library/datetime.html#datetime.time" title="datetime.time"><code class="xref py py-class docutils literal notranslate"><span class="pre">time</span></code></a>, consisting of hour, minute, and second; and <a class="reference internal" href="../library/datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a>,
which contains all the attributes of both <code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code> and <a class="reference internal" href="../library/datetime.html#datetime.time" title="datetime.time"><code class="xref py py-class docutils literal notranslate"><span class="pre">time</span></code></a>.
There's also a <code class="xref py py-class docutils literal notranslate"><span class="pre">timedelta</span></code> class representing differences between two
points in time, and time zone logic is implemented by classes inheriting from
the abstract <code class="xref py py-class docutils literal notranslate"><span class="pre">tzinfo</span></code> class.</p>
<p>You can create instances of <code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code> and <a class="reference internal" href="../library/datetime.html#datetime.time" title="datetime.time"><code class="xref py py-class docutils literal notranslate"><span class="pre">time</span></code></a> by either supplying
keyword arguments to the appropriate constructor, e.g.
<code class="docutils literal notranslate"><span class="pre">datetime.date(year=1972,</span> <span class="pre">month=10,</span> <span class="pre">day=15)</span></code>, or by using one of a number of
class methods.  For example, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">date.today()</span></code> class method returns the
current local date.</p>
<p>構築後の日付時刻クラスのインスタンスは全て <a class="reference internal" href="../glossary.html#term-immutable"><span class="xref std std-term">immutable</span></a> です。オブジェクトから書式文字列を生成する数多くのメソッドがあります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">datetime</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">now</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>
<span class="go">&#39;2002-12-30T21:27:03.994956&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">now</span><span class="o">.</span><span class="n">ctime</span><span class="p">()</span>  <span class="c1"># Only available on date, datetime</span>
<span class="go">&#39;Mon Dec 30 21:27:03 2002&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y </span><span class="si">%d</span><span class="s1"> %b&#39;</span><span class="p">)</span>
<span class="go">&#39;2002 30 Dec&#39;</span>
</pre></div>
</div>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">replace()</span></code> method allows modifying one or more fields  of a
<code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code> or <a class="reference internal" href="../library/datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a> instance, returning a new instance:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">datetime.datetime(2002, 12, 30, 22, 15, 38, 827738)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="mi">2001</span><span class="p">,</span> <span class="n">hour</span> <span class="o">=</span> <span class="mi">12</span><span class="p">)</span>
<span class="go">datetime.datetime(2001, 12, 30, 12, 15, 38, 827738)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Instances can be compared, hashed, and converted to strings (the result is the
same as that of <code class="xref py py-meth docutils literal notranslate"><span class="pre">isoformat()</span></code>).  <code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code> and <a class="reference internal" href="../library/datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a>
instances can be subtracted from each other, and added to <code class="xref py py-class docutils literal notranslate"><span class="pre">timedelta</span></code>
instances.  The largest missing feature is that there's no standard library
support for parsing strings and getting back a <code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code> or
<a class="reference internal" href="../library/datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a>.</p>
<p>さらに詳しい情報については、モジュールのリファレンスドキュメントを参照してください。 (Contributed by Tim Peters.)</p>
</div>
<div class="section" id="the-optparse-module">
<h3>optparse モジュール<a class="headerlink" href="#the-optparse-module" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The <a class="reference internal" href="../library/getopt.html#module-getopt" title="getopt: Portable parser for command line options; support both short and long option names."><code class="xref py py-mod docutils literal notranslate"><span class="pre">getopt</span></code></a> module provides simple parsing of command-line arguments.  The
new <a class="reference internal" href="../library/optparse.html#module-optparse" title="optparse: Command-line option parsing library. (非推奨)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">optparse</span></code></a> module (originally named Optik) provides more elaborate
command-line parsing that follows the Unix conventions, automatically creates
the output for <code class="xref std std-option docutils literal notranslate"><span class="pre">--help</span></code>, and can perform different actions for different
options.</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">OptionParser</span></code> インスタンスを作ることから始め、プログラムのオプションがどんなであるかそれに対して教えてやります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">optparse</span> <span class="kn">import</span> <span class="n">OptionParser</span>

<span class="n">op</span> <span class="o">=</span> <span class="n">OptionParser</span><span class="p">()</span>
<span class="n">op</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s1">&#39;-i&#39;</span><span class="p">,</span> <span class="s1">&#39;--input&#39;</span><span class="p">,</span>
              <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;string&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">,</span>
              <span class="n">help</span><span class="o">=</span><span class="s1">&#39;set input filename&#39;</span><span class="p">)</span>
<span class="n">op</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s1">&#39;-l&#39;</span><span class="p">,</span> <span class="s1">&#39;--length&#39;</span><span class="p">,</span>
              <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;length&#39;</span><span class="p">,</span>
              <span class="n">help</span><span class="o">=</span><span class="s1">&#39;set maximum length of output&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>コマンドラインの解析は <code class="xref py py-meth docutils literal notranslate"><span class="pre">parse_args()</span></code> メソッドを呼び出すことで行います</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">options</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
<span class="nb">print</span> <span class="n">options</span>
<span class="nb">print</span> <span class="n">args</span>
</pre></div>
</div>
<p>これは、全てのオプションの値を含んだオブジェクトと残った引数を含む文字列リストを返します。</p>
<p>Invoking the script with the various arguments now works as you'd expect it to.
Note that the length argument is automatically converted to an integer.</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ./python opt.py -i data arg1
<span class="go">&lt;Values at 0x400cad4c: {&#39;input&#39;: &#39;data&#39;, &#39;length&#39;: None}&gt;</span>
<span class="go">[&#39;arg1&#39;]</span>
<span class="gp">$</span> ./python opt.py --input<span class="o">=</span>data --length<span class="o">=</span><span class="m">4</span>
<span class="go">&lt;Values at 0x400cad2c: {&#39;input&#39;: &#39;data&#39;, &#39;length&#39;: 4}&gt;</span>
<span class="go">[]</span>
<span class="gp">$</span>
</pre></div>
</div>
<p>The help message is automatically generated for you:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ./python opt.py --help
<span class="go">usage: opt.py [options]</span>

<span class="go">options:</span>
<span class="go">  -h, --help            show this help message and exit</span>
<span class="go">  -iINPUT, --input=INPUT</span>
<span class="go">                        set input filename</span>
<span class="go">  -lLENGTH, --length=LENGTH</span>
<span class="go">                        set maximum length of output</span>
<span class="gp">$</span>
</pre></div>
</div>
<p>さらに詳しいことはモジュールのドキュメントを参照して下さい。</p>
<p>Optik は Getopt SIG の読者からの示唆を受けてGreg Ward により書かれました。</p>
</div>
</div>
<div class="section" id="pymalloc-a-specialized-object-allocator">
<span id="section-pymalloc"></span><h2>Pymalloc: 特殊化されたオブジェクトアロケータ<a class="headerlink" href="#pymalloc-a-specialized-object-allocator" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Pymalloc は Vladimir Marangozov により書かれ Python 2.1 で追加された、特殊化されたオブジェクトアロケータです。Pymalloc は典型的な Python プログラムでのアロケーションのパターンにおいて、システムの <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> よりも高速で省メモリであることを意図したものです。このアロケータは C の <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> 関数を大きなメモリプールを得るのに使い、それより小さなメモリ要求はこれらプールで実現しています。</p>
<p>In 2.1 and 2.2, pymalloc was an experimental feature and wasn't enabled by
default; you had to explicitly enable it when compiling Python by providing the
<code class="xref std std-option docutils literal notranslate"><span class="pre">--with-pymalloc</span></code> option to the <strong class="program">configure</strong> script.  In 2.3,
pymalloc has had further enhancements and is now enabled by default; you'll have
to supply <code class="xref std std-option docutils literal notranslate"><span class="pre">--without-pymalloc</span></code> to disable it.</p>
<p>この変更は Python で書いたコードからは見えませんが、 pymalloc は C 拡張内のバグを露にするかもしれません。C 拡張の著者は pymalloc を有効にしてテストすべきです。というのも、ある種の正しくないコードが実行時にコアダンプしうるからです。</p>
<p>問題を起こすとりわけ一般的な誤りが一つあります。Python の C API 内には数多くのメモリアロケーション関数がありますが、これは以前は単に C ライブラリの <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> と <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code> への別名であり、何かの間違いでミスマッチな関数呼び出しをしても、誤りは気付かれないものでした。今回のこのオブジェクトアロケータを有効化すると、これら関数は <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> と <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code> への別名ではまったくなくて、メモリ解放に誤った関数を呼び出すとコアダンプし得ます。例えば <a class="reference internal" href="../c-api/memory.html#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a> を使って獲得したメモリは <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code> ではなく <a class="reference internal" href="../c-api/memory.html#c.PyObject_Free" title="PyObject_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Free()</span></code></a> を使って解放する必要があります。Python に含まれるいくつかのモジュールがまさにこれに抵触し、修正の必要がありました。間違いなく多くのサードパーティモジュールが同じ問題を抱えているでしょう。</p>
<p>この変更の一環として、メモリアロケーションのためのこんがらかった複数インターフェイスが統合されて 2 つの API ファミリになりました。一方のファミリで獲得されたメモリは他方の関数で操作されることは許されません。一方のファミリはメモリの塊を獲得するためのもので、もう一方は Python オブジェクトの獲得に特殊化されたものです。</p>
<ul class="simple">
<li>何某かの区別のないメモリの塊を獲得・解放するのには「生メモリ」ファミリを使います: <a class="reference internal" href="../c-api/memory.html#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a>, <a class="reference internal" href="../c-api/memory.html#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Realloc()</span></code></a>, <a class="reference internal" href="../c-api/memory.html#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a>.</li>
<li>「オブジェクトメモリ」ファミリは上述の pymalloc 機構へのインターフェイスであり、多数の「小さな」獲得をするための特化がされています: <a class="reference internal" href="../c-api/memory.html#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a>, <a class="reference internal" href="../c-api/memory.html#c.PyObject_Realloc" title="PyObject_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Realloc()</span></code></a>, <a class="reference internal" href="../c-api/memory.html#c.PyObject_Free" title="PyObject_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Free()</span></code></a>.</li>
<li>Python オブジェクトの獲得と解放には「オブジェクト」ファミリ <a class="reference internal" href="../c-api/allocation.html#c.PyObject_New" title="PyObject_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_New()</span></code></a>, <a class="reference internal" href="../c-api/allocation.html#c.PyObject_NewVar" title="PyObject_NewVar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_NewVar()</span></code></a>, <a class="reference internal" href="../c-api/allocation.html#c.PyObject_Del" title="PyObject_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Del()</span></code></a> を使います。</li>
</ul>
<p>Thanks to lots of work by Tim Peters, pymalloc in 2.3 also provides debugging
features to catch memory overwrites and doubled frees in both extension modules
and in the interpreter itself.  To enable this support, compile a debugging
version of the Python interpreter by running <strong class="program">configure</strong> with
<code class="xref std std-option docutils literal notranslate"><span class="pre">--with-pydebug</span></code>.</p>
<p>拡張の著者のために、Python 2.3 のソースとともにヘッダファイル <code class="file docutils literal notranslate"><span class="pre">Misc/pymemcompat.h</span></code> が配布されています。これは Python 拡張に 2.3 インターフェイスでのメモリ獲得を使えるようにするもので、1.5.2 以降の全てのバージョンに対してコンパイル可能です。Python のソース配布物からファイルをコピーして、あなたの拡張ソースにバンドル出来ます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference external" href="https://hg.python.org/cpython/file/default/Objects/obmalloc.c">https://hg.python.org/cpython/file/default/Objects/obmalloc.c</a></dt>
<dd>pymalloc 実装に関する完全な詳細については Python ソースコード内の <code class="file docutils literal notranslate"><span class="pre">Objects/obmalloc.c</span></code> ファイルの先頭のコメントを参照してください。上のファイルへのリンクは python.org の SVN ブラウザを指しています。</dd>
</dl>
</div>
</div>
<div class="section" id="build-and-c-api-changes">
<h2>ビルドならびに C API の変更<a class="headerlink" href="#build-and-c-api-changes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python のビルド過程と C API の変更は以下の通りです:</p>
<ul class="simple">
<li>The cycle detection implementation used by the garbage collection has proven
to be stable, so it's now been made mandatory.  You can no longer compile Python
without it, and the <code class="xref std std-option docutils literal notranslate"><span class="pre">--with-cycle-gc</span></code> switch to <strong class="program">configure</strong> has
been removed.</li>
<li>Python can now optionally be built as a shared library
(<code class="file docutils literal notranslate"><span class="pre">libpython2.3.so</span></code>) by supplying <code class="xref std std-option docutils literal notranslate"><span class="pre">--enable-shared</span></code> when running
Python's <strong class="program">configure</strong> script.  (Contributed by Ondrej Palkovsky.)</li>
<li>マクロ <code class="xref c c-macro docutils literal notranslate"><span class="pre">DL_EXPORT</span></code> と <code class="xref c c-macro docutils literal notranslate"><span class="pre">DL_IMPORT</span></code> が非推奨となっています。Python コアが一般的にマクロ <code class="xref c c-macro docutils literal notranslate"><span class="pre">PyAPI_FUNC</span></code> と <code class="xref c c-macro docutils literal notranslate"><span class="pre">PyAPI_DATA</span></code> を使うのに対し、Python 拡張モジュールの初期化関数が新規マクロ <code class="xref c c-macro docutils literal notranslate"><span class="pre">PyMODINIT_FUNC</span></code> を使って宣言されなければならなくなりました。</li>
<li>The interpreter can be compiled without any docstrings for the built-in
functions and modules by supplying <code class="xref std std-option docutils literal notranslate"><span class="pre">--without-doc-strings</span></code> to the
<strong class="program">configure</strong> script. This makes the Python executable about 10% smaller,
but will also mean that you can't get help for Python's built-ins.  (Contributed
by Gustavo Niemeyer.)</li>
<li><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_NoArgs()</span></code> マクロが非推奨となったので、これを使っているコードは修正しなければなりません。Python 2.2 以降ではメソッド定義テーブルでは引数を持たず、引数チェックを省けることを示すのに <a class="reference internal" href="../c-api/structures.html#METH_NOARGS" title="METH_NOARGS"><code class="xref py py-const docutils literal notranslate"><span class="pre">METH_NOARGS</span></code></a> フラグが使えます。2.2 以前の Python バージョンとの互換性が重要な場合には <code class="docutils literal notranslate"><span class="pre">PyArg_ParseTuple(args,</span> <span class="pre">&quot;&quot;)</span></code> を代わりに使えますが、 <a class="reference internal" href="../c-api/structures.html#METH_NOARGS" title="METH_NOARGS"><code class="xref py py-const docutils literal notranslate"><span class="pre">METH_NOARGS</span></code></a> を使うより遅いです。</li>
<li><a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> に符号なし整数の色々なサイズのためのフォーマット文字が追加されました: <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code> のための <code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">int</span></code> のための <code class="docutils literal notranslate"><span class="pre">H</span></code>, <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> のための <code class="docutils literal notranslate"><span class="pre">I</span></code>, <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code> のための <code class="docutils literal notranslate"><span class="pre">K</span></code>.</li>
<li>新規関数 <code class="docutils literal notranslate"><span class="pre">PyObject_DelItemString(mapping,</span> <span class="pre">char</span> <span class="pre">*key)</span></code> が <code class="docutils literal notranslate"><span class="pre">PyObject_DelItem(mapping,</span> <span class="pre">PyString_New(key))</span></code> の速記法として追加されました。</li>
<li>ファイルオブジェクトの内部文字列バッファの管理が変更されて、必要な場合には指数関数的に増やすようになりました。 <code class="file docutils literal notranslate"><span class="pre">Lib/test/test_bufio.py</span></code> 内のベンチマークテストの結果での速度向上は大幅なものです (ある一つの計測では 57 秒から 1.7 秒になりました)。</li>
<li>C 拡張型のクラスメソッドと静的メソッドを定義出来るようになりました。メソッドの <a class="reference internal" href="../c-api/structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethodDef</span></code></a> 構造体に <a class="reference internal" href="../c-api/structures.html#METH_CLASS" title="METH_CLASS"><code class="xref py py-const docutils literal notranslate"><span class="pre">METH_CLASS</span></code></a> フラグか <a class="reference internal" href="../c-api/structures.html#METH_STATIC" title="METH_STATIC"><code class="xref py py-const docutils literal notranslate"><span class="pre">METH_STATIC</span></code></a> フラグをセットすることで行えます。</li>
<li>Python は Expat XML パーサのソースコードのコピーを丸抱えするようになり、これにより Expat のシステムのバージョンやローカルにインストールされたものへの依存がなくなっています。</li>
<li>If you dynamically allocate type objects in your extension, you should be
aware of a change in the rules relating to the <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> and
<a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> attributes.  In summary, you will want to ensure the type's
dictionary contains a <code class="docutils literal notranslate"><span class="pre">'__module__'</span></code> key; making the module name the part of
the type name leading up to the final period will no longer have the desired
effect.  For more detail, read the API reference documentation or the  source.</li>
</ul>
<div class="section" id="port-specific-changes">
<h3>ポート特有の変更<a class="headerlink" href="#port-specific-changes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Support for a port to IBM's OS/2 using the EMX runtime environment was merged
into the main Python source tree.  EMX is a POSIX emulation layer over the OS/2
system APIs.  The Python port for EMX tries to support all the POSIX-like
capability exposed by the EMX runtime, and mostly succeeds; <code class="xref py py-func docutils literal notranslate"><span class="pre">fork()</span></code> and
<a class="reference internal" href="../library/fcntl.html#module-fcntl" title="fcntl: The fcntl() and ioctl() system calls. (Unix)"><code class="xref py py-func docutils literal notranslate"><span class="pre">fcntl()</span></code></a> are restricted by the limitations of the underlying emulation
layer.  The standard OS/2 port, which uses IBM's Visual Age compiler, also
gained support for case-sensitive import semantics as part of the integration of
the EMX port into CVS.  (Contributed by Andrew MacIntyre.)</p>
<p>On MacOS, most toolbox modules have been weaklinked to improve backward
compatibility.  This means that modules will no longer fail to load if a single
routine is missing on the current OS version. Instead calling the missing
routine will raise an exception. (Contributed by Jack Jansen.)</p>
<p>The RPM spec files, found in the <code class="file docutils literal notranslate"><span class="pre">Misc/RPM/</span></code> directory in the Python
source distribution, were updated for 2.3.  (Contributed by Sean Reifschneider.)</p>
<p>Other new platforms now supported by Python include AtheOS
(<a class="reference external" href="http://www.atheos.cx/">http://www.atheos.cx/</a>), GNU/Hurd, and OpenVMS.</p>
</div>
</div>
<div class="section" id="other-changes-and-fixes">
<span id="section-other"></span><h2>その他の変更と修正<a class="headerlink" href="#other-changes-and-fixes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>いつものように、たくさんのほかの改善とバグフィックスがソースツリー全体に渡って散らばっています。CVS 変更ログを検索すると、Python 2.2 から 2.3 にかけて適用されたパッチは 523、バグ修正は 514 ありました。いずれも少なく見積もって、です。</p>
<p>ほかの、さらに特筆すべき変更のいくつかを挙げます:</p>
<ul>
<li><p class="first">環境変数 <span class="target" id="index-79"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONINSPECT"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONINSPECT</span></code></a> をセットしておくと、Python インタプリタが Python プログラム実行後に対話モードに入ります。これは Python を <a class="reference internal" href="../using/cmdline.html#cmdoption-i"><code class="xref std std-option docutils literal notranslate"><span class="pre">-i</span></code></a> で起動するのと同じです。環境変数は Python インタプリタ実行前にセットするか、Python プログラムのその実行の一部としてセットすることが出来ます。</p>
</li>
<li><p class="first">The <code class="file docutils literal notranslate"><span class="pre">regrtest.py</span></code> script now provides a way to allow &quot;all resources
except <em>foo</em>.&quot;  A resource name passed to the <code class="xref std std-option docutils literal notranslate"><span class="pre">-u</span></code> option can now be
prefixed with a hyphen (<code class="docutils literal notranslate"><span class="pre">'-'</span></code>) to mean &quot;remove this resource.&quot;  For example,
the option '<code class="docutils literal notranslate"><span class="pre">-uall,-bsddb</span></code>' could be used to enable the use of all resources
except <code class="docutils literal notranslate"><span class="pre">bsddb</span></code>.</p>
</li>
<li><p class="first">ドキュメントのビルドに使われるツールは今では Unix 同様に Cygwin でも動作します。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">SET_LINENO</span></code> 命令コード (opcode) は削除されました。彼方の昔に戻れば、この命令コードはトレースバック内で行番号を生成し、トレース関数をサポートするのに必要でした (例えば <a class="reference internal" href="../library/pdb.html#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code></a> のために)。Python 1.5 より、トレースバック内の行番号は &quot;python -O&quot; で働くための異なったメカニズムを用いて計算で求められてきました。2.3 のためには Michael Hudson がトレース関数を呼ぶのに決定する似た方法を実装しましたので、 <code class="docutils literal notranslate"><span class="pre">SET_LINENO</span></code> の必要性は完全になくなりました。</p>
<p>Python コードから何か異なる結果を見つけるのは、 <a class="reference internal" href="../using/cmdline.html#cmdoption-o"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a> なしで Python を実行する際のわずかなスピードアップを別とすれば、困難かもしれません。</p>
<p>フレームオブジェクトの <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_lineno</span></code> フィールドにアクセスしている C 拡張は、代わりに <code class="docutils literal notranslate"><span class="pre">PyCode_Addr2Line(f-&gt;f_code,</span> <span class="pre">f-&gt;f_lasti)</span></code> を呼び出すべきです。これは以前の Python バージョンでも &quot;python -O&quot; のもとでコードが動作するのにも望ましい効果を持つでしょう。</p>
<p>気の利いた新機能としては、トレース関数は、今ではフレームオブジェクトの <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_lineno</span></code> 属性を、次に実行される行に変更してセットします。 <a class="reference internal" href="../library/pdb.html#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code></a> デバッガにはこの新機能の恩恵を受けて <code class="docutils literal notranslate"><span class="pre">jump</span></code> コマンドが追加されています。 (Implemented by Richie Hindle.)</p>
</li>
</ul>
</div>
<div class="section" id="porting-to-python-2-3">
<h2>Python 2.3 への移植<a class="headerlink" href="#porting-to-python-2-3" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このセクションでは前述の変更により必要となるかもしれないコードの変更を列挙します:</p>
<ul>
<li><p class="first"><a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> は今では常にキーワードです。変数名として使っていたならば、別の名前を選ぶ必要があります。</p>
</li>
<li><p class="first">文字列 <em>X</em> と <em>Y</em> について、 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">in</span> <span class="pre">Y</span></code> は <em>X</em> が一文字以上の場合でも動作するようになりました。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> 型コンストラクタは、文字列や浮動小数点数を整数に収める際、それがとても大き場合に  <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a> を投げるのではなく長整数を返すようになっています。</p>
</li>
<li><p class="first">8 ビット文字を含んだ Unicode 文字列をソースコードに埋め込む場合、ファイルのエンコーディング (UTF-8, Latin-1, あるいはほか何か) を、ファイルの先頭のコメントに宣言しなければなりません。 <a class="reference internal" href="#section-encodings"><span class="std std-ref">PEP 263: ソースコードのエンコーディング</span></a> を参照してください。</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal notranslate"><span class="pre">_tkinter</span></code> を介した Tcl メソッド呼び出しは今では文字列だけを返すのではありません。代わりに Tcl は対応する Python の等価なオブジェクトに変換されたオブジェクトを返します。Python に等価なものがなければ <code class="xref py py-class docutils literal notranslate"><span class="pre">_tkinter.Tcl_Obj</span></code> で包んで返します。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">0xffffffff</span></code> のような大きな値の 8 進、16 進リテラルで <a class="reference internal" href="../library/exceptions.html#FutureWarning" title="FutureWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FutureWarning</span></code></a> が発行されます。2.3 ではこれは 32 ビットの値に格納されて結果は負の値になりますが、Python 2.4 ではこれは正の長整数になります。</p>
<p>この警告の修正をする方法が少しだけあります。本当に正の値が欲しいのであれば <code class="docutils literal notranslate"><span class="pre">L</span></code> をリテラルの最後に付けて下さい。32 ビット分だけの下位ビットセットで 32 ビット整数を取り出したいのであれば、また、 <code class="docutils literal notranslate"><span class="pre">~(1</span> <span class="pre">&lt;&lt;</span> <span class="pre">31)</span></code> のような式を使ってきたのであれば、おそらく全ビットをセットすることから始めて上位ビットをクリアするのが最も簡明です。例えば最上位ビット (ビット 31) を単にクリアするには <code class="docutils literal notranslate"><span class="pre">0xffffffffL</span> <span class="pre">&amp;~(1L&lt;&lt;31)</span></code> と書けます。(---訳注: 2 点。Python 3 サポートを検討するならば <code class="docutils literal notranslate"><span class="pre">L</span></code> は付けないように。2.4 以降は警告もなしに長整数になりますし。もう一点はこのパラグラフ全体について。根本的に警告への対処の話をしてるようで後半はほとんど本質でない話をしているので意味不明な文章になっています。本当に 2.3 を使わなければならないのでない限り、この文章を真面目に理解しようとしなくとも良いと思います(本質的な措置は <code class="docutils literal notranslate"><span class="pre">L</span></code> を付けることしかない、2.3 では)。---)</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">__debug__</span></code> に代入することでアサーションを無効にすることは出来なくなりました。</p>
</li>
<li><p class="first">Distutils の <code class="xref py py-func docutils literal notranslate"><span class="pre">setup()</span></code> 関数に <em>depends</em> のような色々な新しいキーワード引数が追加されています。Distutils の古いバージョンでは未知のキーワードを渡すと処理を中断してしまいます。新旧で動作させなければならないのであれば、 <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> 内で <code class="xref py py-func docutils literal notranslate"><span class="pre">get_distutil_options()</span></code> 関数の有無をチェックし、それらをサポートするバージョンの Distutils でのみ新しいキーワード引数を使うようにしてください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">distutils</span> <span class="kn">import</span> <span class="n">core</span>

<span class="n">kw</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sources&#39;</span><span class="p">:</span> <span class="s1">&#39;foo.c&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">}</span>
<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">core</span><span class="p">,</span> <span class="s1">&#39;get_distutil_options&#39;</span><span class="p">):</span>
    <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;depends&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;foo.h&#39;</span><span class="p">]</span>
<span class="n">ext</span> <span class="o">=</span> <span class="n">Extension</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">None</span></code> を変数名に使うと <a class="reference internal" href="../library/exceptions.html#SyntaxWarning" title="SyntaxWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxWarning</span></code></a> 警告を出すようになっています。</p>
</li>
<li><p class="first">Python と一緒に含まれるモジュールで定義される拡張型の名前にモジュール名と <code class="docutils literal notranslate"><span class="pre">'.'</span></code> が型名の頭に付くようになっています。</p>
</li>
</ul>
</div>
<div class="section" id="acknowledgements">
<span id="acks"></span><h2>謝辞<a class="headerlink" href="#acknowledgements" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>著者は提案の申し出や修正、様々なこの記事の草稿の助けをしてくれた以下の人々に感謝します:  Jeff Bauer, Simon Brunning, Brett Cannon, Michael Chermside, Andrew Dalke, Scott David Daniels, Fred L. Drake, Jr., David Fraser, Kelly Gerber, Raymond Hettinger, Michael Hudson, Chris Lambert, Detlef Lannert, Martin von Löwis, Andrew MacIntyre, Lalo Martins, Chad Netzer, Gustavo Niemeyer, Neal Norwitz, Hans Nowak, Chris Reedy, Francesco Ricciardi, Vinay Sajip, Neil Schemenauer, Roman Suzi, Jason Tishler, Just van Rossum.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">What's New in Python 2.3</a><ul>
<li><a class="reference internal" href="#pep-218-a-standard-set-datatype">PEP 218: 標準の集合データ型</a></li>
<li><a class="reference internal" href="#pep-255-simple-generators">PEP 255: 単純なジェネレータ</a></li>
<li><a class="reference internal" href="#pep-263-source-code-encodings">PEP 263: ソースコードのエンコーディング</a></li>
<li><a class="reference internal" href="#pep-273-importing-modules-from-zip-archives">PEP 273: Zip アーカイブからモジュールをインポートする</a></li>
<li><a class="reference internal" href="#pep-277-unicode-file-name-support-for-windows-nt">PEP 277: Windows NT での Unicode ファイル名サポート</a></li>
<li><a class="reference internal" href="#pep-278-universal-newline-support">PEP 278: Universal Newline サポート</a></li>
<li><a class="reference internal" href="#pep-279-enumerate">PEP 279: enumerate()</a></li>
<li><a class="reference internal" href="#pep-282-the-logging-package">PEP 282: ロギングパッケージ</a></li>
<li><a class="reference internal" href="#pep-285-a-boolean-type">PEP 285: Boolean 型</a></li>
<li><a class="reference internal" href="#pep-293-codec-error-handling-callbacks">PEP 293: コーデックエラーを処理するコールバック</a></li>
<li><a class="reference internal" href="#pep-301-package-index-and-metadata-for-distutils">PEP 301: パッケージインデクスと、 Distutils のためのメタデータ</a></li>
<li><a class="reference internal" href="#pep-302-new-import-hooks">PEP 302: 新たなインポートフック</a></li>
<li><a class="reference internal" href="#pep-305-comma-separated-files">PEP 305: カンマ区切り形式ファイル</a></li>
<li><a class="reference internal" href="#pep-307-pickle-enhancements">PEP 307: Pickle の機能拡張</a></li>
<li><a class="reference internal" href="#extended-slices">拡張スライス</a></li>
<li><a class="reference internal" href="#other-language-changes">その他の言語変更</a><ul>
<li><a class="reference internal" href="#string-changes">文字列に関する変更</a></li>
<li><a class="reference internal" href="#optimizations">最適化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-improved-and-deprecated-modules">新たなモジュール、改良されたモジュール、非推奨のモジュール</a><ul>
<li><a class="reference internal" href="#date-time-type">日付時刻型</a></li>
<li><a class="reference internal" href="#the-optparse-module">optparse モジュール</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pymalloc-a-specialized-object-allocator">Pymalloc: 特殊化されたオブジェクトアロケータ</a></li>
<li><a class="reference internal" href="#build-and-c-api-changes">ビルドならびに C API の変更</a><ul>
<li><a class="reference internal" href="#port-specific-changes">ポート特有の変更</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-changes-and-fixes">その他の変更と修正</a></li>
<li><a class="reference internal" href="#porting-to-python-2-3">Python 2.3 への移植</a></li>
<li><a class="reference internal" href="#acknowledgements">謝辞</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="2.4.html"
                        title="前の章へ">What's New in Python 2.4</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="2.2.html"
                        title="次の章へ">What's New in Python 2.2</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.8/Doc/whatsnew/2.3.rst"
            rel="nofollow">ソースコードを表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="2.2.html" title="What&#39;s New in Python 2.2"
             >次へ</a> |</li>
        <li class="right" >
          <a href="2.4.html" title="What&#39;s New in Python 2.4"
             >前へ</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.3rc1 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >What's New in Python</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" type="text" name="q" />
          <input type="submit" value="検索" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">著作権</a> 2001-2020, Python Software Foundation.
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最終更新: 5月 13, 2020
    <a href="https://docs.python.org/3/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>

  </body>
</html>