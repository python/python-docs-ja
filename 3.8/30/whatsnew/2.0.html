
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>What&#39;s New in Python 2.0 &#8212; Python 3.8.3 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.8.3 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="next" title="変更履歴" href="changelog.html" />
    <link rel="prev" title="What&#39;s New in Python 2.1" href="2.1.html" />
    <link rel="canonical" href="https://docs.python.org/3/whatsnew/2.0.html" />
    
      
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="changelog.html" title="変更履歴"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="2.1.html" title="What&#39;s New in Python 2.1"
             accesskey="P">前へ</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.3 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">What's New in Python</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" type="text" name="q" />
          <input type="submit" value="検索" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="what-s-new-in-python-2-0">
<h1>What's New in Python 2.0<a class="headerlink" href="#what-s-new-in-python-2-0" title="このヘッドラインへのパーマリンク">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">著者:</th><td class="field-body">A.M. Kuchling and Moshe Zadka</td>
</tr>
</tbody>
</table>
<div class="section" id="introduction">
<h2>はじめに<a class="headerlink" href="#introduction" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>新 Python リリース、バージョン 2.0 は、2000 年 10 月 16 日にリリースされました。この記事では 2.0 のエキサイティングな新機能をカバーし、いくつかの有用な変更点をハイライトし、少しの、コードの書き換えを要する互換性のない変更点について指摘します。</p>
<p>Python の開発は、リリースとリリースの間で止まることはなく、バグフィックスと改善はとめどなく、日夜提出されます。多くのマイナーフィックス、少しの最適化、ドキュメンテーション文字列の追加、より良いエラーメッセージが 2.0 に仲間入りしました。これら全てを列挙するのは不可能ですが、それは確かに大事でしょう、全てのリストを見たければ、公に入手可能な CVS ログを調べてください。この前進は、今やバグ修正に日々を費やすことで報酬を受け取って PythonLabs のために働く 5 人の開発者、それと SourceForge に移行した結果改善されたコミュニケーションのおかげです。</p>
</div>
<div class="section" id="what-about-python-1-6">
<h2>Python 1.6 はいかがっすか?<a class="headerlink" href="#what-about-python-1-6" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 1.6 は「推定的義務」の Python リリースと考えることが出来ます。2000 年 5 月にコア開発チームが CNRI を離れたあと、CNRI は Python にかかる作業全てが CNRI で実施されることを含む 1.6 リリースが作成されることをリクエストしました。それゆえ Python 1.6 は、最も重要な新機能としての Unicode サポートを含む、2000 年 5 月の CVS ツリーの状態と同等です。開発はもちろん 5 月以降も継続されましたので、1.6 ツリーは Python 2.0 との前方互換を保障するために少しの修正を受け取りました。1.6 はですから、Python の進化の一部であり、側枝ではありません。</p>
<p>では、あなたは Python 1.6 に興味を示すべきでしょうか? おそらく答えはノーです。1.6final と 2.0beta1 のリリースは同じ日に行われ (2000 年 9 月 5 日)、Python 2.0 のファイナライズはその一ヶ月かそこらで行われるよう計画されました。もしあなたが保守すべきアプリケーションを持っているならば、1.6 への移行には少しばかりコードの破壊を伴うようです。つまりその修正を行い、一ヶ月の間に 2.0 への移行による別の破壊ラウンドがやってきます。直接 2.0 に移行したほうが良いでしょう。このドキュメントに記載する、ほとんどの面白い機能は 2.0 のみのものであり、なぜならほとんどの作業は、5 月から 9 月の間に行われたからなのです。</p>
</div>
<div class="section" id="new-development-process">
<h2>新しい開発プロセス<a class="headerlink" href="#new-development-process" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 2.0 における最も重要な変化はコードに対するものではまったくなくて、Python がどのように開発されるのかについてでしょう: 2000 年 5 月に Python 開発者たちは、ソースコード格納、バグ報告の追跡、パッチ提出の待ち行列管理のための SourceForge によって利用出来るようになったツールの使用を始めました。Python 2.0 ではバグ報告やパッチの提出には、Python プロジェクトページで利用可能なバグトラッキングとパッチ管理ツールを使ってください。 <a class="reference external" href="https://sourceforge.net/projects/python/">https://sourceforge.net/projects/python/</a> にあります(訳注: 2015 年現在の状況は What's New in Python 2.6 参照)。</p>
<p>SourceForge で現在ホストされているサービスの中で最も重要なのは Python CVS ツリーで、Python のソースコードを含む、バージョンコントロールされたレポジトリです。以前までは、CVS ツリーへの書き込み許可を持つ人々が 7 人ほどいて、全てのパッチはその中の一人が精査とチェックをする必要がありました。明らかにこれはスケーラブルではありませんでした。CVS ツリーを SourceForge に移動することで、より多くの人々に書き込み許可を与えることが可能になりました; 2000 年 9 月時点で、27 人の人々が変更をチェックイン出来るようになっていました。これは 4 倍の増加です。これは大規模な変更、これまでであれば小さなコア開発グループによるフィルタを経由しなければならないために試みられなかったような、大規模な変更を可能にしています。例えばある日 Peter Schneider-Kamp は K&amp;R C 互換を落としてしまうことを思い立ち、Python の C ソースを ANSI C に変換しました。python-dev メーリングリストでの承認を得たのち、彼は立て続けにチェックインを開始しておよそ一週間ほどで終わらせ、ほかの開発者たちも手助けに参加し、そして作業は完了しました。書き込み許可が 5 人だけだったならば、おそらくそのタスクはこう見做されたでしょう:「素晴らしい。けれども時間と労力に見合わない」。そして決して実現することはなかったことでしょう。</p>
<p>SourceForge のサービスを使うことへのシフトは、開発の目覚しいスピードアップをもたらしました。パッチはいまや、提出され、コメントされ、提出者以外の別人によって改定されて戻ってきて、などなどが、パッチがチェックインの価値があると判断されるまで行われています。バグは唯一つの中央保管庫で追跡され、修正には特定の誰かを割り当てることが出来、そして私たちはオープンバグを進捗の指標として考えることが出来ます。これは代償なしでは達成しませんでした; 開発者には今や以前よりもたくさんの処理すべき電子メールがあり、より多くメーリングリストに追従しなければならず、そして新しい環境のための特別なツールを要しました。例えば、SourceForge はデフォルトでパッチ提出とバグ報告を電子メールで通知しますが、これは全く助けにならないもので、Ka-Ping Yee はもっと有用なメッセージを送信するための HTML スクリーンスクレイパを書きました。</p>
<p>簡単にコードを追加出来るようになったことは、当初少し苦痛を大きくしました。例えばコードが不十分なままだったり、開発グループからのはっきりとした承諾のないままチェックインされたりするといったことです。浮上してきた承認プロセスは、Apache グループが使っているようなものにいくらか似たものです。開発者たちは +1, +0, -0, -1 というふうにパッチに投票できます; +1 と -1 は承諾、却下を表し、+0 と -0 は、開発者は変更にほとんど興味がないけれどもやや肯定、否定の傾向であることを意味します。Apache モデルからの最も大きな違いは、投票行為は本質的に助言であって、優しい終身独裁者 Guido van Rossum 侯に大衆の民意を伝えるものであることです。彼は投票結果をそれでも無視出来ますし、コミュニティが異論を唱えようが変更を承認したり却下したり出来ます。</p>
<p>Producing an actual patch is the last step in adding a new feature, and is
usually easy compared to the earlier task of coming up with a good design.
Discussions of new features can often explode into lengthy mailing list threads,
making the discussion hard to follow, and no one can read every posting to
python-dev.  Therefore, a relatively formal process has been set up to write
Python Enhancement Proposals (PEPs), modelled on the Internet RFC process.  PEPs
are draft documents that describe a proposed new feature, and are continually
revised until the community reaches a consensus, either accepting or rejecting
the proposal.  Quoting from the introduction to <span class="target" id="index-0"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0001"><strong>PEP 1</strong></a>, &quot;PEP Purpose and
Guidelines&quot;:</p>
<blockquote class="epigraph">
<div><p>PEP は Python Enhancement Proposal を意味します。PEP は、Python コミュニティに対して情報を提供する、あるいは Python の新機能について記述する設計文書です。PEP は、機能についての技術的な仕様とその機能の論拠(理論)を簡潔に伝えるべきです。</p>
<p>私たちは PEP が新機能提案にかかる、コミュニティによる問題提起の集積と Python になされる設計決断の文書化のための最上位の機構となることを意図しています。PEP の著者にはコミュニティ内の合意形成を行うこと、反対意見を文書化することの責務があります。</p>
</div></blockquote>
<p>Read the rest of <span class="target" id="index-1"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0001"><strong>PEP 1</strong></a> for the details of the PEP editorial process, style, and
format.  PEPs are kept in the Python CVS tree on SourceForge, though they're not
part of the Python 2.0 distribution, and are also available in HTML form from
<a class="reference external" href="https://www.python.org/dev/peps/">https://www.python.org/dev/peps/</a>.  As of September 2000, there are 25 PEPS, ranging
from <span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0201"><strong>PEP 201</strong></a>, &quot;Lockstep Iteration&quot;, to PEP 225, &quot;Elementwise/Objectwise
Operators&quot;.</p>
</div>
<div class="section" id="unicode">
<h2>Unicode 文字列型<a class="headerlink" href="#unicode" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 2.0 での最大の新機能は新しい基礎データ型、Unicode 文字列です。Unicode は文字を表現するのに ASCII で使用される 8 ビット数の代わりに 16 ビットを使います。これによって 65,536 の個別の文字がサポート出来ます。(---訳注: Unicode の扱いはまず Python 2.2 で UCS4 が使えるように拡張され(つまり 32 ビットに拡張)、Python 3 では Unicode が唯一の文字列型に変更されています。後者の変更点は非常に大きいですが、クックブックの「Python 2 から Python 3 への移植」に比較的よくまとめられています。---)</p>
<p>最終的な Unicode サポートに関するインターフェイスは、python-dev メーリングリストにおける数え切れない、時として嵐のような議論を経て、Fredrik Lundh によって実装された Unicode 文字列型に基づいて、ほとんどが Marc-André Lemburg によって実装されました。インターフェイスについての詳細な説明は <span class="target" id="index-8"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0100"><strong>PEP 100</strong></a> 「Python Unicode の統合」に記述されました。今ここでは、Unicode インターフェイスについて、一番重要な点を単純にカバーするだけにしましょう。</p>
<p>Python ソースコード内では Unicode 文字列は <code class="docutils literal notranslate"><span class="pre">u&quot;string&quot;</span></code> のように書きます。任意の Unicode 文字は新しく追加されたエスケープシーケンスで書きます。 <code class="docutils literal notranslate"><span class="pre">\uHHHH</span></code> のように書き、 <em>HHHH</em> は 0000 から FFFF までの 4 桁の 16 進表記数です。以前からあるエスケープシーケンス <code class="docutils literal notranslate"><span class="pre">\xHHHH</span></code> も使えますし、8 進表記も、 <code class="docutils literal notranslate"><span class="pre">\777</span></code> で表現される U+01FF までの文字に使えます。</p>
<p>Unicode strings, just like regular strings, are an immutable sequence type.
They can be indexed and sliced, but not modified in place. Unicode strings have
an <code class="docutils literal notranslate"><span class="pre">encode(</span> <span class="pre">[encoding]</span> <span class="pre">)</span></code> method that returns an 8-bit string in the desired
encoding.  Encodings are named by strings, such as <code class="docutils literal notranslate"><span class="pre">'ascii'</span></code>, <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'iso-8859-1'</span></code>, or whatever.  A codec API is defined for implementing and
registering new encodings that are then available throughout a Python program.
If an encoding isn't specified, the default encoding is usually 7-bit ASCII,
though it can be changed for your Python installation by calling the
<code class="docutils literal notranslate"><span class="pre">sys.setdefaultencoding(encoding)</span></code> function in a customized version of
<code class="file docutils literal notranslate"><span class="pre">site.py</span></code>.</p>
<p>8 ビット文字列と Unicode 文字列を結合すると常に、デフォルトの ASCII エンコーディングを使って Unicode に型変換されます。 <code class="docutils literal notranslate"><span class="pre">'a'</span> <span class="pre">+</span> <span class="pre">u'bc'</span></code> の結果は <code class="docutils literal notranslate"><span class="pre">u'abc'</span></code> になります。</p>
<p>新たなビルトイン関数が追加され、既存のビルトイン関数も Unicode サポートのために修正されました:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">unichr(ch)</span></code> は Unicode におけるコードが整数 <em>ch</em> になるような文字 1 文字からなる Unicode 文字列を返します。</li>
<li><em>u</em> が 1 文字の通常文字あるいは Unicode 文字として、 <code class="docutils literal notranslate"><span class="pre">ord(u)</span></code> はコードを整数で返します。</li>
<li><code class="docutils literal notranslate"><span class="pre">unicode(string</span> <span class="pre">[,</span> <span class="pre">encoding]</span> <span class="pre">[,</span> <span class="pre">errors]</span> <span class="pre">)</span></code> は、8 ビット文字列から Unicode 文字列を作ります。 <code class="docutils literal notranslate"><span class="pre">encoding</span></code> は使用するエンコーディング名の文字列です。 <code class="docutils literal notranslate"><span class="pre">errors</span></code> パラメータは、現在エンコーディングにおいて不正な文字の扱いを指示します; これに値として <code class="docutils literal notranslate"><span class="pre">'strict'</span></code> を渡すと全てのエンコーディングエラーに対し、例外を引き起こします。 <code class="docutils literal notranslate"><span class="pre">'ignore'</span></code> を渡すとエラーは黙って無視されます。 <code class="docutils literal notranslate"><span class="pre">'replace'</span></code> を渡すと、全ての問題ケースで、公式な置き換え文字である U+FFFD に置き換えます。</li>
<li><code class="docutils literal notranslate"><span class="pre">exec</span></code> 文や　<code class="docutils literal notranslate"><span class="pre">eval()</span></code>, <code class="docutils literal notranslate"><span class="pre">getattr()</span></code>, <code class="docutils literal notranslate"><span class="pre">setattr()</span></code> のような色々なビルトインも、普通の文字列同様に Unicode 文字列を受け付けるようになりました。(この修正をするプロセスをいくつかのビルトインで忘れている可能性もあります。文字列を受け取るものが Unicode を全く受け取らないビルトインを見つけたら、バグとして報告してください。)</li>
</ul>
<p>新規モジュール <a class="reference internal" href="../library/unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unicodedata</span></code></a> は、Unicode 文字の特性へのインターフェイスを提供します。例えば <code class="docutils literal notranslate"><span class="pre">unicodedata.category(u'A')</span></code> は 2 文字の文字列 'Lu' を返しますが、これは、 'L' が letter を、 'u' が uppercase を表します。 <code class="docutils literal notranslate"><span class="pre">unicodedata.bidirectional(u'\u0660')</span></code> は 'AN' を返し、これは U+0660 が Arabic Number であることを表します。</p>
<p><a class="reference internal" href="../library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> モジュールには、既存のエンコーディングをルックアップする関数、新しいエンコーディングを登録する関数が含まれます。新しいエンコーディングを実装したいと思うのでない限りは、一番使うことになるのは <code class="docutils literal notranslate"><span class="pre">codecs.lookup(encoding)</span></code> でしょう。これは 4 要素のタプルを返します: <code class="docutils literal notranslate"><span class="pre">(encode_func,</span> <span class="pre">decode_func,</span> <span class="pre">stream_reader,</span> <span class="pre">stream_writer)</span></code> 。</p>
<ul class="simple">
<li><em>encode_func</em> は、Unicode 文字列を受け取って 2 要素タプル <code class="docutils literal notranslate"><span class="pre">(string,</span> <span class="pre">length)</span></code> を返す関数です。 <em>string</em> は、与えられたエンコーディングで Unicode 文字列を変換した部分 (おそらく全体) を含む 8 ビット文字列で、 <em>length</em> は何文字の Unicode 文字列が変換されたかを伝えます。</li>
<li><em>decode_func</em> は <em>encode_func</em> の対となる関数で、8 ビット文字列を受け取って、2 要素のタプル <code class="docutils literal notranslate"><span class="pre">(ustring,</span> <span class="pre">length)</span></code> を返します。 <em>ustring</em> が結果の Unicode 文字列で、整数 <em>length</em> が、8 ビット文字列何文字が消費されたかを表します。</li>
<li><em>stream_reader</em> は、ストリームからの入力のデコードをサポートするクラスです。 <em>stream_reader(file_obj)</em> はメソッド <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code>, <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">readlines()</span></code> をサポートするオブジェクトを返します。これらのメソッドは与えられたエンコーディングで全て変換して Unicode 文字列を返します。</li>
<li><em>stream_writer</em> は同じように、ストリームへのエンコードした出力をサポートするクラスです。 <em>stream_writer(file_obj)</em> はメソッド <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> と <code class="xref py py-meth docutils literal notranslate"><span class="pre">writelines()</span></code> をサポートするオブジェクトを返します。これらメソッドは Unicode 文字列を期待して、それらを与えられたエンコーディングで変換して出力します。</li>
</ul>
<p>例えば以下のコードは Unicode 文字列を UTF-8 でエンコーディングしてファイルに書きます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">codecs</span>

<span class="n">unistr</span> <span class="o">=</span> <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u0660\u2000</span><span class="s1">ab ...&#39;</span>

<span class="p">(</span><span class="n">UTF8_encode</span><span class="p">,</span> <span class="n">UTF8_decode</span><span class="p">,</span>
 <span class="n">UTF8_streamreader</span><span class="p">,</span> <span class="n">UTF8_streamwriter</span><span class="p">)</span> <span class="o">=</span> <span class="n">codecs</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="s1">&#39;UTF-8&#39;</span><span class="p">)</span>

<span class="n">output</span> <span class="o">=</span> <span class="n">UTF8_streamwriter</span><span class="p">(</span> <span class="nb">open</span><span class="p">(</span> <span class="s1">&#39;/tmp/output&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="p">)</span>
<span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span> <span class="n">unistr</span> <span class="p">)</span>
<span class="n">output</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>そして以下コードではファイルから UTF-8 で読めます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">input</span> <span class="o">=</span> <span class="n">UTF8_streamreader</span><span class="p">(</span> <span class="nb">open</span><span class="p">(</span> <span class="s1">&#39;/tmp/output&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="p">)</span>
<span class="nb">print</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
<span class="nb">input</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> モジュールでは Unicode 対応した正規表現が利用可能で、これは新しい根底となる SRE なる実装から成り、Secret Labs AB の Fredrik Lundh によって書かれました。</p>
<p>Python コンパイラに全ての文字列リテラルを Unicode 文字列として解釈させるための <code class="docutils literal notranslate"><span class="pre">-U</span></code> コマンドラインオプションが追加されました。これはあなたの Python コードのテストと将来の保障を意図しています。というのも、将来の Python バージョンでは 8 ビット文字列のサポートがなくなって、Unicode 文字列だけとなる予定だからです。 (---訳注: ここで言っている将来バージョンとは、結果的には Python 3 になりました。What's New での明記はないのですが <code class="docutils literal notranslate"><span class="pre">-U</span></code> オプションは Python 2.7 時点では存在していません。ですが同じことは 2.6 以降では <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">unicode_literals</span></code> で出来ます。 ---)</p>
</div>
<div class="section" id="list-comprehensions">
<h2>リストの内包表記<a class="headerlink" href="#list-comprehensions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>リストというのは Python の馬車馬データ型で、多くのプログラムがリストをいつかは操るものです。リストの操作での 2 つのよくある操作は、それらについてループし、あるいは特定の基準に合致したものを取り出すか個々の要素にある関数を適用するかする、といったものです。例えば文字列のリストが与えられた場合、特定の部分文字列を含む全ての文字列を引き抜いたり、あるいは各行から末尾の空白を取り除いたりしたいでしょう。</p>
<p>既にあった <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a> 関数、 <a class="reference internal" href="../library/functions.html#filter" title="filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">filter()</span></code></a> 関数がこの目的のためには使えますが、それらにはその引数の一つに関数が必要です。何か既存のビルトイン関数で直接渡せるものがあればよいのですが、これがない場合その必要とされる仕事をする小さな関数を作る必要があって、また、Python のスコープ規則によって、その小さな関数が何かほかの情報を必要とする場合に醜いものになります。前パラグラフでの最初の例を考えましょう。指定の部分文字列を含む文字列リストから全てを探す例です。このように書けるでしょう:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Given the list L, make a list of all strings</span>
<span class="c1"># containing the substring S.</span>
<span class="n">sublist</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">substring</span><span class="o">=</span><span class="n">S</span><span class="p">:</span>
                     <span class="n">string</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">substring</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                  <span class="n">L</span><span class="p">)</span>
</pre></div>
</div>
<p>Because of Python's scoping rules, a default argument is used so that the
anonymous function created by the <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> expression knows what
substring is being searched for.  List comprehensions make this cleaner:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sublist</span> <span class="o">=</span> <span class="p">[</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">L</span> <span class="k">if</span> <span class="n">string</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">]</span>
</pre></div>
</div>
<p>リスト内包表記は以下の形式を持ちます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="n">expression</span> <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">sequence1</span>
             <span class="k">for</span> <span class="n">expr2</span> <span class="ow">in</span> <span class="n">sequence2</span> <span class="o">...</span>
             <span class="k">for</span> <span class="n">exprN</span> <span class="ow">in</span> <span class="n">sequenceN</span>
             <span class="k">if</span> <span class="n">condition</span> <span class="p">]</span>
</pre></div>
</div>
<p>The <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code>...<code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code> clauses contain the sequences to be
iterated over.  The sequences do not have to be the same length, because they
are <em>not</em> iterated over in parallel, but from left to right; this is explained
more clearly in the following paragraphs.  The elements of the generated list
will be the successive values of <em>expression</em>.  The final <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> clause
is optional; if present, <em>expression</em> is only evaluated and added to the result
if <em>condition</em> is true.</p>
<p>セマンティクスについてとてもわかりやすく説明しておきましょう。リスト内包は以下の Python コードと等価です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">expr1</span> <span class="ow">in</span> <span class="n">sequence1</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">expr2</span> <span class="ow">in</span> <span class="n">sequence2</span><span class="p">:</span>
    <span class="o">...</span>
        <span class="k">for</span> <span class="n">exprN</span> <span class="ow">in</span> <span class="n">sequenceN</span><span class="p">:</span>
             <span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">):</span>
                  <span class="c1"># Append the value of</span>
                  <span class="c1"># the expression to the</span>
                  <span class="c1"># resulting list.</span>
</pre></div>
</div>
<p>This means that when there are multiple <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code>...<code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code>
clauses, the resulting list will be equal to the product of the lengths of all
the sequences.  If you have two lists of length 3, the output list is 9 elements
long:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">seq1</span> <span class="o">=</span> <span class="s1">&#39;abc&#39;</span>
<span class="n">seq2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq1</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">seq2</span><span class="p">]</span>
<span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
</pre></div>
</div>
<p>Python の文法に曖昧さを紛れ込ませないように、<em>expression</em> でタプルを作るなら括弧で囲わなくてはなりません。下にあるリスト内包表記で、最初のは構文エラーですが、二番目は有効です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Syntax error</span>
<span class="p">[</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq1</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">seq2</span><span class="p">]</span>
<span class="c1"># Correct</span>
<span class="p">[</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq1</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">seq2</span><span class="p">]</span>
</pre></div>
</div>
<p>リスト内包表記のアイディアは、もともとは関数型プログラミング言語 Haskell (<a class="reference external" href="https://www.haskell.org">https://www.haskell.org</a>) に由来しています。Greg Ewing が Python にこれを追加することを最も実際的に主張し、彼が最初のリスト内包のパッチを書きました。それは傍目には終わりのない議論が python-dev メーリングリストにて続き、Skip Montanaro によって最新に保たれました。</p>
</div>
<div class="section" id="augmented-assignment">
<h2>累算代入 (Augmented Assignment)<a class="headerlink" href="#augmented-assignment" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>累算代入はもう一つの長らく待ち望まれた機能であり、Python 2.0 に追加されました。累算代入演算子には  <code class="docutils literal notranslate"><span class="pre">+=</span></code>, <code class="docutils literal notranslate"><span class="pre">-=</span></code>, <code class="docutils literal notranslate"><span class="pre">*=</span></code> などがあります。例えばステートメント <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">2</span></code> は変数 <code class="docutils literal notranslate"><span class="pre">a</span></code> に 2 を加算し、これはちょっとだけ長い記述 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">2</span></code> と同じです。</p>
<p>サポートされる累算代入演算子をぜんぶ列挙すれば、 <code class="docutils literal notranslate"><span class="pre">+=</span></code>, <code class="docutils literal notranslate"><span class="pre">-=</span></code>, <code class="docutils literal notranslate"><span class="pre">*=</span></code>, <code class="docutils literal notranslate"><span class="pre">/=</span></code>, <code class="docutils literal notranslate"><span class="pre">%=</span></code>, <code class="docutils literal notranslate"><span class="pre">**=</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;=</span></code>, <code class="docutils literal notranslate"><span class="pre">|=</span></code>, <code class="docutils literal notranslate"><span class="pre">^=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code> です。Python のクラスは累算代入演算子をオーバライド出来ます。 <a class="reference internal" href="../reference/datamodel.html#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__isub__" title="object.__isub__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__isub__()</span></code></a> などのメソッドを定義することで行います。例えば、以下の <code class="xref py py-class docutils literal notranslate"><span class="pre">Number</span></code> クラスは数値を格納し、 <code class="docutils literal notranslate"><span class="pre">+=</span></code> を使って増分値で新たなインスタンスを作ります。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Number</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">increment</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Number</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">increment</span><span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="n">Number</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">n</span> <span class="o">+=</span> <span class="mi">3</span>
<span class="nb">print</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span>
</pre></div>
</div>
<p>特殊メソッド <a class="reference internal" href="../reference/datamodel.html#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a> は増分値を引数に呼び出され、適切な修正された値を持った新たなインスタンスを返さなければなりません。この戻り値は左辺の新しい値として束縛されます。</p>
<p>累算代入演算子は最初に C 言語で導入されて、 <strong class="program">awk</strong>, C++, Java, Perl, PHP といった C から派生した言語のほとんどでサポートされています。累算代入のパッチは Thomas Wouters により実装されました。</p>
</div>
<div class="section" id="string-methods">
<h2>文字列メソッド<a class="headerlink" href="#string-methods" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>今までは、文字列操作の機能については <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a> モジュール内にあり、これは普通 C で書かれたモジュール <code class="xref py py-mod docutils literal notranslate"><span class="pre">strop</span></code> へのフロントエンドでした。 <code class="xref py py-mod docutils literal notranslate"><span class="pre">strop</span></code> モジュールへの Unicode サポートの追加には困難がありました。8 ビット文字列と Unicode 文字列を受け付けるために全て書き直す必要があったからです。 <code class="xref py py-func docutils literal notranslate"><span class="pre">string.replace()</span></code> のような関数は、これは 3 つの文字列引数を取るのであって、このことは 8 通りの可能な組合せがあるということで、それに応じてコードが複雑化するものでした。</p>
<p>代わりに、Python 2.0 は問題を文字列型に押し込み、文字列操作機能が 8 ビット文字列と Unicode 文字列の両方のメソッドを通じて利用可能としました。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;andrew&#39;</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
<span class="go">&#39;Andrew&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;hostname&#39;</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;os&#39;</span><span class="p">,</span> <span class="s1">&#39;linux&#39;</span><span class="p">)</span>
<span class="go">&#39;hlinuxtname&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;moshe&#39;</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;sh&#39;</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>変わらない一つのこと、華やかなエイプリルフールのジョークではありませんが、それは Python 文字列が <a class="reference internal" href="../glossary.html#term-immutable"><span class="xref std std-term">immutable</span></a> だということです。ですので文字列メソッドは新しい文字列を返し、それが操作する文字列を変更しません。</p>
<p>古い <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a> モジュールはまだ後方互換性のために残されますが、それはほとんど新たな文字列メソッドへのフロントエンドとして振舞います。</p>
<p>2.0 以前のバージョンでは共通で相当するものがなくて JPython にはかなり暫くの間存在していたのが、2 つのメソッド <code class="xref py py-meth docutils literal notranslate"><span class="pre">startswith()</span></code> と <code class="xref py py-meth docutils literal notranslate"><span class="pre">endswith()</span></code> です。 <code class="docutils literal notranslate"><span class="pre">s.startswith(t)</span></code> は <code class="docutils literal notranslate"><span class="pre">s[:len(t)]</span> <span class="pre">==</span> <span class="pre">t</span></code> と等価、 <code class="docutils literal notranslate"><span class="pre">s.endswith(t)</span></code> は <code class="docutils literal notranslate"><span class="pre">s[-len(t):]</span> <span class="pre">==</span> <span class="pre">t</span></code> と等価です。</p>
<p>特筆しなければならないもう一つ別のメソッドには <code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code> があります。文字列の <code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code> メソッドは文字列のシーケンスを一つのパラメータとして受け取りますが、これは古い <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a> モジュールの <code class="xref py py-func docutils literal notranslate"><span class="pre">string.join()</span></code> と引数が逆ですが同じです。つまり <code class="docutils literal notranslate"><span class="pre">s.join(seq)</span></code> と旧式 <code class="docutils literal notranslate"><span class="pre">string.join(seq,</span> <span class="pre">s)</span></code> が同じです。(---訳注: 「引数が逆」はここだけ読むとわかりにくいかもしれません。string モジュールから文字列メソッドへ置き換えるのにほかは第一引数が self に置き換わっただけにみえるのに対しこれはそうではない、ということです。---)</p>
</div>
<div class="section" id="garbage-collection-of-cycles">
<h2>循環参照のガベージコレクション<a class="headerlink" href="#garbage-collection-of-cycles" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python の C 実装は、ガーベージコレクションの実装に参照カウントを使っています。全ての Python オブジェクトは自身を参照している数を維持していて、参照が作成されたり破壊されたりするカウントを調整しています。参照カウントがゼロになればそのオブジェクトにはもはや到達可能ではありません。あなたはそれにアクセスするためのオブジェクトへの参照を持つ必要がありますが、カウントがゼロならば参照はもはや存在しないということです。</p>
<p>参照カウントはある種望ましい特徴を持っています。それは理解しやすく、実装しやすく、結果としての実装の移植性は高く、かなり高速であり、そして、独自のメモリ処理方式を実装しているようなほかのライブラリと共にでも良く振舞います。参照カウントの主要な問題点は、それが時々、オブジェクトにはもう到達不能であることに気付かないので、結果としてメモリリークを引き起こすことです。これは参照の循環がある場合に発生します。</p>
<p>最も単純な循環について考えてみます。クラスインスタンスが自身への参照を持つ場合です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">instance</span> <span class="o">=</span> <span class="n">SomeClass</span><span class="p">()</span>
<span class="n">instance</span><span class="o">.</span><span class="n">myself</span> <span class="o">=</span> <span class="n">instance</span>
</pre></div>
</div>
<p>上の例の 2 行のコードが実行された後では、 <code class="docutils literal notranslate"><span class="pre">instance</span></code> の参照カウントは 2 です。参照の一つ目は <code class="docutils literal notranslate"><span class="pre">'instance'</span></code> と名付けられた変数からのもので、もう一つの参照は、インスタンスの <code class="docutils literal notranslate"><span class="pre">myself</span></code> 属性から来るものです。</p>
<p>このあとに続くコードが <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">instance</span></code> だとしたら、何が起こるでしょうか? <code class="docutils literal notranslate"><span class="pre">instance</span></code> の参照カウントは 1 減るので参照カウントは 1 になります。 <code class="docutils literal notranslate"><span class="pre">myself</span></code> 属性内の参照はいまだ存在します。けれどもインスタンスはもう Python コードからは到達不能ですから、本来削除出来るはずです。お互いを参照しあうならばいくつものオブジェクトが循環に参加しえるので、結果それら全てのオブジェクトはリークしてしまいます。</p>
<p>Python 2.0 はこの問題を、循環検出アルゴリズムを周期的に実行することによりフィックスします。そのアルゴリズムは、到達不能な循環を探して関係するオブジェクトを削除します。新しく追加された <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> モジュールは、ガーベージコレクションを実行する関数、デバッグのための統計情報を取得する関数、コレクタのパラメータを調整する関数を提供します。</p>
<p>循環検出アルゴリズムの実行はいくらかの時間がかかるので、結果として多少の追加的なオーバヘッドがかかるでしょう。2.0 を使って循環のコレクションの経験を積んだのちに、 Python 2.1 では注意深い調整によりオーバヘッドを最小に出来ることが望まれています。今のところパフォーマンスの損失がいかほどなのかは明らかではありません。これはこれのベンチマークがトリッキーであり、プログラムがどれだけの頻度でオブジェクトを構築・破棄するのかに大きく依存するからです。循環の検出は Python コンパイル時に無効に出来ます。もしもあなたが小さな速度のペナルティでさえも許容出来ないであるとか、あるいは循環のコレクションがバギーであることを疑うのであれば、 <strong class="program">configure</strong> スクリプト実行時に <code class="xref std std-option docutils literal notranslate"><span class="pre">--without-cycle-gc</span></code> スイッチを与えることでそうすることが出来ます。 (---訳注: Python 2.3 でこの循環参照の GC は必須となり、 <code class="xref std std-option docutils literal notranslate"><span class="pre">--without-cycle-gc</span></code> 、 <code class="xref std std-option docutils literal notranslate"><span class="pre">--with-cycle-gc</span></code> での有無効化は撤廃されました。---)</p>
<p>何人かの人々がこの問題に体当たりで取り組み、解決に対する貢献をしました。循環検出アプローチの初期の実装は、Toby Kelsey により書かれました。現在のアルゴリズムは CNRI を訪れている間に Eric Tiedemann によって提案されて、Guido van Rossum と Neil Schemenauer が別々の 2 つの実装を書いて、あとで Neil によって統合されたものです。そこに至るまでにもほかの数多くの人々によって提案がなされました。python-dev メーリングリストの 2000 年 3 月のアーカイブに、これに関するほとんどの議論が含まれています。特にタイトルが &quot;Reference cycle collection for Python&quot; と &quot;Finalization again&quot; のスレッドです。</p>
</div>
<div class="section" id="other-core-changes">
<h2>その他の言語コアの変更<a class="headerlink" href="#other-core-changes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 文法とビルトイン関数について、色々マイナーな変更がなされました。影響が広範囲に及ぶものは一つもありませんが、手軽で便利なものです。</p>
<div class="section" id="minor-language-changes">
<h3>言語のマイナー変更<a class="headerlink" href="#minor-language-changes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>引数のタプルとキーワード引数の辞書の一方あるいは両方で関数を呼び出すのに、より便利な構文が追加されました。Python 1.5 とそれ以前ではビルトイン関数 <code class="xref py py-func docutils literal notranslate"><span class="pre">apply()</span></code> を使っていました: <code class="docutils literal notranslate"><span class="pre">apply(f,</span> <span class="pre">args,</span> <span class="pre">kw)</span></code> は引数タプル <em>args</em> と辞書 <em>kw</em> に入れたキーワード引数で関数 <code class="xref py py-func docutils literal notranslate"><span class="pre">f()</span></code> を呼び出します。 <code class="xref py py-func docutils literal notranslate"><span class="pre">apply()</span></code> は 2.0 でも同じですが、Greg Ewing によるパッチのおかげで、同じ効果を得るのにより短くてわかりやすい <code class="docutils literal notranslate"><span class="pre">f(*args,</span> <span class="pre">**kw)</span></code> が使えます。この構文は以下のような関数定義に呼応するものです:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="c1"># args is a tuple of positional args,</span>
    <span class="c1"># kw is a dictionary of keyword args</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">print</span></code> 文がUnix シェルのリダイレクト操作のように、 <code class="docutils literal notranslate"><span class="pre">print</span></code> に続けて <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span> <span class="pre">file</span></code> と書くことでその出力をファイルのように振舞うオブジェクトに向けられるようになりました。(---訳注: 念のため。Python 3 では print は文ではなく関数になっており、これは移植性がありません。Python 2.6 以降であれば関数版の print を使う(<span class="target" id="index-9"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3105"><strong>PEP 3105</strong></a>)か、ファイルオブジェクト自身のメソッドを使ってください。もしくは目的がログ出力であるならば、 <a class="reference internal" href="../library/logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> パッケージの使用を検討してください。---) 以前までは次のいずれかをする必要がありました。一つにはファイルのように振舞うオブジェクトの <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> メソッドを呼び出すことであり、これは <code class="docutils literal notranslate"><span class="pre">print</span></code> が持つ便利さと単純さに欠けています。もう一つは <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> に新しい値を代入し、あとで元の値に戻すというやり方です。標準エラー出力に出力を送るのに、このように遥かに簡単に書くことが出来ます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="o">&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Warning: action field not supplied&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">module</span> <span class="pre">as</span> <span class="pre">name</span></code> または <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">name</span> <span class="pre">as</span> <span class="pre">othername</span></code> という構文を使って、インポートするモジュールの名前をリネーム出来るようになりました。パッチは Thomas Wouters が投稿しました。</p>
<p><code class="docutils literal notranslate"><span class="pre">%</span></code> 演算子を使う際に新しい書式化スタイルが利用可能です; '%r' はその引数の <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> を挿入します。これは対称性の検討からも考えられました。今の場合は既存の '%s' が引数の <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> を挿入することに呼応するものです。例えば <code class="docutils literal notranslate"><span class="pre">'%r</span> <span class="pre">%s'</span> <span class="pre">%</span> <span class="pre">('abc',</span> <span class="pre">'abc')</span></code> は文字列 <code class="docutils literal notranslate"><span class="pre">'abc'</span> <span class="pre">abc</span></code> を返します。</p>
<p>Previously there was no way to implement a class that overrode Python's built-in
<a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> operator and implemented a custom version.  <code class="docutils literal notranslate"><span class="pre">obj</span> <span class="pre">in</span> <span class="pre">seq</span></code> returns
true if <em>obj</em> is present in the sequence <em>seq</em>; Python computes this by simply
trying every index of the sequence until either <em>obj</em> is found or an
<a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> is encountered.  Moshe Zadka contributed a patch which adds a
<a class="reference internal" href="../reference/datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> magic method for providing a custom implementation for
<code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code>. Additionally, new built-in objects written in C can define what
<code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code> means for them via a new slot in the sequence protocol.</p>
<p>以前のバージョンの Python では、オブジェクトの削除に再帰するアルゴリズムを使っていました。データ構造が深くネストしている場合、インタプリタが C のスタックを使い果たしてクラッシュしていました。Christian Tismer はこの問題をフィックスする削除ロジックに書き直しました。これに関係する注目すべきものとしては、再帰するオブジェクトの比較が無限再帰してクラッシュしていたのを、Jeremy Hylton が書き直してクラッシュしないようにして、有用な結果を生成するようにしたことです。例えば以下コード:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>これに対して比較 <code class="docutils literal notranslate"><span class="pre">a==b</span></code> は、2つの再帰データ構造が同型であるので真を返します (---訳注: 詳細はわかりませんが、現在の Python 2.7、Python 3 ではこれは &quot;RuntimeError: maximum recursion depth exceeded in comparison&quot; になります ---)。python-dev メーリングリストのアーカイブの 2000 年 4 月のスレッド &quot;trashcan and PR#7&quot; に、この実装に導いた議論といくつかの関連する有用なリンクがあります。また、比較は今では例外を投げることも出来ます。以前のバージョンの Python では <code class="docutils literal notranslate"><span class="pre">cmp(a,b)</span></code> のような比較操作は、ユーザ定義の <code class="xref py py-meth docutils literal notranslate"><span class="pre">__cmp__()</span></code> メソッドがエラーを起こそうがそれ黙殺された上で、必ず何かの答えを出していました。</p>
<p>Work has been done on porting Python to 64-bit Windows on the Itanium processor,
mostly by Trent Mick of ActiveState.  (Confusingly, <code class="docutils literal notranslate"><span class="pre">sys.platform</span></code> is still
<code class="docutils literal notranslate"><span class="pre">'win32'</span></code> on Win64 because it seems that for ease of porting, MS Visual C++
treats code as 32 bit on Itanium.) PythonWin also supports Windows CE; see the
Python CE page at <a class="reference external" href="http://pythonce.sourceforge.net/">http://pythonce.sourceforge.net/</a> for more information.</p>
<p>Another new platform is Darwin/MacOS X; initial support for it is in Python 2.0.
Dynamic loading works, if you specify &quot;configure --with-dyld --with-suffix=.x&quot;.
Consult the README in the Python source distribution for more instructions.</p>
<p>変数に値が割り当てられる前にローカル変数を参照するコードにおいて、 <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> 例外はよく混乱するものであり、この欠点を軽減する試みがなされました。例えば下に挙げるコードは <code class="docutils literal notranslate"><span class="pre">print</span></code> 文で 1.5.2 と 2.0 の両方で例外が発生しますが、1.5.2 は <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> 例外が、2.0 では新規の例外 <a class="reference internal" href="../library/exceptions.html#UnboundLocalError" title="UnboundLocalError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnboundLocalError</span></code></a> が投げられます。 <a class="reference internal" href="../library/exceptions.html#UnboundLocalError" title="UnboundLocalError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnboundLocalError</span></code></a> は <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> のサブクラスですので <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> が投げられることを想定する既存のコードはそのまま動作するはずです。:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="nb">print</span> <span class="s2">&quot;i=&quot;</span><span class="p">,</span><span class="n">i</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
<p>2 つの新規例外 <a class="reference internal" href="../library/exceptions.html#TabError" title="TabError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TabError</span></code></a> と <a class="reference internal" href="../library/exceptions.html#IndentationError" title="IndentationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndentationError</span></code></a> が導入されました。これらはともに <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> のサブクラスで、Python コードに不適切なインデントが見つかると送出されます。</p>
</div>
<div class="section" id="changes-to-built-in-functions">
<h3>ビルトイン関数の変更<a class="headerlink" href="#changes-to-built-in-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>新しいビルトイン関数 <code class="docutils literal notranslate"><span class="pre">zip(seq1,</span> <span class="pre">seq2,</span> <span class="pre">...)</span></code> が追加されました。 <a class="reference internal" href="../library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> はタプルのリストを返します。それぞれは、引数のシーケンスのそれぞれの i 番目要素たちを含むタプルです。 <a class="reference internal" href="../library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> と <code class="docutils literal notranslate"><span class="pre">map(None,</span> <span class="pre">seq1,</span> <span class="pre">seq2)</span></code> の違いは、 <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a> はシーケンスが同じ長さを持たない場合に <code class="docutils literal notranslate"><span class="pre">None</span></code> が埋められるのに対し、 <a class="reference internal" href="../library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> は返すリストの長さを、引数のシーケンスの最も短い長さに切り詰めます。</p>
<p><a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> と <code class="xref py py-func docutils literal notranslate"><span class="pre">long()</span></code> が、最初の引数が文字列である場合に「base (基数)」パラメータを受け付けるようになりました。 <code class="docutils literal notranslate"><span class="pre">int('123',</span> <span class="pre">10)</span></code> は 123 を返し、 <code class="docutils literal notranslate"><span class="pre">int('123',</span> <span class="pre">16)</span></code> は 291 を返します。 <code class="docutils literal notranslate"><span class="pre">int(123,</span> <span class="pre">16)</span></code> はメッセージ &quot;can't convert non-string with explicit base&quot; を伴った <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 例外を送出します。</p>
<p><a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> モジュールに、これまでより詳細なバージョン情報を持つ変数が追加されました。 <code class="docutils literal notranslate"><span class="pre">sys.version_info</span></code> はタプル <code class="docutils literal notranslate"><span class="pre">(major,</span> <span class="pre">minor,</span> <span class="pre">micro,</span> <span class="pre">level,</span> <span class="pre">serial)</span></code> です。例えば仮に 2.0.1beta1 というバージョンだったとすれば、 <code class="docutils literal notranslate"><span class="pre">sys.version_info</span></code> は <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">'beta',</span> <span class="pre">1)</span></code> となるでしょう。 <em>level</em> は <code class="docutils literal notranslate"><span class="pre">&quot;alpha&quot;</span></code> や <code class="docutils literal notranslate"><span class="pre">&quot;beta&quot;</span></code> といった文字列で、最終リリースでは <code class="docutils literal notranslate"><span class="pre">&quot;final&quot;</span></code> です。(---訳注: Python 2.7 で名前付きタプルになっています。また、その属性名では level ではなく releaselevel です。---)</p>
<p>辞書に、ちょっと風変わりなメソッド <code class="docutils literal notranslate"><span class="pre">setdefault(key,</span> <span class="pre">default)</span></code> が追加されました。これは既存の <code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code> メソッドに似た振る舞いをします。ですが、キーが存在してない場合に <code class="xref py py-meth docutils literal notranslate"><span class="pre">setdefault()</span></code> は <code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code> がそうするように <em>default</em> を返しつつ、同時に辞書にキー <em>key</em> の値として追加もします。ですから以下コード:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nb">dict</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span> <span class="n">key</span> <span class="p">):</span> <span class="k">return</span> <span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</pre></div>
</div>
<p>は、単一の <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">dict.setdefault(key,</span> <span class="pre">[])</span></code> ステートメントだけで書けます。</p>
<p>再帰の暴走を C のスタックが埋め尽くされてコアダンプしたり GPF (訳注: General Protection Fault) する前に捕捉するために、インタプリタは最大の再帰の深さをセットします。以前まではこの制限は Python コンパイル時点で決めてしまっていましたが、2.0 では最大の再帰の深さは <a class="reference internal" href="../library/sys.html#sys.getrecursionlimit" title="sys.getrecursionlimit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getrecursionlimit()</span></code></a> と <a class="reference internal" href="../library/sys.html#sys.setrecursionlimit" title="sys.setrecursionlimit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setrecursionlimit()</span></code></a> を使って読み取れ、修正出来ます。このデフォルトは 1000 です。また、当該プラットフォームでのおよその最大値は、新たに追加されたスクリプト <code class="file docutils literal notranslate"><span class="pre">Misc/find_recursionlimit.py</span></code> を実行することで知ることが出来ます。</p>
</div>
</div>
<div class="section" id="porting-to-2-0">
<h2>Python 2.0 への移植<a class="headerlink" href="#porting-to-2-0" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>新しい Python リリースは以前のリリースとの互換性を保つために苦心していますし、その記録はかなり良くなされてきました。ですがいくつかの変更に関しては、大抵は大きな誤りであると判明した初期デザインを修正するという理由で、後方互換性を破壊することを必ずしも回避せずに有用性が検討されています。このセクションでは Python 2.0 において、古い Python コードを破壊するかもしれない変更点について列挙します。</p>
<p>おそらくほとんどのコードを破壊する変更は、ある種のメソッドで受け付けられる引数に関して厳しくなることです。ある種のメソッドは複数の引数を取ってそれらをタプルとして扱っていたでしょう。特に <code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code> や <code class="xref py py-meth docutils literal notranslate"><span class="pre">insert()</span></code> といったリストの色々なメソッドです。以前のバージョンの Python では、 <code class="docutils literal notranslate"><span class="pre">L</span></code> がリストとして、 <code class="docutils literal notranslate"><span class="pre">L.append(</span> <span class="pre">1,2</span> <span class="pre">)</span></code> はタプル <code class="docutils literal notranslate"><span class="pre">(1,2)</span></code> をリストに追加していました。Python 2.0 ではこれはメッセージ 'append requires exactly 1 argument; 2 given' を持つ <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> を引き起こします。期待通りになるよう修正するには単に、両方の値がタプルとして渡るように追加の括弧を付けます: <code class="docutils literal notranslate"><span class="pre">L.append(</span> <span class="pre">(1,2)</span> <span class="pre">)</span></code> 。</p>
<p>それらメソッドの以前のバージョンがもっと寛容だったのは、その引数の解析のための Python の C インターフェイスで古い関数を使っていたからです。2.0 ではそれらを、引数解析関数 <code class="xref py py-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code> を使って現代化していて、これはより助けとなるエラーメッセージを提供しつつ複数引数での呼び出しをエラーとして扱います。もしも完全に 2.0 を使わなければならないのにあなたのコードを修正出来ないのであれば、 <code class="file docutils literal notranslate"><span class="pre">Objects/listobject.c</span></code> を編集してプリプロセッサシンボル <code class="docutils literal notranslate"><span class="pre">NO_STRICT_LIST_APPEND</span></code> を定義することで、古い振る舞いに戻せます。これはお奨め出来ません。(---訳注: いつ消えたのかはわかりませんが 2.7 ではもちろん <code class="docutils literal notranslate"><span class="pre">NO_STRICT_LIST_APPEND</span></code> の ifdef は入っていません。---)</p>
<p><a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> モジュールのいくつかの関数についてはまだこの方法が許されています。例えば <code class="docutils literal notranslate"><span class="pre">socket.connect(</span> <span class="pre">('hostname',</span> <span class="pre">25)</span> <span class="pre">)</span></code> が正しい形式なのですが、 <code class="docutils literal notranslate"><span class="pre">socket.connect(</span> <span class="pre">'hostname',</span> <span class="pre">25</span> <span class="pre">)</span></code> も動作します。 <code class="xref py py-func docutils literal notranslate"><span class="pre">socket.connect_ex()</span></code> と <code class="xref py py-func docutils literal notranslate"><span class="pre">socket.bind()</span></code> も同じようにおおらかです。2.0alpha1 がそれら関数を厳しくしたのですが、ドキュメントが実際には複数引数を取る形式で誤って書かれたために、多くの人々がその厳しくなったチェックに違反してしまうコードを書いてしまいました。GvR はその変更を、市民たちの反応を受けて元に戻し、 <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> モジュールについてはドキュメントは修正されて、複数引数形式は非推奨としてマークするに留められました。将来バージョンの Python においてこれはもう一度厳しく <em>なります</em> 。 (---訳注: What's New からは読み取れませんが少なくとも 2.7 では単一引数でしか渡せません。つまり明示的にタプルにして渡す必要があります。---)</p>
<p>文字列リテラル内の <code class="docutils literal notranslate"><span class="pre">\x</span></code> エスケープは、正確に 2 桁の 16 進表記文字になりました。以前は 'x' に続く 16 進表記文字全てを消費して最後の 8 ビットを使っていたため、 <code class="docutils literal notranslate"><span class="pre">\x123456</span></code> は <code class="docutils literal notranslate"><span class="pre">\x56</span></code> と同じでした。</p>
<p>例外 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> と <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> がよりフレンドリなエラーメッセージを持つようになっています。それらのテキストは <code class="docutils literal notranslate"><span class="pre">'Spam'</span> <span class="pre">instance</span> <span class="pre">has</span> <span class="pre">no</span> <span class="pre">attribute</span> <span class="pre">'eggs'</span></code> や <code class="docutils literal notranslate"><span class="pre">name</span> <span class="pre">'eggs'</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">defined</span></code> のようなものになります。以前まではエラーメッセージは存在しない属性名 <code class="docutils literal notranslate"><span class="pre">eggs</span></code> だけでしたので、この事実に便乗して書かれたコードは 2.0 では壊れます。</p>
<p>整数と長整数をもう少しだけ相互変換可能にするためのいくつかの仕事がなされました。1.5.2 で、Solaris のためにラージファイルのサポートが追加されました。これは 2 GiB より大きなファイルを読めるようにするものです。これによりファイルオブジェクトの <code class="xref py py-meth docutils literal notranslate"><span class="pre">tell()</span></code> メソッドが、整数ではなく長整数を返すようになりました。ある種のコードは 2 つのファイルオフセットの減算をしたり、結果をシーケンスの積算や文字列のスライスに使おうと試みますが、これは <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> となっていました。2.0 では長整数はシーケンスの積算やスライスに使えて、それは直感に反しない振る舞いをします。 <code class="docutils literal notranslate"><span class="pre">3L</span> <span class="pre">*</span> <span class="pre">'abc'</span></code> は 'abcabcabc' を生成しますし、 <code class="docutils literal notranslate"><span class="pre">(0,1,2,3)[2L:4L]</span></code> は (2,3) です。長整数は以前ならば普通の整数だけが許可されていた様々な文脈で使えます。例えばファイルオブジェクトの <code class="xref py py-meth docutils literal notranslate"><span class="pre">seek()</span></code> メソッドもですし、 <code class="docutils literal notranslate"><span class="pre">%</span></code> 演算子による書式化 (<code class="docutils literal notranslate"><span class="pre">%d</span></code>, <code class="docutils literal notranslate"><span class="pre">%i</span></code>, <code class="docutils literal notranslate"><span class="pre">%x</span></code>, など) もです。例えば <code class="docutils literal notranslate"><span class="pre">&quot;%d&quot;</span> <span class="pre">%</span> <span class="pre">2L**64</span></code> は <code class="docutils literal notranslate"><span class="pre">18446744073709551616</span></code> を生成するでしょう。 (---訳注: 長整数の扱いはこのあとも Python 3 までの間に <span class="target" id="index-10"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0237"><strong>PEP 237</strong></a> 「長整数と整数の一体化」などを経て少しずつ区別がなくされていきました。 ---)</p>
<p>一番微妙な長整数についての変更は、長整数を <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> してももはや末尾の 'L' 文字が付かないことです。 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> では今でも付くのにも関わらずです。 'L' は長整数を普通の整数と全く同じように印字したい多くの人々を悩ませてきました。それを各々自分なりの手段で取り除く必要があったからです。これはもう 2.0 では問題でなくなりましたが、 'L' が付くことをあてにして <code class="docutils literal notranslate"><span class="pre">str(longval)[:-1]</span></code> とするコードが今度は数値の最後の桁を失ってしまいます。</p>
<p>浮動小数点数についての <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> が <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> とは異なる精度でフォーマットするようになりました。 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> は C の <code class="xref py py-func docutils literal notranslate"><span class="pre">sprintf()</span></code> の書式文字列 <code class="docutils literal notranslate"><span class="pre">%.17g</span></code> を使い、 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> はこれまでと同じで <code class="docutils literal notranslate"><span class="pre">%.12g</span></code> を使います。その影響で、 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> では時折ある種の数では <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> よりも小数点以下をより多く出力することがあります。例えば 8.1 は正確に 2 進数で表現出来ないので、 <code class="docutils literal notranslate"><span class="pre">repr(8.1)</span></code> は <code class="docutils literal notranslate"><span class="pre">'8.0999999999999996'</span></code> となり、 str(8.1) は <code class="docutils literal notranslate"><span class="pre">'8.1'</span></code> となります。(---訳注: 精度がこれら2つで違うことについては今でも同じですが 2.7 に至るまでに浮動小数点数の扱い含め色々変更されているため、2.7 時点での <code class="docutils literal notranslate"><span class="pre">repr(8.1)</span></code> は <code class="docutils literal notranslate"><span class="pre">'8.1'</span></code> になります。まず現在の Python は単純に <code class="xref py py-func docutils literal notranslate"><span class="pre">sprintf()</span></code> を使っているのではなくもう少しだけ複雑なことをします。見かけ上は <code class="docutils literal notranslate"><span class="pre">%.16g</span></code> を使っているようにみえると思います。完全な詳細は <code class="file docutils literal notranslate"><span class="pre">Objects/floatobject.c</span></code> を参照して下さい。---)</p>
<p>コマンドラインオプション <code class="docutils literal notranslate"><span class="pre">-X</span></code> を使って標準例外をクラスではなく文字列にする機能は削除されました。標準例外は今では常にクラスです。標準例外を含んでいる <code class="xref py py-mod docutils literal notranslate"><span class="pre">exceptions</span></code> モジュールは Python からビルトインの C モジュールに変換されました。これは Barry Warsaw と Fredrik Lundh によって書かれました。</p>
</div>
<div class="section" id="extending-embedding-changes">
<h2>拡張と埋め込みについての変更<a class="headerlink" href="#extending-embedding-changes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>いくつかの変更点については覆いが被されていて、C 拡張モジュールや大きなアプリケーションでの Python インタプリタの埋め込みを書く人々からしか見えないものです。Python C API を扱う必要がないのであれば、このセクションは読み飛ばして差し支えありません。</p>
<p>Python C API のバージョン番号がインクリメントされたので、1.5.2 でコンパイルされた C 拡張は 2.0 で動作させるために再コンパイルしなければなりません。Windows では Python 1.5.x でビルドされたサードパーティ拡張を Python 2.0 でインポートすることは、Windows の DLL の仕組みのために、出来ません。その場合 Python は例外を投げ、インポートは失敗します。(---訳注: この文章、おかしなことを言っているので一応…。おそらく「Windows の一般市民は C コンパイラを持っていない」ことが著者の頭にあって、手が滑っているのだと思います。DLL の動作の仕組みが問題となるのは事実ですが、本質的には Windows 云々はあまり関係ないです。API が変わるか ABI が変わるならプラットフォームに関係なくリコンパイルは常に必要です。 ---)</p>
<p>Users of Jim Fulton's ExtensionClass module will be pleased to find out that
hooks have been added so that ExtensionClasses are now supported by
<a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> and <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>. This means you no longer have to
remember to write code such as <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">type(obj)</span> <span class="pre">==</span> <span class="pre">myExtensionClass</span></code>, but can use
the more natural <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">isinstance(obj,</span> <span class="pre">myExtensionClass)</span></code>.</p>
<p><code class="file docutils literal notranslate"><span class="pre">Python/importdl.c</span></code> ファイルが多くの異なるプラットフォームの動的ロードをサポートするのに大量の #ifdef だらけになっていたのを、Greg Stein が掃除して再編成しました。 <code class="file docutils literal notranslate"><span class="pre">importdl.c</span></code> は今ではとても小さくなり、プラットフォーム依存のコードは <code class="file docutils literal notranslate"><span class="pre">Python/dynload_*.c</span></code> ファイル群の束にそれぞれ移動しました。もう一つの掃除。include/ ディレクトリ内で色々な移植性のためのハックを施すためのたくさんの <code class="file docutils literal notranslate"><span class="pre">my*.h</span></code> ファイルたちが、単一の <code class="file docutils literal notranslate"><span class="pre">Include/pyport.h</span></code> にマージされました。</p>
<p>Vladimir Marangozov の手による、待ち望まれた malloc の再編成が完了しました。これは Python インタプリタが C 標準の <code class="xref py py-func docutils literal notranslate"><span class="pre">malloc()</span></code> の代わりにカスタムアロケータを使うことを容易にするものです。ドキュメントについては <code class="file docutils literal notranslate"><span class="pre">Include/pymem.h</span></code> と <code class="file docutils literal notranslate"><span class="pre">Include/objimpl.h</span></code> のコメントを読んで下さい。インターフェイスが決着するまでの間の長い長い議論については python.org の 'patches' と 'python-dev' リストのウェブアーカイブをみてください。(---訳注: この件についての続きの話が  What's New in Python 2.3 に Pymalloc として少しわかりやすく記述されています。---)</p>
<p>MacOS の GUSI 開発環境の最近のバージョンは POSIX スレッドをサポートしています。ですので Python の POSIX スレッディングのサポートは今では Macintosh で動作します。ユーザ空間での GNU <code class="docutils literal notranslate"><span class="pre">pth</span></code> ライブラリを使ったスレッディングサポートも寄稿されました。</p>
<p>Windows でのスレッディングサポートも拡張されました。Windows は、競合があるケースでのみカーネルオブジェクトを使うスレッドロックをサポートしています。競合がない普通のケースではそれらはより単純な関数を使い、これは段違いに高速です。NT での Python 1.5.2 版でスレッド化すると、非スレッド版の 2 倍遅くなりますが、2.0 に変えるとその差はたった 10% です。これらの改善は Yakov Markovitch の貢献によるものです。</p>
<p>Python 2.0 のソースが ANSI C プロトタイプだけを使うようになったので、Python のコンパイルには ANSI C コンパイラが必須になりました。K&amp;R C しかサポートしないコンパイラではもうコンパイル出来ません。</p>
<p>以前は、Python 仮想マシンはそのバイトコードに 16 ビットの数値を使って、ソースファイルのサイズを制限していました。特にこれは、Python ソースのリテラルのリストと辞書の最大サイズに影響していました。時々 Python コードを生成する人たちが、この制限に遭遇していました。Charles G. Waldman によるパッチで、この制限が <code class="docutils literal notranslate"><span class="pre">2^16</span></code> から <code class="docutils literal notranslate"><span class="pre">2^{32}</span></code> に引き上げられました。</p>
<p>モジュール初期化時に、モジュールの辞書に定数を追加することを意図した新しい 3 つの関数が追加されました: <code class="xref py py-func docutils literal notranslate"><span class="pre">PyModule_AddObject()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">PyModule_AddIntConstant()</span></code>, and <code class="xref py py-func docutils literal notranslate"><span class="pre">PyModule_AddStringConstant()</span></code> です。これら関数のそれぞれは、モジュールオブジェクトと、追加されるべき名前を含む null 終端の C 文字列と、その名前に代入される値の、3 つの引数を取ります。3 つ目の引数は Python オブジェクトか、C の long か、C 文字列です。</p>
<p>Unix スタイルのシグナルハンドラへのラッパー関数が追加されました。 <code class="xref py py-func docutils literal notranslate"><span class="pre">PyOS_getsig()</span></code> でシグナルハンドラを取得し、 <code class="xref py py-func docutils literal notranslate"><span class="pre">PyOS_setsig()</span></code> で新しいハンドラをセットします。</p>
</div>
<div class="section" id="distutils-making-modules-easy-to-install">
<h2>Distutils: モジュールの簡単インストール<a class="headerlink" href="#distutils-making-modules-easy-to-install" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 2.0 以前は、モジュールのインストールは退屈な作業でした -- Python がどこにインストールされているかや拡張モジュールのコンパイルに必要なオプションを自動的に知る方法はありませんでした。ソフトウェアの作者は Makefile と設定ファイル群の編集という大変な労力を要する儀式を通過しなければならないのに、それは実際には Unix だけのためであって Windows と MacOS のサポートを置き去りにするものでした。Python ユーザは全く異なったインストール命令に直面していました。それは拡張パッケージごとに異なり、Python インストールをある種つまらない作業としていました。</p>
<p>配布のためのユーティリティについての SIG (---訳注: Python Special Interest Groups ---) が Greg Ward に主導されて、パッケージのインストールを格段に簡単にする Distutils を作りました。これにより <a class="reference internal" href="../library/distutils.html#module-distutils" title="distutils: Support for building and installing Python modules into an existing Python installation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils</span></code></a> パッケージが、Python 標準ライブラリの新しい一部として形成されました。最良の場合にはソースから Python モジュールをインストールするのにはいつでも同じステップだけが必要です: まずは単に tarball あるいは zip アーカイブを展開し、その後 &quot;<code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">install</span></code>&quot; を実行します。プラットフォームは自動的に検出されて、コンパイラが認識され、C 拡張モジュールがコンパイルされ、配布物が適切なディレクトリにインストールされます。オプショナルなコマンドライン引数がインストール過程についてより細かな制御を提供します。 distutils パッケージはデフォルトを上書きして別のことを出来る多くのポイントを持っています -- インストールとビルドを別々に行ったり、ビルドやインストールをデフォルトでないディレクトリに行ったり、などです。</p>
<p>Distutils を使うには <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> スクリプトを書く必要があります。単純なケースでは、ソフトウェアが .py ファイルだけを含む場合、最小限の <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> は数行足らずで書けます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">distutils.core</span> <span class="kn">import</span> <span class="n">setup</span>
<span class="n">setup</span> <span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="n">version</span> <span class="o">=</span> <span class="s2">&quot;1.0&quot;</span><span class="p">,</span>
       <span class="n">py_modules</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;module1&quot;</span><span class="p">,</span> <span class="s2">&quot;module2&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p><code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> ファイルは、ソフトウェアが少しのパッケージで構成される場合はこれより大きく複雑になることはありません:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">distutils.core</span> <span class="kn">import</span> <span class="n">setup</span>
<span class="n">setup</span> <span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="n">version</span> <span class="o">=</span> <span class="s2">&quot;1.0&quot;</span><span class="p">,</span>
       <span class="n">packages</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;package&quot;</span><span class="p">,</span> <span class="s2">&quot;package.subpackage&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>C 拡張が最も複雑なケースになりえます。以下は PyXML パッケージからもってきた例です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">distutils.core</span> <span class="kn">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">Extension</span>

<span class="n">expat_extension</span> <span class="o">=</span> <span class="n">Extension</span><span class="p">(</span><span class="s1">&#39;xml.parsers.pyexpat&#39;</span><span class="p">,</span>
     <span class="n">define_macros</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;XML_NS&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)],</span>
     <span class="n">include_dirs</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;extensions/expat/xmltok&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;extensions/expat/xmlparse&#39;</span> <span class="p">],</span>
     <span class="n">sources</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;extensions/pyexpat.c&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;extensions/expat/xmltok/xmltok.c&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;extensions/expat/xmltok/xmlrole.c&#39;</span><span class="p">,</span> <span class="p">]</span>
       <span class="p">)</span>
<span class="n">setup</span> <span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;PyXML&quot;</span><span class="p">,</span> <span class="n">version</span> <span class="o">=</span> <span class="s2">&quot;0.5.4&quot;</span><span class="p">,</span>
       <span class="n">ext_modules</span> <span class="o">=</span><span class="p">[</span> <span class="n">expat_extension</span> <span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>Distutils ではソース配布物、バイナリ配布物の作成の面倒もみてくれます。 &quot;sdist&quot; コマンドは &quot;<code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">sdist</span></code>&quot; を実行することで起動し、これは <code class="file docutils literal notranslate"><span class="pre">foo-1.0.tar.gz</span></code> のようなソース配布物を作ります。新しいコマンドを作るのは難しくありません。コマンド &quot;bdist_rpm&quot; と &quot;bdist_wininst&quot; が既に寄稿されていて、各々 RPM 配布物の作成、Windows インストーラの作成を行います。Debian パッケージや Solaris の <code class="file docutils literal notranslate"><span class="pre">.pkg</span></code> のようなほかの配布フォーマットを作成するコマンドについての開発ステージは様々です。</p>
<p>これら全ては、 Python ドキュメントの基本的なセットとして追加されたマニュアル <em>Python モジュールの配布</em> にドキュメントされています。</p>
</div>
<div class="section" id="xml-modules">
<h2>XML モジュール<a class="headerlink" href="#xml-modules" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 1.5.2 では、 Sjoerd Mullender の手による単純な XML パーサが、 <code class="xref py py-mod docutils literal notranslate"><span class="pre">xmllib</span></code> モジュールの形で追加されました。1.5.2 でのリリース以降で、2 つの異なった XML 処理のインターフェイスが一般的になりました。SAX2 (「Simple API for XML」のバージョン 2) はいくらか <code class="xref py py-mod docutils literal notranslate"><span class="pre">xmllib</span></code> に似た、イベントドリブンのインターフェイスを提供し、DOM (「Document Object Model］) は XML ドキュメントを、横断したり修正できるノードのツリーに変換する、木構造ベースのインターフェイスを提供します。Python 2.0 では SAX2 インターフェイスと必要最小限の DOM インターフェイスが、 <a class="reference internal" href="../library/xml.html#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml</span></code></a> パッケージの一部として追加されました。ここではそれら新規インターフェイスについての簡単な概要について書きます。完全な詳細については Python ドキュメントかソースコードを参照してください。Python XML SIG ではドキュメントの改善についても作業中です。</p>
<div class="section" id="sax2-support">
<h3>SAX2 サポート<a class="headerlink" href="#sax2-support" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>SAX は、XML のパースのイベントドリブンなインターフェイスを定義しています。SAX を利用するには、SAX ハンドラクラスを書く必要があります。ハンドラクラスは SAX により提供される様々なクラスから派生し、XML パーサから呼び出される様々なメソッドをオーバライドします。例えば、メソッド <code class="xref py py-meth docutils literal notranslate"><span class="pre">startElement()</span></code> と <code class="xref py py-meth docutils literal notranslate"><span class="pre">endElement()</span></code> はパーサによって開始・終了タグが検出されるたびに呼び出され、 <code class="xref py py-meth docutils literal notranslate"><span class="pre">characters()</span></code> メソッドは文字データの塊 (chunk) ごとに呼び出される、といった具合です。</p>
<p>イベントドリブンのアプローチはドキュメント全体をいっときにメモリに持たなくて良い点で有利であり、ドキュメントが本当に巨大であるものを処理する際にはこれは重要です。ですが SAX ハンドラクラスを記述することは、ドキュメント構造を変更しようとする場合にはある種入り組んだものとなって、とても複雑になりえます。</p>
<p>以下の小さな実例プログラムでは、全ての開始・終了タグでメッセージを印字するハンドラを定義して、ファイル <code class="file docutils literal notranslate"><span class="pre">hamlet.xml</span></code> をそのハンドラを使ってパースしています:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xml</span> <span class="kn">import</span> <span class="n">sax</span>

<span class="k">class</span> <span class="nc">SimpleHandler</span><span class="p">(</span><span class="n">sax</span><span class="o">.</span><span class="n">ContentHandler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">startElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s1">&#39;Start of element:&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">attrs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">endElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s1">&#39;End of element:&#39;</span><span class="p">,</span> <span class="n">name</span>

<span class="c1"># Create a parser object</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">sax</span><span class="o">.</span><span class="n">make_parser</span><span class="p">()</span>

<span class="c1"># Tell it what handler to use</span>
<span class="n">handler</span> <span class="o">=</span> <span class="n">SimpleHandler</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">setContentHandler</span><span class="p">(</span> <span class="n">handler</span> <span class="p">)</span>

<span class="c1"># Parse a file!</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span> <span class="s1">&#39;hamlet.xml&#39;</span> <span class="p">)</span>
</pre></div>
</div>
<p>もっと詳しい情報については Python ドキュメントを調べるか、 <a class="reference external" href="http://pyxml.sourceforge.net/topics/howto/xml-howto.html">http://pyxml.sourceforge.net/topics/howto/xml-howto.html</a> にある XML HOWTO をご覧ください。</p>
</div>
<div class="section" id="dom-support">
<h3>DOM サポート<a class="headerlink" href="#dom-support" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Document Object Model は XML ドキュメントの木構造ベースの表現です。トップレベルの <code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code> インスタンスは木の根で、これはトップレベルの <code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code> インスタンス一つを子に持ちます。 <code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code> は、文字データやらほかのサブ要素を子ノードとして持ち、それら子ノードがさらに子を持つ、といった具合です。DOM を使って、好きなように結果木を横断し、要素や属性値にアクセスし、ノードを追加したり削除したりし、そして木を XML に戻せます。</p>
<p>DOM は XML ドキュメントを修正するのに有用です。というのも DOM ツリーは作成出来、新規ノードを追加したりサブツリーを再編成したりすることで修正出来、出力として新たな XML ドキュメントを生成出来るからです。DOM ツリーを手動で構築して XML に変換することも出来ます。これにより単純に <code class="docutils literal notranslate"><span class="pre">&lt;tag1&gt;</span></code>...<code class="docutils literal notranslate"><span class="pre">&lt;/tag1&gt;</span></code> をファイルに書くよりも柔軟性の高い方法で XML 出力を生成出来ます。</p>
<p>Python の DOM 実装は <a class="reference internal" href="../library/xml.dom.minidom.html#module-xml.dom.minidom" title="xml.dom.minidom: Minimal Document Object Model (DOM) implementation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.dom.minidom</span></code></a> モジュールにあります。これは XML 名前空間サポートを持つレベル 1 DOM の軽量実装です。コンビニエンス関数 <code class="xref py py-func docutils literal notranslate"><span class="pre">parse()</span></code> と <code class="xref py py-func docutils literal notranslate"><span class="pre">parseString()</span></code> が DOM ツリーの生成のために提供されています:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xml.dom</span> <span class="kn">import</span> <span class="n">minidom</span>
<span class="n">doc</span> <span class="o">=</span> <span class="n">minidom</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;hamlet.xml&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">doc</span></code> が <code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code> のインスタンスです。DOM の全てのクラス、例えば <code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code> や <code class="xref py py-class docutils literal notranslate"><span class="pre">Text</span></code> などや、 <code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code> も、基底クラス <code class="xref py py-class docutils literal notranslate"><span class="pre">Node</span></code> のサブクラスです。ですので DOM ツリー内の全てのノードはある共通のメソッドを持ちます。例えば <code class="xref py py-meth docutils literal notranslate"><span class="pre">toxml()</span></code> はそのノードとその子の XML 表現を含む文字列を返します。それぞれのクラスにはそれ自身の特別なメソッドも持ちます。例えば <code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code> と <code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code> のインスタンスは指定したタグ名で全ての子要素を検索するメソッドを持っています。先ほどの例の 2 行からの続きです:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">perslist</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">getElementsByTagName</span><span class="p">(</span> <span class="s1">&#39;PERSONA&#39;</span> <span class="p">)</span>
<span class="nb">print</span> <span class="n">perslist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">toxml</span><span class="p">()</span>
<span class="nb">print</span> <span class="n">perslist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">toxml</span><span class="p">()</span>
</pre></div>
</div>
<p><em>Hamlet</em> XML ファイルに対して上の例は以下のような出力をします:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">PERSONA</span><span class="o">&gt;</span><span class="n">CLAUDIUS</span><span class="p">,</span> <span class="n">king</span> <span class="n">of</span> <span class="n">Denmark</span><span class="o">.</span> <span class="o">&lt;/</span><span class="n">PERSONA</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">PERSONA</span><span class="o">&gt;</span><span class="n">HAMLET</span><span class="p">,</span> <span class="n">son</span> <span class="n">to</span> <span class="n">the</span> <span class="n">late</span><span class="p">,</span> <span class="ow">and</span> <span class="n">nephew</span> <span class="n">to</span> <span class="n">the</span> <span class="n">present</span> <span class="n">king</span><span class="o">.&lt;/</span><span class="n">PERSONA</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>ドキュメントのルートエレメントは <code class="docutils literal notranslate"><span class="pre">doc.documentElement</span></code> として取得出来、その子は簡単に、ノードを削除したり追加したりすることで修正出来ます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">root</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">documentElement</span>

<span class="c1"># Remove the first child</span>
<span class="n">root</span><span class="o">.</span><span class="n">removeChild</span><span class="p">(</span> <span class="n">root</span><span class="o">.</span><span class="n">childNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>

<span class="c1"># Move the new first child to the end</span>
<span class="n">root</span><span class="o">.</span><span class="n">appendChild</span><span class="p">(</span> <span class="n">root</span><span class="o">.</span><span class="n">childNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>

<span class="c1"># Insert the new first child (originally,</span>
<span class="c1"># the third child) before the 20th child.</span>
<span class="n">root</span><span class="o">.</span><span class="n">insertBefore</span><span class="p">(</span> <span class="n">root</span><span class="o">.</span><span class="n">childNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">root</span><span class="o">.</span><span class="n">childNodes</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>繰り返しになりますが、ほかの異なった <code class="xref py py-class docutils literal notranslate"><span class="pre">Node</span></code> クラスやらそれらの色々なメソッドやらの完全なリストについては、Python ドキュメントを参照して下さい。</p>
</div>
<div class="section" id="relationship-to-pyxml">
<h3>PyXML との関係<a class="headerlink" href="#relationship-to-pyxml" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The XML Special Interest Group has been working on XML-related Python code for a
while.  Its code distribution, called PyXML, is available from the SIG's Web
pages at <a class="reference external" href="https://www.python.org/community/sigs/current/xml-sig">https://www.python.org/community/sigs/current/xml-sig</a>. The PyXML distribution also used
the package name <code class="docutils literal notranslate"><span class="pre">xml</span></code>.  If you've written programs that used PyXML, you're
probably wondering about its compatibility with the 2.0 <a class="reference internal" href="../library/xml.html#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml</span></code></a> package.</p>
<p>The answer is that Python 2.0's <a class="reference internal" href="../library/xml.html#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml</span></code></a> package isn't compatible with PyXML,
but can be made compatible by installing a recent version PyXML.  Many
applications can get by with the XML support that is included with Python 2.0,
but more complicated applications will require that the full PyXML package will
be installed.  When installed, PyXML versions 0.6.0 or greater will replace the
<a class="reference internal" href="../library/xml.html#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml</span></code></a> package shipped with Python, and will be a strict superset of the
standard package, adding a bunch of additional features.  Some of the additional
features in PyXML include:</p>
<ul class="simple">
<li>4DOM, a full DOM implementation from FourThought, Inc.</li>
<li>The xmlproc validating parser, written by Lars Marius Garshol.</li>
<li>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">sgmlop</span></code> parser accelerator module, written by Fredrik Lundh.</li>
</ul>
</div>
</div>
<div class="section" id="module-changes">
<h2>更新されたモジュール<a class="headerlink" href="#module-changes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 標準ライブラリに、広範囲に渡ってたくさんの改善とバグフィクスが行われました。この影響を受けたモジュールとしては <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readline</span></code></a>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">ConfigParser</span></code>, <a class="reference internal" href="../library/cgi.html#module-cgi" title="cgi: Helpers for running Python scripts via the Common Gateway Interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cgi</span></code></a>, <a class="reference internal" href="../library/calendar.html#module-calendar" title="calendar: Functions for working with calendars, including some emulation of the Unix cal program."><code class="xref py py-mod docutils literal notranslate"><span class="pre">calendar</span></code></a>, <a class="reference internal" href="../library/posix.html#module-posix" title="posix: The most common POSIX system calls (normally used via module os). (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">posix</span></code></a>, <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readline</span></code></a>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">xmllib</span></code>, <a class="reference internal" href="../library/aifc.html#module-aifc" title="aifc: Read and write audio files in AIFF or AIFC format."><code class="xref py py-mod docutils literal notranslate"><span class="pre">aifc</span></code></a>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">chunk,</span> <span class="pre">wave</span></code>, <a class="reference internal" href="../library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a>, <a class="reference internal" href="../library/shelve.html#module-shelve" title="shelve: Python object persistence."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shelve</span></code></a>, <a class="reference internal" href="../library/nntplib.html#module-nntplib" title="nntplib: NNTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">nntplib</span></code></a> があります。パッチごとにどのような改造が行われたのかの詳細は CVS ログを調べてください。</p>
<p>Brian Gallew が <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> モジュールについての OpenSSL サポートを寄稿しました。OpenSSL はセキュアソケットレイヤーの実装の一つで、ソケットを通じて送信されるデータの暗号化を行います。Python コンパイル時に <code class="file docutils literal notranslate"><span class="pre">Modules/Setup</span></code> を SSL サポートを含むように編集することで <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> モジュールに追加機能を有効に出来ます: <code class="docutils literal notranslate"><span class="pre">socket.ssl(socket,</span> <span class="pre">keyfile,</span> <span class="pre">certfile)</span></code> はソケットオブジェクトを取り、SSL ソケットを返します。モジュール <code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code> と <a class="reference internal" href="../library/urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> も <code class="docutils literal notranslate"><span class="pre">https://</span></code> をサポートするように変更されましたが、SSL 経由の FTP と SMTP は実装されていません。 (---訳注: Python 2.1 (<span class="target" id="index-11"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0229"><strong>PEP 229</strong></a>) 以降から <code class="file docutils literal notranslate"><span class="pre">Modules/Setup</span></code> を編集する必要はなくなっています。ソケットを SSL でラップするインターフェイスは今では(特に 2.7 のメンテナンスリリースで)もっと進化しています。ドキュメントを参照して下さい。SMTP over SSL は Python 2.2 でサポートされました。FTP については Python 2.7 で FTP_TLS がサポートされました。 ---)</p>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code> モジュールが、HTTP/1.1 をサポートするように Greg Stein により書き直されました。1.5 バージョンでの <code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code> との後方互換性は提供されていますが、パイプライン化のような HTTP/1.1 機能を使うには、これまでとは違ったインターフェイス集合を使ってコードを書き直す必要があります。</p>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">Tkinter</span></code> モジュールが Tcl/Tk バージョン 8.1, 8.2, 8.3 をサポートするようになり、また、古い 7.x バージョンのサポートは取りやめられました。Tkinter モジュールが Tk ウィジットでの Unicode 文字列表示をサポートするようになりました。また、Fredrik Lundh は <code class="docutils literal notranslate"><span class="pre">create_line</span></code> や <code class="docutils literal notranslate"><span class="pre">create_polygon</span></code> のような操作を大きく高速化する最適化を寄稿しました。これは特にたくさんの座標系を使用している場合に効きます。</p>
<p><a class="reference internal" href="../library/curses.html#module-curses" title="curses: An interface to the curses library, providing portable terminal handling. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">curses</span></code></a> モジュールが、Oliver Andrich による拡張版をもとに大規模に拡張され、ncurses と SYSV curses からの多くの追加機能、例えば色付きの表示、別の文字集合サポート、パッド、マウスサポートなどをサポートするようになりました。このことは、モジュールが BSD curses だけしか持っていない OS とは互換性が無いことを意味しますが、現在メンテナンスされている OS でそういう類のものは無さそうです。</p>
<p>2.0 の Unicode サポートについて前述したように、 <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> モジュールで提供される正規表現の根底となる実装が変更されました。SRE は新しい正規表現エンジンで、Fredrik Lundh によって書かれ、部分的に Hewlett Packard 社により寄贈されました。これは 8 ビット文字列と Unicode 文字列両方に合致するようサポートされています。</p>
</div>
<div class="section" id="new-modules">
<h2>新しいモジュール<a class="headerlink" href="#new-modules" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>数多くのモジュールが新しく追加されました。ここではそれらを短い説明とともに列挙するだけにします。特定のモジュールの詳細は 2.0 のドキュメントを調べてください。</p>
<ul class="simple">
<li><a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a>: Python インタプリタが終了する前に呼び出す関数を登録します。これまで <code class="docutils literal notranslate"><span class="pre">sys.exitfunc</span></code> に直接セットしてきたコードは  <a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a> モジュールを代わりに用いるように修正してください。 <a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a> をインポートし、 <a class="reference internal" href="../library/atexit.html#atexit.register" title="atexit.register"><code class="xref py py-func docutils literal notranslate"><span class="pre">atexit.register()</span></code></a> で終了時に呼び出す関数を登録します。(Contributed by Skip Montanaro.)</li>
<li><a class="reference internal" href="../library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings</span></code>, <a class="reference internal" href="../library/unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unicodedata</span></code></a>: 新しい Unicode サポートの一環で追加されました。</li>
<li><a class="reference internal" href="../library/filecmp.html#module-filecmp" title="filecmp: Compare files efficiently."><code class="xref py py-mod docutils literal notranslate"><span class="pre">filecmp</span></code></a>: <code class="xref py py-mod docutils literal notranslate"><span class="pre">cmp</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">cmpcache</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">dircmp</span></code> に取って代わるモジュールです。このためそれらは非推奨となりました。(Contributed by Gordon MacMillan and Moshe Zadka.)</li>
<li><a class="reference internal" href="../library/gettext.html#module-gettext" title="gettext: Multilingual internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gettext</span></code></a>: このモジュールは Python プログラムに、GNU gettext メッセージカタログライブラリへのインターフェイスを提供することで国際化 (I18N=internationalization) と地域化 (L10N=localization) サポートをもたらします。 (Integrated by Barry Warsaw, from separate contributions by Martin von Löwis, Peter Funk, and James Henstridge.)</li>
<li><code class="xref py py-mod docutils literal notranslate"><span class="pre">linuxaudiodev</span></code>: Linux の <code class="file docutils literal notranslate"><span class="pre">/dev/audio</span></code> デバイスサポートであり、既に存在している <code class="xref py py-mod docutils literal notranslate"><span class="pre">sunaudiodev</span></code> モジュールの双子です。 (Contributed by Peter Bosch, with fixes by Jeremy Hylton.)</li>
<li><a class="reference internal" href="../library/mmap.html#module-mmap" title="mmap: Interface to memory-mapped files for Unix and Windows."><code class="xref py py-mod docutils literal notranslate"><span class="pre">mmap</span></code></a>: Windows、Unix 両方でのメモリマップドファイルへのインターフェイスです。ファイル内容をメモリに直接マッピング出来、それは <a class="reference internal" href="../glossary.html#term-mutable"><span class="xref std std-term">mutable</span></a> な文字列であるかのように振る舞い、これにより読み書き出来ます。それらは例えば <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> モジュールのような普通は文字列を期待するような関数にさえも渡せます。(Contributed by Sam Rushing, with some extensions by A.M. Kuchling.)</li>
<li><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyexpat</span></code>: Expat XML パーサへのインターフェイスです。 (Contributed by Paul Prescod.)</li>
<li><code class="xref py py-mod docutils literal notranslate"><span class="pre">robotparser</span></code>: ウェブサイトの特定の領域を礼儀正しく避けるウェブスパイダを書くのに使われる <code class="file docutils literal notranslate"><span class="pre">robots.txt</span></code> を解析します。パーサは <code class="file docutils literal notranslate"><span class="pre">robots.txt</span></code> ファイルの中身を受け取ってそこからルールのセットを構築して、その上で指定した URL がフェッチ可能であるかどうかについての質問の答えを返します。(Contributed by Skip Montanaro.)</li>
<li><a class="reference internal" href="../library/tabnanny.html#module-tabnanny" title="tabnanny: Tool for detecting white space related problems in Python source files in a directory tree."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tabnanny</span></code></a>: Python ソースコードが曖昧なインデントになっていないかをチェックするモジュール/スクリプトです。 (Contributed by Tim Peters.)</li>
<li><code class="xref py py-mod docutils literal notranslate"><span class="pre">UserString</span></code>: 文字列のように振る舞う派生オブジェクトを作るのに有用な基底クラスです。</li>
<li><a class="reference internal" href="../library/webbrowser.html#module-webbrowser" title="webbrowser: Easy-to-use controller for Web browsers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">webbrowser</span></code></a>: 指定した URL で、プラットフォームに依存しない方法でウェブブラウザを起動するモジュールです。個々のプラットフォームにおいて様々なブラウザが特定の順序で試されます。ユーザはどのブラウザを起動するかを環境変数 <em>BROWSER</em> をセットすることで変更出来ます。(元々は Eric S. Raymond による <a class="reference internal" href="../library/urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> への、同じ機能追加をするパッチに触発されましたが、最終的なモジュールは Fred Drake が元々 <code class="file docutils literal notranslate"><span class="pre">Tools/idle/BrowserControl.py</span></code> として実装したものに由来し、Fred が標準ライブラリに適合させました。)</li>
<li><code class="xref py py-mod docutils literal notranslate"><span class="pre">_winreg</span></code>: Windows のレジストリへのインターフェイスです。 <code class="xref py py-mod docutils literal notranslate"><span class="pre">_winreg</span></code> は 1995 年より PythonWin の一部であった関数群の改作で、これが Unicode サポートの拡張をしてコア配布物に追加されました。 <code class="xref py py-mod docutils literal notranslate"><span class="pre">_winreg</span></code> は Bill Tutt と Mark Hammond により書かれました。</li>
<li><a class="reference internal" href="../library/zipfile.html#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipfile</span></code></a>: ZIP 形式アーカイブの読み書きのためのモジュールです。DOS/Windows での <strong class="program">PKZIP</strong> や Unix での <strong class="program">zip</strong> により生成されるアーカイブで、 <strong class="program">gzip</strong> 形式とは混同しないで下さい (こちらは <a class="reference internal" href="../library/gzip.html#module-gzip" title="gzip: Interfaces for gzip compression and decompression using file objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gzip</span></code></a> モジュールによってサポートされています)。(Contributed by James C. Ahlstrom.)</li>
<li><code class="xref py py-mod docutils literal notranslate"><span class="pre">imputil</span></code>: A module that provides a simpler way for writing customized
import hooks, in comparison to the existing <code class="xref py py-mod docutils literal notranslate"><span class="pre">ihooks</span></code> module.  (Implemented
by Greg Stein, with much discussion on python-dev along the way.)</li>
</ul>
</div>
<div class="section" id="idle-improvements">
<h2>IDLE の改善<a class="headerlink" href="#idle-improvements" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>IDLE は公式の Python のクロスプラットフォームな IDE で、 Tkinter を使って書かれています。Python 2.0 では IDLE 0.6 を含めました。これは多くの新機能追加と改善がなされています。以下はその一部です:</p>
<ul class="simple">
<li>UI の、特にシンタックスハイライトと自動インデントの領域において、改善と最適化がなされました。</li>
<li>クラスブラウザで、例えばモジュール内のトップレベル関数のような、より多くの情報をみることが出来るようになりました。</li>
<li>タブ幅をユーザ制御出来るようになりました。既存の Python ファイルを操作する際には、IDLE は自動的にインデントの慣習を検知してそれに合わせます。</li>
<li>色々なプラットフォームでブラウザの呼び出しがサポートされています。これを使って、ブラウザで Python ドキュメントを開きます。</li>
<li>IDLE がコマンドラインを持つようになりました。これは普通の Python インタプリタに大きく似せてあります。</li>
<li>色々な場所でコンテキストヘルプが出るようになっています。</li>
<li>IDLE は今ではパッケージとしてインストール出来ます。</li>
<li>エディタウィンドウ内では、下部に行/桁を表示するようになっています。</li>
<li>新たな 3 つのキーストロークコマンド: モジュールのチェック (<kbd class="kbd docutils literal notranslate">Alt-F5</kbd>)、モジュールのインポート (<kbd class="kbd docutils literal notranslate">F5</kbd>)、スクリプト実行 (<kbd class="kbd docutils literal notranslate">Ctrl-F5</kbd>).</li>
</ul>
</div>
<div class="section" id="deleted-and-deprecated-modules">
<h2>削除されたモジュール、非推奨となったモジュール<a class="headerlink" href="#deleted-and-deprecated-modules" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>少しのモジュールはそれが廃れたり、同じことをするもっと良い手段があるために削除されました。 <code class="xref py py-mod docutils literal notranslate"><span class="pre">stdwin</span></code> はなくなりました。これはプラットフォーム非依存のウィンドウツールキットで、今ではもう開発されていません。</p>
<p>数多くのモジュールが <code class="file docutils literal notranslate"><span class="pre">lib-old</span></code> サブディレクトリに移動されました:  <code class="xref py py-mod docutils literal notranslate"><span class="pre">cmp</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">cmpcache</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">dircmp</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">dump</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">find</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">grep</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">packmail</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">poly</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">util</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">whatsound</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">zmod</span></code> 。 <code class="file docutils literal notranslate"><span class="pre">lib-old</span></code> に移動されたモジュールに依存するコードを持っているのであれば <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> にこれを単に追加出来ますが、それらモジュールを使っているあらゆるコードは更新した方が良いです。(---訳注: <code class="file docutils literal notranslate"><span class="pre">lib-old</span></code> は Python 2.5 で完全に削除されました。---)</p>
</div>
<div class="section" id="acknowledgements">
<h2>謝辞<a class="headerlink" href="#acknowledgements" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>著者は提案の申し出や修正、様々なこの記事の草稿の助けをしてくれた以下の人々に感謝します:  David Bolen, Mark Hammond, Gregg Hauser, Jeremy Hylton, Fredrik Lundh, Detlef Lannert, Aahz Maruch, Skip Montanaro, Vladimir Marangozov, Tobias Polzin, Guido van Rossum, Neil Schemenauer, and Russ Schmidt.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">What's New in Python 2.0</a><ul>
<li><a class="reference internal" href="#introduction">はじめに</a></li>
<li><a class="reference internal" href="#what-about-python-1-6">Python 1.6 はいかがっすか?</a></li>
<li><a class="reference internal" href="#new-development-process">新しい開発プロセス</a></li>
<li><a class="reference internal" href="#unicode">Unicode 文字列型</a></li>
<li><a class="reference internal" href="#list-comprehensions">リストの内包表記</a></li>
<li><a class="reference internal" href="#augmented-assignment">累算代入 (Augmented Assignment)</a></li>
<li><a class="reference internal" href="#string-methods">文字列メソッド</a></li>
<li><a class="reference internal" href="#garbage-collection-of-cycles">循環参照のガベージコレクション</a></li>
<li><a class="reference internal" href="#other-core-changes">その他の言語コアの変更</a><ul>
<li><a class="reference internal" href="#minor-language-changes">言語のマイナー変更</a></li>
<li><a class="reference internal" href="#changes-to-built-in-functions">ビルトイン関数の変更</a></li>
</ul>
</li>
<li><a class="reference internal" href="#porting-to-2-0">Python 2.0 への移植</a></li>
<li><a class="reference internal" href="#extending-embedding-changes">拡張と埋め込みについての変更</a></li>
<li><a class="reference internal" href="#distutils-making-modules-easy-to-install">Distutils: モジュールの簡単インストール</a></li>
<li><a class="reference internal" href="#xml-modules">XML モジュール</a><ul>
<li><a class="reference internal" href="#sax2-support">SAX2 サポート</a></li>
<li><a class="reference internal" href="#dom-support">DOM サポート</a></li>
<li><a class="reference internal" href="#relationship-to-pyxml">PyXML との関係</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-changes">更新されたモジュール</a></li>
<li><a class="reference internal" href="#new-modules">新しいモジュール</a></li>
<li><a class="reference internal" href="#idle-improvements">IDLE の改善</a></li>
<li><a class="reference internal" href="#deleted-and-deprecated-modules">削除されたモジュール、非推奨となったモジュール</a></li>
<li><a class="reference internal" href="#acknowledgements">謝辞</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="2.1.html"
                        title="前の章へ">What's New in Python 2.1</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="changelog.html"
                        title="次の章へ">変更履歴</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.8/Doc/whatsnew/2.0.rst"
            rel="nofollow">ソースコードを表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="changelog.html" title="変更履歴"
             >次へ</a> |</li>
        <li class="right" >
          <a href="2.1.html" title="What&#39;s New in Python 2.1"
             >前へ</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.3 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >What's New in Python</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" type="text" name="q" />
          <input type="submit" value="検索" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">著作権</a> 2001-2020, Python Software Foundation.
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最終更新: 5月 16, 2020
    <a href="https://docs.python.org/3/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>

  </body>
</html>